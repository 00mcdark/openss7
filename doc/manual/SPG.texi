% -*- texinfo -*- vim: ft=texinfo
% vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
% =========================================================================
%
% @(#) $Id$
%
% =========================================================================
%
% Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
% Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
% Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.3 or
% any later version published by the Free Software Foundation; with no
% Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
% copy of the license is included in the section entitled "GNU Free
% Documentation License".
%
% Permission to use, copy and distribute this documentation without
% modification, for any purpose and without fee or royalty is hereby
% granted, provided that both the above copyright notice and this
% permission notice appears in all copies and that the name of OpenSS7
% Corporation not be used in advertising or publicity pertaining to
% distribution of this documentation or its contents without specific,
% written prior permission.  OpenSS7 Corporation makes no representation
% about the suitability of this documentation for any purpose.  It is
% provided "as is" without express or implied warranty.
% 
% Permission is granted to process this file through Tex and print the
% results, provided the printed document carries copying permission
% notice identical to this one except for the removal of this paragraph
% (this paragraph not being relevant to the printed manual).
% 
% OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
% DOCUMENTATION INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE
% CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE
% IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY
% PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN NO EVENT SHALL
% OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
% CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
% USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
% THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS
% THEREOF.
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date$ by $Author$
%
% =========================================================================

\input texinfo
@setfilename SPG.info
@include ../../scripts/texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide
@settitle @value{MANUAL_TITLE}

@dircategory STREAMS
@direntry
* SPG: (SPG).                   STREAMS Programmer's Guide
@end direntry

@include ../../scripts/texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}.

Copyright @copyright{} 2008-2009  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2001  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*

All Rights Reserved.

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled @ref{GNU Free Documentation License}.

Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@ignore
Permission is granted to process this file through Tex and print the results, provided the printed
document carries copying permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT
THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE IMPLEMENTATION OF SUCH
CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN
NO EVENT SHALL OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.
@end ifinfo

@include ../../scripts/texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@subtitle Updated @value{PACKAGE_PDATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@sp 2
@subtitle Copyright @copyright{} 2008-2009  Monavacon Limited
@subtitle All Rights Reserved.
@sp 4
@quotation
@chapheading Abstract:
This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.
@end quotation
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll

@chapheading Published by:

@sp 1

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Copyright @copyright{} 2008-2009  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*

@noindent
All Rights Reserved.

@sp 1

@noindent
Unauthorized distribution or duplication is prohibited.

@sp 1

@noindent
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled @ref{GNU Free Documentation License}.

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@chapheading Notice:

@noindent
@strong{OpenSS7 Corporation disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights.  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.}

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@include texi/macros.texi
@include texi/versions.texi
@include texi/prims.texi

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@heading About This Manual
This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of
@cite{The @value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version
@value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} of the
@value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Acknowledgements::
* Preface::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* STREAMS Messages::
* Polling::
* Modules and Drivers::
* STREAMS Modules::
* STREAMS Drivers::
* STREAMS Multiplexing::
* STREAMS-based Pipes and FIFOs::
* STREAMS-based Terminal Subsystem::
* STREAMS Synchronization::
* Reference::
* Examples::
* Device Numbers::
* Multi-Threading::
* Administration::
* STREAMS Data Structures::
* STREAMS Message Types::
* STREAMS Utilities::
* STREAMS Debugging::
* STREAMS Configuration::
* Conformance::
* Portability::
* Copying::
* Glossary::
* Index::

 --- The Detailed Node Listing ---

Acknowledgements

* Sponsors::			Sponsors
* Contributors::		Contributors

Preface

Introduction

* Background::			STREAMS Background
* What is STREAMS?::		STREAMS Description
* Basic Streams Operations::	STREAMS Basic Operations
* Components::			STREAMS Components
* Multiplexing::		STREAMS Multiplexing
* Benefits of STREAMS::		STREAMS Benefits

Overview

* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems

Mechanism

* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction

Processing

* Procedures::			STREAMS Put and Service Procedures
* Asynchronous Example::	STREAMS Asynchronous Stream Example

Messages

* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers

Polling

* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal

Modules and Drivers

* Environment::			STREAMS Module and Driver Environment
* Input-Output Control::	STREAMS Input and Output Control
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines

STREAMS Modules

* Module::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines

STREAMS Drivers

* Driver::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines

STREAMS Multiplexing

* Multiplexers::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexer Connect and Disconnect Lower Stream
* Multiplexer Construction Example::
				STREAMS Multiplexer Construction Example
* Multiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexer Persistent Links
* Multiplexing Driver Design Guidelines::
				STREAMS Multiplexing Driver Design Guidelines

STREAMS-based Pipes and FIFOs

* Pipes and FIFOs::		STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs

STREAMS-based Terminal Subsystem

* Terminal Subsystem::		STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem

STREAMS Synchronization

* STREAMS Framework Integrity::
* MP Message Ordering::
* MP-UNSAFE Modules::
* MP Put and Service Procedures::
* MP Timeout and Buffer Callbacks::
* MP Open and Close Procedures::
* MP Module Unloading::
* MP Locking::
* MP Asynchronous Callbacks::
* Stream Integrity::

Reference

* Files::			STREAMS Files
* Modules::			STREAMS Modules
* Drivers::			STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions

Examples

* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example

Device Numbers

* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* spec File System::		Avoiding Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering

Multi-Threading

* MT Configuration::		MP STREAMS MT Configuration
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks

Administration

* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System

STREAMS Data Structures

* Stream Structures::
* Queue Structures::
* Message Structures::
* Input Output Control Structures::
* Link Structures::
* Options Structures::

STREAMS Message Types

* Message Type::
* Ordinary Messages::
* High Priority Messages::

STREAMS Utilities

STREAMS Debugging

STREAMS Configuration

Conformance

* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX Compatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility

Portability

* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V

Copying

* GNU Affero General Public License::	AGPL
* GNU General Public License::		GPL
* GNU Lesser General Public License::	LGPL
* GNU Free Documentation License::	FDL

@end menu

@c Indices
@c 
@c * Concept Index::		Concept Index
@c * Type Index::			Type Index
@c * Function Index::		Function Index
@c * Variable Index::		Variable Index
@c * File Index::			File Index


@c --------------------------------------------------------------------------

@node Acknowledgements
@unnumbered Acknowledgements
@cindex credits

@raisesections
@include texi/funding.texi
@lowersections

@unnumberedsec Authors

The authors of the @cite{@value{PACKAGE_TITLE}} package include:

@multitable @columnfractions .05 .95
@item @tab @minus{} @email{bidulock@@openss7.org, Brian Bidulock}
@end multitable

@unnumberedsec Maintainer

The maintainer of the @cite{@value{PACKAGE_TITLE}} package is:

@multitable @columnfractions .05 .95
@item @tab @minus{} @email{bidulock@@openss7.org, Brian Bidulock}
@end multitable

Please send bug reports to @email{@value{PACKAGE_BUGREPORT}} using the @file{send-pr} script
included in the package, only after reading the @file{BUGS} file in the release, or @xref{Problem
Reports}.

@node Preface
@unnumbered Preface

@section Document Information
@cindex document information

@subsection Notice
@cindex document notice
@cindex licensing

This package is released and distributed under the @cite{GNU Affero General Public License} (@pxref{GNU
Affero General Public License}).  Please note, however, that there are different licensing terms for the
manual pages and some of the documentation (derived from X/Open publications and other sources).
Consult the permission notices contained in the documentation for more information.

This document, is released under the @cite{GNU Free Documentation License} (@pxref{GNU Free
Documentation License}) with no sections invariant.

@subsection Abstract
@cindex document abstract

This document provides a @cite{@value{MANUAL_TYPE}} for @cite{@value{PACKAGE_TITLE}}.

@subsection Objective
@cindex document objective

The objective of this document is to provide a guide for the @dfn{STREAMS} programmer when
developing @dfn{STREAMS} modules, drivers and application programs for @cite{@value{PACKAGE_TITLE}}.

This guide provides information to developers on the use of the @dfn{STREAMS} mechanism at user and
kernel levels.

@dfn{STREAMS} was incorporated in @cite{UNIX System V Release 3} to augment the character input/output
(I/O) mechanism and to support development of communication services.

@dfn{STREAMS} provides developers with integral functions, a set of utility routines, and facilities
that expedite software design and implementation.

@subsection Intent
@cindex document intent

The intent of this document is to act as an introductory guide to the @dfn{STREAMS} programmer.  It
is intended to be read alone and is not intended to replace or supplement the
@cite{@value{PACKAGE_TITLE}} manual pages.  For a reference for writing code, the manual pages
(see @manref{STREAMS(9)}) provide a better reference to the programmer.
Although this describes the features of the @cite{@value{PACKAGE_TITLE}} package,
@uref{http://www.openss7.com/,OpenSS7 Corporation} is under no obligation to provide any software,
system or feature listed herein.

@subsection Audience
@cindex document audience

This document is intended for a highly technical audience.  The reader should already be familiar
with @cite{Linux} kernel programming, the @cite{Linux} file system, character devices, driver input
and output, interrupts, software interrupt handling, scheduling, process contexts, multiprocessor
locks, etc.

The guide is intended for network and systems programmers, who use the @dfn{STREAMS} mechanism at
user and kernel levels for @cite{Linux} and @cite{UNIX} system communication services.

Readers of the guide are expected to possess prior knowledge of the @cite{Linux} and @cite{UNIX}
system, programming, networking, and data communication.

@subsection Revisions
@cindex document revisions

Take care that you are working with a current version of this document: you will not be notified of
updates.  To ensure that you are working with a current version, contact the
@uref{mailto:bidulock@@openss7.org,Author}, or check @uref{http://www.openss7.org/,The OpenSS7
Project} website for a current version.

A current version of this document is normally distributed with the @cite{@value{PACKAGE_TITLE}}
package.

@subsubsection Version Control

@smallexample
@verbatim
$Log$
Revision 0.9.2.68  2009-05-01 04:50:41  brian
- update documentation for release

Revision 0.9.2.67  2009-04-21 07:48:37  brian
- updates for release

Revision 0.9.2.66  2008-11-26 12:01:40  brian
- updated to FDL 1.3

Revision 0.9.2.65  2008-09-20 11:04:34  brian
- added package patchlevel

Revision 0.9.2.64  2008-08-03 06:03:35  brian
- protected agains texinfo commands in log entries

Revision 0.9.2.63  2008/07/27 08:49:10  brian
- no invariant sections, more libtool ignores

Revision 0.9.2.62  2008-04-28 12:53:59  brian
- update file headers for release

Revision 0.9.2.61  2007/12/15 20:19:35  brian
- updates

Revision 0.9.2.60  2007/11/07 10:05:06  brian
- updates to pass check target

Revision 0.9.2.59  2007/08/12 06:44:24  brian
- updated licenses in manuals

Revision 0.9.2.58  2007/06/22 00:18:39  brian
- mostly documentation updates for release, some netconfig workaround

Revision 0.9.2.57  2007/02/28 06:30:49  brian
- updates and corrections, #ifdef instead of #if

Revision 0.9.2.56  2006/10/21 10:31:21  brian
- updated release number

Revision 0.9.2.55  2006/10/21 09:17:32  brian
- bumped streams version number

Revision 0.9.2.54  2006/09/18 01:06:47  brian
- updated manuals and release texi docs

Revision 0.9.2.53  2006/08/28 10:46:58  brian
- correction

Revision 0.9.2.52  2006/08/27 12:26:44  brian
- finalizing auto release files

Revision 0.9.2.51  2006/08/26 09:18:19  brian
- better release file generation

Revision 0.9.2.50  2006/08/23 11:00:33  brian
- added preface, corrections and updates for release

Revision 0.9.2.49  2006/08/22 12:36:45  brian
- udpates to documentation, tweaks to Stream head

Revision 0.9.2.48  2005/11/20 22:20:12  brian
- still working up documentation

Revision 0.9.2.47  2005/11/16 10:30:33  brian
- still working up take 2

Revision 0.9.2.46  2005/11/15 12:04:55  brian
- second run at SPG

Revision 0.9.2.45  2005/11/14 23:27:06  brian
- more workup

Revision 0.9.2.44  2005/11/14 11:19:49  brian
- working up manual

Revision 0.9.2.43  2005/11/14 04:43:55  brian
- updating manual

Revision 0.9.2.42  2005/11/13 23:04:01  brian
- starting cleanup of SPG

Revision 0.9.2.41  2005/10/07 09:34:00  brian
- more testing and corrections

Revision 0.9.2.40  2005/09/26 10:56:41  brian
- doc updates

Revision 0.9.2.39  2005/09/20 12:53:07  brian
- more doc updates, corrected QFULL handling

Revision 0.9.2.38  2005/09/18 07:38:35  brian
- more doc updates

Revision 0.9.2.37  2005/09/17 11:52:08  brian
- documentation updates

Revision 0.9.2.36  2005/09/17 08:20:57  brian
- more doc updates

Revision 0.9.2.35  2005/09/17 00:46:12  brian
- document updates

Revision 0.9.2.34  2005/09/16 03:06:02  brian
- added glossary

Revision 0.9.2.33  2005/09/15 13:02:52  brian
- added new graphics and updates
@end verbatim
@end smallexample

@subsubsection ISO 9000 Compliance

Only the @TeX{}, texinfo, or roff source for this document is controlled.  An opaque (printed,
postscript or portable document format) version of this document is an @strong{UNCONTROLLED
VERSION}.

@subsection Disclaimer
@cindex document disclaimer

@noindent
@cite{OpenSS7 Corporation} disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights.  In
no event shall @cite{OpenSS7 Corporation} be liable for any direct, indirect, special or
consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising out of or in connection with
any use of this document or the performance or implementation of the contents thereof.

@noindent
@cite{OpenSS7 Corporation} reserves the right to revise this software and documentation for any
reason, including but not limited to, conformity with standards promulgated by various agencies,
utilization of advances in the state of the technical arts, or the reflection of changes in the
design of any techniques, or procedures embodied, described, or referred to herein.  @cite{OpenSS7
Corporation} is under no obligation to provide any feature listed herein.

@subsubsection U.S. Government Restricted Rights

If you are licensing this Software on behalf of the U.S. Government ("Government"), the following
provisions apply to you.  If the Software is supplied by the Department of Defense ("DoD"), it is
classified as "Commercial Computer Software" under paragraph 252.227-7014 of the DoD Supplement to
the Federal Acquisition Regulations ("DFARS") (or any successor regulations) and the Government is
acquiring only the license rights granted herein (the license rights customarily provided to
non-Government users).  If the Software is supplied to any unit or agency of the Government other
than DoD, it is classified as "Restricted Computer Software" and the Government's rights in the
Software are defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR") (or any
successor regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to
the FAR (or any successor regulations).

@section Organization
@cindex organization

This guide has several chapters, each discussing a unique topic.  @ref{Introduction},
@ref{Overview}, @ref{Mechanism} and @ref{Processing} contain introductory information and can be
ignored by those already familiar with @dfn{STREAMS} concepts and facilities.

This document is organized as follows:

@ifnottex
@menu
  Acknowledgements::
  Preface::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* STREAMS Messages::
* Polling::
* Modules and Drivers::
* STREAMS Modules::
* STREAMS Drivers::
* STREAMS Multiplexing::
* STREAMS-based Pipes and FIFOs::
* STREAMS-based Terminal Subsystem::
* STREAMS Synchronization::
* Reference::
* Examples::
* Device Numbers::
* Multi-Threading::
* Administration::
* STREAMS Data Structures::
* STREAMS Message Types::
* STREAMS Utilities::
* STREAMS Debugging::
* STREAMS Configuration::
* Conformance::
* Portability::
* Copying::
* List of Figures::
* Index::
@end menu
@end ifnottex
@iftex
@table @emph
@item @ref{Preface}
Describes the organization and purpose of the guide.  It also defines an intended audience and an
expected background of the users of the guide.
@item @ref{Introduction}
An introduction to @dfn{STREAMS} and the @cite{@value{PACKAGE_TITLE}} package.
@dfn{STREAMS} Fundamentals.  Presents an overview and the benefits of @dfn{STREAMS}.
@item @ref{Overview}
A brief overview of @dfn{STREAMS}.
@item @ref{Mechanism}
A description of the @dfn{STREAMS} framework.  Describes the basic operations for constructing,
using, and dismantling Streams.  These operations are performed using @manpage{open(2)},
@manpage{close(2)}, @manpage{read(2)}, @manpage{write(2)}, and @manpage{ioctl(2)}.
@item @ref{Processing}
Processing and procedures within the @dfn{STREAMS} framework.  Gives an overview of the
@dfn{STREAMS} put and service routines.
@item @ref{STREAMS Messages}
@dfn{STREAMS} Messages, organization, types, priority, queueing, and general handling.  Discusses
@dfn{STREAMS} messages, their structure, linkage, queueing, and interfacing with other @dfn{STREAMS}
components.
@item @ref{Polling}
Polling of @dfn{STREAMS} file descriptors and other asynchronous application techniques.  Describes
how @dfn{STREAMS} allows user processes to monitor, control, and poll Streams to allow an effective
utilization of system resources.
@item @ref{Modules and Drivers}
An overview of @dfn{STREAMS} modules, drivers and multiplexing drivers.  Describes the @dfn{STREAMS}
module and driver environment, input-output controls, routines, declarations, flush handling, driver-kernel
interface, and also provides general design guidelines for modules and drivers.
@item @ref{STREAMS Modules}
Details of @dfn{STREAMS} modules, including examples.  Provides information on module construction
and function.
@item @ref{STREAMS Drivers}
Details of @dfn{STREAMS} drivers, including examples.  Discusses @dfn{STREAMS} drivers, elements of
driver flow control, flush handling, cloning, and processing.
@item @ref{STREAMS Multiplexing}
Details of @dfn{STREAMS} multiplexing drivers, including examples.  Describes the @dfn{STREAMS}
multiplexing facility.
@item @ref{STREAMS-based Pipes and FIFOs}
Details of @dfn{STREAMS}-based Pipes and FIFOs.  Provides information on creating, writing, reading,
and closing of @dfn{STREAMS}-based pipes and FIFOs and unique connections.
@item @ref{STREAMS-based Terminal Subsystem}
Details of @dfn{STREAMS}-based Terminals and Pseudo-terminals.  Discusses @dfn{STREAMS}-based
terminal and and pseudo-terminal subsystems.
@item @ref{STREAMS Synchronization}
Discusses @dfn{STREAMS} in a symmetrical multi-processor environment.
@item @ref{Reference}
Reference section.
@item @ref{Examples}
Collected examples.
@item @ref{Device Numbers}
Specifics on device numbering and the @dfn{Shadow Special Filesystem}.
@item @ref{Multi-Threading}
Synchronization for Symmetrical Multiprocessor (SMP) architectures.
@item @ref{Administration}
Administration of the @dfn{STREAMS} subsystem.
@item @ref{STREAMS Data Structures}
Primary @dfn{STREAMS} Data Structures, descriptions of their members, flags, constants and use.
Summarizes data structures commonly used by @dfn{STREAMS} modules and drivers.
@item @ref{STREAMS Message Types}
@dfn{STREAMS} Message Type reference, with descriptions of each message type.  Describes
@dfn{STREAMS} messages and their use.
@item @ref{STREAMS Utilities}
@dfn{STREAMS} kernel-level utility functions for the module or driver writer.  Describes
@dfn{STREAMS} utility routines and their usage.
@item @ref{STREAMS Debugging}
@dfn{STREAMS} debugging facilities and their use.
Provides debugging aids for developers.
@item @ref{STREAMS Configuration}
@dfn{STREAMS} configuration, the @dfn{STREAMS Administrative Driver} and the autopush facility.
Describes how modules and drivers are configured into the @dfn{Linux} and @dfn{UNIX} system, tunable
parameters, and the autopush facility.
@item @ref{Conformance}
Conformance of the @cite{@value{PACKAGE_TITLE}} package to other @cite{UNIX} implementations of
@dfn{STREAMS}.
@item @ref{Portability}
Portability of @dfn{STREAMS} modules and drivers written for other @cite{UNIX} implementations of
@dfn{STREAMS} and how they can most easily be ported into @cite{@value{PACKAGE_TITLE}}; but, for
more details on this topic, see the @cite{@value{PACKAGE_TITLE} - @dfn{STREAMS} Portability Guide}.
@end table
@end iftex


@subsubsection Conventions Used

This guide uses @cite{texinfo} typographical conventions.

Throughout this guide, the word @dfn{STREAMS} will refer to the mechanism and the word @dfn{Stream}
will refer to the path between a user application and a driver.  In connection with
@dfn{STREAMS}-based pipes @dfn{Stream} refers to the data transfer path in the kernel between the
kernel and one or more user processes.

Examples are given to highlight the most important and common capabilities of @dfn{STREAMS}.  They
are not exhaustive and, for simplicity, often reference fictional drivers and modules.  Some
examples are also present in the @cite{@value{PACKAGE_TITLE}} package, both for testing and example
purposes.

System calls, @dfn{STREAMS} utility routines, header files, and data structures are given using
@command{texinfo} @file{filename} typesetting, when they are mentioned in the text.

Variable names, pointers, and parameters are given using @command{texinfo} @var{variable}
typesetting conventions.  Routine, field, and structure names unique to the examples are also given
using @command{texinfo} @var{variable} typesetting conventions when they are mentioned in the text.

Declarations and short examples are in @command{texinfo} @samp{sample} typesetting.

@command{texinfo} displays are used to show program source code.
@ignore
Screens are used to simulate what a user will see on a video display screen or to show program
source code.
@end ignore

Data structure formats are also shown in @command{texinfo} displays.

@ignore
[Boxcaut.gif]

The caution sign is used to show possible harm or damage to a system, an application, a process, a
piece of hardware, etc.

[Boxnote.gif]

The note sign is used to emphasize points of interest, to present parenthetical information, and to
cite references to other documents and commands.
@end ignore

@subsection Other Documentation

Although the @cite{@value{MANUAL_TYPE}} for @cite{@value{PACKAGE_TITLE}} provides a guide to aid in
developing @dfn{STREAMS} applications, readers are encouraged to consult the
@cite{@value{PACKAGE_TITLE}} manual pages.  For a reference for writing code, the manual pages (see
@manref{STREAMS(9)}) provide a better reference to the programmer.
For detailed information on
system calls used by @dfn{STREAMS} (section 2), and
@dfn{STREAMS} utilities from section 8.
@dfn{STREAMS} specific input output control (ioctl) calls are provided in @manref{streamio(7)}.
@dfn{STREAMS} modules and drivers are described on section 7.
@dfn{STREAMS} is also described to some extent in the @cite{System V Interface Definition, Third Edition}.

@subsection UNIX Edition

This system conforms to @cite{UNIX System V Release 4.2} for @cite{Linux}.


@subsection Related Manuals

@cite{@value{PACKAGE_TITLE} Installation and Reference Manual}

@subsection Copyright

@copyright{} 1997-2009  Monavacon Limited.  All Rights Reserved.


@node Introduction
@chapter Introduction
@cindex introduction
@menu
* Background::			STREAMS Background
* What is STREAMS?::		STREAMS Description
* Basic Streams Operations::	STREAMS Basic Operations
* Components::			STREAMS Components
* Multiplexing::		STREAMS Multiplexing
* Benefits of STREAMS::		STREAMS Benefits
@end menu

The @url{http://www.openss7.org/, OpensSS7 Project},
@cindex OpenSS7 Project
@file{@value{PACKAGE}-@value{VERSION}} package
@pgindex @value{PACKAGE}-@value{VERSION}
provides an @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
compatible @dfn{STREAMS} implementation for @b{Linux}
@cindex Linux
2.4 and 2.6 series kernels.

@node Background
@section Background

@dfn{STREAMS} is a facility first presented in a paper by Dennis M. Ritchie in
1984,@footnote{@cite{A Stream Input-Output System, AT&T Bell Laboratories Technical Journal 63, No.
8 Part 2 (October, 1984), pp.  1897-1910.}} originally implemented on 4.1BSD and later part of
@cite{Bell Laboratories Eighth Edition UNIX}, incorporated into
@cite{UNIX System V Release 3.0}
@cindex UNIX System V Release 3.0
and enhanced in
@cite{UNIX System V Release 4}
@cindex UNIX System V Release 4
and
@cite{UNIX System V Release 4.2}.
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used in @cite{SVR4} for terminal input/output, pseudo-terminals, pipes, named
pipes (FIFOs), interprocess communication and networking.  Since its release in @cite{System V
Release 4}, @dfn{STREAMS} has been implemented across a wide range of @cite{UNIX}, @cite{UNIX}-like,
and @cite{UNIX}-based systems, making its implementation and use an @i{ipso facto} standard.

@dfn{STREAMS} is a facility that allows for a reconfigurable full duplex communications path,
@dfn{Stream}, between a user process and a driver in the kernel.  Kernel protocol modules can be
pushed onto and popped from the @dfn{Stream} between the user process and driver.  The @dfn{Stream}
can be reconfigured in this way by a user process.  The user process, neighbouring protocol modules
and the driver communicate with each other using a message passing scheme closely related to
@dfn{MOM (Message Oriented Middleware)}.  This permits a loose coupling between protocol modules,
drivers and user processes, allowing a third-party and loadable kernel module approach to be taken
toward the provisioning of protocol modules on platforms supporting @dfn{STREAMS}.

On @cite{UNIX System V Relase 4.2},
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used for terminal input-output, pipes, FIFOs (named pipes), and network
communications.  Modern @cite{UNIX}, @cite{UNIX}-like and @cite{UNIX}-based systems providing
@dfn{STREAMS} normally support some degree of network communications using @dfn{STREAMS}; however,
many do not support @dfn{STREAMS}-based pipe and FIFOs@footnote{For example, AIX.} or terminal
input-output.@footnote{For example, HP-UX}.

@node What is STREAMS?
@section What is STREAMS?

@dfn{STREAMS} is a general, flexible facility and a set of tools for development of @cite{UNIX}
system communication services.  It supports the implementation of services ranging from complete
networking protocol suites to individual device drivers.  @dfn{STREAMS} defines standard interfaces
for character input/output within the kernel, and between the kernel and the rest of the @cite{UNIX}
system.  The associated mechanism is simple and open-ended.  It consists of a set of system calls,
kernel resources, and kernel routines.

The standard interface and mechanism enable modular, portable development and easy integration of
high performance network services and their components.  @dfn{STREAMS} does not impose any specific
network architecture.  The @dfn{STREAMS} user interface is upwardly compatible with the character
I/O user level functions such as @manref{open(2)}, @manref{close(2)}, @manref{read(2)},
@manref{write(2)}, and @manref{ioctl(2)}.  Benefits of @dfn{STREAMS} are discussed in more detail
later in this chapter.

A @dfn{Stream} is a full-duplex processing and data transfer path between a @dfn{STREAMS} driver in
kernel space and a process in user space (see @figref{101}).  In the kernel, a @dfn{Stream} is
constructed by linking a @dfn{Stream head}, a driver, and zero or more modules between the
@dfn{Stream head} and driver.  The @dfn{Stream head} is the end of the @dfn{Stream} nearest to the
user process.  All system calls made by a user level process on a @dfn{Stream} are processed by the
@dfn{Stream head}.

Pipes are also @dfn{STREAMS}-based.  A @dfn{STREAMS}-based pipe (see @figref{102}) is a full-duplex
(bidirectional) data transfer path in the kernel.  It implements a connection between the kernel and
one or more user processes and also shares properties of @dfn{STREAMS}-based devices.

A @dfn{STREAMS} driver may be a device driver that provides the services of an external I/O device,
or a software driver, commonly referred to as a @dfn{pseudo-device driver}.  The driver typically
handles data transfer between the kernel and the device and does little or no processing of data
other than conversion between data structures used by the @dfn{STREAMS} mechanism and data
structures that the device understands.

A @dfn{STREAMS} module represents processing functions to be performed on data flowing on the
@dfn{Stream}.  The module is a defined set of kernel-level routines and data structures used to
process data, status, and control information.  Data processing may involve changing the way the
data are represented, adding/deleting header and trailer information to data, and/or
packetizing/depacketizing data.  Status and control information includes signals and input/output
control information.  Each module is self-contained and functionally isolated from any other
component in the @dfn{Stream} except its two neighbouring components.  The module communicates with
its neighbours by passing messages.  The module is not a required component in @dfn{STREAMS}, whereas
the driver is, except in a @dfn{STREAMS}-based pipe where only the @dfn{Stream head} is required.

@figuresized{SPG_fig01,101,Simple Stream,4in}
@c [strm.stmexap.gif]

One or more modules may be inserted into a @dfn{Stream} between the @dfn{Stream head} and driver to
perform intermediate processing of messages as they pass between the @dfn{Stream head} and driver.
@dfn{STREAMS} modules are dynamically interconnected in a @dfn{Stream} by a user process.  No kernel
programming, assembly, or link editing is required to create the interconnection.

@figuresized{SPG_fig02,102,@dfn{STREAMS}-based Pipe,4in}
@c [strm.stmpipe.gif]

@dfn{STREAMS} uses queue structures to keep information about given instances of a pushed module or
opened @dfn{STREAMS} device.  A queue is a data structure that contains status information, a
pointer to routines processing messages, and pointers for administering the @dfn{Stream}.  Queues
are always allocated in pairs; one queue for the read-side and other for the write-side.  There is
one queue pair for each driver and module, and the @dfn{Stream head}.  The pair of queues is
allocated whenever the @dfn{Stream} is opened or the module is pushed (added) onto the @dfn{Stream}.

Data are passed between a driver and the @dfn{Stream head} and between modules in the form of
messages.  A message is a set of data structures used to pass data, status, and control information
between user processes, modules, and drivers.  Messages that are passed from the @dfn{Stream head}
toward the driver or from the process to the device, are said to travel downstream (also called
write-side).  Similarly, messages passed in the other direction, from the device to the process or
from the driver to the @dfn{Stream head}, travel upstream (also called read-side).

A @dfn{STREAMS} message is made up of one or more message blocks.  Each block is a 3-tuple
consisting of a header, a data block, and a data buffer.  The @dfn{Stream head} transfers data
between the data space of a user process and @dfn{STREAMS} kernel data space.  Data to be sent to a
driver from a user process are packaged into @dfn{STREAMS} messages and passed downstream.  When a
message containing data arrives at the @dfn{Stream head} from downstream, the message is processed
by the @dfn{Stream head}, which copies the data into user buffers.

Within a @dfn{Stream}, messages are distinguished by a type indicator.  Certain message types sent
upstream may cause the @dfn{Stream head} to perform specific actions, such as sending a signal to a
user process.  Other message types are intended to carry information within a @dfn{Stream} and are
not directly seen by a user process.

@c =================================================

@node Basic Streams Operations
@section Basic Streams Operations

This section describes the basic set of operations for manipulating @dfn{STREAMS} entities.

A @dfn{STREAMS} driver is similar to a traditional character I/O driver in that it has one or more
nodes associated with it in the file system and it is accessed using the @manpage{open(2)} system call.
Typically, each file system node corresponds to a separate minor device for that driver.  Opening
different minor devices of a driver will cause separate @dfn{Streams} to be connected between a user
process and the driver.  The file descriptor returned by the @manpage{open(2)} call is used for further access to
the @dfn{Stream}.  If the same minor device is opened more than once, only one @dfn{Stream} will be
created; the first @manpage{open(2)} call will create the @dfn{Stream}, and subsequent @manpage{open(2)} calls will return a
file descriptor that references that @dfn{Stream}.  Each process that opens the same minor device
will share the same @dfn{Stream} to the device driver.

Once a device is opened, a user process can send data to the device using the @manpage{write(2)}
system call and receive data from the device using the @manpage{read(2)} system call.  Access to
@dfn{STREAMS} drivers using @manpage{read(2)} and @manpage{write(2)} is compatible with the
traditional character I/O mechanism.

The @manpage{close(2)} system call will close a device and dismantle the associated @dfn{Stream}
when the last open reference to the @dfn{Stream} is given up.

The following example shows how a simple @dfn{Stream} is used.  In the example, the user program
interacts with a communications device that provides point-to-point data transfer between two
computers.  Data written to the device are transmitted over the communications line, and data
arriving on the line can be retrieved by reading from the device.

@smallexample
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
main()
@{
        char buf[1024]
        int fd, count;

        if ((fd = open("/dev/comm/01", O_RDWR)) < 0) @{
                perror("open failed");
                exit(1);
        @}

        while ((count = read(fd, buf, 1024)) > 0) @{
                if (write(fd, buf, count) != count) @{
                        perror("write failed");
                        break;
                @}
        @}
        exit(0);
@}
@end smallexample

In the example, @file{/dev/comm/01} identifies a minor device of the communications device driver.
When this file is opened, the system recognizes the device as a @dfn{STREAMS} device and connects a
@dfn{Stream} to the driver.  @figref{103} shows the state of the @dfn{Stream} following the call to
@manpage{open(2)}.

@figuresized{SPG_fig03,103,Stream to Communications Driver,4in}
@c [strm.stmdvi.gif]

This example illustrates a user reading data from the communications device and then writing the
input back out to the same device.  In short, this program echoes all input back over the
communications line.  The example assumes that a user is sending data from the other side of the
communications line.  The program reads up to @samp{1024} bytes at a time, and then writes the
number of bytes just read.

The @manpage{read(2)} call returns the available data, which may contain fewer than @samp{1024}
bytes.  If no data are currently available at the @dfn{Stream head}, the @manpage{read(2)} call
blocks until data arrive.

Similarly, the @manpage{write(2)} call attempts to send count bytes to @file{/dev/comm/01}.
However, @dfn{STREAMS} implements a flow control mechanism that prevents a user from exhausting
system resources by flooding a device driver with data.

Flow control is a @dfn{STREAMS} mechanism that controls the rate of message transfer among the
modules, drivers, @dfn{Stream head}, and processes.  Flow control is local to each @dfn{Stream} and
advisory (voluntary).  It limits the number of characters that can be queued for processing at any
queue in a @dfn{Stream}.  This mechanism limits buffers and related processing at any queue and in
any one @dfn{Stream}, but does not consider buffer pool levels or buffer usage in other
@dfn{Streams}.  Flow control is not applied to high priority messages (message priority will be
discussed later).

If the @dfn{Stream} exerts flow control on the user, the @manpage{write(2)} call blocks until flow
control has been relieved.  The call will not return until it has sent count bytes to the device.
@manpage{exit(2)} is called to terminate the user process.  This system call also closes all open
files, thereby dismantling the @dfn{Stream} in this example.

@node Components
@section Components
@menu
* Queue Component::
* Message Component::
* Module Component::
* Driver Component::
@end menu

This section gives an overview of the @dfn{STREAMS} components and discusses how these components
interact with each other.  A more detailed description of each @dfn{STREAMS} component is given in
the later chapters.

@node Queue Component
@subsection Queues

A queue is an interface between a @dfn{STREAMS} driver or module and the rest of the @dfn{Stream}.
Queues are always allocated as an adjacent pair.  The queue with the lower address in the pair is a
read queue, and the queue with the higher address is used for the write queue.

A queue's @command{service} routine is invoked to process messages on the queue.  It usually removes
successive messages from the queue, processes them, and calls the @command{put} routine of the next
module in the @dfn{Stream} to give the processed message to the next queue.

A queue's @command{put} routine is invoked by the preceding queue's @command{put} and/or
@command{service} routine to add a message to the current queue.  If a module does not need to
enqueue messages, its @command{put} routine can call the neighbouring queue's @command{put} routine.
(@ref{Processing} discusses the @command{service} and @command{put} routines in more detail.)

Each queue also has a pointer to an open and close routine.  The open routine of a driver is called
when the driver is first opened and on every successive open of the @dfn{Stream}.  The open routine
of a module is called when the module is first pushed on the @dfn{Stream} and on every successive
open of the @dfn{Stream}.  The close routine of the module is called when the module is popped
(removed) off the @dfn{Stream}.  The close routine of the driver is called when the last reference
to the @dfn{Stream} is given up and the @dfn{Stream} is dismantled.

@node Message Component
@subsection Messages

All input and output under @dfn{STREAMS} is based on messages.  The objects passed between
@dfn{STREAMS} modules are pointers to messages.  All @dfn{STREAMS} messages use two data structures
(msgb and datab) to refer to the message data.  These data structures describe the type of the
message and contain pointers to the data of the message, as well as other information.  Messages are
sent through a @dfn{Stream} by successive calls to the @command{put} procedure of each module or driver in the
@dfn{Stream}.

@subsubsection Message Types

All @dfn{STREAMS} messages are assigned message types to indicate their intended use by modules and
drivers and to determine their handling by the @dfn{Stream head}.  A driver or module can assign
most types to a message it generates, and a module can modify a message type during processing.  The
@dfn{Stream head} will convert certain system calls to specified message types and send them
downstream, and it will respond to other calls by copying the contents of certain message types that
were sent upstream.

Most message types are internal to @dfn{STREAMS} and can only be passed from one @dfn{STREAMS}
component to another.  A few message types, for example M_DATA, M_PROTO, and M_PCPROTO, can also be
passed between a @dfn{Stream} and user processes.  M_DATA messages carry data within a @dfn{Stream}
and between a @dfn{Stream} and a user process.  M_PROTO or M_PCPROTO messages carry both data and
control information.

As shown in @figref{104}, a @dfn{STREAMS} message consists of one or more linked message blocks that
are attached to the first message block of the same message.

@figuresized{SPG_fig05,104,A Message,5in}
@c [strm.strmsg.gif]

Messages can exist stand-alone, as in @figref{104}, when the message is being processed by a
procedure.  Alternately, a message can await processing on a linked list of messages, called a
message queue.  In @figref{105}, @samp{Message 2} is linked to @samp{Message 1}.

@figuresized{SPG_fig06,105,Messages on a Message Queue,5in}
@c [strm.msgque.gif]

When a message is on a queue, the first block of the message contains links to preceding and
succeeding messages on the same message queue, in addition to the link to the second block of the
message (if present).  The message queue head and tail are contained in the queue.

@dfn{STREAMS} utility routines enable developers to manipulate messages and message queues.

@subsubsection Message Queueing Priority

In certain cases, messages containing urgent information (such as a break or alarm conditions) must
pass through the @dfn{Stream} quickly.  To accommodate these cases, @dfn{STREAMS} provides multiple
classes of message queueing priority.  All messages have an associated priority field.  Normal
(ordinary) messages have a priority of zero.  Priority messages have a priority greater than zero.
High priority messages are high priority by virtue of their message type.  The priority field in
high priority messages is unused and should always be set to zero.  @dfn{STREAMS} prevents high
priority messages from being blocked by flow control and causes a @command{service} procedure to
process them ahead of all ordinary messages on the queue.  This results in the high priority message
transiting each module with minimal delay.

Non-priority, ordinary messages are placed at the end of the queue following all other messages in
the queue.  Priority messages can be either high priority or priority band messages.  High priority
messages are placed at the head of the queue but after any other high priority messages already in
the queue.  Priority band messages that enable support of urgent, expedited data are placed in the
queue after high priority messages but before ordinary messages.

Message priority is defined by the message type; once a message is created, its priority cannot be
changed.  Certain message types come in equivalent high priority/ordinary pairs (for example,
@msg{M_PCPROTO} and @msg{M_PROTO}), so that a module or device driver can choose between the two
priorities when sending information.



@node Module Component
@subsection Modules

A module performs intermediate transformations on messages passing between a @dfn{Stream head} and a
driver.  There may be zero or more modules in a @dfn{Stream} (zero when the driver performs all the
required character and device processing).

Each module is constructed from a pair of queue structures (see @samp{Au/Ad} and @samp{Bu/Bd} in
@figref{48}) upstream through the module (@samp{Au} and @samp{Bu} in @figref{48}).  The other set
(@samp{Ad} and @samp{Bd}) performs another set of functions on downstream messages.

Each of the two queues in a module will generally have distinct functions, that is, unrelated
processing procedures and data.  The queues operate independently and @samp{Au} will not know if a
message passes through @samp{Ad} unless @samp{Ad} is programmed to inform it.  Messages and data can
be shared only if the developer specifically programs the module functions to perform the sharing.

Each queue can directly access the adjacent queue in the direction of message flow (for example,
@samp{Au} to @samp{Bu} or @samp{Bd} to @samp{Ad}).  In addition, within a module, a queue can
readily locate its mate and access its messages and data.

@figuresized{SPG_fig48,48,A @dfn{Stream} in More Detail,5in}
@c [strm.strfig.gif]

Each queue in a module points to messages, processing procedures, and data:

@table @dfn

@item Messages
These are dynamically attached to the queue on a linked list (@dfn{message queue}, see @samp{Ad} and
@samp{Bu} in @figref{48}) as they pass through the module.

@item Processing procedures
A put procedure processes messages and must be incorporated in each queue.  An optional
@command{service}
procedure can also be incorporated.  According to their function, the procedures can send messages
upstream and/or downstream, and they can also modify the private data in their module.

@item Data
Developers may use a private field in the queue to reference private data structures (for example,
state information and translation tables).

@end table

In general, each of the two queues in a module has a distinct set of all of these elements.

@node Driver Component
@subsection Drivers

@dfn{STREAMS} device drivers are an initial part of a @dfn{Stream}.  They are structurally similar
to @dfn{STREAMS} modules.  The call interfaces to driver routines are identical to the interfaces
used for modules.

There are three significant differences between modules and drivers.  A driver must be able to
handle interrupts from the device, a driver can have multiple @dfn{Streams} connected to it, and a
driver is initialized/deinitialized via open and close.  A module is initialized/deinitialized via
the @streamio{I_PUSH} @command{ioctl} and @streamio{I_POP} @command{ioctl}.

Drivers and modules can pass signals, error codes, and return values to processes via message types
provided for that purpose.

@node Multiplexing
@section Multiplexing

Earlier, @dfn{Streams} were described as linear connections of modules, where each invocation of a
module is connected to at most one upstream module and one downstream module.  While this
configuration is suitable for many applications, others require the ability to multiplex
@dfn{Streams} in a variety of configurations.  Typical examples are terminal window facilities, and
inter-networking protocols (which might route data over several subnetworks).

An example of a multiplexer is one that multiplexes data from several upper @dfn{Streams} over a
single lower @dfn{Stream}, as shown in @figref{49}.  An upper @dfn{Stream} is one that is upstream
from a multiplexer, and a lower @dfn{Stream} is one that is downstream from a multiplexer.  A
terminal windowing facility might be implemented in this fashion, where each upper @dfn{Stream} is
associated with a separate window.

@figuresized{SPG_fig49,49,Many-to-one Multiplexer,1.5in}
@c [strm.mltprx1.gif]

A second type of multiplexer might route data from a single upper @dfn{Stream} to one of several
lower @dfn{Streams}, as shown in @figref{50}.  An inter-networking protocol could take this form,
where each lower @dfn{Stream} links the protocol to a different physical network.

@figuresized{SPG_fig50,50,One-to-many Multiplexer,1.5in}
@c [strm.mltprx2.gif]

A third type of multiplexer might route data from one of many upper @dfn{Streams} to one of many
lower @dfn{Streams}, as shown in @figref{51}.

@figuresized{SPG_fig51,51,Many-to-many Multiplexer,1.5in}
@c [strm.mltprx3.gif]

The @dfn{STREAMS} mechanism supports the multiplexing of @dfn{Streams} through special pseudo-device
drivers.  Using a linking facility, users can dynamically build, maintain, and dismantle multiplexed
@dfn{Stream} configurations.  Simple configurations like the ones shown in three previous figures
can be further combined to form complex, multi-level multiplexed @dfn{Stream} configurations.

@dfn{STREAMS} multiplexing configurations are created in the kernel by interconnecting multiple
@dfn{Streams}.  Conceptually, there are two kinds of multiplexers: upper and lower multiplexers.
Lower multiplexers have multiple lower @dfn{Streams} between device drivers and the multiplexer, and
upper multiplexers have multiple upper @dfn{Streams} between user processes and the multiplexer.

@figuresized{SPG_fig47,47,Internet Multiplexing @dfn{Stream},5in}
@c [strm.netmlt.gif]

@figref{47} is an example of the multiplexer configuration that would typically occur where
inter-networking functions were included in the system.  This configuration contains three hardware
device drivers.  The @dfn{IP (Internet Protocol)} is a multiplexer.

The @dfn{IP} multiplexer switches messages among the lower @dfn{Streams} or sends them upstream to
user processes in the system.  In this example, the multiplexer expects to see the same interface
downstream to @samp{Module 1}, @samp{Module 2}, and @samp{Driver 3}.

@figref{47} depicts the @dfn{IP} multiplexer as part of a larger configuration.  The multiplexer
configuration, as shown in the dashed rectangle, would generally have an upper multiplexer and
additional modules.  Multiplexers could also be cascaded below the @dfn{IP} multiplexer driver if
the device drivers were replaced by multiplexer drivers.

@figuresized{SPG_fig52,52,Multiplexing @dfn{Stream},4in}
@c [strm.mltstm.gif]

@figref{52} shows a multiplexer configuration where the multiplexer (or multiplexing driver) routes
messages between the lower @dfn{Stream} and one of the upper @dfn{Streams}.  This @dfn{Stream}
performs X.25 multiplexing to multiple independent SVC (Switched Virtual Circuit) and PVC (Permanent
Virtual Circuit) user processes.  Upper multiplexers are a specific application of standard
@dfn{STREAMS} facilities that support multiple minor devices in a device driver.  This figure also
shows that more complex configurations can be built by having one or more multiplexed drivers below
and multiple modules above an upper multiplexer.

Developers can choose either upper or lower multiplexing, or both, when designing their
applications.  For example, a window multiplexer would have a similar configuration to the X.25
configuration of @figref{52}, with a window driver replacing Packet Layer, a tty driver replacing
the driver XYZ, and the child processes of the terminal process replacing the user processes.
Although the X.25 and window multiplexing @dfn{Streams} have similar configurations, their
multiplexer drivers would differ significantly.  The @dfn{IP} multiplexer of @figref{47} has a
different configuration than the X.25 multiplexer, and the driver would implement its own set of
processing and routing requirements in each configuration.

In addition to upper and lower multiplexers, more complex configurations can be created by
connecting @dfn{Streams} containing multiplexers to other multiplexer drivers.  With such a
diversity of needs for multiplexers, it is not possible to provide general purpose multiplexer
drivers.  Rather, @dfn{STREAMS} provides a general purpose multiplexing facility.  The facility
allows users to set up the inter-module/driver plumbing to create multiplexer configurations of
generally unlimited interconnection.

@node Benefits of STREAMS
@section Benefits of STREAMS
@menu
* Standardized Service Interfaces::
* Manipulating Modules::
@end menu

@dfn{STREAMS} provides a flexible, portable, and reusable set of tools for development of @b{Linux}
system communication services.  @dfn{STREAMS} allows an easy creation of modules that offer standard
data communications services and the ability to manipulate those modules on a @dfn{Stream}.  From
user level, modules can be dynamically selected and interconnected; kernel programming, assembly,
and link editing are not required to create the interconnection.

@dfn{STREAMS} also greatly simplifies the user interface for languages that have complex input and
output requirements.  This is discussed in @ref{STREAMS-based Terminal Subsystem}.

@node Standardized Service Interfaces
@subsection Standardized Service Interfaces

@dfn{STREAMS} simplifies the creation of modules that present a service interface to any neighbouring
application program, module, or device driver.  A service interface is defined at the boundary
between two neighbours.  In @dfn{STREAMS}, a service interface is a specified set of messages and the
rules that allow passage of these messages across the boundary.  A module that implements a service
interface will receive a message from a neighbour and respond with an appropriate action (for
example, send back a request to retransmit) based on the specific message received and the preceding
sequence of messages.

In general, any two modules can be connected anywhere in a @dfn{Stream}.  However, rational
sequences are generally constructed by connecting modules with compatible protocol service
interfaces.  For example, a module that implements an X.25 protocol layer, as shown in
@figref{53}, presents a protocol service interface at its input
and output sides.  In this case, other modules should only be connected to the input and output side
if they have the compatible X.25 service interface.

@node Manipulating Modules
@subsection Manipulating Modules
@menu
* Protocol Portability::
* Protocol Substitution::
* Protocol Migration::
* Module Reusability::
@end menu

@dfn{STREAMS} provides the capabilities to manipulate modules from user level, to interchange
modules with common service interfaces, and to change the service interface to a @dfn{STREAMS} user
process.  These capabilities yield further benefits when implementing networking services and
protocols, including:

@itemize @bullet
@item User level programs can be independent of underlying protocols and physical communication
media.

@item Network architectures and higher level protocols can be independent of underlying protocols,
drivers, and physical communication media.

@item Higher level services can be created by selecting and connecting lower level services and
protocols.

@end itemize

The following examples show the benefits of @dfn{STREAMS} capabilities for creating service interfaces and
manipulating modules.  These examples are only illustrations and do not necessarily reflect real
situations.

@node Protocol Portability
@subsubsection Protocol Portability

@figref{53}, shows how the same X.25 protocol module can be used with different drivers on different
machines by implementing compatible service interfaces.  The X.25 protocol module interfaces are
@dfn{Connection Oriented Network Service (CONS)} and @dfn{Link Access Protocol-Balanced (LAPB)}.

@figuresized{SPG_fig53,53,Protocol Module Portability,4in}
@c [strm.ptcmjl.gif]

@node Protocol Substitution
@subsubsection Protocol Substitution

Alternate protocol modules (and device drivers) can be interchanged on the same machine if they are
implemented to an equivalent service interface.

@figref{300} illustrates how @dfn{STREAMS} can substitute upper layer protocol modules to implement
a different protocol stack over the same @dfn{HDLC} driver.  As each module and driver support the
same service interface at each level, it is conceivable that the resulting modules could be
recombined to support, for example, @cite{SS7 MTP} over an @cite{ISDN LAPB} channel.@footnote{SS7
MTP over ISDN LAPB was originally defined under ISDN as an E-Channel.}

@figuresized{SPG_fig56,300,Protocol Substitution,4in}

@node Protocol Migration
@subsubsection Protocol Migration

@figref{54} illustrates how @dfn{STREAMS} can move functions between kernel software and front end
firmware.  A common downstream service interface allows the transport protocol module to be
independent of the number or type of modules below.  The same transport module will connect without
modification to either an X.25 module or X.25 driver that has the same service interface.

By shifting functions between software and firmware, developers can produce cost effective,
functionally equivalent systems over a wide range of configurations.  They can rapidly incorporate
technological advances.  The same transport protocol module can be used on a lower capacity machine,
where economics may preclude the use of front-end hardware, and also on a larger scale system where
a front-end is economically justified.

@figuresized{SPG_fig54,54,Protocol Migration,4in}
@c [strm.ptcmove.gif]

@node Module Reusability
@subsubsection Module Reusability

@figref{55} shows the same canonical module (for example, one that provides
delete and kill processing on character strings) reused in two different @dfn{Streams}.  This module
would typically be implemented as a filter, with no downstream service interface.  In both cases, a
tty interface is presented to the @dfn{Stream}'s user process since the module is nearest the
@dfn{Stream head}.

@figuresized{SPG_fig55,55,Module Reusability,4in}
@c [strm.mjlrep.gif]

@node Overview
@chapter Overview of @value{PACKAGE_TITLE}
@cindex overview
@menu
* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems
@end menu

This guide documents how to develop and port STREAMS drivers and modules for
@value{PACKAGE_TITLE}.

@node Definitions
@section @dfn{STREAMS} Definitions
@cindex @dfn{STREAMS}, definitions
@cindex definitions, @dfn{STREAMS}

@table @dfn

@item Stream
A @dfn{Stream} is a full-duplex communications path between a User Process and a Kernel Level Device
or Pseudo-Device Driver.  A @dfn{Stream} is a group of @dfn{STTREAMS} message queue pairs in a chain
from a kernel driver at the @dfn{Stream End} to a @dfn{Stream Head} at the user.

@item Stream Head
A @dfn{Stream Head} is the component in a @dfn{Stream} that is closest to the User Process.  The
@dfn{Stream Head} sits in Kernel Space and provide interface to the User Process.

@item Stream End
A @dfn{Stream End} is the component in a @dfn{Stream} that is farthest from the User Process.  The
@dfn{Stream End} sits in Kernel Space and is normally a Device or Pseudo-Device Driver.

@item Module
A @dfn{Module} is a protocol module that resides between the @dfn{Stream Head} and @dfn{Stream End}
on a @dfn{Stream}.  Protocol @dfn{Modules} are optional and can be pushed or popped from a
@dfn{Stream} using @command{ioctl} commands to the @dfn{Stream Head}.  A @dfn{Module} can refer to a
linkable kernel component (kernel module), a @dfn{STREAMS} driver, module or mux (@dfn{STREAMS}
module), or a pushable @dfn{STREAMS} module.

@item Driver
A @dfn{Driver} is a device or pseudo-device driver that sits at the @dfn{Stream End}.  @dfn{Drivers}
are associated with device numbers and are opened by the User Process.  A @dfn{Driver} is a
@dfn{STREAMS} module which sets at a @dfn{Stream End}, farthest from the user on a @dfn{Stream}.

@item Messages
A @dfn{Message} is a chain of data buffers used for passing data by reference between neighbouring
@dfn{STREAMS} @dfn{Modules}, the @dfn{Stream Head} and the @dfn{Driver}.  A @dfn{Message} is a
message containing data that is made up of a sequence of message blocks, data blocks and data.

@item Queues
Each @dfn{Stream Head}, @dfn{Stream End} and intervening @dfn{Module} consists of a pair of
@dfn{Queues}: one downstream @dfn{Queue} for messages first written by the User Process, and one
upstream @dfn{Queue} for messages ultimately read by the User Process.  A @dfn{Queue} is an ordered
list of messages awaiting processing.  @dfn{STREAMS} modules form a full duplex connection by
pairing queues as read and write queues.

@item Stream I/O

@item Multiplexing
@dfn{Multiplexing} is a situation where multiple @dfn{Streams} can fan-in or fan-out from a
@dfn{Module} or @dfn{Multiplexing Driver}.  A @dfn{Multiplexing} driver or @dfn{mux} is a
@dfn{STREAMS} module which has lower as well as upper queue pairs.

@item Polling

@item Flow Control
A @dfn{Stream} is flow-controlled when it is congested and temporarily cannot pass messages in the
band in which the stream is flow-controlled.

@end table

@node Concepts
@section Concepts
@cindex concepts

There are three types of @dfn{STREAMS} entities: the stream head, modules and drivers.  Stream
heads are the kernel-space interface to the user process.  Modules are pushable streams protocol
modules that are optionally placed between the user process (stream head) and the driver (stream
end).  Drivers are device drivers or pseudo device drivers that can be opened using a character
device special file.

@figuresized{SPG_fig08,8,@dfn{STREAMS} Modules,4in}

@figref{8} illustrates the basic @dfn{STREAMS} modules:

@table @dfn

@item Stream Head
The @dfn{Stream Head} is allocated by the @dfn{STREAMS} subsystem when a @dfn{STREAMS} character
special device is opened.

A stream head is created whenever the first @manref{open(2)}
is performed on a @dfn{STREAMS} device.  A stream head has a queue pair just like any other driver,
module or multiplexer, but it interfaces directly with user-space library calls.  A stream head is
opened whenever a driver is opened (whether for the first time or not), and each time that a module
is pushed onto the stream.  A stream head is closed when the last close is performed on the stream.

@item Driver
@dfn{Drivers} are opened by character major and minor device number.

Instances of a @dfn{STREAMS} driver are created by calling @manref{open(2)}
on a character special device which has a device major number which has been registered against the
driver.  Opening the special character device results in the driver's open procedure being called.
The driver's open procedure is also called each time that the device is opened and each time that a
module is pushed onto a stream.  Closing the special character device for the last time results in
the driver's close procedure being called.

@item Module
@dfn{Modules} may be pushed under a @dfn{Stream Head} once a @dfn{Driver} or @dfn{Multiplexer} has
been opened.

@dfn{STREAMS} modules are not created by calling @manref{open(2)}:
they are pushed onto an open stream with the @ioctlref{I_PUSH} @manref{ioctl(2)}.
Modules are pushed by name.  Modules can be popped from a stream using the @ioctlref{I_POP}
@manref{ioctl(2)}.
Several modules can be pushed on a stream.  A module's open procedure is called when it is pushed
and whenever the stream is reopened, and its close procedure is called whenever it is popped, or
when the stream is closed for the last time and is being dismantled.

@item Multiplexer
@dfn{Multiplexers} are opened on the upper interface like @dfn{Drivers}, but can also have other
streams @dfn{linked} underneath them.

@dfn{STREAMS} @dfn{Multiplexers} have both an upper queue pair and a lower queue pair.  Upper queue
pairs are opened when a character special device is opened as with a driver.  Lower queue pairs are
linked when another stream is linked under the @dfn{Multiplexer} by executing the @ioctlref{I_LINK}
or @ioctlref{I_PLINK} @manpage{ioctl(2)} command on a control stream associated with the
@dfn{Multiplexer}.

@streamio{I_LINK}'ed streams can by unlinked with the @ioctlref{I_UNLINK} @manpage{ioctl(2)}
command.  @streamio{I_PLINK}'ed streams can by unlinked with the @ioctlref{I_PUNLINK}
@manpage{ioctl(2)} command.  When the control stream is closed, all @streamio{I_LINK}'ed streams are
automatically unlinked.  @streamio{I_PLINK}'ed streams remain linked until the last upper stream of
the @dfn{Multiplexer} is closed, at which time the @dfn{Multiplexer} is dismantled and the
@streamio{I_PLINK}'ed streams are @streamio{I_PUNLINK}'ed and closed.

@end table

A simple stream is illustrated in @figref{1}.

@figuresized{SPG_fig01,1,Simple Stream,4in}

In the simple stream, the @dfn{downstream} flow is the flow from the User Process to the Driver that
passes through any optional intervening Modules; the @dfn{upstream} flow is the flow from the Driver
to the User Process, again through any intervening Modules.

It is possible to have a stream that does not contain a module or driver.  There are two types of
streams that do not contain a module or driver: a pipe and a @dfn{FIFO} (named pipe).

A @dfn{STREAMS}-based pipe is illustrated in @figref{2}.

@figuresized{SPG_fig02,2,@dfn{STREAMS}-based Pipe,4in}

A @dfn{STREAMS}-based @dfn{FIFO} is illustrated in @figref{7}.

@figuresized{SPG_fig07,7,@dfn{STREAMS}-based @dfn{FIFO} (named pipe),4in}

Each @dfn{STREAMS} driver or module has a number of constituent pieces.  Each @dfn{STREAMS} driver
or module contains a stream table, stream administration, module information, module statistics and
queue initialization information.

Each instance of a @dfn{STREAMS} driver or module has associated with it a stream head and a stream
end (the driver).  Each instance of a @dfn{STREAMS} driver or module contains a queue pair with a
write (downstream) and read (upstream) queue.  Each queue possibly has queue band information
associated with the queue.

Each @dfn{STREAMS} queue and queue band can contain @dfn{STREAMS} messages.  @dfn{STREAMS}
messages are composed of message blocks, data blocks and data buffers in a chain-buffer arrangement.

@figuresized{SPG_fig09,9,Message Overview,4in}

@figref{9} illustrates a @dfn{STREAMS} message.  Messages are strings of message blocks.  Each
message block refers to a data block.  Each data block has a data area associated with it.  The
data block has a message type (@samp{db_type}) associated with it.  Message types can be one of the
following:

@subheading Normal Messages

@multitable @columnfractions .20 .05 .05 .70
@item @msg{M_DATA} @tab D @tab U @tab data to or from the user
@item @msg{M_PROTO} @tab D @tab U @tab protocol primitive
@item @msg{M_BREAK} @tab D @tab - @tab request a driver to send a break in the medium
@item @msg{M_CTL} @tab D @tab U @tab used for inter-module and driver communication
@item @msg{M_DELAY} @tab D @tab - @tab requests a real-time delay in output processing
@item @msg{M_IOCTL} @tab D @tab - @tab passes a streams ioctl call
@item @msg{M_PASSFP} @tab D @tab U @tab user be stream heads to pass file pointers to each other (e.g. pipes)
@item @msg{M_RSE} @tab D @tab U @tab reserved
@item @msg{M_SETOPTS} @tab - @tab U @tab set options on the stream head
@item @msg{M_SIG} @tab - @tab U @tab sends a signal to the user
@end multitable

@subheading Priority Messages

@multitable @columnfractions .20 .05 .05 .70
@item @msg{M_COPYIN} @tab - @tab U @tab copy data from user for transparent ioctl
@item @msg{M_COPYOUT} @tab - @tab U @tab copy data to user for transparent ioctl
@item @msg{M_ERROR} @tab - @tab U @tab sends a fatal error to the stream head
@item @msg{M_FLUSH} @tab D @tab U @tab requests that driver and modules discard messages
@item @msg{M_HANGUP} @tab - @tab U @tab indicates to the stream head that no more data can be read or written
@item @msg{M_IOCACK} @tab - @tab U @tab acknowledges an ioctl request
@item @msg{M_IOCNAK} @tab - @tab U @tab negatively acknowledges an ioctl request
@item @msg{M_IOCDATA} @tab D @tab - @tab provides data requested by a @msg{M_COPYIN}
@item @msg{M_PCPROTO} @tab D @tab U @tab priority protocol primitive
@item @msg{M_PCRSE} @tab D @tab U @tab reserved
@item @msg{M_PCSIG} @tab - @tab U @tab sends a priority signal to the user
@item @msg{M_READ} @tab D @tab - @tab sent by the stream head when the user issues an unsatisfied
@manref{read(2)}
call
@item @msg{M_STOP} @tab D @tab - @tab requests that a device stop its output
@item @msg{M_START} @tab D @tab - @tab request that a device start its output
@item @msg{M_STARTI} @tab D @tab - @tab requests that a device start its input
@item @msg{M_STOPI} @tab D @tab - @tab requests that a device stop its input
@end multitable

Message functions consist of the following:

@multitable @columnfractions .30 .70
@item @manpage{adjmsg(9)} @tab trims bytes from the front or back of a message
@item @manpage{allocb(9)} @tab allocates a combined message and data block
@item @manpage{bufcall(9)} @tab calls a specified function when buffers become available
@item @manpage{copyb(9)} @tab copies a message block including the data
@item @manpage{copymsg(9)} @tab copies all the message blocks and data making up a message
@item @manpage{datamsg(9)} @tab tests if the message is a data message (@msg{M_DATA}, @msg{M_PROTO}, ...)
@item @manpage{dupb(9)} @tab duplicates a message block but references the same data
@item @manpage{dupmsg(9)} @tab duplicates all message blocks making up a message but references the
same data in each message block
@item @manpage{esballoc(9)} @tab allocates a message block and data block but references a
user-provided data and free function
@item @manpage{freeb(9)} @tab frees a message block
@item @manpage{freemsg(9)} @tab frees an entire message
@item @manpage{linkb(9)} @tab links a message block onto the end of a message
@item @manpage{msgdsize(9)} @tab counts the bytes in @msg{M_DATA} blocks in a message
@item @manpage{pullupmsg(9)} @tab places data from an entire message into a single message block
@item @manpage{unbufcall(9)} @tab cancels an earlier buffer callback request
@item @manpage{unlinkb(9)} @tab remove the first message block in a message
@end multitable

Messages can be priority or normal messages.  Priority messages are delivered ahead of normal
messages.  Normal messages can be in one of 256 bands (0-255).  Band @samp{n} messages are delivered
ahead of band @samp{m} messages where @samp{n>m}.  Queues are scheduled whenever messages are placed
on the tail of the queue.  Queues are scheduled whenever priority messages exist in a queue,
regardless of whether they were placed on the tail or the head of the queue.  Care must be taken not
to return a priority message to the head of the queue in a service procedure or the service
procedure will simply be rescheduled.

Buffers can be allocated as @constant{BPRI_HI},
@constant{BPRI_MED},
@constant{BPRI_LO}
and @constant{BRPI_WAITOK}.
In many @dfn{STREAMS} implementations, these priorities have no meaning.

A buffer that is smaller than a given size (@constant{FASTBUF})
will be allocated more quickly.  This is because the buffer is allocated coincident with the message
block and data block.

When the system runs out of buffer, it will return failure to @manpage{allocb(9)}
and @manpage{esballoc(9)}.
@manpage{bufcall(9)}
or @manpage{esbbcall(9)}
can be used to have the @dfn{STREAMS} subsystem call a client function when a buffer of the given
size is available.  Care must be taken with the use of @manpage{bufcall(9)}
that deadlock situations do not arise.

@figuresized{SPG_fig03,3,Stream to Communications Driver,4in}

Each module in a stream consists of a pair of queues: one for read (upstream) and one for write
(downstream).  Each queue is one of a pair of queues, see @figref{4}.  Where @samp{q} is one of the
queues in the pair, the paired queue is identified by @samp{OTHERQ(q)}.  Where @samp{q} is the write
queue in the pair, the read queue is identified by @samp{RD(q)}.  The read queue is for messages
ultimately read by the user.  Where @samp{q} is the read queue in the pair, the write queue is
identified by @samp{WR(q)}.  The write queue is for messages first written by the user.

@figuresized{SPG_fig04,4,Queue Pair Allocation,0.5in}

Queue functions consist of the following:

@multitable @columnfractions .30 .70
@item @manpage{backq(9)} @tab obtains a pointer to the previous queue in a stream
@item @manpage{bcanput(9)} @tab tests for flow-control in a particular priority band
@item @manpage{canput(9)} @tab test flow-control
@item @manpage{enableok(9)} @tab marks a queue as being ready to be enabled
@item @manpage{flushband(9)} @tab removes all queued messages in a specified priority band
@item @manpage{flushq(9)} @tab removes all messages from a queue
@item @manpage{getadmin(9)} @tab finds the pointer to the @code{qi_qadmin()} function for a module
@item @manpage{getmid(9)} @tab looks up the module identifier
@item @manpage{getq(9)} @tab gets a message from a queue
@item @manpage{insq(9)} @tab inserts a message at a given point in a queue
@item @manpage{noenable(9)} @tab stops a queue from being scheduled
@item @manpage{OTHERQ(9)} @tab finds the sibling of a given queue
@item @manpage{putbq(9)} @tab puts back a message on a queue
@item @manpage{putctl(9)} @tab puts a control (e.g., @msg{M_CTL}) message on a queue
@item @manpage{putctl1(9)} @tab puts a 1-byte control message on a queue
@item @manpage{putnext(9)} @tab passes a message to the next queue in a stream
@item @manpage{putq(9)} @tab puts a message on a queue
@item @manpage{qenable(9)} @tab schedule a queue
@item @manpage{qreply(9)} @tab passes a reply along a stream in the opposite direction
@item @manpage{qsize(9)} @tab returns the number of message on a queue
@item @manpage{RD(9)} @tab finds the read queue
@item @manpage{rmvq(9)} @tab removes a message from the middle of a queue
@item @manpage{strqget(9)} @tab queries the information from a queue
@item @manpage{WR(9)} @tab finds the write queue
@end multitable

The queue open procedure is called whenever a driver special character device is opened.  It is also
called when a module is pushed onto a stream.

The queue close procedure is called when a driver special character device is closed for the last
time.  It is also called when a module is popped from a stream.

The queue put procedure is called whenever a previous queue in the stream passes a message to the
queue, or a message is otherwise placed on the queue with the @manpage{put(9)}
function.

The queue service procedure is called when there are messages on the queue to be serviced and the
@dfn{STREAMS} subsystem has scheduled the queue for service.

Put and service procedures must handle
@msg{M_DATA},
@msg{M_PROTO},
@msg{M_PCPROTO},
@msg{M_FLUSH}
and
@msg{M_IOCTL}
messages.  Other messages are more or less optional.

Module put and service procedures should pass any unrecognized message types along.  Module put and
service procedures should pass any unrecognized @msg{M_IOCTL}
@manpage{ioctl(2)} commands along.
Modules must perform canonical flushing in response to
@msg{M_FLUSH}
messages.  This includes passing @msg{M_FLUSH}
messages along downstream or upstream.

Driver put and service procedures should discard any unrecognized message types.  Driver put and
service procedures should negatively acknowledge (@msg{M_IOCNAK})
any unrecognized @msg{M_IOCTL}
commands.
Drivers must perform canonical flushing in response to
@msg{M_FLUSH}
messages.  This includes sending @msg{M_FLUSH}
message that arrive on their way downstream to the upstream queues (@manpage{qreply(9)}).

Queue scheduling pertains to when a queue's service procedure is schedule to run by the kernel.
When a queue's service procedure is scheduled to run, the queue is considered enabled.  When a
queue's service routine is prohibited from running, it is considered disabled.  Only queues that
have service procedures can become enabled.  Queues with only @manpage{put(9)}
procedures are never enabled.

Queues are enabled whenever a priority messages is placed on the queue.  Queues are enable whenever
@manpage{qenable(9)}
is called explicitly.
Queues are also enabled as a result of back-enabling.  A queue is back-enabled when it previously
tested the next queue for flow control and found the queue flow controlled (the queue had passed its
high water mark); the queue which was previously test is now no longer flow controlled (it has
fallen below its low water mark); the queue which previously tested can now put to the queue which
was flow controlled.

Queues are disabled whenever the queue service procedure has run.  Queues are disabled whenever
@manpage{noenable(9)}
has been called explicitly.  Queues are disabled whenever they are empty.

Flow control pertains to when a queue will accept messages put to it from above and below.  When the
number of bytes in a  queue passes the high water mark associated with the queue, the queue is
considered flow controlled.  Flow controlled queues will fail a @manpage{canput(9)}
call.  When the number of bytes in a flow controlled queue falls below the low water mark, the queue
is considered available to process messages again.  Only queues that have a service procedure can
become flow controlled.  Only queues that have service procedures need check for flow control
downstream.

It is the responsibility of a module performing a @manpage{putq(9)}, a @manpage{putnext(9)} or a
@manpage{qreply(9)} to a queue to check for flow control with @manpage{canput(9)},
@manpage{canputnext(9)}, @manpage{bcanput(9)}
or
@manpage{bcanputnext(9)}
before placing the message on a queue.
Modules that receive messages when they are flow controlled might discard them.
Flow control kicks in when the number of byte queued passes the queue's high water mark.

Back-enabling occurs when a queue that was previously flow controlled, drops below its low water
mark, and was tested while it was flow controlled.  Flow control can be difficult to accomplish
correctly in drivers and across multiplexers.



@dfn{STREAMS} drivers, modules and multiplexing drivers are described with a series of statically
allocated structures beginning with the driver switch table or module switch table entries.

@menu
* Stream Administration::
* Driver Switch Table::
* Module Switch Table::
* Stream Table::
* Queue Initialization::
* Module Information::
* Module Statistics::
* Stream Head::
* Queue::
* Queue Band::
* Message Block::
* Data Block::
* Data Buffer::
* User Credentials::
@end menu

@node Stream Administration
@subsection Stream Administration
@cindex Stream Administration

Some @dfn{STREAMS} implementation also provide some sort of @dfn{STREAMS} administration structure
that contains more specific information about a @dfn{STREAMS} driver or module, such as the name of
the driver or module, synchronization, administrative flags, version, etc.  These administrative
structures are normally passed to the registration procedure to register a driver or module.
Implementations that function this way are @cite{AIX},
@cindex AIX
@cite{OSF/1},
@cindex OSF/1
@cite{HP-UX}
@cindex HP-UX
and
@cite{UnixWare}.
@cindex UnixWare

@cite{AIX}
@cindex AIX
uses the @type{strconf_t}
structure and calls the @manpage{str_install_AIX(9)}
registration function.
@cite{OSF/1}
@cindex OSF/1
uses the @mantype{streamadm(9)}
structure and calls the @manpage{strmod_add(9)}
and @manpage{strmod_del(9)}
registration functions.
@cite{HP-UX}
@cindex HP-UX
uses the @mantype{stream_inst(9)}
structure and calls the @manpage{str_install_HPUX(9)}
and @manpage{str_uninstall(9)}
registration functions.

The @header{sys/strconf.h} header file contains definitions for both the @dfn{STREAMS} administrative
structures as well as declarations and function prototypes for the registration functions.

Other @dfn{STREAMS} implementations use the character device switch table or module switch table
entries themselves.  The partially completed entry might still be passed to the registration
function like a @dfn{STREAMS} administrative structure.
Implementations that function this way are @cite{Solaris}
@cindex Solaris
and
@dfn{@value{PACKAGE_TITLE}}.
@cindex @value{PACKAGE_TITLE}

@cite{Solaris}
@cindex Solaris
uses a plethora of statically allocated structures to describe @dfn{STREAMS} drivers and modules.
Several of these structures correspond to the character device (well, character and block device)
switch table entry as well as the module switch table entry.
@cite{@value{PACKAGE_TITLE}}
@cindex @value{PACKAGE_TITLE}
uses the actual character device switch table and module switch table structures and calls the
@manpage{register_strdrv(9)}
and
@manpage{register_strmod(9)}
registration functions.

Some implementations use a registration function alone and do not pass a structure.

@node Driver Switch Table
@subsection Driver Switch Table
@cindex Driver Switch Table

Each @dfn{STREAMS} device or pseudo-device driver or multiplexing driver registers itself with the
@dfn{STREAMS} subsystem.  Nevertheless, to allow user processes to open the @dfn{STREAMS} device
requires that the device by entered into the system device switch tables.  @cite{SVR 3} had a device
switch table and many other @cite{UNIX} implementations do as well.  @b{Linux} does not use a device
switch table.  Rather it uses character device lists hashed on device number, or a file system
mechanism such as the device file system (@samp{devfs}) or @samp{udev}.  @dfn{@value{PACKAGE_TITLE}}
registers devices with the necessary @b{Linux} mechanism and then implements an internal device
switch table as a list hashed on device number.

Normally, @dfn{STREAMS} implementations have some mechanism for registering a driver with the
character device switch table or other structures used for opening @dfn{STREAMS} devices.  Some
configuration procedure take structures (e.g. @cite{Solaris}), some do not.  Each
configuration technique is unique to that implementation.  @dfn{@value{PACKAGE_TITLE}} supports its
own registration technique as well as several of the other more common implementation methods.
@dfn{@value{PACKAGE_TITLE}} has its own registration procedure that consists of first completing a
static @mantype{cdevsw(9)}
structure for entry into the @mantype{cdevsw_list(9)},
which is @dfn{@value{PACKAGE_TITLE}}'s equivalent of a character device switch table.

The character device switch table entry structure (@mantype{cdevsw(9)})
structure takes the following information:

@multitable @columnfractions .15 .85
@item @code{d_list} @tab list of all cdevsw structures
@item @code{d_hash} @tab list of module hashes in slot
@item @code{d_name} @tab driver name
@item @code{d_str} @tab pointer to @mantype{streamtab(9)} for driver
@item @code{d_flag} @tab driver flags
@item @code{d_modid} @tab driver module identifier
@item @code{d_count} @tab open count
@item @code{d_sqlvl} @tab synchronization level
@item @code{d_syncq} @tab synchronization queue
@item @code{d_kmod} @tab kernel module
@item @code{d_major} @tab base major device number
@item @code{d_inode} @tab specfs inode
@item @code{d_mode} @tab inode mode
@item @code{d_fop} @tab file operations
@item @code{d_majors} @tab major device nodes for this device
@item @code{d_minors} @tab minor device nodes for this device
@item @code{d_apush} @tab autopush list
@item @code{d_plinks} @tab permanent links for this driver
@item @code{d_stlist} @tab stream head list for this driver
@end multitable

Only the driver name, @mantype{streamtab(9)}
pointer, flags and synchronization level need be completed by the module writer: the remaining
fields in the @mantype{cdevsw(9)}
structure will be populated by the registration procedure.
The procedure used by @dfn{@value{PACKAGE_TITLE}} for registering @dfn{STREAMS} drivers is the
@manpage{register_strdrv(9)}
kernel function.

@node Module Switch Table
@subsection Module Switch Table
@cindex Module Switch Table

Each @dfn{STREAMS} module registers itself with the @dfn{STREAMS} subsystem and is assigned a
unique module identification number.  Even @dfn{STREAMS} device or pseudo-device driver's are
assigned a unique module identification number.  In most @dfn{STREAMS} implementations, modules are
entered by module identification number into a module switch table.  @dfn{@value{PACKAGE_TITLE}}
implements an internal module switch table as a list hashed on module identifier.

Normally, @dfn{STREAMS} implementations have some mechanism for registering a module with the module
switch table or other structures used for opening @dfn{STREAMS} modules.  Some configuration
procedures take structures (e.g. @cite{Solaris}), some do not.  Each configuration
technique is unique to that implementation.  @dfn{@value{PACKAGE_TITLE}} supports its own
configuration technique as well as several of the other more common implementation methods.
@dfn{@value{PACKAGE_TITLE}} has its own registration procedure that consists of first completing a
static @mantype{fmodsw(9)} structure for entry into the @mantype{fmodsw_list(9)}, which is
@dfn{@value{PACKAGE_TITLE}}'s equivalent of a module switch table.

The module switch table entry structure (@mantype{fmodsw(9)}) structure takes the following
information:

@multitable @columnfractions .15 .85
@item @code{f_list} @tab list of all fmodsw structures
@item @code{f_hash} @tab list of module hashes in slot
@item @code{f_name} @tab module name
@item @code{f_str} @tab pointer to @mantype{streamtab(9)} for module
@item @code{f_flag} @tab module flags
@item @code{f_modid} @tab module identifier
@item @code{f_count} @tab open count
@item @code{f_sqlvl} @tab synchronization level
@item @code{f_syncq} @tab synchronization queue
@item @code{f_kmod} @tab kernel module
@end multitable

Only the module name, @mantype{streamtab(9)} pointer, flags and synchronization level need be
completed by the module writer: the remaining fields in the @mantype{fmodsw(9)} structure will be
populated by the registration procedure.  The procedure used by @dfn{@value{PACKAGE_TITLE}} for
registering @dfn{STREAMS} modules is the @manpage{register_strmod(9)} kernel function.  It is no
coincidence that the @code{fmodsw} structure is identical to the first portion of the @code{cdevsw}
structure.

@node Stream Table
@subsection Stream Table
@cindex Stream Table

Each @dfn{STREAMS} driver or module has an external entry point into a streams table.  The stream
table structure is the jumping off point for all driver or module specific data structures that
describe the @dfn{STREAMS} driver or module.  Each @dfn{STREAMS} driver or module that is unique
within the @dfn{STREAMS} subsystem has a unique stream table, regardless of which device major
numbers, module identifiers, or other external registrations have been performed on behalf of the
driver of module.

The stream table structure (@mantype{streamtab(9)})
contains the following information:

@multitable @columnfractions .15 .85
@item @code{st_rdinit} @tab read queue init structure pointer
@item @code{st_wrinit} @tab write queue init structure pointer
@item @code{st_muxrinit} @tab multiplexer lower read queue init structure pointer
@item @code{st_muxwinit} @tab multiplexer lower write queue init structure pointer
@end multitable

Only the @code{st_rdinit} and @code{st_wrinit} members need be completed for a normal module or
driver.  For a multiplexing driver that accepts the @ioctlref{I_LINK} or @ioctlref{I_PLINK}
@manref{ioctl(2)} commands, the lower queue initialization information, @code{st_muxrinit} and
@code{st_muxwinit} must be completed as well.

@node Queue Initialization
@subsection Queue Initialization
@cindex Queue Initialization

Each stream table (driver or module) has associated with it queue initialization information for the
upstream and downstream queues.  If the driver is a multiplexing driver, it may also have associated
with the stream table upstream and downstream queue initialization information for the lower queue
pair.

The queue initialization structure provides function pointers to the put, service, open, close and
administrative procedures for the queue to which the initialization structure belongs.  Queue
initialization structures are bound to a specific upper or lower, upstream or downstream queue using
the stream table.  Up to four queue initialization structures can exist for a driver or module, or,
it is possible that all four queues could share a single queue initialization
structures.@footnote{Only the open and close procedures indicated in the queue initialization
structure associated with an upper upstream (read) queue will be used to open and close an instance
of the driver or module.  Open and close function pointers in the other queue initialization
structures will be ignored.}

The queue initialization structure (@mantype{qinit(9)})
contains the following information:

@multitable @columnfractions .15 .85
@item @code{qi_putp} @tab put procedure
@item @code{qi_srvp} @tab service procedure
@item @code{qi_qopen} @tab each open (read queue only)
@item @code{qi_qclose} @tab last close (read queue only)
@item @code{qi_qadmin} @tab administrative procedure (not used)
@item @code{qi_minfo} @tab module information
@item @code{qi_mstat} @tab module statistics
@end multitable

@node Module Information
@subsection Module Information
@cindex Module Information

Each queue initialization structure points to a module information structure that provides some
queueing parameters for the stream.  Nevertheless, only one module information structure is necessary
for the stream.  The module information structure contains the module identifier, the module name,
the minimum and maximum packet sizes accepted on the queue from the stream head, and the high and
low water marks for flow control.  If any of this later information needs to differ on a queue basis
(upper or lower multiplex queues considered as well), then the module information structure must be
separate for each queue.

The module information structure (@mantype{module_info(9)})
contains the following information:

@multitable @columnfractions .15 .85
@item @code{mi_idnum} @tab module identification number
@item @code{mi_idname} @tab module name
@item @code{mi_minpsz} @tab minimum packet size accepted
@item @code{mi_maxpsz} @tab maximum packet size accepted
@item @code{mi_hiwat} @tab high water mark
@item @code{mi_lowat} @tab low water mark
@end multitable

@node Module Statistics
@subsection Module Statistics
@cindex Module Statistics

Each queue initialization structure points to an optional module statistics structure that collects
statistics for the stream.

The module statistics structure (@mantype{module_stat(9)})
contains the following information:

@multitable @columnfractions .15 .85
@item @code{ms_pcnt} @tab calls to @code{qi_putp}
@item @code{ms_scnt} @tab calls to @code{qi_srvp}
@item @code{ms_ocnt} @tab calls to @code{qi_qopen}
@item @code{ms_ccnt} @tab calls to @code{qi_qclose}
@item @code{ms_acnt} @tab calls to @code{qi_qadmin}
@item @code{ms_xptr} @tab module private statistics pointer
@item @code{ms_xsize} @tab size of module private statistics area
@item @code{ms_flags} @tab boolean statistics, for future use
@end multitable

@node Stream Head
@subsection Stream Head
@cindex Stream Head

A stream head is a dynamic structure that is created whenever a @dfn{STREAMS} driver (stream end)
is instantiated. 

The stream head accepts the following input-output controls:

@multitable @columnfractions .30 .70
@item @streamio{I_PUSH} @tab push a module
@item @streamio{I_POP} @tab pop a module
@item @streamio{I_SETSIG} @tab receive a @signal{SIGPOLL} signal when an event occurs
@item @streamio{I_FDINSERT} @tab pass information about a stream
@item @streamio{I_STR} @tab generate an @manpage{ioctl(2)} to a streams module
@item @streamio{I_SENDFD} @tab send a file descriptor down a stream
@item @streamio{I_LINK} @tab link a stream under a multiplexer
@item @streamio{I_PLINK} @tab permanently link a stream under a multiplexer
@item @streamio{I_LOOK} @tab get name of module below stream head
@item @streamio{I_FLUSH} @tab flush a stream
@item @streamio{I_FLUSHBAND} @tab flush a stream in a given band
@item @streamio{I_GETSIG} @tab return events that generate @signal{SIGPOLL}
@item @streamio{I_FIND} @tab find a particular module in a stream
@item @streamio{I_PEEK} @tab read first message on a stream
@item @streamio{I_SRDOPT} @tab set read options
@item @streamio{I_GRDOPT} @tab get read options
@item @streamio{I_SWROPT} @tab set write options
@item @streamio{I_GWROPT} @tab get write options
@item @streamio{I_RECVFD} @tab retrieve a passed file descriptor 
@item @streamio{I_LIST} @tab list all modules in a stream
@item @streamio{I_ATMARK} @tab see if stream head message has been marked
@item @streamio{I_CKBAND} @tab check if message of a particular band is writable
@item @streamio{I_GETBAND} @tab get priority band of first message at stream head
@item @streamio{I_CANPUT} @tab check if given band is writable
@item @streamio{I_SETCLTIME} @tab set the time that @dfn{STREAMS} will wait while closing
@item @streamio{I_GETCLTIME} @tab get the time that @dfn{STREAMS} will wait while closing
@item @streamio{I_UNLINK} @tab unlink a stream from beneath a multiplexer
@item @streamio{I_PUNLINK} @tab unlink a permanent stream from beneath a multiplexer
@end multitable

@multitable @columnfractions .30 .70
@item @stropt{SO_ALL} @tab set all old options
@item @stropt{SO_READOPT} @tab set read option
@item @stropt{SO_WROFF} @tab set write offset
@item @stropt{SO_MINPSZ} @tab set minimum packet size
@item @stropt{SO_MAXPSZ} @tab set maximum packet size
@item @stropt{SO_HIWAT} @tab set high water mark
@item @stropt{SO_LOWAT} @tab set low water mark
@item @stropt{SO_MREADON} @tab set read notification on
@item @stropt{SO_MREADOFF} @tab set read notification off
@item @stropt{SO_NDELON} @tab old @dfn{TTY} semantics for @constant{NDELAY} reads and writes
@item @stropt{SO_NDELOFF} @tab @dfn{STREAMS} semantics for @constant{NDELAY} reads and writes
@item @stropt{SO_ISTTY} @tab the stream is acting as a terminal
@item @stropt{SO_ISNTTY} @tab the stream is not acting as a terminal
@item @stropt{SO_TOSTOP} @tab stop on background writes to this stream
@item @stropt{SO_TONSTOP} @tab do not stop on background writes to this stream
@item @stropt{SO_BAND} @tab water marks affect band
@item @stropt{SO_DELIM} @tab messages are delimited
@item @stropt{SO_NODELIM} @tab turn off delimiters
@item @stropt{SO_STRHOLD} @tab @cite{UnixWare} and @cite{Solaris} only: enable strwrite message coalescing
@item @stropt{SO_ERROPT} @tab @cite{Solaris} only
@item @stropt{SO_LOOP} @tab @cite{UnixWare} only
@item @stropt{SO_COPYOPT} @tab @cite{Solaris} only: user io copy options
@item @stropt{SO_MAXBLK} @tab @cite{Solaris} only: maximum block size
@end multitable

@multitable @columnfractions .30 .70
@item @constant{IOCWAIT} @tab ioctl in progress
@item @constant{RSLEEP} @tab process sleeping on read
@item @constant{WSLEEP} @tab process sleeping on write
@item @constant{STRPRI} @tab priority message waiting
@item @constant{STRHUP} @tab stream is hung up
@item @constant{STWOPEN} @tab strem head open in progress
@item @constant{STPLEX} @tab stream linked under mux
@item @constant{STRISTTY} @tab stream is a terminal
@item @constant{STRDERR} @tab @msg{M_ERROR} for read received
@item @constant{STWRERR} @tab @msg{M_ERROR} for write received
@item @constant{STRCLOSE} @tab wait for strclose to complete
@item @constant{SNDMREAD} @tab send @msg{M_READ} msg when read issued
@item @constant{STRHOLD} @tab coalesce written messages
@item @constant{STRMSIG} @tab @msg{M_SIG} at head of queue
@item @constant{STRDELIM} @tab generate delimited messages
@item @constant{STRTOSTOP} @tab stop timeout
@item @constant{STRISFIFO} @tab stream is a fifo
@item @constant{STRISPIPE} @tab stream is a @dfn{STREAMS} pipe
@item @constant{STRISSOCK} @tab stream is a @dfn{STREAMS} socket
@item @constant{STFROZEN} @tab stream is frozen
@end multitable

@node Queue
@subsection Queue
@cindex Queue

A pair of queues are allocated, initialized, assigned and linked into a stream each time that a
@dfn{STREAMS} driver or module is instantiated.  A pointer to the upstream (read) queue in the
queue pair is the common method for passing a handle to a driver or module instance.

@node Queue Band
@subsection Queue Band
@cindex Queue Band

Queue bands are allocated and initialized in association with queues on demand.  Many @dfn{STREAMS}
drivers or modules never have queue bands allocated because they do not pass priority banded
messages, only normal messages.

@node Message Block
@subsection Message Block
@cindex Message Block

A message block is a structure that references a data block and data buffer.  Each message block is
a view into a data buffer and has a start (read pointer) and finish (write pointer) within the
buffer.  Message block can be chained together to form larger segmented messages.

@node Data Block
@subsection Data Block
@cindex Data Block

Data blocks are a description of a data buffer external to the buffer itself.  Each data block
describes the limits of the data buffer, its base, and size.  Each data block also hold a number of
flags and contains a data block type describing the type of data contained in the data buffer.  Data
blocks also contain any necessary information concerning the functions and arguments necessary to
free the data buffer.  Also, data blocks maintain reference counts of the number of message blocks
that reference the data buffer.

@subsubsection Data Block Types
@cindex Data Block Types

@node Data Buffer
@subsection Data Buffer
@cindex Data Buffer

Data buffers can be allocated within the @dfn{STREAMS} buffer pools using the @manpage{allocb(9)}
function or can be allocated externally and associated with a data and message block using the
@manpage{esballoc(9)}
function.

@node User Credentials
@subsection User Credentials
@cindex User Credentials

@node Application Interface
@section Application Interface
@cindex @dfn{STREAMS}, application interface
@cindex application interface, @dfn{STREAMS}

@subsection System Calls

@multitable @columnfractions .30 .70
@item @manpage{close(2)} @tab --
@item @manpage{fattach(2)} @tab --
@item @manpage{fcntl(2)} @tab --
@item @manpage{fdetach(2)} @tab --
@item @manpage{getmsg(2)} @tab --
@item @manpage{getpmsg(2)} @tab --
@item @manpage{ioctl(2)} @tab --
@item @manpage{isastream(2)} @tab --
@item @manpage{open(2)} @tab --
@item @manpage{pipe(2)} @tab --
@item @manpage{poll(2)} @tab --
@item @manpage{putmsg(2)} @tab --
@item @manpage{putpmsg(2)} @tab --
@item @manpage{read(2)} @tab --
@item @manpage{readv(2)} @tab --
@item @manpage{select(2)} @tab --
@item @manpage{write(2)} @tab --
@item @manpage{writev(2)} @tab --
@end multitable

@node Kernel Level Facilities
@section Kernel Level Facilities
@cindex kernel level facilities
@cindex @dfn{STREAMS}, kernel level facilities
@cindex kernel level facilities, @dfn{STREAMS}

@subsection Stream Head

@subsection Modules

@subsection Drivers

@subsection Messages

@figuresized{SPG_fig05,5,A Message,5in}

@figuresized{SPG_fig06,6,Messages on a Message Queue,5in}

@subsubsection Message Types

@subsubheading Normal Messages

@multitable @columnfractions .20 .05 .05 .70
@item @msg{M_DATA} @tab D @tab U @tab Normal data.
@item @msg{M_PROTO} @tab D @tab U @tab Normal protocol information.
@item @msg{M_BREAK} @tab D @tab -- @tab Break request.
@item @msg{M_PASSFP} @tab D @tab U @tab Passed file pointer.
@item @msg{M_EVENT} @tab -- @tab U @tab Normal event.  (@cite{Solaris} only)
@item @msg{M_SIG} @tab -- @tab U @tab Signal.
@item @msg{M_DELAY} @tab D @tab -- @tab Delay request.
@item @msg{M_CTL} @tab D @tab U @tab Normal inter-module control message.
@item @msg{M_IOCTL} @tab D @tab -- @tab Input-Output control.
@item @msg{M_SETOPTS} @tab -- @tab U @tab Normal set queue options.
@item @msg{M_RSE} @tab D @tab U @tab Normal reserved.
@item @msg{M_TRAIL} @tab -- @tab -- @tab (@cite{UnixWare} only)
@item @msg{M_BACKWASH} @tab D @tab -- @tab (@cite{AIX} only)
@end multitable

@subsubheading Priority Messages

@multitable @columnfractions .20 .05 .05 .70
@item @msg{M_IOCACK} @tab -- @tab U @tab Input-Output control acknowledgement (result).
@item @msg{M_IOCNAK} @tab -- @tab U @tab Input-Output control negative acknowledgement (error).
@item @msg{M_PCPROTO} @tab D @tab U @tab Priority protocol information.
@item @msg{M_PCSIG} @tab -- @tab U @tab Priority signal.
@item @msg{M_READ} @tab D @tab -- @tab Read request.
@item @msg{M_FLUSH} @tab D @tab U @tab Flush queue request.
@item @msg{M_STOP} @tab D @tab -- @tab Stop output request.
@item @msg{M_START} @tab D @tab -- @tab Start output request.
@item @msg{M_HANGUP} @tab -- @tab U @tab Hangup.
@item @msg{M_ERROR} @tab -- @tab U @tab Fatal error.
@item @msg{M_COPYIN} @tab -- @tab U @tab Input-Output control copyin request.
@item @msg{M_COPYOUT} @tab -- @tab U @tab Input-Output control copyout request.
@item @msg{M_IOCDATA} @tab D @tab -- @tab Input-Output control copied in data.
@item @msg{M_PCRSE} @tab D @tab U @tab Priority reserved.
@item @msg{M_STOPI} @tab D @tab -- @tab Stop input request.
@item @msg{M_STARTI} @tab D @tab -- @tab Start input request.
@item @msg{M_PCCTL} @tab D @tab U @tab Priority inter-module control message.  (@cite{UnixWare} only)
@item @msg{M_PCSETOPTS} @tab -- @tab U @tab Priority set queue options.  (@cite{UnixWare} only)
@item @msg{M_PCEVENT} @tab -- @tab U @tab Priority event.  (@cite{Solaris} only)
@item @msg{M_UNHANGUP} @tab -- @tab U @tab Hangup corrected.  (@cite{Solaris} and @cite{OSF/1} only)
@item @msg{M_NOTIFY} @tab -- @tab U @tab (@cite{OSF/1} and @cite{HP-UX} only)
@item @msg{M_HPDATA} @tab D @tab U @tab (@cite{HP-UX} and @cite{MacOT} only)
@item @msg{M_LETSPLAY} @tab -- @tab U @tab (@cite{AIX} only)
@item @msg{M_DONTPLAY} @tab D @tab -- @tab (@cite{AIX} only)
@item @msg{M_BACKDONE} @tab D @tab -- @tab (@cite{AIX} only)
@end multitable

@subsection Message Queueing Priority

@subsection Queues

@subsection Multiplexing

@subsection Multithreading

@node Subsystems
@section Subsystems
@cindex subsystems, STREAMS
@cindex STREAMS, subsystems

@menu
* Logging::			STREAMS Logging
* Administrative Driver::	STREAMS Administrative Driver
* Terminal I/O::		STREAMS Terminal I/O
* Pipes::			STREAMS Pipes
* FIFOs::			STREAMS FIFOs
* Networking::			STREAMS Networking
@end menu

@node Logging
@subsection Logging
@cindex logging, STREAMS
@cindex STREAMS, logging

The kernel logger and system logger on a @b{Linux} system is the native logging implementation.
These are @cite{BSD}-style loggers.  @dfn{@value{PACKAGE_TITLE}} provides a @dfn{STREAMS}-based logger as
well.  The advantage of a @dfn{STREAMS}-based logger is for trace and error logging @dfn{STREAMS}
drivers and modules using the @command{strlog} facility.  This facility includes a device driver
(the @dfn{STREAMS} log device, @manpage{log(4)}),
a kernel function (@manpage{strlog(9)}),
and two user space daemon processes (@manpage{strace(8)}
and @manpage{strerr(8)}).
The @dfn{STREAMS} logger has the unique capability that it can filter trace messages and only incur
the cost of tracing and logging those messages that are filtered out (at the kernel level).  This
allows a large degree of trace logging to be available, yet, only a small proportion of the
available trace messages generated to logs.

The @dfn{STREAMS} logger @manpage{log(4)},
@manpage{strlog(9)}
command, and @manpage{strace(8)}
and @manpage{strerr(8)}
loggers are all available in the base @code{@value{PACKAGE}-@value{VERSION}} package.

@node Administrative Driver
@subsection Administrative Driver
@cindex administrative driver, STREAMS
@cindex STREAMS, administrative driver

@dfn{@value{PACKAGE_TITLE}} provides a @dfn{STREAMS} administration facility.  This facility
consists of a driver (the @dfn{STREAMS Administrative Driver}, @manpage{sad(4)}),
several autopush kernel functions (@manpage{autopush_add(9)},
@manpage{autopush_del(9)},
@manpage{autopush_find(9)},
@manpage{autopush_vml(9)}),
and the @manpage{autopush(8)},
@manpage{insf(8)},
@manpage{strload(8)},
@manpage{strsetup(8)},
@manpage{strinfo(8)},
@manpage{scls(8)}
and other administrative commands.

@node Terminal I/O
@subsection Terminal I/O
@cindex terminal i/o, STREAMS
@cindex STREAMS, terminal i/o

By default, terminal I/O in a @b{Linux} system does not use @dfn{STREAMS}.  It, in fact, uses a
@dfn{STREAMS} @samp{pty} emulation.  However, this is only an emulation and does not provide all
@dfn{STREAMS} facilities.  It is not possible, for example, on a @b{Linux} @samp{pty} to push or
pop modules from a terminal.  The @b{Linux} @samp{pty} only provides emulation for read/write and
ioctl calls.

A separate auxiliary package for @dfn{@value{PACKAGE_TITLE}} that provides true @dfn{STREAMS}-based
@cite{UNIX'98} compliant pseudo terminals is available.  This is the @code{strpty-0.9.2.1} package
also available from @url{http://www.openss7.org/, The OpenSS7 Project}.@footnote{Actually, this
package is not yet avilable.  I will work on it someday when it is necessary.}

There are three user commands available in the @dfn{@value{PACKAGE_TITLE}} package that are useful
for terminal input-output: these are the
@manpage{strchg(1)}
@manpage{strconf(1)}
and
@manpage{strreset(1)}
user commands.

@node Pipes
@subsection Pipes
@cindex pipes, STREAMS
@cindex STREAMS, pipes

@dfn{@value{PACKAGE_TITLE}} supports @cite{STREMS}-based pipes as an optional feature.
@dfn{STREAMS}-based pipes operate as described in the @cite{UNIX SVR4.2 Operating System API
Reference} and the @cite{UNIX System V Release 4 Programmer's Guide: STREAMS}.

By default, pipes created on @b{Linux} by the @manpage{pipe(2)} system call are not
@dfn{STREAMS}-based.  To get @dfn{STREAMS}-based pipes, configure @cite{@value{PACKAGE_TITLE}} with
configuration parameter @code{--enable-streams-fifos}.

@dfn{@value{PACKAGE_TITLE}} also provides a character device based pipe facility using the
@manpage{spx(4)} driver.
@footnote{I am considering taking pipes and FIFOs out of the base
@code{@value{PACKAGE}-@value{VERSION}} package an placing them in their own @code{strpipe-0.9.2.1}
package.}

@node FIFOs
@subsection FIFOs
@cindex FIFOs, STREAMS
@cindex STREAMS, FIFOs

@dfn{@value{PACKAGE_TITLE}} supports @dfn{STREAMS}-based FIFOs (named pipes) as an optional feature.
@dfn{STREAMS}-based FIFOs operate as described in the @cite{UNIX SVR4.2 Operating System API
Reference} and the @cite{UNIX System V Release 4 Programmer's Guide: STREAMS}.

By default, FIFOs created on @b{Linux} with the
@manpage{mknod(8)}
utility are not @dfn{STREAMS}-based.  To get @dfn{STREAMS}-based FIFOs, configure @cite{@value{PACKAGE_TITLE}} with configuration parameter @code{--enable-streams-fifos}.
@footnote{I am considering taking pipes and FIFOs out of the base
@code{@value{PACKAGE}-@value{VERSION}} package an placing them in their own @code{strpipe-0.9.2.1}
package.}

@node Networking
@subsection Networking
@cindex networking, STREAMS
@cindex STREAMS, networking

By default, networking in a @b{Linux} system does not use @dfn{STREAMS}.  It uses the native Linux
@dfn{BSD Sockets} approach.  Some @b{GNU/Linux} distributions do provide an @cite{iBCS (Intel Binary
Compatibility Suite)}
@cindex iBCS
@cindex Intel Binary Compatibility Suite
that provides @cite{XTI/TLI} networking, however, this is only a @dfn{STREAMS} emulation and cannot push or
pop protocol modules from a stream.  Also, @b{Linux} @cite{iBCS} only provides emulation for
read/write and ioctl calls.

A separate auxiliary package for @dfn{@value{PACKAGE_TITLE}} that provides a true
@dfn{STREAMS}-based @cite{UNIX'98} compliant @cite{XTI/TLI library} is available.  This is the
@code{strxnet-0.9.2.5} package
also available from @url{http://www.openss7.org/, The OpenSS7 Project}.

To be able to open @dfn{INET} streams also requires the @code{strinet-0.9.2.1} package
also available from @url{http://www.openss7.org/, The OpenSS7 Project}.  This package provides
@dfn{STREAMS}-based networking by providing a specialized @dfn{STREAMS} driver that internally opens
a @b{Linux} native @dfn{BSD Socket} and translates @dfn{STREAMS} messages to and from the internal
@dfn{Socket}.

@node Mechanism
@chapter STREAMS Mechanism
@cindex mechanism
@menu
* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction
@end menu

@node Mechanism Overview
@section STREAMS Mechanism Overview
@cindex mechanism overview

This chapter shows how to construct, use, and dismantle a @dfn{Stream} using @dfn{STREAMS}-related
systems calls.  General and @dfn{STREAMS}-specific system calls provide the user level facilities
required to implement application programs.  This system call interface is upwardly compatible with
the traditional character I/O facilities.  The @manpage{open(2)} system call will recognize a
@dfn{STREAMS} file and create a @dfn{Stream} to the specified driver.  A user process can receive
and send data on @dfn{STREAMS} files using @manpage{read(2)} and @manpage{write(2)} in the same
manner as with traditional character files.  The @manpage{ioctl(2)} system call enables users to
perform functions specific to a particular device.  @dfn{STREAMS} ioctl commands (see
@manpage{streamio(7)}) support a variety of functions for accessing and controlling @dfn{Streams}.
The last @manpage{close(2)} in a @dfn{Stream} will dismantle a @dfn{Stream}.

@ignore
In addition to the traditional @command{ioctl} commands and system calls, there are other system
calls used by @dfn{STREAMS}.
@end ignore
@dfn{STREAMS} provides @manpage{ioctl(2)} commands and system calls in addition to the traditional
ones.  The @manpage{poll(2)} system call enables a user to poll multiple @dfn{Streams} for various
events.@footnote{Yes, @dfn{STREAMS} is responsible for the @manref{poll(2)} system call.}
The @manpage{putmsg(2)} and @manpage{getmsg(2)} system calls enable users to send and receive
@dfn{STREAMS} messages, and are suitable for interacting with @dfn{STREAMS} modules and drivers
through a service interface.

@dfn{STREAMS} provides kernel facilities and utilities to support development of modules and
drivers.  The @dfn{Stream head} handles most system calls so that the related processing does not
have to be incorporated in a module or driver.

@subsection STREAMS System Calls

The @dfn{STREAMS}-related system calls are:

@multitable @columnfractions .20 .80
@item @manpage{open(2)}
@tab Open a @dfn{Stream}
@item @manpage{close(2)}
@tab Close a @dfn{Stream}
@item @manpage{read(2)}
@tab Read data from a @dfn{Stream}
@item @manpage{write(2)}
@tab Write data to a @dfn{Stream}
@item @manpage{ioctl(2)}
@tab Control a @dfn{Stream}
@item @manpage{getmsg(2)}
@tab Receive a message at the @dfn{Stream head}
@item @manpage{putmsg(2)}
@tab Send a message downstream
@item @manpage{poll(2)}
@tab Notify the application program when selected events occur on a @dfn{Stream}
@item @manpage{pipe(2)}
@tab Create a channel that provides a communication path between multiple processes.
@end multitable

@node Stream Construction
@section STREAMS Stream Construction
@cindex stream construction

@dfn{STREAMS} constructs a @dfn{Stream} as a linked list of kernel resident data structures.  The
list is created as a set of linked queue pairs.  The first queue pair is the head of the
@dfn{Stream} and the second queue pair is the end of the @dfn{Stream}.  The end of the @dfn{Stream}
represents a device driver, pseudo device driver, or the other end of a @dfn{STREAMS}-based pipe.
Kernel routines interface with the @dfn{Stream head} to perform operations on the @dfn{Stream}.
@figref{13} depicts the upstream (read) and downstream (write) portions of the @dfn{Stream}.  Queue
@samp{H2} is the upstream half of the @dfn{Stream head} and queue @samp{H1} is the downstream half
of the @dfn{Stream head}.  Queue @samp{E2} is the upstream half of the @dfn{Stream end} and queue
@samp{E1} is the downstream half of the @dfn{Stream end}.

@figuresized{SPG_fig13,13,Upstream and Downstream @dfn{Stream} Construction,2.5in}

At the same relative location in each queue is the address of the entry point, a procedure to
process any message received by that queue.  The procedure for queues @samp{H1} and @samp{H2}
process messages sent to the @dfn{Stream head}.  The procedure for queues @samp{E1} and @samp{E2},
process messages received by the other end of the @dfn{Stream}, the @dfn{Stream end} (tail).
Messages move from one end to the other, from one queue to the next linked queue, as the procedure
specified by that queue is executed.

@figref{14} the data structures forming each queue: @code{queue}, @code{qinit}, @code{qband},
@code{module_info}, and @code{module_stat}.  The @code{qband} structures have information for each
priority band in the queue.  The queue data structure contains various modifiable values for that
queue.  The @code{qinit} structure contains a pointer to the processing procedures, the
@code{module_info} structure contains initial limit values, and the @code{module_stat} structure is
used for statistics gathering.  Each queue in the queue pair contains a different set of these data
structures.  There is a @code{queue}, @code{qinit}, @code{module_info}, and @code{module_stat} data
structure for the upstream portion of the queue pair and a set of data structures for the downstream
portion of the pair.  In some situations, a queue pair may share some or all of the data structures.
For example, there may be a separate @code{qinit} structure for each queue in the pair and one
@code{module_stat} structure that represents both queues in the pair.  These data structures are
described in @ref{STREAMS Data Structures}.

@figuresized{SPG_fig14,14,@dfn{Stream} Queue Relationship,5.5in}

@figref{14} shows two neighbouring queue pairs with links (solid vertical arrows) in both directions.
When a module is pushed onto a @dfn{Stream}, @dfn{STREAMS} creates a queue pair and links each queue
in the pair to its neighbouring queue in the upstream and downstream direction.  The linkage allows
each queue to locate its next neighbour.  This relation is implemented between adjacent queue pairs
by the @var{q_next} pointer.  Within a queue pair, each queue locates its mate (see dashed arrows in
@figref{14}) by use of @dfn{STREAMS} macros, since there is no pointer between the two queues.  The
existence of the @dfn{Stream head} and @dfn{Stream end} is known to the queue procedures only as
destinations toward which messages are sent.

@page
@subsection Opening a STREAMS Device File

One way to construct a @dfn{Stream} is to open (see @manref{open(2)}) a @dfn{STREAMS}-based driver
file (see @figref{15}).

A @dfn{STREAMS}-based driver file is either a character device special file within a @b{Linux}
file system, or a @dfn{STREAMS} special file file within the @dfn{Shadow Special Filesystem
(specfs)}.  When the @file{specfs} is mounted, @file{specfs} device nodes can be opened directly.
When the @file{specfs} is not mounted, @file{specfs} device nodes can only be opened indirectly via
character device nodes in a file system external to the @file{specfs}.

All entry points into the driver are defined by the @mantype{streamtab(9)} structure
for that driver.  The @type{streamtab} structure has a format as follows:

@cartouche
@smallexample
struct streamtab @{
    struct qinit *st_rdinit;
    struct qinit *st_wrinit;
    struct qinit *st_muxrinit;
    struct qinit *st_muxwinit;
@};
@end smallexample
@end cartouche

The @type{streamtab}
structure defines a module or driver.  @var{st_rdinit} points to the read @code{qinit} structure for
the driver and @var{st_wdinit} points to the driver's write @code{qinit} structure.
@var{st_muxrinit} and @var{st_muxwinit} point to the lower read and write @code{qinit} structures if
the driver is a multiplexer driver.

When a @dfn{STREAMS}-based file is opened, a new @dfn{Stream} is created if one does not already
exists for the file, or if the @code{D_CLONE} flag is set for the flag indicating that a new
@dfn{Stream} is to be created on each open of the file.  First, a file descriptor is allocated in
the process' file descriptor table, a file pointer is allocated to represent the opened file.  The
file pointer is initialized to point to the associated @dfn{inode} (see @var{f_inode} in
@figref{15}).  The @dfn{inode} is of type character special (@code{S_IFCHR}).

@ignore
If the @manpage{open(2)} call is the initial file open, a @dfn{Stream} is created.  (There is one
@dfn{Stream} per major/minor device pair.)  First, an entry is allocated in the user's file table
and a @dfn{vnode} is created to represent the opened file.  The file table entry is initialized to
point to the allocated @dfn{vnode} (see @var{f_vnode} in @figref{15}) and the @dfn{vnode} is
initialized to specify a file of type character special.
@end ignore

Second, a @dfn{Stream header} is created from an @code{stdata} data structure and a @dfn{Stream
head} is created from a pair of @code{queue} structures.  The content of @code{stdata} and
@code{queue} are initialized with predetermined values, including the @dfn{Stream head} processing
procedures.

The @dfn{snode} contains the file system dependent information.  The @dfn{snode} is an @dfn{inode}
within the @file{specfs} file system.  It is associated with the @dfn{inode} representing the device
by device number.  The @var{sd_inode} field of the @code{stdata} structure is initialized to point
to the @dfn{snode}.  The @var{i_pipe} field of the @dfn{inode} data structure is initialized to
point to the @dfn{Stream header}, thus there is a forward and backward pointer between the
@dfn{Stream header} and the @dfn{inode}.@footnote{For those familiar with the @cite{UNIX} virtual
file system approach to @dfn{STREAMS}, the @b{Linux} @dfn{file pointer} corresponds to the SVR4
@dfn{vnode} and the @dfn{inode} corresponds to the the common @dfn{vnode}.}

The @dfn{private_data} member of the @dfn{file pointer} is initialized to point to the @dfn{Stream
header} and the @var{sd_file} field of the @code{stdata} structure is initialized to point to the
@dfn{file pointer}.

@ignore
The @dfn{snode} contains the file system dependent information.  It is associated with the
@dfn{vnode} representing the device.  The @var{s_commonvp} field of the @dfn{snode} points to the
common device @dfn{vnode}.  The @dfn{vnode} field, @var{v_data}, contains a pointer to the
@dfn{snode}.  Instead of maintaining a pointer to the @dfn{vnode}, the @dfn{snode} contains the
@dfn{vnode} as an element.  The @var{sd_vnode} field of @code{stdata} is initialized to point to the
allocated @dfn{vnode}.  The @var{v_stream} field of the @dfn{vnode} data structure is initialized to
point to the @dfn{Stream header}, thus there is a forward and backward pointer between the
@dfn{Stream header} and the @dfn{vnode}.
@end ignore

There is one @dfn{Stream header} per @dfn{Stream}.  The header is used by @dfn{STREAMS} while
performing operations on the @dfn{Stream}.  In the downstream portion of the @dfn{Stream}, the
@dfn{Stream header} points to the downstream half of the @dfn{Stream head} queue pair.  Similarly,
the upstream portion of the @dfn{Stream} terminates at the @dfn{Stream header}, since the upstream
half of the @dfn{Stream head} queue pair points to the header.  As shown in @figref{15}, from the
@dfn{Stream header} onward, a @dfn{Stream} is constructed of linked queue pairs.

@figuresized{SPG_fig15,15,Opened @dfn{STREAMS}-based Driver,4in}

Next, a @code{queue} structure pair is allocated for the driver.  The queue limits are initialized
to those values specified in the corresponding @code{module_info} structure.  The queue processing
routines are initialized to those specified by the corresponding @code{qinit} structure.

Then, the @var{q_next} values are set so that the @dfn{Stream head} write queue points to the driver
write queue and the driver read queue points to the @dfn{Stream head} read queue.  The @var{q_next}
values at the ends of the @dfn{Stream} are set to @samp{NULL}.  Finally, the driver open procedure
(located via its read @code{qinit} structure) is called.

If this @manpage{open(2)} is not the initial open of this @dfn{Stream}, and the file is not marked
for clone open with the @code{D_CLONE} flag in the @manref{cdevsw(9)} structure, the only actions
performed are to call the driver @command{open} and the @command{open} procedures of all pushable
modules on the @dfn{Stream}.  When a @dfn{Stream} is already open, further opens of the same device
will result in the @command{open} routines of all modules and the driver on the @dfn{Stream} being
called.  Note that this is in reverse order from the way a @dfn{Stream} is initially set up.  That
is, a driver is opened and a module is pushed on a @dfn{Stream}.  When a push occurs the module
@command{open} routine is called.  If another open of the same device is made, the @command{open}
routine of the module will be called followed by the @command{open} routine of the driver.  This is
opposite from the initial order of opens when the @dfn{Stream} is created.

@subsection Creating a STREAMS-based Pipe

A @dfn{Stream} can also be created by creating a pipe (see @manpage{pipe(2)}).  Since pipes are not
character devices, @dfn{STREAMS} creates and initializes a @mantype{streamtab(9)} structure for each
end of the pipe.  As with modules and drivers, the @type{streamtab} structure defines the pipe.  The
@var{st_rdinit}, however, points to the read @code{qinit} structure for the @dfn{Stream head} and
not for a driver.  Similarly, the @var{st_wdinit} points to the @dfn{Stream head's} write
@code{qinit} structure and not to a driver.  The @var{st_muxrinit} and @var{st_muxwinit} are
initialized to null since a pipe cannot be a multiplexer driver.

When the pipe system call is executed, two @dfn{Streams} are created.  @dfn{STREAMS} follows the
procedures similar to those of opening a driver; however, duplicate data structures are created.
That is, two entries are allocated in the user's file table and two @dfn{inodes} are created to
represent each end of the pipe, as shown in @figref{16}.  The file table entries are initialized to
point to the allocated @dfn{inodes} and each @dfn{inode} is initialized to specify a file of type
@dfn{S_IFIFO}.

Next, two @dfn{Stream headers} are created from @code{stdata} data structures and two @dfn{Stream
heads} are created from two pairs of @code{queue} structures.  The content of @code{stdata} and
@code{queue} are initialized with the same values for all pipes.

Each @dfn{Stream header} represents one end of the pipe and it points to the downstream half of each
@dfn{Stream head} queue pair.  Unlike @dfn{STREAMS}-based devices, however, the downstream portion
of the @dfn{Stream} terminates at the upstream portion of the other @dfn{Stream}.

@figuresized{SPG_fig16,16,Creating @dfn{STREAMS}-based Pipe,5.5in}

The @var{q_next} values are set so that the @dfn{Stream head} write queue points to the @dfn{Stream
head} read queue on the other side.  The @var{q_next} values for the @dfn{Stream head's} read queue
points to null since it terminates the @dfn{Stream}.

@subsection Adding and Removing Modules

As part of constructing a @dfn{Stream}, a module can be added (pushed) with an @command{ioctl}
@ioctlref{I_PUSH} (see @manpage{streamio(7)}) system call.  The push inserts a module beneath the
@dfn{Stream head}.  Because of the similarity of @dfn{STREAMS} components, the push operation is
similar to the driver open.  First, the address of the @code{qinit} structure for the module is
obtained.

Next, @dfn{STREAMS} allocates a pair of @code{queue} structures and initializes their contents as in
the driver open.

Then, @var{q_next} values are set and modified so that the module is interposed between the
@dfn{Stream} head and its neighbour immediately downstream.  Finally, the module @command{open}
procedure (located via @code{qinit}) is called.

Each push of a module is independent, even in the same @dfn{Stream}.  If the same module is pushed
more than once on a @dfn{Stream}, there will be multiple occurrences of that module in the
@dfn{Stream}.  The total number of pushable modules that may be contained on any one @dfn{Stream} is
limited by the kernel parameter @constant{NSTRPUSH} (@pxref{STREAMS Configuration}).

An @command{ioctl} @ioctlref{I_POP} (see @manpage{streamio(7)}) system call removes (pops) the module
immediately below the @dfn{Stream} head.  The pop calls the module @command{close} procedure.  On
return from the module @command{close}, any messages left on the module's message queues are freed
(deallocated).  Then, @dfn{STREAMS} connects the @dfn{Stream head} to the component previously below
the popped module and deallocates the module's @code{queue} pair.  @streamio{I_PUSH} and @streamio{I_POP}
enable a user process to dynamically alter the configuration of a @dfn{Stream} by pushing and
popping modules as required.  For example, a module may be removed and a new one inserted below the
@dfn{Stream} head.  Then the original module can be pushed back after the new module has been
pushed.

@subsection Closing the Stream

The last close to a @dfn{STREAMS} file dismantles the @dfn{Stream}.  Dismantling consists of popping
any modules on the @dfn{Stream} and closing the driver.  Before a module is popped, the close may
delay to allow any messages on the write message queue of the module to be drained by module
processing.  Similarly, before the driver is closed, the close may delay to allow any messages on
the write message queue of the driver to be drained by driver processing.  If @constant{O_NDELAY} (or
@constant{O_NONBLOCK}) (see @manpage{open(2)}) is clear, close will wait up to @samp{15} seconds for each
module to drain and up to @samp{15} seconds for the driver to drain.  If @constant{O_NDELAY} (or
@constant{O_NONBLOCK}) is set, the pop is performed immediately and the driver is closed without delay.
Messages can remain queued, for example, if flow control is inhibiting execution of the write queue
service procedure.  When all modules are popped and any wait for the driver to drain is completed,
the driver @command{close} routine is called.  On return from the driver @command{close}, any
messages left on the driver's queues are freed, and the @code{queue} and @code{stdata} structures
are deallocated.

@dfn{STREAMS} frees only the messages contained on a message queue.  Any message or data structures
used internally by the driver or module must be freed by the driver or module @command{close}
procedure.

Finally, the user's @dfn{file table} entry and the @dfn{inode} are deallocated and the @dfn{file} is
closed.

@subsection Stream Construction Example

The following example extends the previous communications device echoing example (@pxref{Basic
Streams Operations}) by inserting a module in the Stream.  The (hypothetical) module in this example
can convert (change case, delete, duplicate) selected alphabetic characters.

@subsubsection Inserting Modules


An advantage of @dfn{STREAMS} over the traditional character I/O mechanism stems from the ability to
insert various modules into a @dfn{Stream} to process and manipulate data that pass between a user
process and the driver.  In the example, the character conversion module is passed a command and a
corresponding string of characters by the user.  All data passing through the module are inspected
for instances of characters in this string; the operation identified by the command is performed on
all matching characters.  The necessary declarations for this program are shown below:

@smallexample
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/uio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stropts.h>

#define   BUFLEN      1024

/*
 *  These defines would typically be
 *  found in a header file for the module
 */
#define   XCASE       1         /* change alphabetic case of char */
#define   DELETE      2         /* delete char */
#define   DUPLICATE   3         /* duplicate char */

main()
@{
    char buf[BUFLE];
    int fd, count;
    struct strioct1 strioctl;
@end smallexample

The first step is to establish a @dfn{Stream} to the communications driver and insert the character
conversion module.  The following sequence of system calls accomplishes this:

@smallexample
    if ((fd = open("/dev/comm/01", O_RDWR)) < 0) @{
        perror("open failed");
        exit(1);
    @}

    if (ioctl(fd, I_PUSH, "chconv") < 0) @{
        perror("ioctl  I_PUSH failed");
        exit(2);
    @}
@end smallexample

The @ioctlref{I_PUSH} @manref{ioctl(2)} call directs the @dfn{Stream} head to insert the character
conversion module between the driver and the @dfn{Stream head}, creating the @dfn{Stream} shown in
@figref{17}.  As with drivers, this module resides in the kernel and must have been configured into
the system before it was booted.

@figuresized{SPG_fig17,17,Case Converter Module,4in}

An important difference between @dfn{STREAMS} drivers and modules is illustrated here.  Drivers are
accessed through a node or nodes in the file system and may be opened just like any other device.
Modules, on the other hand, do not occupy a file system node.  Instead, they are identified through
a separate naming convention, and are inserted into a @dfn{Stream} using @streamio{I_PUSH}.  The name of
a module is defined by the module developer.

Modules are pushed onto a @dfn{Stream} and removed from a @dfn{Stream} in @dfn{Last-In-First-Out
(LIFO)} order.  Therefore, if a second module was pushed onto this @dfn{Stream}, it would be
inserted between the @dfn{Stream} head and the character conversion module.

@subsubsection Module and Driver Control

The next step in this example is to pass the commands and corresponding strings to the character
conversion module.  This can be accomplished by issuing ioctl calls to the character conversion
module as follows:

@smallexample
/* change all uppercase vowels to lowercase */
strioctl.ic_cmd = XCASE;
strioctl.ic_timout = 0;         /* default timeout (15 sec) */
strioctl.ic_dp = "AEIOU";
strioctl.ic_len = strlen(strioctl.ic_dp);

if (ioctl(fd, I_STR, &strioctl) < 0) @{
    perror("ioctl I_STR failed");
    exit(3);
@}

/* delete all instances of trhe chars 'x' and  'X' */
strioctl.ic_cmd = DELETE;
strioctl.ic_dp = "xX";
strioctl.ic_len = strlen(strioctl.ic_dp);

if (ioctl(fd, I_STR, &strioctl) < 0) @{
    perror("ioctl I_STR failed");
    exit(4);
@}
@end smallexample

@command{ioctl} requests are issued to @dfn{STREAMS} drivers and modules indirectly, using the
@ioctlref{I_STR} @command{ioctl} call (see @manpage{streamio(7)}).  The argument to @streamio{I_STR} must be a
pointer to a @code{strioctl} structure, which specifies the request to be made to a module or
driver.  This structure is defined in @header{sys/stropts.h} and has the following format:

@smallexample
struct strioctl @{
    int ic_cmd;                         /* ioctl request */
    int ic_timout;                      /* ACK/NAK timeout */
    int ic_len;                         /* length of data argument */
    char *ic_dp;                        /* ptr to data argument */
@};
@end smallexample

where @var{ic_cmd} identifies the command intended for a module or driver, @var{ic_timout} specifies
the number of seconds an @streamio{I_STR} request should wait for an acknowledgement before timing out,
@var{ic_len} is the number of bytes of data to accompany the request, and @var{ic_dp} points to that
data.

In the example, two separate commands are sent to the character conversion module.  The first sets
@var{ic_cmd} to the command @constant{XCASE} and sends as data the string @samp{AEIOU}; it will convert
all uppercase vowels in data passing through the module to lowercase.  The second sets ic_cmd to the
command @constant{DELETE} and sends as data the string @samp{xX}; it will delete all occurrences of the
characters @samp{x} and @samp{X} from data passing through the module.  For each command, the value
of @var{ic_timout} is set to zero, which specifies the system default timeout value of @samp{15}
seconds.  The @var{ic_dp} field points to the beginning of the data for each command; @var{ic_len}
is set to the length of the data.

@streamio{I_STR} is intercepted by the @dfn{Stream head}, which packages it into a message, using
information contained in the @code{strioctl} structure, and sends the message downstream.  Any
module that does not understand the command in @var{ic_cmd} will pass the message further
downstream.  The request will be processed by the module or driver closest to the @dfn{Stream head}
that understands the command specified by @var{ic_cmd}.  The @command{ioctl} call will block up to
@var{ic_timout} seconds, waiting for the target module or driver to respond with either a positive
or negative acknowledgement message.  If an acknowledgement is not received in @var{ic_timout}
seconds, the @command{ioctl} call will fail.

Only one @streamio{I_STR} request can be active on a @dfn{Stream} at one time.  Further requests will
block until the active @streamio{I_STR} request is acknowledged and the system call completes.

The @code{strioctl} structure is also used to retrieve the results, if any, of an @streamio{I_STR}
request.  If data are returned by the target module or driver, @var{ic_dp} must point to a buffer
large enough to hold that data, and @var{ic_len} will be set on return to indicate the amount of
data returned.

The remainder of this example is identical to the example in @ref{Modules and Drivers}:

@smallexample
    while ((count = read(fd, buf, BUFLEN)) > 0) @{
        if (write(fd, buf, count) != count) @{
            perror("write failed");
            break;
        @}
    @}
    exit(0);
@}
@end smallexample

Notice that the character conversion processing was realized with no change to the communications
driver.

The exit system call will dismantle the @dfn{Stream} before terminating the process.  The character
conversion module will be removed from the @dfn{Stream} automatically when it is closed.
Alternatively, modules may be removed from a @dfn{Stream} using the @streamio{I_POP} @command{ioctl} call
described in @manpage{streamio(7)}.  This call removes the topmost module on the @dfn{Stream}, and
enables a user process to alter the configuration of a @dfn{Stream} dynamically, by popping modules
as needed.

A few of the important @command{ioctl} requests supported by @dfn{STREAMS} have been discussed.
Several other requests are available to support operations such as determining if a given module
exists on the @dfn{Stream}, or flushing the data on a @dfn{Stream}.  These requests are described
fully in @manpage{streamio(7)}.

@node Processing
@chapter STREAMS Processing Routines
@cindex processing routines
@menu
* Procedures::			STREAMS Put and Service Procedures
* Asynchronous Example::	STREAMS Asynchronous Stream Example
@end menu

@node Procedures
@section STREAMS Put and Service Procedures
@cindex put and service procedures

The @command{put} and @command{service} procedures in the queue are routines that process messages
as they transit the queue.  The processing is generally performed according to the message type and
can result in a modified message, new message(s), or no message.  A resultant message, if any, is
generally sent in the same direction in which it was received by the queue, but may be sent in
either direction.  Typically, each @command{put} procedure places messages on its queue as they
arrive, for later processing by the @command{service} procedure.

A queue will always contain a @command{put} procedure and may also contain an associated
@command{service} procedure.  Having both a @command{put} and @command{service} procedure in a queue
enables @dfn{STREAMS} to provide the rapid response and the queueing required in multi-user systems.

The @command{service} and @command{put} routines pointed at by a queue, and the queues themselves,
are not associated with any process.  These routines may not sleep if they cannot continue
processing, but must instead return.  Any information about the current status of the queue must be
saved by the routine before returning.

@subsection Put Procedure

A @command{put} procedure is the queue routine that receives messages from the preceding queues in
the @dfn{Stream}.  Messages are passed between queues by a procedure in one queue calling the
@command{put} procedure contained in the following queue.  A call to the @command{put} procedure in
the appropriate direction is generally the only way to pass messages between @dfn{STREAMS}
components.  There is usually a separate @command{put} procedure for the read and write queues
because of the full-duplex operation of most @dfn{Streams}.  However, there can be a single
@command{put} procedure shared between both the read and write queues.

The @command{put} procedure allows rapid response to certain data and events, such as echoing of
input characters.  It has higher priority than any scheduled @command{service} procedure and is
associated with immediate, as opposed to deferred, processing of a message.  The @command{put}
procedure executes before the scheduled @command{service} procedure of any queue is executed.

Each @dfn{STREAMS} component accesses the adjacent @command{put} procedure as a subroutine.  For
example, consider that @samp{modA}, @samp{modB}, and @samp{modC} are three consecutive components in
a @dfn{Stream}, with @samp{modC} connected to the @dfn{Stream head}.  If @samp{modA} receives a
message to be sent upstream, @samp{modA} processes that message and calls @samp{modB}'s read
@command{put} procedure, which processes it and calls @samp{modC}'s read @command{put} procedure,
which processes it and calls the @dfn{Stream head's} read @command{put} procedure.  Thus, the
message will be passed along the @dfn{Stream} in one continuous processing sequence.  This sequence
has the benefit of completing the entire processing in a short time with low overhead (subroutine
calls).  On the other hand, if this sequence is lengthy and the processing is implemented on a
multi-user system, then this manner of processing may be good for this @dfn{Stream} but may be
detrimental for others.  @dfn{Streams} may have to wait too long to get their turn, since each
@command{put} procedure is called from the preceding one, and the kernel stack (or interrupt stack)
grows with each function call.  The possibility of running off the stack exists, thus panicking the
system or producing indeterminate results.

@subsection Service Procedure

In addition to the @command{put} procedure, a @command{service} procedure may be contained in each
queue to allow deferred processing of messages.  If a queue has both a @command{put} and
@command{service} procedure, message processing will generally be divided between the procedures.
The @command{put} procedure is always called first, from a preceding queue.  After completing its
part of the message processing, it arranges for the @command{service} procedure to be called by
passing the message to the @manpage{putq(9)} routine.  @manpage{putq(9)} does two things: it places
the message on the message queue of the queue (see @figref{6}) and links the queue to the end of the
@dfn{STREAMS} scheduling queue.  When @manpage{putq(9)} returns to the @command{put} procedure, the
procedure can return or continue to process the message.  Some time later, the @command{service}
procedure will be automatically called by the @dfn{STREAMS} scheduler.

The @dfn{STREAMS} scheduler is separate and distinct from the @b{Linux} system process scheduler.
It is concerned only with queues linked on the @dfn{STREAMS} scheduling queue.  The scheduler calls
each @command{service} procedure of the scheduled queues one at a time in a @dfn{First-In-First-Out
(FIFO)} manner.

The scheduling of queue @command{service} routines is machine dependent.  However, they are
guaranteed to run before returning to user level.

@dfn{STREAMS} utilities deliver the messages to the processing @command{service} routine in the
@dfn{FIFO} manner within each priority class (high priority, priority band, ordinary), because the
@command{service} procedure is unaware of the message priority and simply receives the next message.
The @command{service} routine receives control in the order it was scheduled.  When the
@command{service} routine receives control, it may encounter multiple messages on its message queue.
This buildup can occur if there is a long interval between the time a message is queued by a
@command{put} procedure and the time that the @dfn{STREAMS} scheduler calls the associated
@command{service} routine.  In this interval, there can be multiple calls to the @command{put}
procedure causing multiple messages to build up.  The @command{service} procedure always processes
all messages on its message queue unless prevented by flow control.

Terminal output and input erase and kill processing, for example, would typically be performed in a
@command{service} procedure because this type of processing does not have to be as timely as
echoing.  Use of a @command{service} procedure also allows processing time to be more evenly spread
among multiple @dfn{Streams}.  As with the @command{put} procedure there can be a separate
@command{service} procedure for each queue in a @dfn{STREAMS} component or a single procedure used
by both the read and write queues.

Rules that should be observed in @command{put} and @command{service} procedures are listed in
@ref{Modules and Drivers}.

@node Asynchronous Example
@section An Asynchronous Stream Example
@cindex asynchronous stream example

In the following example, our computer runs the @b{Linux} system and supports different kinds of
asynchronous terminals, each logging in on its own port.  The port hardware is limited in function;
for example, it detects and reports line and modem status, but does not check parity.

Communications software support for these terminals is provided via a @dfn{STREAMS} based
asynchronous protocol.  The protocol includes a variety of options that are set when a terminal
operator dials in to log on.  The options are determined by a @dfn{STREAMS} user process,
@command{getstrm}, which analyzes data sent to it through a series of dialogues (prompts and
responses) between the process and terminal operator.

The process sets the terminal options for the duration of the connection by pushing modules onto the
@dfn{Stream} or by sending control messages to cause changes in modules (or in the device driver)
already on the @dfn{Stream}.  The options supported include:

@itemize @bullet
@item @dfn{ASCII} or @dfn{EBCDIC} character codes
@item For @dfn{ASCII} code, the parity (odd, even or none)
@item Echo or not echo input characters
@item Canonical input and output processing or transparent (raw) character handling
@end itemize

These options are set with the following modules:

@vtable @var
@item CHARPROC
Provides input character processing functions, including dynamically settable (via control messages
passed to the module) character echo and parity checking.  The module's default settings are to echo
characters and not check character parity.
@item CANONPROC
Performs canonical processing on @dfn{ASCII} characters upstream and downstream (note that this
performs some processing in a different manner from the standard @b{Linux} system character I/O
@dfn{tty} subsystem).
@item ASCEBC
Translates @dfn{EBCDIC} code to @dfn{ASCII} upstream and @dfn{ASCII} to @dfn{EBCDIC} downstream.
@end vtable

At system initialization a user process, @command{getstrm}, is created for each @dfn{tty} port.
@command{getstrm} opens a @dfn{Stream} to its port and pushes the @constant{CHARPROC} module onto the
@dfn{Stream} by use of an @command{ioctl} @ioctlref{I_PUSH} command.  Then, the process issues a getmsg
system call to the @dfn{Stream} and sleeps until a message reaches the @dfn{Stream} head.  The
@dfn{Stream} is now in its idle state.

The initial idle @dfn{Stream}, shown in @figref{18}, contains only one pushable module,
@constant{CHARPROC}.  The device driver is a limited function raw @dfn{tty} driver connected to a
limited-function communication port.  The driver and port transparently transmit and receive one
unbuffered character at a time.

@figuresized{SPG_fig18,18,Idle @dfn{Stream} Configuration for Example,4in}

Upon receipt of initial input from a @dfn{tty} port, @command{getstrm} establishes a connection with
the terminal, analyzes the option requests, verifies them, and issues @dfn{STREAMS} system calls to
set the options.  After setting up the options, @command{getstrm} creates a user application
process.  Later, when the user terminates that application, @command{getstrm} restores the
@dfn{Stream} to its idle state by use of similar system calls.

@figref{19} continues the example and associates kernel operations with user-level system calls.  As
a result of initializing operations and pushing a module, the @dfn{Stream} for port one has the
following configuration:

@figuresized{SPG_fig19,19,Operational @dfn{Stream} for Example,4in}

As mentioned before, the upstream queue is also referred to as the read queue reflecting the message
flow direction.  Correspondingly, downstream is referred to as the write queue.

@subsection Read-Side Processing

In our example, read-side processing consists of driver processing, @constant{CHARPROC} processing, and
@constant{CANONPROC} processing.

@subsubsection Driver Processing

The user process has been blocked on the @manpage{getmsg(2)} system call while waiting for a message
to reach the @dfn{Stream head}, and the device driver independently waits for input of a character
from the port hardware or for a message from upstream.  Upon receipt of an input character interrupt
from the port, the driver places the associated character in an @msg{M_DATA} message, allocated
previously.  Then, the driver sends the message to the @constant{CHARPROC} module by calling
@constant{CHARPROC}'s upstream put procedure.  On return from @constant{CHARPROC}, the driver calls the
@manpage{allocb(9)} utility routine to get another message for the next character.

@subsubsection CHARPROC

@constant{CHARPROC} has both @command{put} and @command{service} procedures on its read-side.  In the
example, the other queues in the modules also have both procedures:

@figuresized{SPG_fig20,20,Module Put and Service Procedures,3in}

When the driver calls @constant{CHARPROC}'s read queue @command{put} procedure, the procedure checks
private data flags in the queue.  In this case, the flags indicate that echoing is to be performed
(recall that echoing is optional and that we are working with port hardware which can not
automatically echo).  @constant{CHARPROC} causes the echo to be transmitted back to the terminal by first
making a copy of the message with a @dfn{STREAMS} utility routine.  Then, @constant{CHARPROC} uses
another utility routine to obtain the address of its own write queue.  Finally, the @constant{CHARPROC}
read @command{put} procedure calls its write @command{put} procedure and passes it the message copy.
The write procedure sends the message to the driver to effect the echo and then returns to the read
procedure.

This part of read-side processing is implemented with @command{put} procedures so that the entire
processing sequence occurs as an extension of the driver input character interrupt.  The
@constant{CHARPROC} read and write @command{put} procedures appear as subroutines (nested in the case of
the write procedure) to the driver.  This manner of processing is intended to produce the character
echo in a minimal time frame.

After returning from echo processing, the @constant{CHARPROC} read @command{put} procedure checks another
of its private data flags and determines that parity checking should be performed on the input
character.  Parity should most reasonably be checked as part of echo processing.  However, for this
example, parity is checked only when the characters are sent upstream.  This relaxes the timing in
which the checking must occur, that is, it can be deferred along with the canonical processing.
@constant{CHARPROC} uses @manpage{putq(9)} to schedule the (original) message for parity check processing
by its read @command{service} procedure.  When the @constant{CHARPROC} read @command{service} procedure
is complete, it transfers the message to the read @command{put} procedure of @constant{CANONPROC}.  Note
that if parity checking was not required, the @constant{CHARPROC} @command{put} procedure would call the
@constant{CANONPROC} @command{put} procedure directly.

@subsubsection CANONPROC

@constant{CANONPROC} performs canonical processing.  As implemented, all read queue processing is
performed in its @command{service} procedure so that @constant{CANONPROC}'s @command{put} procedure
simply calls @manpage{putq(9)} to schedule the message for its read @command{service} procedure and
then exits.  The @command{service} procedure extracts the character from the message buffer and
places it in the "line buffer" contained in another @msg{M_DATA} message it is constructing.  Then,
the message which contained the single character is returned to the buffer pool.  If the character
received was not an @dfn{end-of-line}, @constant{CANONPROC} exits.  Otherwise, a complete line has been
assembled and @constant{CANONPROC} sends the message upstream to the @dfn{Stream head} which unblocks the
user process from the @manpage{getmsg(2)} call and passes it the contents of the message.

@subsection Write-Side Processing

The write-side of this Stream carries two kinds of messages from the user process: @command{ioctl}
messages for @constant{CHARPROC}, and @msg{M_DATA} messages to be output to the terminal.

@command{ioctl} messages are sent downstream as a result of an @manpage{ioctl(2)} system call.  When
@constant{CHARPROC} receives an @command{ioctl} message type, it processes the message contents to modify
internal flags and then uses a utility routine to send an acknowledgement message upstream to the
@dfn{Stream head}.  The @dfn{Stream head} acts on the acknowledgement message by unblocking the user
from the @command{ioctl}.

For terminal output, it is presumed that @msg{M_DATA} messages, sent by @manpage{write(2)} system
calls, contain multiple characters.  In general, @dfn{STREAMS} returns to the user process
immediately after processing the @command{write} call so that the process may send additional
messages.  Flow control will eventually block the sending process.  The messages can queue on the
write-side of the driver because of character transmission timing.  When a message is received by
the driver's write @command{put} procedure, the procedure will use @manpage{putq(9)} to place the
message on its write-side service message queue if the driver is currently transmitting a previous
message buffer.  However, there is generally no write queue @command{service} procedure in a device
driver.  Driver output interrupt processing takes the place of scheduling and performs the
@command{service} procedure functions, removing messages from the queue.

@subsection Analysis

For reasons of efficiency, a module implementation would generally avoid placing one character per
message and using separate routines to echo and parity check each character, as was done in this
example.  Nevertheless, even this design yields potential benefits.  Consider a case where
alternate, more intelligent, port hardware was substituted.  If the hardware processed multiple
input characters and performed the echo and parity checking functions of @constant{CHARPROC}, then the
new driver could be implemented to present the same interface as @constant{CHARPROC}.  Other modules such
as @constant{CANONPROC} could continue to be used without modification.

@node STREAMS Messages
@chapter STREAMS Messages
@cindex messages
@menu
* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers
@end menu

@node Messages Overview
@section STREAMS Messages Overview
@cindex messages overview
@menu
* Message Types::		STREAMS Message Types
* Expedited Data::		STREAMS Handling of Expedited Data
@end menu

Messages are the means of communication within a @dfn{Stream}.  All input and output under
@dfn{STREAMS} is based on messages.  The objects passed between @dfn{Streams} components are
pointers to messages.  All messages in @dfn{STREAMS} use two data structures to refer to the data in
the message.  These data structures describe the type of the message and contain pointers to the
data of the message, as well as other information.  Messages are sent through a @dfn{Stream} by
successive calls to the @command{put} routine of each queue in the @dfn{Stream}.  Messages may be
generated by a driver, a module, or by the @dfn{Stream head}.

@node Message Types
@subsection Message Types

There are several different @dfn{STREAMS} messages (@pxref{Message Types}) and they are defined in
@header{sys/stream.h}.  The messages differ in their intended purpose and their queueing priority.
The contents of certain message types can be transferred between a process and a @dfn{Stream} by use
of system calls.

Below, the message types are briefly described and classified according to their queueing priority.

Ordinary Messages (also called normal messages):

@multitable @columnfractions .20 .05 .05 .70
@item @msg{M_DATA} @tab D @tab U @tab User data message for I/O system calls
@item @msg{M_PROTO} @tab D @tab U @tab Protocol control information
@item @msg{M_BREAK} @tab D @tab - @tab Request to a @dfn{Stream} driver to send a "break"
@item @msg{M_CTL} @tab D @tab U @tab Control/status request used for inter-module communication
@item @msg{M_DELAY} @tab D @tab - @tab Request a real-time delay on output
@item @msg{M_IOCTL} @tab D @tab - @tab Control/status request generated by a @dfn{Stream head}
@item @msg{M_PASSFP} @tab D @tab U @tab File pointer passing message
@item @msg{M_RSE} @tab D @tab U @tab Reserved for internal use
@item @msg{M_SETOPTS} @tab - @tab U @tab Set options at the @dfn{Stream head}, sent upstream
@item @msg{M_SIG} @tab - @tab U @tab Signal sent from a module/driver to a user
@end multitable

High Priority Messages:

@multitable @columnfractions .20 .05 .05 .70
@item @msg{M_COPYIN} @tab - @tab U @tab Copy in data for transparent @command{ioctl}s, sent upstream
@item @msg{M_COPYOUT} @tab - @tab U @tab Copy out data for transparent @command{ioctl}s, sent upstream
@item @msg{M_ERROR} @tab - @tab U @tab Report downstream error condition, sent upstream
@item @msg{M_FLUSH} @tab D @tab U @tab Flush module queue
@item @msg{M_HANGUP} @tab - @tab U @tab Set a @dfn{Stream head} hangup condition, sent upstream
@item @msg{M_IOCACK} @tab - @tab U @tab Positive @manpage{ioctl(2)} acknowledgement
@item @msg{M_IOCDATA} @tab D @tab - @tab Data for transparent @command{ioctl}s, sent downstream
@item @msg{M_IOCNAK} @tab - @tab U @tab Negative @manpage{ioctl(2)} acknowledgement
@item @msg{M_PCPROTO} @tab D @tab U @tab Protocol control information
@item @msg{M_PCRSE} @tab D @tab U @tab Reserved for internal use
@item @msg{M_PCSIG} @tab - @tab U @tab Signal sent from a module/driver to a user
@item @msg{M_READ} @tab D @tab - @tab Read notification, sent downstream
@item @msg{M_STOP} @tab D @tab - @tab Suspend output
@item @msg{M_START} @tab D @tab - @tab Restart stopped device output
@item @msg{M_STOPI} @tab D @tab - @tab Suspend input
@item @msg{M_STARTI} @tab D @tab - @tab Restart stopped device input
@end multitable

Transparent @command{ioctl}s support applications developed prior to the introduction of @dfn{STREAMS}.

@node Expedited Data
@subsection Expedited Data

The @cite{Open Systems Interconnection (OSI) Reference Model} developed by the @cite{International
Standards Organization (ISO)} and @cite{International Telegraph and Telephone Consultative Committee
(CCITT)} provides an international standard seven-layer architecture for the development of
communication protocols.  @cite{AT&T} adheres to this standard and also supports the
@dfn{Transmission Control Protocol and Internet Protocol (TCP/IP)}.

@dfn{OSI} and @dfn{TCP/IP} support the transport of expedited data (see note below) for transmission
of high priority, emergency data.  This is useful for flow control, congestion control, routing, and
various applications where immediate delivery of data is necessary.

Expedited data are mainly for exceptional cases and transmission of control signals.  These are
emergency data that are processed immediately, ahead of normal data.  These messages are placed
ahead of normal data on the queue, but after @dfn{STREAMS} high priority messages and after any
expedited data already on the queue.

Expedited data flow control is unaffected by the flow control constraints of normal data transfer.
Expedited data have their own flow control because they can easily run the system out of buffers if
their flow is unrestricted.

Drivers and modules define separate high and low water marks for priority band data flow.  (Water
marks are defined for each queue and they indicate the upper and lower limit of bytes that can be
contained on the queue; see @msg{M_SETOPTS} in @pxref{Message Types}).  The default water marks for
priority band data and normal data are the same.  The @dfn{Stream} head also ensures that incoming
priority band data are not blocked by normal data already on the queue.  This is accomplished by
associating a priority with the messages.  This priority implies a certain ordering of the messages
in the queue.  (Message queues and priorities are discussed later in this chapter.)

Within the @dfn{STREAMS} mechanism and in this guide expedited data are also referred to as priority
band data.

@node Message Structure
@section STREAMS Message Structure
@cindex message structure
@menu
* Message Linkage::
* Sending and Receiving Messages::
* Control of Stream Head Processing::
@end menu

All messages are composed of one or more message blocks.  A message block is a linked triplet of two
structures and a variable length data buffer.  The structures are a message block (@code{msgb}) and
a data block (@code{datab}).  The data buffer is a location in memory where the data of a message
are stored.

@smallexample
struct msgb @{
    struct msgb *b_next;        /* next message on queue */
    struct msgb *b_prev;        /* previous message on queue */
    struct msgb *b_cont;        /* next message block of message */
    unsigned char *b_rptr;      /* first unread data byte in buffer */
    unsigned char *b_wptr;      /* first unwritten data byte in buffer */
    struct datab *b_datap;      /* data block */
    unsigned char b_band;       /* message priority */
    unsigned char b_padl;
    unsigned short b_flag;      /* see below - message flags */
    long b_pad2;
@};

typedef struct msgb mblk_t;

/* message flags.  these are interpreted by the stream head.  */
#define msgmark    0x01         /* last byte of message is "marked" */
#define msgnoloop  0x02         /* do not loop message around to write
                                   side of stream */
#define msgdelim   0x04         /* message is delimited */
#define msgnoget   0x08         /* getq does not return message */
#define msgatten   0x20         /* attention to on read side */

struct free_rtn @{
    void (*free_func) (caddr_t);
    caddr_t free_arg;
@};

struct datab @{
    union @{
        struct datab *freep;
        struct free_rtn *frtnp;
    @} db_f;             /* used internally */
    unsigned char *db_base;     /* first byte of buffer */
    unsigned char *db_lim;      /* last byte+1 of buffer */
    unsigned char db_ref;       /* message count pointing to this block 
                                 */
    unsigned char db_type;      /* message type */
    unsigned char db_iswhat;    /* status of message/dat buffer triplet 
                                 */
    unsigned int db_size;       /* used internally */
    caddr_t db_msgaddr; /* triplet message header pointing to datab */
    long db_filler;     /* reserved for future use */
@};

#define db_freep db_f.freep
#define db_frtnp db_f.frtnp

typedef struct datab dblk_t;
typedef struct free_rtn frtn_t;
@end smallexample

The field @var{b_band} determines where the message is placed when it is enqueued using the
@dfn{STREAMS} utility routines.  This field has no meaning for high priority messages and is set to
zero for these messages.  When a message is allocated via @manpage{allocb(9)}, the @var{b_band}
field will be initially set to zero.  Modules and drivers may set this field if so desired.

Note that in @cite{System V Release 4.0}, certain data structures fundamental to the kernel (for
example, device numbers, user IDs) were enlarged to enable them to hold more information.  This
feature was referred to as Expanded Fundamental Types (EFT).  Since some of this information was
passed in @dfn{STREAMS} messages, there was a binary compatibility issue for pre-System V Release 4
drivers and modules.  @code{#ifdef}'s were added to the kernel to provide a transition period for
these drivers and modules to be recompiled, and to allow it to be built to use the pre-System V
Release 4 short data types or the System V Release 4 long data types.  Support for short data types
will be dropped in some future releases.

@node Message Linkage
@subsection Message Linkage

The message block is used to link messages on a message queue, link message blocks to form a
message, and manage the reading and writing of the associated data buffer.  The @var{b_rptr} and @var{b_wptr}
fields in the @code{msgb} structure are used to locate the data currently contained in the buffer.  As
shown in @figref{21}, the message block (@code{mblk_t}) points to the data block of the triplet.
The data block contains the message type, buffer limits, and control variables.  @dfn{STREAMS}
allocates message buffer blocks of varying sizes.  @var{db_base} and @var{db_lim} are the fixed
beginning and end (+1) of the buffer.

A message consists of one or more linked message blocks.  Multiple message blocks in a message can
occur, for example, because of buffer size limitations, or as the result of processing that expands
the message.  When a message is composed of multiple message blocks, the type associated with the
first message block determines the message type, regardless of the types of the attached message
blocks.

@figuresized{SPG_fig21,21,Message Form and Linkage,5.5in}

A message may occur singly, as when it is processed by a @command{put} procedure, or it may be
linked on the message queue in a @code{queue}, generally waiting to be processed by the service
procedure.  Message @samp{2}, as shown in @figref{21}, links to message @samp{1}.

Note that a data block in message @samp{1} is shared between message @samp{1} and another message.
Multiple message blocks can point to the same data block to conserve storage and to avoid copying
overhead.  For example, the same data block, with associated buffer, may be referenced in two
messages, from separate modules that implement separate protocol levels.  @figref{21}, illustrates
the concept, but data blocks would not typically be shared by messages on the same queue).  The
buffer can be retransmitted, if required because of errors or timeouts, from either protocol level
without replicating the data.  Data block sharing is accomplished by means of a utility routine (see
@manpage{dupmsg(9)} or @ref{STREAMS Utilities}).  @dfn{STREAMS} maintains a count of the message
blocks sharing a data block in the @var{db_ref} field.

@dfn{STREAMS} provides utility routines and macros, specified in @ref{STREAMS Utilities}, to assist
in managing messages and message queues, and to assist in other areas of module and driver
development.  A utility routine should always be used when operating on a message queue or accessing
the message storage pool.  If messages are manipulated on the queue without using the @dfn{STREAMS}
utilities, the message ordering may become confused and lead to inconsistent results.

@node Sending and Receiving Messages
@subsection Sending and Receiving Messages

Most message types can be generated by modules and drivers.  A few are reserved for the @dfn{Stream
head}.  The most commonly used messages are @msg{M_DATA}, @msg{M_PROTO}, and @msg{M_PCPROTO}.  These
messages can also be passed between a process and the topmost module in a @dfn{Stream}, with the
same message boundary alignment maintained on both sides of the kernel.  This allows a user process
to function, to some degree, as a module above the @dfn{Stream} and maintain a service interface.
@msg{M_PROTO} and @msg{M_PCPROTO} messages are intended to carry service interface information among
modules, drivers, and user processes.  Some message types can only be used within a @dfn{Stream} and
cannot be sent or received from user level.

Modules and drivers do not interact directly with any system calls except @manpage{open(2)} and
@manpage{close(2)}.  The @dfn{Stream} head handles all message translation and passing between user
processes and @dfn{STREAMS} components.  Message transfer between processes and the @dfn{Stream
head} can occur in different forms.  For example, @msg{M_DATA} and @msg{M_PROTO} messages can be
transferred in their direct form by the @manpage{getmsg(2)} and @manpage{putmsg(2)} system calls.
Alternatively, @manpage{write(2)} causes one or more @msg{M_DATA} messages to be created from the
data buffer supplied in the call.  @msg{M_DATA} messages received at the @dfn{Stream head} will be
consumed by @manpage{read(2)} and copied into the user buffer.  As another example, @msg{M_SIG}
causes the @dfn{Stream head} to send a signal to a process.

Any module or driver can send any message in either direction on a @dfn{Stream}.  However, based on
their intended use in @dfn{STREAMS} and their treatment by the @dfn{Stream} head, certain messages
can be categorized as upstream, downstream, or bidirectional.  @msg{M_DATA}, @msg{M_PROTO}, or
@msg{M_PCPROTO} messages, for example, can be sent in both directions.  Other message types are
intended to be sent upstream to be processed only by the @dfn{Stream head}.  Messages intended to be
sent downstream are silently discarded if received by the @dfn{Stream head}.

@dfn{STREAMS} enables modules to create messages and pass them to neighbouring modules.  However, the
@manpage{read(2)} and @manpage{write(2)} system calls are not sufficient to enable a user process to
generate and receive all such messages.  First, read and write are byte-stream oriented with no
concept of message boundaries.  To support service interfaces, the message boundary of each service
primitive must be preserved so that the beginning and end of each primitive can be located.  Also,
read and write offer only one buffer to the user for transmitting and receiving @dfn{STREAMS}
messages.  If control information and data were placed in a single buffer, the user would have to
parse the contents of the buffer to separate the data from the control information.

The @command{putmsg} system call enables a user to create messages and send them downstream.  The
user supplies the contents of the control and data parts of the message in two separate buffers.
The @command{getmsg} system call retrieves @msg{M_DATA} or @msg{M_PROTO} messages from a
@dfn{Stream} and places the contents into two user buffers.

The format of @command{putmsg} is as follows:

@smallexample
int
putmsg(fd, ctlptr, dataptr, flags)
        int fd, flags;
        struct strbuf *ctlptr, *dataptr;
@end smallexample

@var{fd} identifies the @dfn{Stream} to which the message will be passed, @var{ctlptr} and
@var{dataptr} identify the control and data parts of the message, and @var{flags} may be used to
specify that a high priority message (@msg{M_PCPROTO}) should be sent.  When a control part is
present, setting @var{flags} to @samp{0} generates an @msg{M_PROTO} message.  If flags is set to
@constant{RS_HIPRI}, an @msg{M_PCPROTO} message is generated.

The @dfn{Stream} head guarantees that the control part of a message generated by @manpage{putmsg(2)}
is at least @samp{64} bytes in length.  This promotes reuse of the buffer.  When the buffer is
a reasonable size, modules and drivers may reuse the buffer for other headers.

The @code{strbuf} structure is used to describe the control and data parts of a message, and has the
following format:

@smallexample
struct strbuf @{
    int maxlen;     /* maximum buffer length */
    int len;        /* length of data */
    char *buf;      /* pointer to buffer */
@}
@end smallexample

@var{buf} points to a buffer containing the data and @var{len} specifies the number of bytes of data
in the buffer.  @var{maxlen} specifies the maximum number of bytes the given buffer can hold, and is
only meaningful when retrieving information into the buffer using @command{getmsg}.

The @command{getmsg} system call retrieves @msg{M_DATA}, @msg{M_PROTO}, or @msg{M_PCPROTO} messages
available at the @dfn{Stream} head, and has the following format:

@smallexample
int getmsg(int fd, struct strbuf *ctlptr, struct strbuf *dataptr, int *flagsp);
@end smallexample

The arguments to @command{getmsg} are the same as those of @command{putmsg} except that the
@var{flagsp} parameter is a pointer to an @code{int}.

@manpage{putpmsg(2)} and @manpage{getpmsg(2)} (see @manref{putpmsg(2)} and @manref{getpmsg(2)})
support multiple bands of data flow.  They are analogous to the system calls @manpage{putmsg(2)} and
@manpage{getmsg(2)}.  The extra parameter is the priority band of the message.

@manpage{putpmsg(2)} has the following interface:

@smallexample
int
putpmsg(fd, ctlptr, dataptr, band, flags)
        int fd, band, flags;
        struct strbuf *ctlptr, *dataptr;
@end smallexample

The parameter @var{band} is the priority band of the message to put downstream.  The valid values
for @var{flags} are @constant{MSG_HIPRI} and @constant{MSG_BAND}.  @constant{MSG_BAND} and @constant{MSG_HIPRI} are
mutually exclusive.  @constant{MSG_HIPRI} generates a high priority message (@msg{M_PCPROTO}) and
@var{band} is ignored.  @constant{MSG_BAND} causes an @msg{M_PROTO} or @msg{M_DATA} message to be
generated and sent down the priority band specified by @var{band}.  The valid range for band is from
@samp{0} to @samp{255} inclusive.

The call

@smallexample
putpmsg(fd, ctlptr, dataptr, 0, MSG_BAND)
@end smallexample

is equivalent to the the system call

@smallexample
putmsg(fd, ctlptr, dataptr, 0)
@end smallexample

and the call

@smallexample
putpmsg(fd, ctlptr, dataptr, 0, MSG_HIPRI)
@end smallexample

is equivalent to the system call

@smallexample
putmsg(fd, ctlptr, dataptr, RS_HIPRI)
@end smallexample

If @constant{MSG_HIPRI} is set and band is non-zero, @manpage{putpmsg(2)} fails with @errno{EINVAL}.

@manpage{getpmsg(2)} has the following format:

@smallexample
int
getpmsg(fd, ctlptr, dataptr, bandp, flagsp)
        int fd, *bandp, *flagsp;
        struct strbuf *ctlptr, *dataptr;
@end smallexample

@var{bandp} is the priority band of the message.  This system call retrieves a message from the
@dfn{Stream}.  If @samp{*flagsp} is set to @constant{MSG_HIPRI}, @manpage{getpmsg(2)} attempts to retrieve
a high priority message.  If @constant{MSG_BAND} is set, @manpage{getpmsg(2)} tries to retrieve a message
from priority band @samp{*bandp} or higher.  If @constant{MSG_ANY} is set, the first message on the
@dfn{Stream head} read queue is retrieved.  These three flags (@constant{MSG_HIPRI}, @constant{MSG_BAND}, and
@constant{MSG_ANY}) are mutually exclusive.  On return, if a high priority message was retrieved,
@samp{*flagsp} is set to @constant{MSG_HIPRI} and @samp{*bandp} is set to @samp{0}.  Otherwise,
@samp{*flagsp} is set to @constant{MSG_BAND} and @samp{*bandp} is set to the band of the message
retrieved.

The call

@smallexample
int band = 0;
int flags = MSG_ANY;
getpmsg(fd, ctlptr, dataptr, &band, &flags);
@end smallexample

is equivalent to

@smallexample
int flags = 0;
getmsg(fd, ctlptr, dataptr, &flags);
@end smallexample

If @constant{MSG_HIPRI} is set and @samp{*bandp} is non-zero, @manpage{getpmsg(2)} fails with
@errno{EINVAL}.

@node Control of Stream Head Processing
@subsection Control of Stream Head Processing
@menu
* Read Options::
* Write Options::
@end menu

The @msg{M_SETOPTS} message allows a driver or module to exercise control over certain @dfn{Stream
head} processing.  An @msg{M_SETOPTS} can be sent upstream at any time.  The @dfn{Stream head}
responds to the message by altering the processing associated with certain system calls.  The
options to be modified are specified by the contents of the @code{stroptions} structure (@pxref{STREAMS
Data Structures}) contained in the message.

Six @dfn{Stream head} characteristics can be modified.  Four characteristics correspond to fields
contained in @code{queue} (min/max packet sizes and high/low water marks).  The other two are
discussed here.

@node Read Options
@subsubsection Read Options

The value for read options (@var{so_readopt}) corresponds to two sets of three modes a user can set
via the @ioctlref{I_SRDOPT} @command{ioctl} (see @manpage{streamio(7)}) call.  The first set deals with
data and message boundaries:

@table @asis
@item @dfn{byte-stream} (@constant{RNORM})
The @manpage{read(2)} call completes when the byte count is satisfied, the @dfn{Stream head} read
queue becomes empty, or a zero length message is encountered.  In the last case, the zero length
message is put back on the queue.  A subsequent read will return @samp{0} bytes.
@item @dfn{message non-discard} (@constant{RMSGN})
The @manpage{read(2)} call completes when the byte count is satisfied or at a message boundary,
whichever comes first.  Any data remaining in the message are put back on the @dfn{Stream head} read
queue.
@item @dfn{message discard} (@constant{RMSGD})
The @manpage{read(2)} call completes when the byte count is satisfied or at a message boundary.  Any
data remaining in the message are discarded.
@end table

@dfn{Byte-stream mode} approximately models pipe data transfer.  @dfn{Message non-discard mode}
approximately models a @dfn{TTY} in canonical mode.

The second set deals with the treatment of protocol messages by the @manpage{read(2)} system call:

@table @asis

@item @dfn{normal protocol} (@constant{RPROTNORM})
The @manpage{read(2)} call fails with @errno{EBADMSG} if an @msg{M_PROTO} or @msg{M_PCPROTO} message
is at the front of the @dfn{Stream head} read queue.  This is the default operation protocol.

@item @dfn{protocol discard} (@constant{RPROTDIS})
The @manpage{read(2)} call will discard any @msg{M_PROTO} or @msg{M_PCPROTO} blocks in a message,
delivering the @msg{M_DATA} blocks to the user.

@item @dfn{protocol data} (@constant{RPROTDAT})
The @manpage{read(2)} call converts the @msg{M_PROTO} and @msg{M_PCPROTO} message blocks to
@msg{M_DATA} blocks, treating the entire message as data.

@end table

@node Write Options
@subsubsection Write Options

The value for write offset (@var{so_wroff}) is a hook to allow more efficient data handling.  It
works as follows: In every data message generated by a @manpage{write(2)} system call and in the
first @msg{M_DATA} block of the data portion of every message generated by a @manpage{putmsg(2)}
call, the @var{Stream head} will leave @samp{so_wroff} bytes of space at the beginning of the
message block.  Expressed as a C language construct:

@smallexample
bp->b_rptr = bp->b_datap->db_base + write offset.
@end smallexample

The write offset value must be smaller than the maximum @dfn{STREAMS} message size, @constant{STRMSGSZ}
(@pxref{Tunable Parameters}).  In certain cases (e.g., if a buffer large enough to hold the
@samp{offset+data} is not currently available), the write offset might not be included in the block.
To handle all possibilities, modules and drivers should not assume that the offset exists in a
message, but should always check the message.

The intended use of write offset is to leave room for a module or a driver to place a protocol
header before user data in the message rather than by allocating and prepending a separate message.

@node Queues and Priority
@section STREAMS Message Queues and Priority
@cindex message queues and priority

Message queues grow when the @dfn{STREAMS} scheduler is delayed from calling a service procedure
because of system activity, or when the procedure is blocked by flow control.  When called by the
scheduler the service procedure processes enqueued messages in a @dfn{First-In-First-Out (FIFO)}
manner.  However, expedited data support and certain conditions require that associated messages
(e.g., an @msg{M_ERROR}) reach their @dfn{Stream} destination as rapidly as possible.  This is
accomplished by associating priorities to the messages.  These priorities imply a certain ordering
of messages on the queue as shown in @figref{22}.  Each message has a priority band associated with
it.  Ordinary messages have a priority of zero.  High priority messages are high priority by nature
of their message type.  Their priority band is ignored.  By convention, they are not affected by
flow control.  The @manpage{putq(9)} utility routine places high priority messages at the head of
the message queue followed by priority band messages (expedited data) and ordinary messages.

@figuresized{SPG_fig22,22,Message Ordering on a Queue,5in}

When a message is queued, it is placed after the messages of the same priority already on the queue
(i.e., @dfn{FIFO} within their order of queueing).  This affects the flow control parameters
associated with the band of the same priority.  Message priorities range from @samp{0} (normal) to
@samp{255} (highest).  This provides up to @samp{256} bands of message flow within a @dfn{Stream}.
Expedited data can be implemented with one extra band of flow (priority band 1) of data.  This is
shown in @figref{23}.

@figuresized{SPG_fig23,23,Message Ordering with One Priority Band,2.5in}

High priority messages are not subject to flow control.  When they are queued by @manpage{putq(9)},
the associated queue is always scheduled (in the same manner as any queue; following all other
queues currently scheduled).  When the service procedure is called by the scheduler, the procedure
uses @manpage{getq(9)} to retrieve the first message on queue, which will be a high priority
message, if present.  Service procedures must be implemented to act on high priority messages
immediately.  The above mechanisms priority message queueing, absence of flow control, and immediate
processing by a procedure result in rapid transport of high priority messages between the
originating and destination components in the @dfn{Stream}.

Several routines are provided to aid users in controlling each priority band of data flow.  These
routines are @manpage{flushband(9)}, @manpage{bcanput(9)}, @manpage{strqget(9)}, and
@manpage{strqset(9)}.  The @manpage{flushband(9)} routine is discussed in @ref{Flush Handling}, the
@manpage{bcanput(9)} routine is discussed under @ref{Flow Control}, later in this chapter, and the
other two routines are described next.  @ref{STREAMS Utilities}, also has a description of these
routines.

The @manpage{strqget(9)} routine allows modules and drivers to obtain information about a queue or
particular band of the queue.  This provides a way to insulate the @dfn{STREAMS} data structures
from the modules and drivers.  The format of the routine is:

@smallexample
int
strqget(q, what, pri, valp)
        register queue_t *q;
        qfields_t what;
        register unsigned char pri;
        long *valp;
@end smallexample

The information is returned in the @code{long} referenced by @var{valp}.  The fields that can be
obtained are defined by the following:

@smallexample
typedef enum qfields @{
    QHIWAT = 0,         /* q_hiwat or qb_hiwat */
    QLOWAT = 1,         /* q_lowat or qb_lowat */
    QMAXPSZ = 2,        /* q_maxpsz */
    QMINPSZ = 3,        /* q_minpsz */
    QCOUNT = 4,         /* q_count or qb_count */
    QFIRST = 5,         /* q_first or qb_first */
    QLAST = 6,          /* q_last or qb_last */
    QFLAG = 7,          /* q_flag or qb_flag */
    QBAD = 8
@} qfields_t;
@end smallexample

This routine returns @samp{0} on success and an error number on failure.

The routine @manpage{strqset(2)} allows modules and drivers to change information about a queue or
particular band of the queue.  This also insulates the @dfn{STREAMS} data structures from the
modules and drivers.  Its format is:

@smallexample
int
strqset(q, what, pri, val)
        register queue_t *q;
        qfields_t what;
        register unsigned char pri;
        long val;
@end smallexample

The updated information is provided by @var{val}.  @manpage{strqset(2)} returns @samp{0} on success
and an error number on failure.  If the field is intended to be read-only, then the error
@errno{EPERM} is returned and the field is left unchanged.  The following fields are currently
read-only: @constant{QCOUNT}, @constant{QFIRST}, @constant{QLAST}, and @constant{QFLAG}.

The @command{ioctl}s @streamio{I_FLUSHBAND}, @streamio{I_CKBAND}, @streamio{I_GETBAND}, @streamio{I_CANPUT}, and
@streamio{I_ATMARK} support multiple bands of data flow.  The @command{ioctl} @streamio{I_FLUSHBAND} allows a
user to flush a particular band of messages.  It is discussed in more detail in @ref{Flush
Handling}.

The @command{ioctl} @ioctlref{I_CKBAND} allows a user to check if a message of a given priority exists on
the @dfn{Stream head} read queue.  Its interface is:

@smallexample
ioctl(fd, I_CKBAND, pri);
@end smallexample

This returns @samp{1} if a message of priority @var{pri} exists on the @dfn{Stream head} read queue
and @samp{0} if no message of priority @var{pri} exists.  If an error occurs, @samp{-1} is returned.
Note that @var{pri} should be of type @code{int}.

The @command{ioctl} @ioctlref{I_GETBAND} allows a user to check the priority of the first message on the
@dfn{Stream head} read queue.  The interface is:

@smallexample
ioctl(fd, I_GETBAND, prip);
@end smallexample

This results in the integer referenced by @var{prip} being set to the priority band of the message
on the front of the @dfn{Stream head} read queue.

The @command{ioctl} @ioctlref{I_CANPUT} allows a user to check if a certain band is writable.  Its
interface is:

@smallexample
ioctl(fd, I_CANPUT, pri);
@end smallexample

The return value is @samp{0} if the priority band @var{pri} is flow controlled, @samp{1} if the band
is writable, and @samp{-1} on error.

The field @var{b_flag} of the @code{msgb} structure can have a flag @constant{MSGMARK} that allows a
module or driver to mark a message.  This is used to support @dfn{TCP}'s (@dfn{Transport Control
Protocol}) ability to indicate to the user the last byte of out-of-band data.  Once marked, a
message sent to the @dfn{Stream head} causes the @dfn{Stream head} to remember the message.  A user
may check to see if the message on the front of its @dfn{Stream head} read queue is marked or not
with the @ioctlref{I_ATMARK} @command{ioctl}.  If a user is reading data from the @dfn{Stream head} and
there are multiple messages on the read queue, and one of those messages is marked, the
@manpage{read(2)} terminates when it reaches the marked message and returns the data only up to that
marked message.  The rest of the data may be obtained with successive reads.

The @command{ioctl} @streamio{I_ATMARK} has the following format:

@smallexample
ioctl(fd, I_ATMARK, flag);
@end smallexample

where flag may be either @constant{ANYMARK} or @constant{LASTMARK}.  @constant{ANYMARK} indicates that the user
merely wants to check if the message is marked.  @constant{LASTMARK} indicates that the user wants to see
if the message is the only one marked on the queue.  If the test succeeds, @samp{1} is returned.  On
failure, @samp{0} is returned.  If an error occurs, @samp{-1} is returned.

@subsection The @code{queue} Structure

Service procedures, message queues, message priority, and basic flow control are all intertwined in
@dfn{STREAMS}.  A queue will generally not use its message queue if there is no @command{service}
procedure in the queue.  The function of a @command{service} procedure is to process messages on its
queue.  Message priority and flow control are associated with message queues.

The operation of a queue revolves around the @code{queue} structure:

@smallexample
struct queue @{
    struct qinit *q_qinfo;   /* procedures and limits for queue */
    struct msgb *q_first;    /* head of message queue for this queue */
    struct msgb *q_last;     /* tail of message queue for this queue */
    struct queue *q_next;    /* next queue in Stream */
    struct queue *q_link;    /* to next queue for scheduling */
    _VOID *q_ptr;            /* to private data structure */
    ulong q_count;           /* number of bytes in queue */
    ulong q_flag;            /* queue state */
    long q_minpsz;           /* min packet size accepted by this module */
    long q_maxpsz;           /* max packet size accepted by this module */
    ulong q_hiwat;           /* queue high water mark for flow control */
    ulong q_lowat;           /* queue low water mark for flow control */
    struct qband *q_bandp;   /* separate flow information */
    unsigned char q_nband;   /* number of priority bands */
    unsigned char q_blocked; /* number of bands flow controlled */
    unsigned char q_pad1[2]; /* reserved for future use */
    long q_pad2[2];          /* reserved for future use */
@};

typedef struct queue queue_t;
@end smallexample

Queues are always allocated in pairs (read and write); one queue pair per a module, a driver, or a
@dfn{Stream head}.  A queue contains a linked list of messages.  When a queue pair is allocated, the
following fields are initialized by @dfn{STREAMS}:

@itemize @bullet
@item @var{q_qinfo} from @type{streamtab}
@item @var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, @var{q_lowat} from @code{module_info}
@end itemize

Copying values from @type{module_info} allows them to be changed in the queue without modifying the
@type{streamtab} and @type{module_info} values.

@var{q_count} is used in flow control calculations and is the number of bytes in messages on the queue.

@subsubsection Using @code{queue} Information

Modules and drivers should use @dfn{STREAMS} utility routines (@pxref{STREAMS Utilities}) to alter
@var{q_first}, @var{q_last}, @var{q_count}, and @var{q_flag}.

Modules and drivers can change @var{q_ptr}, @var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, and
@var{q_lowat}.

Modules and drivers can read but should not change @var{q_qinfo}, @var{q_next}, @var{q_bandp}, and
@var{q_nband}.

Modules and drivers should not touch @var{q_link}, @var{q_pad1}, and @var{q_pad2}.

@subsubsection Queue Flags

Programmers using the @dfn{STREAMS} mechanism should be aware of the following queue flags:

@multitable @columnfractions .10 .90
@item @constant{QENAB} @tab queue is enabled to run the @command{service} procedure (it is on the run queue)
@item @constant{QWANTR} @tab someone wants to read from the queue
@item @constant{QWANTW} @tab someone wants to write to the queue
@item @constant{QFULL} @tab queue is full
@item @constant{QREADR} @tab set for read queues
@item @constant{QUSE} @tab queue has been allocated
@item @constant{QNOENB} @tab do not enable the queue when data are placed on it
@item @constant{QBACK} @tab queue has been back-enabled
@item @constant{QOLD} @tab queue supports module/driver interface to open/close developed prior to @cite{UNIX System V Release 4.0}
@item @constant{QHLIST} @tab the @dfn{Stream head} write queue is scanned
@end multitable

@subsubsection The @code{qband} Structure

The queue flow information for each band is contained in a @code{qband} structure.  It is defined as
follows:

@smallexample
struct qband @{
    struct qband *qb_next;      /* next band's info */
    ulong qb_count;             /* number of bytes in band */
    struct msgb *qb_first;      /* beginning of band's data */
    struct msgb *qb_last;       /* end of band's data */
    ulong qb_hiwat;             /* high water mark for band */
    ulong qb_lowat;             /* low water mark for band */
    ulong qb_flag;              /* flag, QB_FULL, denotes that a band
                                   of data flow is flow controlled */
    long qb_pad1;               /* reserved for future use */
@};

typedef struct qband qband_t;

/*
 * qband flags
 */
#define QB_FULL       0x01      /* band is considered full */
#define QB_WANTW      0x02      /* someone wants to write to band */
#define QB_BACK       0x04      /* queue has been back-enabled */
@end smallexample

This structure contains pointers to the linked list of messages on the queue.  These pointers,
@var{qb_first} and @var{qb_last}, denote the beginning and end of messages for the particular band.
The @var{qb_count} field is analogous to the queue's @var{q_count} field.  However, @var{qb_count}
only applies to the messages on the queue in the band of data flow represented by the corresponding
@code{qband} structure.  In contrast, @var{q_count} only contains information regarding normal and
high priority messages.

Each band has a separate high and low water mark, @var{qb_hiwat} and @var{qb_lowat}.  These are
initially set to the queue's @var{q_hiwat} and @var{q_lowat} respectively.  Modules and drivers may
change these values if desired through the @manpage{strqset(9)} function.  Three flags,
@constant{QB_FULL}, @constant{QB_WANTW}, and @constant{QB_BACK}, are defined for @var{qb_flag}.
@constant{QB_FULL}
denotes that the particular band is full.  @constant{QB_WANTW} indicates that someone tried to write to
the band that was flow controlled.  @constant{QB_BACK} is set when the service procedure runs as a result
of being back-enabled because the queue is no longer flow-controlled.

The @code{qband} structures are not preallocated per queue.  Rather, they are allocated when a
message with a priority greater than zero is placed on the queue via @manpage{putq(9)},
@manpage{putbq(9)}, or @manpage{insq(9)}.  Since band allocation can fail, these routines return
@samp{0} on failure and @samp{1} on success.  Once a @code{qband} structure is allocated, it remains
associated with the queue until the queue is freed.  @manpage{strqset(9)} and @manpage{strqget(9)}
will cause @code{qband} allocation to occur.

@subsubsection Using @code{qband} Information

The @dfn{STREAMS} utility routines should be used when manipulating the fields in the @code{qband}
structures.  The routines @manpage{strqset(9)} and @manpage{strqget(9)} should be used to access
band information.

Drivers and modules are allowed to change the @var{qp_hiwat} and @var{qp_lowat} fields of the
@code{qband} structure.

Drivers and modules may only read the @var{qb_count}, @var{qb_first}, @var{qb_last}, and
@var{qb_flag} fields of the @code{qband} structure.

The @var{pad} fields should not be used in the @code{qband} structure; they are intended for future
use.

The following figure depicts a queue with two priority bands of flow.

@figuresized{SPG_fig24,24,Data Structure Linkage,4in}

@subsection Message Processing

Put procedures are generally required in pushable modules.  Service procedures are optional.  If the
@command{put} routine enqueues messages, there must exist a corresponding @command{service} routine
that handles the enqueued messages.  If the @command{put} routine does not enqueue messages, the
@command{service} routine need not exist.

The general processing flow when both procedures are present is as follows:

@enumerate
@item  A message is received by the @command{put} procedure in a queue, where some processing may be
performed on the message.

@item  The @command{put} procedure places the message on the queue by use of the @manpage{putq(9)}
utility routine for the @command{service} procedure to perform further processing at some later
time.

@item  @manpage{putq(9)} places the message on the queue based on its priority.

@item  Then, @manpage{putq(9)} makes the queue ready for execution by the @dfn{STREAMS} scheduler
following all other queues currently scheduled.

@item  After some indeterminate delay (intended to be short), the @dfn{STREAMS} scheduler calls the
@command{service} procedure.

@item  The @command{service} procedure gets the first message (@var{q_first}) from the message queue
with the @manpage{getq(9)} utility.

@item  The @command{service} procedure processes the message and passes it to the @command{put}
procedure of the next queue with @manpage{putnext(9)}.

@item  The @command{service} procedure gets the next message and processes it.

@end enumerate

This processing continues until the queue is empty or flow control blocks further processing.  The
@command{service} procedure returns to the caller.

A @command{service} procedure must never sleep since it has no user context.  It must always return
to its caller.

If no processing is required in the @command{put} procedure, the procedure does not have to be
explicitly declared.  Rather, @manpage{putq(9)} can be placed in the @code{qinit} structure
declaration for the appropriate queue side to queue the message for the @command{service} procedure,
e.g.,

@smallexample
static struct qinit winit = @{ putq, modwsrv, ....... @};
@end smallexample

More typically, @command{put} procedures will, at a minimum, process high priority messages to avoid
queueing them.

The key attribute of a @command{service} procedure in the @dfn{STREAMS} architecture is delayed
processing.  When a @command{service} procedure is used in a module, the module developer is
implying that there are other, more time sensitive activities to be performed elsewhere in this
@dfn{Stream}, in other @dfn{Streams}, or in the system in general.  The presence of a
@command{service} procedure is mandatory if the flow control mechanism is to be utilized by the
queue.

The delay for @dfn{STREAMS} to call a @command{service} procedure will vary with implementation and
system activity.  However, once the @command{service} procedure is scheduled, it is guaranteed to be
called before user level activity is resumed.

If a module or driver wishes to recognize priority bands, the @command{service} procedure is written
to the following algorithm:

@smallexample
.
.
while ((bp = getq(q)) != NULL) @{
    if (bp->b_datap->db_type >= QPCTL) @{
        putnext(q, bp);
    @} else if (bcanputnext(q, bp->b_band)) @{
        putnext(q, bp);
    @} else @{
        putbq(q, bp);
        return;
    @}
@}
.
.
@end smallexample

@anchor{Flow Control}
@subsubsection Flow Control

The @dfn{STREAMS} flow control mechanism is voluntary and operates between the two nearest queues in
a @dfn{Stream} containing @command{service} procedures (see @figref{25}).  Messages are generally
held on a queue only if a @command{service} procedure is present in the associated queue.

Messages accumulate on a queue when the queue's @command{service} procedure processing does not keep
pace with the message arrival rate, or when the procedure is blocked from placing its messages on
the following @dfn{Stream} component by the flow control mechanism.  Pushable modules contain
independent upstream and downstream limits.  The @dfn{Stream head} contains a preset upstream limit
(which can be modified by a special message sent from downstream) and a driver may contain a
downstream limit.

Flow control operates as follows:

@enumerate
@item  Each time a @dfn{STREAMS} message handling routine (for example, @manpage{putq(9)}) adds or
removes a message from a message queue, the limits are checked.  @dfn{STREAMS} calculates the total
size of all message blocks (@samp{bp->b_wptr - bp->b_rptr}) on the message queue.
@item  The total is compared to the queue high water and low water values.  If the total exceeds the
high water value, an internal full indicator is set for the queue.  The operation of the
@command{service} procedure in this queue is not affected if the indicator is set, and the
@command{service} procedure continues to be scheduled.
@item  The next part of flow control processing occurs in the nearest preceding queue that contains a
@command{service} procedure.  In @figref{25}, if @samp{D} is full and @samp{C} has no
@command{service} procedure, then @samp{B} is the nearest preceding queue.
@item  The service procedure in @samp{B} uses a @dfn{STREAMS} utility routine to see if a queue
ahead is marked full.  If messages cannot be sent, the scheduler blocks the service procedure in
@samp{B} from further execution.  @samp{B} remains blocked until the low water mark of the full
queue, @samp{D}, is reached.
@item  While @samp{B} is blocked, any messages except high priority messages arriving at @samp{B}
will accumulate on its message queue (recall that high priority messages are not subject to flow
control).  Eventually, @samp{B} may reach a full state and the full condition will propagate back to
the module in the @dfn{Stream}.
@item  When the @command{service} procedure processing on @samp{D} causes the message block total to
fall below the low water mark, the full indicator is turned off.  Then, @dfn{STREAMS} automatically
schedules the nearest preceding blocked queue (@samp{B} in this case), getting things moving again.
This automatic scheduling is known as back-enabling a queue.
@end enumerate

@figuresized{SPG_fig25,25,Flow Control,3in}

Modules and drivers need to observe the message priority.  High priority messages, determined by the
type of the first block in the message, (@samp{mp->b_datap->db_type >= QPCTL}), are not subject to
flow control.  They are processed immediately and forwarded, as appropriate.

For ordinary messages, flow control must be tested before any processing is performed.  The
@manpage{canputnext(9)} utility determines if the forward path from the queue is blocked by flow
control.

This is the general flow control processing of ordinary messages:

@enumerate
@item  Retrieve the message at the head of the queue with @manpage{getq(9)}.
@item  Determine if the message type is high priority and not to be processed here.
@item  If so, pass the message to the @command{put} procedure of the following queue with @manpage{putnext(9)}.
@item  Use @manpage{canputnext(9)} to determine if messages can be sent onward.
@item  If messages should not be forwarded, put the message back on the queue with
@manpage{putbq(9)} and return from the procedure.
@item  Otherwise, process the message.
@end enumerate

The canonical representation of this processing within a service procedure is as follows:

@smallexample
while (qetq != NULL)
    if (high priority message||canputnext)
         process message
         putnext
    else
         putbq
    return
@end smallexample

Expedited data have their own flow control with the same general processing as that of ordinary
messages.  @manpage{bcanputnext(9)} is used to provide modules and drivers with a way to test flow
control in the given priority band.  It returns @samp{1} if a message of the given priority can be
placed on the queue.  It returns @samp{0} if the priority band is flow controlled.  If the band does
not yet exist on the queue in question, the routine returns @samp{1}.

If the band is flow controlled, the higher bands are not affected.  However, the same is not true
for lower bands.  The lower bands are also stopped from sending messages.  If this did not take place,
the possibility would exist where lower priority messages would be passed along ahead of the flow
controlled higher priority ones.

The call @samp{bcanputnext(q, 0);} is equivalent to the call @samp{canputnext(q);}.

A @command{service} procedure must process all messages on its queue unless flow control prevents
this.

A @command{service} procedure continues processing messages form its queue until @manpage{getq(9)}
returns @samp{NULL}.  When an ordinary message is enqueued by @manpage{putq(9)}, @manpage{putq(9)}
will cause the @command{service} procedure to be scheduled only if the queue was previously empty,
and a previous @manpage{getq(9)} call returns @samp{NULL} (that is, the @constant{QWANTR} flag is set).  If
there are messages on the queue, @manpage{putq(9)} presumes the @command{service} procedure is
blocked by flow control and the procedure will be automatically rescheduled by @dfn{STREAMS} when
the block is removed.  If the @command{service} procedure cannot complete processing as a result of
conditions other than flow control (e.g., no buffers), it must ensure it will return later (e.g., by
use of @manpage{bufcall(9)} utility routine) or it must discard all messages on the queue.  If this
is not done, @dfn{STREAMS} will never schedule the @command{service} procedure to be run unless the
queue's @command{put} procedure enqueues a priority message with @manpage{putq(9)}.

High priority messages are discarded only if there is already a high priority message on the
@dfn{Stream head} read queue.  That is, there can be only one high priority message present on the
@dfn{Stream head} read queue at any time.

@manpage{putbq(9)} replaces messages at the beginning of the appropriate section of the message
queue in accordance with their priority.  This might not be the same position at which the message
was retrieved by the preceding @manpage{getq(9)}.  A subsequent @manpage{getq(9)} might return a
different message.

@manpage{putq(9)} only looks at the priority band in the first message.  If a high priority message
is passed to @manpage{putq(9)} with a non-zero @var{b_band} value, @var{b_band} is reset to 0 before
placing the message on the queue.@footnote{Under @cite{@value{PACKAGE_TITLE}}, this is performed by
@manref{putq(9)}, @manref{putbq(9)} and @manref{insq(9)}.} If the message is passed to
@manpage{putq(9)} with a @var{b_band} value that is greater than the number of @code{qband}
structures associated with the queue, @manpage{putq(9)} tries to allocate a new @code{qband}
structure for each band up to and including the band of the message.

The above also applies to @manpage{putbq(9)} and @manpage{insq(9)}.  If an attempt is made to insert
a message out of order in a queue via @manpage{insq(9)}, the message is not inserted and the routine
fails.

@manpage{putq(9)} will not schedule a queue if @manpage{noenable(9)} had been previously called for
this queue.  @manpage{noenable(9)} instructs @manpage{putq(9)} to enqueue the message when called by
this queue, but not to schedule the @command{service} procedure.  @manpage{noenable(9)} does not
prevent the queue from being scheduled by a flow control back-enable.  The inverse of
@manpage{noenable(9)} is @manpage{enableok(9)}.

Driver upstream flow control is explained next as an example.  Although device drivers typically
discard input when unable to send it to a user process, @dfn{STREAMS} allows driver read-side flow
control, possibly for handling temporary upstream blockages.  This is done through a driver read
@command{service} procedure which is disabled during the driver open with @manpage{noenable(9)}.  If
the driver input interrupt routine determines messages can be sent upstream (from
@manpage{canputnext(9)}), it sends the message with @manpage{putnext(9)}.  Otherwise, it calls
@manpage{putq(9)} to queue the message.  The message waits on the message queue (possibly with queue
length checked when new messages are enqueued by the interrupt routine) until the upstream queue
becomes unblocked.  When the blockage abates, @dfn{STREAMS} back-enables the driver read
@command{service} procedure.  The @command{service} procedure sends the messages upstream using
@manpage{getq(9)} and @manpage{canputnext(9)}, as described previously.  This is similar to
@command{looprsrv()} (@pxref{Loop-Around Driver}) where the @command{service} procedure is present
only for flow control.

@manpage{qenable(9)}, another flow control utility, allows a module or driver to cause one of its
queues, or another module's queues, to be scheduled.  @manpage{qenable(9)} might also be used when a
module or driver wants to delay message processing for some reason.  An example of this is a buffer
module that gathers messages in its message queue and transfers them as a single, larger message.
This module uses @manpage{noenable(9)} to inhibit its @command{service} procedure and queues
messages with its @command{put} procedure until a certain byte count or "in queue" time has been
reached.  When either of these conditions is met, the module calls @manpage{qenable(9)} to cause its
@command{service} procedure to run.

Another example is a communication line discipline module that implements end-to-end (i.e., to a
remote system) flow control.  Outbound data are held on the write-side message queue until the
read-side receives a transmit window from the remote end of the network.

@dfn{STREAMS} routines are called at different priority levels.  Interrupt routines are called at the
interrupt priority of the interrupting device.  Service routines are called with interrupts enabled
(hence @command{service} routines for @dfn{STREAMS} drivers can be interrupted by their own
interrupt routines).  Put routines are generally called at @var{str} priority.

@subsection Scheduling

Flow control and scheduling mechanisms are closely related.  They are also influenced by other parts
of the kernel such as the memory management routines and the system call mechanism.  The following
subsections describes how the variables and data structures for flow control and scheduling are used,
and how the individual procedures work together.

@subsubsection Flow Control Variables

The flow control mechanism uses the @member{q_flag} bit mask in the @mantype{queue(9)} structure to
hold state information.  The flag values are described as follows:

@multitable @columnfractions .20 .80

@item @constant{QENAB} @tab
This flag is set by @manref{qenable(9)} and cleared when the @command{service} procedure is run by
@manref{runqueues(9)}.

@item @constant{QWANTR} @tab
This flag is set by @manref{getq(9)} (or @manref{rmvq(9)}) when it tries to take a message from the
queue but finds the queue empty, indicating that a @command{service} procedure wants to read from
the queue.  The flag is cleared when @manref{getq(9)} successfully takes a message from the queue.

@item @constant{QWANTW} @tab
This flag is set by @manref{canput(9)} (or @manref{bcanput(9)}) when it detects that the queue being
tested is above its high water mark.  It indicates that a function is trying to put data into the
queue.  The flag is cleared by @manref{getq(9)} (or @manref{rmvq(9)}) when the quantity of data in
the queue falls below the low-water mark.

@item @constant{QFULL} @tab
This flag is set when @manref{putq(9)} (or @manref{putbq(9)} or @manref{insq(9)}) make the queued
data count exceed the high water mark by putting a message on the queue.  The flag is cleared by
@manref{getq(9)} (or @manref{insq(9)}) when the data count falls below the high water mark.

@item @constant{QNOENB} @tab
This flag is set by @manref{noenable(9)} and is cleared by @manref{enableok(9)}.

@end multitable

Several variables are used by the scheduling and flow control mechanisms.  They fall in two
categories: boolean variables and list variables.  The boolean variables prevent the kernel from
trying to do two things at the same time.  The list variables link together items that are waiting
for something to happen.

@cartouche
@float Table,Table 100
@multitable @columnfractions .30 .70
@item char @var{qrunflag} @tab There is at least 1 enabled queue.
@item char @var{queueflag} @tab The function @manref{queuerun(9)} is running.
@item char @var{strbcflag} @tab There is enough free memory, so the @manref{bufcall(9)} functions must be run.
@item char @var{strbcwiat} @tab Someone has called @manref{bufcall(9)}, but there is not yet enough free memory to let the function execute.
@end multitable
@caption{@emph{Boolean Scheduling Variables}}
@end float
@end cartouche

@cartouche
@float Table,Table 101
@multitable @columnfractions .30 .70
@item struct queue *@var{qhead} @tab Pointer to the first queue in list of scheduled queues.
@item struct queue *@var{qtail} @tab Pointer to last queue in list of scheduled queues.
@item struct bclist @var{strbcalls} @tab List of @manref{bufcall(9)} functions pending execution.
@item struct queue *@var{scanqhead} @tab Head of @dfn{STREAMS} scan queue.
@item struct queue *@var{scanqtail} @tab Tail of @dfn{STREAMS} scan queue.
@item struct sefino *@var{sefreelist} @tab List of free Stream events use for scheduling @manref{bufcall(9)} and @manref{poll(2)}.
@item struct sefino *@var{secachep} @tab Pointer to secret store of Stream events for when times get hard and memory is low.
@item struct strinfo @var{Strinfo}[] @tab Keeps track of allocated Stream events.
@end multitable
@caption{@emph{List Scheduling Variables}}
@end float
@end cartouche

@subsubsection Flow Control Procedures

There are seven procedures that a @dfn{STREAMS} module or driver uses to manage queue flow control.
They are described as follows:

@subsubheading qenable(9)

@manref{qenable(9)} performs the following tasks:

@itemize @bullet
@item Checks whether the queue to be enabled has a @command{service} procedure; if not, it returns
to the caller.
@item Checks the @constant{QNOENB} bit in @member{q_flag}.  If it is set, the queue cannot be
enabled, so it returns to the caller.
@item Checks the @constant{QENAB} bit in @member{q_flag}.  If it is set, the queue has already been
enabled, so it returns to the caller.
@item Sets the @constant{QENAB} bit in @member{q_flag}.
@item Links the queue into the tail of the list of scheduled queues (@member{qtail}).
@item Sets @member{qrunflag} by calling the macro @manref{setqsched(9)}.
@end itemize

@subsubheading getq(9)

A back enable is done in two situations; when the current queue become empty, or if another module
or driver found the queue full previously, but now it has drained below its low water mark.

@subsubheading putq(9), putbq(9)

@manref{putq(9)} and @manref{putbq(9)} are similar.  They both put a message at the correction
position in the queue.  @manref{putq(9)} puts the message at the tail of the queue, whereas
@manref{putbq(9)} puts it at the head of the queue.  The correct position within the queue depends
on the message type and the message priority band.  Given a priority message, @manref{putq(9)} puts
it after the last priority message but before the ordinary messages in the queue.  Similarly,
@manref{putbq(9)} puts an ordinary message back into the queue after all the priority messages but
before the ordinary messages.

Note the circumstances in which the queue is enabled.  When the queue receives its first message
after being empty, it is enabled; this is a good policy because a @command{service} procedure
generally passes a batch of messages to the next queue.  That queue is then enabled and runs after
the current @command{service} procedure exists.

A queue is @emph{always} enabled when a priority message is placed on to it so that it can be
processed more quickly.  However, a deadlock condition could occur if a module puts a priority
message back on its own queue.  If the @command{service} procedure puts the priority message back on
its queue because it cannot pass it along, the @command{service} procedure exits; but putting the
priority message back on the queue makes it enabled again.  The @dfn{STREAMS} scheduler finds this
queue in its run queue list, so it calls the @command{service} procedure again.  The
@command{service} procedure gets the same message, but since the conditions have not changed the
message is put back.  This cycle continues indefinitely, giving the appearance that the system is
hung.  This problem does not occur when normal priority messages are put back.

@subsubsection The STREAMS Scheduler 

@node Service Interfaces
@section STREAMS Service Interfaces
@cindex service interfaces

@dfn{STREAMS} provides the means to implement a service interface between any two components in a
@dfn{Stream}, and between a user process and the topmost module in the @dfn{Stream}.  A service
interface is defined at the boundary between a service user and a service provider (see
@figref{27}).  A service interface is a set of primitives and the rules that define a service and
the allowable state transitions that result as these primitives are passed between the user and the
provider.  These rules are typically represented by a state machine.  In @dfn{STREAMS}, the service
user and provider are implemented in a module, driver, or user process.  The primitives are carried
bidirectionally between a service user and provider in @msg{M_PROTO} and @msg{M_PCPROTO} messages.

@dfn{PROTO} messages (@msg{M_PROTO} and @msg{M_PCPROTO}) can be multi-block, with the second through
last blocks of type @msg{M_DATA}.  The first block in a @dfn{PROTO} message contains the control
part of the primitive in a form agreed upon by the user and provider.  The block is not intended to
carry protocol headers.  (Although its use is not recommended, upstream @dfn{PROTO} messages can
have multiple @dfn{PROTO} blocks at the start of the message.  @manpage{getmsg(2)} will compact the
blocks into a single control part when sending to a user process.)  The @msg{M_DATA} block(s)
contains any data part associated with the primitive.  The data part may be processed in a module
that receives it, or it may be sent to the next @dfn{Stream} component, along with any data
generated by the module.  The contents of @dfn{PROTO} messages and their allowable sequences are
determined by the service interface specification.

@dfn{PROTO} messages can be sent bidirectionally (upstream and downstream) on a @dfn{Stream} and
between a @dfn{Stream} and a user process.  @manpage{putmsg(2)} and @manpage{getmsg(2)} system calls
are analogous, respectively, to @manpage{write(2)} and @manpage{read(2)} except that the former
allow both data and control parts to be (separately) passed, and they retain the message boundaries
across the user-@dfn{Stream} interface.  @manpage{putmsg(2)} and @manpage{getmsg(2)} separately copy
the control part (@msg{M_PROTO} or @msg{M_PCPROTO} block) and data part (@msg{M_DATA} blocks)
between the @dfn{Stream} and user process.

An @msg{M_PCPROTO} message is normally used to acknowledge primitives composed of other messages.
@msg{M_PCPROTO} insures that the acknowledgement reaches the service user before any other message.
If the service user is a user process, the @dfn{Stream head} will only store a single
@msg{M_PCPROTO} message, and discard subsequent @msg{M_PCPROTO} messages until the first one is read
with @manpage{getmsg(2)}.

A @dfn{STREAMS} message format has been defined to simplify the design of service interfaces.
System calls, @manpage{getmsg(2)} and @manpage{putmsg(2)} are available for sending messages
downstream and receiving messages that are available at the @dfn{Stream head}.

This section describes the system calls @command{getmsg} and @command{putmsg} in the context of a
service interface example.  First, a brief overview of @dfn{STREAMS} service interfaces is
presented.

@subsection Service Interface Benefits

A principal advantage of the @dfn{STREAMS} mechanism is its modularity.  From user level,
kernel-resident modules can be dynamically interconnected to implement any reasonable processing
sequence.  This modularity reflects the layering characteristics of contemporary network
architectures.

One benefit of modularity is the ability to interchange modules of like functions.  For example, two
distinct transport protocols, implemented as @dfn{STREAMS} modules, may provide a common set of
services.  An application or higher layer protocol that requires those services can use either
module.  This ability to substitute modules enables user programs and higher level protocols to be
independent of the underlying protocols and physical communication media.

Each @dfn{STREAMS} module provides a set of processing functions, or services, and an interface to those
services.  The service interface of a module defines the interaction between that module and any
neighbouring modules, and is a necessary component for providing module substitution.  By creating a
well defined service interface, applications and @dfn{STREAMS} modules can interact with any module that
supports that interface.  @figref{26} demonstrates this.

@figuresized{SPG_fig26,26,Protocol Substitution,4in}

By defining a service interface through which applications interact with a transport protocol, it is
possible to substitute a different protocol below that service interface in a manner completely
transparent to the application.  In this example, the same application can run over the
@dfn{Transmission Control Protocol (TCP)} and the @dfn{ISO} transport protocol.  Of course, the
service interface must define a set of services common to both protocols.

The three components of any service interface are the service user, the service provider, and the
service interface itself, as seen in the following figure.

@figuresized{SPG_fig27,27,Service Interface,3in}

Typically, a user makes a request of a service provider using some well-defined service primitive.
Responses and event indications are also passed from the provider to the user using service
primitives.

Each service interface primitive is a distinct @dfn{STREAMS} message that has two parts; a control part
and a data part.  The control part contains information that identifies the primitive and includes
all necessary parameters.  The data part contains user data associated with that primitive.

An example of a service interface primitive is a transport protocol connect request.  This primitive
requests the transport protocol service provider to establish a connection with another transport
user.  The parameters associated with this primitive may include a destination protocol address and
specific protocol options to be associated with that connection.  Some transport protocols also
allow a user to send data with the connect request.  A @dfn{STREAMS} message would be used to define this
primitive.  The control part would identify the primitive as a connect request and would include the
protocol address and options.  The data part would contain the associated user data.

@subsection Service Interface Library Example

The service interface library example presented here includes four functions that enable a user to
do the following:

@itemize @bullet
@item establish a @dfn{Stream} to the service provider and bind a protocol address to the @dfn{Stream},
@item send data to a remote user,
@item close the @dfn{Stream} connected to the provider
@end itemize

First, the structure and constant definitions required by the library are shown.  These typically
will reside in a header file associated with the service interface.

@smallexample
/*
 * Primitives initiated by the service user.
 */
#define BIND_REQ 1              /* bind request */
#define UNITDATA_REQ 2          /* unit data request */

/*
 * Primitives initiated by the service provider.
 */
#define OK_ACK 3                /* bind acknowledgement */
#define ERROR_ACK 4             /* error acknowledgement */
#define UNITDATA_IND 5          /* unit data indication */

/*
 * The following structure definitions define the format of the
 * control part of the service interface message of the above
 * primitives.
 */
struct bind_req @{               /* bind request */
    long PRIM_type;             /* always BIND_REQ */
    long BIND_addr;             /* addr to bind */
@};
struct unitdata_req @{           /* unit data request */
    long PRIM_type;             /* always UNITDATA_REQ */
    long BEST_addr;             /* destination addr */
@};
struct ok_ack @{                 /* positive acknowledgement */
    long PRIM_type;             /* always OK_ACK */
@};
struct error_ack @{              /* error acknowledgement */
    long PRIM_type;             /* always ERROR_ACK */
    long UNIX_error;            /* UNIX system error code */
@};
struct unitdata_ind @{           /* unit data indication */
    long PRIM_type;             /* always UNITDATA_IND */
    long SRC_addr;              /* source addr */
@};

/* union of all primitives */
union primitives @{
    long type;
    struct bind_req bind_req;
    struct unitdata_req unitdata_req;
    struct ok_ack ok_ack;
    struct error_ack error_ack;
    struct unitdata_ind unitdata_ind;
@};

/* header files needed by library */
#include <stropts.h>
#include <stdio.h>
#include <errno.h>
@end smallexample

Five primitives have been defined.  The first two represent requests from the service user to the
service provider.  These are:

@table @var
@item BIND_REQ
This request asks the provider to bind a specified protocol address.  It requires an acknowledgement
from the provider to verify that the contents of the request were syntactically correct.
@item UNITDATA_REQ
This request asks the provider to send data to the specified destination address.  It does not
require an acknowledgement from the provider.
@end table

The three other primitives represent acknowledgements of requests, or indications of incoming
events, and are passed from the service provider to the service user.  These are:

@table @var
@item OK_ACK
This primitive informs the user that a previous bind request was received successfully by the
service provider.
@item ERROR_ACK
This primitive informs the user that a non-fatal error was found in the previous bind request.  It
indicates that no action was taken with the primitive that caused the error.
@item UNITDATA_IND
This primitive indicates that data destined for the user has arrived.
@end table

The defined structures describe the contents of the control part of each service interface message
passed between the service user and service provider.  The first field of each control part defines
the type of primitive being passed.

@subsubsection Accessing the Service Provider

The first routine presented, @code{inter_open}, opens the protocol driver device file specified by
path and binds the protocol address contained in addr so that it may receive data.  On success, the
routine returns the file descriptor associated with the open @dfn{Stream}; on failure, it returns
@samp{-1} and sets @code{errno} to indicate the appropriate @b{Linux} system error value.

@smallexample
inter_open(path, oflags, addr)
        char *path;
@{
    int fd;
    struct bind_req bind_req;
    struct strbuf ctlbuf;
    union primitives rcvbuf;
    struct error_ack *error_ack;
    int flags;

    if ((fd = open(path, oflags)) < 0)
        return (-1);

    /* send bind request msg down stream */

    bind_req.PRIM_type = BIND_REQ;
    bind_req.BIND_addr = addr;
    ctlbuf.len = sizeof(struct bind_req);
    ctlbuf.buf = (char *) &bind_req;

    if (putmsg(fd, &ctlbuf, NULL, 0) < 0) @{
        close(fd);
        return (-1);
    @}
@end smallexample

After opening the protocol driver, @code{inter_open} packages a bind request message to send
downstream.  @manpage{putmsg(2)} is called to send the request to the service provider.  The bind
request message contains a control part that holds a @code{bind_req} structure, but it has no data
part.  @code{bind_req} is a structure of type @code{strbuf}, and it is initialized with the
primitive type and address.  Notice that the @var{maxlen} field of @var{ctlbuf} is not set before
calling @manpage{putmsg(2)}.  That is because @manpage{putmsg(2)} ignores this field.  The
@var{dataptr} argument to @manpage{putmsg(2)} is set to @samp{NULL} to indicate that the message
contains no data part.  Also, the @var{flags} argument is @samp{0}, which specifies that the message
is not a high priority message.

After @code{inter_open} sends the bind request, it must wait for an acknowledgement from the service
provider, as follows:

@smallexample
    /* wait for ack of request */

    ctlbuf.maxlen = sizeof(union primitives);
    ctlbuf.len = 0;
    ctlbuf.buf = (char *) &rcvbuf;
    flags = RS_HIPRI;

    if (getmsg(fd, &ctlbuf, NULL, &flags) < 0) @{
        close(fd);
        return (-1);
    @}

    /* did we get enough to determine type */
    if (ctlbuf.len < sizeof(long)) @{
        close(fd);
        errno = EPROTO;
        return (-1);
    @}

    /* switch on type (first long in rcvbuf) */
    switch (rcvbuf.type) @{
    default:
        close(fd);
        errno = EPROTO;
        return (-1);

    case OK_ACK:
        return (fd);

    case ERROR_ACK:
        if (ctlbuf.len < sizeof(struct error_ack)) @{
            close(fd);
            errno = EPROTO;
            return (-1);
        @}
        error_ack = (struct error_ack *) &rcvbuf;
        close(fd);
        errno = error_ack->UNIX_error;
        return (-1);
    @}
@}
@end smallexample

@manpage{getmsg(2)} is called to retrieve the acknowledgement of the bind request.  The
acknowledgement message consists of a control part that contains either an @code{ok_ack} or
@code{error_ack} structure, and no data part.

The acknowledgement primitives are defined as priority messages.  Messages are queued in a first-in-
first-out manner within their priority at the @dfn{Stream head}; high priority messages are placed
at the front of the @dfn{Stream head} queue followed by priority band messages and ordinary
messages.  The @dfn{STREAMS} mechanism allows only one high priority message per @dfn{Stream} at the
@dfn{Stream head} at one time; any further high priority messages are queued until the message at
the @dfn{Stream head} is processed.  (There can be only one high priority message present on the
@dfn{Stream head} read queue at any time.)  High priority messages are particularly suitable for
acknowledging service requests when the acknowledgement should be placed ahead of any other messages
at the @dfn{Stream head}.

Before calling getmsg, this routine must initialize the @code{strbuf} structure for the control
part.  @var{buf} should point to a buffer large enough to hold the expected control part, and
@var{maxlen} must be set to indicate the maximum number of bytes this buffer can hold.

Because neither acknowledgement primitive contains a data part, the @var{dataptr} argument to
@manpage{getmsg(2)} is set to @samp{NULL}.  The @var{flagsp} argument points to an integer
containing the value @constant{RS_HIPRI}.  This flag indicates that @manpage{getmsg(2)} should wait for a
@dfn{STREAMS} high priority message before returning.  It is set because we want to catch the
acknowledgement primitives that are priority messages.  Otherwise if the flag is zero the first
message is taken.  With @constant{RS_HIPRI} set, even if a normal message is available,
@manpage{getmsg(2)} will block until a high priority message arrives.

On return from @manpage{getmsg(2)}, the @var{len} field is checked to ensure that the control part
of the retrieved message is an appropriate size.  The example then checks the primitive type and
takes appropriate actions.  An @constant{OK_ACK} indicates a successful bind operation, and
@code{inter_open} returns the file descriptor of the open @dfn{Stream}.  An @errno{ERROR_ACK}
indicates a bind failure, and @manpage{errno(3)} is set to identify the problem with the request.

@subsubsection Closing the Service Provider

The next routine in the service interface library example is inter_close, which closes the
@dfn{Stream} to the service provider.

@smallexample
inter_close(fd)
@{
    close(fd);
@}
@end smallexample

The routine simply closes the given file descriptor.  This will cause the protocol driver to free
any resources associated with that @dfn{Stream}.  For example, the driver may unbind the protocol
address that had previously been bound to that @dfn{Stream}, thereby freeing that address for use by
some other service user.

@subsubsection Sending Data to the Service Provider

The third routine, @code{inter_snd}, passes data to the service provider for transmission to the
user at the address specified in @var{addr}.  The data to be transmitted are contained in the buffer
pointed to by @var{buf} and contains @var{len} bytes.  On successful completion, this routine
returns the number of bytes of data passed to the service provider; on failure, it returns @samp{-1}
and sets @manpage{errno(3)} to an appropriate @b{Linux} system error value.

@smallexample
inter_snd(fd, buf, len, addr)
        char *buf;
        long addr;
@{
    struct strbuf ctlbuf;
    struct unitdata_req unitdata_req;

    unitdata_req.PRIM_type = UNITDATA_REQ;
    unitdata_req.DEST_addr = addr;
    ctlbuf.len = sizeof(struct unitdata_req);
    ctlbuf.buf = (char *) &unitdata_req;
    databuf.len = len;
    databuf.buf = buf;

    if (putmsg(fd, &ctlbuf, &databuf, 0) < 0)
        return (-1);

    return (len);
@}
@end smallexample

In this example, the data request primitive is packaged with both a control part and a data part.
The control part contains a @code{unitdata_req} structure that identifies the primitive type and the
destination address of the data.  The data to be transmitted are placed in the data part of the
request message.

Unlike the bind request, the data request primitive requires no acknowledgement from the service
provider.  In the example, this choice was made to minimize the overhead during data transfer.  If
the @manpage{putmsg(2)} call succeeds, this routine assumes all is well and returns the number of
bytes passed to the service provider.

@subsubsection Receiving Data

The final routine in this example, @code{inter_rcv}, retrieves the next available data.  @var{buf}
points to a buffer where the data should be stored, @var{len} indicates the size of that buffer, and
@var{addr} points to a long integer where the source address of the data will be placed.  On
successful completion, @code{inter_rcv} returns the number of bytes in the retrieved data; on
failure, it returns @samp{-1} and sets the appropriate @b{Linux} system error value.

@smallexample
inter_rvc(fd, buf, len, addr)
        char *buf;
        long *addr;
@{
    struct strbuf ctlbuf;
    struct strbuf databuf;
    struct unitdata_ind unitdata_ind;
    int retval;
    int flagsp;

    ctlbuf.maxlen = sizeof(struct unitdata_ind);
    ctlbuf.len = 0;
    ctlbuf.buf = (char *) &unitdata_ind;
    databuf.maxlen = len;
    databuf.len = 0;
    databuf.buf = buf;
    flagsp = 0;

    if ((retval = getmsg(fd, &ctlbuf, &databuf, &flagsp)) < 0)
        return (-1);
    if (unitdata_ind.PRIM_type != UNITDATA_IND) @{
        errno = EPROTO;
        return (-1);
    @}
    if (retval) @{
        errno = EIO;
        return (-1);
    @}
    *addr = unitdata_ind.SRC_addr;
    return (databuf.len);
@}
@end smallexample

@manpage{getmsg(2)} is called to retrieve the data indication primitive, where that primitive
contains both a control and data part.  The control part consists of a @code{unitdata_ind} structure
that identifies the primitive type and the source address of the data sender.  The data part
contains the data itself.

In @var{ctlbuf}, @var{buf} must point to a buffer where the control information will be stored, and
@var{maxlen} must be set to indicate the maximum size of that buffer.  Similar initialization is
done for @var{databuf}.

The integer pointed at by @var{flagsp} in the @manpage{getmsg(2)} call is set to zero, indicating
that the next message should be retrieved from the @dfn{Stream head}, regardless of its priority.
Data will arrive in normal priority messages.  If no message currently exists at the @dfn{Stream
head}, getmsg will block until a message arrives.

The user's control and data buffers should be large enough to hold any incoming data.  If both
buffers are large enough, @manpage{getmsg(2)} will process the data indication and return @samp{0},
indicating that a full message was retrieved successfully.  However, if either buffer is not large
enough, @manpage{getmsg(2)} will only retrieve the part of the message that fits into each user
buffer.  The remainder of the message is saved for subsequent retrieval (if in message non-discard
mode), and a positive, non-zero value is returned to the user.  A return value of @samp{MORECTL}
indicates that more control information is waiting for retrieval.  A return value of @samp{MOREDATA}
indicates that more data are waiting for retrieval.  A return value of @samp{(MORECTL | MOREDATA)}
indicates that data from both parts of the message remain.  In the example, if the user buffers are
not large enough (that is, @manpage{getmsg(2)} returns a positive, non-zero value), the function
will set @errno{EIO} to @manpage{errno(3)} and fail.

The type of the primitive returned by @manpage{getmsg(2)} is checked to make sure it is a data
indication (@constant{UNITDATA_IND} in the example).  The source address is then set and the number of
bytes of data is returned.

The example presented is a simplified service interface.  The state transition rules for such an
interface were not presented for the sake of brevity.  The intent was to show typical uses of the
@manpage{putmsg(2)} and @manpage{getmsg(2)} system calls.  See @manpage{putmsg(2)} and
@manpage{getmsg(2)} for further details.  For simplicity, this example did not also consider
expedited data.

@subsubsection Module Service Interface Example

The following example is part of a module which illustrates the concept of a service interface.  The
module implements a simple service interface and mirrors the service interface library example given
earlier.  The following rules pertain to service interfaces:

@itemize @bullet
@item Modules and drivers that support a service interface must act upon all @dfn{PROTO} messages
and not pass them through.
@item Modules may be inserted between a service user and a service provider to manipulate the data
part as it passes between them.  However, these modules may not alter the contents of the control
part (@dfn{PROTO} block, first message block) nor alter the boundaries of the control or data parts.
That is, the message blocks comprising the data part may be changed, but the message may not be
split into separate messages nor combined with other messages.
@end itemize

In addition, modules and drivers must observe the rule that high priority messages are not subject
to flow control and forward them accordingly.

@subsubheading Declarations

The service interface primitives are defined in the declarations:

@smallexample
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>
#include <sys/errno.h>

/* Primitives initiated by the service user */

#define BIND_req 1              /* bind request */
#define UNITDATA_REQ 2          /* unit data request */

/* Primitives initiated by the service provider */

#define OK_ACK 3                /* bind acknowledgement */
#define ERROR_ACK 4             /* error acknowledgement */
#define UNITDATA_IND 5          /* unit data indication */
/*
 * The following structures define the format of the
 * stream message block of the above primitives.
 */
struct bind_req @{               /* bind request */
    long PRIM_type;             /* always BIND_REQ */
    long BIND_addr;             /* addr to bind */
@};
struct unitdata_req @{           /* unit data request */
    long PRIM_type;             /* always UNITDATA_REQ */
    long DEST_addr;             /* dest addr */
@};
struct ok_ack @{                 /* ok acknowledgement */
    long PRIM_type;             /* always OK_ACK */
@};
struct error_ack @{              /* error acknowledgement */
    long PRIM_type;             /* always ERROR_ACK */
    long UNIX_error;            /* UNIX system error code */
@};
struct unitdata_ind @{           /* unit data indication */
    long PRIM_type;             /* always UNITDATA_IND */
    long SRC_addr;              /* source addr */
@};
union primitives @{              /* union of all primitives */
    long type;
    struct bind_req bind_req;
    struct unitdata_req unitdata_req;
    struct ok_ack ok_ack;
    struct error_ack error_ack;
    struct unitdata_ind unitdata_ind;
@};
struct dgproto @{                /* structure per minor device */
    short state;                /* current provider state */
    long addr;                  /* net address */
@};

/* provider states */
#define IDLE 0
#define BOUND 1
@end smallexample

In general, the @msg{M_PROTO} or @msg{M_PCPROTO} block is described by a data structure containing
the service interface information.  In this example, union primitives is that structure.

Two commands are recognized by the module:

@table @var
@item BIND_REQ
Give this @dfn{Stream} a protocol address (i.e., give it a name on the network).  After a
@constant{BIND_REQ} is completed, data from other senders will find their way through the network to this
particular @dfn{Stream}.
@item UNITDATA_REQ
Send data to the specified address.
@end table

Three messages are generated:

@table @var
@item OK_ACK
A positive acknowledgement (ack) of @constant{BIND_REQ}.
@item ERROR_ACK
A negative acknowledgement (nak) of @constant{BIND_REQ}.
@item UNITDATA_IND
Data from the network have been received (this code is not shown).
@end table

The acknowledgement of a @constant{BIND_REQ} informs the user that the request was syntactically correct
(or incorrect if @errno{ERROR_ACK}).  The receipt of a @constant{BIND_REQ} is acknowledged with an
@msg{M_PCPROTO} to insure that the acknowledgement reaches the user before any other message.  For
example, a @constant{UNITDATA_IND} could come through before the bind has completed, and the user would
get confused.

The driver uses a per-minor device data structure, dgproto, which contains the following:

@table @var
@item state
current state of the service provider @constant{IDLE} or @constant{BOUND}
@item addr
network address that has been bound to this @dfn{Stream}
@end table

It is assumed (though not shown) that the module open procedure sets the write queue @var{q_ptr} to
point at the appropriate private data structure.

@subsubheading Service Interface Procedure

The write put procedure is:

@smallexample
static int
protowput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    union primitives *proto;
    struct dgproto *dgproto;
    int err;

    dgproto = (struct dgproto *) q->q_ptr;

    switch (mp->b_datap->db_type) @{

    default:
        /* do not understand it */
        mp->b_datap->db_type = M_ERROR;
        mp->b_rptr = mp->b_wptr = mp->b_datap->db_base;
        *mp->b_wptr++ = EPROTO;
        qreply(q, mp);
        break;

    case M_FLUSH:
        /* standard flush handling goes here ...  */
        break;

    case M_PROTO:
        /* Protocol message -> user request */
        proto = (union primitives *) mp->b_rptr;

        switch (proto->type) @{
        default:
            mp->b_datap->db_type = M_ERROR;
            mp->b_rptr = mp->wptr = mp->b_datap->db_base;
            *mp->b_wptr++ = EPROTO;
            qreply(q, mp);
            break;

        case BIND_REQ:
            if (dgproto->state != IDLE) @{
                err = EINVAL;
                goto error_ack;
            @}
            if (mp->b_wptr - mp->b_rptr != sizeof(struct bind req)) @{
                err = EINVAL;
                goto error_ack;
            @}
            if (err = chkaddr(proto->bind_req.BIND_addr))
                goto error_ack;

            dgproto->state = BOUND;
            dgproto->addr = proto->bind_req.BIND_addr;
            mp->b_datap->db_type = M_PCPROTO;
            proto->type = OK_ACK;
            mp->b_wptr = mp->b_rptr + sizeof(struct ok_ack);
            qreply(q, mp);
            break;

          error_ack:
            mp->b_datap->db_type = M_PCPROTO;
            proto->type = ERROR_ACK;
            proto->error_ack.UNIX_error = err;
            mp->b_wptr = mp->b_rptr + sizeof(struct error_ack);
            greply(q, mp);
            break;

        case UNITDATA_REQ:
            if (dgproto->state != BOUND)
                goto bad;
            if (mp->b_wptr - mp->b_rptr != sizeof(struct unitdata_req))
                goto bad;
            if (err = chkaddr(proto->unitdata_req.DEST_addr)) @{
                goto bad;
                putq(q, mp);
                /* start device or mux output ...  */
            @}
            break;

          bad:
            freemsg(mp);
            break;
        @}
    @}
@}
@end smallexample

The write put procedure switches on the message type.  The only types accepted are @msg{M_FLUSH} and
@msg{M_PROTO}.  For @msg{M_FLUSH} messages, the driver will perform the canonical flush handling
(not shown).  For @msg{M_PROTO} messages, the driver assumes the message block contains a union
primitive and switches on the type field.  Two types are understood: @constant{BIND_REQ} and
@constant{UNITDATA_REQ}.

For a @constant{BIND_REQ}, the current state is checked; it must be @constant{IDLE}.  Next, the message size
is checked.  If it is the correct size, the passed-in address is verified for legality by calling
@command{chkaddr}.  If everything checks, the incoming message is converted into an @constant{OK_ACK} and
sent upstream.  If there was any error, the incoming message is converted into an @errno{ERROR_ACK}
and sent upstream.

For @constant{UNITDATA_REQ}, the state is also checked; it must be @constant{BOUND}.  As above, the message
size and destination address are checked.  If there is any error, the message is simply discarded.
If all is well, the message is put on the queue, and the lower half of the driver is started.

If the write @command{put} procedure receives a message type that it does not understand, either a
bad @samp{b_datap->db_type} or bad @samp{proto->type}, the message is converted into an
@msg{M_ERROR} message and sent upstream.

The generation of @constant{UNITDATA_IND} messages (not shown in the example) would normally occur in the
device interrupt if this is a hardware driver or in the lower read @command{put} procedure if this
is a multiplexer.  The algorithm is simple: The data part of the message is prepended by an
@msg{M_PROTO} message block that contains a @code{unitdata_ind} structure and sent upstream.

@node Message Allocation
@section STREAMS Message Allocation and Freeing
@cindex message allocation and freeing

The @manpage{allocb(9)} utility routine is used to allocate a message and the space to hold the data
for the message.  @manpage{allocb(9)} returns a pointer to a message block containing a data buffer
of at least the size requested, providing there is enough memory available.  It returns null on
failure.  Note that @manpage{allocb(9)} always returns a message of type @msg{M_DATA}.  The type may
then be changed if required.  @var{b_rptr} and @var{b_wptr} are set to @var{db_base} (see
@manpage{msgb(9)} and @manpage{datab(9)}) which is the start of the memory location for the data.

@manpage{allocb(9)} may return a buffer larger than the size requested.  If @manpage{allocb(9)}
indicates buffers are not available (@manpage{allocb(9)} fails), the @command{put}/@command{service}
procedure may not call @manpage{sleep(9)} to wait for a buffer to become available.  Instead, the
@manpage{bufcall(9)} utility can be used to defer processing in the module or the driver until a
buffer becomes available.

If message space allocation is done by the @command{put} procedure and @manpage{allocb(9)} fails, the
message is usually discarded.  If the allocation fails in the @command{service} routine, the message
is returned to the queue.  @manpage{bufcall(9)} is called to enable to the @command{service} routine
when a message buffer becomes available, and the @command{service} routine returns.

The @manpage{freeb(9)} utility routine releases (de-allocates) the message block descriptor and the
corresponding data block, if the reference count (see datab structure) is equal to @samp{1}.  If the
reference counter exceeds @samp{1}, the data block is not released.

The @manpage{freemsg(9)} utility routine releases all message blocks in a message.  It uses
@manpage{freeb(9)} to free all message blocks and corresponding data blocks.

In the following example, @manpage{allocb(9)} is used by the @code{bappend} subroutine that appends a
character to a message block:

@smallexample
/*
 * Append a character to a message block.
 * If (*bpp) is null, it will allocate a new block
 * Returns 0 when the message block is full, 1 otherwise
 */

#define MODBLKSZ 128            /* size of message blocks */

static
bappend(bpp, ch)
        mblk_t **bpp;
        int ch;
@{
    mblk_t *bp;

    if ((bp = *bpp) != NULL) @{
        if (bp->b_wptr >= bp->b_datap->db_lim)
            return 0;
    @} else if ((*bpp = bp = allocb(MODBLKSZ, BPRI_MED)) == NULL)
        return 1;
    *bp->b_wptr++ = ch;
    return 1;
@}
@end smallexample

@code{bappend} receives a pointer to a message block pointer and a character as arguments.  If a
message block is supplied @samp{(*bpp != NULL)}, @code{bappend} checks if there is room for more data in
the block.  If not, it fails.  If there is no message block, a block of at least @constant{MODBLKSZ} is
allocated through @manpage{allocb(9)}.

If the @manpage{allocb(9)} fails, @code{bappend} returns success, silently discarding the character.
This may or may not be acceptable.  For @dfn{TTY}-type devices, it is generally accepted.  If the
original message block is not full or the @manpage{allocb(9)} is successful, @code{bappend} stores
the character in the block.

The next example, subroutine @code{modwput} processes all the message blocks in any downstream data
(type @msg{M_DATA}) messages.  @manpage{freemsg(9)} deallocates messages.

@smallexample
/* Write side put procedure */
static
modwput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    switch (mp->b_datap->db_TYPE) @{
    default:
        putnext(q, mp);         /* Do not do these, pass them along */
        break;

    case M_DATA:
    @{
        register mblk_t *bp;
        struct mblk_t *nmp = NULL, *nbp = NULL;

        for (bp = mp; bp != NULL; bp = bp->b_cont) @{
            while (bp->b_rptr < bp->b_wptr) @{
                if (*bp->b_rptr == '\n')
                    if (!bappend(&nbp, '\r'))
                        goto newblk;
                if (!bappend(&nbp, *bp->b_rptr))
                    goto newblk;
                bp->b_rpt++;
                continue;

              newblk:
                if (nmp == NULL)
                    nmp = nbp;
                else
                    linkb(nmp, nbp);    /* link message block to tail
                                           of nmp */
                nbp = NULL;
            @}
        @}
        if (nmp == NULL)
            nmp = nbp;
        else
            linkb(nmp, nbp);
        freemsg(mp);            /* de-allocate message */
        if (nmp)
            putnext(q, nmp);
    @}
    @}
@}
@end smallexample

Data messages are scanned and filtered.  @code{modwput1} copies the original message into a new
block(s), modifying as it copies.  @var{nbp} points to the current new message block.  @var{nmp}
points to the new message being formed as multiple @msg{M_DATA} message blocks.  The outer
@command{for()} loop goes through each message block of the original message.  The inner
@command{while()} loop goes through each byte.  @code{bappend} is used to add characters to the
current or new block.  If @code{bappend} fails, the current new block is full.  If @var{nmp} is
@samp{NULL}, @var{nmp} is pointed at the new block.  If @var{nmp} is not @samp{NULL}, the new block
is linked to the end of @var{nmp} by use of the @manpage{linkb(9)} utility.

At the end of the loops, the final new block is linked to @var{nmp}.  The original message (all
message blocks) is returned to the pool by @manpage{freemsg(9)}.  If a new message exists, it is
sent downstream.

@subsubsection Recovering From No Buffers

The @manpage{bufcall(9)} utility can be used to recover from an @manpage{allocb(9)} failure.  The
call syntax is as follows:

@smallexample
bufcall()(size, pri, func.arg);
    int size, pri, (*func) ();
    long arg;
@end smallexample

@manpage{bufcall(9)} calls @samp{(*func)(arg)} when a buffer of size bytes is available.  When
@var{func} is called, it has no user context and must return without sleeping.  Also, because of
interrupt processing, there is no guarantee that when @var{func} is called, a buffer will actually
be available (someone else may steal it).

On success, @manpage{bufcall(9)} returns a nonzero identifier that can be used as a parameter to
@manpage{unbufcall(9)} to cancel the request later.  On failure, @samp{0} is returned and the
requested function will never be called.

Care must be taken to avoid deadlock when holding resources while waiting for @manpage{bufcall(9)} to
call @samp{(*func)(arg)}.  @manpage{bufcall(9)} should be used sparingly.

Two examples are provided.  The first example is a device receive interrupt handler:

@smallexample
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>

dev_rintr(dev)
@{
    /* process incoming message ...  */

    /* allocate new buffer for device */
    dev_re_load(dev);
@}

/*
 * Reload device with a new receive buffer
 */
dev_re_load(dev)
@{
    mblk_t *bp;

    if ((bp = allocb(DEVBLKSZ, BPRI_MED)) == NULL) @{
        cmn_err(CE_WARN, "dev: allocb failure (size %d)\n", DEVBLKSZ);
        /* Allocation failed.  Use bufcall to * schedule a call to
           ourselves. */
        (void) bufcall(DEVBLKSZ, BPRI_MED, dev_re_load, dev);
        return;
    @}

    /* pass buffer to device ...  */
@}
@end smallexample

@code{dev_rintr} is called when the device has posted a receive interrupt.  The code retrieves the
data from the device (not shown).  @code{dev_rintr} must then give the device another buffer to fill
by a call to @code{dev_re_load}, which calls @manpage{allocb(9)}.  If @manpage{allocb(9)} fails,
@code{dev_re_load} uses @manpage{bufcall(9)} to call itself when @dfn{STREAMS} determines a buffer
is available.

Since @manpage{bufcall(9)} may fail, there is still a chance that the device may hang.  A better
strategy, in the event @manpage{bufcall(9)} fails, would be to discard the current input message and
resubmit that buffer to the device.  Losing input data is generally better than hanging.

The second example is a write @command{service} procedure, @code{mod_wsrv}, which needs to prepend
each output message with a header.  @code{mod_wsrv} illustrates a case for potential deadlock:

@smallexample
static int
mod_wsrv(q)
        queue_t *q;
@{
    int qenable();
    mblk_t *mp, *bp;

    while (mp = getq(q)) @{
        /* check for priority messages and canput ...  */

        /* Allocate a header to prepend to the message.  If the allocb
           fails, use bufcall to reschedule. */
        if ((bp = allocb(HDRSZ, BPRI_MED)) == NULL) @{
            if (!bufcall(HDRSZ, BPRI_MED, qenable, q)) @{
                timeout(qenable, q, HZ * 2);
            @}
            /* Put the message back and exit, we will be re-enabled
               later */
            putbq(q, mp);
            return;
        @}
        /* process message ...  */
    @}
@}
@end smallexample

However, if @manpage{allocb(9)} fails, @code{mod_wsrv} wants to recover without loss of data and
calls @manpage{bufcall(9)}.  In this case, the routine passed to @manpage{bufcall(9)} is
@manpage{qenable(9)}.  When a buffer is available, the @command{service} procedure will be
automatically re-enabled.  Before exiting, the current message is put back on the queue.  This
example deals with @manpage{bufcall(9)} failure by resorting to the @manpage{timeout(9)} operating
system utility routine.  @manpage{timeout(9)} will schedule the given function to be run with the
given argument in the given number of clock ticks (there are @constant{HZ} ticks per second).  In this
example, if @manpage{bufcall(9)} fails, the system will run @manpage{qenable(9)} after two seconds
have passed.@footnote{Under @value{PACKAGE_TITLE}, it is not a good strategy to call
@manpage{timeout(9)} when @manpage{bufcall(9)} fails.  This is because if @manpage{bufcall(9)} fails
to allocate resource for the buffer callback, @manpage{timeout(9)} is also likely to fail to
allocate necessary resources.  A as final resort, if @manpage{timeout(9)} fails, the
@command{service} procedure can simply re-enable itself with @manpage{qenable(9)} and try again when
it is rescheduled.}

@node Extended Buffers
@section STREAMS Extended Buffers
@cindex extended buffers

Some hardware using the @dfn{STREAMS} mechanism supports memory-mapped I/O that allows the sharing
of buffers between users, kernel, and the I/O card.

If the hardware supports memory-mapped I/O, data received from the network are placed in the
@dfn{DARAM (dual access RAM)} section of the I/O card.  Since @dfn{DARAM} is a shared memory between
the kernel and the I/O card, data transfer between the kernel and the I/O card is eliminated.  Once
in kernel space, the data buffer can be manipulated as if it were a kernel resident buffer.
Similarly, data being sent downstream are placed in @dfn{DARAM} and then forwarded to the network.

In a typical network arrangement, data are received from the network by the I/O card.  The disk
controller reads the block of data into the card's internal buffer.  It interrupts the host computer
to denote that data have arrived.  The @dfn{STREAMS} driver gives the controller the kernel address
where the data block is to go and the number of bytes to transfer.  After the disk controller has
read the data into its buffer and verified the checksum, it copies the data into main memory to the
address specified by the the @dfn{DMA} (@dfn{direct memory access}) memory address.  Once in the
kernel space, the data are packaged into message blocks and processed on the usual manner.

When data are transmitted from user process to the network, data are copied from the user space to
the kernel space, and packaged as a message block and sent to the downstream driver.  The driver
interrupts the I/O card signalling that data are ready to be transmitted to the network.  The
controller copies the data from the kernel space to the internal buffer on the I/O card, and from
there data are placed on the network.

The @dfn{STREAMS} buffer allocation mechanism enables the allocation of message and data blocks to
point directly to a client-supplied (non-@dfn{STREAMS}) buffer.  Message and data blocks allocated
this way are indistinguishable (for the most part) from the normal data blocks.  The client-supplied
buffers are processed as if they were normal @dfn{STREAMS} data buffers.

Drivers may not only attach non-@dfn{STREAMS} data buffers but also free them.  This is accomplished
as follows:

@itemize @bullet
@item Allocation If the drivers are to use @dfn{DARAM} without wasting @dfn{STREAMS} resources and
without being dependent on upstream modules, a data and message block can be allocated without an
attached data buffer.  The routine to use is called @manpage{esballoc(9)}.  This returns a message
block and data block without an associated @dfn{STREAMS} buffer.  Rather, the buffer used is the one
supplied by the caller.
@item Freeing Each driver using non-@dfn{STREAMS} resources in a @dfn{STREAMS} environment must
fully manage those resources, including freeing them.  However, to make this as transparent as
possible, a driver-dependent routine is executed in the event @manpage{freeb(9)} is called to free a
message and data block with an attached non-@dfn{STREAMS} buffer.  @manpage{freeb(9)} detects if a
buffer is a client supplied, non-@dfn{STREAMS} buffer.  If it is, @manpage{freeb(9)} finds the
@code{free_rtn} structure associated with that buffer.  After calling the driver-dependent routine
(defined in @code{free_rtn}) to free the buffer, the @manpage{freeb(9)} routine frees the message and
data block.
@end itemize

The format of the @code{free_rtn} structure is as follows:

@smallexample
struct free_rtn @{
    void (*free_func) ();       /* driver dependent free routine */
    char *free_arg;             /* argument for free_rtn */
@};
typedef struct free_rtn frtn_t;
@end smallexample

The structure has two fields: a pointer to a function and a location for any argument passed to the
function.  Instead of defining a specific number of arguments, @var{free_arg} is defined as a
@samp{char *}.  This way, drivers can pass pointers to structures in the event more than one
argument is needed.

The @dfn{STREAMS} utility routine, @manpage{esballoc(9)}, provides a common interface for allocating
and initializing data blocks.  It makes the allocation as transparent to the driver as possible and
provides a way to modify the fields of the data block, since modification should only be performed
by @dfn{STREAMS}.  The driver calls this routine when it wants to attach its own data buffer to a
newly allocated message and data block.  If the routine successfully completes the allocation and
assigns the buffer, it returns a pointer to the message block.  The driver is responsible for
supplying the arguments to @manpage{esballoc(9)}, namely, a pointer to its data buffer, the size of
the buffer, the priority of the data block, and a pointer to the @code{free_rtn} structure.  All
arguments should be non-@samp{NULL}.  See @ref{STREAMS Utilities}, for a detailed description of
@manpage{esballoc(9)}.

@node Polling
@chapter Polling and Signalling
@cindex polling and signalling
@menu
* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal
@end menu

@node Input and Output Polling
@section STREAMS Input and Output Polling
@cindex input and output polling

This chapter describes the synchronous polling mechanism and asynchronous event notification within
@dfn{STREAMS}.  Also discussed is how a @dfn{Stream} can be a controlling terminal.

User processes can efficiently monitor and control multiple @dfn{Streams} with two system calls:
@manpage{poll(2)} and the @ioctlref{I_SETSIG} @manpage{ioctl(2)} command.  These calls allow a user
process to detect events that occur at the @dfn{Stream head} on one or more @dfn{Streams}, including
receipt of data or messages on the read queue and cessation of flow control.

To monitor @dfn{Streams} with @manpage{poll(2)}, a user process issues that system call and
specifies the @dfn{Streams} to be monitored, the events to look for, and the amount of time to wait
for an event.  The @manpage{poll(2)} system call will block the process until the time expires or
until an event occurs.  If an event occurs, it will return the type of event and the @dfn{Stream} on
which the event occurred.

Instead of waiting for an event to occur, a user process may want to monitor one or more
@dfn{Streams} while processing other data.  It can do so by issuing the @streamio{I_SETSIG}
@manpage{ioctl(2)} command, specifying one or more @dfn{Streams} and events (as with
@manpage{poll(2)}).  This @command{ioctl} does not block the process and force the user process to
wait for the event but returns immediately and issues a signal when an event occurs.  The process
must request @manpage{signal(2)} to catch the resultant @signal{SIGPOLL} signal.

If any selected event occurs on any of the selected @dfn{Streams}, @dfn{STREAMS} will cause the
@signal{SIGPOLL} catching function to be executed in all associated requesting processes.  However, the
process(es) will not know which event occurred, nor on what @dfn{Stream} the event occurred.  A
process that issues the @streamio{I_SETSIG} can get more detailed information by issuing a poll after it
detects the event.

@subsection Syncrhonous Input and Output

The @manpage{poll(2)} system call provides a mechanism to identify those @dfn{Streams} over which a
user can send or receive data.  For each @dfn{Stream} of interest users can specify one or more
events about which they should be notified.  The types of events that can be polled are
@constant{POLLIN}, @constant{POLLRDNORM}, @constant{POLLRDBAND}, @constant{POLLPRI},
@constant{POLLOUT}, @constant{POLLWRNORM},
@constant{POLLWRBAND}, @constant{POLLMSG}, and @constant{POLLNORM}:

@vtable @constant

@item POLLIN
A message other than an @msg{M_PCPROTO} is at the front of the @dfn{Stream head} read queue.  This
event is maintained for compatibility with the previous releases of the @cite{UNIX System V}.

@item POLLRDNORM
A normal (non-priority) message is at the front of the @dfn{Stream head} read queue.

@item POLLRDBAND
A priority message (@samp{band > 0}) is at the front of the @dfn{Stream head} read queue.

@item POLLPRI
A high priority message (@msg{M_PCPROTO}) is at the front of the @dfn{Stream head} read queue.

@item POLLOUT
The normal priority band of the queue is writable (not flow controlled).

@item POLLWRNORM
The same as @constant{POLLOUT}.

@item POLLWRBAND
A priority band greater than @samp{0} of a queue downstream exists and is writable.

@item POLLMSG
An @msg{M_SIG} or @msg{M_PCSIG} message containing the @signal{SIGPOLL} signal has reached the front of
the @dfn{Stream head} read queue.

@item POLLNORM
The same as @constant{POLLRDNORM}.

@end vtable

Some of the events may not be applicable to all file types.  For example, it is not expected that
the @constant{POLLPRI} event will be generated when polling a regular file.  @constant{POLLIN},
@constant{POLLRDNORM}, @constant{POLLRDBAND}, and @constant{POLLPRI} are set even if the message is of zero length.

The @command{poll} system call will examine each file descriptor for the requested events and, on return, will
indicate which events have occurred for each file descriptor.  If no event has occurred on any
polled file descriptor, @command{poll} blocks until a requested event or timeout occurs.
@manpage{poll(2)} takes the following arguments:

@itemize @bullet
@item an array of file descriptors and events to be polled
@item the number of file descriptors to be polled
@item the number of milliseconds @command{poll} should wait for an event if no events are pending (@samp{-1}
specifies wait forever)
@end itemize

The following example shows the use of @command{poll}.  Two separate minor devices of the
communications driver are opened, thereby establishing two separate @dfn{Streams} to the driver.
The @var{pollfd} entry is initialized for each device.  Each @dfn{Stream} is polled for incoming
data.  If data arrive on either @dfn{Stream}, data are read and then written back to the other
@dfn{Stream}.

@smallexample
#include <stropts.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>

#define NPOLL 2			/* number of file descriptors to poll */

main()
@{
    struct pollfd pollfds[NPOLL];
    char buf[1024];
    int count, i;

    if ((pollfds[0].fd = open("/dev/comm/01", O_RDWR | O_NDELAY)) < 0) @{
	perror("open failed for /dev/comm/01");
	exit(1);
    @}
    if ((pollfds[1].fd = open("/dev/comm/02", O_RDWR | O_NDELAY)) < 0) @{
	perror("open failed for /dev/comm/02");
	exit(2);
    @}
@end smallexample

The variable pollfds is declared as an array of the pollfd structure that is defined in @header{poll.h}
and has the following format:

@smallexample
struct pollfd @{
    int fd;             /* file descriptor */
    short events;       /* requested events */
    short revents;      /* returned events */
@};
@end smallexample

For each entry in the array, @var{fd} specifies the file descriptor to be polled and events is a
bit mask that contains the bitwise inclusive OR of events to be polled on that file descriptor.  On
return, the @var{revents} bit mask will indicate which of the requested events has occurred.

The example continues to process incoming data as follows:

@smallexample
    pollfds[0].events = POLLIN; /* set events to poll pollfds[1].events 
                                   = POLLIN; for incoming data */
    while (1)
        /* poll and use -1 timeout (infinite) */
        if (poll(pollfds, NPOLL, -1) < 0) @{
            perror("poll failed");
            exit(3);
        @}
    for (i = 0; i < NPOLL; i++) @{
        switch (pollfds[i].revents) @{

        default:                /* default error case */
            perror("error event");
            exit(4);

        case 0:         /* no events */
            break;

        case POLLIN:
            /* echo incoming data on "other" Stream */
            while ((count = read(pollfds[i].fd, buf, 1024)) > 0)
                /* the write loses data if flow control prevents the
                   transmit at this time. */
                if (write(pollfds[(i + 1) % 2].fd, buf, count) != count)
                    fprintf(stderr, "writer lost data \n");
            break;
        @}
    @}
@}
@end smallexample

The user specifies the polled events by setting the events field of the @var{pollfd} structure to
@constant{POLLIN}.  This requested event directs @command{poll} to notify the user of any incoming data on each
@dfn{Stream}.  The bulk of the example is an infinite loop, where each iteration will poll both
@dfn{Streams} for incoming data.

The second argument to the @command{poll} system call specifies the number of entries in the
@var{pollfds} array (@samp{2} in this example).  The third argument is a timeout value indicating
the number of milliseconds @command{poll} should wait for an event if none has occurred.  On a
system where millisecond accuracy is not available, timeout is rounded up to the nearest value
available on that system.  If the value of timeout is 0, @command{poll} returns immediately.  Here,
the value of timeout is @samp{-1}, specifying that @command{poll} should block until a requested
event occurs or until the call is interrupted.

If the @command{poll} call succeeds, the program looks at each entry in the @var{pollfds} array.  If
@var{revents} is set to @samp{0}, no event has occurred on that file descriptor.  If @var{revents}
is set to @constant{POLLIN}, incoming data are available.  In this case, all available data are read from
the polled minor device and written to the other minor device.

If @var{revents} is set to a value other than @samp{0} or @constant{POLLIN}, an error event must have
occurred on that @dfn{Stream}, because @constant{POLLIN} was the only requested event.  The following are
@command{poll} error events:

@vtable @constant
@item POLLERR
A fatal error has occurred in some module or driver on the @dfn{Stream} associated with the
specified file descriptor.  Further system calls will fail.
@item POLLHUP
A hangup condition exists on the @dfn{Stream} associated with the specified file descriptor.  This
event and @constant{POLLOUT} are mutually exclusive; a @dfn{Stream} cannot be writable if a hangup has
occurred.
@item POLLNVAL
The specified file descriptor is not associated with an open @dfn{Stream}.
@end vtable

These events may not be polled for by the user, but will be reported in @var{revents} whenever they
occur.  As such, they are only valid in the @var{revents} bit mask.

The example attempts to process incoming data as quickly as possible.  However, when writing data to
a @dfn{Stream}, the write call may block if the @dfn{Stream} is exerting flow control.  To prevent
the process from blocking, the minor devices of the communications driver were opened with the
@constant{O_NDELAY} (or @constant{O_NONBLOCK}, see note) flag set.  The write will not be able to send all the
data if flow control is exerted and @constant{O_NDELAY} (@constant{O_NONBLOCK}) is set.  This can occur if the
communications driver is unable to keep up with the user's rate of data transmission.  If the
@dfn{Stream} becomes full, the number of bytes the write sends will be less than the requested
count.  For simplicity, the example ignores the data if the @dfn{Stream} becomes full, and a warning
is printed to @dfn{stderr}.

For conformance with the @dfn{IEEE} operating system interface standard, @dfn{POSIX}, it is
recommended that new applications use the @constant{O_NONBLOCK} flag, whose behaviour is the same as that
of @constant{O_NDELAY} unless otherwise noted.

This program continues until an error occurs on a @dfn{Stream}, or until the process is interrupted.

@subsection Asynchronous Input and Output

The @command{poll} system call described before enables a user to monitor multiple @dfn{Streams} in
a synchronous fashion.  The @manpage{poll(2)} call normally blocks until an event occurs on any of
the polled file descriptors.  In some applications, however, it is desirable to process incoming
data asynchronously.  For example, an application may wish to do some local processing and be
interrupted when a pending event occurs.  Some time-critical applications cannot afford to block,
but must have immediate indication of success or failure.

The @ioctlref{I_SETSIG} @manpage{ioctl(2)} call (see @manpage{streamio(7)}) is used to request that a
@signal{SIGPOLL} signal be sent to a user process when a specific event occurs.  Listed below are
events for the @command{ioctl} @streamio{I_SETSIG}.  These are similar to those described for
@manpage{poll(2)}.

@vtable @constant

@item S_INPUT
@msg{M_PCPROTO} is at the front of the @dfn{Stream head} read queue.  This event is maintained for
compatibility with the previous releases of the @cite{UNIX System V}.

@item S_RDNORM
A normal (non-priority) message is at the front of the @dfn{Stream head} read queue.

@item S_RDBAND
A priority message (@samp{band > 0}) is at the front of the @dfn{Stream head} read queue.

@item S_HIPRI
A high priority message (@msg{M_PCPROTO}) is present at the front of the @dfn{Stream head} read
queue.

@item S_OUTPUT
A write queue for normal data (priority band = 0) is no longer full (not flow controlled).  This
notifies a user that there is room on the queue for sending or writing normal data downstream.

@item S_WRNORM
The same as @constant{S_OUTPUT}.

@item S_WRBAND
A priority band greater than @samp{0} of a queue downstream exists and is writable.  This notifies a
user that there is room on the queue for sending or writing priority data downstream.

@item S_MSG
An @msg{M_SIG} or @msg{M_PCSIG} message containing the @signal{SIGPOLL} flag has reached the front of
@dfn{Stream head} read queue.

@item S_ERROR
An @msg{M_ERROR} message reaches the @dfn{Stream head}.

@item S_HANGUP
An @msg{M_HANGUP} message reaches the @dfn{Stream head}.

@item S_BANDURG
When used in conjunction with @constant{S_RDBAND}, @signal{SIGURG} is generated instead @signal{SIGPOLL} when a
priority message reaches the front of the @dfn{Stream head} read queue.

@end vtable

@constant{S_INPUT}, @constant{S_RDNORM}, @constant{S_RDBAND}, and @constant{S_HIPRI} are set even if the message is of
zero length.  A user process may choose to handle only high priority messages by setting the
@var{arg} to @constant{S_HIPRI}.

@subsection Signals

@dfn{STREAMS} allows modules and drivers to cause a signal to be sent to user process(es) through an
@msg{M_SIG} or @msg{M_PCSIG} message.  The first byte of the message specifies the signal for the
@dfn{Stream head} to generate.  If the signal is not @signal{SIGPOLL} (see @manpage{signal(2)}), the
signal is sent to the process group associated with the @dfn{Stream}.  If the signal is
@signal{SIGPOLL}, the signal is only sent to processes that have registered for the signal by using the
@ioctlref{I_SETSIG} @manpage{ioctl(2)}.

An @msg{M_SIG} message can be used by modules or drivers that wish to insert an explicit in-band
signal into a message @dfn{Stream}.  For example, this message can be sent to the user process
immediately before a particular service interface message to gain the immediate attention of the
user process.  When the @msg{M_SIG} message reaches the head of the @dfn{Stream} head read queue, a
signal is generated and the @msg{M_SIG} message is removed.  This leaves the service interface
message as the next message to be processed by the user.  Use of the @msg{M_SIG} message is
typically defined as part of the service interface of the driver or module.

@subsubsection Extended Signals

To enable a process to obtain the band and event associated with @signal{SIGPOLL} more readily,
@dfn{STREAMS} supports extended signals.  For the given events, a special code is defined in
@header{siginfo.h} that describes the reason @signal{SIGPOLL} was generated.  The following table
describes the data available in the @code{siginfo_t} structure passed to the signal handler.

@multitable @columnfractions .20 .20 .20 .20 .20
@item event @tab @code{si_signo} @tab @code{si_code} @tab @code{si_band} @tab @code{si_errno}
@item @constant{S_INPUT} @tab @signal{SIGPOLL} @tab @constant{POLL_IN} @tab band readable @tab unused
@item @constant{S_OUTPUT} @tab @signal{SIGPOLL} @tab @constant{POLL_OUT} @tab band writable @tab unused
@item @constant{S_MSG} @tab @signal{SIGPOLL} @tab @constant{POLL_MSG} @tab band signalled @tab unused
@item @constant{S_ERROR} @tab @signal{SIGPOLL} @tab @constant{POLL_ERR} @tab unused @tab @dfn{Stream} error
@item @constant{S_HANGUP} @tab @signal{SIGPOLL} @tab @constant{POLL_HUP} @tab unused @tab unused
@item @constant{S_HIPRI} @tab @signal{SIGPOLL} @tab @constant{POLL_PRI} @tab unused @tab unused
@end multitable

@node Controlling Terminal
@section STREAMS Stream as Controlling Terminal
@cindex stream as controlling terminal

@subsection Job Control

An overview of @dfn{Job Control} is provided here for completeness and because it interacts with the
@dfn{STREAMS}-based terminal subsystem.  More information on @dfn{Job Control} may be obtained from
the following manual pages: @manpage{exit(2)}, @manpage{getpgid(2)}, @manpage{getpgrp(2)},
@manpage{getsid(2)}, @manpage{kill(2)}, @manpage{setpgid(2)}, @manpage{setpgrp(2)},
@manpage{setsid(2)}, @manpage{sigaction(2)}, @manpage{signal(2)}, @manpage{sigsend(2)},
@manpage{termios(2)}, @manpage{waitid(2)}, @manpage{waitpid(3)}, and @manpage{signal(5)}, and
@manpage{termio(7)}.

@dfn{Job Control} is a feature supported by the @cite{BSD UNIX} operating system.  It is also an
optional part of the @cite{IEEE P1003.1 POSIX} standard.  @dfn{Job Control} breaks a login session
into smaller units called jobs.  Each job consists of one or more related and cooperating processes.
One job, the foreground job, is given complete access to the controlling terminal.  The other jobs,
background jobs, are denied read access to the controlling terminal and given conditional write and
ioctl access to it.  The user may stop an executing job and resume the stopped job either in the
foreground or in the background.

Under @dfn{Job Control}, background jobs do not receive events generated by the terminal and are not
informed with a hangup indication when the controlling process exits.  Background jobs that linger
after the login session has been dissolved are prevented from further access to the controlling
terminal, and do not interfere with the creation of new login sessions.

The following defines terms associated with @dfn{Job Control}:

@itemize @bullet
@item Background Process group A process group that is a member of a session that established a
connection with a controlling terminal and is not the foreground process group.
@item Controlling Process A session leader that established a connection to a controlling terminal.
@item Controlling Terminal A terminal that is associated with a session.  Each session may have at
most one controlling terminal associated with it and a controlling terminal may be associated with
at most one session.  Certain input sequences from the controlling terminal cause signals to be sent
to the process groups in the session associated with the controlling terminal.
@item Foreground Process Group Each session that establishes a connection with a controlling
terminal distinguishes one process group of the session as a foreground process group.  The
foreground process group has certain privileges that are denied to background process groups when
accessing its controlling terminal.
@item Orphaned Process Group A process group in which the parent of every member in the group is
either a member of the group, or is not a member of the process group's session.
@item Process Group Each process in the system is a member of a process group that is identified by
a process group ID.  Any process that is not a process group leader may create a new process group
and become its leader.  Any process that is not a process group leader may join an existing process
group that shares the same session as the process.  A newly created process joins the process group
of its creator.
@item Process Group Leader A process whose process ID is the same as its process group ID.
@item Process Group Lifetime A time period that begins when a process group is created by its
process group leader and ends when the last process that is a member in the group leaves the group.
@item Process ID A positive integer that uniquely identifies each process in the system.  A process
ID may not be reused by the system until the process lifetime, process group lifetime, and session
lifetime ends for any process ID, process group ID, and session ID sharing that value.
@item Process Lifetime A time period that begins when the process is forked and ends after the
process exits, when its termination has been acknowledged by its parent process.
@item Session Each process group is a member of a session that is identified by a session ID.
@item Session ID A positive integer that uniquely identifies each session in the system.  It is the
same as the process ID of its session leader.
@item Session Leader A process whose session ID is the same as its process and process group ID.
@item Session Lifetime A time period that begins when the session is created by its session leader
and ends when the lifetime of the last process group that is a member of the session ends.
@end itemize

The following signals manage @dfn{Job Control}: (see also @manpage{signal(5)})

@vtable @signal
@item SIGCONT
Sent to a stopped process to continue it.
@item SIGSTOP
Sent to a process to stop it.  This signal cannot be caught or ignored.
@item SIGTSTP
Sent to a process to stop it.  It is typically used when a user requests to stop the foreground
process.
@item SIGTTIN
Sent to a background process to stop it when it attempts to read from the controlling terminal.
@item SIGTTOU
Sent to a background process to stop it when one attempts to write to or modify the controlling
terminal.
@end vtable

A session may be allocated a controlling terminal.  For every allocated controlling terminal,
@dfn{Job Control} elevates one process group in the controlling process's session to the status of
foreground process group.  The remaining process groups in the controlling process's session are
background process groups.  A controlling terminal gives a user the ability to control execution of
jobs within the session.  Controlling terminals play a central role in @dfn{Job Control}.  A user
may cause the foreground job to stop by typing a predefined key on the controlling terminal.  A user
may inhibit access to the controlling terminal by background jobs.  Background jobs that attempt to
access a terminal that has been so restricted will be sent a signal that typically will cause the
job to stop.  (@pxref{Accessing the Controlling Terminal}, later in this chapter.)

@dfn{Job Control} requires support from a line discipline module on the controlling terminal's
@dfn{Stream}.  The @termio{TCSETA}, @termio{TCSETAW}, and @termio{TCSETAF} commands of @manpage{termio(7)}
allow a process to set the following line discipline values relevant to @dfn{Job Control}:

@table @asis

@item @constant{SUSP} character
A user defined character that, when typed, causes the line discipline module to request that the
@dfn{Stream} head sends a @signal{SIGTSTP} signal to the foreground process with an @msg{M_PCSIG}
message, which by default stops the members of that group.  If the value of @constant{SUSP} is zero, the
@signal{SIGTSTP} signal is not sent, and the @constant{SUSP} character is disabled.

@item @constant{TOSTOP} flag
If @constant{TOSTOP} is set, background processes are inhibited from writing to their controlling
terminal.

@end table

A line discipline module must record the @constant{SUSP} suspend character and notify the @dfn{Stream
head} when the user has typed it, and record the state of the @constant{TOSTOP} bit and notify the
@dfn{Stream head} when the user has changed it.

@subsection Allocation and Deallocation

A @dfn{Stream} is allocated as a controlling terminal for a session if:

@itemize @bullet
@item The @dfn{Stream} is acting as a terminal,
@item The @dfn{Stream} is not already allocated as a controlling terminal, and
@item The @dfn{Stream} is opened by a session leader that does not have a controlling terminal.
@end itemize

Drivers and modules can inform the @dfn{Stream} head to act as a terminal @dfn{Stream} by sending an
@msg{M_SETOPTS} message with the @stropt{SO_ISTTY} flag set upstream.  This state may be changed by
sending an @msg{M_SETOPTS} message with the @stropt{SO_ISNTTY} flag set upstream.

Controlling terminals are allocated with the @manpage{open(2)} system call.  A @dfn{Stream} head
must be informed that it is acting as a terminal by an @msg{M_SETOPTS} message sent upstream before
or while the @dfn{Stream} is being opened by a potential controlling process.  If the @dfn{Stream}
head is opened before receiving this message, the @dfn{Stream} is not allocated as a controlling
terminal.

@subsection Hung-up Streams

When a @dfn{Stream} head receives an @msg{M_HANGUP} message, it is marked as hung-up.  @dfn{Streams}
that are marked as hung-up are allowed to be reopened by their session leader if they are allocated
as a controlling terminal, and by any process if they are not allocated as a controlling terminal.
This way, the hangup error can be cleared without forcing all file descriptors to be closed first.

If the reopen is successful, the hung-up condition is cleared.

@subsection Hangup Signals

When the @signal{SIGHUP} signal is generated via an @msg{M_HANGUP} message (instead of an @msg{M_SIG}
or @msg{M_PCSIG} message), the signal is sent to the controlling process instead of the foreground
process group, since the allocation and deallocation of controlling terminals to a session is the
responsibility of that process group.

@anchor{Accessing the Controlling Terminal}
@subsection Accessing the Controlling Terminal

If a process attempts to access its controlling terminal after it has been deallocated, access will
be denied.  If the process is not holding or ignoring @signal{SIGHUP}, it is sent a @signal{SIGHUP} signal.
Otherwise, the access will fail with an @errno{EIO} error.

Members of background process groups have limited access to their controlling terminals:

@itemize @bullet

@item If the background process is ignoring or holding the @signal{SIGTTIN} signal or is a member of an
orphaned process group, an attempt to read from the controlling terminal will fail with an @errno{EIO}
error.  Otherwise, the process is sent a @signal{SIGTTIN} signal, which by default stops the process.

@item If the process is attempting to write to the terminal and if the terminal's @constant{TOSTOP} flag
is clear, the process is allowed access.  The @constant{TOSTOP} flag is set upon reception of an
@msg{M_SETOPTS} message with the @stropt{SO_TOSTOP} flag set in the @var{so_flags} field.  It is
cleared upon reception of an @msg{M_SETOPTS} message with the @stropt{SO_TONSTOP} flag set.

@item If the terminal's @constant{TOSTOP} flag is set and a background process is attempting to write to
the terminal, the write will succeed if the process is ignoring or holding @signal{SIGTTOU}.
Otherwise, the process will stop except when it is a member of an orphaned process group, in which
case it is denied access to the terminal and it is returned an @errno{EIO} error.

@item If a background process is attempting to perform a destructive @command{ioctl} (an
@command{ioctl} that modifies terminal parameters), the @command{ioctl} call will succeed if the
process is ignoring or holding @signal{SIGTTOU}.  Otherwise, the process will stop except when the
process is a member of the orphaned process group.  In that case the access to the terminal is
denied and an @errno{EIO} error is returned.

@end itemize

@node Modules and Drivers
@chapter Overview of STREAMS Modules and Drivers
@cindex modules and drivers
@menu
* Environment::			STREAMS Module and Driver Environment
* Input-Output Control::	STREAMS Input and Output Controls
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines
@end menu

@node Environment
@section STREAMS Module and Driver Environment
@cindex module and driver environment
@menu
* Module and Driver Declarations::
@end menu

Modules and drivers are processing elements in @dfn{STREAMS}.  A @dfn{STREAMS} device driver is
similar to a conventional @b{Linux} character device driver.  A @dfn{STREAMS} device driver is
opened like a conventional driver and is responsible for the system interface to the device.

@dfn{STREAMS} modules and drivers are structurally similar.  The kernel-level call interfaces to
driver routines are identical to those used for modules.  Drivers and modules must declare
@mantype{streamtab(9)}, @code{qinit}, and @code{module_info} structures.  Within the @dfn{STREAMS}
mechanism drivers are required elements, but modules are optional.  However, in the
@dfn{STREAMS}-based pipe mechanism and the pseudo-terminal subsystem only the @dfn{Stream} head is
required.

There are three significant differences between modules and drivers:

@enumerate
@item A device driver must be able to handle interrupts from a device, so the driver will typically include
an interrupt handler routine.
@item A device driver may have multiple @dfn{Streams} connected to it.
@item The initialization/deinitialization process that happens via
@manpage{open(2)}/@manpage{close(2)} with a driver and via the @command{ioctls}
@streamio{I_PUSH}/@streamio{I_POP} with a module.@footnote{@streamio{I_PUSH}/@streamio{I_POP} results in
calls to the module @command{open}/@command{close} procedures.}
@end enumerate

User context is not generally available to @dfn{STREAMS} module procedures and drivers.  The
exception is during execution of the @command{open} and @command{close} routines.  Driver and module
@command{open} and @command{close} routines have user context and may access
@c the @code{u_area} structure (defined in @header{user.h}, (@pxref{Accessible Symbols and Functions}), later in this chapter)
the @code{current} @code{task_struct} structure, although this is discouraged.  These routines are
allowed to sleep, but must always return to the caller.
@ignore
That is, if they sleep, it must be at priority numerically <= @constant{PZERO}, or with
@constant{PCATCH} set in the sleep priority.  Priorities are higher as they decrease in numerical
value.  The process will never return from the sleep call and the system call will be aborted if:

@itemize @bullet
@item A process is sleeping at priority > @dfn{PZERO},
@item @dfn{PCATCH} is not set, and
@item A process is sent signal via @manpage{kill(2)}.
@end itemize
@end ignore
That is, if they sleep, the sleep must be interruptible (i.e., @constant{TASK_INTERRUPTIBLE} instead
of @constant{TASK_UNINTERRUPTIBLE}).  If queue synchronization or synchronization variables are used
to sleep, @manref{qwait_sig(9)} should be used instead of @manref{qwait(9)} and
@manref{SV_WAIT_SIG(9)} should be used instead of @manref{SV_WAIT(9)}.

@dfn{STREAMS} driver and module @command{put} procedures and @command{service} procedures have no
user context.  They cannot access
@c the @code{u_area} structure
the @code{current} @code{task_struct} structure of a process and must not sleep.

An exception to this general rule is that the topmost module under a @dfn{Stream head} has its
@command{put} procedure executed with user context in the @dfn{Uni-Processor (UP)} environment, or
in the @dfn{Symmetric Multi-Processor (SMP)} environment where the module is MP-safe.  Any module or
driver below the topmost module for which the topmost module invokes its @command{put} procedure
using @manref{putnext(9)} will also have its @command{put} procedure executed in user context.
However, neither a module or driver's @command{put} or @command{service} procedures are allowed to
sleep.  If a @command{put} or @command{service} sleeps, the @dfn{STREAMS} scheduler will halt for
the duration of the sleep.

@ignore
The module and driver @command{open}/@command{close} interface was modified for @cite{UNIX System V
Release 4.0}.  However, @cite{UNIX} systems defaults to @cite{UNIX System V Release 3.0} interface
unless @var{prefixflag} is defined.  This is discussed later in this chapter (@pxref{Driver-Kernel
Interface}).
@end ignore

Examples and descriptions in this chapter reflect @cite{Release 4.0} interface.
@cite{@value{PACKAGE_TITLE}} uses the @cite{UNIX System V Release 4.0} interface and does not
support the @cite{UNIX System V Release 3.0} interface, regardless of the existence or absence of
@var{prefixflag}.

@node Module and Driver Declarations
@subsection Module and Driver Declarations

A module and driver will contain, at a minimum, declarations of the following form:

@smallexample
@c #include <sys/types.h>  /* required in all modules and drivers */
@c #include <sys/stream.h> /* required in all modules and drivers */
@c #include <sys/param.h>
#include <linux/types.h>  /* required in all modules and drivers */
#include <linux/stream.h> /* required in all modules and drivers */

static struct module_info rminfo = @{
    .mi_idnum = 0x08,
    .mi_idname = "mod",
    .mi_minpsz = 0,
    .mi_maxpsz = INFPSZ,
    .mi_hiwat = 0,
    .mi_lowat = 0,
@};
static struct module_info wminfo = @{
    .mi_idnum = 0x08,
    .mi_idname = "mod",
    .mi_minpsz = 0,
    .mi_maxpsz = INFPSZ,
    .mi_hiwat = 0,
    .mi_lowat = 0,
@};

static int modopen(queue_t *, dev_t *, int, int, cred_t *);
static int modput(queue_t *, mblk_t *);
static int modclose(queue_t *, int, cred_t *);

static struct qinit rinit = @{
    .qi_putp = modput,
    .qi_srvp = NULL,
    .qi_qopen = modopen,
    .qi_qclose = modclose,
    .qi_qadmin = NULL,
    .qi_minfo = &rminfo,
    .qi_mstat = NULL,
@};

static struct qinit winit = @{
    .qi_putp = modput,
    .qi_srvp = NULL,
    .qi_qopen = NULL,
    .qi_qclose = NULL,
    .qi_qadmin = NULL,
    .qi_minfo = &wminfo,
    .qi_mstat = NULL,
@};

struct streamtab modinfo = @{
    .st_rdinit = &rinit,
    .st_wrinit = &winit,
    .st_muxrinit = NULL,
    .st_muxwinit = NULL,
@};
@c 
@c extern int moddevflag = 0; /* not necessary for LFS */
@end smallexample

The contents of these declarations are constructed for the @file{nullmod} null module example in
this section.  This module performs no processing.  Its only purpose is to show linkage of a module
into the system.  The descriptions in this section are general to all @dfn{STREAMS} modules and
drivers unless they specifically reference the example.

The declarations shown are: the header set; the read and write queue (@code{rminfo} and
@code{wminfo}) @code{module_info} structures; the module open, read-put, write-put, and close
procedures; the read and write (@code{rinit}, and @code{winit}) @code{qinit} structures; and the
@mantype{streamtab(9)} structure.

The header files, @header{types.h} and @header{stream.h}, are always required for modules and drivers.
@ignore
The header file, @header{param.h}, contains definitions for @samp{NULL} and other values for
@dfn{STREAMS} modules and drivers as shown later in this chapter (@pxref{Accessible Symbols and
Functions}).
@end ignore

@ignore
When configuring a @dfn{STREAMS} module or driver (@pxref{STREAMS Configuration}) the
@type{streamtab} structure must be externally accessible.  The @type{streamtab} structure name must
be the @var{prefix} appended with @samp{info}.  Also, the driver flag must be externally accessible.
The flag name must be the @var{prefix} appended with @samp{devflag}.
@end ignore

The @type{streamtab} contains @code{qinit} values for the read and write queues.  The @code{qinit}
structures in turn point to a @code{module_info} and an optional @code{module_stat} structure.  The
two required structures are:

@smallexample
typedef int (*qi_putp_t) (queue_t *, mblk_t *);
typedef int (*qi_srvp_t) (queue_t *);
typedef int (*qi_qopen_t) (queue_t *, dev_t *, int, int, cred_t *);
typedef int (*qi_qclose_t) (queue_t *, int, cred_t *);
typedef int (*qi_qadmin_t) (void);

struct qinit @{
    qi_putp_t qi_putp;                  /* put procedure */
    qi_srvp_t qi_srvp;                  /* service procedure */
    qi_qopen_t qi_qopen;                /* each open (read q only) */
    qi_qclose_t qi_qclose;              /* last close (read q only) */
    qi_qadmin_t qi_qadmin;              /* admin procedure (not used) */
    struct module_info *qi_minfo;       /* module info */
    struct module_stat *qi_mstat;       /* module stats */
@};

struct module_info @{
    ushort mi_idnum;                    /* module id number */
    char *mi_idname;                    /* module name */
    ssize_t mi_minpsz;                  /* min packet size accepted */
    ssize_t mi_maxpsz;                  /* max packet size accepted */
    size_t mi_hiwat;                    /* hi water mark */
    size_t mi_lowat;                    /* lo water mark */
@};
@end smallexample

The @code{qinit} contains the queue procedures: @command{put}, @command{service}, @command{open},
and @command{close}.  All modules and drivers with the same @type{streamtab} (i.e., the same
@code{fmodsw} or @code{cdevsw} entry) point to the same upstream and downstream @code{qinit}
structure(s).  The structure is meant to be software read-only, as any changes to it affect all
instantiations of that module in all @dfn{Streams}.  Pointers to the @command{open} and
@command{close} procedures must be contained in the read @code{qinit} structure.  These fields are
ignored on the write-side.  Our example has no @command{service} procedure on the read-side or
write-side.

The @code{module_info} contains identification and limit values.  All queues associated with a
certain driver/module share the same @code{module_info} structures.  The @code{module_info}
structures define the characteristics of that driver/module's queues.  As with the @code{qinit},
this structure is intended to be software read-only.

However, the four limit values (@var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, @var{q_lowat}) are
copied to a queue structure where they are modifiable.  In the example, the flow control high and
low water marks are zero since there is no @command{service} procedure and messages are not queued
in the module.

Three names are associated with a module:

@enumerate
@item the character string in @code{fmodsw}, obtained from the name of the @file{master.d} file used
to configure the module;
@item the prefix for @type{streamtab}, used in configuring the module;
@item and the module name field in the @code{module_info} structure.
@end enumerate

The module name must be the same as that of @file{master.d} for autoconfiguration.  Each module ID
and module name should be unique in the system.  The module ID is currently used only in logging and
tracing (see @manref{strlog(9)}).  It is @samp{0x08} in the example.

Minimum and maximum packet sizes are intended to limit the total number of characters contained in
@msg{M_DATA} messages passed to this queue.  These limits are advisory except for the @dfn{Stream
head}.  For certain system calls that write to a @dfn{Stream}, the @dfn{Stream head} will observe
the packet sizes set in the write queue of the module immediately below it.  It is also expected
that the module immediately below the @dfn{Stream head} will observe the packet sizes set in the
read queue of the @dfn{Stream head}.  Otherwise, the use of packet size is developer dependent.  In
the example, @constant{INFPSZ} indicates unlimited size on the read-side.

The @code{module_stat} is optional.  Currently, there is no explicit @dfn{STREAMS} support for
statistical information gathering.  If the module or driver wishes to collect statistics, it should
do so from within its own procedures.

@subsubsection Null Module Example

The null module procedures are as follows:

@smallexample
static int
modopen(q, devp, flag, sflag, credp)
        queue_t *q;     /* pointer to the read queue */
        dev_t *devp;    /* pointer to major/minor device number */
        int flag;       /* file flags */
        int sflag;      /* stream open flags */
        cred_t *credp;  /* pointer to a credentials structure */
@{
    /* return success */
    return 0;
@}
static int
modput(q, mp)           /* put procedure */
        queue_t *q;     /* pointer to the queue */
        mblk_t *mp;     /* message pointer */
@{
    putnext(q, mp);             /* pass message through */
@}

/* NOTE: we only need one put procedure that can be used for both
 * read-side and write-side.
 */
static int
modclose(q, flag, credp)
        queue_t *q;     /* pointer to the read queue */
        int flag;       /* file flags */
        cred_t *credp;  /* pointer to a credentials structure */
@{
    return 0;
@}
@end smallexample

The form and arguments of these procedures are the same in all modules and all drivers.  Modules and
drivers can be used in multiple @dfn{Streams} and their procedures must be reentrant.

@samp{modopen} illustrates the open call arguments and return value.  The arguments are the read
queue pointer (@var{q}), the pointer (@var{devp}) to the major/minor device number, the file flags
(@var{flag}, defined in @header{linux/file.h}), the @dfn{Stream} open flag (@var{sflag}), and a pointer
to a credentials structure (@var{credp}).  The @dfn{Stream} open flag can take on the following values:

@multitable @columnfractions .15 .85
@item @constant{MODOPEN}
@tab normal module open
@item @constant{0}
@tab normal driver open
@item @constant{DRVOPEN}
@tab normal driver open
@item @constant{CLONEOPEN}
@tab clone driver open
@end multitable

The return value from open is @samp{0} for success and an error number (non-zero) for failure.  If a
driver is called with the @constant{CLONEOPEN} flag, the device number pointed to by the @var{devp}
should be set by the driver to an unused device number accessible to that driver.  This should be an
entire device number (major and minor device number).

For a module, the @var{devp} argument points to the device number (major and minor device numbers)
associated with the driver over which the module is pushed.  Modules are always opened with
@var{sflag} set to @constant{MODOPEN}.  Modules should treat the area pointed to by @var{devp} as
read only, and any alterations made to this area will be ignored by @dfn{STREAMS}.

The open procedure for a module is called on the first @ioctlref{I_PUSH} and on all subsequent open
calls to the same @dfn{Stream}.  During a push, a nonzero return value causes the @streamio{I_PUSH}
to fail and the module to be removed from the @dfn{Stream}.  If an error is returned by a module
during an @manpage{open(2)} call, the open fails, but the @dfn{Stream} remains intact.

@ignore
The module open fails if not opened by the super-user (also referred to as a privileged user) that
in future releases will be a user with @samp{driver/special} permissions.
@end ignore

Permission checks in module and driver open routines should be done with the @manpage{drv_priv(9)}
routine.  For @cite{Linux}, there is no need to check if @samp{u.u_uid == 0}.  This and the
@manpage{suser(9)} routine are replaced with:

@smallexample
error = drv_priv(credp);
if (error)                      /* not super-user */
    return errno;
@end smallexample

In the null module example, @samp{modopen} simply returns successfully.  @samp{modput} illustrates
the common interface to @command{put} procedures.  The arguments are the read or write queue
pointer, as appropriate, and the message pointer.  The @command{put} procedure in the appropriate
side of the queue is called when a message is passed from upstream or downstream.  The @command{put}
procedure has no return value (i.e., any value returned is ignored).  In the example, no message
processing is performed.  All messages are forwarded using the @manpage{putnext(9)}
@c macro
function
(@pxref{STREAMS Utilities}).  @command{putnext} calls the @command{put} procedure of the next queue
in the proper direction.

The @command{close} routine is only called on an @ioctlref{I_POP} @manpage{ioctl(2)} or on the last
@manpage{close(2)} call of the @dfn{Stream}.  The arguments are the read queue pointer, the file
flags as in @samp{modopen}, and a pointer to a credentials structure.  The return value is @samp{0}
on success and @samp{errno} on failure.

@node Input-Output Control
@section STREAMS Input and Output Controls
@cindex input and output controls
@menu
* General ioctl Processing::
* I_STR ioctl Processing::
* Transparent ioctl Processing::
* Transparent ioctl Messages::
* Transparent ioctl Examples::
* I_LIST ioctl::
@end menu

@dfn{STREAMS} is an addition to the @b{Linux} system traditional character input/output (I/O)
mechanism.  In this section, the phrases @dfn{"character I/O mechanism"} and @dfn{"I/O mechanism"}
refer only to that part of the mechanism that pre-existed @dfn{STREAMS}.

The @dfn{character I/O mechanism} handles all @manpage{ioctl(2)} system calls in a transparent
manner.  That is, the kernel expects all @command{ioctl}s to be handled by the device driver
associated with the character special file on which the call is sent.  All @command{ioctl} calls are
sent to the driver, which is expected to perform all validation and processing other than file
descriptor validity checking.  The operation of any specific @command{ioctl} is dependent on the
device driver.  If the driver requires data to be transferred in from user space, it will use the
kernel @manpage{copyin(9)} function.  It may also use @manpage{copyout(9)} to transfer out any data
results back to user space.

With @dfn{STREAMS}, there are a number of differences from the @dfn{character I/O mechanism} that
impact @command{ioctl} processing.

First, there are a set of generic @dfn{STREAMS} @command{ioctl} command values (see
@manpage{ioctl(2)}) recognized and processed by the @dfn{Stream} head.  These are described in
@manpage{streamio(7)}.  The operation of the generic @dfn{STREAMS} @command{ioctl}s are generally
independent of the presence of any specific module or driver on the @dfn{Stream}.

The second difference is the absence of user context in a module and driver when the information
associated with the @command{ioctl} is received.  This prevents use of @manpage{copyin(9)} or
@manpage{copyout(9)} by the module.  This also prevents the module and driver from associating any
kernel data with the currently running process.  (It is likely that by the time the module or driver
receives the @command{ioctl}, the process generating it may no longer be running.)

A third difference is that for the @dfn{character I/O mechanism}, all @command{ioctl}s are handled
by the single driver associated with the file.  In @dfn{STREAMS}, there can be multiple modules on a
@dfn{Stream} and each one can have its own set of @command{ioctl}s.  That is, the @command{ioctl}s
that can be used on a @dfn{Stream} can change as modules are pushed and popped.

@dfn{STREAMS} provides the capability for user processes to perform control functions on specific
modules and drivers in a @dfn{Stream} with @command{ioctl} calls.  Most @manpage{streamio(7)}
@command{ioctl} commands go no further than the @dfn{Stream} head.  They are fully processed there
and no related messages are sent downstream.  However, certain commands and all unrecognized
commands cause the @dfn{Stream} head to create an @msg{M_IOCTL} message which includes the
@command{ioctl} arguments and send the message downstream to be received and processed by a specific
module or driver.  The @msg{M_IOCTL} message is the initial message type which carries
@command{ioctl} information to modules.  Other message types are used to complete the
@command{ioctl} processing in the @dfn{Stream}.  In general, each module must uniquely recognize and
take action on specific @msg{M_IOCTL} messages.

@dfn{STREAMS} @command{ioctl} handling is equivalent to the transparent processing of the
@dfn{character I/O mechanism}.  @dfn{STREAMS} modules and drivers can process @command{ioctl}s
generated by applications that are implemented for a non-@dfn{STREAMS} environment.

@node General ioctl Processing
@subsection General @command{ioctl} Processing

@dfn{STREAMS} blocks a user process which issues an @command{ioctl} and causes the Stream head to generate an
@msg{M_IOCTL} message.  The process remains blocked until either:

@itemize @bullet

@item a module or a driver responds with an @msg{M_IOCACK} (ack, positive acknowledgement) message
or an @msg{M_IOCNAK} (nak, negative acknowledgement) message, or

@item no message is received and the request "times out," or

@item the @command{ioctl} is interrupted by the user process, or

@item an error condition occurs.

@end itemize

For the @command{ioctl} @ioctlref{I_STR} the timeout period can be a user specified interval or a
default.  For the other @msg{M_IOCTL} @command{ioctl}s, the default value (infinite) is used.

For an @streamio{I_STR}, the @dfn{STREAMS} module or driver that generates a positive acknowledgement
message can also return data to the process in that message.  An alternate means to return data is
provided with transparent @command{ioctl}.  If the @dfn{Stream} head does not receive a positive or
negative acknowledgement message in the specified time, the @command{ioctl} call fails.

A module that receives an unrecognized @msg{M_IOCTL} message should pass it on unchanged.  A driver
that receives an unrecognized @msg{M_IOCTL} should produce a negative acknowledgement.

The form of an @msg{M_IOCTL} message is a single @msg{M_IOCTL} message block followed by (see
@msg{M_PROTO} and @msg{M_PCPROTO} Message Structure, @pxref{Message Types}) zero or more
@msg{M_DATA} blocks.  The @msg{M_IOCTL} message block contains an @code{iocblk} structure, defined
in @header{sys/stream.h}:

@smallexample
struct iocblk @{
    int ioc_cmd         /* ioctl command type */
    cred_t *ioc_cr;     /* full credentials */
    uint ioc_id;        /* ioctl id */
    uint ioc_count;     /* count of bytes in data field */
    int ioc_error;      /* error code */
    int ioc_rval;       /* return value */
    long ioc_filler[4]; /* reserved for future use */
@};

#define ioc_uid ioc_cr->cr_uid
#define ioc_gid ioc_cr->cr_gid
@end smallexample

For an @streamio{I_STR} @command{ioctl}, @var{ioc_cmd} contains the command supplied by the user in the
@code{strioctl} structure defined in @manpage{streamio(7)}.

If a module or driver determines an @msg{M_IOCTL} message is in error for any reason, it must
produce the negative acknowledgement message.  This is typically done by setting the message type to
@msg{M_IOCNAK} and sending the message upstream.  No data or a return value can be sent to a user in
this case.  If @var{ioc_error} is set to 0, the @dfn{Stream} head will cause the @command{ioctl}
call to fail with @errno{EINVAL}.  The driver has the option of setting @var{ioc_error} to an
alternate error number if desired.

@var{ioc_error} can be set to a nonzero value in both @msg{M_IOCACK} and @msg{M_IOCNAK}.  This will
cause that value to be returned as an error number to the process that sent the @command{ioctl}.

If a module wants to look at what @command{ioctl}s of other modules are doing, the module should not
look for a specific @msg{M_IOCTL} on the write-side but look for @msg{M_IOCACK} or @msg{M_IOCNAK} on
the read-side.  For example, the module sees @termio{TCSETA} (see @manpage{termio(7)}) going down and
wants to know what is being set.  The module should look at it and save away the answer but not use
it.  The read-side processing knows that the module is waiting for an answer for the
@command{ioctl}.  When the read-side processing sees an "ack" or "nak" next time, it checks if it is
the same @command{ioctl} (here @termio{TCSETA}) and if it is, the module may use the answer previously
saved.

The two @dfn{STREAMS} @command{ioctl} mechanisms, @streamio{I_STR} and transparent, are described next.
(Here, @streamio{I_STR} means the @manpage{streamio(7)} @streamio{I_STR} command and implies the related
@dfn{STREAMS} processing unless noted otherwise.) @streamio{I_STR} has a restricted format and restricted
addressing for transferring @command{ioctl}-related data between user and kernel space.  It requires
only a single pair of messages to complete @command{ioctl} processing.  The transparent mechanism is
more general and has almost no restrictions on @command{ioctl} data format and addressing.  The
transparent mechanism generally requires that multiple pairs of messages be exchanged between the
@dfn{Stream} head and module to complete the processing.

@node I_STR ioctl Processing
@subsection @code{I_STR} @command{ioctl} Processing

The @streamio{I_STR} @command{ioctl} provides a capability for user applications to perform module and
driver control functions on @dfn{STREAMS} files.  @streamio{I_STR} allows an application to specify the
@command{ioctl} timeout.  It requires that all user @command{ioctl} data (to be received by the
destination module) be placed in a single block which is pointed to from the @code{strioctl}
structure.  The module can also return data to this block.

If the module is looking at for example the @termio{TCSETA}/@termio{TCGETA} group of @command{ioctl} calls
as they pass up or down a @dfn{Stream}, it must never assume that because @termio{TCSETA} comes down
that it actually has a data buffer attached to it.  The user may have formed @termio{TCSETA} as an
@streamio{I_STR} call and accidentally given a null data buffer pointer.  One must always check
@var{b_cont} to see if it is @samp{NULL} before using it as an index to the data block that goes with
@msg{M_IOCTL} messages.

The @termio{TCGETA} call, if formed as an @streamio{I_STR} call with a data buffer pointer set to a value by
the user, will always have a data buffer attached to @var{b_cont} from the main message block.  If
one assumes that the data block is not there and allocates a new buffer and assigns @var{b_cont} to
point at it, the original buffer will be lost.  Thus, before assuming that the @command{ioctl}
message does not have a buffer attached, one should check first.

The following example illustrates processing associated with an @streamio{I_STR} @command{ioctl}.
@command{lpdoioctl} is called to process trapped @msg{M_IOCTL} messages:

@smallexample
lpdoioctl(lp, mp)
	struct lp *lp;
	mblk_t *mp;

@{
    struct iocblk *iocp;
    queue_t *q;

    q = 1 p->qptr;

    /* 1st block contains iocblk structure */
    iocp = (struct iocblk *) mp->b_rptr;

    switch (iocp->ioc_cmd) @{
    case SET_OPTIONS:
	/* Count should be exactly one short's worth (for this example) 
	 */
	if (iocp->ioc_count != sizeof(short))
	    goto iocnak;
	if (mp->b_cont == NULL)
	    goto lognak;	/* not shown in this example */
	/* Actual data is in 2nd message block */
	lpsetopt(lp, *(short *) mp->b_cont->b_rptr);
	/* ACK the ioctl */
	mp->b_datap->db_type = M_IOCACK;
	iocp->ioc_cont = 0;
	greply(q, mp);
	break;
    default:
      iocnak:
	/* NAK the ioctl */
	mp->b_datap->db_type = M_IOCNAK;
	greply(q, mp);
    @}
@}
@end smallexample

@command{lpdoioctl} illustrates driver @msg{M_IOCTL} processing which also applies to modules.
However, at case default, a module would not "nak" an unrecognized command, but would pass the
message on.  In this example, only one command is recognized, @constant{SET_OPTIONS}.  @var{ioc_count}
contains the number of user supplied data bytes.  For this example, it must equal the size of a
short.  The user data are sent directly to the printer interface using @command{lpsetopt}.  Next,
the @msg{M_IOCTL} message is changed to type @msg{M_IOCACK} and the @var{ioc_count} field is set to
zero to indicate that no data are to be returned to the user.  Finally, the message is sent upstream
using @manpage{qreply(9)}.  If @var{ioc_count} was left nonzero, the Stream head would copy that
many bytes from the 2nd Nth message blocks into the user buffer.

@node Transparent ioctl Processing
@subsection Transparent @command{ioctl} Processing

The transparent @dfn{STREAMS} @command{ioctl} mechanism allows application programs to perform
module and driver control functions with @command{ioctl}s other than @ioctlref{I_STR}.  It is intended to
transparently support applications developed prior to the introduction of @dfn{STREAMS}.  It
alleviates the need to recode and recompile the user level software to run over @dfn{STREAMS} files.

The mechanism extends the data transfer capability for @dfn{STREAMS} @command{ioctl} calls beyond
that provided in the @streamio{I_STR} form.  Modules and drivers can transfer data between their kernel
space and user space in any @command{ioctl} which has a value of the command argument not defined in
@manpage{streamio(7)}.  These @command{ioctl}s are known as transparent @command{ioctl}s to
differentiate them from the @streamio{I_STR} form.  Transparent processing support is necessary when
existing user level applications perform @command{ioctl}s on a non-@dfn{STREAMS} character device
and the device driver is converted to @dfn{STREAMS}.  The @command{ioctl} data can be in any format
mutually understood by the user application and module.

The transparent mechanism also supports @dfn{STREAMS} applications that want to send @command{ioctl}
data to a driver or module in a single call, where the data may not be in a form readily embedded in
a single user block.  For example, the data may be contained in nested structures, different user
space buffers, etc.

This mechanism is needed because user context does not exist in modules and drivers when
@command{ioctl} processing occurs.  This prevents them from using the kernel
@manpage{copyin(9)}/@manpage{copyout(9)} functions.  For example, consider the following
@command{ioctl} call:

@smallexample
ioctl (stream_fildes, user_command, &ioctl_struct);
@end smallexample

where @code{ioctl_struct} is a structure containing the members:

@smallexample
int stringlen;          /* string length */
char *string;
struct other_struct *other1;
@end smallexample

To read (or write) the elements of @code{ioctl_struct}, a module would have to perform a series of
@manpage{copyin(9)}/@manpage{copyout(9)} calls using pointer information from a prior
@manpage{copyin(9)} to transfer additional data.  A non @dfn{STREAMS} character driver could
directly execute these copy functions because user context exists during all @b{Linux} system
calls to the driver.  However, in @dfn{STREAMS}, user context is only available to modules and
drivers in their @command{open} and @command{close} routines.

The transparent mechanism enables modules and drivers to request that the @dfn{Stream} head perform a
@manpage{copyin(9)} or @manpage{copyout(9)} on their behalf to transfer @command{ioctl} data between
their kernel space and various user space locations.  The related data are sent in message pairs
exchanged between the @dfn{Stream} head and the module.  A pair of messages is required so that each
transfer can be acknowledged.  In addition to @msg{M_IOCTL}, @msg{M_IOCACK}, and @msg{M_IOCNAK}
messages, the transparent mechanism also uses @msg{M_COPYIN}, @msg{M_COPYOUT}, and @msg{M_IOCDATA}
messages.

The general processing by which a module or a driver reads data from user space for the transparent
case involves pairs of request/response messages, as follows:

@enumerate

@item The @dfn{Stream} head does not recognize the command argument of an @command{ioctl} call and
creates a transparent @msg{M_IOCTL} message (the @code{iocblk} structure has a @constant{TRANSPARENT}
indicator, @pxref{Transparent ioctl Messages}) containing the value of the @var{arg}
argument in the call.  It sends the @msg{M_IOCTL} message downstream.

@item A module receives the @msg{M_IOCTL} message, recognizes the @var{ioc_cmd}, and determines that
it is @constant{TRANSPARENT}.

@item If the module requires user data, it creates an @msg{M_COPYIN} message to request a
@manpage{copyin(9)} of user data.  The message will contain the address of user data to copy in and
how much data to transfer.  It sends the message upstream.

@item The @dfn{Stream} head receives the @msg{M_COPYIN} message and uses the contents to
@manpage{copyin(9)} the data from user space into an @msg{M_IOCDATA} response message which it sends
downstream.  The message also contains an indicator of whether the data transfer succeeded (the
@manpage{copyin(9)} might fail, for instance, because of an @errno{EFAULT} (see @manpage{errno(3)})
condition).

@item The module receives the @msg{M_IOCDATA} message and processes its contents.  The module may
use the message contents to generate another @msg{M_COPYIN}.  Steps 3 through 5 may be repeated
until the module has requested and received all the user data to be transferred.

@item When the module completes its data transfer, it performs the @command{ioctl} processing and
sends an @msg{M_IOCACK} message upstream to notify the @dfn{Stream} head that @command{ioctl}
processing has successfully completed.

@end enumerate

Writing data from a module to user space is similar except that the module uses an @msg{M_COPYOUT}
message to request the @dfn{Stream} head to write data into user space.  In addition to length and
user address, the message includes the data to be copied out.  In this case, the @msg{M_IOCDATA}
response will not contain user data, only an indication of success or failure.

The module may intermix @msg{M_COPYIN} and @msg{M_COPYOUT} messages in any order.  However, each
message must be sent one at a time; the module must receive the associated @msg{M_IOCDATA} response
before any subsequent @msg{M_COPYIN}/@msg{M_COPYOUT} request or "ack/nak" message is sent upstream.
After the last @msg{M_COPYIN}/@msg{M_COPYOUT} message, the module must send an @msg{M_IOCACK}
message (or @msg{M_IOCNAK} in the event of a detected error condition).

For a transparent @msg{M_IOCTL}, user data can not be returned with an @msg{M_IOCACK} message.  The
data must have been sent with a preceding @msg{M_COPYOUT} message.

@node Transparent ioctl Messages
@subsection Transparent @command{ioctl} Messages

The form of the @msg{M_IOCTL} message generated by the @dfn{Stream head} for a transparent
@command{ioctl} is a single @msg{M_IOCTL} message block followed by one @msg{M_DATA} block.  The
form of the @code{iocblk} structure in the @msg{M_IOCTL} block is the same as described above
@pxref{General ioctl Processing}).  However, @var{ioc_cmd} is set to the value of the command
argument in the @command{ioctl} system call and @var{ioc_count} is set to @constant{TRANSPARENT}, defined
in @header{sys/stream.h}.  @constant{TRANSPARENT} distinguishes the case where an @ioctlref{I_STR}
@command{ioctl} may specify a value of ioc_cmd equivalent to the command argument of a transparent
@command{ioctl}.  The @msg{M_DATA} block of the message contains the value of the @var{arg}
parameter in the call.

Modules that process a specific @var{ioc_cmd} which did not validate the @var{ioc_count} field of
the @msg{M_IOCTL} message will break if transparent @command{ioctl}s with the same command are
performed from user space.

@msg{M_COPYIN}, @msg{M_COPYOUT}, and @msg{M_IOCDATA} messages and their use are described in more
detail (@pxref{Message Types}).

@node Transparent ioctl Examples
@subsection Transparent @command{ioctl} Examples

Following are three examples of transparent @command{ioctl} processing.  The first illustrates
@msg{M_COPYIN}.  The second illustrates @msg{M_COPYOUT}.  The third is a more complex example showing
state transitions combining both @msg{M_COPYIN} and @msg{M_COPYOUT}.

@subsubsection @code{M_COPYIN} Example

In this example, the contents of a user buffer are to be transferred into the kernel as part of an
ioctl call of the form

@smallexample
ioctl(fd, SET_ADDR, &bufadd)
@end smallexample

where @code{bufadd} is a structure declared as

@smallexample
struct address @{
    int ad_len;         /* buffer length in bytes */
    caddr_t ad_addr;    /* buffer address */
@};
@end smallexample

This requires two pairs of messages (request/response) following receipt of the @msg{M_IOCTL}
message.  The first will @command{copyin} the structure and the second will @command{copyin} the
buffer.  This example illustrates processing that supports only the transparent form of
@command{ioctl}.  @dfn{xxx}@code{wput} is the write-side put procedure for module or driver
@dfn{xxx}:

@smallexample
struct address @{        /* same members as in user space */
    int ad_len;         /* length in bytes */
    caddr_t ad_addr;    /* buffer address */
@};

    /* state values (overloaded in private field) */
#define GETSTRUCT    0          /* address structure */
#define GETADDR      1          /* byte string from ad_addr */

xxxwput(q, mp)
        queue_t *q;     /* write queue */
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;

    switch (mp->b_datap->db_type) @{
    .
    .
    .
    case M_IOCTL:
        iocbp = (struct iocblk *) mp->b_rptr;
        switch (iocbp->ioc_cmd) @{
        case SET_ADDR:
            if (iocbp->ioc_count != TRANSPARENT) @{
                /* fail if I_STR */
                if (mp->b_cont) @{
                    /* return buffer to pool ASAP */
                    freemsg(mp->b_cont);
                    mp->b_cont = NULL;
                @}
                mp->b_datap->db_type = M_IOCNAK;        /* EINVAL */
                greply(q, mp);
                break;
            @}
            /* Reuse M_IOCTL block for M_COPYIN request */
            cqp = (struct copyreq *) mp->b_rptr;
            /* Get user space structure address from linked M_DATA
               block */
            cqp->cq_addr = (caddr_t) *(long *) mp->b_cont->b_rptr;
            freemsg(mp->b_cont);        /* MUST free linked blocks */
            mp->b_cont = NULL;
            cqp->cq_private = (mblk_t *) GETSTRUCT;
            /* to identify response */
            /* Finish describing M_COPYIN message */
            cqp->cq_size = sizeof(struct address);
            cqp->cq_flag = 0;
            mp->b_datap->db_type = M_COPYIN;
            mp->b_wptr = mp->b_rptr + sizeof(struct copyreq);
            greply(q, mp);
            break;
        default:                /* M_IOCTL not for us */
            /* if module, pass on */
            /* if driver, nak ioctl */
            break;
        @}                       /* switch (iocbp->ioc_cmd) */
        break;
    case M_IOCDATA:
        xxxioc(q, mp);          /* all M_IOCDATA processing done here */
        break;
    .
    .
    .
    @}                           /* switch (mp->b_datap->db_type) */
@}
@end smallexample

@dfn{xxx}@code{wput} verifies that the @constant{SET_ADDR} is @constant{TRANSPARENT} to avoid confusion with
an @ioctlref{I_STR} @command{ioctl} which uses a value of @var{ioc_cmd} equivalent to the command
argument of a transparent @command{ioctl}.  When sending an @msg{M_IOCNAK}, freeing the linked
@msg{M_DATA} block is not mandatory as the @dfn{Stream head} will free it.  However, this returns
the block to the buffer pool more quickly.

In this and all following examples in this section, the message blocks are reused to avoid the
overhead of deallocating and allocating.

The @dfn{Stream head} will guarantee that the size of the message block containing an @code{iocblk}
structure will be large enough also to hold the @code{copyreq} and @code{copyresp} structures.

@var{cq_private} is set to contain state information for @command{ioctl} processing (tells us what
the subsequent @msg{M_IOCDATA} response message contains).  Keeping the state in the message makes
the message self describing and simplifies the @command{ioctl} processing.  @msg{M_IOCDATA}
processing is done in @dfn{xxx}@code{ioc}.  Two @msg{M_IOCDATA} types are processed, @constant{GETSTRUCT}
and @constant{GETADDR}:

@smallexample
xxxioc(q, mp)                   /* M_IOCDATA processing */
        queue_t *q;
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct copyresp *csp;
    struct address *ap;

    csp = (struct copyresp *) mp->b_rptr;
    iocbp = (struct iocblk *) mp->b_rptr;
    switch (csp->cp_cmd) @{
        /* validate this M_IOCDATA is for this module */

    case SET_ADDR:
        if (csp->cp_rval) @{     /* GETSTRUCT or GETADDR failed */
            freemsg(mp);
            return;
        @}
        switch ((int) csp->cp_private) @{        /* determine state */

        case GETSTRUCT: /* user structure has arrived */
            mp->b_datap->db_type = M_COPYIN;    /* reuse M_IOCDATA
                                                   block */
            cqp = (struct copyreq *) mp->b_rptr;
            /* user structure */
            ap = (struct address *) mp->b_cont->b_rptr;
            cqp->cq_size = ap->ad_len;  /* buffer length */
            cqp->cq_addr = ap->ad_addr; /* user space buffer address */
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            cqp->cq_flag = 0;
            csp->cp_private = (mblk_t *) GETADDR;       /* next state */
            qreply(q, mp);
            break;

        case GETADDR:
            /* user address is here */
            /* hypothetical routine */
            if (xxx_set_addr(mp->b_cont) == FAILURE) @{
                mp->b_datap->db_type = M_IOCNAK;
                iocbp->ioc_error = EIO;
            @} else @{
                mp->b_datap->db_type = M_IOCACK;        /* success */
                iocbp->ioc_error = 0;   /* may have been overwritten */
                iocbp->ioc_count = 0;   /* may have been overwritten */
                iocbp->ioc_rval = 0;    /* may have been overwritten */
            @}
            mp->b_wptr = mp->b_rptr + sizeof(struct ioclk);
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            greply(q, mp);
            break;

        default:                /* invalid state: cannot happen */
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            mp->b_datap->db_type = M_IOCNAK;
            mp->b_wptr = mp->rptr + sizeof(struct iocblk);
            iocbp->ioc_error = EINVAL;  /* may have been overwritten */
            qreply(q, mp);
            ASSERT(0);          /* panic if debugging mode */
            break;
        @}
        break;                  /* switch (cp_private) */
    default:                    /* M_IOCDATA not for us */
        /* if module, pass message on */
        /* if driver, free message */
        break;
    @}                           /* switch (cp_cmd) */
@}
@end smallexample

@dfn{xxx}@code{_set_addr} is a routine (not shown in the example) that processes the user address
from the @command{ioctl}.  Since the message block has been reused, the fields that the @dfn{Stream
head} will examine (denoted by @cite{"may have been overwritten"}) must be cleared before sending an
@msg{M_IOCNAK}.

@subsubsection @code{M_COPYOUT} Example

In this example, the user wants option values for this @dfn{Stream} device to be placed into the
user's options structure (see beginning of example code, below).  This can be accomplished by use of
a transparent

@smallexample
ioctl(fd, GET_OPTIONS, &optadd)
@end smallexample

or, alternately, by use of a @manpage{streamio(7)} call

@smallexample
ioctl(fd, I_, &opts_strioctl)
@end smallexample

In the first case, @code{optadd} is declared @code{struct options}.  In the @ioctlref{I_STR} case,
@code{opts_strioctl} is declared @code{struct strioctl} where @code{opts_strioctl.ic_dp} points to
the user @code{options} structure.

This example illustrates support of both the @streamio{I_STR} and transparent forms of an
@command{ioctl}.  The transparent form requires a single @msg{M_COPYOUT} message following receipt
of the @msg{M_IOCTL} to @command{copyout} the contents of the structure.  @dfn{xxx}@code{wput} is
the write-side put procedure for module or driver @dfn{xxx}:

@smallexample
struct options @{        /* same members as in user space */
    int op_one;
    int op_two;
    short op_three;
    long op_four;
@};

xxxwput(q, mp)
        queue_t *q;     /* write queue */
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct copyresp *csp;
    int transparent = 0;

    switch (mp->b_datap->db_type) @{
    .
    .
    .
    case M_IOCTL:
        iocbp = (struct iocblk *) mp->b_rptr;

        switch (iocbp->ioc_cmd) @{
        case GET_OPTIONS:
            if (iocbp->ioc_count == TRANSPARENT) @{
                transparent = 1;
                cqp = (struce copyreq *) mp->b_rptr;
                cqp->cq_size = sizeof(struct options);
                /* Get structure address from linked M_DATA block */
                cqp->cq_addr = (caddr_t) *(long *) mp->b_cont->b_rptr;
                cqp->cq_flag = 0;
                /* No state necessary - we will only ever get one
                   M_IOCDATA from the Stream head indicating success or 
                   failure for the copyout */
            @}
            if (mp->b_cont)
                freemsg(mp->b_cont);    /* overwitten below */
            if ((mp->b_cont =
                 allocb(sizeof(struct options), BPRI_MED)) == NULL) @{
                mp->b_datap->db_type = M_IOCNAK;
                iocbp->ioc_error = EAGAIN;
                qreply(q, mp);
                break;
            @}
            /* hypothetical routine */
            xxx_get_options(mp->b_cont);
            if (transparent) @{
                mp->b_datap->db_type = M_COPYOUT;
                mp->b_wptr = mp->b_rptr + sizeof(struct copyreq);
            @} else @{
                mp->b_datap->db_type = M_IOCACK;
                iocbp->ioc_count = sizeof(struct options);
            @}
            qreply(q, mp);
            break;

        default:                /* M_IOCTL not for us */
            /* if module, pass on; if driver, nak ioctl */
            break;
        @}                       /* switch (iocbp->ioc_cmd) */
        break;

    case M_IOCDATA:
        csp = (struct copyresp *) mp->b_rptr;
        if (csp->cmd != GET_OPTIONS) @{  /* M_IOCDATA not for us */
            /* if module, pass on; if driver, free message */
            break;
        @}
        if (csp->cp_rval) @{
            freemsg(mp);        /* failure */
            return;
        @}
        /* Data successfully copied out, ack */
        /* reuse M_IOCDATA for ack */
        mp->b_datap->db_type = M_IOCACK;
        mp->b_wptr = mp->b_rptr + sizeof(struct iocblk);
        iocbp->ioc_error = 0;   /* may have been overwritten */
        iocbp->ioc_count = 0;   /* may have been overwritten */
        iocbp->ioc_rval = 0;    /* may have been overwritten */
        qreply(q, mp);
        break;
    .
    .
    .
    @}                           /* switch (mp->b_datap->db_type) */
@}
@end smallexample

@subsubsection Bidirectional Transfer Example

This example illustrates bidirectional data transfer between the kernel and user space during
transparent ioctl processing.  It also shows how more complex state information can be used.

The user wants to send and receive data from user buffers as part of a transparent @command{ioctl}
call of the form

@smallexample
ioctl(fd, XXX_IOCTL, &addr_xxxdata)
@end smallexample

The user @code{addr_xxxdata} structure defining the buffers is declared as struct @code{xxxdata},
shown below.  This requires three pairs of messages following receipt of the @msg{M_IOCTL} message:
the first to @command{copyin} the structure; the second to @command{copyin} one user buffer; and the
last to @command{copyout} the second user buffer.  @dfn{xxx}@code{wput} is the write-side put
procedure for module or driver @dfn{xxx}:

@smallexample
struct xxxdata @{        /* same members in user space */
    int x_inlen;        /* number of bytes copied in */
    caddr_t x_inaddr;   /* buffer address of data copied in */
    int x_outlen;       /* number of bytes copied out */
    caddr_t x_outaddr;  /* buffer address of data copied out */
@};

    /* State information for ioctl processing */
struct state @{
    int st_state;       /* see below */
    struct xxxdata st_data;     /* see above */
@};

    /* state values */
#define GETSTRUCT        0      /* get xxxdata structure */
#define GETINDATA        1      /* get data from x_inaddr */
#define PUTOUTDATA       1      /* get response from M_COPYOUT */

xxxwput(q, mp)
        queue_t *q;     /* write queue */
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct state *stp;
    mblk_t *tmp;

    switch (mp->b_datap->db_type) @{
    .
    .
    .
    case M_IOCTL:
        iocbp = (struct iocblk *) mp->b_rptr;
        switch (iocbp->ioc_cmd) @{
        case XXX_IOCTL:
            if (iocbp->ioc_cont != TRANSPARENT) @{
                /* fail if I_STR */
                if (mp->b_cont) @{
                    /* return buffer to pool ASAP */
                    freemsg(mp->b_cont);
                    mp->b_cont = NULL;
                @}
                mp->b_datap->db_type = M_IOCNAK;        /* EINVAL */
                qreply(q, mp);
                break;
            @}
            /* Reuse M_IOCTL block for M_COPYIN request */
            cqp = (struct copyreq *) mp->b_rptr;
            /* Get structure's user address from linked M_DATA block */
            cqp->cq_addr = (caddr_t) *(long *) mp->b_cont->b_rptr;
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            /* Allocate state buffer */
            if ((tmp =
                 allocb(sizeof(struct state), BPRI_MED)) == NULL) @{
                mp->b_datap->db_type = M_IOCNK;
                iocbp->ioc_error = EAGAIN;
                qreply(q, mp);
                break;
            @}
            tmp->b_wptr += sizeof(struct state);
            stp = (struct state *) tmp->b_rptr;
            stp->st_state = GETSTRUCT;
            cqp->cq_private = tmp;
            /* Finish describing M_COPYIN message */
            cqp->cq_size = sizeof(struct xxxdata);
            cqp->cq_flag = 0;
            mp->b_datap->db_type = M_COPYIN;
            mp->b_wptr = mp->b_rptr + sizeof(struct copyreq);
            qreply(q, mp);
            break;

        default:                /* M_ioctl not for us */
            /* if module, pass on */
            /* if driver, nak ioctl */
            break;
        @}
        break;
    case M_IOCDATA:
        xxxioc(q, mp);          /* all M_IOCDATA processing done here 
                                 */
        break;
    .
    .
    .
    @}                           /* switch (mp->b_datap->db_type) */
@}
@end smallexample

@dfn{xxx}@code{wput} allocates a message block to contain the state structure and reuses the
@msg{M_IOCTL}
to create an @msg{M_COPYIN} message to read in the @dfn{xxx}@code{data} structure.

@msg{M_IOCDATA} processing is done in @dfn{xxx}@code{ioc}:

@smallexample
xxxioc(q, mp)                   /* M_IOCDATA processing */
        queue_t *q;
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct copyresp *csp;
    struct state *stp;
    mblk_t *xxx_indata();

    csp = (struct copyresp *) mp->b_rptr;
    iocbp = (struct iocblk *) mp->b_rptr;
    switch (csp->cp_cmd) @{

    case XXX_IOCTL:
        if (csp->cp_rval) @{     /* failure */
            if (csp->cp_private)        /* state structure */
                freemsg(csp->cp_private);
            freemsg(mp);
            return;
        @}
        stp = (struct state *) csp->cp_private->b_rptr;
        switch (stp->st_state) @{

        case GETSTRUCT: /* xxxdata structure copied in */
            /* save structure */
            stp->st_data = *(struct xxxdata *) mp->b_cont->b_rptr;
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            /* Reuse M_IOCDATA to copyin data */
            mp->b_datap->db_type = M_COPYIN;
            cqp = (struct copyreq *) mp->b_rptr;
            cqp->cq_size = stp->st_data.x_inlen;
            cqp->cq_addr = stp->st_data.x_inaddr;
            cqp->cq_flag = 0;
            stp->st_state = GETINDATA;  /* next state */
            qreply(q, mp);
            break;

        case GETINDATA: /* data successfully copied in */
            /* Process input, return output */
            if ((mp->b_cont = xxx_indata(mp->b_cont)) == NULL) @{
                /* hypothetical */
                mp->b_datap->db_type = M_IOCNAK;
                /* fall xxx_indata */
                mp->b_wptr = mp->b_rptr + sizeof(struct iocblk);
                iocbp->ioc_error = EIO;
                qreply(q, mp);
                break;
            @}
            mp->b_datap->db_type = M_COPYOUT;
            cqp = (struct copyreq *) mp->b_rptr;
            cqp->cq_size =
                min(msgdsize(mp->b_cont), stp->st_data.x_outlen);
            cqp->cq_addr = stp->st_data.x_outaddr;
            cqp->cq_flag = 0;
            stp->st_state = PUTOUTDATA; /* next state */
            qreply(q, mp);
            break;

        case PUTOUTDATA:        /* data successfilly copied out, ack
                                   ioctl */
            freemsg(csp->cp_private);   /* state structure */
            mp->b_datap->db_type = M_IOCACK;
            mp->b_wtpr = mp->b_rptr + sizeof(struct iocblk);
            iocbp->ioc_error = 0;       /* may have been overwritten */
            iocbp->ioc_count = 0;       /* may have been overwritten */
            iocbp->ioc_rval = 0;        /* may have been overwritten */
            qreply(q, mp);
            break;

        default:                /* invalid state: cannot happen */
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            mp->b_datap->db_type = M_IOCNAK;
            mp->b_wptr = mp->b_rptr + sizeof(struct iocblk);
            iocbp->ioc_error = EINVAL;
            qreply(q, mp);
            ASSERT(0);          /* panic if debugging mode */
            break;
        @}                       /* switch (stp->st_state) */
        break;
    default:                    /* M_IOCDATA not for us */
        /* if module, pass message on */
        /* if driver, free message */
        break;
    @}                           /* switch (csp->cp_cmd) */
@}
@end smallexample

At case @constant{GETSTRUCT}, the @dfn{xxx}@code{data} structure is copied into the module's state
structure (pointed at by @var{cp_private} in the message) and the @msg{M_IOCDATA} message is reused
to create a second @msg{M_COPYIN} message to read in the user data.  At case @constant{GETINDATA}, the
input user data are processed by the @dfn{xxx}@code{_indata} routine (not supplied in the example)
which frees the linked @msg{M_DATA} block and returns the output data message block.  The
@msg{M_IOCDATA} message is reused to create an @msg{M_COPYOUT} message to write the user data.  At
case @constant{PUTOUTDATA}, the message block containing the state structure is freed and an
acknowledgement is sent upstream.

Care must be taken at the "cannot happen" default case since the message block containing the state
structure (@var{cp_private}) is not returned to the pool because it might not be valid.  This might
result in a lost block.  The @command{ASSERT} will help find errors in the module if a "cannot
happen" condition occurs.

@node I_LIST ioctl
@subsection @code{I_LIST} @command{ioctl}

The @command{ioctl} @ioctlref{I_LIST} supports the
@command{strconf} and @command{strchg} commands (see @manpage{strconf(1)} and @manpage{strchg(1)})
that are used to query or change the configuration of a @dfn{Stream}.  Only the super-user or an
owner of a @dfn{STREAMS} device may alter the configuration of that @dfn{Stream}.

The @manpage{strchg(1)} command does the following:

@itemize @bullet
@item Push one or more modules on the @dfn{Stream}.
@item Pop the topmost module off the @dfn{Stream}.
@item Pop all the modules off the @dfn{Stream}.
@item Pop all modules up to but not including a specified module.
@end itemize

The @manpage{strconf(1)} command does the following:

@itemize @bullet
@item Indicate if the specified module is present on the @dfn{Stream}.
@item Print the topmost module of the @dfn{Stream}.
@item Print a list of all modules and topmost driver on the @dfn{Stream}.
@end itemize

If the @dfn{Stream} contains a multiplexing driver, the @manpage{strchg(1)} and @manpage{strconf(1)}
commands will not recognize any modules below that driver.

The @command{ioctl} @streamio{I_LIST} performs two functions.  When the third argument of the
@command{ioctl} call is set to @samp{NULL}, the return value of the call indicates the number of
modules, including the driver, present on the @dfn{Stream}.  For example, if there are two modules
above the driver, 3 is returned.  On failure, @manpage{errno(3)} may be set to a value specified in
@manpage{streamio(7)}.  The second function of the @streamio{I_LIST} @command{ioctl} is to copy the
module names found on the @dfn{Stream} to the user supplied buffer.  The address of the buffer in
user space and the size of the buffer are passed to the @command{ioctl} through a structure
@code{str_list} that is defined as:

@smallexample
struct str_mlist @{
    char l_name[FMNAMESZ + 1];  /* space for holding a module name */
@};
struct str_list @{
    int sl_nmods;       /* # of modules for which space is allocated */
    struct str_mlist *sl_modlist;  /* address of buffer for names */
@};
@end smallexample

where @var{sl_nmods} is the number of modules in the @var{sl_modlist} array that the user has
allocated.  Each element in the array must be at least @samp{FMNAMESZ+1} bytes long.  @constant{FMNAMESZ}
is defined by @header{sys/conf.h}.

The user can find out how much space to allocate by first invoking the @command{ioctl} @streamio{I_LIST}
with arg set to @samp{NULL}.  The @streamio{I_LIST} call with @var{arg} pointing to the @code{str_list}
structure returns the number of entries that have been filled into the @var{sl_modlist} array (the
number includes the number of modules including the driver).  If there is not enough space in the
@var{sl_modlist} array (see note) or @var{sl_nmods} is less than 1, the @streamio{I_LIST} call will fail
and @manpage{errno(3)} is set to @errno{EINVAL}.  If @var{arg} or the @var{sl_modlist} array points outside the
allocated address space, @errno{EFAULT} is returned.

It is possible, but unlikely, that another module was pushed on the @dfn{Stream} after the user
invoked the @streamio{I_LIST} @command{ioctl} with the @samp{NULL} argument and before the @streamio{I_LIST}
@command{ioctl} with the structure argument was invoked.

@node Flush Handling
@section STREAMS Flush Handling
@cindex flush handling

All modules and drivers are expected to handle @msg{M_FLUSH} messages.  An @msg{M_FLUSH} message can
originate at the @dfn{Stream head} or from a module or a driver.  The first byte of the
@msg{M_FLUSH} message is an option flag that can have following values:

@vtable @constant
@item FLUSHR
Flush read queue.
@item FLUSHW
Flush write queue.
@item FLUSHRW
Flush both, read and write, queues.
@item FLUSHBAND
Flush a specified priority band only.
@end vtable

The following example shows line discipline module flush handling:

@smallexample
ld_put(q, mp)
        queue_t *q;     /* pointer to read/write queue */
        mblk_t *mp;     /* pointer to message being passed */
@{
    switch (mp->b_datap->db_type) @{
    default:
        putq(q, mp);            /* queue everything */
        return;                 /* except flush */

    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW)       /* flush write queue */
            flushq((q->q_flag & QREADR) ? WR(q) : q, FLUSHDATA);

        if (*mp->b_rptr & FLUSHR)       /* flush read queue */
            flushq((q->q_flag & QREADR) ? q : RD(q), FLUSHDATA);
        putnext(q, mp);         /* pass it on */
        return;
    @}
@}
@end smallexample

The @dfn{Stream head} turns around the @msg{M_FLUSH} message if @constant{FLUSHW} is set (@constant{FLUSHR}
will be cleared).  A driver turns around @msg{M_FLUSH} if @constant{FLUSHR} is set (should mask off
@constant{FLUSHW}).

The next example shows the line discipline module flushing due to break:

@smallexample
ld_put(q, mp)
        queue_t *q;     /* pointer to read/write queue */
        mblk_t *mp;     /* pointer to message being passed */
@{
    switch (mp->b_datap->db_type) @{
    default:
        putq(q, mp);            /* queue everything except flush */
        return;

    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW)       /* flush write queue */
            flushq((q->q_flag & QREADR) ? WR(q) : q, FLUSHDATA);

        if (*mp->b_rptr & FLUSHR)       /* flush read queue */
            flushq((q->q_flag & QREADR) ? q : RD(q), FLUSHDATA);
        putnext(q, mp);         /* pass it on */
        return;
    case M_BREAK:
        if (q->q_flag & QREADR) @{       /* read side only */
            /* it does not make sense for write side */
            putctll(q->q_next, M_PCSIG, SIGINT);
            putctll(q->q_next, M_FLUSH, FLUSHW);
            putctll(WR(q)->q_next, M_FLUSH, FLUSHR);
        @}
        return;
    @}
@}
@end smallexample

The next two figures further demonstrate flushing the entire @dfn{Stream} due to a line break.
@figref{10} shows the flushing of the write-side of a @dfn{Stream}, and @figref{11} shows the
flushing of the read-side of a @dfn{Stream}.  In the figures dotted boxes indicate flushed queues.

@figuresized{SPG_fig10,10,Flushing the Write-Side of a @dfn{Stream},4in}

The following takes place:

@enumerate

@item A break is detected by a driver.

@item The driver generates an @msg{M_BREAK} message and sends it upstream.

@item The module translates the @msg{M_BREAK} into an @msg{M_FLUSH} message with @constant{FLUSHW} set and sends it upstream.

@item The @dfn{Stream} head does not flush the write queue (no messages are ever queued there).

@item The @dfn{Stream} head turns the message around (sends it down the write-side).

@item The module flushes its write queue.

@item The message is passed downstream.

@item The driver flushes its write queue and frees the message.

@end enumerate

This figure shows flushing read-side of a @dfn{Stream}.

@figuresized{SPG_fig11,11,Flushing the Read-Side of a @dfn{Stream},4in}

The events taking place are:

@enumerate
@item After generating the first @msg{M_FLUSH} message, the module generates an @msg{M_FLUSH} with
@constant{FLUSHR} set and sends it downstream.
@item The driver flushes its read queue.
@item The driver turns the message around (sends it up the read-side).
@item The module flushes its read queue.
@item The message is passed upstream.
@item The @dfn{Stream} head flushes the read queue and frees the message.
@end enumerate

The @manpage{flushband(9)} routine (@pxref{STREAMS Utilities}) provides the module and driver with
the capability to flush messages associated with a given priority band.  A user can flush a
particular band of messages by issuing:

@smallexample
ioctl(fd, I_FLUSHBAND, bandp)
@end smallexample

where @var{bandp} is a pointer to a structure @code{bandinfo} that has a format:

@smallexample
struct bandinfo @{
    unsigned char bi_pri;
    int bi_flag;
@};
@end smallexample

The @var{bi_flag} field may be one of @constant{FLUSHR}, @constant{FLUSHW}, or @constant{FLUSHRW}.

The following example shows flushing according to the priority band:

@smallexample
@{
    queue_t *rdq;       /* read queue */
    queue_t *wrq;       /* write queue */

    switch (bp->b_datap->db_type) @{
    case M_FLUSH:
        if (*bp->b_rptr & FLUSHBAND) @{
            if (*bp->b_rptr & FLUSHW)
                flushband(wrq, FLUSHDATA, *(bp->b_rptr + 1));
            if (*bp->b_rptr & FLUSHR)
                flushband(rdq, FLUSHDATA, *(bp->b_rptr + 1));
        @} else @{
            if (*bp->b_rptr & FLUSHW)
                flushq(wrq, FLUSHDATA);
            if (*bp->b_rptr & FLUSHR)
                flushq(rdq, FLUSHDATA);
        @}
        /* 
         * modules pass the message on;
         * drivers shut off FLUSHW and loop the message
         * up the read-side if FLUSHR is set; otherwise,
         * drivers free the message.
         */
        break;
    @}
@}
@end smallexample

Note that modules and drivers are not required to treat messages as flowing in separate bands.
Modules and drivers can view the queue having only two bands of flow, normal and high priority.
However, the latter alternative will flush the entire queue whenever an @msg{M_FLUSH} message is
received.

One use of the field @var{b_flag} of the @code{msgb} structure is provided to give the @dfn{Stream}
head a way to stop @msg{M_FLUSH} messages from being reflected forever when the @dfn{Stream} is
being used as a pipe.  When the @dfn{Stream} head receives an @msg{M_FLUSH} message, it sets the
@constant{MSGNOLOOP} flag in the @var{b_flag} field before reflecting the message down the write-side of
the @dfn{Stream}.  If the @dfn{Stream head} receives an @msg{M_FLUSH} message with this flag set,
the message is freed rather than reflected.

@node Driver-Kernel Interface
@section STREAMS Driver-Kernel Interface
@cindex driver-kernel interface

The @dfn{Driver-Kernel Interface (DKI)} is an interface between the @b{Linux} system kernel and
drivers.  These drivers are block interface drivers, character interface drivers, and drivers and
modules supporting a @dfn{STREAMS} interface.  Each driver type supports an interface from the
kernel to the driver.  This kernel to-driver interface consists of a set of driver-defined functions
that are called by the kernel.  These functions are the entry points into the driver.

One benefit of defining the @dfn{DKI} is increased portability of driver source code between various
@dfn{UNIX System V} implementations.  Another benefit is a gain in modularity that results in
extending the potential for changes in the kernel without breaking driver code.

The interaction between a driver and the kernel can be described as occurring along two paths.  (See
@figref{12}).

One path includes those functions in the driver that are called by the kernel.  These are entry
points into the driver.  The other path consists of the functions in the kernel that are called by
the driver.  These are kernel utility functions used by the driver.  Along both paths, information
is exchanged between the kernel and drivers in the form of data structures.  The @dfn{DKI}
identifies these structures and specifies a set of contents for each.  The @dfn{DKI} also defines
the common set of entry points expected to be supported in each driver type and their calling and
return syntaxes.  For each driver type, the @dfn{DKI} lists a set of kernel utility functions that
can be called by that driver and also specifies their calling and return syntaxes.

@figuresized{SPG_fig12,12,Interfaces Affecting Drivers,4in}

The set of @dfn{STREAMS} utilities available to drivers are listed (@pxref{STREAMS Utilities}).  No
system-defined macros that manipulate global kernel data or introduce structure size dependencies
are permitted in these utilities.  Therefore, some utilities that have been implemented as macros in
the prior @cite{UNIX} system releases are implemented as functions in @cite{UNIX System V Release
4.0}.  This does not preclude the existence of both macro and function versions of these utilities.
It is envisioned that driver source code will include a header file (@pxref{Header Files}, later in
this chapter) that picks up function declarations while the core operating system source includes a
header file that defines the macros.  With the @dfn{DKI} interface the following @dfn{STREAMS}
utilities are implemented as @samp{C} programming language functions: @manpage{datamsg(9)},
@manpage{OTHERQ(9)}, @manpage{putnext(9)}, @manpage{RD(9)}, @manpage{splstr(9)}, and
@manpage{WR(9)}.

Replacing macros such as @manpage{RD(9)} with function equivalents in the driver source code allows
driver objects to be insulated from changes in the data structures and their size, further
increasing the useful lifetime of driver source code and objects.

The @dfn{DKI} interface defines an interface suitable for drivers and there is no need for drivers
to access global kernel data structures directly.  The kernel functions @manpage{drv_getparm(9)} and
@manpage{drv_setparm(9)} are provided for reading and writing information in these structures.  This
restriction has an important consequence.  Since drivers are not permitted to access global kernel
data structures directly, changes in the contents/offsets of information within these structures
will not break objects.

@subsection Device Driver Interface and Driver-Kernel Interface

The @dfn{Device Driver Interface (DDI)} is an @cite{AT&T} interface that facilitates driver
portability across different @cite{UNIX} system versions on the @cite{AT&T 3B2} hardware.  The
@dfn{Driver-Kernel Interface (DKI)} is an interface that also facilitates driver source code
portability across implementations of @cite{UNIX System V Release 4.0} on all machines.  @dfn{DKI}
driver code, however, will have to be recompiled on the machine on which it is to run.

The most important distinction between the @dfn{DDI} and the @dfn{DKI} lies in scope.  The @dfn{DDI}
addresses complete interfaces (see note below) for block, character, and @dfn{STREAMS} interface
drivers and modules.  The @dfn{DKI} defines only driver interfaces with the kernel with the addition
of the kernel interface for file system type (@dfn{FST}) modules.  The @dfn{DKI} interface does not
specify the system initialization driver interface (i.e., @command{init()} and @command{start()}
driver routines) nor hardware related interfaces such as @command{getvec} for the @cite{AT&T 3B2}.

The "complete interface" refers to hardware- and boot/configuration-related driver interface in
addition to the interface with the kernel.

@subsection @dfn{STREAMS} Interface

The entry points from the kernel into @dfn{STREAMS} drivers and modules are through the @code{qinit}
structures (@pxref{STREAMS Data Structures}) pointed to by the @type{streamtab} structure,
@code{prefixinfo}.  @dfn{STREAMS} drivers may need to define additional entry points to support the
interface with boot/autoconfiguration software and the hardware (for example, an interrupt handler).

If the @dfn{STREAMS} module has prefix @dfn{mod} then the declaration is of the form:

@smallexample
static int modwput(), modwput(), modwsrv(), modclose();

static int modwput(), modwput(), modwsrv();

static struct qinit rdinit =
    @{ modrput, modrsrv, modopen, modclose, NULL, struct module_info,
NULL @};

static struct qinit wdinit =
    @{ modwput, modwsrv, NULL, NULL, NULL, struct module_info, NULL @};

struct streamtab modinfo = @{ &rdinit, &wrinit, NULL, NULL @};

extern int moddevflag = 0;
@end smallexample

where @code{modrput} is the module's read queue put procedure, @code{modrsrv} is the module's read
queue service procedure, @code{modopen} is the open routine for the module, @code{modclose} is the
close routine for the module, @code{modwput} is the put procedure for the module's write queue, and
@code{modwsrv} is the service procedure for the module's write queue.

Each @code{qinit} structure can point to four entry points.  (An additional function pointer has been
reserved for future use and must not be used by drivers or modules.) These four function pointer
fields in the @code{qinit} structure are: @var{qi_putp}, @var{qi_srvp}, @var{qi_qopen}, and
@var{qi_close}.

The utility functions that can be called by @dfn{STREAMS} drivers and modules are listed
(@pxref{STREAMS Utilities}).  They must follow the call and return syntaxes specified in the
appendix.

@node Design Guidelines
@section STREAMS Design Guidelines
@cindex design guidelines
@menu
* Module and Driver Rules::
* Data Structures::
* Header Files::
* Accessible Symbols and Functions::
@end menu

This section summarizes guidelines common to the design of @dfn{STREAMS} modules and drivers.
Additional rules pertaining to modules and drivers can be found in @ref{Modules}, for modules and
@ref{Drivers}, for drivers.

@node Module and Driver Rules
@subsection Module and Driver Rules
@menu
* Rules for Open and Close Routines::
* Rules for Input Output Controls::
* Rules for Put and Service Procedures::
@end menu

@enumerate

@item Modules and drivers cannot access information in
@c the @code{u_area}
the @code{current} @code{task_struct} structure
of a process.  Modules and drivers are not associated with any process, and therefore have no
concept of process or user context, except during @command{open} and @command{close} routines
(@pxref{Rules for Open and Close Routines}).

@item Every module and driver must process an @msg{M_FLUSH} message according to the value of the
argument passed in the message.

@item A module or a driver should not change the contents of a data block whose reference count is
greater than 1 (see @manpage{dupmsg(9)}) because other modules/drivers that have references to the
block may not want the data changed.  To avoid problems, data should be copied to a new block and
then changed in the new one.

@item Modules and drivers should manipulate queues and manage buffers only with the routines
provided for that purpose, (@pxref{STREAMS Utilities}).

@item Modules and drivers should not require the data in an @msg{M_DATA} message to follow a
particular format, such as a specific alignment.

@item Care must be taken when modules are mixed and matched, because one module may place different
semantics on the priority bands than another module.  The specific use of each band by a module
should be included in the service interface specification.  When designing modules and drivers that
make use of priority bands one should keep in mind that priority bands merely provide a way to
impose an ordering of messages on a queue.  The priority band is not used to determine the service
primitive.  Instead, the service interface should rely on the data contained in the message to
determine the service primitive.

@end enumerate

@node Rules for Open and Close Routines
@subsubsection Rules for Open and Close Routines

@enumerate

@item  @command{open} and @command{close} routines may sleep, but the sleep must return to the
routine in the event of a signal.  That is, if they sleep, they must be at @samp{priority <= PZERO},
or with @samp{PCATCH} set in the sleep priority.

@item  The @command{open} routine should return zero on success or an error number on failure.  If
the @command{open} routine is called with the @constant{CLONEOPEN} flag, the device number should be set
by the driver to an unused device number accessible to that driver.  This should be an entire device
number (major/minor).

@item  @command{open} and @command{close} routines have user context and can access
@c the @code{u_area}.
the @code{current} @code{task_struct} structure.
Only the following fields can be accessed in the
@code{u_area} (@header{user.h}): @var{u_procp}, @var{u_ttyp}, @var{u_uid}, @var{u_gid}, @var{u_ruid}, and @var{u_rgid}.
The fields @var{u_uid}, @var{u_gid}, @var{u_ruid}, and @var{u_rgid} are for backward compatibility
with previously designed device drivers.  The actual user credentials are passed directly to the
driver and need not be accessed in
@c the @code{u_area}.
the @code{current} @code{task_struct} structure.
These fields may not support valid @dfn{uids} or @dfn{gids} when the system is configured with large
user ids.  See note.

@item  Only the following fields can be accessed in the process table (@header{proc.h}): @var{p_pid},
@var{p_pgrp}.  See note.

@item  If a module or a driver wants to allocate a controlling terminal, it should send an
@msg{M_SETOPTS} message to the @dfn{Stream} head with the @stropt{SO_ISTTY} flag set.  Otherwise
signalling will not work on the @dfn{Stream}.

@end enumerate

The @dfn{DKI} interface provides the @manpage{drv_getparm(9)} and @manpage{drv_setparm(9)} functions
to read/write these data and the driver/module need not access them directly.

@node Rules for Input Output Controls
@subsubsection Rules for Input Output Controls

@itemize @bullet

@item Do not change the @var{ioc_id}, @var{ioc_uid}, @var{ioc_gid}, or @var{ioc_cmd} fields in an
@msg{M_IOCTL} message.

@item The above rule also applies to fields in an @msg{M_IOCDATA}, @msg{M_COPYIN}, and
@msg{M_COPYOUT} message.  (Field names are different; @pxref{STREAMS Data Structures})

@item Always validate @var{ioc_count} to see whether the @command{ioctl} is the @dfn{transparent} or
@ioctlref{I_STR} form.

@end itemize

@node Rules for Put and Service Procedures
@subsubsection Rules for Put and Service Procedures

To ensure proper data flow between modules and drivers, the following rules should be observed in
@command{put} and @command{service} procedures:

@itemize @bullet

@item Put and @command{service} procedure must not sleep.

@item Return codes can be sent with @dfn{STREAMS} messages @msg{M_IOCACK}, @msg{M_IOCNAK}, and
@msg{M_ERROR}.

@item Protect data structures common to @command{put} and @command{service} procedures by using
@manpage{splstr(9)}.

@item Put and @command{service} procedures cannot access the information in
@c the @code{u_area}
the @code{current} @code{task_struct} structure
of a process.

@item Processing @msg{M_DATA} messages by both @command{put} and @command{service} procedures could
lead to messages going out of sequence.  The @command{put} procedure should check if any messages
were queued before processing the current message.

@end itemize

On the read-side, it is usually a good idea to have the @command{put} procedure check if the
@command{service} procedure is running because of the possibility of a race condition.  That is, if
there are unprotected sections in the @command{service} procedure, the @command{put} procedure can
be called and run to completion while the @command{service} procedure is running (the @command{put}
procedure can interrupt the @command{service} procedure on the read-side).  For example, the
@command{service} procedure is running and it removes the last message from the queue, but before it
puts the message upstream the @command{put} procedure is called (e.g., from an interrupt routine) at
an unprotected section in the @command{service} procedure.  The @command{put} procedure sees that
the queue is empty and processes the message.  The @command{put} procedure then returns and the
@command{service} procedure resumes; but at this point data are out of order because the
@command{put} procedure sent upstream the message that was received after the data the
@command{service} procedure was processing.

@subsubheading Put Procedures

@enumerate

@item  Each queue must define a @command{put} procedure in its @code{qinit} structure for passing
messages between modules.

@item  A @command{put} procedure must use the @manpage{putq(9)} (@pxref{STREAMS Utilities}) utility
to enqueue a message on its own queue.  This is necessary to ensure that the various fields of the
queue structure are maintained consistently.

@item  When passing messages to a neighbouring module, a module may not call @manpage{putq(9)}
directly, but must call its neighbour module's @command{put} procedure (see @manpage{putnext(9)}).
However, the @var{q_qinfo} structure that points to a module's @command{put} procedure may point to
@manpage{putq(9)} (i.e., @manpage{putq(9)} is used as the @command{put} procedure for that module).
When a module calls a neighbour module's @command{put} procedure that is defined in this manner, it
will be calling @manpage{putq(9)} indirectly.  If any module uses @manpage{putq(9)} as its
@command{put} procedure in this manner, the module must define a @command{service} procedure.
Otherwise, no messages will ever be processed by the next module.  Also, because @manpage{putq(9)}
does not process @msg{M_FLUSH} messages, any module that uses @manpage{putq(9)} as its @command{put}
procedure must define a @command{service} procedure to process @msg{M_FLUSH} messages.

@item  The @command{put} procedure of a queue with no @command{service} procedure must call the
@command{put} procedure of the next queue using @manpage{putnext(9)}, if a message is to be passed
to that queue.

@item  Processing many function calls with the @command{put} procedure could lead to interrupt stack
overflow.  In that case, switch to @command{service} procedure processing whenever appropriate to
switch to a different stack.

@end enumerate

@subsubheading Service Procedures

@enumerate
@item  If flow control is desired, a @command{service} procedure is required.  The
@manpage{canput(9)} or @manpage{bcanput(9)} routines should be used by @command{service} procedures
before doing @manpage{putnext(9)} to honour flow control.
@item  The @command{service} procedure must use @manpage{getq(9)} to remove a message from its
message queue, so that the flow control mechanism is maintained.
@item  The @command{service} procedure should process all messages on its queue.  The only exception
is if the @dfn{Stream head} is blocked (i.e., @manpage{canput(9)} fails) or some other failure like
buffer allocation failure.  Adherence to this rule is the only guarantee that @dfn{STREAMS} will
enable (schedule for execution) the @command{service} procedure when necessary, and that the flow
control mechanism will not fail.  If a @command{service} procedure exits for other reasons, it must
take explicit steps to assure it will be re-enabled.
@item  The @command{service} procedure should not @command{put} a high priority message back on the
queue, because of the possibility of getting into an infinite loop.
@item  The @command{service} procedure must follow the steps below for each message that it processes.
@dfn{STREAMS} flow control relies on strict adherence to these steps.
@end enumerate

@table @asis
@item Step 1:
Remove the next message from the queue using @manpage{getq(9)}.  It is possible that the
@command{service} procedure could be called when no messages exist on the queue, so the
@command{service} procedure should never assume that there is a message on its queue.  If there is
no message, return.
@item Step 2:
If all of the following conditions are met: @manpage{canput(9)} or @manpage{bcanput(9)} fails and
the message type is not a high priority type and the message is to be @command{put} on the next
queue, continue at Step 3.  Otherwise, continue at Step 4.
@item Step 3:
The message must be replaced on the head of the queue from which it was removed using
@manpage{putbq(9)} (@pxref{STREAMS Utilities}).  Following this, the @command{service} procedure is
exited.  The @command{service} procedure should not be re-enabled at this point.  It will be
automatically back-enabled by flow control.
@item Step 4:
If all of the conditions of Step 2 are not met, the message should not be returned to the queue.  It
should be processed as necessary.  Then, return to Step 1.
@end table

@node Data Structures
@subsection Data Structures

Only the contents of q_ptr, q_minpsz, q_maxpsz, q_hiwat, and q_lowat in the queue structure may be
altered.  q_minpsz, q_maxpsz, q_hiwat, and q_lowat are set when the module or driver is opened, but
they may be modified subsequently.

Drivers and modules are allowed to change the qb_hiwat and qb_lowat fields of the qband structure.
They may only read the qb_count, qb_first, qb_last, and qb_flag fields.

The routines @manpage{strqget(9)} and @manpage{strqset(9)} can be used to get and set the fields
associated with the queue.  They insulate modules and drivers from changes in the queue structure
and also enforce the previous rules.

@subsubsection Dynamic Allocation of Data Structures

Prior to @cite{UNIX System V Release 4.0}, @dfn{STREAMS} data structures were statically configured
to support a fixed number of @dfn{Streams}, read and write queues, message and data blocks, link
block data structures, and @dfn{Stream} event cells.  The only way to change this configuration was
to reconfigure and reboot the system.  Resources were also wasted because data structures were
allocated but not necessarily needed.

With @cite{Release 4.0} the @dfn{STREAMS} mechanism has been enhanced to dynamically allocate the
following @dfn{STREAMS} data structures: @code{stdata}, @code{queue}, @code{linkblk},
@code{strevent}, @code{datab}, and @code{msgb}.  @dfn{STREAMS} allocates memory to cover these
structures as needed.

Dynamic data structure allocation has the advantage of the kernel being initially smaller than a
system with static configuration.  The performance of the system may also improve because of better
memory utilization and added flexibility.  However, @manpage{allocb(9)}, @manpage{bufcall(9)}, and
@manpage{freeb(9)}, the routines that manage these data structures, may be slower at times because
of extra overhead needed for dynamic allocation.

@node Header Files
@subsection Header Files

The following header files are generally required in modules and drivers:

@table @header

@item types.h
contains type definitions used in the @dfn{STREAMS} header files

@item stream.h
contains required structure and constant definitions

@item stropts.h
primarily for users, but contains definitions of the arguments to the @msg{M_FLUSH} message type
also required by modules

@item ddi.h
contains definitions and declarations needed by drivers to use functions for the @cite{UNIX System
V} @dfn{Device Driver Interface} or @dfn{Driver-Kernel Interface}.  This header file should be the
last header file included in the driver source code (after all statements).

@end table

One or more of the header files described next may also be included.  No standard @b{Linux} system
header files should be included except as described in the following section.  The intent is to
prevent attempts to access data that cannot or should not be accessed.

@table @header

@item errno.h
defines various system error conditions, and is needed if errors are to be returned upstream to the
user

@item sysmacros.h
contains miscellaneous system macro definitions

@item param.h
defines various system parameters, particularly the value of the @constant{PCATCH} sleep flag

@item signal.h
defines the system signal values, and should be used if signals are to be processed or sent upstream

@item file.h
defines the file open flags, and is needed if @constant{O_NDELAY} (or @constant{O_NONBLOCK}) is interpreted

@end table

@node Accessible Symbols and Functions
@subsection Accessible Symbols and Functions


The following lists the only symbols and functions that modules or drivers may refer to (in addition
to those defined by @dfn{STREAMS}; see Appendices A and C), if hardware and system release
independence is to be maintained.  Use of symbols not listed here is unsupported.

@table @header

@item user.h
(from open/close procedures only)

@vtable @var
@item u_procp
process structure pointer
@item u_ttyp
@dfn{tty} group ID pointer
@end vtable

@item proc.h
(from open/close procedures only)

@vtable @var
@item p_pid
process ID
@item p_pgrp
process group ID
@end vtable

@item (none)
functions accessible from open/close procedures only

@vtable @command
@item sleep(chan, pri)
sleep until wakeup
@item delay(ticks)
delay for a specified time
@end vtable

@item (none)
universally accessible functions

@vtable @command
@item bcopy(from, to, nbytes)
copy data quickly
@item bzero(buffer, nbytes)
zero data quickly
@item max(a, b)
return max of args
@item min(a, b)
return min of args
@item rmalloc(mp, size)
allocate memory space
@item rmfree(mp, size, i)
de-allocate memory space
@item rminit(mp, mapsize)
initialize map structure
@item vtop(vaddr, NULL)
translate from virtual to physical address
@item cmn_err(level,...)
print message and optional panic
@item spln()
set priority level
@item splstr()
set processor level for Streams
@item timeout(func, arg, ticks)
schedule event
@item untimeout(id)
cancel event
@item wakeup(chan)
wake up sleeper
@end vtable

@item sysmacros.h
The first four functions are used to get the major/minor part of the expanded device number.

@vtable @command
@item getemajor(x)
return external major part
@item getmajor(x)
return internal major part
@item geteminor(x)
return external minor part
@item getminor(x)
return internal minor part
@item makedev(x, y)
create a old device number
@item makedevice(x, y)
create a new device number
@item cmpdev(x)
convert to old device format
@item expdev(x)
convert to new device format
@end vtable

@item systm.h
system file

@vtable @var
@item lbolt
clock ticks since boot in HZ
@item time
seconds since epoch
@end vtable

@item param.h
parameter file

@vtable @constant
@item PZERO
zero sleep priority
@item PCATCH
catch signal sleep flag
@item HZ
clock ticks per second
@item NULL
0
@end vtable

@item types.h
Everything in @header{types.h} can be used.

@end table

@node STREAMS Modules
@chapter STREAMS Modules
@cindex STREAMS modules
@menu
* Module::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines
@end menu

@node Module
@section Modules

A @dfn{STREAMS} module is a pair of queues and a defined set of kernel-level routines and data
structures used to process data, status, and control information.  A @dfn{Stream} may have zero or
more modules.  User processes push (insert) modules on a @dfn{Stream} using the @ioctlref{I_PUSH}
@command{ioctl} and pop (remove) them using the @ioctlref{I_POP} @command{ioctl}.  Pushing and popping of
modules happens in a @dfn{LIFO (Last-In-First-Out)} fashion.  Modules manipulate messages as they
flow through the @dfn{Stream}.

@subsection Module Routines

@dfn{STREAMS} module routines (@command{open}, @command{close}, @command{put}, @command{service})
have already been described in the previous chapters.  This section shows some examples and further
describes attributes common to module @command{put} and @command{service} routines.

A module's @command{put} routine is called by the preceding module, driver, or @dfn{Stream head} and
before the corresponding @command{service} routine.  The @command{put} routine should do any
processing that needs to be done immediately (for example, processing of high priority messages).
Any processing that can be deferred should be left for the corresponding @command{service} routine.

The @command{service} routine is used to implement flow control, handle de-packetization of
messages, perform deferred processing, and handle resource allocation.  Once the @command{service}
routine is enabled, it always runs before any user level code.  The @command{put} and
@command{service} routines must not call @manpage{sleep(9)} and cannot access
@c the @code{u_area} area,
the @code{current} @code{task_struct} structure,
because they are executed asynchronously with respect to any process.

The following example shows a @dfn{STREAMS} module read-side @command{put} routine:

@smallexample
modrput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    struct mod_prv *modptr;

    modptr = (struct mod_prv *) q->q_ptr;       /* for state
                                                   information */
    if (mp->b_datap->db_type >= QPCTL) @{        /* process priority
                                                   message */
        putnext(q, mp);         /* and pass it on */
        return;
    @}
    switch (mp->b_datap->db_type) @{
        case M_DATA;            /* may process message data */
        putq(q, mp);            /* queue message for service routine */
        return;
        case M_PROTO;           /* handle protocol control message */
    ...default:
        putnext(q, mp);
        return;
    @}
@}
@end smallexample

The following briefly describes the code:

@itemize @bullet

@item A pointer to a queue defining an instance of the module and a pointer to a message are passed
to the @command{put} routine.

@item The @command{put} routine switches on the type of the message.  For each message type, the
@command{put} routine either enqueues the message for further processing by the module
@command{service} routine, or passes the message to the next module in the @dfn{Stream}.

@item High priority messages are processed immediately by the @command{put} routine and passed to
the next module.

@item Ordinary (or normal) messages are either enqueued or passed along the @dfn{Stream}.

@end itemize

This example shows a module write-side @command{put} routine:

@smallexample
modwput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    struct mod_prv *modptr;

    modptr = (struct mod_prv *) q->q_ptr;       /* for state
                                                   information */
    if (mp->b_datap->db_type >= QPCTL) @{        /* process priority
                                                   message */
        putnext(q, mp);         /* and pass it on */
        return;
    @}
    switch (mp->b_datap->db_type) @{
    case M_DATA:                /* may process message data */
        putq(q, mp);            /* queue message for service routine */
        /* or pass message along */
        /* putnext(q, mp); */
        return;
    case M_PROTO:
    .
    .
    .
    case M_IOCTL:               /* if command in message is
                                   recognized */
        /* process message and send back reply */
        /* else pass message downstream */
    default:
        putnext(q, mp);
        return;
    @}
@}
@end smallexample

The write-side @command{put} routine, unlike the read-side, may be passed @msg{M_IOCTL} messages.
It is up to the module to recognize and process the @command{ioctl} command, or pass the message
downstream if it does not recognize the command.

The following example shows a general scenario employed by the module's @command{service} routine:

@smallexample
modrsrv(q)
        queue_t *q;
@{
    mblk_t *mp;

    while ((mp = getq(q)) != (mblk_t *) NULL) @{
        if (!(mp->b_datap->db_type >= QPCTL) && !canput(q->q_next)) @{
            /* flow control check */
            putbq(q, mp);       /* return message */
            return;
        @}
        /* process the message */
        switch (mp->b_datap->db_type) @{
            .
            .
            .
            putnext(q, mp);     /* pass the result */
        @}
    @}                           /* while */
@}
@end smallexample

The steps are:

@itemize @bullet

@item Retrieve the first message from the queue using @manpage{getq(9)}.  If the message is high
priority, process

@item it immediately, and pass it along the @dfn{Stream}.

@item Otherwise, the @command{service} routine should use the @manpage{canput(9)} utility to
determine if the next module or driver that enqueues messages is within acceptable flow control
limits.  The @manpage{canput(9)} routine goes down (or up on the read-side) the @dfn{Stream} until
it reaches a module with a @command{service} routine, a driver, or the @dfn{Stream head}.  When it
reaches one, it looks at the total message space currently allocated at that queue for enqueued
messages.  If the amount of space currently used at that queue exceeds the high water mark, the
@manpage{canput(9)} routine sets the @constant{QWANTW} flag@footnote{Setting the @constant{QWANTW} flag on the
queue is an indication to the @manpage{getq(9)} utility that the queue needs to be back-enabled when
the count falls to the low water mark.} for the queue and returns @samp{false} (zero).  If the next
queue with a @command{service} routine is within acceptable flow control limits, @manpage{canput(9)}
simply returns @samp{true} (nonzero).

@item If @manpage{canput(9)} returns @samp{false}, the @command{service} routine should return the
message to its own queue using the @manpage{putbq(9)} routine.  The @command{service} routine can do
no further processing at this time, and it should return.

@item If @manpage{canput(9)} returns @samp{true}, the @command{service} routine should complete any
processing of the message.  This may involve retrieving more messages from the queue,
(de)-allocating header and trailer information, and performing control function for the module.

@item When the @command{service} routine is finished processing the message, it may call the
@manpage{putnext(9)} routine to pass the resulting message to the next queue.

@item Above steps are repeated until there are no messages left on the queue (that is,
@manpage{getq(9)} returns @samp{NULL}) or @manpage{canput(9)} returns @samp{false}.

@end itemize

@subsection Filter Module Example

The module shown next, @code{crmod}, is an asymmetric filter.  On the write-side, @dfn{newline} is
converted to @dfn{carriage return} followed by @dfn{newline}.  On the read-side, no conversion is
done.  The declarations of this module are essentially the same as those of the null module
presented in the previous chapter:

@smallexample
/* Simple filter - converts newline -> carriage return, newline */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>
#include <sys/stropts.h>

static struct module_info minfo =
    @{ 0x09, "crmod", 0, INFPSZ, 512, 128 @};

static int modopen(), modrput(), modwput(), modwsrv(), modclose();

static struct qinit rinit = @{
    modrput, NULL, modopen, modclose, NULL, &minfo, NULL
@};

static struct qinit winit = @{
    modwput, modwsrv, NULL, NULL, NULL, NULL, &minfo, NULL
@};

struct streamtab crmdinfo = @{ &rinit, &winit, NULL, NULL @};

extern int moddevflag = 0;
@end smallexample

A @file{master.d} file to configure @code{crmod} is shown in @ref{STREAMS Configuration}.  @header{sys/stropts.h}
includes definitions of flush message options common to user level, modules and drivers.  modopen
and modclose are unchanged from the null module example shown in @ref{Modules and Drivers}.  modrput
is like modput from the null module.

Note that, in contrast to the null module example, a single module_info structure is shared by the
read-side and write-side.  The module_info includes the flow control high and low water marks (512
and 128) for the write queue.  (Though the same module_info is used on the read queue side, the
read-side has no @command{service} procedure so flow control is not used.) The qinit contains the
@command{service}
procedure pointer.

The write-side @command{put} procedure, the beginning of the @command{service} procedure, and an example of flushing a
queue are shown next:

@smallexample
static int
modwput(q, mp)
        queue_t *q;
        register mblk_t *mp;
@{
    if (mp->b_datap->db_type >= QPCTL && mp->b_datap - &gt;
        db_type != M_FLUSH)
        putnext(q, mp);
    else
        putq(q, mp);            /* Put it on the queue */
@}

static int
modwsrv(q)
        queue_t *q;
@{
    mblk_t *mp;

    while ((mp = getq(q)) != NULL) @{
        switch (mp->b_datap->db_type) @{
        default:
            if (canput(q->q_next)) @{
                putnext(q, mp);
                break;
            @} else @{
                putbq(q, mp);
                return;
            @}

        case M_FLUSH:
            if (*mp->b_rptr & FLUSHW)
                flushq(q, FLUSHDATA);
            putnext(q, mp);
            break;
@end smallexample

modwput, the write @command{put} procedure, switches on the message type.  High priority messages
that are not type @msg{M_FLUSH} are putnext to avoid scheduling.  The others are queued for the
@command{service} procedure.  An @msg{M_FLUSH} message is a request to remove messages on one or both
queues.  It can be processed in the @command{put} or @command{service} procedure.

modwsrv is the write @command{service} procedure.  It takes a single argument, a pointer to the
write queue.  modwsrv processes only one high priority message, @msg{M_FLUSH}.  No other high priority
messages should reach modwsrv.

For an @msg{M_FLUSH} message, modwsrv checks the first data byte.  If @constant{FLUSHW} (defined in
@header{sys/stropts.h}) is set, the write queue is flushed by use of the @manpage{flushq(9)} utility
(see @dfn{STREAMS} Utilities).  @manpage{flushq(9)} takes two arguments, the queue pointer and a
flag.  The flag indicates what should be flushed, data messages (@constant{FLUSHDATA}) or everything
(@constant{FLUSHALL}).  In the example, data includes @msg{M_DATA}, @msg{M_DELAY}, @msg{M_PROTO},
and @msg{M_PCPROTO} messages.  The choice of what types of messages to flush is module specific.

Ordinary messages will be returned to the queue if

canput(q->q_next)

returns @samp{false}, indicating the downstream path is blocked.  The example continues with the remaining
part of modwsrv processing @msg{M_DATA} messages:

@smallexample
        case M_DATA:
        @{
            mblk_t *nbp = NULL;
            mblk_t *next;

            if (!canput(q->q_next)) @{
                putbq(q, mp);
                return;
            @}
            /* Filter data, appending to queue */
            for (; mp != NULL; mp = next) @{
                while (mp->b_rptr < mp->b_wptr) @{
                    if (*mp->b_rptr == '\n') @{
                        if (!bappend(&nbp, '\r'))
                            goto push;
                        if (!bappend(&nbp, *mp->b_rptr))
                            goto push;
                        mb->b_rptr++;
                        continue;
                    @}
                  push:
                    if (nbp)
                        putnext(q, nbp);
                    nbp = NULL;
                    if (!canput(q->q_next)) @{
                        if (mp->b_rptr >= mp->b_wptr) @{
                            next = mp->b_cont;
                            freeb(mp);
                            mp = next;
                        @}
                        if (mp)
                            putbq(q, mp);
                        return;
                    @}
                @}               /* while */
                next = mp->b_cont;
                freeb(mp);
            @}                   /* for */
            if (nbp)
                putnext(q, nbp);
        @}                       /* case M_DATA */
        @}                       /* switsh */
    @}                           /* while */
@}
@end smallexample

The differences in @msg{M_DATA} processing between this and the example in Messages (see
@ref{Message Allocation}) relate to the manner in which the new messages are forwarded and flow
controlled.  For the purpose of demonstrating alternative means of processing messages, this version
creates individual new messages rather than a single message containing multiple message blocks.
When a new message block is full, it is immediately forwarded with the @manpage{putnext(9)} routine
rather than being linked into a single, large message (as was done in the Messages example).  This
alternative may not be desirable because message boundaries will be altered and because of the
additional overhead of handling and scheduling multiple messages.

When the filter processing is performed (following push), flow control is checked (with
@manpage{canput(9)})
after, rather than before, each new message is forwarded.  This is done because there is no
provision to hold the new message until the queue becomes unblocked.  If the downstream path is
blocked, the remaining part of the original message is returned to the queue.  Otherwise, processing
continues.

@node Module Flow Control
@section Module Flow Control

To utilize the @dfn{STREAMS} flow control mechanism, modules must use @command{service} procedures,
invoke @manpage{canput(9)} before calling @manpage{putnext(9)}, and use appropriate values for the high and low water
marks.

Module flow control limits the amount of data that can be placed on a queue.  It prevents depletion
of buffers in the buffer pool.  Flow control is advisory in nature and it can be bypassed.  It is
managed by high and low water marks and regulated by @constant{QWANTW} and @constant{QFULL} flags.  Module flow control is
implemented by using the @manpage{canput(9)}, @manpage{getq(9)}, @manpage{putq(9)},
@manpage{putbq(9)}, @manpage{insq(9)}, and @manpage{rmvq(9)} routines.

The following scenario takes place normally in flow control when a module and driver are in sync:

@itemize @bullet
@item  A driver sends data to a module using the @manpage{putnext(9)} routine, and the module's
@command{put} procedure queues data using @manpage{putq(9)}.  The @manpage{putq(9)} routine then
increments the module's q_count by the number of bytes in the message and enables the
@command{service} procedure.  When @dfn{STREAMS} scheduling runs the @command{service} procedure,
the @command{service} procedure then retrieves the data by calling the @manpage{getq(9)} utility,
and @manpage{getq(9)} decrements q_count by an appropriate value.
@end itemize

If the module cannot process data at the rate at which the driver is sending the data, the following
happens:

@itemize
@item The module's q_count goes above its high water mark, and the @constant{QFULL} flag is set by
@manpage{putq(9)}.  The driver's @manpage{canput(9)} fails, and @manpage{canput(9)} sets
@constant{QWANTW} flag in the module's queue.  The driver may send a command to the device to stop
input, queue the data in its own queue, or drop the data.  In the meanwhile, the module's q_count
falls below its low water mark (by @manpage{getq(9)}) and @manpage{getq(9)} finds the nearest back
queue with a @command{service} procedure and enables it.  The scheduler then runs the
@command{service} procedure.
@end itemize

The next two examples show a line discipline module's flow control.  The first example is a
read-side line discipline module:

@smallexample
/* read- side line discipline module flow control */

id_read_srv(q)
        queue_t *q;     /* pointer to read queue */
@{
    mblk_t *mp;         /* original message */
    mblk_t *bp;         /* canonicalized message */

    while ((mp = getq(q)) != NULL) @{
        switch (mp->b_datap->db_type) @{ /* type of message */
        case M_DATA:            /* data message */
            if (canput(q->q_next)) @{
                bp = read_canon(mp);
                putnext(q, bp);
            @} else @{
                putbq(q, mp);   /* put message back in queue */
                return;
            @}
            break;
        default:
            if (mp->b_datap->db_type >= QPCTL)
                putnext(q, mp); /* high priority message */
            else @{              /* ordinary message */
                if (canput(q->q_next))
                    putnext(q, mp);
                else @{
                    putbq(q, mp);
                    return;
                @}
            @}
            break;
        @}
    @}
@}
@end smallexample

The following shows a write-side line discipline module:

@smallexample
/* write-side line discipline module flow control */

id_write_srv(q)
        queue_t *q;     /* pointer to write queue */
@{
    mblk_t *mp;         /* original message */
    mblk_t *bp;         /* canonicalized message */

    while ((mp = getq(q)) != NULL) @{
        switch (mp->b_datap->db_type) @{ /* type of message */
        case M_DATA:            /* data message */
            if (canput(q->q_next)) @{
                bp = write_canon(mp);
                putnext(q, bp);
            @} else @{
                putbq(q, mp);
                return;
            @}
            break;

        case M_IOCTL:
            ld ioctl(q, mp);
            break;

        default:
            if (mp->b_datap->db_type >= QPCTL)
                putnext(q, mp); /* high priority message */
            else @{              /* ordinary message */
                if (canput(q->q_next))
                    putnext(q, mp);
                else @{
                    putbq(q, mp);
                    return;
                @}
            @}
            break;
        @}
    @}
@}
@end smallexample

@node Module Design Guidelines
@section Module Design Guidelines

Module developers should follow these guidelines:

@itemize @bullet

@item Messages types that are not understood by the modules should be passed to the next module.

@item The module that acts on an @msg{M_IOCTL} message should send an @msg{M_IOCACK} or
@msg{M_IOCNAK} message in
response to the @command{ioctl}.  If the module does not understand the @command{ioctl}, it should
pass the @msg{M_IOCTL}
message to the next module.

@item Modules should be designed in such a way that they do not pertain to any particular driver but
can be used by all drivers.

@item In general, modules should not require the data in an @msg{M_DATA} message to follow a particular
format, such as a specific alignment.  This makes it easier to arbitrarily push modules on top of
each other in a sensible fashion.  Not following this rule may limit module reuse.

@item Filter modules pushed between a service user and a service provider may not alter the contents
of the @msg{M_PROTO} or @msg{M_PCPROTO} block in messages.  The contents of the data blocks may be manipulated,
but the message boundaries must be preserved.

@end itemize

Also see @ref{Driver Design Guidelines}.

@node STREAMS Drivers
@chapter STREAMS Drivers
@cindex STREAMS drivers
@menu
* Driver::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines
@end menu

@node Driver
@section Drivers

This chapter describes the operation of a @dfn{STREAMS} driver and also discusses some of the
processing typically required in drivers.

Unlike a module, a device driver must have an interrupt routine so that it is accessible from a
hardware interrupt as well as from the @dfn{Stream}.  A driver can have multiple @dfn{Streams}
connected to it.  Multiple connections occur when more than one minor device of the same driver is
in use and in the case of multiplexers (multiplexing is discussed in Multiplexing).  However, these
particular differences are not recognized by the @dfn{STREAMS} mechanism.  They are handled by
developer-provided code included in the driver procedures.

@subsection Overview of Drivers

This section provides a brief overview of the UNIX@registeredsymbol{} system drivers.  This is not an all-inclusive
description, but an introduction and general information on drivers.  UNIX@registeredsymbol{} system drivers.  This is
not an all-inclusive description, but an introduction and general information on drivers.

A driver is software that provides an interface between the operating system and a device.  The
driver controls the device in response to kernel commands, and user-level programs access the device
through system calls.  The system calls interface with the file system and process control system,
which in turn access the drivers.  The driver provides and manages a path for the data to and from
the hardware device, and services interrupts issued by the device controller.

@subsubsection Driver Classification

In general, drivers are grouped according to the type of the device they control, the access method
(the way data are transferred), and the interface between the driver and the device.

The type can be hardware or software.  A hardware driver controls a physical device such as a disk.
A software driver, also called a pseudo device, controls software, which in turn may interface with
a hardware device.  The software driver may also support pseudo devices that have no associated
physical device.

Drivers can be character-type or block-type, but many support both access methods.  In
character-type transfer, data are read a character at a time or as a variable length stream of
bytes, the size of which is determined by the device.  In block-type access, data transfer is
performed on fixed-length blocks of data.  Devices that support both block- and character-type
access must have a separate special device file for each access method.  Character access devices
can also use "raw" (also called unbuffered) data transfer that takes place directly between user
address space and the device.  Unbuffered data transfer is used mainly for administrative functions
where the speed of the specific operation is more important than overall system performance.

The driver interface refers to the system structures and kernel interfaces used by the driver.  For
example, @dfn{STREAMS} is an interface.

@subsubsection Driver Configuration

For a driver to be recognized as part of the system, information on driver type, where object code
resides, interrupts, and so on, must be stored in appropriate files.

The following summarizes information needed to include a driver in the system (this information is
unique to the @cite{AT&T 3B2}):

@ftable @file

@item /etc/master.d
A master file supplies information to the system initialization software to describe different
attributes of a driver.  There is one master file for each driver in the system.

@item /dev
This directory contains special files that provide applications with a way to access drivers via
file operators.

@end ftable

@subsubsection Writing a Driver

All drivers are identified by a string of called the prefix.  The prefix is defined in the master
file for the driver and is added to the name of the driver routines.  For example, the open routine
for the driver with the "xyz" prefix is xyzopen.

Writing a driver differs from writing other C programs in the following ways:

@itemize @bullet

@item  A driver does not have a main.c routine.Rather, driver entry points are given specific names
and accessed through switch tables.

@item  A driver functions as a part of the kernel.  Consequently, a poorly written driver can
degrade system performance or corrupt the system.

@item  A driver cannot use system calls or the C library, because the driver functions at a lower
level.

@item  A driver cannot use floating point arithmetic.  A driver cannot use archives or shared
libraries,

@item  but frequently used subroutines can be put in separate files in the source code directory for
the driver.

@end itemize

Driver code, like other system software, uses the advanced C language capabilities.  These include:
bit manipulation capabilities, casting of data types, and use of header files for defining and
declaring global data structures.

Driver code includes a set of entry point routines:

@itemize @bullet

@item initialization entry points that are accessed through arrays during system initialization.

@item switch table entry points that are accessed through bdevsw (block- access) and @code{cdevsw}
(character-access) switch tables when the appropriate system call is issued.

@end itemize

The following lists rules of driver development:

@itemize @bullet

@item All drivers must have an associated file in the @file{master.d} directory.

@item All drivers should have system header files that define data structures used in the driver.

@item Drivers may have an init and/or astart routine to initialize the driver.  Software drivers
will usually have little to initialize, because there is no hardware involved.  An init routine is
used when a driver needs to initialize but does not need any system services.  init routines are run
before system services are initialized.  When a driver needs to do initialization that requires
system services, a start routine is used.  The start routines are run after system services have
been initialized.

@item Drivers will have open and close routines.  Most drivers will have an interrupt handler
routine.  The driver developer is responsible for supplying an interrupt routine for the device's
driver.  The @b{Linux} system provides a few interrupt handling routines for hardware interrupts, but the
developer has to supply the specifics about the device.  In general, a prefixint interrupt routine
should be written for any device that does not send separate transmit and receive interrupts.
@dfn{TTY}
devices that request separate transmit and receive interrupts can have two separate interrupt
routines associated with them; prefixxinit to transmit an interrupt, and prefixrint to receive an
interrupt.

@item Most drivers will have static subordinate driver routines to provide the functionality for the
specific device.  The names of these routines should include the driver prefix, although this is not
absolutely required since the routine is declared as static.

@item A bootable object file and special device files are also needed for a driver to be fully
functional.

@end itemize

@subsubsection Major and Minor Device Numbers

The @cite{UNIX System V} operating system identifies and accesses peripheral devices by major and
minor numbers.  When a driver is installed and a special device file is created, a device then
appears to the user application as a file.  A device is accessed by opening, reading, writing, and
closing a special device file that has the proper major and minor device numbers.

The major number identifies a driver for a controller.  The minor number identifies a specific
device.  Major numbers are assigned sequentially by either the system initialization software at
boot time for hardware devices, by a program such as drvinstall, or by administrator direction.  The
major number for a software device is assigned automatically by the drvinstall command.  Minor
numbers are designated by the driver developer.

Major and minor numbers can be external or internal.

External major numbers are those visible to the user.

Internal major numbers serve as an index into the @code{cdevsw} and bdevsw switch tables.  These are
assigned by the autoconfiguration process when drivers are loaded and they may change every time a
full configuration boot is done.  The system uses the @dfn{MAJOR} table to translate external major
numbers to the internal major numbers needed to access the switch tables.

One driver may control several devices, but each device will have its own external major number and
all those external major numbers are mapped to one internal major number for the driver.

Minor numbers are determined differently for different types of devices.  Typically, minor numbers
are an encoding of information needed by the controller board.

External minor numbers are controlled by a driver developer, although there are conventions enforced
for some types of devices by some utilities.  For example, a tape drive may interface with a
hardware controller (device) to which several tape drives (subdevices) are attached.  All tape
drives attached to one controller will have the same external major number, but each drive will have
a different external minor number.

The @dfn{MAJOR} and @dfn{MINOR} tables map external major and minor numbers to the internal major number.  The
switch tables will have only as many entries as required to support the drivers installed on the
system.  Switch table entry points are activated by system calls that reference a special device
file that supplies the external major number and instructions on whether to use bdevsw or @code{cdevsw}.
By mapping the external major number to the corresponding internal major number in the @dfn{MAJOR}
table, the system knows which driver routine to activate.  The routines @manpage{getmajor(9)} and
@manpage{getminor(9)} return an internal major and minor number for the device.  The routines
@manpage{getemajor(9)} and @manpage{geteminor(9)} return an external major and minor number for the
device.

@subsection Drivers

At the interface to hardware devices, character I/O drivers have interrupt entry points; at the
system interface, those same drivers generally have direct entry points (routines) to process open,
close, read, write, poll, and @command{ioctl} system calls.

@dfn{STREAMS} device drivers have interrupt entry points at the hardware device interface and have
direct entry points only for the open and close system calls.  These entry points are accessed via
@dfn{STREAMS}, and the call formats differ from traditional character device drivers.
(@dfn{STREAMS} drivers are character drivers, too.  We call the non-@dfn{STREAMS} character drivers
traditional character drivers or non-@dfn{STREAMS} character drivers.) The @command{put} procedure
is a driver's third entry point, but it is a message (not system) interface.  The @dfn{Stream head}
translates write and @command{ioctl} calls into messages and sends them downstream to be processed
by the driver's write queue @command{put} procedure.  read is seen directly only by the @dfn{Stream
head}, which contains the functions required to process system calls.  A driver does not know about
system interfaces other than open and close, but it can detect the absence of a read indirectly if
flow control propagates from the @dfn{Stream head} to the driver and affects the driver's ability to
send messages upstream.

For input processing, when the driver is ready to send data or other information to a user process,
it does not wake up the process.  It prepares a message and sends it to the read queue of the
appropriate (minor device) @dfn{Stream}.  The driver's open routine generally stores the queue
address corresponding to this @dfn{Stream}.

For output processing, the driver receives messages in place of a write call.  If the message can
not be sent immediately to the hardware, it may be stored on the driver's write message queue.
Subsequent output interrupts can remove messages from this queue.

@figref{28} shows multiple @dfn{Streams} (corresponding to minor devices) to a common driver.  There
are two distinct @dfn{Streams} opened from the same major device.  Consequently, they have the same
@type{streamtab} and the same driver procedures.

The configuration mechanism distinguishes between @dfn{STREAMS} devices and traditional character
devices, because system calls to @dfn{STREAMS} drivers are processed by @dfn{STREAMS} routines, not
by the @b{Linux} system driver routines.  In the @code{cdevsw} file, the field @var{d_str} provides this
distinction.  See @ref{STREAMS Configuration}, for details.

Multiple instantiations (minor devices) of the same driver are handled during the initial open for
each device.  Typically, the queue address is stored in a driver-private structure array indexed by
the minor device number.  This is for use by the interrupt routine which needs to translate from
device number to a particular @dfn{Stream}.  The q_ptr of the queue will point to the private data
structure entry.  When the messages are received by the queue, the calls to the driver @command{put} and
@command{service} procedures pass the address of the queue, allowing the procedures to determine the
associated device.

A driver is at the end of a @dfn{Stream}.  As a result, drivers must include standard processing for
certain message types that a module might simply be able to pass to the next component.

During the open and close routine the kernel locks the device snode.  Thus only one open or close
can be active at a time per major/minor device pair.

@figuresized{SPG_fig28,28,Device Driver Streams,4in}

@subsubsection Printer Driver Example

The next example shows how a simple interrupt-per-character line printer driver could be written.
The driver is unidirectional and has no read-side processing.  It demonstrates some differences
between module and driver programming, including the following:

@table @asis

@item Open handling
A driver is passed a device number or is asked to select one.

@item Flush handling
A driver must loop @msg{M_FLUSH} messages back upstream.

@item @command{ioctl} handling
A driver must send a negative acknowledgement for @command{ioctl} messages it does not understand.
This is discussed under @ref{Input-Output Control}.

@end table

@subsubheading Declarations

The driver declarations are as follows (see also @ref{Module and Driver Declarations}):

@smallexample
/* Simple line printer driver */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/dir.h>            /* required for user.h */
#include <sys/signal.h>         /* required for user.h */
#include <sys/user.h>
#include <sys/errno.h>
#include <sys/cred.h>
#include <sys/ddi.h>

static struct module_info minfo = @{
    0xaabb, "lp", 0, INFPSZ, 150, 50
@};

static int lpopen(), lpclose(), lpwput();

static struct qinit rinit = @{
    NULL, NULL, lpopen, lpclose, NULL, &minfo, NULL
@};

static struct qinit winit = @{
    lpwput, NULL, NULL, NULL, NULL, &minfo, NULL
@};

struct streamtab lpinfo = @{ &rinit, &winit, NULL, NULL @};

#define SET_OPTIONS (('1'<<8)|1)        /* should be in a .  h file */

/* This is a private data structure, one per minor device number.  */

struct lp @{
    short flags;        /* flags -- see below */
    mblk_t *msg;        /* current message being output */
    queue_t *qptr;      /* back pointer to write queue */
@};

/* Flags bits */
#define BUSY 1                  /* device is running and interrupt is
                                   pending */

extern struct lp lp_lp[];       /* per device lp structure array */
extern int lp_cnt;      /* number of valid minor devices */
int lpdevflag = 0;
@end smallexample

Configuring a @dfn{STREAMS} driver requires only the @type{streamtab} structure to be externally accessible.  All
other @dfn{STREAMS} driver procedures would typically be declared static.

The @type{streamtab} structure must be defined as prefixinfo, where prefix is the value of the prefix field
in the master file for this driver.  The values in the module name and ID fields in the module_info
structure should be unique in the system.  Note that, as in character I/O drivers, extern variables
are assigned values in the master file when configuring drivers or modules.

There is no read-side @command{put} or @command{service} procedure.  The flow control limits for use on the write-side
are 50 bytes for the low water mark and 150 bytes for the high water mark.  The private lp structure
is indexed by the minor device number and contains these elements:

@table @var

@item flags
A set of flags.  Only one bit is used: @constant{BUSY} indicates that output is active and a device interrupt
is pending.

@item msg
A pointer to the current message being output.

@item qptr
A back pointer to the write queue.  This is needed to find the write queue during interrupt
processing.

@end table

@subsubheading Driver Open

The @dfn{STREAMS} mechanism allows only one @dfn{Stream} per minor device.  The driver open routine
is called whenever a @dfn{STREAMS} device is opened.  Opening also allocates a private data
structure.  The driver open, lpopen in this example, has the same interface as the module open:

@smallexample
static int
lpopen(q, devp, flag, sflag, credp)
        queue_t *q;     /* read queue */
        dev_t *devp;
        int flag;
        int sflag;
        cred_t *credp;
@{
    struct lp *lp;
    dev_t device;

    if (sflag)                  /* check if non-driver open */
        return ENXIO;

    device = getminor(*devp);
    if (device >= lp_cnt)
        return ENXIO;

    if (q->q_ptr)               /* Check if open already.  q_ptr is
                                   assigned below */
        return EBUSY;

    lp = &lp_lp[device];
    lp->qptr = WR(q);
    q->q_ptr = (char *) lp;
    WR(q)->q_ptr = (char *) lp;
    return 0;
@}
@end smallexample

The @dfn{Stream} flag, sflag, must have the value 0, indicating a normal driver open.  devp is a
pointer to the major/minor device number for this port.  After checking sflag, the @dfn{STREAMS}
open flag, lpopen extracts the minor device pointed to by devp, using the @manpage{getminor(9)} function.
credp is a pointer to a credentials structure.

The minor device number selects a printer.  The device number pointed to by devp must be less than
lp_cnt, the number of configured printers.  Otherwise failure occurs.

The next check, if (q->q_ptr)..., determines if this printer is already open.  If it is,
@errno{EBUSY} is
returned to avoid merging printouts from multiple users.  q_ptr is a driver/module private data
pointer.  It can be used by the driver for any purpose and is initialized to zero by @dfn{STREAMS}.
In this example, the driver sets the value of q_ptr, in both the read and write queue structures, to
point to a private data structure for the minor device, lp_lp[device].

There are no physical pointers between queues.  WR is a queue pointer macro.  WR(q) generates the
write pointer from the read pointer.  @manpage{RD(9)} and @manpage{OTHER(9)} are also the queue pointer macros.  RD(q)
generates the read pointer from the write pointer, and @manpage{OTHER(9)} generates the mate pointer from
either.  With the @dfn{DDI}, @manpage{WR(9)}, @manpage{RD(9)}, and @manpage{OTHER(9)} are functions.

@subsubheading Driver Flush Handling

The following write @command{put} procedure, lpwput, illustrates driver @msg{M_FLUSH} handling.  NOTE that
all drivers are expected to incorporate flush handling.

If @constant{FLUSHW} is set, the write message queue is flushed, and (in this example) the leading message
(lp->msg) is also flushed.  spl5 is used to protect the critical code, assuming the device
interrupts at level 5.

Normally, if @constant{FLUSHR} is set, the read queue would be flushed.  However, in this example, no messages
are ever placed on the read queue, so it is not necessary to flush it.  The @constant{FLUSHW} bit is cleared
and the message is sent upstream using @manpage{qreply(9)}.  If @constant{FLUSHR} is not set, the
message is discarded.

The @dfn{Stream head} always performs the following actions on flush requests received on the
read-side from downstream.  If @constant{FLUSHR} is set, messages waiting to be sent to user space are flushed.
If @constant{FLUSHW} is set, the @dfn{Stream head} clears the @constant{FLUSHR} bit and sends the @msg{M_FLUSH} message
downstream.  In this manner, a single @msg{M_FLUSH} message sent from the driver can reach all queues in a
@dfn{Stream}.  A module must send two @msg{M_FLUSH} messages to have the same affect.

lpwput enqueues @msg{M_DATA} and @msg{M_IOCTL} messages and, if the device is not busy, starts output by calling
lpout.  Messages types that are not recognized are discarded.


@smallexample
static int
lpwput(q, mp)
        queue_t *q;     /* write queue */
        register mblk_t *mp;    /* message pointer */
@{
    register struct lp *lp;
    int s;

    lp = (struct lp *) q->q_ptr;
    switch (mp->b_datap->db_type) @{

    default:
        freemsg(mp);
        break;

    case M_FLUSH:               /* Canonical flush handing */
        if (*mp->b_rptr & FLUSHW) @{
            flushq(q, FLUSHDATA);
            s = sp15();         /* also flush lp->msg since it is
                                   logically * at the head of the
                                   write queue */
            if (lp->msg) @{
                freemsg(lp->msg);
                lp->msg = NULL;
            @}
            splx(s);
        @}
        if (*mp->b_rptr & FLUSHR) @{
            *mp->b_rptr &= ~FLUSHW;
            qreply(q, mp);
        @} else
            freemsg(mp);
        break;

    case M_IOCTL:

    case M_DATA:
        putq(q, mp);
        s = sp15();
        if (!(lp->flags & BUSY))
            lpout(lp);
        splx(s);
    @}
@}
@end smallexample

@subsubheading Driver Interrupt

The following example shows the interrupt routine in the printer driver.

lpint is the driver interrupt handler routine.

lpout simply takes a character from the queue and sends it to the printer.  For convenience, the
message currently being output is stored in lp->msg.

lpoutchar sends a character to the printer and interrupts when complete.  Printer interface options
need to be set before being able to print.

@smallexample
/* Device interrupt routine */

lpint(device)
        int device;     /* minor device nimber of lp */
@{
    register struct lp *lp;

    lp = &lp_lp[device];
    if (!(lp->flags & BUSY)) @{
        cmn_err(CE_WARN, "^lp: unexpected interrupt\n");
        return;
    @}
    lp->flag &= ~BUSY;
    lpout(lp);
@}

/* Start output to device - used by put procedure and driver */
lpout(lp)
        register struct lp *lp;
@{
    register mblk_t *bp;
    queue_t *q;

    q = lp->qptr;

  loop:
    if ((bp = lp->msg) == NULL) @{       /* no current message */
        if ((bp = getq(q)) == NULL) @{
            lp->flags &= NBUSY;
            return;
        @}
        if (bp->b_datap->db_type == M_IOCTL) @{
            lpdoioctl(lp, bp);
            goto loop;
        @}
        lp->msg = bp;           /* new message */

    @}
    if (bp->b_rptr >= bp->b_wptr) @{     /* validate message */
        bp = lp->msg->b_cont;
        lp->msg->b_cont = NULL;
        freeb(lp->msg);
        lp->msg = bp;
        goto loop;
    @}
    lpoutchar(lp, *bp->b_rptr++);       /* output one charactor */
    lp->flags |= BUSY;
@}
@end smallexample

@subsubheading Driver Close

The driver close routine is called by the @dfn{Stream head}.  Any messages left on the queue will be
automatically removed by @dfn{STREAMS}.  The @dfn{Stream} is dismantled and the data structures are
de-allocated.

@smallexample
static int
lpclose(q, flag, credp)
        queue_t *q;     /* read queue */
        int flag;
        cred_t *credp;
@{
    struct lp *lp;
    int s;

    lp = (struct lp *) q->q_ptr;

    /* Free message, queue is automatically flushed by STREAMS */

    s = sp15();
    if (lp->msg) @{
        freemsg(lp->msg);
        lp->msg = NULL;
    @}
    splx(s);
    lp->flags = 0;
@}
@end smallexample

@subsubsection Driver Flow Control

The same utilities (described in @ref{STREAMS Modules}) and mechanisms used for module flow control
are used by drivers.

When the message is queued, @manpage{putq(9)} increments the value of @member{q_count} by the size
of the message and compares the result against the driver's write high water limit
(@member{q_hiwat}) value.  If the count exceeds @member{q_hiwat}, the @manpage{putq(9)} utility
routine will set the internal @constant{QFULL} indicator for the driver write queue.  This will
cause messages from upstream to be halted (@manpage{canput(9)} returns @constant{FALSE}) until the
write queue count reaches @member{q_lowat}.  The driver messages waiting to be output are dequeued
by the driver output interrupt routine with @manpage{getq(9)}, which decrements the count.  If the
resulting count is below @member{q_lowat}, the @manpage{getq(9)} routine will back-enable any
upstream queue that had been blocked.

Device drivers typically discard input when unable to send it to a user process.  However,
@dfn{STREAMS} allows flow control to be used on the driver read-side to handle temporary upstream
blocks.

To some extent, a driver or a module can control when its upstream transmission will become blocked.
Control is available through the @msg{M_SETOPTS} message (@pxref{Message Types}) to modify the
@dfn{Stream head} read-side flow control limits.

@node Cloning
@section Cloning

In many earlier examples, each user process connected a @dfn{Stream} to a driver by opening a
particular minor device of that driver.  Often, however, a user process wants to connect a new
@dfn{Stream} to a driver regardless of which minor device is used to access the driver.  In the
past, this typically forced the user process to poll the various minor device nodes of the driver
for an available minor device.  To alleviate this task, a facility called clone open is supported
for @dfn{STREAMS} drivers.  If a @dfn{STREAMS} driver is implemented as a cloneable device, a single
node in the file system may be opened to access any unused device that the driver controls.  This
special node guarantees that the user will be allocated a separate @dfn{Stream} to the driver on
every open call.  Each @dfn{Stream} will be associated with an unused major/minor device, so the
total number of @dfn{Streams} that may be connected to a particular cloneable driver is limited by
the number of minor devices configured for that driver.

The clone device may be useful, for example, in a networking environment where a protocol pseudo
device driver requires each user to open a separate @dfn{Stream} over which it will establish
communication.

The decision to implement a @dfn{STREAMS} driver as a cloneable device is made by the designers of
the device driver.

Knowledge of clone driver implementation is not required to use it.  A description is presented here
for completeness and to assist developers who must implement their own clone driver.

There are two ways to create a clone device node in the file system.  The first is to have a node
with major number 63 (major of the clone driver) and with a minor number equal to the major number
of the real device one wants to open.  For example, /dev/starlan00 might be major 40, minor 0
(normal open), and /dev/starlan might be major 63, minor 40 (clone open).

The second way to create a clone device node is for the driver to designate a special minor device
as its clone entry point.  Here, /dev/starlan might be major 40, minor 0 (clone open).

The former example will cause sflag to be set to @constant{CLONEOPEN} in the open routine when /dev/starlan is
opened.  The latter will not.  Instead, in the latter case the driver has decided to designate a
special minor device as its clone interface.  When the clone is opened, the driver knows that it
should look for an unused minor device.  This implies that the reserved minor for the clone entry
point will never be given out.

In either case, the driver returns the new device number as:

*devp = makedevice(getmajor(*devp), newminor)

makedevice is unique to the @dfn{DDI} interface.  If the @dfn{DDI} interface is not used, makedev can be used
instead of makedevice.

@node Loop-Around Driver
@section Loop-Around Driver

The loop-around driver is a pseudo driver that loops data from one open @dfn{Stream} to another open
@dfn{Stream}.  The user processes see the associated files almost like a full-duplex pipe.  The
@dfn{Streams} are not physically linked.  The driver is a simple multiplexer that passes messages
from one @dfn{Stream}'s write queue to the other @dfn{Stream}'s read queue.

To create a connection, a process opens two @dfn{Streams}, obtains the minor device number
associated with one of the returned file descriptors, and sends the device number in an
@ioctlref{I_STR}
@manpage{ioctl(2)} to the other @dfn{Stream}.  For each open, the driver open places the passed
queue pointer in a driver interconnection table, indexed by the device number.  When the driver
later receives the @ioctlref{I_STR} as an @msg{M_IOCTL} message, it uses the device number to locate the other
@dfn{Stream}'s interconnection table entry, and stores the appropriate queue pointers in both of the
@dfn{Streams}' interconnection table entries.

Subsequently, when messages other than @msg{M_IOCTL} or @msg{M_FLUSH} are received by the driver on either
@dfn{Stream}'s write-side, the messages are switched to the read queue following the driver on the
other @dfn{Stream}'s read-side.  The resultant logical connection is shown in @figref{29} (in the
figure, the abbreviation QP represents a queue pair).  Flow control between the two @dfn{Streams}
must be handled by special code since @dfn{STREAMS} will not automatically propagate flow control
information between two @dfn{Streams} that are not physically interconnected.

@figuresized{SPG_fig29,29,Loop-Around Streams,4in}

The next example shows the loop-around driver code.  A master file to configure the loop driver is
shown in @ref{STREAMS Configuration}.  The loop structure contains the interconnection information for a pair of
@dfn{Streams}.  loop_loop is indexed by the minor device number.  When a @dfn{Stream} is opened to
the driver, the address of the corresponding loop_loop element is placed in q_ptr (private data
structure pointer) of the read-side and write-side queues.  Since @dfn{STREAMS} clears q_ptr when
the queue is allocated, a @samp{NULL} value of q_ptr indicates an initial open.  loop_loop is used to
verify that this @dfn{Stream} is connected to another open @dfn{Stream}.

The declarations for the driver are:

@smallexample
/* Loop-around driver */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/dir.h>
#include <sys/signal.h>
#include <sys/user.h>
#include <sys/errno.h>
#include <sys/cred.h>
#include <sys/ddi.h>

static struct module_info minfo = @{
    0xee12, "loop", 0, INFPSZ, 512, 128
@};

static int loopopen(), loopclose(), loopwput(), loopwsrv(),
looprsrv();

static struct qinit rinit = @{
    NULL, looprsrv, loopopen, loopclose, NULL, &minfo, NULL
@};
static struct qinit winit = @{
    loopwput, loopwsrv, NULL, NULL, NULL, &minfo, NULL
@};

struct streamtab loopinfo = @{ &rinit, &winit, NULL, NULL @};

struct loop @{
    queue_t *qptr;      /* back pointer to write queue */
    queue_t *oqptr;     /* pointer to connected read queue */
@}
#define LOOP_SET (('1'<<8|1)    /* should be in a .  h file */
extern struct loop loop_loop[];
extern int loop_cnt;
int loopdevflag = 0;
@end smallexample

The open procedure includes canonical clone processing which enables a single file system node to
yield a new minor device/vnode each time the driver is opened:

@smallexample
static int
loopopen(q, devp, flag, sflag, credp)
        queue_t *q;
        dev_t *devp;
        int flag;
        int sflag;
        cred_t *credp;
@{
    struct loop *loop;

    dev_t newminor;

    /* 
     * If CLONEOPEN, pick a minor device number to use.
     * Otherwise, check the minor device range.
     */
    if (sflag == CLONEOPEN) @{
        for (newminor = 0; newminor < loop_cnt; newminor++) @{
            if (loop_loop[newminor].qptr == NULL)
                break;
        @}
    @} else
        newminor = getminor(*devp);

    if (newminor >= loop_cnt)
        return ENXIO;
    /* construct new device number and reset devp */

    /* getmajor gets the external major number, if (sflag ==
       CLONEOPEN) */

    if (q->q_ptr)               /* already open */
        return 0;

    *devp = makedev(getemajor(*devp), newminor);
    loop = &loop_loop[newminor];
    WR(q)->q_ptr = (char *) loop;
    q->q_ptr = (char *) loop;
    loop->qptr = WR(q);
    loop->oqptr = NULL;

    return 0;
@}
@end smallexample

In loopopen, sflag can be @constant{CLONEOPEN}, indicating that the driver should pick an unused minor device
(i.e., the user does not care which minor device is used).  In this case, the driver scans its
private loop_loop data structure to find an unused minor device number.  If sflag has not been set
to @constant{CLONEOPEN}, the passed-in minor device specified by getminor->(*devp) is used.

Since the messages are switched to the read queue following the other @dfn{Stream}'s read-side, the driver
needs a @command{put} procedure only on its write-side:

@smallexample
static int
loopwput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    register struct loop *loop;

    loop = (struct loop *) q->q_ptr;

    switch (mp->b_datap->db_type) @{
    case M_IOCTL:
    @{
        struct iocblk *iocp;
        int error;

        iocp = (struct iocblk *) mp->b_rptr;
        switch (iocp->ioc_cmd) @{
        case LOOP_SET:
        @{
            int to      /* other minor device */
                /* 
                 * Sanity check.  ioc_count contains the amount of
                 * user supplied data which must equal the size of an int.
                 */
            if (iocp->ioc_count != sizeof(int)) @{
                error = EINVAL;
                goto iocnak;
            @}
            /* fetch other dev from 2nd message block */
            to = *(int *) mp->b_cont->b_rptr;
            /* 
             * More sanity checks.  The minor must be in range, open already.
             * Also, this device and the other one nust be disconnected.
             */

            if (to >= loop_cnt || to < 0 || !loop_loop[to].qptr) @{
                error = ENXIO;
                goto iocnak;
            @}
            if (loop->oqptr || loop_loop[to].oqptr) @{
                error = EBUSY;
                goto iocnak;
            @}
            /* Cross connect streams via the loop structures */
            loop->oqptr = RD(loop_loop[to].qptr);
            loop_loop[to].oqptr = RD(q);
            /* 
             * Return successful ioctl.  Set ioc_count
             * to zero, since no data are returned.
             */

            mp->b_datap->db_type = M_IOCACK;
            iocp->ioc_count = 0;
            qreply(q, mp);
            break;
        @}

        default:
            error = EINVAL;
          iocnak:
            /* 
             * Bad ioctl.  Setting ioc_error causes the
             * ioctl call to return that particular errno.
             * By default, ioctl will return EINVAL on failure
             */
            mp->b_datap->db_type = M_IOCNAK;
            iocp->ioc_error = error;    /* set returned errno */
            qreply(q, mp);

        @}
        break;
    @}
@end smallexample

loopwput shows another use of an @ioctlref{I_STR} @command{ioctl} call (see @ref{Input-Output Control}).
The driver supports a LOOP_SET value of ioc_cmd in the
iocblk of the @msg{M_IOCTL} message.  LOOP_SET instructs the driver to connect the current open
@dfn{Stream} to
the @dfn{Stream} indicated in the message.  The second block of the @msg{M_IOCTL} message holds an integer that
specifies the minor device number of the @dfn{Stream} to connect to.

The driver performs several sanity checks: Does the second block have the proper amount of data? Is
the "to" device in range? Is the "to" device open? Is the current @dfn{Stream} disconnected? Is the "to"
@dfn{Stream} disconnected?

If everything checks out, the read queue pointers for the two @dfn{Streams} are stored in the respective
oqptr fields.  This cross-connects the two @dfn{Streams} indirectly, via loop_loop.

Canonical flush handling is incorporated in the @command{put} procedure:

@smallexample
    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW) @{
            flushq(q, FLUSHALL);        /* write */
            flushq(loop->optr, FLUSHALL);
            /* read on other side equals write on this side */
        @}
        if (*mp->b_rptr & FLUSHR) @{
            flushq(RD(q), FLUSHALL);
            flushq(WR(loop->oqptr), FLUSHALL);
        @}
        switch (*mp->b_rptr) @{

        case FLUSHW:
            *mp->b_rptr = FLUSHR;
            break;

        case FLUSHR:
          *mp->b_rptr = FLUSHW:
            break;
        @}
        putnext(loop->oqptr, mp);
        break;

    default:
        /* If this Stream is not connected, send M_ERROR upstream.  */
        if (loop->oqptr == NULL) @{
            freemsg(mp);
            putctl1(RD(q)->q_next, M_ERROR, ENXIO);
            break;
        @}
        putq(q, mp);
    @}
@}
@end smallexample

Finally, loopwput enqueues all other messages (e.g., @msg{M_DATA} or @msg{M_PROTO}) for processing by its
@command{service} procedure.  A check is made to see if the @dfn{Stream} is connected.  If not, an
@msg{M_ERROR} is sent upstream to the @dfn{Stream head}.

Certain message types can be sent upstream by drivers and modules to the @dfn{Stream head} where
they are translated into actions detectable by user process(es).  The messages may also modify the
state of the @dfn{Stream head}:

@table @msg

@item M_ERROR
Causes the @dfn{Stream head} to lock up.  Message transmission between @dfn{Stream} and user
processes is terminated.  All subsequent system calls except @manpage{close(2)} and
@manpage{poll(2)} will fail.  Also causes an @msg{M_FLUSH} clearing all message queues to be sent
downstream by the @dfn{Stream head}.

@item M_HANGUP
Terminates input from a user process to the @dfn{Stream}.  All subsequent system calls that would
send messages downstream will fail.  Once the @dfn{Stream head} read message queue is empty,
@dfn{EOF} is
returned on reads.  Can also result in the @signal{SIGHUP} signal being sent to the process group.

@item M_SIG
@itemx M_PCSIG
Causes a specified signal to be sent to a process.

@end table

@manpage{putctl1(9)} and @manpage{putctl(9)} are utilities that allocate a non-data (i.e., not @msg{M_DATA},
@msg{M_DELAY},
@msg{M_PROTO},
or @msg{M_PCPROTO}) type message, place one byte in the message (for putctl1) and call the @command{put}
procedure of the specified queue.

Service procedures are required in this example on both the write-side and read-side for flow
control:

@smallexample
static int
loopwsrv(q)
        register queue_t *q;
@{
    mblk_t *mp;
    register struct loop *loop;

    loop = (struct loop *) q->q_ptr;

    while ((mp = getq(q)) != NULL) @{

        /* Check if we can put the message up the other Stream read
           queue */

        if (mp->b_datap->db_type <= QPCTL
            && !canput(loop->oqptr->q_next)) @{
            putbq(q, mp);       /* read-side is blocked */
            break;
        @}
        /* send message */

        putnext(loop->oqptr, mp);       /* To queue following other
                                           Stream read queue */
    @}
@}

static int
looprsrv(q)
        queue_t *q;
@{
    /* Enter only when "back enabled" by flow control */

    struct loop *loop;

    loop = (struct loop *) q->q_ptr;
    if (loop->oqptr == NULL)
        return;

    /* manually enable write service procedure */

    qenable(WR(loop->oqptr));
@}
@end smallexample

The write @command{service} procedure, loopwsrv, takes on the canonical form.  The queue being
written to is not downstream, but upstream (found via oqptr) on the other @dfn{Stream}.

In this case, there is no read-side @command{put} procedure so the read @command{service} procedure,
looprsrv, is not scheduled by an associated @command{put} procedure, as has been done previously.
looprsrv is scheduled only by being back enabled when its upstream becomes unstuck from flow control
blockage.  The purpose of the procedure is to re-enable the writer (loopwsrv) by using oqptr to find
the related queue.  loopwsrv can not be directly back-enabled by @dfn{STREAMS} because there is no
direct queue linkage between the two @dfn{Streams}.  Note that no message ever gets queued to the
read @command{service} procedure.  Messages are kept on the write-side so that flow control can
propagate up to the @dfn{Stream head}.  The @manpage{qenable(9)} routine schedules the write-side
@command{service} procedure of the other @dfn{Stream}.

loopclose breaks the connection between the @dfn{Streams}:

@smallexample
static int
loopclose(q, flag, credp)
        queue_t *q;
        int flag;
        cred_t *credp;
@{
    register struct loop *loop;

    loop = (struct loop *) q->q_ptr;
    loop->qptr = NULL;

    /* If we are connected to another stream, break the linkage, and
       send a hangup message. The hangup message causes the stream
       head to fail writes, allow the queued data to be read
       completely, and then return EOF on subsequent reads. */
    if (loop->oqptr) @{
        ((struct loop *) loop->oqptr->q_ptr)->oqptr = NULL;
        putctl(loop->oqptr->q_next, M_HANGUP);
        loop->oqptr = NULL;
    @}
@}
@end smallexample

loopclose sends an @msg{M_HANGUP} message up the connected @dfn{Stream} to the @dfn{Stream head}.

This driver can be implemented much more cleanly by actually linking the q_next pointers of the
queue pairs of the two @dfn{Streams}.

@node Driver Design Guidelines
@section Driver Design Guidelines

Driver developers should follow these guidelines:

@itemize @bullet

@item Messages that are not understood by the drivers should be freed.

@item A driver must process an @msg{M_IOCTL} message, if only to respond with an @msg{M_IOCNAK}
message.  Otherwise, the @dfn{Stream head} will block for an @msg{M_IOCNAK} or @msg{M_IOCACK} until
the timeout (potentially infinite) expires.

@item If a driver does not understand an @command{ioctl}, an @msg{M_IOCNAK} message must be sent to upstream.

@item Terminal drivers must always acknowledge the @dfn{EUC} ioctls whether they understand them or not.

@item The @dfn{Stream head} locks up the @dfn{Stream} when it receives an @msg{M_ERROR} message, so driver developers
should be careful when using the @msg{M_ERROR} message.

@item If a driver wants to allocate a controlling terminal, it should send an @msg{M_SETOPTS} message with
the @stropt{SO_ISTTY} flag set upstream.

@item A driver must be a part of the kernel (or a demand loadable kernel module) for it to be opened.

@end itemize

Also see @ref{Module Design Guidelines}.

@node STREAMS Multiplexing
@chapter STREAMS Multiplexing
@cindex STREAMS multiplexing
@menu
* Multiplexers::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexer Connect and Disconnect Lower Stream
* Multiplexer Construction Example::
				STREAMS Multiplexer Construction Example
* Multiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexer Persistent Links
* Multiplexing Driver Design Guidelines::
				STREAMS Multiplexing Driver Design Guidelines
@end menu

@node Multiplexers
@section Multiplexing

This chapter describes how @dfn{STREAMS} multiplexing configurations are created and also discusses
multiplexing drivers.  A @dfn{STREAMS} multiplexer is a driver with multiple @dfn{Streams} connected
to it.  The primary function of the multiplexing driver is to switch messages among the connected
@dfn{Streams}.  Multiplexer configurations are created from user level by system calls.

@dfn{STREAMS} related system calls are used to set up the "plumbing," or @dfn{Stream}
interconnections, for multiplexing drivers.  The subset of these calls that allows a user to connect
(and disconnect) @dfn{Streams} below a driver is referred to as the multiplexing facility.  This
type of connection is referred to as a 1-to-M, or lower, multiplexer configuration.  This
configuration must always contain a multiplexing driver, which is recognized by @dfn{STREAMS} as
having special characteristics.

Multiple @dfn{Streams} can be connected above a driver by use of @manpage{open(2)} calls.  This was done for
the loop around driver and for the driver handling multiple minor devices in Drivers.  There is no
difference between the connections to these drivers, only the functions performed by the driver are
different.  In the multiplexing case, the driver routes data between multiple @dfn{Streams}.  In the
device driver case, the driver routes data between user processes and associated physical ports.
Multiplexing with @dfn{Streams} connected above is referred to as an N-to-1, or upper, multiplexer.
@dfn{STREAMS} does not provide any facilities beyond @manpage{open(2)} and @manpage{close(2)} to
connect or disconnect upper @dfn{Streams} for multiplexing purposes.

From the driver's perspective, upper and lower configurations differ only in the way they are
initially connected to the driver.  The implementation requirements are the same: route the data and
handle flow control.  All multiplexer drivers require special developer-provided software to perform
the multiplexing data routing and to handle flow control.  @dfn{STREAMS} does not directly support
flow control among multiplexed @dfn{Streams}.

M-to-N multiplexing configurations are implemented by using both of the above mechanisms in a
driver.

As discussed in Drivers, the multiple @dfn{Streams} that represent minor devices are actually
distinct @dfn{Streams} in which the driver keeps track of each @dfn{Stream} attached to it.  The
@dfn{STREAMS} subsystem does not recognize any relationship between the @dfn{Streams}.  The same is
true for @dfn{STREAMS} multiplexers of any configuration.  The multiplexed @dfn{Streams} are
distinct and the driver must be implemented to do most of the work.

In addition to upper and lower multiplexers, more complex configurations can be created by
connecting @dfn{Streams} containing multiplexers to other multiplexer drivers.  With such a
diversity of needs for multiplexers, it is not possible to provide general purpose multiplexer
drivers.  Rather, @dfn{STREAMS} provides a general purpose multiplexing facility.  The facility
allows users to set up the inter-module/driver plumbing to create multiplexer configurations of
generally unlimited interconnection.

@subsection Building a Multiplexer

This section builds a protocol multiplexer with the multiplexing configuration shown in @figref{30}.
To free users from the need to know about the underlying protocol structure, a user-level daemon
process will be built to maintain the multiplexing configuration.  Users can then access the
transport protocol directly by opening the transport protocol (TP) driver device node.

An inter-networking protocol driver (IP) routes data from a single upper @dfn{Stream} to one of two
lower @dfn{Streams}.  This driver supports two @dfn{STREAMS} connection beneath it.  These
connections are to two distinct networks; one for the @cite{IEEE 802.3} standard via the 802.3 driver, and
other to the @cite{IEEE 802.4} standard via the 802.4 driver.  The TP driver multiplexes upper
@dfn{Streams} over a single @dfn{Stream} to the IP driver.

@figuresized{SPG_fig30,30,Protocol Multiplexer,5in}

The following example shows how this daemon process sets up the protocol multiplexer.  The necessary
declarations and initialization for the daemon program are as follows:

@smallexample
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stropts.h>

main()
@{
    int fd_802_4, fd_802_3, fd_ip, fd_tp;

    /* daemon-ize this process */

    switch (fork()) @{
    case 0:
        break;
        case -1;
        perror("fork failed");
        exit(2);
    default:
        exit(0);
    @}
    setsid();
@end smallexample

This multi-level multiplexed @dfn{Stream} configuration will be built from the bottom up.
Therefore, the example begins by first constructing the Internet Protocol (IP) multiplexer.  This
multiplexing device driver is treated like any other software driver.  It owns a node in the
@b{Linux} file system and is opened just like any other @dfn{STREAMS} device driver.

The first step is to open the multiplexing driver and the 802.4 driver, thus creating separate
@dfn{Streams} above each driver as shown in @figref{31}.  The @dfn{Stream} to the 802.4 driver may
now be connected below the multiplexing IP driver using the @ioctlref{I_LINK} @command{ioctl}
call.

@figuresized{SPG_fig31,31,Before Link,4in}

The sequence of instructions to this point is:

@smallexample
    if ((fd_802.4 = open("/dev/802_4", O_RDWR)) < 0) @{
        perror("open of /dev/802_4 failed");
        exit(1);
    @}

    if ((fd_ip = open("/dev/ip", O_RDWR)) < 0) @{
        perror("open of /dev/ip failed");
        exit(2);
    @}

    /* now link 802.  4 to underside of IP */

    if (ioctl(fd_ip, I_LINK, fd_802_4) < 0) @{
        perror("I_LINK ioctl failed");
        exit(3);
    @}
@end smallexample

@streamio{I_LINK} takes two file descriptors as arguments.  The first file descriptor, fd_ip, must
reference the @dfn{Stream} connected to the multiplexing driver, and the second file descriptor,
fd_802_4, must reference the @dfn{Stream} to be connected below the multiplexer.  @figref{32} shows
the state of these @dfn{Streams} following the @ioctlref{I_LINK} call.  The complete @dfn{Stream} to
the 802.4 driver has been connected below the IP driver.  The @dfn{Stream head}'s queues of the 802.4
driver will be used by the IP driver to manage the lower half of the multiplexer.

@figuresized{SPG_fig32,32,IP Multiplexer After First Link,4in}

@ioctlref{I_LINK} will return an integer value, called @var{muxid}, which is used by the
multiplexing driver to identify the @dfn{Stream} just connected below it.  This @var{muxid} is
ignored in the example, but it is useful for dismantling a multiplexer or routing data through the
multiplexer.  Its significance is discussed later.

The following sequence of system calls is used to continue building the inter-networking protocol
multiplexer (IP):

@smallexample
    if ((fd_802_3 = open("/dev/802_3", O_RDWR)) < 0) @{
        perror("open of /dev/802_3 failed");
        exit(4);
    @}

    if (ioctl(fd_ip, I_LINK, fd_802_3) < 0) @{
        perror("I_LINK ioctl failed");
        exit(5);
    @}
@end smallexample

All links below the IP driver have now been established, giving the configuration in @figref{33}.

@figuresized{SPG_fig33,33,IP Multiplexer,4in}

The @dfn{Stream} above the multiplexing driver used to establish the lower connections is the
controlling @dfn{Stream} and has special significance when dismantling the multiplexing
configuration.  This will be illustrated later in this chapter.  The @dfn{Stream} referenced by
fd_ip is the controlling @dfn{Stream} for the IP multiplexer.

The order in which the @dfn{Streams} in the multiplexing configuration are opened is unimportant.
If it is necessary to have intermediate modules in the @dfn{Stream} between the IP driver and media
drivers, these modules must be added to the @dfn{Streams} associated with the media drivers (using
@ioctlref{I_PUSH}) before the media drivers are attached below the multiplexer.

The number of @dfn{Streams} that can be linked to a multiplexer is restricted by the design of the
particular multiplexer.  The manual page describing each driver describes such restrictions.
However, only one @ioctlref{I_LINK} operation is allowed for each lower @dfn{Stream}; a single @dfn{Stream}
cannot be linked below two multiplexers simultaneously.

Continuing with the example, the IP driver will now be linked below the transport protocol (TP)
multiplexing driver.  As seen earlier in @figref{30}, only one link will be supported below the
transport driver.  This link is formed by the following sequence of system calls:

@smallexample
    if ((fd_tp = open("/dev/tp", O_RDWR)) < 0) @{
        perror("open of /dev/tp failed");
        exit(6);
    @}

    if (ioctl(fd_tp, I_LINK, fd_ip) < 0) @{
        perror("I_LINK ioctl failed");
        exit(7);
    @}
@end smallexample

The multi-level multiplexing configuration shown in @figref{34} has now been created.

@figuresized{SPG_fig34,34,TP Multipexor,4in}

Because the controlling @dfn{Stream} of the IP multiplexer has been linked below the TP multiplexer, the
controlling @dfn{Stream} for the new multi-level multiplexer configuration is the @dfn{Stream} above the TP
multiplexer.

At this point the file descriptors associated with the lower drivers can be closed without affecting
the operation of the multiplexer.  If these file descriptors are not closed, all subsequent read,
write, @command{ioctl}, poll, getmsg, and putmsg system calls issued to them will fail.  That is
because @streamio{I_LINK} associates the @dfn{Stream head} of each linked @dfn{Stream} with the multiplexer, so
the user may not access that @dfn{Stream} directly for the duration of the link.

The following sequence of system calls completes the daemon example:

@smallexample
    close(fd_802_4);
    close(fd_802_3);
    close(fd_ip);

    /* Hold multiplexer open forever */
    pause();
@}
@end smallexample

To summarize, @figref{34} shows the multi-level protocol multiplexer.  The transport driver supports
several simultaneous @dfn{Streams}.  These @dfn{Streams} are multiplexed over the single
@dfn{Stream} connected to the IP multiplexer.  The mechanism for establishing multiple @dfn{Streams}
above the transport multiplexer is actually a by-product of the way in which @dfn{Streams} are
created between a user process and a driver.  By opening different minor devices of a @dfn{STREAMS}
driver, separate @dfn{Streams} will be connected to that driver.  Of course, the driver must be
designed with the intelligence to route data from the single lower @dfn{Stream} to the appropriate
upper @dfn{Stream}.

The daemon process maintains the multiplexed @dfn{Stream} configuration through an open @dfn{Stream}
(the controlling @dfn{Stream}) to the transport driver.  Meanwhile, other users can access the
services of the transport protocol by opening new @dfn{Streams} to the transport driver; they are
freed from the need for any unnecessary knowledge of the underlying protocol configurations and
sub-networks that support the transport service.

Multi-level multiplexing configurations should be assembled from the bottom up.  That is because the
passing of ioctls through the multiplexer is determined by the nature of the multiplexing driver and
cannot generally be relied on.

@subsection Dismantling a Multiplexer

@dfn{Streams} connected to a multiplexing driver from above with open, can be dismantled by closing
each @dfn{Stream} with close.  The mechanism for dismantling @dfn{Streams} that have been linked
below a multiplexing driver is less obvious, and is described below.

The @ioctlref{I_UNLINK} @command{ioctl} call is used to disconnect each multiplexer link below a multiplexing
driver individually.  This command has the form:

@smallexample
ioctl(fd, I_UNLINK, muxid);
@end smallexample

where @var{fd} is a file descriptor associated with a @dfn{Stream} connected to the multiplexing
driver from above, and @var{muxid} is the identifier that was returned by @streamio{I_LINK} when a
driver was linked below the multiplexer.  Each lower driver may be disconnected individually in this
way, or a special @var{muxid} value of @samp{-1} (@constant{MUXID_ALL}) may be used to disconnect
all drivers from the multiplexer simultaneously.

In the multiplexing daemon program presented earlier, the multiplexer is never explicitly
dismantled.  That is because all links associated with a multiplexing driver are automatically
dismantled when the controlling @dfn{Stream} associated with that multiplexer is closed.  Because
the controlling @dfn{Stream} is open to a driver, only the final call of close for that @dfn{Stream}
will close it.  In this case, the daemon is the only process that has opened the controlling
@dfn{Stream}, so the multiplexing configuration will be dismantled when the daemon exits.

For the automatic dismantling mechanism to work in the multi-level, multiplexed Stream
configuration, the controlling @dfn{Stream} for each multiplexer at each level must be linked under
the next higher level multiplexer.  In the example, the controlling @dfn{Stream} for the IP driver
was linked under the TP driver.  This resulted in a single controlling @dfn{Stream} for the full,
multi-level configuration.  Because the multiplexing program relied on closing the controlling
@dfn{Stream} to dismantle the multiplexed @dfn{Stream} configuration instead of using explicit
@streamio{I_UNLINK} calls, the @var{muxid} values returned by @ioctlref{I_LINK} could be ignored.

An important side effect of automatic dismantling on the close is that it is not possible for a
process to build a multiplexing configuration with @streamio{I_LINK} and then exit.  That is because
@manpage{exit(2)} will close all files associated with the process, including the controlling
@dfn{Stream}.  To keep the configuration intact, the process must exist for the life of that
multiplexer.  That is the motivation for implementing the example as a daemon process.

However, if the process uses persistent links via the @ioctlref{I_PLINK} @manref{ioctl(2)} call, the
multiplexer configuration would remain intact after the process exits.  Persistent links are
described later in this chapter.

@subsection Routing Data Through a Multiplexer

As demonstrated, @dfn{STREAMS} provides a mechanism for building multiplexed @dfn{Stream}
configurations.  However, the criteria on which a multiplexer routes data is driver dependent.  For
example, the protocol multiplexer shown before might use address information found in a protocol
header to determine over which sub-network data should be routed.  It is the multiplexing driver's
responsibility to define its routing criteria.

One routing option available to the multiplexer is to use the @var{muxid} value to determine to
which @dfn{Stream} data should be routed (remember that each multiplexer link is associated with a
@var{muxid}).  @streamio{I_LINK} passes the @var{muxid} value to the driver and returns this value
to the user.  The driver can therefore specify that the @var{muxid} value must accompany data routed
through it.  For example, if a multiplexer routed data from a single upper @dfn{Stream} to one of
several lower @dfn{Streams} (as did the IP driver), the multiplexer could require the user to insert
the @var{muxid} of the desired lower @dfn{Stream} into the first four bytes of each message passed
to it.  The driver could then match the @var{muxid} in each message with the @var{muxid} of each
lower @dfn{Stream}, and route the data accordingly.

@node Connecting and Disconnecting Lower Stream
@section Connecting and Disconnecting Lower Stream

Multiple @dfn{Streams} are created above a driver/multiplexer by use of the open system call on
either different minor devices, or on a cloneable device file.  Note that any driver that handles
more than one minor device is considered an upper multiplexer.

To connect @dfn{Streams} below a multiplexer requires additional software within the multiplexer.
The main difference between @dfn{STREAMS} lower multiplexers and @dfn{STREAMS} device drivers are
that multiplexers are pseudo-devices and that multiplexers have two additional qinit structures,
pointed to by fields in the @type{streamtab} structure: the lower half read-side qinit and the lower half
write-side qinit.

The multiplexer is conceptually divided into two parts: the lower half (bottom) and the upper half
(top).  The multiplexer queue structures that have been allocated when the multiplexer was opened,
use the usual qinit entries from the multiplexer's @type{streamtab}.  This is the same as any open of the
@dfn{STREAMS} device.  When a lower @dfn{Stream} is linked beneath the multiplexer, the qinit
structures at the @dfn{Stream head} are substituted by the bottom half qinit structures of the
multiplexers.  Once the linkage is made, the multiplexer switches messages between upper and lower
@dfn{Streams}.  When messages reach the top of the lower @dfn{Stream}, they are handled by
@command{put} and @command{service} routines specified in the bottom half of the multiplexer.

@subsection Connecting Lower Streams

A lower multiplexer is connected as follows: the initial open to a multiplexing driver creates a
@dfn{Stream}, as in any other driver.  open uses the first two @type{streamtab} structure entries to create
the driver queues.  At this point, the only distinguishing characteristic of this @dfn{Stream} are
non-@samp{NULL} entries in the @type{streamtab} st_muxrinit and st_muxwinit fields.

These fields are ignored by open (see the rightmost @dfn{Stream} in @figref{35}).  Any other
@dfn{Stream} subsequently opened to this driver will have the same @type{streamtab} and thereby the
same mux fields.

Next, another file is opened to create a (soon to be) lower @dfn{Stream}.  The driver for the lower
Stream is typically a device driver (see the leftmost @dfn{Stream} in @figref{35}).  This Stream has
no distinguishing characteristics.  It can include any driver compatible with the multiplexer.  Any
modules required on the lower @dfn{Stream} must be pushed onto it now.

Next, this lower @dfn{Stream} is connected below the multiplexing driver with an @ioctlref{I_LINK}
@command{ioctl} call (see @manref{streamio(7)}).  The @dfn{Stream head} points to the @dfn{Stream
head} routines as its procedures (known via its queue).  An @streamio{I_LINK} to the upper
@dfn{Stream}, referencing the lower @dfn{Stream}, causes @dfn{STREAMS} to modify the contents of the
@dfn{Stream head}'s queues in the lower @dfn{Stream}.  The pointers to the @dfn{Stream head}
routines, and other values, in the @dfn{Stream head}'s queues are replaced with those contained in
the mux fields of the multiplexing driver's @type{streamtab}.  Changing the @dfn{Stream head}
routines on the lower @dfn{Stream} means that all subsequent messages sent upstream by the lower
@dfn{Stream}'s driver will, ultimately, be passed to the @command{put} procedure designated in
st_muxrinit, the multiplexing driver.  The @streamio{I_LINK} also establishes this upper
@dfn{Stream} as the control @dfn{Stream} for this lower @dfn{Stream}.  @dfn{STREAMS} remembers the
relationship between these two @dfn{Streams} until the upper @dfn{Stream} is closed, or the lower
@dfn{Stream} is unlinked.

Finally, the @dfn{Stream head} sends an @msg{M_IOCTL} message with ioc_cmd set to @streamio{I_LINK}
to the multiplexing driver.  The @msg{M_DATA} part of the @msg{M_IOCTL} contains a linkblk
structure.  The multiplexing driver stores information from the linkblk structure in private storage
and returns an @msg{M_IOCACK} message (acknowledgement).  @member{l_index} is returned to the
process requesting the @streamio{I_LINK}.  This value can be used later by the process to disconnect
this @dfn{Stream}.

An @streamio{I_LINK} is required for each lower @dfn{Stream} connected to the driver.  Additional
upper @dfn{Streams} can be connected to the multiplexing driver by open calls.  Any message type can
be sent from a lower @dfn{Stream} to user processes along any of the upper @dfn{Streams}.  The upper
@dfn{Streams} provide the only interface between the user processes and the multiplexer.

Note that no direct data structure linkage is established for the linked @dfn{Streams}.  The read
queue's q_next will be @samp{NULL} and the write queue's q_next will point to the first entity on
the lower @dfn{Stream}.  Messages flowing upstream from a lower driver (a device driver or another
multiplexer) will enter the multiplexing driver @command{put} procedure with @member{l_qbot} as the
queue value.  The multiplexing driver has to route the messages to the appropriate upper (or lower)
@dfn{Stream}.  Similarly, a message coming downstream from user space on any upper Stream has to be
processed and routed, if required, by the driver.

Also note that the lower @dfn{Stream} (see the headers and file descriptors in @figref{36}) is no
longer accessible from user space.  This causes all system calls to the lower @dfn{Stream} to return
@errno{EINVAL}, with the exception of close.  This is why all modules have to be in place before the
lower @dfn{Stream} is linked to the multiplexing driver.

Finally, note that the absence of direct linkage between the upper and lower @dfn{Streams} means
that @dfn{STREAMS} flow control has to be handled by special code in the multiplexing driver.  The
flow control mechanism cannot see across the driver.

In general, multiplexing drivers should be implemented so that new @dfn{Streams} can be dynamically
connected to (and existing @dfn{Streams} disconnected from) the driver without interfering with its
ongoing operation.  The number of @dfn{Streams} that can be connected to a multiplexer is developer
dependent.

@subsection Disconnection Lower Streams

Dismantling a lower multiplexer is accomplished by disconnecting (unlinking) the lower
@dfn{Streams}.  Unlinking can be initiated in three ways: an @streamio{I_UNLINK} @command{ioctl} referencing a
specific @dfn{Stream}, an @streamio{I_UNLINK} indicating all lower @dfn{Streams}, or the last close of the
control @dfn{Stream}.  As in the link, an unlink sends a linkblk structure to the driver in an
@msg{M_IOCTL} message.  The @streamio{I_UNLINK} call, which unlinks a single @dfn{Stream}, uses the @member{l_index} value
returned in the @streamio{I_LINK} to specify the lower Stream to be unlinked.  The latter two calls must
designate a file corresponding to a control @dfn{Stream} which causes all the lower @dfn{Streams}
that were previously linked by this control @dfn{Stream} to be unlinked.  However, the driver sees a
series of individual unlinks.

If no open references exist for a lower @dfn{Stream}, a subsequent unlink will automatically close
the @dfn{Stream}.  Otherwise, the lower @dfn{Stream} must be closed by close following the unlink.
@dfn{STREAMS} will automatically dismantle all cascaded multiplexers (below other multiplexing
@dfn{Streams}) if their controlling @dfn{Stream} is closed.  An @streamio{I_UNLINK} will leave lower, cascaded
multiplexing @dfn{Streams} intact unless the @dfn{Stream} file descriptor was previously closed.

@node Multiplexer Construction Example
@section Multiplexer Construction Example

This section describes an example of multiplexer construction and usage.  @figref{35} shows the
@dfn{Streams} before their connection to create the multiplexing configuration of @figref{36}.
Multiple upper and lower @dfn{Streams} interface to the multiplexer driver.  The user processes of
@figref{36} are not shown in @figref{35}.

@figuresized{SPG_fig35,35,Internet Multiplexer Before Connecting,5in}

The Ethernet, @dfn{LAPB} and @cite{IEEE 802.2} device drivers terminate links to other nodes.  The multiplexer
driver is an Internet Protocol (IP) multiplexer that switches data among the various nodes or sends
data upstream to a user(s) in the system.  The Net modules would typically provide a convergence
function which matches the multiplexer driver and device driver interface.

@figref{35} depicts only a portion of the full, larger
@dfn{Stream}.  In the dotted rectangle above the IP multiplexer, there generally would be an upper
transport control protocol (@dfn{TCP}) multiplexer, additional modules and, possibly, additional
multiplexers in the @dfn{Stream}.  Multiplexers could also be cascaded below the IP driver if the
device drivers were replaced by multiplexer drivers.

@figuresized{SPG_fig36,36,Internet Multiplexer After Connecting,5.5in}

@dfn{Streams} A, B, and C are opened by the process, and modules are pushed as needed.  Two upper
@dfn{Streams} are opened to the IP multiplexer.  The rightmost @dfn{Stream} represents multiple
@dfn{Streams}, each connected to a process using the network.  The @dfn{Stream} second from the
right provides a direct path to the multiplexer for supervisory functions.  It is the control
@dfn{Stream}, leading to a process which sets up and supervises this configuration.  It is always
directly connected to the IP driver.  Although not shown, modules can be pushed on the control
@dfn{Stream}.

After the @dfn{Streams} are opened, the supervisory process typically transfers routing information
to the IP drivers (and any other multiplexers above the IP), and initializes the links.  As each
link becomes operational, its @dfn{Stream} is connected below the IP driver.  If a more complex
multiplexing configuration is required, the IP multiplexer @dfn{Stream} with all its connected links
can be connected below another multiplexer driver.

@figref{36} shows that the file descriptors for the lower device driver @dfn{Streams} are left
dangling.  The primary purpose in creating these @dfn{Streams} was to provide parts for the
multiplexer.  Those not used for control and not required for error recovery (by reconnecting them
through an @streamio{I_UNLINK} @command{ioctl}) have no further function.  These lower @dfn{Streams}
can be closed to free the file descriptor without any effect on the multiplexer.

@node Multiplexing Driver
@section Multiplexing Driver

This section contains an example of a multiplexing driver that implements an N-to-1 configuration.
This configuration might be used for terminal windows, where each transmission to or from the
terminal identifies the window.  This resembles a typical device driver, with two differences: the
device handling functions are performed by a separate driver, connected as a lower @dfn{Stream}, and
the device information (i.e., relevant user process) is contained in the input data rather than in
an interrupt call.

Each upper @dfn{Stream} is created by @manpage{open(2)}.  A single lower @dfn{Stream} is opened and
then it is linked by use of the multiplexing facility.  This lower @dfn{Stream} might connect to the
@dfn{tty} driver.  The implementation of this example is a foundation for an M-to-N multiplexer.

As in the loop-around driver (in Drivers), flow control requires the use of standard and special
code, since physical connectivity among the @dfn{Streams} is broken at the driver.  Different
approaches are used for flow control on the lower @dfn{Stream}, for messages coming upstream from
the device driver, and on the upper @dfn{Streams}, for messages coming downstream from the user
processes.

The multiplexer declarations are:

@smallexample
#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/streams.h>
#include <sys/stropts.h>
#include <sys/errno.h>
#include <sys/cred.h>
#include <sys/ddi.h>

static int muxopen(), muxclose(), muxuwput(), muxlwsrv(), muxlrput(),
muxuwsrv();

static struct module_info info = @{
    0xaabb, "mux", 0, INFPSZ, 512, 128
@};

static struct qinit urinit = @{	/* upper read */
    NULL, NULL, muxopen, muxclose, NULL, &info, NULL
@};

static struct qinit uwinit = @{	/* upper write */
    muxuwput, muxuwsrv, NULL, NULL, NULL, &info, NULL
@};

static struct qinit lrinit = @{	/* lower read */
    muxlrput, NULL, NULL, NULL, NULL, &info, NULL
@};

static struct qinit lwinit = @{	/* lower write */
    NULL, muxlwsrv, NULL, NULL, NULL, &info, NULL
@};

struct streamtab muxinfo = @{ &urinit, &uwinit, &lrinit, &l winit
@};

struct mux @{
    queue_t *qbtr;	/* back pointer to read queue */
@};

extern struct mux mux_mux[];
extern int mux_cnt;

queue_t *muxbot;	/* linked lower queue */
int muxerr;		/* set if error of hangup on lower stream */
@end smallexample

The four @type{streamtab} entries correspond to the upper read, upper write, lower read, and lower
write qinit structures.  The multiplexing qinit structures replace those in each (in this case there
is only one) lower @dfn{Stream head} after the @ioctlref{I_LINK} has completed successfully.  In a
multiplexing configuration, the processing performed by the multiplexing driver can be partitioned
between the upper and lower queues.  There must be an upper @dfn{Stream} write @command{put}
procedure and lower @dfn{Stream} read @command{put} procedure.  If the queue procedures of the
opposite upper/lower queue are not needed, the queue can be skipped over, and the message put to the
following queue.

In the example, the upper read-side procedures are not used.  The lower @dfn{Stream} read queue
@command{put} procedure transfers the message directly to the read queue upstream from the
multiplexer.  There is no lower write @command{put} procedure because the upper write @command{put}
procedure directly feeds the lower write queue downstream from the multiplexer.

The driver uses a private data structure, mux.  mux_mux[dev] points back to the opened upper read
queue.  This is used to route messages coming upstream from the driver to the appropriate upper
queue.  It is also used to find a free major/minor device for a @constant{CLONEOPEN} driver open
case.

The upper queue open contains the canonical driver open code:

@smallexample
static int
muxopen(q, devp, flag, sflag, credp)
        queue_t *q;
        dev_t *devp;
        int flag;
        int sflag;
        cred_t *credp;
@{
    struct mux *mux;
    dev_t device;

    if (sflag == CLONEOPEN) @{
        for (device = 0; device < mux_cnt; device++) @{
            if (mux_mux[device].qptr == 0)
                break;
        @}
    @} else
        device = getminor(*devp);

    if (device >= mux_cnt)
        return ENXIO;

    mux = &mux_mux[device];
    mux->qptr = q;
    q->q_ptr = (char *) mux;
    wr(q)->q_ptr = (char *) mux;
    return 0;
@}
@end smallexample

@code{muxopen} checks for a clone or ordinary open call.  It initializes q_ptr to point at the
mux_mux[t] structure.

The core multiplexer processing is the following: downstream data written to an upper @dfn{Stream}
is queued on the corresponding upper write message queue if the lower @dfn{Stream} is flow
controlled.  This allows flow control to propagate toward the @dfn{Stream head} for each upper
@dfn{Stream}.  A lower write @command{service} procedure, rather than a write @command{put}
procedure, is used so that flow control, coming up from the driver below, may be handled.

On the lower read-side, data coming up the lower @dfn{Stream} are passed to the lower read
@command{put} procedure.  The procedure routes the data to an upper @dfn{Stream} based on the first
byte of the message.  This byte holds the minor device number of an upper @dfn{Stream}.  The
@command{put} procedure handles flow control by testing the upper @dfn{Stream} at the first upper
read queue beyond the driver.  That is, the @command{put} procedure treats the @dfn{Stream}
component above the driver as the next queue.

@subsection Upper Write Put Procedure

@code{muxuwput}, the upper queue write @command{put} procedure, traps ioctls, in particular
@ioctlref{I_LINK} and @streamio{I_UNLINK}:

@smallexample
static int
muxuwput(q, mp)
        queue_t *q;
        mblk_t *MP;
@{
    int s;
    struct mux *mux;

    mux = (struct mux *) q->q_ptr;
    switch (mp->b_datap->db_type) @{
    case M_IOCTL:
    @{
        struct iocblk *iocp;
        struct linkblk *linkp;

        /* 
         * ioctl.  Only channel 0 can do ioctls.  Two
         * calls are recognized: Link, and UNLINK
         */

        if (mux != mux_mux)
            goto iocnak;

        iocp = (struct iocblk *) mp->b_rptr;
        switch (iocp->ioc_cmd) @{
        case I_LINK:

            /* 
             * Link.  The data contains a linkblk structure
             * Remember the bottom queue in muxbot.
             */

            if (muxbot != NULL)
                goto iocnak;
            linkp = (struct linkblk *) mp->b_cont->b_rptr;
            muxbot = linkp->l_qbot;
            muxerr = 0;
            mp->b_datap->db_type = M_IOCACK;
            iocp->ioc_count = 0;
            qreply(q, mp);
            break;

        case I_UNLINK:

            /* 
             * Unlink.  The data contains a linkblk structure.
             * Should not fail an unlink.  Null out muxbot.
             */

            linkp = (struct linkblk *) mp->b_cont->b_rptr;
            muxbot = NULL;
            mp->b_datap->db_type = M_IOCACK;
            iocp->ioc_cont = 0;
            qreply(q, mp);
            break;

        default:
          iocnak:

            /* fail ioctl */

            mp->b_datap->db_type = M_IOCNAK;
            qreply(q, mp);
        @}

        break;

    @}
@end smallexample

First, there is a check to enforce that the @dfn{Stream} associated with minor device 0 will be the
single, controlling @dfn{Stream}.  The ioctls are only accepted on this @dfn{Stream}.  As described
previously, a controlling @dfn{Stream} is the one that issues the @streamio{I_LINK}.  Having a
single control @dfn{Stream} is a recommended practise.  @streamio{I_LINK} and @streamio{I_UNLINK}
include a linkblk structure containing:

@table @member
@item l_qtop
The upper write queue from which the @command{ioctl} is coming.  It should always equal q.

@item l_qbot
The new lower write queue.  It is the former @dfn{Stream head} write queue.  It is of most interest
since that is where the multiplexer gets and puts its data.

@item l_index
A unique (system wide) identifier for the link.  It can be used for routing or during selective
unlinks.  Since the example only supports a single link, @member{l_index} is not used.

@end table

For @streamio{I_LINK}, @member{l_qbot} is saved in muxbot and a positive acknowledgement is
generated.  From this point on, until an @streamio{I_UNLINK} occurs, data from upper queues will be
routed through muxbot.  Note that when an @streamio{I_LINK}, is received, the lower Stream has
already been connected.  This allows the driver to send messages downstream to perform any
initialization functions.  Returning an @msg{M_IOCNAK} message (negative acknowledgement) in
response to an @streamio{I_LINK} will cause the lower @dfn{Stream} to be disconnected.

The @streamio{I_UNLINK} handling code nulls out muxbot and generates a positive acknowledgement.  A
negative acknowledgement should not be returned to an @streamio{I_UNLINK}.  The @dfn{Stream head}
assures that the lower Stream is connected to a multiplexer before sending an @streamio{I_UNLINK}
@msg{M_IOCTL}.

@code{muxuwput} handles @msg{M_FLUSH} messages as a normal driver would:

@smallexample
    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW)
            flushq(q, FLUSHDATA);
        if (*mp->b_rptr & FLUSHR) @{
            *mp->b_rptr &= ~FLUSHW;
            qreply(q, mp);
        @} else
            freemsg(mp);
        break;
    case M_DATA:
        /* 
         * Data.  If we have no bottom queue --> fail
         * Otherwise, queue the data and invoke the lower
         * service procedure.
         */
        if (muxerr || muxbot == NULL)
            goto bad;
        if (canput(muxbot->q_next)) @{
            mblk_t *bp;

            if ((bp = allocb(l, BPRI_MED)) == NULL) @{
                putq(q, mp);
                bufcall(l, BPRI_MED, qenable, q);
                break;
            @}
            *bp->b_wptr++ = (struct mux *) q->q_ptr - mux_mux;
            bp->b_cont = mp;
            putnext(muxbot, bp);
        @} else
            putq(q, mp);
        break;
    default:
      bad:
        /* 
         * Send an error message upstream.
         */
        mp->b_datap->db_type = M_ERROR;
        mp->b_rptr = mp->b_wptr = mp->b_datap->db_base;
        *mp->b_wptr++ = EINVAL;
        qreply(q, mp);
    @}
@}
@end smallexample

@msg{M_DATA} messages are not placed on the lower write message queue.  They are queued on the upper
write message queue.  When flow control subsides on the lower @dfn{Stream}, the lower
@command{service} procedure, @code{muxlwsrv}, is scheduled to start output.  This is similar to
starting output on a device driver.

@subsection Upper Write Service Procedure

The following example shows the code for the upper multiplexer write @command{service} procedure:

@smallexample
static int
muxuwsrv(q)
        queue_t *q;
@{
    struct mux *muxp;
    mblk_t *mp;

    muxp = (struct mux *) q->q_ptr;

    if (!muxbot && q->q_first) @{
        flushq(q, FLUSHALL);
        return;
    @}
    if (muxerr) @{
        flushq(q, FLUSHALL);
        return;
    @}
    while (mp = getq(q)) @{
        if (canput(muxbot->q_next))
            putnext(muxbot, mp);
        else @{
            putnext(muxbot, mp);
            return;
        @}
    @}
@}
@end smallexample

As long as there is a @dfn{Stream} still linked under the multiplexer and there are no errors, the
@command{service} procedure will take a message off the queue and send it downstream, if flow
control allows.

@subsection Lower Write Service Procedure

@code{muxlwsrv}, the lower (linked) queue write @command{service} procedure is scheduled as a result
of flow control subsiding downstream (it is back-enabled).

@smallexample
static int
muxlwsrv(q)
        queue_t *q;
@{
    register int i;

    for (i = 0; i < mux_cnt; i++)
        if (mux_mux[i].qptr && mux_mux[i].qptr->q_first)
            genable(mux_mux[i].qptr);
@}
@end smallexample

@code{muxlwsrv} steps through all possible upper queues.  If a queue is active and there are
messages on the queue, then its the upper write @command{service} procedure is enabled via
@manref{qenable(9)}.

@subsection Lower Read Put Procedure

The lower (linked) queue read @command{put} procedure is:

@smallexample
static int
muxlrput(q, mp)
        queue_t *q;
        mklk_t *mp;
@{
    queue_t *uq;
    mklk_t *b_cont;
    int device;

    if (muxerr) @{
        freemsg(mp);
        return;
    @}
    switch (mp->b_datap->db_type) @{
    case M_FLUSH:
        /* 
         * Flush queues.  NOTE: sense of tests is reversed
         * since we are acting like a "stream head"
         */
        if (*mp->b_rptr & FLUSHW) @{
            *mp->b_rptr &= ~FLUSHR;
            qreply(q, mp);
        @} else
            freemsg(mp);
        break;

    case M_ERROR:
    case M_HANGUP:
        muxerr = 1;
        freemsg(mp);
        break;

    case M_DATA:
        /* 
         * Route message.  First byte indicates
         * device to send to.  No floe control.
         *
         * Extract and delete device number.  If the leading block is
         * now empty and more blocks follow, strip the leading block.
         */

        device = *mp->b_rptr++;

        /* Sanity check.  Device must be in range */

        if (device < 0 || device >= mux_cut) @{
            freemsg(mp);
            break;
        @}

        /* 
         * If upper stream is open and not backed up,
         * send the message there, otherwise discard it.
         */

        uq = mux_mux[device].qptr;
        if (uq != NULL && canput(uq->q_next))
            putnext(uq, mp);
        else
            freemsg(mp);
        break;
    default:
        freemsg(mp);
    @}
@}
@end smallexample

@code{muxlrput} receives messages from the linked @dfn{Stream}.  In this case, it is acting as a
@dfn{Stream head}.  It handles @msg{M_FLUSH} messages.  Note the code is reversed from that of a
driver, handling @msg{M_FLUSH} messages from upstream.  There is no need to flush the read queue
because no data are ever placed on it.

@code{muxlrput} also handles @msg{M_ERROR} and @msg{M_HANGUP} messages.  If one is received, it
locks-up the upper @dfn{Streams} by setting muxerr.

@msg{M_DATA} messages are routed by looking at the first data byte of the message.  This byte
contains the minor device of the upper @dfn{Stream}.  Several sanity checks are made: Is the device
in range? Is the upper @dfn{Stream} open? Is the upper @dfn{Stream} not full?

This multiplexer does not support flow control on the read-side.  It is merely a router.  If
everything checks out, the message is put to the proper upper queue.  Otherwise, the message is
discarded.

The upper @dfn{Stream} close routine simply clears the mux entry so this queue will no longer be
found.

@smallexample
/*
 * Upper queue close
 */
static int
muxclose(q, flag, credp)
        queue_t *q;
        int flag;
        cred_t *credp;
@{
    ((struct mux *) q->q_ptr)->qptr = NULL;
    q->q->ptr = NULL;
    wr(q)->q_ptr = NULL;
@}
@end smallexample

@node Persistent Links
@section Persistent Links

With @streamio{I_LINK} and @streamio{I_UNLINK} ioctls the file descriptor associated with the
@dfn{Stream} above the multiplexer used to set up the lower multiplexer connections must remain open
for the duration of the configuration.  Closing the file descriptor associated with the controlling
@dfn{Stream} will dismantle the whole multiplexing configuration.  Some applications may not want to
keep a process running merely to hold the multiplexer configuration together.  Therefore,
"free-standing" links below a multiplexer are needed.  A persistent link is such a link.  It is
similar to a @dfn{STREAMS} multiplexer link, except that a process is not needed to hold the links
together.  After the multiplexer has been set up, the process may close all file descriptors and
exit, and the multiplexer will remain intact.

Two ioctls, @streamio{I_PLINK} and @streamio{I_PUNLINK}, are used to create and remove persistent
links that are associated with the @dfn{Stream} above the multiplexer.  @manpage{close(2)} and
@streamio{I_UNLINK} are not able to disconnect the persistent links.

The format of @streamio{I_PLINK} is:

@smallexample
ioctl(fd0, I_PLINK, fd1)
@end smallexample

The first file descriptor, @var{fd0}, must reference the @dfn{Stream} connected to the multiplexing
driver and the second file descriptor, @var{fd1}, must reference the @dfn{Stream} to be connected
below the multiplexer.  The persistent link can be created in the following way:

@smallexample
    upper_stream_fd = open("/dev/mux", O_RDWR);
    iower_stream_fd = open("/dev/driver", O_RDWR);
    muxid = ioctl(upper_stream_fd, I_PLINK, lower_stream_fd);
    /* 
     * save muxid in s file
     */
    exit(0);
@end smallexample

@figref{37} shows how @manpage{open(2)} establishes a @dfn{Stream} between the device and the
@dfn{Stream head}.

@figuresized{SPG_fig37,37,open() of MUXdriver and Driver1,4in}

The persistent link can still exist even if the file descriptor associated with the upper
@dfn{Stream} to the multiplexing driver is closed.  The @streamio{I_PLINK} @command{ioctl} returns
an integer value, @var{muxid}, that can be used for dismantling the multiplexing configuration.  If
the process that created the persistent link still exists, it may pass the @var{muxid} value to some
other process to dismantle the link, if the dismantling is desired, or it can leave the @var{muxid}
value in a file so that other processes may find it later.  @figref{38} shows a multiplexer after
@streamio{I_PLINK}.

@figuresized{SPG_fig38,38,Multiplexer After @streamio{I_PLINK},4in}

Several users can open the @var{MUXdriver} and send data to the @var{Driver1} since the persistent
link to the @var{Driver1} remains intact.  This is shown in the following figure.

@figuresized{SPG_fig39,39,Other Users Opening a MUXdriver,4in}

The @command{ioctl} @streamio{I_PUNLINK} is used for dismantling the persistent link.  Its format
is:

@smallexample
ioctl(fd0, I_PUNLINK, muxid)
@end smallexample

where the @var{fd0} is the file descriptor associated with @dfn{Stream} connected to the
multiplexing driver from above.  The @var{muxid} is returned by the @command{ioctl}
@streamio{I_PLINK} for the @dfn{Stream} that was connected below the multiplexer.  The
@streamio{I_PUNLINK} removes the persistent link between the multiplexer referenced by the @var{fd0}
and the @dfn{Stream} to the driver designated by the @var{muxid}.  Each of the bottom persistent
links can be disconnected individually.  An @streamio{I_PUNLINK} @command{ioctl} with the
@var{muxid} value of @constant{MUXID_ALL} will remove all persistent links below the multiplexing
driver referenced by the @var{fd0}.

The following will dismantle the previously given configuration:

@smallexample
    fd = open("/dev/mux", O_RDWR);
    /*
     * retrieve muxid from the file
     */
    ioctl(fd, I_PUNLINK, muxid);
    exit(0);
@end smallexample

The use of the ioctls @streamio{I_PLINK} and @streamio{I_PUNLINK} should not be intermixed with the
@streamio{I_LINK} and @streamio{I_UNLINK}.  Any attempt to unlink a regular link via the
@streamio{I_PUNLINK} or to unlink a persistent link via the @streamio{I_UNLINK} @command{ioctl} will
cause the @var{errno} value of @errno{EINVAL} to be returned.

Since multi-level multiplexing configurations are allowed in @dfn{STREAMS}, it is possible to have a
situation where persistent links exist below a multiplexer whose @dfn{Stream} is connected to the
above multiplexer by regular links.  Closing the file descriptor associated with the controlling
Stream will remove the regular link but not the persistent links below it.  On the other hand,
regular links are allowed to exist below a multiplexer whose @dfn{Stream} is connected to the above
multiplexer via persistent links.  In this case, the regular links will be removed if the persistent
link above is removed and no other references to the lower @dfn{Streams} exist.

The construction of cycles is not allowed when creating links.  A cycle could be constructed by
creating a persistent link of multiplexer 2 below multiplexer 1 and then closing the controlling
file descriptor associated with the multiplexer 2 and reopening it again and then linking the
multiplexer 1 below the multiplexer 2.  This is not allowed.  The operating system prevents a
multiplexer configuration from containing a cycle to ensure that messages can not be routed
infinitely, thus creating an infinite loop or overflowing the kernel stack.

@node Multiplexing Driver Design Guidelines
@section Multiplexing Driver Design Guidelines

The following lists general multiplexer design guidelines:

@itemize @bullet
@item The upper half of the multiplexer acts like the end of the upper @dfn{Stream}.
@item The lower half of the multiplexer acts like the head of the lower @dfn{Stream}.
@item Service procedures are used for flow control.
@item Message routing is based on multiplexer specific criteria.
@item When one @dfn{Stream} is being fed by many @dfn{Streams}, flow control may have to take place.
Then all feeding @dfn{Streams} on the other end of the multiplexer will have to be enabled when the
flow control is relieved.
@item When one @dfn{Stream} is feeding many @dfn{Streams}, flow control may also have to take place.
Be careful not to starve other @dfn{Streams} when one becomes flow controlled.
@end itemize

@node STREAMS-based Pipes and FIFOs
@chapter STREAMS-based Pipes and FIFOs
@cindex STREAMS-based pipes and fifos
@menu
* Pipes and FIFOs::		STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs
@end menu

@node Pipes and FIFOs
@section Pipes and FIFOs

A pipe in the @cite{UNIX} system is a mechanism that provides a communication path between multiple
processes.  Prior to @cite{Release 4.0}, @cite{UNIX System V} had "standard" pipes and named pipes
(also called FIFOs).  With standard pipes, one end was opened for reading and the other end for
writing, thus data flow was uni-directional.  FIFOs had only one end and typically one process
opened the file for reading and another process opened the file for writing.  Data written into the
@dfn{FIFO} by the writer could then be read by the reader.

The @cite{GNU/Linux} system implements standard @cite{UNIX System V Release 3.2} style pipes.

To provide greater support and development flexibility for applications using a network, pipes and
FIFOs became @dfn{STREAMS}-based in @cite{UNIX System V Release 4.0}.  The basic interface remains
the same but the underlying implementation has changed.  @dfn{STREAMS}-based pipes provide a
bi-directional mechanism for process communication.  When a pipe is created via the
@manpage{pipe(2)} system call, two @dfn{Streams} are opened and connected together, thus providing a
full-duplex mechanism.  Data flow is on a First-In-First-Out basis.  Previously pipes were
associated with character devices and the creation of a pipe was limited to the capacity and
configuration of the device.@footnote{The most significant capacity limitation was the number of
character minor device numbers.  @b{Linux} has never had this problem.}  @dfn{STREAMS}-based pipes
and FIFOs are not attached to @dfn{STREAMS}-based character devices.  This eliminates configuration
constraints and only limits the number of opened pipes to the number of file descriptors for that
process.

The remainder of this chapter uses the terms @dfn{pipe} and @dfn{STREAMS-based pipe} interchangeably
for a @dfn{STREAMS}-based pipe.

@cite{@value{PACKAGE_TITLE}} provides @dfn{STREAMS}-based pipes and
FIFOs.  Whereas some implementations provided FIFOs based on character devices (reintroducing the limitation
on character device minor numbers), @cite{@value{PACKAGE_TITLE}} has the option of making all
@b{Linux} system FIFOs @dfn{STREAMS}-based.
@cite{@value{PACKAGE_TITLE}} also supports the @cite{System V Release 3.0} approach
of associating FIFOs with @dfn{STREAMS} devices.  The limitation of minor device number is not so
severe for @b{Linux} 2.6 kernels, or 2.4 kernels with expanded minor and major device numbers.

@cite{@value{PACKAGE_TITLE}} overrides the @manref{pipe(2)} system call
with a library function as part of the @file{libstreams} library.

@subsection Creating and Opening Pipes and FIFOs

FIFOs are created via @manref{mknod(2)} or @manref{mkfifo(3)}.  FIFOs behave like regular file
system nodes but are distinguished from other file system nodes by the @samp{p} in the first column
when the @samp{ls -l} command is executed.  Data written to the @dfn{FIFO} or read from the
@dfn{FIFO} flow up and down the @dfn{Stream} in @dfn{STREAMS} buffers.  Data written by one process
can be read by another process.

FIFOs are opened in the same manner as other file system nodes via the @manpage{open(2)} system
call.  Any data written to the @dfn{FIFO} can be read from the same file descriptor in the
First-In-First-Out manner.  Modules can also be pushed on the @dfn{FIFO}.  See @manref{open(2)}, for
the restrictions that apply when opening a @dfn{FIFO}.

@figuresized{SPG_fig40,40,Pushing Modules on a @dfn{STREAMS}-based Pipe,4in}

A @dfn{STREAMS}-based pipe is created via the @manpage{pipe(2)} system call that returns two file
descriptors, @var{fd}[0] and @var{fd}[1].  Both file descriptors are opened for reading and writing.
Data written to @var{fd}[0] becomes data read from @var{fd}[1] and vice versa.

Each end of the pipe has knowledge of the other end through internal data structures.  Subsequent
reads, writes, and closes are aware of if the other end of the pipe is open or closed.  When one end
of the pipe is closed, the internal data structures provide a way to access the @dfn{Stream} for the
other end so that an @msg{M_HANGUP} message can be sent to its @dfn{Stream head}.

After successful creation of a @dfn{STREAMS}-based pipe, 0 is returned.  If @manpage{pipe(2)} is
unable to create and open a @dfn{STREAMS}-based pipe, it will fail with errno set as follows:

@itemize @bullet
@item @errno{ENOMEM} could not allocate two inodes.
@item @errno{ENFILE} file table is overflowed.
@item @errno{EMFILE} cannot allocate more file descriptors for the process.
@item @errno{ENOSR} could not allocate resources for both @dfn{Stream heads}.
@item @errno{EINTR} signal was caught while creating the @dfn{Stream heads}.
@end itemize

@dfn{STREAMS} modules can be added to a @dfn{STREAMS}-based pipe with the @manpage{ioctl(2)}
@streamio{I_PUSH}.  A module can be pushed onto one or both ends of the pipe (see @figref{40}).
However, a pipe maintains the concept of a midpoint so that if a module is pushed onto one end of
the pipe, that module cannot be popped from the other end.

@subsection Accessing Pipes and FIFOs

@dfn{STREAMS}-based pipes and FIFOs can be accessed through the operating system routines
@manpage{read(2)}, @manpage{write(2)}, @manpage{ioctl(2)}, @manpage{close(2)}, @manpage{putmsg(2)},
@manpage{getmsg(2)}, and @manpage{poll(2)}.  In case of FIFOs open(2) is also used.

@subsubsection Reading from a Pipe or FIFO

The @manpage{read(2)} (or @manpage{getmsg(2)}) system call is used to read from a pipe or
@dfn{FIFO}.  A user reads data from a @dfn{Stream} (not from a data buffer as was done prior to
@cite{Release 4.0} and currently by @cite{Linux}).  Data can be read from either end of a pipe.

On success, the read returns the number of bytes read and placed in the buffer.  When the end of the
data is reached, the read returns 0.

When a user process attempts to read from an empty pipe (or @dfn{FIFO}), the following will happen:

@itemize @bullet

@item If one end of the pipe is closed, 0 is returned indicating the end of the file.

@item If no process has the @dfn{FIFO} open for writing, @manpage{read(2)} returns 0 to indicate the
end of the file.

@item If some process has the @dfn{FIFO} open for writing, or both ends of the pipe are open, and
@constant{O_NDELAY} is set, @manpage{read(2)} returns 0.

@item If some process has the @dfn{FIFO} open for writing, or both ends of the pipe are open, and
@constant{O_NONBLOCK} is set, @manpage{read(2)} returns -1 and set errno to @errno{EAGAIN}.

@item If @constant{O_NDELAY} and @constant{O_NONBLOCK} are not set, the read call will block until
data are written to the pipe, until one end of the pipe is closed, or the @dfn{FIFO} is no longer
open for writing.

@end itemize

@cite{@value{PACKAGE_TITLE}} implements both the old terminal @constant{NDELAY} behaviour as well as
the newer behaviour.  The newer behaviour is described by @cite{POSIX/SUSv3}, see @manref{open(2p)},
@manref{open(2s)}, @manref{read(2p)}, @manref{read(2s)}, @manref{getmsg(2p)}, @manref{getmsg(2s)},
@manref{write(2p)}, @manref{write(2s)}, @manref{putmsg(2p)}, and @manref{putmsg(2s)} for details.

@subsubsection Writing to a Pipe or FIFO

When a user process calls the @manpage{write(2)} system call, data are sent down the associated
@dfn{Stream}.  If the pipe or @dfn{FIFO} is empty (no modules pushed), data written are placed on
the read queue of the other @dfn{Stream} for @dfn{STREAMS}-based pipes, and on the read queue of the
same @dfn{Stream} for FIFOs.  Since the size of a pipe is the number of unread data bytes, the
written data are reflected in the size of the other end of the pipe.

@subsubheading Zero Length Writes 

If a user process issues @manpage{write(2)} with 0 as the number of bytes to send down a
@dfn{STREAMS}-based pipe or @dfn{FIFO}, 0 is returned, and by default no message is sent down the
@dfn{Stream}.  However, if a user requires that a 0-length message be sent downstream, an
@command{ioctl} call may be used to change this default behaviour.  The flag @constant{SNDZERO}
supports this.  If @constant{SNDZERO} is set in the @dfn{Stream head}, @manpage{write(2)} requests
of 0 bytes will generate a 0-length message and send the message down the @dfn{Stream}.  If
@constant{SNDZERO} is not set, no message is generated and 0 is returned to the user.

To toggle the @constant{SNDZERO} bit, the @command{ioctl} @streamio{I_SWROPT} is used.  If @var{arg}
in the @command{ioctl} call is set to @constant{SNDZERO} and the @constant{SNDZERO} bit is off, the
bit is turned on.  If @var{arg} is set to 0 and the @constant{SNDZERO} bit is on, the bit is turned
off.

The @command{ioctl} @streamio{I_GWROPT} is used to return the current write settings.

@subsubheading Atomic Writes 

If multiple processes simultaneously write to the same pipe, data from one process can be
interleaved with data from another process, if modules are pushed on the pipe or the write is
greater than @constant{PIPE_BUF}.  The order of data written is not necessarily the order of data
read.  To ensure that writes of less than @constant{PIPE_BUF} bytes will not be interleaved with
data written from other processes, any modules pushed on the pipe should have a maximum packet size
of at least @constant{PIPE_BUF}.

@constant{PIPE_BUF} is an implementation specific constant that specifies the maximum number of
bytes that are atomic in a write to a pipe.  When writing to a pipe, write requests of
@constant{PIPE_BUF} or less bytes will not be interleaved with data from other processes doing
writes on the same pipe.  However, write requests greater than @constant{PIPE_BUF} bytes may have
data interleaved on arbitrary byte boundaries with writes by other processes whether or not the
@constant{O_NONBLOCK} or @constant{O_NDELAY} flag is set.

If the module packet size is at least the size of @constant{PIPE_BUF}, the @dfn{Stream head}
packages the data in such a way that the first message is at least @constant{PIPE_BUF} bytes.  The
remaining data may be packaged into smaller or larger blocks depending on buffer availability.  If
the first module on the Stream cannot support a packet of @constant{PIPE_BUF}, atomic writes on the
pipe cannot be guaranteed.

@subsubsection Closing a Pipe or FIFO

The @manpage{close(2)} system call closes a pipe or @dfn{FIFO} and dismantles its associated
@dfn{Streams}.  On the last close of one end of a pipe, an @msg{M_HANGUP} message is sent upstream
to the other end of the pipe.  Subsequent @manpage{read(2)} or @manpage{getmsg(2)} calls on that
@dfn{Stream head} will return the number of bytes read and zero when there are no more data.
Subsequent @manpage{write(2)} or @manpage{putmsg(2)} requests will fail with @errno{ENXIO}.  If the
pipe has been mounted via @manpage{fattach(3)} the pipe must be unmounted prior to calling close,
otherwise the @dfn{Stream} will not be dismantled.  If the other end of the pipe is mounted, the
last close of the pipe will force it to be unmounted.

@node Flushing Pipes and FIFOs
@section Flushing Pipes and FIFOs

When the flush request is initiated from a user @command{ioctl} or from a @manpage{flushq(9)}
routine, the @constant{FLUSHR} and/or @constant{FLUSHW} bits of an @msg{M_FLUSH} message will have
to be switched.  The point of switching the bits is the point where the @msg{M_FLUSH} message is
passed from a write queue to a read queue.  This point is also known as the @dfn{mid-point} of the pipe.

The @dfn{mid-point} of a pipe is not always easily detectable, especially if there are numerous modules
pushed on either end of the pipe.  In that case, there needs to be a mechanism to intercept all
messages passing through the @dfn{Stream}.  If the message is an @msg{M_FLUSH} message and it is at
the @dfn{Streams} @dfn{mid-point}, the flush bits need to switched.

This bit switching is handled by the @file{pipemod} module.  @file{pipemod} should be pushed onto a
pipe or @dfn{FIFO} where flushing of any kind will take place.  The @file{pipemod} module can be
pushed on either end of the pipe.  The only requirement is that it is pushed onto an end that
previously did not have modules on it.  That is, @file{pipemod} must be the first module pushed onto
a pipe so that it is at the @dfn{mid-point} of the pipe itself.

The @file{pipemod} module handles only @msg{M_FLUSH} messages.  All other messages are passed on to
the next module via the @manpage{putnext(9)} utility routine.  If an @msg{M_FLUSH} message is passed
to @file{pipemod} and the @constant{FLUSHR} and @constant{FLUSHW} bits are set, the message is not
processed but is passed to the next module via the @manpage{putnext(9)} routine.  If only the
@constant{FLUSHR} bit is set, the @constant{FLUSHR} bit is turned off and the @constant{FLUSHW} bit
is set.  The message is then passed to the next module via @manpage{putnext(9)}.  Similarly, if the
@constant{FLUSHW} bit was the only bit set in the @msg{M_FLUSH} message, the @constant{FLUSHW} bit
is turned off and the @constant{FLUSHR} bit is turned on.  The message is then passed to the next
module on the @dfn{Stream}.

The @file{pipemod} module can be pushed on any @dfn{Stream} that desires the bit switching.  It must
be pushed onto a pipe or @dfn{FIFO} if any form of flushing must take place.

@node Named Streams
@section Named Streams

Some applications may want to associate a @dfn{Stream} or @dfn{STREAMS}-based pipe with an existing
node in the file system name space.  For example, a server process may create a pipe, name one end
of the pipe, and allow unrelated processes to communicate with it over that named end.

@subsection fattach

A @dfn{STREAMS} file descriptor can be named by attaching that file descriptor to a node in the file
system name space.  The routine @manpage{fattach(3)} (see also @manref{fattach(3)}) is used to name a
@dfn{STREAMS} file descriptor.  @dfn{Stream}, @manpage{fattach(3)} Its format is:

@smallexample
int fattach (int fildes, char *path)
@end smallexample

where fildes is an open file descriptor that refers to either a @dfn{STREAMS}-based pipe or a
@dfn{STREAMS} device driver (or a pseudo device driver), and path is an existing node in the file
system name space (for example, regular file, directory, character special file, etc).

The path cannot have a @dfn{Stream} already attached to it.  It cannot be a mount point for a file
system nor the root of a file system.  A user must be an owner of the path with write permission or
a user with the appropriate privileges in order to attach the file descriptor.

If the path is in use when the routine @manpage{fattach(3)} is executed, those processes accessing
the path will not be interrupted and any data associated with the path before the call to the
@manpage{fattach(3)} routine will continue to be accessible by those processes.

After a @dfn{Stream} is named, all subsequent operations (for example, @manpage{open(2)}) on the
path will operate on the named @dfn{Stream}.  Thus, it is possible that a user process has one file
descriptor pointing to the data originally associated with the path and another file descriptor
pointing to a named @dfn{Stream}.

Once the Stream has been named, the @manpage{stat(2)} system call on path will show information for
the @dfn{Stream}.  If the named @dfn{Stream} is a pipe, the @manpage{stat(2)} information will show
that path is a pipe.  If the @dfn{Stream} is a device driver or a pseudo device driver, path appears
as a device.  The initial modes, permissions, and ownership of the named @dfn{Stream} are taken from
the attributes of the path.  The user can issue the system calls @manpage{chmod(2)} and
@manpage{chown(2)} to alter the attributes of the named @dfn{Stream} and not affect the original
attributes of the path nor the original attributes of the @dfn{STREAMS} file.

The size represented in the @manpage{stat(2)} information will reflect the number of unread bytes of
data currently at the @dfn{Stream head}.  This size is not necessarily the number of bytes written
to the @dfn{Stream}.

A @dfn{STREAMS}-based file descriptor can be attached to many different paths at the same time
(i.e., a @dfn{Stream} can have many names attached to it).  The modes, ownership, and permissions of
these paths may vary, but operations on any of these paths will access the same @dfn{Stream}.

Named @dfn{Streams} can have modules pushed on them, be polled, be passed as file descriptors, and
be used for any other @dfn{STREAMS} operation.

@subsection fdetach

A named @dfn{Stream} can be disassociated from a file name with the @manpage{fdetach(3)} routine
(see also @manpage{fdetach(3)}) that has the following format:

@smallexample
int fdetach (char *path)
@end smallexample

where path is the name of the previously named @dfn{Stream}.  Only the owner of path or the user
with the appropriate privileges may disassociate the @dfn{Stream} from its name.  The @dfn{Stream}
may be disassociated from its name while processes are accessing it.  If these processes have the
named @dfn{Stream} open at the time of the @manpage{fdetach(3)} call, the processes will not get an
error, and will continue to access the @dfn{Stream}.  However, after the disassociation, subsequent
operations on path access the underlying file rather than the named @dfn{Stream}.

If only one end of the pipe is named, the last close of the other end will cause the named end to be
automatically detached.  If the named @dfn{Stream} is a device and not a pipe, the last close will
not cause the @dfn{Stream} to be detached.

If there is no named @dfn{Stream} or the user does not have access permissions on path or on the
named @dfn{Stream}, @manpage{fdetach(3)} returns -1 with errno set to @errno{EINVAL}.  Otherwise,
@manpage{fdetach(3)} returns 0 for success.

A @dfn{Stream} will remain attached with or without an active server process.  If a server aborted,
the only way a named @dfn{Stream} is cleaned up is if the server executed a clean up routine that
explicitly detached and closed down the @dfn{Stream}.

If the named @dfn{Stream} is that of a pipe with only one end attached, clean up will occur
automatically.  The named end of the pipe is forced to be detached when the other end closes down.
If there are no other references after the pipe is detached, the @dfn{Stream} is deallocated and
cleaned up.  Thus, a forced detach of a pipe end will occur when the server is aborted.

If the both ends of the pipe are named, the pipe remains attached even after all processes have
exited.  In order for the pipe to become detached, a server process would have to explicitly invoke
a program that executed the @manpage{fdetach(3)} routine.

To eliminate the need for the server process to invoke the program, the @manref{fdetach(8)} command
can be used.  This command accepts a path name that is a path to a named @dfn{Stream}.  When the
command is invoked, the @dfn{Stream} is detached from the path.  If the name was the only reference
to the @dfn{Stream}, the @dfn{Stream} is also deallocated.

A user invoking the @manref{fdetach(8)} command must be an owner of the named @dfn{Stream} or a user
with the appropriate permissions.

@subsection isastream

The function @manpage{isastream(3)} (see also @manref{isastream(3)}) may be used to determine if a
file descriptor is associated with a @dfn{STREAMS} device.  Its format is:

@smallexample
int isastream (int fildes)
@end smallexample

where fildes refers to an open file.  @manpage{isastream(3)} returns 1 if fildes represents a
@dfn{STREAMS} file, and 0 if not.  On failure, @manpage{isastream(3)} returns -1 with errno set to
@errno{EBADF}.

This function is useful for client processes communicating with a server process over a named Stream
to check whether the file has been overlaid by a @dfn{Stream} before sending any data over the file.

@subsection File Descriptor Passing

Named @dfn{Streams} are useful for passing file descriptors between unrelated processes.  A user
process can send a file descriptor to another process by invoking the @manpage{ioctl(2)}
@streamio{I_SENDFD} on
one end of a named @dfn{Stream}.  This sends a message containing a file pointer to the @dfn{Stream
head} at the other end of the pipe.  Another process can retrieve that message containing the file
pointer by invoking the @manpage{ioctl(2)} @streamio{I_RECVFD} on the other end of the pipe.

@subsection Named Streams in A Remote Environment

If a user on the server machine creates a pipe and mounts it over a file that is part of an
advertised resource, a user on the client machine (that has remotely named the resource) may access
the remote named @dfn{Stream}.  A user on the client machine is not allowed to pass file descriptors
across the named @dfn{Stream} and will get an error when the @command{ioctl} request is attempted.
If a user on the client machine creates a pipe and attempts to attach it to a file that is a
remotely named resource, the system call will fail.

The following three examples are given as illustrations:

Suppose the server advertised a resource /dev/foo, created a @dfn{STREAMS}-based pipe, and attached
one end of the pipe onto /dev/foo/spipe.  All processes on the server machine will be able to access
the pipe when they open /dev/foo/spipe.  Now suppose that client @samp{XYZ} mounts the advertised
resource /dev/foo onto its /mnt directory.  All processes on client @samp{XYZ} will be able to
access the @dfn{STREAMS}-based pipe when they open /mnt/spipe.

If the server advertised another resource /dev/fog and client @samp{XYZ} mounts that resource onto
its /install directory and then attaches a @dfn{STREAMS}-based pipe onto /install, the mount would
fail with errno set to @errno{EBUSY}, because /install is already a mount point.  If client
@samp{XYZ} attached a pipe onto /install/spipe, the mount would also fail with errno set to
@errno{EREMOTE}, because the mount would require crossing an @dfn{RFS (Remote File System)} mount
point.

Suppose the server advertised its /usr/control directory and client @samp{XYZ} mounts that resource
onto its /tmp directory.  The server now creates a @dfn{STREAMS}-based pipe and attaches one end
over its /usr directory.  When the server opens /usr it will access the pipe.  On the other hand,
when the client opens /tmp it will access what is in the server's /usr/control directory.

@node Unique Connections
@section Unique Connections

With named pipes, client processes may communicate with a server process via a module called @manref{connld(4)}
that enables a client process to gain a unique, non-multiplexed connection to a server.  The @manpage{connld(4)}
module can be pushed onto the named end of the pipe.  If @manpage{connld(4)} is pushed on the named end of the
pipe and that end is opened by a client, a new pipe will be created.  One file descriptor for the
new pipe is passed back to a client (named @dfn{Stream}) as the file descriptor from the
@manpage{open(2)} system call and the other file descriptor is passed to the server.  The server and
the client may now communicate through a new pipe.

@figuresized{SPG_fig41,41,Server Sets Up a Pipe,4in}

@figref{41} illustrates a server process that has created a pipe and
pushed the @manpage{connld(4)} module on the other end.  The server then invokes the @manpage{fattach(3)} routine
to name the other end @file{/usr/toserv}.

@figuresized{SPG_fig42,42,Processes X and Y Open /usr/toserv,4in}

When process X (procx) opens /usr/toserv, it gains a unique connection to the server process that
was at one end of the original @dfn{STREAMS}-based pipe.  When process Y (procy) does the same, it
also gains a unique connection to the server.  As shown in @figref{42}, the server process has
access to three separate @dfn{STREAMS}-based pipes via three file descriptors.

@manpage{connld(4)} is a @dfn{STREAMS}-based module that has an open, close, and @command{put} procedure.  @manpage{connld(4)}
is opened when the module is pushed onto the pipe for the first time and whenever the named end of
the pipe is opened.  The @manpage{connld(4)} module distinguishes between these two opens by use of the q_ptr
field of its read queue.  On the first open, this field is set to 1 and the routine returns without
further processing.  On subsequent opens, the field is checked for 1 or 0.  If the 1 is present, the
@manpage{connld(4)} module creates a pipe and sends the file descriptor to a client and a server.

Making use of the q_ptr field eliminates the need to configure the @manpage{connld(4)} module at boot time.  It
also eliminates the need to manage the number of times the module is either pushed and/or popped.

When the named @dfn{Stream} is opened, the open routine of @manpage{connld(4)} is called.  The @manpage{connld(4)} open will
fail if:

@itemize @bullet
@item The pipe ends can not be created.
@item A file pointer and file descriptor can not be allocated.
@item The @dfn{Stream head} can not stream the two pipe ends.
@item strioctl() fails while sending the file descriptor to the server.
@end itemize

The open is not complete until the server process has received the file descriptor using the
@command{ioctl} @streamio{I_RECVFD}.  The setting of the @constant{O_NDELAY} or
@constant{O_NONBLOCK} flag has no impact on the open.

The @manpage{connld(4)} module does not process messages.  All messages are passed to the next object in the
@dfn{Stream}.  The read and write @command{put} routines call @manpage{putnext(9)} (see @dfn{STREAMS}
Utilities) to send the message up or down the @dfn{Stream}.

@node STREAMS-based Terminal Subsystem
@chapter STREAMS-based Terminal Subsystem
@cindex STREAMS-based terminal subsystem
@menu
* Terminal Subsystem::		STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem
@end menu

@node Terminal Subsystem
@section Terminal Subsystem

@dfn{STREAMS} provides a uniform interface for implementing character I/O devices and networking
protocols in the kernel.  @cite{UNIX System V Release 4.0} implements the terminal subsystem in
@dfn{STREAMS}.  The @dfn{STREAMS}-based terminal subsystem (see @figref{43}) provides many benefits:

@itemize @bullet
@item Reusable line discipline modules.  The same module can be used in many @dfn{STREAMS} where the
configuration of these @dfn{STREAMS} may be different.

@item Line discipline substitution.  Although @cite{UNIX System V} provides a standard terminal line
discipline module, another one conforming to the interface may be substituted.  For example, a
remote login feature may use the terminal subsystem line discipline module to provide a terminal
interface to the user.

@item Internationalization.  The modularity and flexibility of the @dfn{STREAMS}-based terminal
subsystem enables an easy implementation of a system that supports multiple byte characters for
internationalization.  This modularity also allows easy addition of new features to the terminal
subsystem.

@item Easy customizing.  Users may customize their terminal subsystem environment by adding and
removing modules of their choice.

@item The pseudo-terminal subsystem.  The pseudo-terminal subsystem can be easily supported (this is
discussed in more detail later in this chapter).

@item Merge with networking.  By pushing a line discipline module on a network line, one can make
the network look like a terminal line.

@end itemize

@figuresized{SPG_fig43,43,@dfn{STREAMS}-based Terminal Subsystem,4in}

The initial setup of the @dfn{STREAMS}-based terminal subsystem is handled with the
@manpage{ttymon(8)} command within the framework of the Service Access Facility or the autopush
feature.  The autopush facility is discussed in @ref{STREAMS Configuration}.

The @dfn{STREAMS}-based terminal subsystem supports @manpage{termio(7)}, the @manpage{termios(2)} specification of the
POSIX standard, multiple byte characters for internationalization, the interface to asynchronous
hardware flow control (see @manref{termiox(7)}), and peripheral controllers for asynchronous terminals.
XENIX@registeredsymbol{} and @cite{BSD} compatibility can also be provided by pushing the ttcompat
module.  UNIX@registeredsymbol{} and @cite{BSD} compatibility can also be provided by pushing the
ttcompat module.

@subsection Line Discipline Module

A @dfn{STREAMS} line discipline module called ldterm (see @manref{ldterm(7)}) is a key part of the
@dfn{STREAMS}-based terminal subsystem.  Throughout this chapter, the terms line discipline and
ldterm are used interchangeably and refer to the @dfn{STREAMS} version of the standard line
discipline and not the traditional character version.  ldterm performs the standard terminal I/O
processing which was traditionally done through the linesw mechanism.

The termio and termios specifications describe four flags which are used to control the terminal:
c_iflag (defines input modes), c_oflag (defines output modes), c_cflag (defines hardware control
modes), and c_lflag (defines terminal functions used by ldterm).  In order to process these flags
elsewhere (for example, in the firmware or in another process), a mechanism is in place to turn on
and off the processing of these flags.  When ldterm is pushed, it sends an @msg{M_CTL} message
downstream which asks the driver which flags the driver will process.  The driver sends back that
message in response if it needs to change ldterm's default processing.  By default, ldterm assumes
that it must process all flags except c_cflag, unless it receives a message telling otherwise.

@subsubsection Default Settings

When ldterm is pushed on the @dfn{Stream}, the open routine initializes the settings of the termio
flags.  The default settings are:

@table @var
@item c_iflag
@samp{= BRKINT|ICRNL|IXON|ISTRIP|IXANY |ICRNL|IXON|ISTRIP|IXANY}
@item c_oflag
@samp{= OPOST|ONLCR|TAB3 |ONLCR|TAB3}
@item c_cflag
@samp{= 0}
@item c_lflag
@samp{= ISIG|ICANON|ECHO|ECHOK |ICANON|ECHO|ECHOK}
@end table

In canonical mode (@constant{ICANON} flag in c_lflag is turned on), read from the terminal file
descriptor is in message non-discard (@constant{RMSGN}) mode (@manref{see streamio(7)}).  This implies that
in canonical mode, read on the terminal file descriptor always returns at most one line regardless
how many characters have been requested.  In non-canonical mode, read is in byte-stream
(@constant{RNORM}) mode.

@subsubsection Data Structure

The ldterm module uses the following structure to maintain state information:

@smallexample
struct ldterm_mod @{
    mblk_t *t_savbp;    /* saved mblk that holds ld structure */
    struct termios t_modes;     /* effective modes set by the
                                   provider */
    struct termios t_amodes;    /* apparent modes for user programs */
    struct termios t_dmodes;    /* modes that driver wishes to
                                   process */
    unsigned long t_state;      /* internal state of tty module */
    int t_line;         /* output line of tty */
    int t_col;          /* output column of tty */
    int t_rocount;      /* number of characters echoed since last
                           output */
    int t_rocol;        /* column in which first such character
                           appeared */
    mblk_t *t_message;  /* pointer to 1st mblk in message being built 
                         */
    mblk_t *t_endmsg;   /* pointer to last mblk in that message */
    int t_msglen;       /* number of characters in that message */
    mblk_t *t_echomp;   /* echoed output being assembled */
    int t_rd_request;   /* number of bytes requested by M_READ during
                           vmin/vtime read */
    int t_tid;          /* vtime timer id */

    /* 
     * The following are for EUC processing.
     */

    unchar t_codeset;   /* current code set indicator - read-side */
    unchar t_eucleft;   /* bytes left to get in current character */
    unchar t_eucign;    /* bytes left to ignore - output post proc */
    unchar t_eucpad;    /* padding for eucwioc */
    eucioc_t eucwioc;   /* eucioc structure (have to use bcopy) */
    unchar *t_eucp;     /* pointer to parallel array of column widths 
                         */
    mblk_t *t_eucp_mp;  /* message block that holds parallel array */
    unchar t_maxeuc;    /* maximum length in memory bytes of an EUC */
    int t_eucwarn;      /* bad EUC counter */
@};
@end smallexample

@subsubsection Open and Close Routines

The open routine of the ldterm module allocates space for holding the @code{tty} structure (see
@header{tty.h}) by allocating a buffer from the @dfn{STREAMS} buffer pool.  The number of modules
that can be pushed depends on the availability of buffers.  The open also sends an @msg{M_SETOPTS}
message upstream to set the Stream head high and low water marks to 512 and 128 respectively.

The ldterm module establishes a controlling @dfn{tty} for the line when an @msg{M_SETOPTS} message
(so_flags is set to @stropt{SO_ISTTY}) is sent upstream.  The @dfn{Stream head} allocates the
controlling @dfn{tty} on the open, if one is not already allocated.

To maintain compatibility with existing applications that use the @constant{O_NDELAY} flag, the open
routine sets the @stropt{SO_NDELON} flag on in the so_flags field of the @code{stroptions} structure
in the @msg{M_SETOPTS} message.

The open routine fails if there are no buffers available (cannot allocate the @code{tty} structure)
or when an interrupt occurs while sleeping for a buffer to become available.

The close routine frees all the outstanding buffers allocated by this @dfn{Stream}.  It also sends
an @msg{M_SETOPTS} message to the @dfn{Stream head} to undo the changes made by the open routine.
The ldterm module also sends @msg{M_START} and @msg{M_STARTI} messages downstream to undo the effect
of any previous @msg{M_STOP} and @msg{M_STOPI} messages.

@subsubsection Read-Side Processing

The ldterm module's read-side processing has @command{put} and @command{service} procedures.  High
and low water marks for the read queue are 512 and 200 respectively.

ldterm can send the following messages upstream:

@manref{ldterm(7)} messages

@msg{M_DATA}, @msg{M_BREAK}, @msg{M_PCSIG}, @msg{M_SIG}, @msg{M_FLUSH}, @msg{M_ERROR},
@msg{M_IOCACK},
@msg{M_IOCNAK}, @msg{M_HANGUP},
@msg{M_CTL}, @msg{M_SETOPTS},
@msg{M_COPYOUT}, and @msg{M_COPYIN} (@pxref{Message Types}).

The ldterm module's read-side processes @msg{M_BREAK}, @msg{M_DATA}, @msg{M_CTL}, @msg{M_FLUSH},
@msg{M_HANGUP}, and @msg{M_IOCACK} messages.  All other messages are sent upstream unchanged.

The @command{put} procedure scans the message for flow control characters (@constant{IXON}), signal
generating characters, and after (possible) transformation of the message, queues the message for
the @command{service} procedure.  Echoing is handled completely by the @command{service} procedure.

In canonical mode if the @constant{ICANON} flag is on in c_lflag, canonical processing is performed.
If the @constant{ICANON} flag is off, non-canonical processing is performed (see @manref{termio(7)}, for more
details).  Handling of @constant{VMIN}/@constant{VTIME} in the @dfn{STREAMS} environment is somewhat
complicated, because read needs to activate a timer in the ldterm module in some cases; hence, read
notification becomes necessary.  When a user issues an @command{ioctl} to @command{put} ldterm in
non-canonical mode, the ldterm module sends an @msg{M_SETOPTS} message to the @dfn{Stream head} to
register read notification.  Further reads on the terminal file descriptor will cause the
@dfn{Stream head} to issue an @msg{M_READ} message downstream and data will be sent upstream in
response to the @msg{M_READ} message.  With read notification, buffering of raw data is performed by
ldterm.  It is possible to canonize the raw data, when the user has switched from raw to canonical
mode.  However, the reverse is not possible.

To summarize, in non-canonical mode, the ldterm module buffers all data until a request for the data
arrives in the form of an @msg{M_READ} message.  The number of bytes sent upstream will be the
argument of the @msg{M_READ} message.

The @command{service} procedure of ldterm handles @dfn{STREAMS} related flow control.  Since the
read-side high and low water marks are 512 and 200 respectively, placing more than 512 characters on
the ldterm's read queue will cause the @constant{QFULL} flag be turned on indicating that the module
below should not send more data upstream.

Input flow control is regulated by the line discipline module by generating @msg{M_STARTI} and
@msg{M_STOPI} high priority messages.  When sent downstream, receiving drivers or modules take
appropriate action to regulate the sending of data upstream.  Output flow control is activated when
ldterm receives flow control characters in its data stream.  The ldterm module then sets an internal
flag indicating that output processing is to be restarted/stopped and sends an
@msg{M_START}/@msg{M_STOP} message downstream.

@subsubsection Write-Side Processing

Write-side processing of the ldterm module is performed by the write-side @command{put} procedures.

The ldterm module supports the following ioctls:

@termio{TCSETA}, @termio{TCSETAW}, @termio{TCSETAF}, @termio{TCSETS}, @termio{TCSETSW},
@termio{TCSETSF},
@termio{TCGETA}, @termio{TCGETS}, @termio{TCXONC}, @termio{TCFLSH}, @termio{TCSBRK},
@termio{TIOCSWINSZ}, @termio{TIOCGWINSZ}, and @termio{JWINSIZE}.

All ioctls not recognized by the ldterm module are passed downstream to the neighbouring module or
driver.  @cite{BSD} functionality is turned off by @constant{IEXTEN} (see @manref{termio(7)}, for more details).

The following messages can be received on the write-side:

@msg{M_DATA}, @msg{M_DELAY}, @msg{M_BREAK}, @msg{M_FLUSH}, @msg{M_STOP}, @msg{M_START},
@msg{M_STOPI}, @msg{M_STARTI},
@msg{M_READ},
@msg{M_IOCDATA}, @msg{M_CTL}, and
@msg{M_IOCTL}.

On the write-side, the ldterm module processes @msg{M_FLUSH}, @msg{M_DATA}, @msg{M_IOCTL}, and
@msg{M_READ} messages, and all other message are passed downstream unchanged.

An @msg{M_CTL} message is generated by ldterm as a query to the driver for an intelligent peripheral
and to decide on the functional split for termio processing.  If all or part of termio processing is
done by the intelligent peripheral, ldterm can turn off this processing to avoid computational
overhead.  This is done by sending an appropriate response to the @msg{M_CTL} message, as follows:
(see also @manref{ldterm(7)}).

@itemize @bullet

@item If all of the termio processing is done by the peripheral hardware, the driver sends an
@msg{M_CTL} message back to ldterm with ioc_cmd of the structure iocblk set to MC_NO_CANON.  If
ldterm is to handle all termio processing, the driver sends an @msg{M_CTL} message with ioc_cmd set
to MC_DO_CANON.  Default is MC_DO_CANON.

@item If the peripheral hardware handles only part of the termio processing, it informs ldterm in
the following way: The driver for the peripheral device allocates an @msg{M_DATA} message large
enough to hold a termios structure.  The driver then turns on those c_iflag, c_oflag, and c_lflag
fields of the termios structure that are processed on the peripheral device by ORing the flag
values.  The @msg{M_DATA} message is then attached to the b_cont field of the @msg{M_CTL} message it
received.  The message is sent back to ldterm with ioc_cmd in the data buffer of the @msg{M_CTL}
message set to MC_PART_CANON.

@end itemize

The line discipline module does not check if write-side flow control is in effect before forwarding
data downstream.  It expects the downstream module or driver to queue the messages on its queue
until flow control is lifted.

@subsubsection EUC Handling in ldterm

The idea of letting post-processing (the o_flags) happen off the host processor is not recommended
unless the board software is prepared to deal with international (@dfn{EUC}) character sets
properly.  The reason for this is that post-processing must take the @dfn{EUC} information into
account.  ldterm knows about the screen width of characters (that is, how many columns are taken by
characters from each given code set on the current physical display) and it takes this width into
account when calculating tab expansions.  When using multi-byte characters or multi-column
characters ldterm automatically handles tab expansion (when @constant{TAB3} is set) and does not
leave this handling to a lower module or driver.

As an example, consider the @cite{3B2 PORTS} board that has a processor and runs firmware on the board
that can handle output post-processing.  However, the firmware on the @cite{PORTS} board has no
knowledge of @dfn{EUC} unless one can change the firmware.  Therefore, with some @dfn{EUC} code sets,
particularly those where number of bytes in a character is not equivalent to the width of the
character on the screen (for example, 3 byte codes that take only 2 screen columns), the @cite{PORTS}
board's firmware miscalculates the number of spaces required to expand the tab.  Hence, if the board
is allowed to handle tab expansion, it may get the expansion wrong in some cases.

By default multi-byte handling by ldterm is turned off.  When ldterm receives an EUC_WSET
@command{ioctl} call, it turns multi-byte processing on, if it is essential to properly handle the
indicated code set.  Thus, if one is using single byte 8-bit codes and has no special multi-column
requirements, the special multi-column processing is not used at all.  This means that multi-byte
processing does not reduce the processing speed or efficiency of ldterm unless it is actually used.

The following describes how the @dfn{EUC} handling in ldterm works:

First, the multi-byte and multi-column character handling is only enabled when the EUC_WSET
@command{ioctl} indicates that one of the following conditions is met:

@itemize @bullet
@item Code set consists of more than one byte (including the SS2 and/or SS3) of characters, or

@item Code set requires more than one column to display on the current device, as indicated in the
EUC_WSET structure.

@end itemize

Assuming that one or more of the above conditions, @dfn{EUC} handling is enabled.  At this point, a
parallel array (see ldterm_mod structure) used for other information, is allocated and a pointer to
it is stored in t_eucp_mp.  The parallel array which it holds is pointed to by t_eucp.  The
t_codeset field holds the flag that indicates which of the code sets is currently being processed on
the read-side.  When a byte with the high bit arrives, it is checked to see if it is SS2 or SS3.  If
so, it belongs to code set 2 or 3.  Otherwise, it is a byte that comes from code set 1.  Once the
extended code set flag has been set, the input processor retrieves the subsequent bytes, as they
arrive, to build one multi-byte character.  The counter field t_eucleft tells the input processor
how many bytes remain to be read for the current character.  The parallel array t_eucp holds for
each logical character in the canonical buffer its display width.  During erase processing,
positions in the parallel array are consulted to figure out how many backspaces need to be sent to
erase each logical character.  (In canonical mode, one backspace of input erases one logical
character, no matter how many bytes or columns that character consumes.) This greatly simplifies
erase processing for @dfn{EUC}.

The t_maxeuc field holds the maximum length, in memory bytes, of the @dfn{EUC} character mapping
currently in use.  The eucwioc field is a sub-structure that holds information about each extended
code set.

The t_eucign field aids in output post-processing (tab expansion).  When characters are output,
ldterm keeps a column to indicate what the current cursor column is supposed to be.  When it sends
the first byte of an extended character, it adds the number of columns required for that character
to the output column.  It then subtracts one from the total width in memory bytes of that character
and stores the result in t_eucign.  This field tells ldterm how many subsequent bytes to ignore for
the purposes of column calculation.  (ldterm calculates the appropriate number of columns when it
sees the first byte of the character.)

The field t_eucwarn is a counter for occurrences of bad extended characters.  It is mostly useful
for debugging.

There are two relevant files for handling multi-byte characters: @header{euc.h} and
@header{eucioctl.h}.  The @header{eucioctl.h} contains the structure that is passed with EUC_WSET
and EUC_WGET calls.  The normal way to use this structure is to get @constant{CSWIDTH} (see note
below) from the locale via a mechanism such as getwidth or setlocale and then copy the values into
the structure in @header{eucioctl.h}, and send the structure via an @streamio{I_STR} @command{ioctl}
call.  The EUC_WSET call informs the ldterm module about the number of bytes in extended characters
and how many columns the extended characters from each set consume on the screen.  This allows
ldterm to treat multi-byte characters as single entities for the purpose of erase processing and to
correctly calculate tab expansions for multi-byte characters.

@ignore
LC_CTYPE (instead of @constant{CSWIDTH}) should be used in the environment in UXP/V systems.  See
@manpage{chrtbl(8)} for more information.
@end ignore

The file @header{euc.h} has the structure with fields for @dfn{EUC} width, screen width, and wide
character width.  The following functions are used to set and get @dfn{EUC} widths (these functions
assume the environment where the eucwidth_t structure is needed and available):

@smallexample
#include <sys/eucioctl.h>       /* need some other things too, like
                                   stropts.h */

struct eucioc eucw;     /* for EUC_WSET/EUC_WGET to line discipline */
eucwidth_t width;       /* return struct from_getwidth() */

/*
 * set_euc Send EUC code widths to line discipline.
 */
set_euc(e)
        struct eucioc *e;
@{
    struct strioctl sb;

    sb.ic_cmd = EUC_WSET;
    sb.ic_timout = 15;
    sb.ic_len = sizeof(struct eucioc);
    sb.ic_dp = (char *) e;

    if (ioctl(0, I_STR, &sb) < 0)
        fail();
@}

/*
 * euclook Get current EUC code widths from line discipline.
 */
euclook(e)
        struct eucioc *e;
@{
    struct strioctl sb;

    sb.ic_cmd = EUC_WGET;
    sb.ic_timout = 15;
    sb.ic_len = sizeof(struct eucioc);
    sb.ic_dp = (char *) e;
    if (ioctl(0, I_STR, &sb) < 0)
        fail();

    printf("CSWIDTH=%d:%d, %d:%d, %d:%d0",
           e->eucw[1], e->scrw[1],
           e->eucw[2], e->scrw[2], e->eucw[3], e->scrw[3]);
@}
@end smallexample

@ignore
@subsection Support of termiox(7)

The brief discussion of multiple byte character handling by the ldterm module was provided here for
those interested in internationalization applications in UXP/V.  More detailed descriptions may be
obtained from product-related documents, for example, UXP/V Programmer's Guide:
Internationalization.

UXP/V includes the extended general terminal interface (see @manref{termiox(7)}) that supplements the
@manpage{termio(7)} general terminal interface by adding for asynchronous hardware flow control, isochronous
flow control and clock modes, and local implementations of additional asynchronous features.
@manpage{termiox(7)} is handled by hardware drivers if the board (e.g., EPORTS) supports it.

Hardware flow control supplements the @manpage{termio(7)} @constant{IXON}, @constant{IXOFF}, and
@constant{IXANY} character flow control.  The @manpage{termiox(7)} interface allows for both unidirectional
and bidirectional hardware flow control.  Isochronous communication is a variation of asynchronous
communication where two communicating devices provide transmit and/or receive clock to each other.
Incoming clock signals can be taken from the baud rate generator on the local isochronous port
controller.  Outgoing signals are sent on the receive and transmit baud rate generator on the local
isochronous port controller.

Terminal parameters are specified in the termiox structure that is defined in the
@header{termiox.h}.
@end ignore

@subsection Hardware Emulation Module

If a @dfn{Stream} supports a terminal interface, a driver or module that understands all ioctls to
support terminal semantics (specified by termio and termios) is needed.  If there is no hardware
driver that understands all @command{ioctl} commands downstream from the ldterm module, a hardware
emulation module must be placed downstream from the line discipline module.  The function of the
hardware emulation module is to understand and acknowledge the ioctls that may be sent to the
process at the @dfn{Stream head} and to mediate the passage of control information downstream.  The
combination of the line discipline module and the hardware emulation module behaves as if there were
an actual terminal on that @dfn{Stream}.

The hardware emulation module is necessary whenever there is no @dfn{tty} driver at the end of the
@dfn{Stream}.  For example, it is necessary in a @dfn{pseudo-tty} situation where there is process
to process communication on one system (this is discussed later in this chapter) and in a network
situation where a termio interface is expected (e.g., remote login) but there is no @dfn{tty} driver
on the @dfn{Stream}.

Most of the actions taken by the hardware emulation module are the same regardless of the underlying
architecture.  However, there are some actions that are different depending on whether the
communication is local or remote and whether the underlying transport protocol is used to support
the remote connection.  For example, @dfn{NTTY} is a hardware emulation module supported by
@cite{AT&T} in its StarLAN networking environment.  This hardware emulation module behaves in a way
understood by the @dfn{URP} protocol driver that exists below @dfn{NTTY}.  On receipt of a
@termio{TCSBRK} @command{ioctl}, @dfn{NTTY} sends an @msg{M_BREAK} message downstream.  When the baud
rate is 0, the hardware emulation module sends a @dfn{TPI} message requesting a disconnect.  These
actions are valid for a network situation but may not make sense in other environments when there is
no module/driver below to understand the @dfn{TPI} messages or handle @msg{M_BREAK} messages.

Each hardware emulation module has an open, close, read queue @command{put} procedure, and write
queue @command{put} procedure.

The hardware emulation module does the following:


@itemize @bullet
@item Processes, if appropriate, and acknowledges receipt of the following ioctls on its write queue
by sending an @msg{M_IOCACK} message back upstream: @termio{TCSETA}, @termio{TCSETAW},
@termio{TCSETAF}, @termio{TCSETS}, @termio{TCSETSW}, @termio{TCSETSF},
@termio{TCGETA}, @termio{TCGETS}, and @termio{TCSBRK}.

@item Acknowledges the Extended @cite{UNIX} Code (@dfn{EUC}) ioctls.

@item If the environment supports windowing, it acknowledges the windowing ioctls
@termio{TIOCSWINSZ}, @termio{TIOCGWINSZ}, and @termio{JWINSIZE}.  If the environment does not
support windowing, an @msg{M_IOCNAK} message is sent upstream.

@item If any other ioctls are received on its write queue, it sends an @msg{M_IOCNAK} message
upstream.

@item When the hardware emulation module receives an @msg{M_IOCTL} message of type @termio{TCSBRK}
on its write queue, it sends an @msg{M_IOCACK} message upstream and the appropriate message
downstream.  For example, an @msg{M_BREAK} message could be sent downstream.

@item When the hardware emulation module receives an @msg{M_IOCTL} message on its write queue to set
the baud rate to 0 (@termio{TCSETAW} with @constant{CBAUD} set to B0), it sends an @msg{M_IOCACK}
message upstream and an appropriate message downstream; for networking situations this will probably
be an @msg{M_PROTO} message which is a @dfn{TPI} @code{T_DISCON_REQ} message requesting the
transport provider to disconnect.

@item All other messages (@msg{M_DATA}, etc.) not mentioned here are passed to the next module or
driver in the @dfn{Stream}.

@end itemize

The hardware emulation module processes messages in a way consistent with the driver that exists
below.

@node Pseudo-Terminal Subsystem
@section Pseudo-Terminal Subsystem

The @dfn{STREAMS}-based pseudo-terminal subsystem provides the user with an interface that is
identical to the @dfn{STREAMS}-based terminal subsystem described earlier in this chapter.  The
pseudo-terminal subsystem (@dfn{pseudo-tty}) supports a pair of @dfn{STREAMS}-based devices called
the master device and slave device.  The slave device provides processes with an interface that is
identical to the terminal interface.  However, where all devices, which provide the terminal
interface, have some kind of hardware device behind them, the slave device has another process
manipulating it through the master half of the pseudo terminal.  Anything written on the master
device is given to the slave as an input and anything written on the slave device is presented as an
input on the master side.

@figref{44} illustrates the architecture of the @dfn{STREAMS}-based pseudo-terminal subsystem.  The
master driver called ptm is accessed through the clone driver (see @manref{clone(7)}) and is the controlling
part of the system.  The slave driver called pts works with the line discipline module and the
hardware emulation module to provide a terminal interface to the user process.  An optional
packetizing module called pckt is also provided.  It can be pushed on the master side to support
packet mode (this is discussed later).

The number of @dfn{pseudo-tty} devices that can be installed on a system is dependent on available
memory.

@subsection Line Discipline Module

In the @dfn{pseudo-tty} subsystem, the line discipline module is pushed on the slave side to present
the user with the terminal interface.

ldterm may turn off the processing of the c_iflag, c_oflag, and c_lflag fields to allow processing
to take place elsewhere.  The ldterm module may also turn off all canonical processing when it
receives an @msg{M_CTL} message with the MC_NO_CANON command in order to support remote mode (this
is discussed later).  Although ldterm passes through messages without processing them, the
appropriate flags are set when a "get" @command{ioctl}, such as @termio{TCGETA} or @termio{TCGETS},
is issued to indicate that canonical processing is being performed.

@figuresized{SPG_fig44,44,@dfn{Pseudo-tty} Subsystem Architecture,4in}

@subsection @dfn{Pseudo-tty} Emulation Module PTEM

Since the @dfn{pseudo-tty} subsystem has no hardware driver downstream from the ldterm module to
process the terminal @command{ioctl} calls, another module that understands the @command{ioctl}
commands is placed downstream from the ldterm.  This module, known as ptem, processes all of the
terminal @command{ioctl} commands and mediates the passage of control information downstream.

ldterm and ptem together behave like a real terminal.  Since there is no real terminal or modem in
the @dfn{pseudo-tty} subsystem, some of the @command{ioctl} commands are ignored and cause only an
acknowledgement of the command.  The ptem module keeps track of the terminal parameters set by the
various "set" commands such as @termio{TCSETA} or @termio{TCSETAW} but does not usually perform any
action.  For example, if one of the "set" ioctls is called, none of the bits in the c_cflag field of
termio has any effect on the pseudo terminal except if the baud rate is set to 0.  When setting the
baud rate to 0, it has the effect of hanging up the pseudo-terminal.

The pseudo-terminal has no concept of parity so none of the flags in the c_iflag that control the
processing of parity errors have any effect.  The delays specified in the c_oflag field are not also
supported.

The ptem module does the following:

@itemize @bullet
@item Processes, if appropriate, and acknowledges receipt of the following ioctls on its write queue
by sending an @msg{M_IOCACK} message back upstream: @termio{TCSETA}, @termio{TCSETAW},
@termio{TCSETAF}, @termio{TCSETS}, @termio{TCSETSW}, @termio{TCSETSF},
@termio{TCGETA}, @termio{TCGETS}, and @termio{TCSBRK}.

@item Keeps track of the window size; information needed for the @termio{TIOCSWINSZ},
@termio{TIOCGWINSZ}, and @termio{JWINSIZE} @command{ioctl} commands.

@item When it receives any other @command{ioctl} on its write queue, it sends an @msg{M_IOCNAK}
message upstream.

@item It passes downstream the following ioctls after processing them: @termio{TCSETA},
@termio{TCSETAW}, @termio{TCSETAF}, @termio{TCSETS}, @termio{TCSETSW}, @termio{TCSETSF},
@termio{TCSBRK}, and @termio{TIOCSWINSZ}.

@item ptem frees any @msg{M_IOCNAK} messages it receives on its read queue in case the pckt module
(pckt is described later) is not on the pseudo terminal subsystem and the above ioctls get to the
master's @dfn{Stream head} which would then send an @msg{M_IOCNAK} message.

@item In its open routine, the ptem module sends an @msg{M_SETOPTS} message upstream requesting
allocation of a controlling @dfn{tty}.

@item When the ptem module receives an @msg{M_IOCTL} message of type @termio{TCSBRK} on its read
queue, it sends an @msg{M_IOCACK} message downstream and an @msg{M_BREAK} message upstream.

@item When it receives an @command{ioctl} message on its write queue to set the baud rate to 0
(@termio{TCSETAW} with @constant{CBAUD} set to B0), it sends an @msg{M_IOCACK} message upstream and
a 0-length message downstream.

@item When it receives an @msg{M_IOCTL} of type @termio{TIOCSIGNAL} on its read queue, it sends an
@msg{M_IOCACK} downstream and an @msg{M_PCSIG} upstream where the signal number is the same as in
the @msg{M_IOCTL} message.

@item When the ptem module receives an @msg{M_IOCTL} of type @termio{TIOCREMOTE} on its read queue,
it sends an @msg{M_IOCACK} message downstream and the appropriate @msg{M_CTL} message upstream to
enable/disable canonical processing.

@item When it receives an @msg{M_DELAY} message on its read or write queue, it discards the message
and does not act on it.

@item When it receives an @msg{M_IOCTL} message with type @termio{JWINSIZE} on its write queue and
if the values in the jwinsize structure of ptem are not zero, it sends an @msg{M_IOCACK} message
upstream with the jwinsize structure.  If the values are zero, it sends an @msg{M_IOCNAK} message
upstream.

@item When it receives an @msg{M_IOCTL} message of type @termio{TIOCGWINSZ} on its write queue and
if the values in the winsize structure are not zero, it sends an @msg{M_IOCACK} message upstream
with the winsize structure.  If the values are zero, it sends an @msg{M_IOCNAK} message upstream.
It also saves the information passed to it in the winsize structure and sends a @dfn{STREAMS} signal
message for signal @signal{SIGWINCH} upstream to the slave process if the size changed.

@item When the ptem module receives an @msg{M_IOCTL} message with type @termio{TIOCGWINSZ} on its
read queue and if the values in the winsize structure are not zero, it sends an @msg{M_IOCACK}
message downstream with the winsize structure.  If the values are zero, it sends an @msg{M_IOCNAK}
message downstream.  It also saves the information passed to it in the winsize structure and sends a
@dfn{STREAMS} signal message for signal @signal{SIGWINCH} upstream to the slave process if the size
changed.

@item All other messages not mentioned above are passed to the next module or driver.

@end itemize

@subsubsection Data Structure

Each instantiation of the ptem module is associated with a local area.  These data are held in a
structure called ptem that has the following format:

@smallexample
struct ptem @{
    long cflags;          /* copy of c_flags */
    mblk_t *dack_ptr;     /* pointer to preallocated message block used
                             to send disconnect */
    queue_t *q_ptr;       /* pointer to ptem's read queue */
    struct winsize wsz;   /* structure to hold windowing information */
    unsigned short state; /* state of ptem entry */
@};
@end smallexample

When the ptem module is pushed onto the slave side @dfn{Stream}, a search of the ptem structure is
made for a free entry (state is not set to @constant{INUSE}).  The c_cflags of the termio structure
and the windowing variables are stored in cflags and wsz respectively.  The dack_ptr is a pointer to
a message block used to send a 0-length message whenever a hang-up occurs on the slave side.

@subsubsection Open and Close Routines

In the open routine of ptem a @dfn{STREAMS} message block is allocated for a 0-length message for
delivering a hang-up message; this allocation of a buffer is done before it is needed to ensure that
a buffer is available.  An @msg{M_SETOPTS} message is sent upstream to set the read-side @dfn{Stream
head} queues, to assign high and low water marks(512 and 256 respectively), and to establish a
controlling terminal.

The default values @constant{B300}, @constant{CS8}, @constant{CREAD}, and @constant{HUPCL} are
assigned to cflags, and @constant{INUSE} to the state field.

The open routine fails if:

@itemize @bullet
@item No free entries are found when the ptem structure is searched.
@item sflag is not set to @constant{MODOPEN}.
@item A 0-length message can not be allocated (no buffer is available).
@item A @code{stroptions} structure cannot be allocated.
@end itemize

The close routine is called on the last close of the slave side @dfn{Stream}.  Pointers to read and
write queue are cleared and the buffer for the 0-length message is freed.

@subsection Remote Mode

A feature known as remote mode is available with the @dfn{pseudo-tty} subsystem.  This feature is
used for applications that perform the canonical function normally done by the ldterm module and
@dfn{tty} driver.  The remote mode allows applications on the master side to turn off the canonical
processing.  An @key{]} is issued on the master side to enter the remote mode.  When this occurs, an
@msg{M_CTL} message with the command MC_NO_CANON is sent to the ldterm module indicating that data
should be passed when received on the read-side and no canonical processing is to take place.  The
remote mode may be disabled by

@smallexample
ioctl(fd, TIOCREMOTE, 0).
@end smallexample

@subsection Packet Mode

The @dfn{STREAMS}-based pseudo-terminal subsystem also supports a feature called packet mode.  This
is used to inform the process on the master side when state changes have occurred in the
@dfn{pseudo-tty}.  Packet mode is enabled by pushing the pckt module on the master side.  Data
written on the master side is processed normally.  When data are written on the slave side or when
other messages are encountered by the pckt module, a header is added to the message so it can be
subsequently retrieved by the master side with a getmsg operation.

The pckt module does the following:

@itemize @bullet

@item When a message is passed to this module on its write queue, the module does no processing and
passes the message to the next module or driver.

@item The pckt module creates an @msg{M_PROTO} message when one of the following messages is passed
to it: @msg{M_DATA}, @msg{M_IOCTL}, @msg{M_PROTO}/@msg{M_PCPROTO}, @msg{M_FLUSH},
@msg{M_START}/@msg{M_STOP}, @msg{M_STARTI}/@msg{M_STOPI}, and @msg{M_READ}.

All other messages are passed through.  The @msg{M_PROTO} message is passed upstream and retrieved
when the user issues @manpage{getmsg(2)}.

@item If the message is an @msg{M_FLUSH} message, pckt does the following: If the flag is
@constant{FLUSHW}, it is changed to @constant{FLUSHR} (because @constant{FLUSHR} was the original
flag before the pts driver changed it), packetized into an @msg{M_PROTO} message, and passed
upstream.  To prevent the @dfn{Stream head}'s read queue from being flushed, the original
@msg{M_FLUSH} message must not be passed upstream.

If the flag is @constant{FLUSHR}, it is changed to @constant{FLUSHW}, packetized into an
@msg{M_PROTO} message, and passed upstream.  In order to flush of the write queues properly, an
@msg{M_FLUSH} message with the @constant{FLUSHW} flag set is also sent upstream.

If the flag is @constant{FLUSHRW}, the message with both flags set is packetized and passed
upstream.  An @msg{M_FLUSH} message with the @constant{FLUSHW} flag set is also sent upstream.

@end itemize

@subsection Pseudo-tty Drivers ptm and pts

In order to use the @dfn{pseudo-tty} subsystem, a node for the master side driver /dev/ptmx and N
number of slave drivers (N is determined at installation time) must be installed.  The names of the
slave devices are /dev/pts/M where M has the values 0 through N-1.  A user accesses a
@dfn{pseudo-tty} device through the master device (called ptm) that in turn is accessed through the
clone driver (see @manref{clone(7)}).  The master device is set up as a clone device where its major device
number is the major for the clone device and its minor device number is the major for the ptm
driver.

The master pseudo driver is opened via the @manref{open(2)} system call with /dev/ptmx as the device to be
opened.  The clone open finds the next available minor device for that major device; a master device
is available only if it and its corresponding slave device are not already open.  There are no nodes
in the file system for master devices.

When the master device is opened, the corresponding slave device is automatically locked out.  No
user may open that slave device until it is unlocked.  A user may invoke a function grantpt that
will change the owner of the slave device to that of the user who is running this process, change
the group id to @dfn{tty}, and change the mode of the device to 0620.  Once the permissions have
been changed, the device may be unlocked by the user.  Only the owner or super-user can access the
slave device.  The user must then invoke the unlockpt function to unlock the slave device.slave
driver, open Before opening the slave device, the user must call the ptsname function to obtain the
name of the slave device.  The functions grantpt, unlockpt, and ptsname are called with the file
descriptor of the master device.  The user may then invoke the open system call with the name that
was returned by the ptsname function to open the slave device.

The following example shows how a user may invoke the @dfn{pseudo-tty} subsystem:

@smallexample
    int fdm, fds;
    char *slavename;
    extern char *ptsname();

    fdm = open("/dev/ptmx", O_RDWR); /* open master */
    grantpt(fdm);                    /* change permission of slave */
    unlockpt(fdm);                   /* unlock slave */
    slavename = ptsname(fdm);        /* get name of slave */
    fds = open(slavename, O_RDWR);   /* open slave */
    ioctl(fds, I_PUSH, "ptem");      /* push ptem */
    ioctl(fds, I_PUSH, "ldterm");    /* push ldterm */
@end smallexample

Unrelated processes may open the pseudo device.  The initial user may pass the master file
descriptor using a @dfn{STREAMS}-based pipe or a slave name to another process to enable it to open
the slave.  After the slave device is open, the owner is free to change the permissions.

Certain programs such as write and wall are set group-id (setgid) to @dfn{tty} and are also able to
access the slave device.

After both the master and slave have been opened, the user has two file descriptors which provide
full duplex communication using two @dfn{Streams}.  The two @dfn{Streams} are automatically
connected.  The user may then push modules onto either side of the @dfn{Stream}.  The user also
needs to push the ptem and ldterm modules onto the slave side of the pseudo-terminal subsystem to
get terminal semantics.

The master and slave drivers pass all @dfn{STREAMS} messages to their adjacent queues.  Only the
@msg{M_FLUSH} needs some processing.  Because the read queue of one side is connected to the write
queue of the other, the @constant{FLUSHR} flag is changed to @constant{FLUSHW} flag and vice versa.

When the master device is closed, an @msg{M_HANGUP} message is sent to the slave device which will
render the device unusable.  The process on the slave side gets the errno @errno{ENXIO} when
attempting to write on that @dfn{Stream} but it will be able to read any data remaining on the
@dfn{Stream head} read queue.  When all the data have been read, read returns 0 indicating that the
@dfn{Stream} can no longer be used.

On the last close of the slave device, a 0-length message is sent to the master device.  When the
application on the master side issues a read or getmsg and 0 is returned, the user of the master
device decides whether to issue a close that dismantles the pseudo-terminal subsystem.  If the
master device is not closed, the @dfn{pseudo-tty} subsystem will be available to another user to
open the slave device.

Since 0-length messages are used to indicate that the process on the slave side has closed and
should be interpreted that way by the process on the master side, applications on the slave side
should not write 0-length messages.  If that occurs, the write returns 0, and the 0-length message
is discarded by the ptem module.

The standard @dfn{STREAMS} system calls can access the @dfn{pseudo-tty} devices.  The slave devices
support the @constant{O_NDELAY} and @constant{O_NONBLOCK} flags.  Since the master side does not act
like the terminal, if @constant{O_NONBLOCK} or @constant{O_NDELAY} is set, read on the master side
returns with errno set to @errno{EAGAIN} if no data are available, and write returns -1 with errno
set to @errno{EAGAIN} if there is internal flow control.

The master driver supports the @termio{ISPTM} and @termio{UNLKPT} ioctls that are used by the
functions grantpt, unlockpt, and ptsname (see @manref{grantpt(3)}, @manref{unlockpt(3)},
@manref{ptsname(3)}).  The @command{ioctl} @termio{ISPTM} determines whether the file descriptor is
that of an open master device.  On success, it returns the major/minor number (type dev_t) of the
master device which can be used to determine the name of the corresponding slave device.  The
@command{ioctl} @termio{UNLKPT} unlocks the master and slave devices.  It returns 0 on success.  On
failure, the errno is set to @errno{EINVAL} indicating that the master device is not open.

The format of these commands is:

@smallexample
int ioctl(fd, command, arg)
    int fd, command, arg
@end smallexample

where command is either @termio{ISPTM} or @termio{UNLKPT} and arg is 0.  On failure, -1 is returned.

When data are written to the master side, the entire block of data written is treated as a single
line.  The slave side process reading the terminal receives the entire block of data.  Data are not
input edited by the ldterm module regardless of the terminal mode.  The master side application is
responsible for detecting an interrupt character and sending an interrupt signal @signal{SIGINT} to
the process in the slave side. This can be done as follows:

@smallexample
ioctl(fd, TIOCSIGNAL, SIGINT)
@end smallexample

where @signal{SIGINT} is defined in the file @header{signal.h}.  When a process on the master side
issues this @command{ioctl}, the argument is the number of the signal that should be sent.  The
specified signal is then sent to the process group on the slave side.

To summarize, the master driver and slave driver have the following characteristics:

@itemize @bullet

@item Each master driver has one-to-one relationship with a slave device based on major/minor device
numbers.

@item Only one open is allowed on a master device.  Multiple opens are allowed on the slave device
according to standard file mode and ownership permissions.

@item Each slave driver minor device has a node in the file system.

@item An open on a master device automatically locks out an open on the corresponding slave driver.

@item A slave cannot be opened unless the corresponding master is open and has unlocked the slave.

@item To provide a @dfn{tty} interface to the user, the ldterm and ptem modules are pushed on the
slave side.

@item A close on the master sends a hang-up to the slave and renders both @dfn{Streams} unusable
after all data have been consumed by the process on the slave side.

@item The last close on the slave side sends a 0-length message to the master but does not sever the
connection between the master and slave drivers.

@end itemize

@subsubsection grantpt

The grantpt function changes the mode and the ownership of the slave device that is associated with
the given master device.  Given a file descriptor @var{fd}, grantpt first checks that the file
descriptor is that of the master device.  If so, it obtains the name of the associated slave device
and sets the user id to that of the user running the process and the group id to @dfn{tty}.  The
mode of the slave device is set to 0620.

If the process is already running as root, the permission of the slave can be changed directly
without invoking this function.  The interface is:

@smallexample
grantpt(int fd);
@end smallexample

The grantpt function returns 0 on success and -1 on failure.  It fails if one or more of the
following occurs: @var{fd} is not an open file descriptor, @var{fd} is not associated with a master
device, the corresponding slave could not be accessed, or a system call failed because no more
processes could be created.

@subsubsection unlockpt

The unlockpt function clears a lock flag associated with a master/slave device pair.  Its interface
is:

@smallexample
unlockpt(int fd);
@end smallexample

The unlockpt returns 0 on success and -1 on failure.  It fails if one or more of the following
occurs: @var{fd} is not an open file descriptor or @var{fd} is not associated with a master device.

@subsubsection ptsname

The ptsname function returns the name of the slave device that is associated with the given master
device.  It first checks that the file descriptor is that of the master.  If it is, it then
determines the name of the corresponding slave device /dev/pts/ and returns a pointer to a string
containing the null-terminated path name.  The return value points to static data whose content is
overwritten by each call.  The interface is:

@smallexample
char *ptsname(int fd)
@end smallexample

The ptsname function returns a non-@samp{NULL} path name upon success and a @samp{NULL} pointer upon
failure.  It fails if one or more of the following occurs: @var{fd} is not an open file descriptor
or @var{fd} is not associated with the master device.

@node STREAMS Synchronization
@chapter STREAMS Synchronization
@cindex STREAMS, synchronization
@cindex synchronization, STREAMS
@menu
* STREAMS Framework Integrity::
* MP Message Ordering::
* MP-UNSAFE Modules::
* MP Put and Service Procedures::
* MP Timeout and Buffer Callbacks::
* MP Open and Close Procedures::
* MP Module Unloading::
* MP Locking::
* MP Asynchronous Callbacks::
* Stream Integrity::
@end menu

This chapter describes how to multi-thread a @dfn{STREAMS} driver or module.  It covers the
necessary conversion topics so that new and existing @dfn{STREAMS} modules and drivers will run in
a symmetrical multi-processor kernel.  This chapter covers primarily @dfn{STREAMS} specific
multiprocessor issues and techniques.

@cite{Linux} is a fully @dfn{SMP} capable operating system able to make effective use of the
available parallelism of the symmetric shared-memory multiprocessor computer.  All kernel subsystems
are multiprocessor safe: scheduler, virtual memory, file systems, block, character, STREAMS input
and output, networking protocols and device drivers.

@dfn{STREAMS} in an @dfn{MP} environment introduces some new concepts and terminology as follows:

@table @dfn

@item Thread
sequence of instructions executed within the context of a process

@item Lock
mechanism for restricting access to data structures

@item Single Threaded
restricting access to a single thread

@item Multi-Threaded
allowing two or more threads access

@item Multiprocessing
two or more CPUs concurrently executing the operating system

@end table

@node STREAMS Framework Integrity
@section STREAMS Framework Integrity
@cindex STREAMS, framework integrity
@cindex framework integrity, STREAMS

The @dfn{STREAMS} framework guarantees the integrity of the @dfn{STREAMS} scheduler and related data
structures, such as the @mantype{queue(9)}, @mantype{msgb(9)}, and @mantype{datab(9)} structures,
assuming that the module properly accesses global operating system data structures, utilities and
facilities.

The @member{q_next} and @member{q_ptr} files of the @mantype{queue(9)} structure will not be
modified by the system while a thread is actively executing within a synchronous entry point.  The
@member{q_next} field of the @mantype{queue(9)} structure could change while a thread is executing
within an asynchronous entry point.

A @dfn{STREAMS} module or driver must not call another module's @command{put} or @command{service}
procedure directly.  The @dfn{STREAMS} utilities @manref{putnext(9)}, @manref{put(9)} and others
described in @ref{STREAMS Utilities} must be used to pass messages to another queue.  Calling
another @dfn{STREAMS} module or driver directly circumvents the @dfn{MP-STREAMS} framework.

To make a @dfn{STREAMS} module or driver @dfn{MP-SAFE} requires that the integrity of private module
data structures be protected by the module itself.  The integrity of private module data structures
can be maintained either by using the @dfn{MP-STREAMS} framework to control concurrency and
synchronize access to private data structures, or by the use of private locks within the module, or a
combination of the two.


@node MP Message Ordering
@section MP Message Ordering
@cindex message ordering

@dfn{STREAMS} guarantees the ordering of messages along a @dfn{Stream} if all the modules in the
@dfn{Stream} preserve message ordering internally.  This ordering guarantee only applies to message
that are sent along the same @dfn{Stream} and produced by the same source.

@dfn{STREAMS} does not guarantee that a message has been seen by the next @command{put} procedure
by the time that @manref{putnext(9)} or @manref{qreply(9)} return.  Under some circumstances,
invocation of the next module's @command{put} procedure might be deferred until after an exclusive
thread leaves a synchronization boundary.

Regardless of @dfn{STREAMS} integrity protection, or the presence of synchronization barriers, at
most one thread will be executing a given module's @command{service} procedure.

@node MP-UNSAFE Modules
@section MP-UNSAFE Modules

@dfn{STREAMS} supports modules that are not MP-SAFE and that are expecting to run in a uniprocessor
environment.

By default, all @dfn{STREAMS} modules and drivers are considered @dfn{MP-UNSAFE} unless configured
into the system as @dfn{MP-SAFE}.

Unsafe drivers run with only the minimum of modification.  Unsafe drivers are synchronized at the
level @constant{SQLVL_MODULE}, which implies that, at any time, only one processor in the entire
system is executing the module's @dfn{STREAMS} code.  @dfn{MP-UNSAFE} modules might not gain any
performance advantage by being run in a multiprocessor environment.

@dfn{MP-UNSAFE} modules that access data structures private to other @dfn{STREAMS} modules must be
synchronized at a broader level of synchronization.  All such cooperating modules must be run with
synchronization at the level @constant{SQLVL_ELSEWHERE}, with a synchronization queue that is shared
across all the pertinent modules.

@dfn{MP-UNSAFE} modules are still responsible for cancelling all outstanding callbacks in their
@member{qi_qclose} procedure.

@subsection MP-UNSAFE Interrupt Service Routines

@dfn{MP-UNSAFE} modules synchronized at synchronization level @constant{SQLVL_MODULE},
@constant{SQLVL_ELSEWHERE}, or @constant{SQLVL_GLOBAL} are singly threaded within the @dfn{STREAMS}
framework.  However, interrupt service routines exist outside the @dfn{STREAMS} framework.
Interrupt service routines that invoke @dfn{STREAMS} utilities will have execution of those
utilities deferred until after all threads have left the synchronization barrier.

@subsection MP-UNSAFE Shared Data Structures

Modules that share data structure(s), and that are to be protected by @dfn{STREAMS} synchronization,
must be configured at the same level of synchronization.

@subsection MP-UNSAFE Sleeping

An @dfn{MP-UNSAFE} module that must wait in its @command{open} or @command{close} procedure for a
message from another @dfn{STREAMS} module must wait outside of all synchronization barriers;
otherwise the responding thread might never be allowed to enter the synchronization barrier to invoke
the module's @command{put} or @command{service} procedure.  Sleeping outside the synchronization
barriers is accomplished by using @manref{qwait(9)} or @manref{qwait_sig(9)}.

Modules using @dfn{STREAMS} synchronization barriers, either explicitly by configuration, or by
default, must use @manref{qwait(9)} and @manref{qwait_sig(9)} instead of @manref{CV_WAIT(9)} or
@manref{CV_WAIT_SIG(9)} from within @member{qi_qopen} and @member{qi_qclose}
procedures.@footnote{Modules are not permitted to sleep outside of their queue open and close
procedures.  Attempting to sleep in a @command{put} or @command{service} procedure will panic most
kernels.}

@node MP Put and Service Procedures
@section MP Put and Service Procedures

The @dfn{STREAMS} utilities @manref{qprocson(9)} and @manref{qprocsoff(9)} enable and disable the
@command{put} and @command{service} procedures of a queue pair.  Prior to a call to
@manref{qprocson(9)} and after a call to @manref{qprocsoff(9)}, the module's @command{put} and
@command{service} procedures are disabled.  Messages flow around the module as if it were not
present in the @dfn{Stream}.

@manref{qprocson(9)} must be called by the first @manref{open(2)} of a module, but only after
allocation and initialization of any module resources or private data structures upon which the
@command{put} and @command{service} procedures depend.  @manref{qprocsoff(9)} must be called by the
@manref{close(2)} routine of a module before deallocating any resources on which the @command{put}
and @command{service} procedures depend.

For example, it is typical for a module's @member{qi_qopen} procedure to allocate a private data
structure and associate it with the read- and write-queue @member{q_ptr} pointer for use by both the
@command{put} and @command{service} procedure.  It is typical for a module's @member{qi_qclose}
procedure to free the private data structure.  In this case, @manref{qprocson(9)} should not be
called until @emph{after} the private data structure has been allocated, initialized and attached to the
@member{q_ptr} pointers.  @manref{qprocsoff(9)} should be called @emph{before} deallocating the
private data structure and invalidating the @member{q_ptr} pointers.

@node MP Timeout and Buffer Callbacks
@section MP Timeout and Buffer Callbacks

The @manref{timeout(9)}, @manref{bufcall(9)} and @manref{esbbcall(9)} callbacks are asynchronous
when invoked from outside the @dfn{STREAMS} framework.  The means that the @manref{timeout(9)},
@manref{bufcall(9)}, or @manref{esbbcall(9)} callback functions might execute concurrent with module
procedures.

In contrast, under @cite{@value{PACKAGE_TITLE}}, when @manref{timeout(9)}, @manref{bufcall(9)}, and
@manref{esbbcall(9)} are invoked from within the @dfn{STREAMS} framework,@footnote{That is, they are
invoked from a module's @command{put} or @command{service} procedure, or from within another
synchronous callback, but not within a module's @command{open} or @command{close} procedures.} they
are equivalent to a call to @manref{qtimeout(9)}, @manref{qbufcall(9)} with the current
synchronization queue used as the @var{q} argument.  This is possible because @dfn{STREAMS} always
knows what queue's synchronous
procedures or callbacks it is running.

To provide for synchronous callbacks that can be invoked from outside the @dfn{STREAMS} framework,
the @manref{qtimeout(9)}, @manref{quntimeout(9)} @manref{qbufcall(9)}, and @manref{qunbufcall(9)}
@dfn{STREAMS} utilities are provided.  When using these utilities, the callback function is executed
inside any synchronization barrier associated with the queue that is passed to the function.

There are some restrictions on which queue pointer the @manref{qtimeout(9)} and @manref{qbufcall(9)}
can be passed when called from a module's @command{open} or @command{close} procedure, or when
called from outside @dfn{STREAMS} (at soft or hard interrupt).  The caller is responsible for the
validity of the queue pointer.  That is, the queue must be allocated and have procedures enabled
across the call.  The queue pointer argument of a module's @command{open}, @command{close},
@command{put}, or @command{service} procedure can always be passed as an argument to these functions
without any special consideration.  They should not be passed a @var{q->q_next} pointer, unless the
@dfn{Stream} is first frozen by the caller with @manref{freezestr(9)}.  They may be passed a
driver's read-side queue pointer, or a lower multiplexed @dfn{Stream}'s write-side queue pointer,
provided that the caller can ensure that the driver is not closed and the multiplexed @dfn{Stream}
is not unlinked across the call.  Reference to interior queue pairs must not be performed unless the
@dfn{Stream} has first been frozen by the caller with @manref{freezestre(9)}.

@node MP Open and Close Procedures
@section MP Open and Close Procedures

@dfn{STREAMS} modules are permitted to sleep in their @member{qi_qopen} and @member{qi_qclose}
procedures.  However, a module that uses synchronization of these procedures against @command{put}
and @command{service} procedures must leave the synchronization barrier before sleeping.  This is
accomplished by using the @manref{qwait(9)} and @manref{qwait_sig(9)} @dfn{STREAMS} utilities.
These utilities are similar to @manref{sleep(9)}, however, they release the synchronization barrier
before sleeping.

Because callback functions can be asynchronous with respect to the @dfn{STREAMS} framework, they
might execute concurrent with a module's @command{close} procedure.  It is the responsibility of the
module to cancel all outstanding callbacks before deallocating data structure upon which those
callbacks depend, and before returning from the @command{close} procedure.

A callback function scheduled with @manref{timeout(9)} or @manref{bufcall(9)} are guaranteed to have
been cancelled by the time that the corresponding @manref{untimeout(9)} or @manref{unbufcall(9)}
utilities return.  The same is true for @manref{qtimeout(9)}, @manref{qbufcall(9)},
@manref{quntimeout(9)} and @manref{qunbufcall(9)}.

@node MP Module Unloading
@section MP Module Unloading

@dfn{STREAMS} tracks kernel module references and prohibits a kernel module from unloading while
there is a reference to a statically allocated data structure contained within the kernel module.
If a @dfn{STREAMS} module does not cancel all callbacks in the module @command{close} procedure, the
associated kernel module must not be permitted to be unloaded.  @dfn{STREAMS} handles all references
with the exception of references to the free routine provided to @manref{esballoc(9)}.  @dfn{STREAMS}
loadable kernel modules that pass free routines to @manref{esballoc(9)} are responsible for
incrementing their own module counts upon the call to @manref{esballoc(9)} and decrementing them when
the @member{free_rtn} function exits.@footnote{On kernels supporting the mapping of addresses to
kernel modules, the esballoc function will hold a reference on the module until the corresponding free
function is called and reference counting of @manref{esballoc(9)} is also atutomatic.}

@node MP Locking
@section MP Locking

Basic spin locks or reader/writer locks can be used by @dfn{MP-SAFE} modules to protect module
private data structures.  When using locks, however, the following guidelines should be followed:

@itemize @bullet

@item Avoid holding module private locks across calls to @manref{putnext(9)}, @manref{qreply(9)}, or
other @dfn{STREAMS} utilities that invoke a @command{put} procedure, unless re-entrancy is provided.
Otherwise, the calling thread might reenter the same queue procedure and attempt to take the same
lock twice, causing a single-party deadlock scenario.

@item Do no hold module private locks, acquired in @command{put} or @command{service} procedures,
across the calls to @manref{qprocson(9)} or @manref{qprocsoff(9)}.  These utilities spin waiting for
all @command{put} and @command{service} procedures to exit, causing a single-party deadlock
scenario.

@item Do not hold locks, acquired in the @manref{timeout(9)} or @manref{bufcall(9)} callback
functions across calls to @manref{untimeout(9)} or @manref{unbufcall(9)}.  These utilities spin
waiting for the callback function to exit, causing a single-party deadlock scenario.

@end itemize

@node MP Asynchronous Callbacks
@section MP Asynchronous Callbacks

Interrupt service routines and other asynchronous callback functions require special care by the
@dfn{STREAMS} driver writer, because they can execute asynchronous to threads executing within the
@dfn{STREAMS} framework.

MP-SAFE modules, or modules using synchronization barriers can use the @manref{qtimeout(9)} and
@manref{qbufcall(9)} callbacks that are synchronous with respect to the @dfn{STREAMS} framework.
Under @cite{@value{PACKAGE_TITLE}}, even @manref{timeout(9)} and @manref{bufcall(9)} utilities are
synchronous with respect to the @dfn{STREAMS} framework when invoked from within a @member{qi_putp}
procedure, @member{qi_srvp} procedure, or a synchronous callback.  However, when invoked from
outside a @dfn{STREAMS} module procedure (or from within @member{qi_qopen} or @member{qi_qclose}
procedures, these functions generate asynchronous callbacks.

Because an asynchronous thread from outside of @dfn{STREAMS}can enter the driver at any time, the
driver writer is responsible for ensuring that the asynchronous callback function acquires the
necessary private locks before accessing private module data structures and releases those locks
before returning.  It is also the responsibility of the module to cancel any outstanding callback
functions (see @manref{untimeout(9)} and @manref{unbufcall(9)}) before the data structures upon
which they depend are deallocated and the module closed.

The following guidelines must be followed:

@itemize @bullet

@item Interrupt service routines must be disabled by the callback if the interrupt service routine
is accessing shared data structures with the callback function.

@item Outstanding callbacks from @manref{timeout(9)} and @manref{bufcall(9)} must be cancelled with
a call to @manref{untimeout(9)} or @manref{unbufcall(9)}.

@item Outstanding callbacks from @manref{esballoc(9)}, must be allowed to complete before the kernel
module is permitted to be unloaded.

@end itemize

@node Stream Integrity
@section Stream Integrity

The @member{q_next} field of the @mantype{queue(9)} structure can be dereferenced in that queue's
@member{qi_qopen}, @member{qi_qclose}, @member{qi_putp}, and @member{qi_srvp} procedures as well as
within any other synchronous procedure or callback (such as @manref{qtimeout(9)},
@manref{qbufcall(9)}, @manref{qwriter(9)}) predicated on a queue in the same @dfn{Stream}.

All code executing outside the @dfn{STREAMS} framework, such as interrupt service routines,
tasklets, network bottom halves, asynchronous @manref{timeout(9)}, @manref{bufcall(9)}, and
@manref{esballoc(9)} callback routines, are not permitted to dereference @member{q_next} for any
queue pair in any @dfn{Stream}.  Asynchronous procedures must use the @samp{next} version of all
functions (e.g, @samp{canputnext(q)} instead of @samp{canput(q->q_next)}).

@node Reference
@chapter Reference
@cindex reference
@menu
* Files::			STREAMS Files
* Modules::			STREAMS Modules
* Drivers::			STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions
@end menu

@node Files
@section Files
@cindex files

@subsection User Header Files

@unnumberedsubsubsec STREAMS

@ftable @header

@item stropts.h
User include file for the @dfn{STREAMS} options file.  This file includes ioctl definitions for the
@dfn{Stream Head}.  This file includes @header{sys/stropts.h}.
Files are organized this way for backward compatibility of header file locations.

@item sys/stropts.h
System include file for the @dfn{STREAMS} options file.  This file includes ioctl definitions for
the @dfn{Stream Head}.  This file is included by @header{stropts.h}.
Files are organized this way for backward compatibility of header file locations.

@end ftable

@unnumberedsubsubsec STREAMS logger

@ftable @header

@item log.h
User include file for the @dfn{STREAMS} logger.

@item sys/log.h

@item strlog.h
User include file for the @dfn{STREAMS} logger.

@item sys/strlog.h

@end ftable

@unnumberedsubsubsec STREAMS Administrative Driver

@ftable @header

@item sad.h
User include file for the @cite{STREAMS Administrative Driver}.

@item sys/sc.h

@item sys/sad.h

@end ftable

@subsection System Header Files

@unnumberedsubsubsec STREAMS

@ftable @header

@item sys/stream.h

@item sys/strsubr.h

@item sys/strconf.h

@item sys/strdebug.h

@end ftable

@unnumberedsubsubsec DDI/DKI

@ftable @header

@item sys/debug.h

@item sys/kmem.h

@item sys/cmn_err.h

@item sys/dki.h

@item sys/ddi.h
@cite{DDI/DKI} function declarations and defines for @dfn{@value{PACKAGE_TITLE}}.  Extension definitions will
be included when one or more of
@constant{_LFS_SOURCE},
@constant{_SVR4_SOURCE},
@constant{_AIX_SOURCE},
@constant{_HPUX_SOURCE},
@constant{_OSF_SOURCE},
@constant{_SUN_SOURCE},
@constant{_LIS_SOURCE} or
@constant{_UW7_SOURCE} are
defined.

@item sys/svr4ddi.h
@cite{SVR4 DDI} compatibility function declarations and defines.  This file should not be included
directly, but will be included from @header{sys/ddi.h} when
@constant{_SVR4_SOURCE}
is defined.

@item sys/aixddi.h
@cite{AIX DDI} compatibility function declarations and defines.  This file should not be included
directly, but will be included from @header{sys/ddi.h} when
@constant{_AIX_SOURCE}
is defined.

@item sys/hpuxddi.h
@cite{HP-UX DDI} compatibility function declarations and defines.  This file should not be included
directly, but will be included from @header{sys/ddi.h} when
@constant{_HPUX_SOURCE}
is defined.

@item sys/osfddi.h
@cite{OSF DDI} compatibility function declarations and defines.  This file should not be included
directly, but will be included from @header{sys/ddi.h} when
@constant{_OSF_SOURCE}
is defined.

@item sys/sunddi.h
@cite{Solaris DDI} compatibility function declarations and defines.  This file should not be included
directly, but will be included from @header{sys/ddi.h} when
@constant{_SUN_SOURCE}
is defined.

@item sys/uw7ddi.h
@cite{UnixWare DDI} compatibility function declarations and defines.  This file should not be included
directly, but will be included from @header{sys/ddi.h} when
@constant{_UW7_SOURCE}
is defined.

@end ftable

@unnumberedsubsubsec Miscellaneous

@ftable @header

@item sys/spec_fs_i.h

@item sys/streams/config.h

@end ftable

@node Modules
@section Modules
@cindex STREAMS, modules
@cindex modules, STREAMS

@menu
* Stream Head Module ("sth")::
* Connect Line Discipline Module ("connld")::
* Pipe Module ("pipemod")::
* STREAMS Configuration Module ("sc")::
@end menu

@node Stream Head Module ("sth")
@subsection Stream Head Module ("sth")
@cindex sth, module
@cindex modules, sth
@cindex Stream Head, module
@cindex modules, Stream Head

@node Connect Line Discipline Module ("connld")
@subsection Connect Line Discipline Module ("connld")
@cindex connld, module
@cindex modules, connld

@node Pipe Module ("pipemod")
@subsection Pipe Module ("pipemod")
@cindex pipemod, module
@cindex modules, pipemod
@cindex Pipe Module, module
@cindex modules, Pipe Module

@node STREAMS Configuration Module ("sc")
@subsection STREAMS Configuration Module ("sc")
@cindex sc, module
@cindex modules, sc
@cindex STREAMS Configuration, module
@cindex modules, STREAMS Configuration


@node Drivers
@section Drivers
@cindex STREAMS, drivers
@cindex drivers, STREAMS

@menu
* Clone Driver ("clone")::
* Echo Driver ("echo")::
* FIFO Driver ("fifo")::
* Log Driver ("log")::
* Named STREAMS Device Driver ("nsdev")::
* Null STREAM Driver ("nuls")::
* Pipe Driver ("pipe")::
* STREAMS Administrative Driver ("sad")::
@end menu


@node Clone Driver ("clone")
@subsection Clone Driver ("clone")
@cindex clone, driver
@cindex drivers, clone
@cindex Clone, driver
@cindex drivers, Clone

@node Echo Driver ("echo")
@subsection Echo Driver ("echo")
@cindex echo, driver
@cindex drivers, echo
@cindex Echo, driver
@cindex drivers, Echo

@node FIFO Driver ("fifo")
@subsection FIFO Driver ("fifo")
@cindex fifo, driver
@cindex drivers, fifo
@cindex FIFO, driver
@cindex drivers, FIFO

@node Log Driver ("log")
@subsection Log Driver ("log")
@cindex log, driver
@cindex drivers, log
@cindex Log, driver
@cindex drivers, Log

@node Named STREAMS Device Driver ("nsdev")
@subsection Named STREAMS Device Driver ("nsdev")
@cindex nsdev, driver
@cindex drivers, nsdev
@cindex Named STREAMS Device, driver
@cindex drivers, Named STREAMS Device

@node Null STREAM Driver ("nuls")
@subsection Null STREAM Driver ("nuls")
@cindex nuls, driver
@cindex drivers, nuls
@cindex Null STREAM, driver
@cindex drivers, Null STREAM

@node Pipe Driver ("pipe")
@subsection Pipe Driver ("pipe")
@cindex pipe, driver
@cindex drivers, pipe
@cindex Pipe, driver
@cindex drivers, Pipe

@node STREAMS Administrative Driver ("sad")
@subsection STREAMS Administrative Driver ("sad")
@cindex sad, driver
@cindex drivers, sad
@cindex STREAMS Administrative Driver, driver
@cindex drivers, STREAMS Administrative Driver


@node System Calls
@section System Calls
@cindex system calls

@subsection New System Calls

@dfn{@value{PACKAGE_TITLE}} suffers from the
inability to hook system calls that have been, otherwise, reserved in the @b{Linux} kernel for use
by @dfn{STREAMS}.  Therefore, these system calls are implemented as library calls in the
@file{libsttreams} library instead of as system calls in the @file{libc} library.

@multitable @columnfractions .30 .70
@item @manpage{getmsg(2)} @tab @manpage{getmsg(2)} is not normally implemented as a system call: it is a library call that calls @manpage{getpmsg(2)}.
@item @manpage{getpmsg(2)} @tab --
@item @manpage{putmsg(2)} @tab @manpage{putmsg(2)} is not normally implemented as a system call: it is a library call that calls @manpage{putpmsg(2)}.
@item @manpage{putpmsg(2)} @tab --
@item @manpage{fattach(2)} @tab --
@item @manpage{fdetach(2)} @tab (Note: HP-UX mentions a fdetach system call: I do not know why.)
@item @manpage{isastream(2)} @tab --
@end multitable

@subsection Modifications to Old System Calls

@multitable @columnfractions .30 .70
@item @manpage{pipe(2)} @tab --
@item @manpage{open(2)} @tab --
@item @manpage{fcntl(2)} @tab --
@item @manpage{ioctl(2)} @tab --
@item @manpage{signal(2)} @tab --
@item @manpage{poll(2)} @tab --
@item @manpage{select(2)} @tab --
@item @manpage{read(2)} @tab The @manpage{read(2)} system call is overloaded with an invalid length to implement the @manpage{getmsg(2)} and @manpage{getpmsg(2)} system calls.
@item @manpage{readv(2)} @tab --
@item @manpage{write(2)} @tab The @manpage{write(2)} system call is overloaded with an invalid length to implement the @manpage{putmsg(2)} and @manpage{putpmsg(2)} system calls.
@item @manpage{writev(2)} @tab --
@item @manpage{close(2)} @tab --
@end multitable

@node Input-Output Controls
@section Input-Output Controls
@cindex STREAMS, input-output controls
@cindex input-output controls, STREAMS

@multitable @columnfractions .30 .70
@item @streamio{I_NREAD} @tab --
@item @streamio{I_PUSH} @tab --
@item @streamio{I_POP} @tab --
@item @streamio{I_LOOK} @tab --
@item @streamio{I_FLUSH} @tab --
@item @streamio{I_SRDOPT} @tab --
@item @streamio{I_GRDOPT} @tab --
@item @streamio{I_STR} @tab --
@item @streamio{I_SETSIG} @tab --
@item @streamio{I_GETSIG} @tab --
@item @streamio{I_FIND} @tab --
@item @streamio{I_LINK} @tab --
@item @streamio{I_UNLINK} @tab --
@item @streamio{I_RECVFD} @tab non-@dfn{EFT} definition
@item @streamio{I_PEEK} @tab --
@item @streamio{I_FDINSERT} @tab --
@item @streamio{I_SENDFD} @tab --
@item @streamio{I_E_RECVFD} @tab @cite{Unixware}: @dfn{EFT} definition
@item @streamio{I_SWROPT} @tab --
@item @streamio{I_GWROPT} @tab --
@item @streamio{I_LIST} @tab --
@item @streamio{I_PLINK} @tab --
@item @streamio{I_PUNLINK} @tab --
@item @streamio{I_FLUSHBAND} @tab --
@item @streamio{I_CKBAND} @tab --
@item @streamio{I_GETBAND} @tab --
@item @streamio{I_ATMARK} @tab --
@item @streamio{I_SETCLTIME} @tab --
@item @streamio{I_GETCLTIME} @tab --
@item @streamio{I_CANPUT} @tab --
@item @streamio{I_SERROPT} @tab @cite{Solaris} only
@item @streamio{I_GERROPT} @tab @cite{Solaris} only
@item @streamio{I_ANCHOR} @tab @cite{Solaris} only
@item @streamio{I_S_RECVFD} @tab @cite{UnixWare} only
@item @streamio{I_STATS} @tab @cite{UnixWare} only
@item @streamio{I_BIGPIPE} @tab @cite{UnixWare} only
@item @streamio{I_GETTP} @tab @cite{UnixWare} only
@item @streamio{I_AUTOPUSH} @tab @cite{Mac OT} only
@item @streamio{I_HEAP_REPORT} @tab @cite{Mac OT} only
@item @streamio{I_FIFO} @tab @cite{Mac OT} only
@item @streamio{I_PUTPMSG} @tab @cite{Mac OT}
@item @streamio{I_GETPMSG} @tab @cite{Mac OT}
@item @streamio{I_PIPE} @tab @cite{Mac OT}
@end multitable

@node Module Entry Points
@section Module entry points
@cindex module entry points

@multitable @columnfractions .30 .70
@item @manpage{qopen(9)} @tab Module queue open procedure.
@item @manpage{put(9)} @tab Module queue put procedure.
@item @manpage{srv(9)} @tab Module queue service procedure.
@item @manpage{qadmin(9)} @tab Module queue administrative procedure.
@item @manpage{qclose(9)} @tab Module queue close procedure.
@item @manpage{timeout(9)} @tab Timeout callback.
@item @manpage{qtimeout(9)} @tab Timeout callback.
@item @manpage{bufcall(9)} @tab Buffer callback.
@item @manpage{qbufcall(9)} @tab Buffer callback.
@item @manpage{mi_bufcall(9)} @tab Buffer callback.
@item @manpage{freemsg(9)} @tab Buffer free routine callout.
@end multitable

@node Structures
@section Structures
@cindex structures

@subsection STREAMS Structures

@unnumberedsubsubsec Driver Structures

@multitable @columnfractions .30 .70
@item @type{cdevsw(9)} @tab Character device switch table.
@item @type{devinfo(9)} @tab Device information structure.
@end multitable

@unnumberedsubsubsec Module Structures

@multitable @columnfractions .30 .70
@item @type{fmodsw(9)} @tab Module switch table.
@item @type{modinfo(9)} @tab Module information structure.
@item @type{module_info(9)} @tab Module information structure.
@item @type{module_stat(9)} @tab Module statistics structure.
@end multitable

@unnumberedsubsubsec Stream Structures

@multitable @columnfractions .30 .70
@item @type{streamtab(9)} @tab Stream information table.
@item @type{streamadm(9)} @tab Stream administration table.
@item @type{stdata(9)} @tab Stream head data structure.
@item @type{shinfo(9)} @tab Stream head information structure.
@end multitable

@unnumberedsubsubsec Queue Structures

@multitable @columnfractions .30 .70
@item @type{queue(9)} @tab Message queue.
@item @type{qband(9)} @tab Message queue band.
@item @type{bandinfo(9)} @tab Message queue band information structure.
@item @type{qinit(9)} @tab Message queue initialization.
@item @type{queinfo(9)} @tab Message queue information structure.
@end multitable

@unnumberedsubsubsec Message Structures

@multitable @columnfractions .30 .70
@item @type{msgb(9)} @tab Message block.
@item @type{datab(9)} @tab Data block.
@item @type{mbinfo(9)} @tab Message block information structure.
@item @type{dbinfo(9)} @tab Data block information structure.
@end multitable

@unnumberedsubsubsec Ancilliary Structures

@multitable @columnfractions .30 .70
@item @type{strevent(9)} @tab STREAMS event structure.
@item @type{seinfo(9)} @tab STREAMS event information structure.
@item @type{strapush(9)} @tab STREAMS autopush structure.
@item @type{apinfo(9)} @tab STREAMS autopush information structure.
@end multitable

@unnumberedsubsubsec Additional Structures

@multitable @columnfractions .30 .70
@item @type{cred_t(9)} @tab User credentials.
@end multitable

@node Registration
@section Registration
@cindex registration

@subsection @value{PACKAGE_TITLE} Registration

@unnumberedsubsubsec Registration

@multitable @columnfractions .30 .70
@item @manpage{register_clone(9)} @tab Register a clone minor device number for a @dfn{STREAMS} driver.
@item @manpage{unregister_clone(9)} @tab Unregister a clone minor device number for a @dfn{STREAMS} driver.
@item @manpage{register_cmajor(9)} @tab Register file operations against a major device number.
@item @manpage{unregister_cmajor(9)} @tab Unregister file operations against a major device number.
@item @manpage{register_strdev(9)} @tab Register a @dfn{STREAMS} device against a device major number.
@item @manpage{unregister_strdev(9)} @tab Unregister a @dfn{STREAMS} device against a device major number.
@item @manpage{register_strdrv(9)} @tab Register a @dfn{STREAMS} driver.
@item @manpage{unregister_strdrv(9)} @tab Unregister a @dfn{STREAMS} driver.
@item @manpage{register_strmod(9)} @tab Register a @dfn{STREAMS} module.
@item @manpage{unregister_strmod(9)} @tab Unregister a @dfn{STREAMS} module.
@item @manpage{register_strnod(9)} @tab Register a @dfn{STREAMS} minor device node.
@item @manpage{unregister_strnod(9)} @tab Unregister a @dfn{STREAMS} minor device node.
@end multitable

@unnumberedsubsubsec Autopush

@multitable @columnfractions .30 .70
@item @manpage{autopush_add(9)} @tab Add an autopush list entry for a given @dfn{STREAMS} device number.
@item @manpage{autopush_del(9)} @tab Delete an autopush list entry for a given @dfn{STREAMS} device number.
@item @manpage{autopush_find(9)} @tab Find an autopush list entry for a given @dfn{STREAMS} device number.
@item @manpage{autopush_vml(9)} @tab Verify an autopush @dfn{STREAMS} module list.
@end multitable

@unnumberedsubsubsec Administration

@multitable @columnfractions .30 .70
@item @manpage{getadmin(9)} @tab Get the administration function pointer for a @dfn{STREAMS} module.
@item @manpage{getmid(9)} @tab Get the @dfn{STREAMS} module identifier by module name.
@end multitable

@node Message Handling
@section Message Handling
@cindex message handling

@subsection STREAMS Message Handling Utilities

@multitable @columnfractions .30 .70
@item @manpage{allocb(9)} @tab Allocate a @dfn{STREAMS} message and data block.
@item @manpage{esballoc(9)} @tab Allocate a @dfn{STREAMS} message and data block with a caller supplied data buffer.
@item @manpage{testb(9)} @tab Test if a @dfn{STREAMS} message can be allocated.
@item @manpage{bufcall(9)} @tab Install a @dfn{STREAMS} buffer callback.
@item @manpage{unbufcall(9)} @tab Remove a @dfn{STREAMS} buffer callback.
@item @manpage{copyb(9)} @tab Copy a @dfn{STREAMS} message block.
@item @manpage{copymsg(9)} @tab Copy a @dfn{STREAMS} message.
@item @manpage{dupb(9)} @tab Duplicate a @dfn{STREAMS} message block.
@item @manpage{dupmsg(9)} @tab Duplicate a @dfn{STREAMS} message.
@item @manpage{linkb(9)} @tab Link a message block into a @dfn{STREAMS} message.
@item @manpage{unlinkb(9)} @tab Unlink a message block from a @dfn{STREAMS} message.
@item @manpage{rmvb(9)} @tab Remove a message block from a @dfn{STREAMS} message.
@item @manpage{adjmsg(9)} @tab Trim bytes from the front or back of a @dfn{STREAMS} message.
@item @manpage{msgpullup(9)} @tab Pull up bytes in a @dfn{STREAMS} message.
@item @manpage{pullupmsg(9)} @tab Pull up the bytes in a @dfn{STREAMS} message.
@item @manpage{freeb(9)} @tab Frees a @dfn{STREAMS} message block.
@item @manpage{freemsg(9)} @tab Frees a @dfn{STREAMS} message.
@item @manpage{datamsg(9)} @tab Tests a @dfn{STREAMS} message type for data.
@item @manpage{msgdsize(9)} @tab Calculates the size of the data in a @dfn{STREAMS} message.
@item @manpage{pcmsg(9)} @tab Test a @dfn{STREAMS} data block message type for priority control.
@end multitable

@node Queue Handling
@section Queue Handling
@cindex queue handling

@subsection UP Queue Handling Functions

@multitable @columnfractions .30 .70
@item @manpage{backq(9)} @tab Find the upstream or downstream @dfn{STREAMS} message queue.
@item @manpage{RD(9)} @tab Return the read queue of a @dfn{STREAMS} queue pair.
@item @manpage{WR(9)} @tab Return the write queue of a @dfn{STREAMS} queue pair.
@item @manpage{OTHERQ(9)} @tab Return the other queue of a @dfn{STREAMS} queue pair.
@item @manpage{SAMESTR(9)} @tab Test for @dfn{STREAMS} pipe or @dfn{FIFO}.
@item @manpage{qsize(9)} @tab Return the number of messages on a @dfn{STREAMS} message queue.
@item @manpage{bcanput(9)} @tab Test banded flow control on a @dfn{STREAMS} message queue.
@item @manpage{canput(9)} @tab Test flow control on a @dfn{STREAMS} message queue.
@item @manpage{qenable(9)} @tab Schedule a @dfn{STREAMS} message queue service routine.
@item @manpage{canenable(9)} @tab Test whether a @dfn{STREAMS} message queue can be scheduled.
@item @manpage{enableok(9)} @tab Allow a @dfn{STREAMS} message queue to be scheduled.
@item @manpage{noenable(9)} @tab Disable a @dfn{STREAMS} message queue from being scheduled.
@item @manpage{flushband(9)} @tab Flushes band @dfn{STREAMS} messages from a @dfn{STREAMS} message queue.
@item @manpage{flushq(9)} @tab Flushes messages from a @dfn{STREAMS} message queue.
@item @manpage{getq(9)} @tab Gets a message from a @dfn{STREAMS} message queue.
@item @manpage{insq(9)} @tab Insert a message into a @dfn{STREAMS} message queue.
@item @manpage{rmvq(9)} @tab Remove a message from a @dfn{STREAMS} message queue.
@item @manpage{qreply(9)} @tab Reply to a message from a @dfn{STREAMS} message queue.
@item @manpage{putq(9)} @tab Put a message onto a @dfn{STREAMS} message queue.
@item @manpage{putbq(9)} @tab Put a message back on a @dfn{STREAMS} message queue.
@item @manpage{putctl(9)} @tab Put a control message on a @dfn{STREAMS} message queue.
@item @manpage{putctl1(9)} @tab Put a 1 byte control message on a @dfn{STREAMS} message queue.
@end multitable

@subsection MP Queue Handling Functions

@multitable @columnfractions .30 .70
@item @manpage{bcanputnext(9)} @tab Test for banded flow control beyond a @dfn{STREAMS} message queue.
@item @manpage{canputnext(9)} @tab Test for flow control beyond a @dfn{STREAMS} message queue.
@item @manpage{put(9)} @tab Invoke the put procedure for a @dfn{STREAMS} module or driver with a @dfn{STREAMS} message.
@item @manpage{putnext(9)} @tab Put a message beyond a @dfn{STREAMS} message queue.
@item @manpage{putnextctl1(9)} @tab Put a one byte control message beyond a @dfn{STREAMS} message queue.
@item @manpage{putnextctl(9)} @tab Put a control message beyond a @dfn{STREAMS} message queue.
@item @manpage{qprocsoff(9)} @tab Disable a @dfn{STREAMS} message queue for multi-processing.
@item @manpage{qprocson(9)} @tab Enable a @dfn{STREAMS} message queue for multi-processing.
@item @manpage{freezestr(9)} @tab Freeze the state of a @dfn{STREAMS} message queue.
@item @manpage{unfreezestr(9)} @tab Thaw the state of a @dfn{STREAMS} message queue.
@item @manpage{strqget(9)} @tab Gets information about a @dfn{STREAMS} message queue.
In the non-@i{MP} environment, it was typical to directly access the elements of the @var{queue}
structure.  In the @i{MP} environment, it is no longer safe to directly access elements of the
@var{queue} structure in this fashion.  The @manpage{strqget(9)}
function provides the ability to retrieve information about @dfn{STREAMS} message queues in the
@i{MP} environment.
@item @manpage{strqset(9)} @tab Sets attributes of a @dfn{STREAMS} message queue.
In the non-@i{MP} environment, it was typical to directly access the elements of the @var{queue}
structure.  In the @i{MP} environment, it is no longer safe to directly access elements of the
@var{queue} structure in this fashion.  The @manpage{strqset(9)}
function provides the ability to set attributes for @dfn{STREAMS} message queues in the
@i{MP} environment.
@end multitable

@node Miscellaneous Functions
@section Miscellaneous Functions
@cindex miscellaneous functions

@subsection Miscellaneous DDI/DKI Functions

@unnumberedsubsubsec Memory Functions

@multitable @columnfractions .30 .70
@item @manpage{kmem_alloc(9)} @tab Allocate kernel memory.
@item @manpage{kmem_free(9)} @tab Deallocate kernel memory.
@item @manpage{kmem_zalloc(9)} @tab Allocate and zero kernel memory.
@item @manpage{kmem_fast_alloc(9)} @tab Allocate kernel memory, fast.
@item @manpage{kmem_fast_free(9)} @tab Deallocate kernel memory, fast.
@end multitable

@unnumberedsubsubsec Data Movement and Comparison

@multitable @columnfractions .30 .70
@item @manpage{bcopy(9)} @tab Copy byte strings.
@item @manpage{bzero(9)} @tab Zero a byte string.
@item @manpage{copyin(9)} @tab Copy user data in from user space to kernel space.
@item @manpage{copyout(9)} @tab Copy user data out to user space from kernel space.
@item @manpage{max(9)} @tab Determine the maximum of two integers.
@item @manpage{min(9)} @tab Determine the minimum of two integers.
@end multitable

@unnumberedsubsubsec Device Numbers

@multitable @columnfractions .30 .70
@item @manpage{getmajor(9)} @tab Get the internal major device number for a device.
@item @manpage{getminor(9)} @tab Get the internal minor device number for a device.
@item @manpage{makedevice(9)} @tab Create a device from major and minor device numbers.
@end multitable

@unnumberedsubsubsec Timers

@multitable @columnfractions .30 .70
@item @manpage{delay(9)} @tab Postpone the calling process for a number of clock ticks.
@item @manpage{timeout(9)} @tab Start a timer.
@item @manpage{untimeout(9)} @tab Stop a timer.
@end multitable

@unnumberedsubsubsec Time, Process and Privilege

@multitable @columnfractions .30 .70
@item @manpage{drv_getparm(9)} @tab Driver retrieval of kernel parameters.
@item @manpage{drv_hztomsec(9)} @tab Convert kernel ticks to milliseconds.
@item @manpage{drv_hztousec(9)} @tab Convert kernel ticks to microseconds.
@item @manpage{drv_msectohz(9)} @tab Convert milliseconds to kernel ticks.
@item @manpage{drv_priv(9)} @tab Check if the current process is privileged.
@item @manpage{drv_usectohz(9)} @tab Convert microseconds to kernel ticks.
@item @manpage{drv_usecwait(9)} @tab Delay for a number of microseconds.
@end multitable

@unnumberedsubsubsec Error Logging

@multitable @columnfractions .30 .70
@item @manpage{cmn_err(9)} @tab Print a kernel command error.
@item @manpage{strlog(9)} @tab Pass a message to the @dfn{STREAMS} logger.
@end multitable

@unnumberedsubsubsec File Manipulation

@multitable @columnfractions .30 .70
@item @manpage{mknod(9)} @tab Create a device node.
@item @manpage{mount(9)} @tab Mount a file system.
@item @manpage{umount(9)} @tab Unmount a file system.
@item @manpage{unlink(9)} @tab Unlink a file.
@end multitable

@node Extensions
@section Extensions
@cindex extensions

There are a number of extensions to @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
@dfn{STREAMS} that have been applied by implementations over the years.  Some of these extensions
are common enough across multiple implementations to be considered part of the @i{ipso facto}
standard for @dfn{STREAMS}.  @cite{@value{PACKAGE_TITLE}} implements these functions are part of the core
set of @dfn{STREAMS} functions.

@subsection Common Extensions

@multitable @columnfractions .30 .70
@item @manpage{linkmsg(9)} @tab Link a message block to a @dfn{STREAMS} message.
@item @manpage{putctl2(9)} @tab Put a two byte control message on a @dfn{STREAMS} message queue.
@item @manpage{putnextctl2(9)} @tab Put a two byte control message on the next @dfn{STREAMS} message queue.
@item @manpage{weldq(9)} @tab Weld two (or four) @dfn{STREAMS} message queues together.
@item @manpage{unweldq(9)} @tab Unweld two (or four) @dfn{STREAMS} message queues.
@end multitable

@subsection @value{PACKAGE_TITLE} Extensions

@unnumberedsubsubsec Internal Queue Functions

@multitable @columnfractions .30 .70
@item @manpage{allocq(9)} @tab Allocate a @dfn{STREAMS} queue pair.
@item @manpage{setq(9)} @tab Set sizes and procedures associated with a @dfn{STREAMS} message queue.
@item @manpage{qattach(9)} @tab Attach a module onto a @dfn{STREAMS} file.
@item @manpage{qopen(9)} @tab Call a @dfn{STREAMS} module or driver open routine.
@item @manpage{qclose(9)} @tab Closes a @dfn{STREAMS} module or driver.
@item @manpage{qdetach(9)} @tab Detach a module from a @dfn{STREAMS} file.
@item @manpage{freeq(9)} @tab Deallocate a @dfn{STREAMS} queue pair.
@end multitable

@unnumberedsubsubsec Flow Control

@multitable @columnfractions .30 .70
@item @manpage{bcanget(9)} @tab Test for message arrival on a band on a stream.
@item @manpage{canget(9)} @tab Test for message arrival on a stream.
@end multitable

@subsection Extensions
@cindex extensions

@multitable @columnfractions .30 .70
@item @manpage{appq(9)} @tab Append on @dfn{STREAMS} message after another.
@item @manpage{esbbcall(9)} @tab Install a buffer callback for an extended @dfn{STREAMS} message block.
@item @manpage{isdatablk(9)} @tab Test a @dfn{STREAMS} data block for data type.
@item @manpage{isdatamsg(9)} @tab Test a @dfn{STREAMS} data block for data type.
@item @manpage{kmem_zalloc_node(9)} @tab (undoc).
@item @manpage{msgsize(9)} @tab Calculate the size of the message blocks in a @dfn{STREAMS} message.
@item @manpage{qcountstrm(9)} @tab Add all counts on all @dfn{STREAMS} message queues in a stream.
@item @manpage{xmsgsize(9)} @tab Calculate the size of message blocks in a @dfn{STREAMS} message.
@end multitable

@node Compatibility
@section Compatibility
@cindex compatibility

@subsection SVR 4.2 MP DDI/DKI Compatibility Functions
@cindex SVR 4.2 MP, compatibility functions
@cindex compatibility functions, SVR 4.2 MP
@cindex SVR 4.2 MP

@subsubheading @cite{SVR 4.2 MP} Core Functions
@cindex core functions, SVR 4.2 MP
@cindex SVR 4.2 MP, core functions
@cindex SVR 4.2 MP

@multitable @columnfractions .30 .70
@item @manpage{lbolt(9)}
Time in ticks since reboot.
@end multitable

@subsubheading @cite{SVR 4.2 MP} Compatibility Module
@cindex compatibility module, SVR 4.2 MP
@cindex SVR 4.2 MP, compatibility module
@cindex SVR 4.2 MP

@multitable @columnfractions .30 .70
@item @manpage{itimeout(9)} @tab Perform a timeout at an interrupt level.
@item @manpage{major(9)} @tab Get the internal major number of a device.
@item @manpage{makedev(9)} @tab Make a device number from internal major and minor device numbers.
@item @manpage{minor(9)} @tab Get the internal minor number of a device.
@item @manpage{sleep(9)} @tab Put a process to sleep.
@item @manpage{vtop(9)} @tab Convert virtual to physical address.
@item @manpage{wakeup(9)} @tab Wake a process.
@end multitable

@unnumberedsubsubsec Atomic Integers

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating atomic integers.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating atomic integers.
These functions are general purpose and not @dfn{STREAMS}-specific.
For portability of @dfn{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @manpage{ATOMIC_INT_ADD(9)} @tab Add an integer value to an atomic integer.
@item @manpage{ATOMIC_INT_ALLOC(9)} @tab Allocate and initialize an atomic integer.
@item @manpage{ATOMIC_INT_DEALLOC(9)} @tab Deallocate an atomic integer.
@item @manpage{ATOMIC_INT_DECR(9)} @tab Decrement and test an atomic integer.
@item @manpage{ATOMIC_INT_INCR(9)} @tab Increment an atomic integer.
@item @manpage{ATOMIC_INT_INIT(9)} @tab Initialize an atomic integer.
@item @manpage{ATOMIC_INT_READ(9)} @tab Read an atomic integer.
@item @manpage{ATOMIC_INT_SUB(9)} @tab Subtract and integer value from an atomic integer.
@item @manpage{ATOMIC_INT_WRITE(9)} @tab Write an integer value to an atomic integer.
@end multitable

@unnumberedsubsubsec Basic Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating basic (spin) locks.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating spin locks.
These functions are general purpose and not @dfn{STREAMS}-specific.
For portability of @dfn{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @manpage{LOCK(9)} @tab Lock a basic lock.
@item @manpage{LOCK_ALLOC(9)} @tab Allocate a basic lock.
@item @manpage{LOCK_DEALLOC(9)} @tab Deallocate a basic lock.
@item @manpage{LOCK_OWNED(9)} @tab Determine whether a basic lock is head by the caller.
@item @manpage{TRYLOCK(9)} @tab Try to lock a basic lock.
@item @manpage{UNLOCK(9)} @tab Unlock a basic lock.
@end multitable

@unnumberedsubsubsec STREAMS Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
defines a set of @dfn{STREAMS}-specific locks.  The @b{Linux} kernel
@cindex Linux
does not provide these functions.  @dfn{@value{PACKAGE_TITLE}} has some equivalent internal functions.
For portability of @dfn{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @manpage{MPSTR_QLOCK(9)} @tab Release a queue from exclusive access.
@item @manpage{MPSTR_QRELE(9)} @tab Acquire a queue for exclusive access.
@item @manpage{MPSTR_STPLOCK(9)} @tab Acquire a stream head for exclusive access.
@item @manpage{MPSTR_STPRELE(9)} @tab Release a stream head from exclusive access.
@end multitable

@unnumberedsubsubsec Read/Write Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating read-write locks.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating spin locks.
These functions are general purpose and not @dfn{STREAMS}-specific.
For portability of @dfn{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @manpage{RW_ALLOC(9)} @tab Allocate and initialize a read/write lock.
@item @manpage{RW_DEALLOC(9)} @tab Deallocate a read/write lock.
@item @manpage{RW_RDLOCK(9)} @tab Acquire a read/write lock in read mode.
@item @manpage{RW_TRYRDLOCK(9)} @tab Attempt to acquire a read/write lock in read mode.
@item @manpage{RW_TRYWRLOCK(9)} @tab Attempt to acquire a read/write lock in write mode.
@item @manpage{RW_UNLOCK(9)} @tab Release a read/write lock.
@item @manpage{RW_WRLOCK(9)} @tab Acquire a read/write lock in write mode.
@end multitable

@unnumberedsubsubsec Priority Levels

@multitable @columnfractions .30 .70
@item @manpage{spl0(9)} @tab Set priority level 0.
@item @manpage{spl1(9)} @tab Set priority level 1.
@item @manpage{spl2(9)} @tab Set priority level 2.
@item @manpage{spl3(9)} @tab Set priority level 3.
@item @manpage{spl4(9)} @tab Set priority level 4.
@item @manpage{spl5(9)} @tab Set priority level 5.
@item @manpage{spl7(9)} @tab Set priority level 6.
@item @manpage{spl7(9)} @tab Set priority level 7.
@item @manpage{spl(9)} @tab Set priority level.
@item @manpage{splx(9)} @tab Set priority level x.
@end multitable

@unnumberedsubsubsec Sleep Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating sleep locks.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating semaphores.
These functions are general purpose and not @dfn{STREAMS}-specific.
For portability of @dfn{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @manpage{SLEEP_ALLOC(9)} @tab Allocate a sleep lock.
@item @manpage{SLEEP_DEALLOC(9)} @tab Deallocate a sleep lock.
@item @manpage{SLEEP_LOCK(9)} @tab Acquire a sleep lock.
@item @manpage{SLEEP_LOCKAVAIL(9)} @tab Determine whether a sleep lock is available.
@item @manpage{SLEEP_LOCKOWNED(9)} @tab Determine whether a sleep lock is held by the caller.
@item @manpage{SLEEP_LOCK_SIG(9)} @tab Acquire a sleep lock.
@item @manpage{SLEEP_TRYLOCK(9)} @tab Attempt to acquire a sleep lock.
@item @manpage{SLEEP_UNLOCK(9)} @tab Release a sleep lock.
@end multitable

@unnumberedsubsubsec Synchronization Variables

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating synchronization variables.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating wait queues.
These functions are general purpose and not @dfn{STREAMS}-specific.
For portability of @dfn{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @manpage{SV_ALLOC(9)} @tab Allocate a basic condition variable.
@item @manpage{SV_BROADCAST(9)} @tab Broadcast a basic condition variable.
@item @manpage{SV_DEALLOC(9)} @tab Deallocate a basic condition variable.
@item @manpage{SV_SIGNAL(9)} @tab Signal a basic condition variable.
@item @manpage{SV_WAIT(9)} @tab Wait on a basic condition variable.
@item @manpage{SV_WAIT_SIG(9)} @tab Interruptible wait on a basic condition variable.
@end multitable

@unnumberedsubsubsec Resource Allocation

@multitable @columnfractions .30 .70
@item @manpage{rmalloc(9)} @tab Allocate a number of units from a resource map.
@item @manpage{rmallocmap(9)} @tab Allocated a resource map.
@item @manpage{rmallocmap_wait(9)} @tab Allocated a resource map.
@item @manpage{rmalloc_wait(9)} @tab Allocate a number of units from a resource map.
@item @manpage{rmfree(9)} @tab Free a number of units from a resource map.
@item @manpage{rmfreemap(9)} @tab Free a resource map.
@item @manpage{rmget(9)} @tab Allocated a number of units from a resource map.
@item @manpage{rminit(9)} @tab Initialize a resource map.
@item @manpage{rmsetwant(9)} @tab Wait for resources on a resource map.
@item @manpage{rmwanted(9)} @tab Waiters on a resource map.
@end multitable

@subsection AIX 5L Version 5.1 Compatibility Functions
@cindex AIX 5L Version 5.1, compatibility functions
@cindex compatibility functions, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1
@cindex AIX PSE
@cindex AIX

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the @cite{AIX
5L Version 5.1 Portable STREAMS Environment (PSE)}:

@subsubheading @cite{AIX} Core Functions
@cindex core functions, AIX
@cindex AIX, core functions
@cindex AIX

The functions in this section are provided as part of the core functions provided in the
@cite{@value{PACKAGE_TITLE}} @dfn{STREAMS} subsystem:

@multitable @columnfractions .30 .70
@item @manpage{putctl2(9)} @tab Put a 2 byte control message on a @dfn{STREAMS} message queue.
Many @dfn{STREAMS} implementations provide this function.  When the errors that can be delivered to
the Stream Head in a @msg{M_ERROR} message were broken from a single read/write error condition to a
separate read and write error condition, the
@manpage{putctl(9)}
function lost much of its utility.  Implementation of a
@manpage{putctl2(9)}
function provides a similar capability for read/write error conditions as
@manpage{putctl(9)}
provided for combined error conditions previously.
@cite{AIX} implements this function.  @dfn{@value{PACKAGE_TITLE}} provides this function for
compatibility with @cite{AIX} and other @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based @dfn{STREAMS} implementations.
@manpage{putctl2(9)}
is not very useful in an @i{MP} environment, where one really wants to place @msg{M_ERROR} messages
on the @i{upstream} queue.  The function for that in the @i{MP} environment is
@manpage{putnextctl2(9)}.
@cite{AIX} does not implement the
@manpage{putnextctl2(9)}
function, which is somewhat surprising, but then @cite{AIX} does not really handle @i{MP} environments
the same way that @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
does: the @cite{AIX Portable STREAMS Environment (PSE)} is essentially single threaded, and
@cite{AIX PSE} does not implement @constant{QHLIST} meaning that the synchronization for protecting
dereferencing of @samp{q->q_next} pointers is not present.

@item @manpage{splstr(9)} @tab Set or restore priority levels.
Although @dfn{@value{PACKAGE_TITLE}} does not interpret priority levels in the same fashion as @cite{SVR
4.2 MP}, the
@manpage{splstr(9)}
is provided in support of @cite{AIX} and other @dfn{STREAMS} implementations.
@cite{AIX} also does not interpret priority levels in the same manner, but provides
@manpage{splstr(9)}
and
@manpage{splx(9)}
functions in support of @dfn{STREAMS}.

@item @manpage{splx(9)} @tab Set or restore priority levels.
Although @dfn{@value{PACKAGE_TITLE}} does not interpret priority levels in the same fashion as @cite{SVR
4.2 MP}, the
@manpage{splx(9)}
is provided in support of @cite{AIX} and other @dfn{STREAMS} implementations.
@cite{AIX} also does not interpret priority levels in the same manner, but provides
@manpage{splstr(9)}
and
@manpage{splx(9)}
functions in support of @dfn{STREAMS}.

@item @manpage{unweldq(9)} @tab Unweld two pairs of @dfn{STREAMS} message queues.
@item @manpage{weldq(9)} @tab Weld together two pairs of @dfn{STREAMS} message queues.
@end multitable


@subsubheading @cite{AIX} Compatibility Module
@cindex compatibility module, AIX
@cindex AIX, compatibility module
@cindex AIX

The functions in this section are provided as part of the @cite{AIX Compatibility Module} contained
in the @file{streams-aixcompat.o} kernel module.

@multitable @columnfractions .30 .70
@item @manpage{mi_bufcall(9)} @tab Reliable alternative to @manpage{buffcall(9)}.
@manpage{mi_bufcall(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{mi_close_comm(9)} @tab @dfn{STREAMS} common minor device close utility.
@manpage{mi_close_comm(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{mi_next_ptr(9)} @tab @dfn{STREAMS} minor device list traversal.
@manpage{mi_next_ptr(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{mi_open_comm(9)} @tab @dfn{STREAMS} common minor device open utility.
@manpage{mi_open_comm(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{mi_prev_ptr(9)} @tab @dfn{STREAMS} minor device list traversal.
@manpage{mi_prev_ptr(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{str_install(9)} @tab Install a @dfn{STREAMS} module or driver.
@manpage{str_install(9)}
is the @cite{AIX}-specific driver and module registration and deregistration facility.  This
facility is fashioned after the @cite{SVR 4.2 MP} facility.  @dfn{@value{PACKAGE_TITLE}} provides an
@cite{AIX} version of this function in support of @cite{AIX}.
Only the @cite{SVR 4.2 MP} version of this function will be used by portable @dfn{STREAMS} modules
and drivers intended to be portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{wantio(9)} @tab Perform direct I/O from a @dfn{STREAMS} driver.
@manpage{wantio(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{wantmsg(9)} @tab Provide a filter of wanted messages from a @dfn{STREAMS} module.
@manpage{wantmsg(9)}
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
@end multitable

@subsection HP-UX 11.0i v2 Compatibility Functions
@cindex HP-UX 11.0i v2, compatibility functions
@cindex compatibility functions, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2
@cindex HP-UX

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with
@cite{HP-UX 11.0i v2}:

@subsubheading @cite{HP-UX} Core Functions
@cindex HP-UX, core functions
@cindex core functions, HP-UX
@cindex HP-UX

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{HP-UX 11.0i v2 STREAMS/UX}:
@cindex HP-UX 11.0i v2, STREAMS/UX

@multitable @columnfractions .30 .70
@item @manpage{putctl2(9)} @tab Put a 2 byte control message on a @dfn{STREAMS} message queue.
Many @dfn{STREAMS} implementations provide this function.  When the errors that can be delivered to
the Stream Head in a @msg{M_ERROR} message were broken from a single read/write error condition to a
separate read and write error condition, the
@manpage{putctl(9)}
function lost much of its utility.  Implementation of a
@manpage{putctl2(9)}
function provides a similar capability for read/write error conditions as
@manpage{putctl(9)}
provided for combined error conditions previously.
@cite{HP-UX}
@cindex HP-UX
implements this function.  @dfn{@value{PACKAGE_TITLE}} provides this function for
compatibility with @cite{HP-UX}
@cindex HP-UX
and other @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based @dfn{STREAMS} implementations.

@item @manpage{putnextctl2(9)} @tab Put a 2 byte control message on the downstream @dfn{STREAMS} message queue.
Many @dfn{STREAMS} @i{MP} implementations provide this function.  When the errors that can be
delivered to the Stream Head in a @msg{M_ERROR}
message were broken from a single read/write error condition to a separate read and write error
condition, the
@manpage{putnextctl(9)}
function lost much of its utility.  Implementation of a
@manpage{putnextctl2(9)}
function provides a similar capability for read/write error conditions as
@manpage{putnextctl(9)}
provided for combined error conditions previously.
@cite{HP-UX}
@cindex HP-UX
implements this function.  @dfn{@value{PACKAGE_TITLE}} provides this function for
compatibility with @cite{HP-UX}
@cindex HP-UX
and other @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based @dfn{STREAMS} implementations.

@item @manpage{unweldq(9)} @tab Unweld two pairs of @dfn{STREAMS} message queues.
@item @manpage{weldq(9)} @tab Weld together two pairs of @dfn{STREAMS} message queues.
@end multitable

@subsubheading @cite{HP-UX} Compatibility Module
@cindex HP-UX, compatibility module
@cindex compatibility module, HP-UX
@cindex HP-UX

The functions in this section are provided as part of the @cite{HP-UX Compatibility Module} contained
in the @file{streams-hpuxcompat.o} kernel module.

@multitable @columnfractions .30 .70
@item @manpage{str_install(9)} @tab Install a @dfn{STREAMS} module or driver.
@manpage{str_install(9)}
is the @cite{HP-UX}-specific
@cindex HP-UX
driver and module registration facility.  This facility is fashioned
after the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
facility.  @dfn{@value{PACKAGE_TITLE}} provides an @cite{HP-UX} version of
this function in support of @cite{HP-UX}.  Only the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
version of this function will be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{str_uninstall(9)} @tab Uninstall a @dfn{STREAMS} module or driver.
@manpage{str_uninstall(9)}
is the @cite{HP-UX}-specific
@cindex HP-UX
driver and module deregistration facility.  This facility is fashioned
after the @cite{SVR 4.2 MP} facility.  @dfn{@value{PACKAGE_TITLE}} provides an @cite{HP-UX}
@cindex HP-UX
version of this function in support of @cite{HP-UX}.
@cindex HP-UX
Only the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
version of this function will be used by portable @dfn{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @manpage{streams_get_sleep_lock(9)} @tab Provide access to the global sleep lock.
@item @manpage{streams_put(9)} @tab Invoke the put procedure for a @dfn{STREAMS} module or driver with a @dfn{STREAMS} message.
@end multitable

@subsection OSF/1 1.2/Digital UNIX Compatibility Functions
@cindex OSF/1 1.2/Digital UNIX, compatibility functions
@cindex compatibility functions, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@subsubheading @cite{OSF/1} Core Functions
@cindex core functions, OSF/1
@cindex OSF/1, core functions
@cindex OSF/1

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{OSF/1 1.2/Digital UNIX}:

@multitable @columnfractions .30 .70
@item @manpage{unweldq(9)} @tab Unweld two pairs of @dfn{STREAMS} message queues.
@item @manpage{weldq(9)} @tab Weld together two pairs of @dfn{STREAMS} message queues.
@end multitable

@subsubheading @cite{OSF/1} Compatibility Module
@cindex compatibility module, OSF/1
@cindex OSF/1, compatibility module
@cindex OSF/1

The functions in this section are provided as part of the @cite{OSF/1 Compatibility Module} contained
in the @file{streams-osfcompat.o} kernel module.

@multitable @columnfractions .30 .70
@item @manpage{lbolt(9)} @tab Time in ticks since reboot.
@item @manpage{puthere(9)} @tab Invoke the put procedure for a @dfn{STREAMS} module or driver with a @dfn{STREAMS} message.
@item @manpage{streams_close_comm(9)} @tab Common minor device close utility.
@item @manpage{streams_open_comm(9)} @tab Common minor device open utility.
@item @manpage{streams_open_ocomm(9)} @tab Common minor device open utility.
@item @manpage{strmod_add(9)} @tab Add a @dfn{STREAMS} module.
@item @manpage{strmod_del(9)} @tab Delete a @dfn{STREAMS} module or driver from the kernel.
@item @manpage{time(9)} @tab (undoc).
@end multitable

@subsection UnixWare 7.1.3 (OpenUnix 8) Compatibility Functions
@cindex UnixWare 7.1.3 (OpenUnix 8), compatibility functions
@cindex compatibility functions, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@subsubheading @cite{UnixWare} Core Functions
@cindex core functions, UnixWare
@cindex UnixWare, core functions
@cindex UnixWare

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{UnixWare 7.1.3 (OpenUnix 8)}:

@multitable @columnfractions .30 .70
@end multitable

@subsubheading @cite{UnixWare} Compatibility Module
@cindex compatibility module, UnixWare
@cindex UnixWare, compatibility module
@cindex UnixWare

The functions in this section are provided as part of the @cite{UnixWare Compatibility Module} contained
in the @file{streams-uw7compat.o} kernel module.

@multitable @columnfractions .30 .70
@item @manpage{allocb_physreq(9)} @tab Allocate a @dfn{STREAMS} message and data block.
@item @manpage{emajor(9)} @tab Get the external (real) major device number from the device number.
@item @manpage{eminor(9)} @tab Get the external extended minor device number from the device number.
@item @manpage{etoimajor(9)} @tab Convert an external major device number to an internal major device number.
@item @manpage{getemajor(9)} @tab Get the external (real) major device number.
@item @manpage{geteminor(9)} @tab Get the external minor device number.
@item @manpage{itoemajor(9)} @tab Convert an internal major device number to an external major device number.
@item @manpage{msgphysreq(9)} @tab Cause a message block to meet physical requirements.
@item @manpage{msgpullup_physreq(9)} @tab Pull up bytes in a @dfn{STREAMS} message.
@item @manpage{msgscgth(9)} @tab (undoc).
@item @manpage{printf(9)} @tab (undoc).
@item @manpage{strioccall(9)} @tab (undoc).
@end multitable

@subsection Solaris 9/SunOS 5.9 Compatibility Functions
@cindex Solaris 9/SunOS 5.9, compatibility functions
@cindex compatibility functions, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@subsubheading @cite{Solaris} Core Functions
@cindex core functions, Solaris
@cindex Solaris, core functions
@cindex Solaris

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{Solaris 9/SunOS 5.9}:

@multitable @columnfractions .30 .70
@end multitable

@subsubheading @cite{Solaris} Compatibility Module
@cindex compatibility module, Solaris
@cindex Solaris, compatibility module
@cindex Solaris

The functions in this section are provided as part of the @cite{Solaris Compatibility Module} contained
in the @file{streams-suncompat.o} kernel module.

@multitable @columnfractions .40 .60
@item @manpage{_fini(9)} @tab
@item @manpage{_info(9)} @tab
@item @manpage{_init(9)} @tab
@item @manpage{attach(9)} @tab attach a device to the system or resume a suspended device
@item @manpage{ddi_create_minor_node(9)} @tab create a minor node for this device
@item @manpage{ddi_driver_major(9)} @tab find the major device number associated with a driver
@item @manpage{ddi_driver_name(9)} @tab return normalized driver name
@item @manpage{ddi_get_cred(9)} @tab get a reference to the credentials of the current user
@item @manpage{ddi_getiminor(9)} @tab
@item @manpage{ddi_get_instance(9)} @tab get device instance number
@item @manpage{ddi_get_lbolt(9)} @tab get the current value of the system tick clock
@item @manpage{ddi_get_pid(9)} @tab
@item @manpage{ddi_get_soft_state(9)} @tab
@item @manpage{ddi_get_time(9)} @tab get the current time in seconds since the epoch
@item @manpage{ddi_remove_minor_node(9)} @tab remove a minor node for a device
@item @manpage{ddi_removing_power(9)} @tab
@item @manpage{ddi_soft_state(9)} @tab
@item @manpage{ddi_soft_state_fini(9)} @tab
@item @manpage{ddi_soft_state_free(9)} @tab
@item @manpage{ddi_soft_state_init(9)} @tab
@item @manpage{ddi_soft_state_zalloc(9)} @tab
@item @manpage{ddi_umem_alloc(9)} @tab allocate page aligned kernel memory
@item @manpage{ddi_umem_free(9)} @tab
@item @manpage{detach(9)} @tab detach a device from the system or suspend a device
@item @manpage{getinfo(9)} @tab
@item @manpage{identify(9)} @tab determine if a driver is associated with a device
@item @manpage{install_driver(9)} @tab install a device driver
@item @manpage{mod_info(9)} @tab provides information on a loadable kernel module to the @dfn{STREAMS} executive
@item @manpage{mod_install(9)} @tab installs a loadable kernel module in the @dfn{STREAMS} executive
@item @manpage{mod_remove(9)} @tab removes a loadable module from the @dfn{STREAMS} executive
@item @manpage{power(9)} @tab power a device attached to the system
@item @manpage{probe(9)} @tab
@item @manpage{qbufcall(9)} @tab install a buffer callback
@item @manpage{qtimeout(9)} @tab start a timer associated with a queue
@item @manpage{queclass(9)} @tab
@item @manpage{qunbufcall(9)} @tab Cancel a @dfn{STREAMS} buffer callback.
@item @manpage{quntimeout(9)} @tab
@item @manpage{qwait(9)} @tab wait for a queue message
@item @manpage{qwait_sig(9)} @tab wait for a queue message or signal
@item @manpage{qwriter(9)} @tab
@end multitable

@node Examples
@chapter Examples
@cindex examples
@menu
* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example
@end menu

@node Module Example
@section Module Example
@cindex module example

@node Driver Example
@section Driver Example
@cindex driver example

@node Device Numbers
@chapter Device Numbers
@cindex device numbers
@menu
* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering
* spec File System::		Avoiding Device Numbering
@end menu

@dfn{@value{PACKAGE_TITLE}} supports the concept of internal and external device numbering with base
majors and extended minors.

@dfn{@value{PACKAGE_TITLE}} uses several device numbering schemes intended to be compatible with
@cite{SVR 4.2 MP DDI/DKI}
@cindex DDI/DKI
@cindex SVR 4.2 MP DDI/DKI
and implementations based on @cite{SVR 4.2}
@cindex SVR 4.2
including AIX,
@cindex AIX
HP-UX,
@cindex HP-UX
OSF/1,
@cindex OSF/1
Solaris,
@cindex Solaris
Super/UX,
@cindex Super/UX
UnixWare,
@cindex UnixWare
and UXP/V.
@cindex UXP/V

@node External Device Numbers
@section External Device Numbers
@cindex external device numbers
@cindex device numbers, external

@dfn{@value{PACKAGE_TITLE}} provides real external device numbering using the functions
@manpage{getemajor(9)}, @manpage{geteminor(9)} and @manpage{makedevice(9)}.  When used on a
@var{devp} argument passed to the @manpage{qopen(9)} procedures of a @dfn{STREAMS} driver or module,
@manpage{getemajor(9)} and @manpage{geteminor(9)} will return the real external major or minor
device number.  The real external major or minor device number is the major or minor device number
that is seen by user applications.

A number of administrative utilities are provided that assist with the assignment of device names
and number and are useful in boot scripts: (@pxref{Administrative Utilities})

@multitable @columnfractions .30 .70
@item @manpage{autopush(8)} @tab -- verify modules and establish autopush lists
@item @manpage{insf(8)} @tab -- install special device files
@item @manpage{scls(8)} @tab -- list @dfn{STREAMS} drivers
@item @manpage{strinfo(8)} @tab -- provide information on @dfn{STREAMS} drivers and modules
@item @manpage{strload(8)} @tab -- load or unload @dfn{STREAMS} drivers and modules
@item @manpage{strsetup(8)} @tab -- create @dfn{STREAMS} devices
@end multitable

Another approach to establishment of dynamically allocated major device numbers is to use the
approach of creating minor device nodes using the @manpage{mknod(9)}
and @manpage{unlink(9)}
facilities.
But this approach does not work well with demand loading of kernel modules
because it relies upon the @b{Linux} character device demand loading approach, or requires informing
@dfn{STREAMS} of all devices and drivers when @dfn{STREAMS} is being compiled.

@dfn{@value{PACKAGE_TITLE}} supports the @b{Linux} character device module demand loading; however, the
@b{Linux} mechanism requires prior knowledge of the character major device number.  Some of the
administrative utilities above can load kernel modules and establish what major device number was
assigned.  See the individual manual pages for more information.

@node Internal Device Numbers
@section Internal Device Numbers
@cindex internal device numbers
@cindex device numbers, internal

Internal extended minor device number is a scheme whereby the @dfn{STREAMS} device driver does not
have to be concerned with architectural limitations on the number of minor device number available
to user applications (0 to 255 in @b{Linux 2.4}).  Instead, the driver treats the major device
number as a base internal device number against which a range of minor devices can be assigned
(currently 0 to 65535).  For external applications, device numbering consists of multiple (real)
external major device numbers that correspond to a single base internal major device number.
Internal extended device numbering is provided by the @manpage{getmajor(9)},
@manpage{getminor(9)}
and @manpage{makedevice(9)}
facilities.  Conversions between external (real) major device numbers and internal (base) major
device numbers can be performed with the @manpage{etoimajor(9)}
and @manpage{itoemajor(9)}
utilities provided by the @dfn{UnixWare} compatibility modules.

Extended device numbering further complicates the matter of dynamic assignment of major device
numbers and makes it harder for boot and configuration scripts to properly create device nodes.

@node Clone Device
@section Clone Device
@cindex clone device

@subsection Traditional Cloning

The @manpage{clone(4)}
driver supports traditional clone devices.  Traditional clone devices work by
assigning the clone major device number and a unique minor device number to a ``clone'' device.
When this device is opened, the minor device number of the device is used as the new major device
number and zero (0) is used as the minor device number, and the @manpage{qopen(9)}
is chained to the @manpage{qopen(9)}
procedure of the new @mantype{streamtab(9)}
structure resulting from looking up this newly created device number.  @var{sflag}
is always set to @samp{CLONEOPEN}
when the traditional clone driver opens a device.

@manpage{getemajor(9)},
@manpage{geteminor(9)},
@manpage{getmajor(9)}
and @manpage{getminor(9)}
still function as normal on the resulting @var{devp}
argument passed to the ultimate driver's @manpage{qopen(9)}
procedure.  This is true both for base and extended major device numbers.  The following table
illustrates the situation (assuming that the major device number assigned to the @manpage{clone(4)}
device is 72):

@multitable @columnfractions .25 .25 .25 .25
@item @b{clone}		@tab @b{external}	@tab @b{internal}	@tab @var{sflag}
@item @t{72:32}		@tab @t{32:0}		@tab @t{32:000}		@tab @samp{CLONEOPEN}
@item @t{72:35}		@tab @t{35:0}		@tab @t{32:256}		@tab @samp{CLONEOPEN}
@item @t{72:37}		@tab @t{37:0}		@tab @t{32:512}		@tab @samp{CLONEOPEN}
@end multitable

If a driver wishes to assign an extended major device number in response to a @b{CLONEOPEN},
it should use @manpage{makedevice(9)}
with the major device number obtained with @manpage{getmajor(9)}
and an extended minor device number assigned by the driver.  In this way, extended minor device
numbers are transparent to the operation of the @manpage{clone(4)}
driver and @samp{CLONEOPEN}.

@subsection New Cloning

@dfn{@value{PACKAGE_TITLE}} supports the new cloning approach whereby a driver is permitted to alter
the device number returned in the @var{devp}
argument to @manpage{qopen(9)}
even though @var{sflag}
is set to @samp{DRVOPEN}
instead of @samp{CLONEOPEN}.
The driver, at its discretion, can treat any minor device number as a new style clone device,
although normally minor device number zero (0) is usually used as the clone minor.

The driver may either use an external (real) major device number or the internal (base) major device
number.  That is, when calling @manpage{makedevice(9)}
to create the device to return to the @var{devp}
argument to @manpage{qopen(9)},
the driver can use an external (real) major device number (returned by @manpage{getemajor(9)})
combined with an assigned external (real) minor device number (from 0 to 255); or, it can use an
internal (base) major device number (returned by @manpage{getmajor(9)})
combined with an assigned extended minor device number (from 0 to 65535).  The latter approach is
often easier to use.

@node Named STREAMS Device
@section Named STREAMS Device
@cindex named streams device

The @manpage{nsdev(4)}
driver provides for a @dfn{Named STREAMS Device}.  This is a device numbering approach unique to
@dfn{@value{PACKAGE_TITLE}}.  The @manpage{nsdev(4)}
driver operates in a similar manner to the @manpage{clone(4)}
driver, however, the major number is derived from the prefix name of the device and the minor number
is taken directly from the minor number of the @manpage{nsdev(4)}
device.

The following table summarizes the approach (assuming that the major device numbers assigned to the
@manpage{nsdev(4)}
device are 74, 75, 76 and 77 and the major device numbers assigned to the @manpage{inet(4)}
driver are 32, 35 and 37):

@multitable @columnfractions .2 .2 .2 .2 .2
@item @b{nsdev}		@tab		@tab @b{external}	@tab @b{internal}	@tab @var{sflag}
@item inet		@tab @t{74:000}	@tab @t{32:000}		@tab @t{32:000}		@tab @samp{DRVOPEN}
@item inet.udp		@tab @t{74:017}	@tab @t{32:017}		@tab @t{32:017}		@tab @samp{DRVOPEN}
@item inet.99		@tab @t{74:099}	@tab @t{32:099}		@tab @t{32:099}		@tab @samp{DRVOPEN}
@item inet.512		@tab @t{76:000}	@tab @t{37:000}		@tab @t{32:512}		@tab @samp{DRVOPEN}
@end multitable

The @manpage{nsdev(4)}
device also has the characteristic that if a device name with a major device number of the
@manpage{nsdev(4)}
device is opened and there is no device loaded that corresponds to the prefix name of the device
from which to obtain a major device number, the @manpage{nsdev(4)}
will attempt to load the `@t{@b{streams-}@i{prefix}}' kernel module using @manpage{request_module(9)}
and try again: where, @samp{prefix} is the prefix of the device name up to the first point character
(corresponding to a digit @kbd{.}).  So, in the example above, if the @samp{inet} driver was not
loaded, but an attempt was made to open the @file{/dev/inet.99} device, @dfn{STREAMS} would request
the @file{streams-inet} kernel module be loaded.  This approach simplifies kernel module loading as
well as device numbering and makes it easier for boot scripts to initialize devices.

@node spec File System
@section spec File System
@cindex spec file system

Another approach to creation and assignment of device numbers is the mountable @manpage{specfs(5)}
file system.  The @manpage{specfs(5)}
file system can be mounted to provide an in-kernel device directory similar to the @b{Linux}
@file{devfs} file system and the @dfn{Solaris} devices file system.  The @manpage{spefs(5)}
file system should normally be mounted on the @file{/dev/streams} subdirectory by system
initialization scripts using a command such as: @command{mount -t specfs none /dev/streams}.  See
@manpage{mount(8)}
for more information.  Once mounted over the @file{/dev/streams} subdirectory, subdirectories of
@file{/dev/streams} corresponding to each loaded driver will appear.  So, for example, when the
@manpage{inet(4)}
driver is loaded, the ``inet'' subdirectory will appear at @file{/dev/streams/inet}.  Within each
device subdirectory @file{/dev/streams/@i{devicename}/}, each instance of the device will appear as
a character device named with the instance number of the device and having the eternal (real) major
and external (real) minor device number.

The mounted @manpage{specfs(5)}
file system also has the characteristic that if a device subdirectory
@file{/dev/streams/@i{devname}/} does not exist, but an attempt is made to read such a directory,
@dfn{@value{PACKAGE_TITLE}} will attempt to load kernel module @file{streams-@i{devname}} into the
kernel with @manpage{request_module(9)}.
If the load is successful, the kernel module will register and the subdirectory will be created and
read.

Also, if an attempt is make to open a numbered file within a device subdirectory of
@file{/dev/streams/@i{devname}/@i{nnnn}} where, @samp{nnnn} is an octal, hexadecimal or decimal
@dfn{ASCII} number, @dfn{STREAMS} will open the driver (call @manpage{qopen(9)}
for driver @samp{devname}) with the instance number resulting from the conversion of the device name
@samp{nnnn} to an instance number.

These two characteristics permit symbolic links to be placed in the @file{/dev} directory that link
to a device name and instance number in the @file{/dev/stream} directory.  An example is given in
the table below:

@multitable @columnfractions .55 .15 .15 .15
@item @b{link} @tab @b{external} @tab @b{internal} @tab @var{sflag}
@item @file{/dev/tcp}@ ->@ @file{/dev/streams/inet/36} @tab @t{30:36} @tab @t{30:36} @tab @samp{DRVOPEN}
@item @file{/dev/udp}@ ->@ @file{/dev/streams/inet/39} @tab @t{30:39} @tab @t{30:39} @tab @samp{DRVOPEN}
@end multitable

In fact, it does not matter what the character device major or minor device number is on the node in
the @manpage{specfs(5)}
file system.  This is because the inode in the file system is directly associated with the
@mantype{streamtab(9)}
structure and instance number without using the normal @b{Linux} character device mechanisms.  When
a device instance exceeds the extended minor device numbering space assigned to a device driver in
the @manpage{specfs(5)}
file system, device number displayed by @manpage{stat(2)},
@manpage{lstat(2)}
or @manpage{fstat(2)}
is chosen by wrapping the instance number into the extended minor device numbering space.

This approach makes it unnecessary to statically assign major device numbers, or to dynamically
assign major device numbers to devices in boot scripts, and is by far the easiest approach.  All that
is required by packages at installation is that they establish the necessary symbolic links on
device name and instance number without concern for major device numbers.

@node Multi-Threading
@chapter Multi-Threading
@cindex multi-threading
@menu
* MT Configuration::		MP STREAMS MT Configuration
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks
* Synchronous Callouts::	MP STREAMS Synchronous Callouts
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Asynchronous Callouts::	MP STREAMS Asynchronous Callouts
@end menu

The @b{Linux} 2.6 kernel is multi-threaded to make effective use of symmetric shared-memory
multiprocessor computers.  All parts of the kernel, including @dfn{STREAMS} modules and drivers,
must ensure data integrity in a multiprocessing environment.  For the most part, developers must
ensure that concurrently running kernel threads do not attempt to manipulate the same data at the
same time.  The @dfn{STREAMS} framework provides multiprocessing @dfn{Syncrhonization Levels},
which allows the developer control over the level of concurrency allowed in a module.  The @cite{SVR
4.2 MP DDI/DKI}
@cindex DDI/DKI
@cindex SVR 4.2 MP DDI/DKI
also provides locking mechanisms for protecting data.

There are two types of entry points, callbacks and callouts in the @dfn{@value{PACKAGE_TITLE}}
subsystem:

@enumerate

@item @emph{Synchronous.}
These entry points (callouts) and callbacks are referenced against a @dfn{STREAMS} queue structure.
That is, they were invoked using a @dfn{STREAMS} queue structure as an argument.  These procedures
are as follows:

@multitable @columnfractions .30 .70
@item @manpage{put(9)} @tab --
@item @manpage{srv(9)} @tab --
@item @manpage{qopen(9)} @tab --
@item @manpage{qclose(9)} @tab --
@item @manpage{qbufcall(9)} @tab --
@item @manpage{qtimeout(9)} @tab --
@item @manpage{mi_bufcall(9)} @tab --
@item @manpage{putq(9)} @tab --
@item @manpage{putbq(9)} @tab --
@item @manpage{putnext(9)} @tab --
@item @manpage{qreply(9)} @tab --
@end multitable

@item @emph{Asynchronous.}
These callbacks are @emph{not} referenced against a @dfn{STREAMS} queue structure.  That is, they
were invoked without a specific @dfn{STREAMS} queue structure as an argument (known to
@dfn{STREAMS}).  These procedures are as follows:

@multitable @columnfractions .30 .70
@item @manpage{bufcall(9)} @tab --
@item @manpage{esbbufcall(9)} @tab --
@item @manpage{timeout(9)} @tab --
@item @manpage{esballoc(9)} @tab (free routine)
@end multitable

@end enumerate

@node MT Configuration
@section Configuration
@cindex configuration
@cindex STREAMS, configuration
@cindex configuration, STREAMS

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
specifies a synchronization mechanism that can be used during configuration of a @dfn{STREAMS}
driver or module to specify the level of synchronization required by a module.  The @cite{SVR 4}
synchronization levels are as follows:

@multitable @columnfractions .30 .70
@item @constant{SQLVL_DEFAULT}
@cindex synchronization, default
@tab @emph{Default level synchronization.}
Specifies that the module uses the default synchronization scheme.  This is the same as specifying
@constant{SQLVL_MODULE}.

@item @constant{SQLVL_GLOBAL}
@cindex synchronization, global
@tab @emph{Global (@dfn{STREAMS} scheduler) level synchronization.}
Specifies that all of @dfn{STREAMS} can be access by only one thread at the same time.  The module
is run with global synchronization.  This means that only one @dfn{STREAMS} executive thread will be
permitted to enter any module.  This makes the entire @dfn{STREAMS} executive single threaded and is
useful primarily for debugging.  This is the same as "Uniprocessor Emulation" on some systems, and
reduces the @dfn{STREAMS} executive to running on a single processor at a time.  This option should
normally be used only for debugging.

@item @constant{SQLVL_ELSEWHERE}
@cindex synchronization, elsewhere
@tab @emph{Module group level synchronization.}
Specifies that the module is run with synchronization within a group of modules.  Only one thread of
execution will be within the group of modules at a time.  The group is separately specified as a
character string name.  This permits a group of modules to run single threaded as though they are
running on a single processor, without interfering with the concurrency of other modules outside the
group.  This can be important for testing and for modules that implicitly share unprotected data
structures.

@item @constant{SQLVL_MODULE}
@cindex synchronization, module
@tab @emph{Module level synchronization.}
Specifies that all instances of a module can be accessed by only one thread at the same time.  This
is the default value.
The module is run with synchronization at the module.  Only one thread of execution will be
permitted within the module.  Where the module does not share data structures between modules, this
has a similar effect on running on a uniprocessor system.  This is the default and works best for
non-multiprocessor-safe modules written in accordance with @dfn{STREAMS} guidelines.
This level is roughly equivalent to @cite{Solaris} @constant{D_MTPERMOD}
perimeters.

@item @constant{SQLVL_QUEUEPAIR}
@cindex synchronization, queue pair
@tab @emph{Queue pair level synchronization.}
Specifies that each queue pair can be accessed by only one thread at the same time.  Only one thread
will be permitted to enter a given queue's procedures within a given queue pair.  Where the read and
write side of the queue pair share the same private structure (@samp{q->q_ptr}), this provides
multiprocessor protection of the common data structure to all synchronous entry points without an
external lock.
This level is roughly equivalent to @cite{Solaris} @constant{D_MTAPAIR}
perimeters.

@item @constant{SQLVL_QUEUE}
@cindex synchronization, queue
@tab @emph{Queue level synchronization.}
Specifies that each queue can be accessed by only one thread at the same time.  The module is run
with synchronization at the queue.  Only one thread of execution will be permitted to enter a given
queue's procedures, however, another thread will be permitted to enter procedures of the other queue
in the queue pair.  This is useful when the read and write side of a module are largely independent
and do not require synchronization between sides of the queue pair.
This level is roughly equivalent to @cite{Solaris} @constant{D_MTPERQ}
perimeters.

@item @constant{SQLVL_NOP}
@cindex synchronization, none
@tab @emph{No synchronization.}
Specifies that each queue can be accessed by more than one thread at a the same time.  The
protection of internal data and of @manpage{put(9)}
and @manpage{srv(9)}
procedures against @manpage{timeout(9)}
or @manpage{bufcall(9)}
is done by the module or driver itself.  This synchronization level should be used essentially for
multiprocessor-efficient modules.
This level is roughly equivalent to @cite{Solaris} @constant{D_MP}
flag.
@end multitable

@node Synchronous Entry Points
@section Synchronous Entry Points
@cindex synchronous entry points

@dfn{Synchronous Entry Points} are those entry points into the @dfn{STREAMS} driver or module that
will be synchronized according to the specified synchronization level.

@multitable @columnfractions .30 .70
@item @manpage{put(9)} @tab @emph{Queue put procedure.}
If the module has any synchronization level other than @constant{SQLVL_NOP},
the put procedure will be exclusive.  Attempts to enter the put procedure while another thread is
running within the synchronization level will result in the call being postponed until the thread
currently in the synchronization level exits.

@item @manpage{srv(9)} @tab If the module has any synchronization level other than @constant{SQLVL_NOP},
@emph{Queue service procedure.}
the service procedure will be exclusive.  Attempts to enter the service procedure while another
thread is running within the synchronization level will result in the service procedure being
postponed until the thread currently in the synchronization level exits.

@item @manpage{qopen(9)} @tab @emph{Queue open procedure.}
The queue open procedure is synchronous and exclusive before the call to @manpage{qprocson(9)},
or in any event, until return from the procedure.  If the module has synchronization level of
global, elsewhere or per-module; the call to the @manref{qopen(9)} procedure is exclusive.

@item @manpage{qclose(9)} @tab @emph{Queue close procedure.}
The queue close procedure is synchronous and exclusive after the call to @manpage{qprocsoff(9)},
or in any event, after return from the procedure.  If the module has synchronization level of
global, elsewhere or per-module; the call to the @manref{qclose(9)} procedure is exclusive.

@item @manpage{qprocson(9)} @tab @emph{Queue procedures on.}
@item @manpage{qprocsoff(9)} @tab @emph{Queue procedures off.}
@item @manpage{freezestr(9)} @tab @emph{Freeze stream.}
@item @manpage{unfreezestr(9)} @tab @emph{Thaw stream.}
@item @manpage{qwriter(9)} @tab @emph{Queue writer.}
@end multitable

@node Synchronous Callbacks
@section Synchronous Callbacks
@cindex synchronous callbacks

@dfn{Synchronous Callbacks} are those callbacks into the @dfn{STREAMS} driver or module that
will be synchronized according to the specified synchronization level.  Synchronous callbacks are an
extension to the @cite{UNIX System V Release 4.2}
@cindex UNIX System V Release 4.2
specifications of @dfn{STREAMS}.  Synchronous callback extensions include @cite{Solaris} extensions
and @cite{AIX}
@cindex AIX
extensions.

These include:

@multitable @columnfractions .30 .70
@item @manpage{qbufcall(9)} @tab -- queue referenced buffer call
@item @manpage{qtimeout(9)} @tab -- queue referenced timeout
@item @manpage{qunbufcall(9)} @tab -- queue referenced buffer call cancel
@item @manpage{quntimeout(9)} @tab -- queue referenced timeout cancel
@item @manpage{mi_bufcall(9)} @tab -- queue reference buffer call
@end multitable

@node Synchronous Callouts
@section Synchronous Callouts
@cindex synchronous callouts

@multitable @columnfractions .30 .70
@item @manpage{putnext(9)} @tab --
@item @manpage{qreply(9)} @tab --
@end multitable

@node Asynchronous Entry Points
@section Asynchronous Entry Points
@cindex asynchronous entry points

@node Asynchronous Callbacks
@section Asynchronous Callbacks
@cindex asynchronous callbacks

@dfn{Asynchronous Callbacks} are those callbacks into the @dfn{STREAMS} driver or module that will
@emph{not} be synchronized according to the specified synchronization level.  Asynchronous callbacks
are the basic @cite{UNIX System V Release 4.2} callbacks.

@node Asynchronous Callouts
@section Asynchronous Callouts
@cindex asynchronous callouts

@node Administration
@chapter Administration
@cindex STREAMS, administration
@cindex administration, STREAMS

@menu
* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System
@end menu

@node Administrative Utilities
@section Administrative Utilities
@cindex administrative utilities

@multitable @columnfractions 0.25 0.75
@item @manpage{autopush(8)} @tab control the autopush module list for a @dfn{STREAMS} device
@item @manpage{fattach(8)} @tab name a @dfn{STREAMS} file
@item @manpage{fdetach(8)} @tab unlink a named @dfn{STREAMS} file
@item @manpage{insf(8)} @tab install special device files
@item @manpage{scls(8)} @tab produce a list of module and driver names
@item @manpage{strace(8)} @tab write @dfn{STREAMS} event trace messages to the standard output
@item @manpage{strclean(8)} @tab clean up after the @dfn{STREAMS} error and trace loggers
@item @manpage{strconf(8)} @tab @dfn{STREAMS} configuration utility
@item @manpage{streams_mknod(8)} @tab create or remove @dfn{STREAMS} device nodes
@item @manpage{strerr(8)} @tab receive error log messages from the @dfn{STREAMS} @manpage{log(4)} driver
@item @manpage{strinfo(8)} @tab display information about @dfn{STREAMS} devices
@item @manpage{strload(8)} @tab loads the @dfn{STREAMS} subsystem
@item @manpage{strsetup(8)} @tab @dfn{STREAMS} setup command
@item @manpage{strvf(8)} @tab @dfn{STREAMS} verification tool
@end multitable

@menu
* autopush(8)::			
* fattach(8)::			
* fdetach(8)::			
* insf(8)::			
* scls(8)::			
* strace(8)::			
* strclean(8)::			
* strconf(8)::			
* streams_mknod(8)::		
* strerr(8)::			
* strinfo(8)::			
* strload(8)::			
* strsetup(8)::			
* strvf(8)::			
@end menu

@page
@node autopush(8)
@subsection autopush(8)
@pgindex autopush(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node fattach(8)
@subsection fattach(8)
@pgindex fattach(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node fdetach(8)
@subsection fdetach(8)
@pgindex fdetach(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node insf(8)
@subsection insf(8)
@pgindex insf(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node scls(8)
@subsection scls(8)
@pgindex scls(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strace(8)
@subsection strace(8)
@pgindex strace(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strclean(8)
@subsection strclean(8)
@pgindex strclean(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strconf(8)
@subsection strconf(8)
@pgindex strconf(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node streams_mknod(8)
@subsection streams_mknod(8)
@pgindex streams_mknod(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strerr(8)
@subsection strerr(8)
@pgindex strerr(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strinfo(8)
@subsection strinfo(8)
@pgindex strinfo(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strload(8)
@subsection strload(8)
@pgindex strload(8)
@subsubheading NAME
@command{strload} -- loads the @dfn{STREAMS} subsystem
@subsubheading SYNOPSIS
@smallexample
strload [-u|-q|[-l]] [-f @i{file}] [-d @i{list}] [-m @i{list}]
strload @{-h|--help@}
strload @{-V|--version@}
strload @{-C|--copying@}
@end smallexample
@subsubheading DESCRIPTION
@dfn{@value{PACKAGE_TITLE}} drivers and modules are dynamically loaded and unloaded.  To support
this function, each driver and module must have a configuration routine that performs the necessary
initialization and setup operations.

For compatibility with @cite{AIX PSE}, @dfn{@value{PACKAGE_TITLE}} provides the @command{strload}
command to load @dfn{STREAMS} drivers and modules.  After loading the driver or module, the
@command{strload} command calls the driver or module entry point using the @constant{SYS_CFGDD}
or
@constant{SYS_CFGMOD}
operations in @manpage{sysconfig(9)}.

Each @dfn{STREAMS} driver of module must eventually call the @manpage{str_install(9)}
utility to link into @dfn{STREAMS}.

Commonly used drivers or modules can be placed in a configuration file, which controls the normal
setup and tear-down of @dfn{@value{PACKAGE_TITLE}}.  The configuration file allows more flexibility
when loading drivers or modules by providing user-specified nodes and arguments.
@subsubheading OPTIONS
@table @code
@item [-l]
Loads the referenced drivers and modules.  (This is the default if the @samp{-q} and @samp{-u} flags
are not specified.)  If no configuration file, driver or modules are listed in the command options,
only the @dfn{STREAMS} executive is loaded;
@item -u, --unload
Unloads the referenced drivers and modules.  If no configuration file, drivers or modules are listed
in the command options, the entire @dfn{STREAMS} executive is unloaded;
@item -q, --query
Queries the referenced drivers and modules.  If no configuration file, drivers or modules are listed
in the command options, only the @dfn{STREAMS} executive is queried;
@item -f, --file @i{file}
Specifies the file to use as the configuration file.  If @samp{-f} is not specified, the default
filename is @file{/etc/strload.conf}.
@pgindex /etc/strload.conf
@item -d, --drivers @i{list}
Specifies a list of driver names to load or unload.
@i{list} is a comma separated list of driver names.
@item -m, --modules @i{list}
Specifies a list of module names to load or unload.
@i{list} is a comma separated list of module names.
@end table
Without any options, by default, @command{strload} loads the @dfn{STREAMS} executive and takes its
configuration from the file @file{/etc/strload.conf}.
@pgindex /etc/strload.conf
Only one of @samp{-l}, @samp{-q} and @samp{-u} are permitted.
@subsubheading FILE FORMAT
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strsetup(8)
@subsection strsetup(8)
@pgindex strsetup(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strvf(8)
@subsection strvf(8)
@pgindex strvf(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node System Controls
@section System Controls
@cindex system controls

@dfn{@value{PACKAGE_TITLE}} provides and supports a number of system controls that can be accessed
using the /proc/sys/streams/* files, with the @manpage{sysctl(2)}
interface, or using @manpage{sysctl(8)}.

The following @dfn{STREAMS} specific system controls are provided by @dfn{@value{PACKAGE_TITLE}}:

@vtable @var

@item sys.streams.cltime
Defines the default time interval (in milliseconds) that closing stream will linger for messages to
clear its queues before finally closing.  Valid values are zero (0) or greater (@constant{MAXINT}).  The
default value is the traditional @dfn{UNIX} value of 15,000 milliseconds (15 seconds).  This system
control defines the default for all new streams.  The value for a given stream can be changed with
the @manpage{streamio(7)} IO control @streamio{I_CLTIME},
after the stream is opened and before the stream is closed.

@item sys.streams.max_apush
Defines the maximum number of modules that can be configured for autopush onto a @dfn{STREAMS} driver.
Valid values are zero (0) or greater (@constant{MAXINT}).  The default value is the traditional @dfn{UNIX} value of 8
modules.  This system control defines the maximum for all new autopush configurations.  Existing
autopush configurations are unchanged.

@item sys.streams.max_mblk
Defines the maximum number of combined message data blocks that will be held on the per-CPU free
list between runs of @manpage{runqueues(9)}.  Valid values are zero (0) or greater (@constant{MAXINT}).
The default value is the traditional @i{UNIX} value of 10 blocks.  This system control defines the
maximum for the next run of @manpage{runqueues(9)} for all CPUs.  Increasing or decreasing this
number may have a positive or negative performance impact.

@item sys.streams.max_stramod
Defines the maximum number of autopush structures that can be defined for the entire system.  Valid
values are zero (0) or greater (@constant{MAXINT}).  The default value is eight (8) ???????  This system
control defines the system-wide maximum.

@item sys.streams.max_strdev
Defines the maximum number of streams devices.  This is normally the maximum number of character
devices (@constant{MAX_CHRDEV}).
Valid values are zero (0) or greater (@constant{MAXINT}).  The default value is @constant{MAX_CHRDEV}
(256).
This is a read-only system control.

@item sys.streams.max_strmod
Defines the maximum number of streams modules.  This is normally the maximum number of character
devices (@constant{MAX_CHRDEV}).
Valid values are zero (0) or greater (@constant{MAXINT}).  The default value is @constant{MAX_CHRDEV}
(256).  This is a read-only system control.

@item sys.streams.msg_priority
Defines whether allocation priority will honoured or whether all allocations will be treated the
same.  See @manpage{allocb(9)}.  When @samp{true} (non-zero), allocation priority will be honoured when
allocating message blocks.  When @samp{false} (zero), allocation priority will be ignored.  Valid values
are zero (0) or non-zero.  The default value is zero (0).  Changing this value may have a positive
or negative impact on system performance.

@item sys.streams.nband
Defines the number of queue bands available.  Valid values are zero (0) or greater (@constant{MAXINT}).
The default value is the traditional @cite{UNIX} value of 256.  This system control defines the system wide
value.  This system control is read-only.

@item sys.streams.nstrmsgs
Defines the maximum number of combined message data blocks that will be allocated.  Valid values are
zero (0) or greater (@constant{MAXINT}).  The default value is 2^12.  Changing this value may have a
positive or negative impact on system performance.  Setting this value to a small number may be
useful for debugging @i{STREAMS} drivers and modules.

@item sys.streams.nstrpush
Defines the maximum number of modules that can be pushed on a stream.  This includes both autopushed
modules and modules pushed using the
@streamio{I_PUSH}
IO control of @manpage{streamio(7)}.  Valid values are zero (0) or greater (@constant{MAXINT}).  The
default value is the traditional @cite{UNIX} value of 64.  This is the default values for all new
streams.  Existing streams are unaffected.

@item sys.streams.hiwat
Defines the default high water mark (in message bytes) for the stream head.  Valid values are zero
(0) or greater (@constant{MAXINT}).  The default value is 5120.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@msg{M_SETOPTS}
message to the stream head.

@item sys.streams.lowat
Defines the default low water mark (in message bytes) for the stream head.  Valid values are zero
(0) or greater (@constant{MAXINT}).  The default value is 1024.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@msg{M_SETOPTS}
message to the stream head.

@item sys.streams.maxpsz
Defines the maximum packet size accepted (in message bytes) for the stream head.  Valid values are
zero (0) or greater (@constant{MAXINT}).  The default value is 2^12.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@msg{M_SETOPTS}
message to the stream head.

@item sys.streams.minpsz
Defines the minimum packet size accepted (in message bytes) for the stream head.  Valid values are
zero (0) or greater (@constant{MAXINT}).  The default value is 0.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@msg{M_SETOPTS}
message to the stream head.

@item sys.streams.reuse_fmodsw
Defines whether @code{fmodsw} table entries will be reused.  When @samp{false} (zero), @code{fmodsw}
table entries will not be reused.  When @samp{true} (non-zero), @code{fmodsw} table entries will be
reused.  Valid values are zero (0) and non-zero.  The default value is @samp{false} (zero).

@item sys.streams.rtime
Defines the time interval (in milliseconds) that the stream head will wait to forward held messages
when @constant{SNDHOLD}
is set for the stream head.  Valid values are zero (0) or greater (@constant{MAXINT}).  The default value
is 10 milliseconds (one clock tick).  This is the system wide value for all streams.  Changing this
value may have a positive or negative impact on system performance.

@item sys.streams.strhold
Defines whether the @constant{SNDHOLD}
feature is active or not.  When @samp{false} (0), the @constant{SNDHOLD}
feature is deactivated.  When @samp{true} (non-zero), the @constant{SNDHOLD}
feature is activated.  Valid values are zero (0) or non-zero.  The default value is @samp{false} (0).  This
is the default value for all new streams.  Existing streams are unaffected.  This setting can be
examined and altered on an open stream using the
@streamio{I_GWROPT}
and
@streamio{I_SWROPT}
IO controls of @manpage{streamio(7)}.

@item sys.streams.strctlsz
Defines the maximum @i{STREAMS} control part size.  Valid values are zero (0) or greater
(@constant{MAXINT}).  The default value is 2^12.  This is the system wide maximum.  Existing allocations
are unaffected by lowering this value.  Changing this value can have an impact on users of
@manpage{putpmsg(2)}.

@item sys.streams.strmsgsz
Defines the maximum @i{STREAMS} message size.  Valid values are zero (0) or greater (@constant{MAXINT}).
The default value is 2^18.  This is the system wide maximum.  Existing allocations are unaffected by
lowering this value.  Changing this value can have an impact on users of @manpage{write(2)},
@manpage{writev(2)}, and @manpage{putpmsg(2)}.

@item sys.streams.strthresh
Defines the maximum amount of memory that will be allocated for use by the @dfn{STREAMS} subsystem via
@manpage{kmem_alloc(9)} or @manpage{kmem_zalloc(9)}, or indirectly using @manpage{allocb(9)} or
allocating other @i{STREAMS} data structures.  Valid values are zero (0) or greater (@constant{MAXINT}).
This is the system wide maximum.  Existing allocations are unaffected by lowering this value.
Changing this value to a low value may have some use in debugging @i{STREAMS} drivers and modules.

@end vtable

@node /proc File System
@section /proc File System
@cindex /proc file system

@node STREAMS Data Structures
@appendix STREAMS Data Structures
@cindex STREAMS data structures
@menu
* Stream Structures::
* Queue Structures::
* Message Structures::
* Input Output Control Structures::
* Link Structures::
* Options Structures::
@end menu

This appendix summarizes data structures commonly encountered in @dfn{STREAMS} module and driver
development.  Most of the data structures given in this appendix are contained in
@header{sys/stream.h}.

@node Stream Structures
@section Stream Structures
@menu
* streamtab::
@end menu

@node streamtab
@appendixsubsec streamtab
@tindex streamtab
@anchor{streamtab(9)}

This structure defines a module or a driver.

@smallexample
struct streamtab @{
    struct qinit *st_rdinit;    /* defines read queue */
    struct qinit *st_wrinit;    /* defines write queue */
    struct qinit *st_muxrinit;  /* for multiplexing drivers only */
    struct qinit *st_muxwinit;  /* for multiplexing drivers only */
@};
@end smallexample

@node Queue Structures
@section Queue Structures
@menu
* queue::
* qinit::
* module_info::
* module_stat::
* qband::
@end menu

Two sets of queue structures form a module.  The structures are @code{queue}, @code{qband},
@code{qinit}, @code{module_info}, and @code{module_stat} (optional).

@node queue
@appendixsubsec queue

@code{queue} structure has the following format:

@smallexample
struct queue @{
    struct qinit *q_qinfo;      /* procedures and limits for queue */
    struct msgb *q_first;       /* head of message queue for this
                                   queue */
    struct msgb *q_last;        /* tail of message queue for this
                                   queue */
    struct queue *q_next;       /* next queue in stream */
    struct queue *q_link;       /* to next queue for scheduling */
    _VOID *q_ptr;               /* to private data structure */
    ulong q_count;              /* number of bytes in queue */
    ulong q_flag;               /* queue state */
    long q_minpsz;              /* min packet size accepted by this
                                   module */
    long q_maxpsz;              /* max packet size accepted by this
                                   module */
    ulong q_hiwat;              /* queue high water mark for flow
                                   control */
    ulong q_lowat;              /* queue low water mark for flow
                                   control */
    struct qband *q_bandp;      /* separate flow information */
    unsigned char q_nband;      /* number of priority bands */
    unsigned char q_blocked     /* number of bands flow controlled */
    unsigned char q_padl1[2];   /* reserved for future use */
    long q_padl2[2];            /* reserved for future use */
@};

typedef struct queue queue_t;
@end smallexample

When a queue pair is allocated, their contents are zero unless specifically initialized.  The
following fields are initialized:

@itemize @bullet

@item @var{q_qinfo}: @var{st_rdinit} and @var{st_wrinit} (or @var{st_muxrinit} and
@var{st_muxwinit}) from @type{streamtab}

@item @var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, @var{q_lowat} from @code{module_info}

@item @var{q_ptr} optionally, by the driver/module open routine

@end itemize

@node qinit
@appendixsubsec qinit

@code{qinit} format is as follows:

@smallexample
struct qinit @{
    int (*qi_putp) ();          /* put procedure */
    int (*qi_srvp) ();          /* service procedure */
    int (*qi_qopen) ();         /* called on each open or a push */
    int (*qi_qclose) ();        /* called on last close or a pop */
    int (*qi_qadmin) ();        /* reserved for future use */
    struct module_info *qi_minfo;       /* information structure */
    struct module_stat *qi_mstat;       /* statistics structure -
                                           optional */
@};
@end smallexample

@node module_info
@appendixsubsec module_info

@code{module_info} has the following:

@smallexample
struct module_info @{
    ushort mi_idnum;            /* module ID number */
    char *mi_idname;            /* module name */
    long mi_minpsz;             /* min packet size accepted */
    long mi_maxpsz;             /* max packet size accepted */
    ulong mi_hiwat;             /* high water mark, for flow control */
    ulong mi_lowat;             /* low water mark, for flow control */
@};
@end smallexample

@node module_stat
@appendixsubsec module_stat

The format of @code{module_stat} is:

@smallexample
struct module_stat @{
    long ms_pcnt;               /* count of calls to put proc */
    long ms_scnt;               /* count of calls to service proc */
    long ms_ocnt;               /* count of calls to open proc */
    long ms_ccnt;               /* count of calls to close proc */
    long ms_acnt;               /* count of calls to abmin proc */
    char *ms_xptr;              /* pointer to private statistics */
    short ms_xsize;             /* length of private statistics
                                   buffer */
@};
@end smallexample

Note that in the event these counts are calculated by modules or drivers, the counts will be
cumulative over all instantiations of modules with the same @code{fmodsw} entry and drivers with the
same @code{cdevsw} entry. (@code{cdevsw} and @code{fmodsw} tables are described in @ref{STREAMS
Configuration}.)

@node qband
@appendixsubsec qband

The queue flow information for each band is contained in the following
structure:

@smallexample
/* Structure that describes the separate information for each priority
 * band in the queue
 */

struct qband @{
    struct qband *qb_next;      /* next band's info */
    ulong qb_count;             /* number of bytes in band */
    struct msgb *qb_first;      /* beginning of band's data */
    struct msgb *qb_last;       /* end of band's data */
    ulong qb_hiwat;             /* high water mark for band */
    ulong qb_lowat;             /* low water mark for band */
    ulong qb_flag;              /* flag, QB_FULL, denotes that a band 
                                   of data flow is flow controlled */
    long qb_pad1;               /* reserved for future use */
@};

typedef struct qband qband_t;

/*
 * qband flags
 */
#define  QB_FULL   0x01         /* band is considered full */
#define  QB_WANTW  0x02         /* someone wants to write to band */
#define  QB_BACK   0x04         /* queue has been back-enabled */
@end smallexample

@node Message Structures
@section Message Structures
@menu
* msgb::
* datab::
@end menu

A  message  is composed of a linked list of triples, consisting of two
structures (msgb and datab) and a data buffer.

@node msgb
@appendixsubsec msgb

@smallexample
/* the message block, msgb, structure */

struct msgb @{
    struct msgb *b_next;        /* next message on queue */
    struct msgb *b_prev;        /* previous message on queue */
    struct msgb *b_cont;        /* next message block of message */
    unsigned char *b_rptr;      /* first unread data byte in buffer */
    unsigned char *b_wptr;      /* first unwritten data byte in
                                   buffer */
    struct datab *b_datap;      /* data block */
    unsigned char b_band;       /* message priority */
    unsigned char b_pad1;
    unsigned short b_flag;
    long b_pad2;
@};

typedef struct msgb mblk_t;
typedef struct datab dblk_t;
typedef struct free_rtn frtn_t;

/* Message flags.  These are interpreted by the Stream head.  */

#define MSGMARK   0x01          /* last byte of message is "marked" */
#define MSGNOLOOP 0x02          /* do not loop message around to
                                   write-side of Stream */
#define MSGDELIM  0x04          /* message is delimited */
#define MSGNOGET  0x08          /* getq does not return message */
#define MSGATTEN  0x20          /* attention to on read side */
@end smallexample

@node datab
@appendixsubsec datab

@smallexample
/* data block, datab, structure */

struct datab @{
    union @{
        struct datab *freep;
        struct free_rtn *frtnp;
    @} db_f;                    /* used internally */
    unsigned char *db_base;     /* first byte of buffer */
    unsigned char *db_lim;      /* last byte+1 of buffer */
    unsigned char db_ref;       /* count of message pointing to this
                                   block */
    unsigned char db_type;      /* message type */
    unsigned char db_iswhat;    /* status of message/data/buffer
                                   triplet */
    unsigned int db_size;       /* used internally */
    caddr_t db_msgaddr;         /* triplet message header pointing to
                                   datab */
    long db_filler;             /* reserved for future use */
@};

#define db_freep db_f.freep
#define db_freep db_f.frtnp
@end smallexample

@node Input Output Control Structures
@section Input Output Control Structures
@menu
* iocblk::
* copyreq::
* copyresp::
* strioctl::
@end menu

@node iocblk
@appendixsubsec iocblk

This is contained in an @msg{M_IOCTL} message block:

@smallexample
struct iocblk @{
    int ioc_cmd;                /* ioctl command type */
    cred_t *ioc_cr;             /* full credentials */
    uint ioc_id;                /* ioctl id */
    uint ioc_count;             /* count of bytes in data field */
    int ioc_error;              /* error code */
    int ioc_rval;               /* return value */
    long ioc_filler[4];         /* reserved for future use */
@};

#define  ioc_uid  ioc_cr->cr_uid
#define  ioc_gid  ioc_cr->cr_gid
@end smallexample

@node copyreq
@appendixsubsec copyreq

This is used in @msg{M_COPYIN}/@msg{M_COPYOUT} messages:

@smallexample
struct copyreq @{
    int cq_cmd;                 /* ioctl command (form ioc_cmd) */
    cred_t *cq_cr;              /* full credentials */
    uint cq_id;                 /* ioctl id (from ioc_id) */
    caddr_t cq_addr;            /* address to copy data to/from */
    uint cq_size;               /* number of bytes to copy */
    int cq_flag;                /* see below */
    mblk_t *cq_private;         /* private state information */
    long cq_filler[4];          /* reserved for future use */
@};

#define cq_uid cq_cr->cr_uid
#define cq_gid cq_cr->cr_gid

/* cq_flag values */

#define STRCANON   0x01         /* b_cont data block contains
                                   canonical format specifier */
#define RECOPY     0x02         /* perform I_STR copyin again this
                                   time using canonical format
                                   specifier */
@end smallexample

@node copyresp
@appendixsubsec copyresp

This structure is used in @msg{M_IOCDATA}:

@smallexample
struct copyresp @{
    int cp_cmd;                 /* ioctl command (form ioc_cmd) */
    cred_t *cp_cr;              /* full credentials */
    uint cp_id;                 /* ioctl id (from ioc_id) */
    cadd_t cp_rval;             /* status of request: 0 for
                                   success, non-zero for failure */
    uint cp_pad1;               /* reserved */
    int cp_pad2;                /* reserved */
    mblk_t *cp_private;         /* private state information */
    long cp_filler[4];          /* reserved for future use */
@};

#define cp_uid cp_cr->cr_uid
#define cp_gid cp_cr->cr_gid
@end smallexample

@node strioctl
@appendixsubsec strioctl

This structure supplies user values as an argument to the ioctl call @streamio{I_STR} in
@manpage{streamio(7)}.

@smallexample
struct strioctl @{
    int ic_cmd;                 /* downstream request */
    int ic_timout;              /* timeout acknowledgement - ACK/NAK */
    int ic_len;                 /* length of data argument */
    char *ic_dp;                /* pointer to data argument */
@};
@end smallexample

@node Link Structures
@section Link Structures
@menu
* linkblk::
@end menu

@node linkblk
@appendixsubsec linkblk

This structure is used in the lower multiplexer drivers to indicate a link.

@smallexample
/* this is used in lower multiplexer drivers to indicate a link */

struct linkblk @{
    queue_t *l_qtop;            /* lowest level write queue of upper
                                   Stream set to NULL for persistent 
                                   links */
    queue_t *l_qbot;            /* highest level write queue of lower 
                                   Stream */
    int l_index;                /* system-unique index for lower
                                   Stream */
    long l_pad[5];              /* reserved for future use */
@};
@end smallexample

@node Options Structures
@section Options Structures
@menu
* stroptions::
@end menu

@node stroptions
@appendixsubsec stroptions

This is an options structure of the @msg{M_SETOPTS} message.  The structure is sent upstream with
modules or drivers to specify an optional stream head value.

@smallexample
struct stroptions @{
    ulong so_flags;             /* options to set */
    short so_readopt;           /* read option */
    ushort so_wroff;            /* write offset */
    long so_minpsz;             /* minimum read packet size */
    long so_maxpsz;             /* maximum read packet size */
    ulong so_hiwat;             /* read queue high water mark */
    ulong so_lowat;             /* read queue low water mark */
    unsigned char so_band;      /* band for water marks */
@};

/* flags for Stream options set message */
#define   SO_ALL       0x003f   /* set all options */
#define   SO_READOPT   0x0001   /* set read option */
#define   SO_WROFF     0x0002   /* set write offset */
#define   SO_MINPSZ    0x0004   /* set minimim packet size */
#define   SO_MAXPSZ    0x0008   /* set maximim packet size */
#define   SO_HIWAT     0x0010   /* set high water mark */
#define   SO_LOWAT     0x0020   /* set low water mark */
#define   SO_MREADON   0x0040   /* set read notification on */
#define   SO_MREADOFF  0x0080   /* set read notification off */
#define   SO_NDELON    0x0100   /* old TTY semantics for NDELAY
                                   reads/writes */
#define   SO_NDELOFF   0x0200   /* STREAMS semantics for NDELAY
                                   reads/writes */
#define   SO_ISTTY     0x0400   /* Stream is acting as terminal */
#define   SO_ISNTTY    0x0800   /* Stream is not acting as a terminal */
#define   SO_TOSTOP    0x1000   /* stop on background writes to
                                   Stream */
#define   SO_TONSTOP   0x2000   /* do not stop on background jobs to
                                   stream */
#define   SO_BAND      0x4000   /* water marks that affect band */
#define   SO_DELIM     0x8000   /* messages are delimited */
#define   SO_NODELIM   0x010000 /* turn off delimiters */
#define   SO_STRHOLD   0x020000 /* enable strwrite message coalescing */
@end smallexample

@node STREAMS Message Types
@appendix STREAMS Message Types
@cindex STREAMS message types
@menu
* Message Type::
* Ordinary Messages::
* High Priority Messages::
@end menu

@node Message Type
@section Message Types

Defined @dfn{STREAMS} message types differ in their intended purposes, their treatment at the
@dfn{Stream head}, and in their message queueing priority.

@dfn{STREAMS} does not prevent a module or driver from generating any message type and sending it in
any direction on the @dfn{Stream}.  However, established processing and direction rules should be
observed.  @dfn{Stream head} processing according to message type is fixed, although certain
parameters can be altered.

The message types are described in this appendix, classified according to their message queueing
priority.  Ordinary messages are described first, with high priority messages following.  In certain
cases, two message types may perform similar functions, differing only in priority.  Message
construction is described in Messages.  The use of the word module will generally imply "module or
driver."

Ordinary messages are also called normal or non-priority messages.  Ordinary messages are subject to
flow control whereas high priority messages are not.

@node Ordinary Messages
@section Ordinary Messages

@table @msg

@item M_BREAK
Sent to a driver to request that @dfn{BREAK} be transmitted on whatever media the driver is
controlling.  The message format is not defined by @dfn{STREAMS} and its use is developer dependent.
This message may be considered a special case of an @msg{M_CTL} message.  An @msg{M_BREAK} message
cannot be generated by a user-level process and is always discarded if passed to the @dfn{Stream
head}.

@item M_CTL
Generated by modules that wish to send information to a particular module or type of module.
@msg{M_CTL} messages are typically used for inter-module communication, as when adjacent
@dfn{STREAMS} protocol modules negotiate the terms of their interface.  An @msg{M_CTL} message
cannot be generated by a user-level process and is always discarded if passed to the @dfn{Stream
head}.

@item M_DATA
Intended to contain ordinary data.  Messages allocated by the @manpage{allocb(9)} routine (see @dfn{STREAMS}
Utilities) are type @msg{M_DATA} by default.  @msg{M_DATA} messages are generally sent
bidirectionally on a @dfn{Stream} and their contents can be passed between a process and the
@dfn{Stream head}.  In the @manpage{getmsg(2)} and @manpage{putmsg(2)} system calls, the contents of
@msg{M_DATA} message blocks are referred to as the data part.  Messages composed of multiple
message blocks will typically have @msg{M_DATA} as the message type for all message blocks
following the first.

@item M_DELAY
Sent to a media driver to request a real-time delay on output.  The data buffer associated with this
message is expected to contain an integer to indicate the number of machine ticks of delay desired.
@msg{M_DELAY} messages are typically used to prevent transmitted data from exceeding the buffering
capacity of slower terminals.

The message format is not defined by @dfn{STREAMS} and its use is developer dependent.  Not all
media drivers may understand this message.  This message may be considered a special case of an
@msg{M_CTL} message.  An @msg{M_DELAY} message cannot be generated by a user-level process and is
always discarded if passed to the @dfn{Stream head}.

@item M_IOCTL
Generated by the @dfn{Stream head} in response to @streamio{I_STR}, @streamio{I_LINK}, @streamio{I_UNLINK},
@streamio{I_PLINK}, and @streamio{I_PUNLINK} (@manpage{ioctl(2)} @dfn{STREAMS} system calls, see
@manpage{streamio(7)}), and in response to @command{ioctl} calls which contain a command argument
value not defined in @manpage{streamio(7)}.  When one of these @command{ioctl}s is received from a
user process, the @dfn{Stream head} uses values supplied in the call and values from the process to
create an @msg{M_IOCTL} message containing them, and sends the message downstream.  @msg{M_IOCTL}
messages are intended to perform the general @command{ioctl} functions of character device drivers.

For an @streamio{I_STR} @command{ioctl}, the user values are supplied in a structure of the following
form, provided as an argument to the @command{ioctl} call (see @streamio{I_STR} in
@manpage{streamio(7)}):

@smallexample
struct strioctl @{
    int ic_cmd;                 /* downstream request */
    int ic_timout;              /* ACK/NAK timeout */
    int ic_len;                 /* length of data arg */
    char *ic_dp;                /* ptr to data arg */
@};
@end smallexample

where @var{ic_cmd} is the request (or command) defined by a downstream module or driver,
@var{ic_timout} is the time the @dfn{Stream head} will wait for acknowledgement to the
@msg{M_IOCTL} message before timing out, and @var{ic_dp} is a pointer to an optional data buffer.
On input, @var{ic_len} contains the length of the data in the buffer passed in and, on return from
the call, it contains the length of the data, if any, being returned to the user in the same buffer.

The @msg{M_IOCTL} message format is one @msg{M_IOCTL} message block followed by zero or more
@msg{M_DATA} message blocks.  @dfn{STREAMS} constructs an @msg{M_IOCTL} message block by placing
an @code{iocblk} structure, defined in @header{sys/stream.h}, in its data buffer (@pxref{STREAMS Data
Structures}, for a complete @code{iocblk} structure):

@smallexample
struct iocblk @{
    int ioc_cmd;                /* ioctl command type */
    cred_t *ioc_cr;             /* full credentials */
    uint ioc_id;                /* ioctl identifier */
    uint ioc_count;             /* byte count for ioctl data */
    int ioc_error;              /* error code for M_IOCACK or
                                   M_IOCNAK */
    int ioc_rval;               /* return value for M_IOCACK */
    long ioc_filler[4];         /* reserved for future use */
@};
@end smallexample

For an @streamio{I_STR} @command{ioctl}, @var{ioc_cmd} corresponds to @var{ic_cmd} of the @code{strioctl}
structure.  @var{ioc_cr} points to a credentials structure defining the user process's permissions
(see @header{cred.h}).  Its contents can be tested to determine if the user issuing the
@command{ioctl} call is authorized to do so.  For an @streamio{I_STR} @command{ioctl}, @var{ioc_count} is
the number of data bytes, if any, contained in the message and corresponds to @var{ic_len}.

@var{ioc_id} is an identifier generated internally, and is used by the @dfn{Stream head} to match
each @msg{M_IOCTL} message sent downstream with response messages sent upstream to the @dfn{Stream
head}.  The response message which completes the @dfn{Stream head} processing for the
@command{ioctl} is an @msg{M_IOCACK} (positive acknowledgement) or an @msg{M_IOCNAK} (negative
acknowledgement) message.

For an @streamio{I_STR} @command{ioctl}, if a user supplies data to be sent downstream, the @dfn{Stream
head} copies the data, pointed to by @var{ic_dp} in the @code{strioctl} structure, into
@msg{M_DATA} message blocks and links the blocks to the initial @msg{M_IOCTL} message block.
@var{ioc_count} is copied from @var{ic_len}.  If there are no data, @var{ioc_count} is zero.

If the @dfn{Stream head} does not recognize the command argument of an @command{ioctl}, it creates a
transparent @msg{M_IOCTL} message.  The format of a transparent @msg{M_IOCTL} message is one
@msg{M_IOCTL} message block followed by one @msg{M_DATA} block.  The form of the @code{iocblk}
structure is the same as above.  However, @var{ioc_cmd} is set to the value of the command argument
in the @command{ioctl} system call and @var{ioc_count} is set to @samp{TRANSPARENT}, defined in
@header{sys/stream.h}.  @samp{TRANSPARENT} distinguishes the case where an @streamio{I_STR} @command{ioctl}
may specify a value of @var{ioc_cmd} equivalent to the command argument of a transparent
@command{ioctl}.  The @msg{M_DATA} block of the message contains the value of the @var{arg}
parameter in the @command{ioctl} call.

The first module or driver that understands the @var{ioc_cmd} request contained in the
@msg{M_IOCTL} acts on it.  For an @streamio{I_STR} @command{ioctl}, this action generally includes an
immediate upstream transmission of an @msg{M_IOCACK} message.  For transparent @msg{M_IOCTL}s,
this action generally includes the upstream transmission of an @msg{M_COPYIN} or @msg{M_COPYOUT}
message.

Intermediate modules that do not recognize a particular request must pass the message on.  If a
driver does not recognize the request, or the receiving module can not acknowledge it, an
@msg{M_IOCNAK} message must be returned.

@msg{M_IOCACK} and @msg{M_IOCNAK} message types have the same format as an @msg{M_IOCTL} message
and contain an @code{iocblk} structure in the first block.  An @msg{M_IOCACK} block may be linked
to following @msg{M_DATA} blocks.  If one of these messages reaches the @dfn{Stream head} with an
identifier which does not match that of the currently-outstanding @msg{M_IOCTL} message, the
response message is discarded.  A common means of assuring that the correct identifier is returned
is for the replying module to convert the @msg{M_IOCTL} message into the appropriate response type
and set @var{ioc_count} to 0, if no data are returned.  Then, the @manpage{qreply(9)} utility
(@pxref{STREAMS Utilities}) is used to send the response to the @dfn{Stream head}.

In an @msg{M_IOCACK} or @msg{M_IOCNAK} message, @var{ioc_error} holds any return error condition
set by a downstream module.  If this value is non-zero, it is returned to the user in
@manpage{errno(3)}.  Note that both an @msg{M_IOCNAK} and an @msg{M_IOCACK} may return an error.
@footnote{@value{PACKAGE_TITLE} implementation does not permit @msg{M_IOCACK} to return an error
number and a return value simultaneously.} However, only an @msg{M_IOCACK} can have a return value.
For an @msg{M_IOCACK}, @var{ioc_rval} holds any return value set by a responding module.  For an
@msg{M_IOCNAK}, @var{ioc_rval} is ignored by the @dfn{Stream head}.  If a module processing an
@streamio{I_STR} @command{ioctl} wants to send data to a user process, it must use the @msg{M_IOCACK}
message which it constructs such that the @msg{M_IOCACK} block is linked to one or more following
@msg{M_DATA} blocks containing the user data.  The module must set @var{ioc_count} to the number of
data bytes sent.  The @dfn{Stream head} places the data in the address pointed to by @var{ic_dp} in
the user @streamio{I_STR} strioctl structure.

If a module processing a transparent @command{ioctl} (i.e., it received a transparent
@msg{M_IOCTL}) wants to send data to a user process, it can use only an @msg{M_COPYOUT} message.
For a transparent @command{ioctl}, no data can be sent to the user process in an @msg{M_IOCACK}
message.  All data must have been sent in a preceding @msg{M_COPYOUT} message.  The @dfn{Stream
head} will ignore any data contained in an @msg{M_IOCACK} message (in @msg{M_DATA} blocks) and
will free the blocks.  No data can be sent with an @msg{M_IOCNAK} message for any type of
@msg{M_IOCTL}.  The @dfn{Stream head} will ignore and will free any @msg{M_DATA} blocks.

The @dfn{Stream head} blocks the user process until an @msg{M_IOCACK} or @msg{M_IOCNAK} response
to the @msg{M_IOCTL} (same @var{ioc_id}) is received.  For an @msg{M_IOCTL} generated from an
@streamio{I_STR} @command{ioctl}, the @dfn{Stream head} will "time out" if no response is received in
@var{ic_timout} interval (the user may specify an explicit interval or specify use of the default
interval).  For @msg{M_IOCTL} messages generated from all other @command{ioctl}s, the default
(infinite) is used.@footnote{@value{PACKAGE_TITLE} uses a default of @samp{15} seconds, in
accordance with common practice.}

@item M_PASSFP
Used by @dfn{STREAMS} to pass a file pointer from the @dfn{Stream head} at one end of a @dfn{Stream}
pipe to the @dfn{Stream head} at the other end of the same @dfn{Stream} pipe.

The message is generated as a result of an @streamio{I_SENDFD} @command{ioctl} (see
@manpage{streamio(7)}) issued by a process to the sending @dfn{Stream head}.  @dfn{STREAMS} places
the @msg{M_PASSFP} message directly on the destination @dfn{Stream head}'s read queue to be
retrieved by an @streamio{I_RECVFD} @command{ioctl} (see @manpage{streamio(7)}).  The message is placed
without passing it through the @dfn{Stream} (i.e., it is not seen by any modules or drivers in the
@dfn{Stream}).  This message should never be present on any queue except the read queue of a
@dfn{Stream head}.  Consequently, modules and drivers do not need to recognize this message, and it
can be ignored by module and driver developers.

@item M_PROTO
Intended to contain control information and associated data.  The message format is one or more (see
note) @msg{M_PROTO} message blocks followed by zero or more @msg{M_DATA} message blocks as shown in
@figref{45}.  The semantics of the @msg{M_DATA} and @msg{M_PROTO} message block are determined by
the @dfn{STREAMS} module that receives the message.

The @msg{M_PROTO} message block will typically contain implementation dependent control
information.  @msg{M_PROTO} messages are generally sent bidirectionally on a @dfn{Stream}, and
their contents can be passed between a process and the @dfn{Stream head}.  The contents of the first
message block of an @msg{M_PROTO} message is generally referred to as the control part, and the
contents of any following @msg{M_DATA} message blocks are referred to as the data part.  In the
@manpage{getmsg(2)} and @manpage{putmsg(2)} system calls, the control and data parts are passed
separately.

NOTE: On the write-side, the user can only generate @msg{M_PROTO} messages containing one
@msg{M_PROTO} message block.

Although its use is not recommended, the format of @msg{M_PROTO} and @msg{M_PCPROTO} (generically
@dfn{PROTO}) messages sent upstream to the @dfn{Stream head} allows multiple @dfn{PROTO} blocks at
the beginning of the message.  @manpage{getmsg(2)} will compact the blocks into a single control
part when passing them to the user process.

@figuresized{SPG_fig45,45,@msg{M_PROTO} and @msg{M_PCPROTO} Message Structure,3in}

@item M_RSE
Reserved for internal use.  Modules that do not recognize this message must pass it on.  Drivers
that do not recognize it must free it.

@item M_SETOPTS
Used to alter some characteristics of the @dfn{Stream head}.  It is generated by any downstream
module, and is interpreted by the @dfn{Stream head}.  The data buffer of the message has the
following structure (@pxref{STREAMS Data Structures}, for a complete @code{stroptions} structure):

@smallexample
struct stroptions @{
    ulong so_flags;             /* options to set */
    short so_readopt;           /* read option */
    ushort so_wroff;            /* write offset */
    long so_minpsz;             /* minimum read packet size */
    long so_maxpsz;             /* maximum read packet size */
    ulong so_hiwat;             /* read queue high-water mark */
    ulong so_lowat;             /* read queue low-water mark */
    unsigned char so_band;      /* updata water marks for this band */
@};
@end smallexample

where @var{so_flags} specifies which options are to be altered, and can be any combination of the
following:

@table @stropt

@item SO_ALL
Update all options according to the values specified in the remaining fields of the
@code{stroptions} structure.

@item SO_READOPT
Set the read mode (see @manpage{read(2)}) to @constant{RNORM} (byte stream), @constant{RMSGD} (message
discard), @constant{RMSGN} (message non-discard), @constant{RPROTNORM} (normal protocol), @constant{RPROTDAT} (turn
@msg{M_PROTO} and @msg{M_PCPROTO} messages into @msg{M_DATA} messages), or @constant{RPROTDIS}
(discard @msg{M_PROTO} and @msg{M_PCPROTO} blocks in a message and retain any linked @msg{M_DATA}
blocks) as specified by the value of @var{so_readopt}.

@item SO_WROFF
Direct the @dfn{Stream head} to insert an offset (unwritten area, see @pxref{Write Options})
specified by @var{so_wroff} into the first message block of all @msg{M_DATA} messages created as a
result of a @manpage{write(2)} system call.  The same offset is inserted into the first @msg{M_DATA}
message block, if any, of all messages created by a @manpage{putmsg(2)} system call.  The default
offset is zero.  The offset must be less than the maximum message buffer size (system dependent).
Under certain circumstances, a write offset may not be inserted.

A module or driver must test that @var{b_rptr} in the @code{msgb} structure is greater than
@var{db_base} in the @code{datab} structure to determine that an offset has been inserted in the
first message block.

@item SO_MINPSZ
Change the minimum packet size value associated with the @dfn{Stream head} read queue to
@var{so_minpsz} (see @var{q_minpsz} in the @code{queue} structure, @pxref{STREAMS Data Structures}).
This value is advisory for the module immediately below the @dfn{Stream head}.  It is intended to
limit the size of @msg{M_DATA} messages that the module should put to the @dfn{Stream head}.  There
is no intended minimum size for other message types.  The default value in the @dfn{Stream head} is
zero.

@item SO_MAXPSZ
Change the maximum packet size value associated with the @dfn{Stream head} read queue to
@var{so_maxpsz} (see @var{q_maxpsz} in the @code{queue} structure, @pxref{STREAMS Data Structures}).
This value is advisory for the module immediately below the @dfn{Stream head}.  It is intended to
limit the size of @msg{M_DATA} messages that the module should put to the @dfn{Stream head}.  There
is no intended maximum size for other message types.  The default value in the @dfn{Stream head} is
@samp{INFPSZ}, the maximum @dfn{STREAMS} allows.

@item SO_HIWAT
Change the flow control high water mark (@var{q_hiwat} in the @code{queue} structure, @var{qb_hiwat}
in the @code{qband} structure) on the @dfn{Stream head} read queue to the value specified in
@var{so_hiwat}.

@item SO_LOWAT
Change the flow control low water mark (@var{q_lowat} in the @code{queue} structure, @var{qb_lowat}
in the @code{qband} structure) on the @dfn{Stream head} read queue to the value specified in
@var{so_lowat}.

@item SO_MREADON
Enable the @dfn{Stream head} to generate @msg{M_READ} messages when processing a @manpage{read(2)}
system call.  The message contains the number of bytes the reader is expecting as a @type{long}
value stored in four data bytes.

If both @stropt{SO_MREADON} and @stropt{SO_MREADOFF} are set in @var{so_flags}, @stropt{SO_MREADOFF}
will have precedence.

@item SO_MREADOFF
Disable the @dfn{Stream head} generation of @msg{M_READ} messages when processing a
@manpage{read(2)} system call and there is no data to be read.

This is the default.  If both @stropt{SO_MREADON} and @stropt{SO_MREADOFF} are set in
@var{so_flags}, @stropt{SO_MREADOFF} will have precedence.

@item SO_NDELON
Set non-@dfn{STREAMS} @dfn{tty} semantics for @constant{O_NDELAY} (or @constant{O_NONBLOCK}) processing on
@manpage{read(2)} and @manpage{write(2)} system calls.  If @constant{O_NDELAY} (or @constant{O_NONBLOCK}) is
set, a @manpage{read(2)} will return @samp{0} if no data are waiting to be read at the @dfn{Stream
head}.  If @constant{O_NDELAY} (or @constant{O_NONBLOCK}) is clear, a @manpage{read(2)} will block until
data become available at the @dfn{Stream head}.  (See note below.)  Regardless of the state of
@constant{O_NDELAY} (or @constant{O_NONBLOCK}), a @manpage{write(2)} will block on flow control and will
block if buffers are not available.

If both @stropt{SO_NDELON} and @stropt{SO_NDELOFF} are set in @var{so_flags}, @stropt{SO_NDELOFF} will
have precedence.

NOTE: For conformance with the @cite{POSIX} standard, it is recommended that new applications
use the @constant{O_NONBLOCK} flag whose behaviour is the same as that of @constant{O_NDELAY} unless otherwise
noted.

@item SO_NDELOFF
Set @dfn{STREAMS} semantics for @constant{O_NDELAY} (or @constant{O_NONBLOCK}) processing on
@manpage{read(2)} and @manpage{write(2)} system calls.  If @constant{O_NDELAY} (or
@constant{O_NONBLOCK}) is set, a @manpage{read(2)} will return -1 and set @errno{EAGAIN} in @var{errno} if
no data are waiting to be read at the @dfn{Stream head}.  If @constant{O_NDELAY} (or
@constant{O_NONBLOCK}) is clear, a @manpage{read(2)} will block until data become available at the
@dfn{Stream head}.  (See note above)

If @constant{O_NDELAY} (or @constant{O_NONBLOCK}) is set, a @manpage{write(2)} will return -1 and
set @errno{EAGAIN} in @var{errno} if flow control is in effect when the call is received.  It will block
if buffers are not available.  If @constant{O_NDELAY} (or @constant{O_NONBLOCK}) is set and part of
the buffer has been written and a flow control or buffers not available condition is encountered,
@manpage{write(2)} will terminate and return the number of bytes written.

If @constant{O_NDELAY} (or @constant{O_NONBLOCK}) is clear, a @manpage{write(2)} will block on flow
control and will block if buffers are not available.  This is the default.  If both
@stropt{SO_NDELON} and @stropt{SO_NDELOFF} are set in so_flags, @stropt{SO_NDELOFF} will have
precedence.

In the @dfn{STREAMS}-based pipe mechanism, the behaviour of @manpage{read(2)} and @manpage{write(2)}
is different for the @constant{O_NDELAY} and @constant{O_NONBLOCK} flags.  See @manpage{read(2)} and
@manpage{write(2)} for details.

@item SO_ISTTY
Inform the @dfn{Stream head} that the @dfn{Stream} is acting like a controlling terminal.

For @stropt{SO_ISTTY}, the @dfn{Stream} may or may not be allocated as a controlling terminal via an
@msg{M_SETOPTS} message arriving upstream during open processing.  If the @dfn{Stream head} is opened before
receiving this message, the @dfn{Stream} will not be allocated as a controlling terminal until it
is queued again by a session leader.

@item SO_ISNTTY
Inform the @dfn{Stream head} that the @dfn{Stream} is no longer acting like a controlling terminal.

@item SO_TOSTOP
Stop on background writes to the @dfn{Stream}.

@item SO_TONSTOP
Do not stop on background writes to the @dfn{Stream}.  @stropt{SO_TOSTOP} and @stropt{SO_TONSTOP} are used in
conjunction with job control.

@item SO_BAND
Set water marks in a band.  If the @stropt{SO_BAND} flag is set with the @stropt{SO_HIWAT} or
@stropt{SO_LOWAT} flag, the
so_band field contains the priority band number the so_hiwat and so_lowat fields pertain to.

If the @stropt{SO_BAND} flag is not set and the @stropt{SO_HIWAT} and @stropt{SO_LOWAT} flags are
on, the normal high and low water marks are affected.  The @stropt{SO_BAND} flag has no effect if
@stropt{SO_HIWAT} and @stropt{SO_LOWAT} flags are off.

Only one band's water marks can be updated with a single @msg{M_SETOPTS} message.

@item SO_DELIM
Messages are delimited.@footnote{Although the @constant{SO_DELIM} flag occurs in the @cite{SVR 4
STREAMS Programmer's Guide}, there is no description for the flag.}

@item SO_NODELIM
Turn off message delimiters.@footnote{Although the @constant{SO_NODELIM} flag occurs in the
@cite{SVR 4 STREAMS Programmer's Guide}, there is no description for the flag.}

@item SO_STRHOLD
Enable @command{strwrite()} message coalescing.@footnote{Although the @constant{SO_STRHOLD} flag
occurs in the @cite{SVR 4 STREAMS Programmer's Guide}, there is no description for the flag.}

@item SO_ERROPT
@cite{Solaris@registeredsymbol{}} specific.

@item SO_LOOP
@cite{UnixWare@registeredsymbol{}} specific.  Indicates to the @dfn{Stream head} that this is a
loop-around @dfn{Stream} (i.e. it supports passing of file descriptors).

@item SO_COPYOPT
@cite{Solaris@registeredsymbol{}} specific.
User input-output copy options.

@item SO_MAXBLK
@cite{Solaris@registeredsymbol{}} specific.
Maximum block size.

@end table

@item M_SIG
Sent upstream by modules or drivers to post a signal to a process.  When the message reaches
the front of the @dfn{Stream head} read queue, it evaluates the first data byte of the message as a
signal number, defined in <sys/signal.h>.  (Note that the signal is not generated until it
reaches the front of the @dfn{Stream head} read queue.) The associated signal will be sent to process(es)
under the following conditions:

If the signal is @signal{SIGPOLL}, it will be sent only to those processes that have explicitly
registered to receive the signal (see @streamio{I_SETSIG} in @manref{streamio(7)}).

If the signal is not @signal{SIGPOLL} and the @dfn{Stream} containing the sending module or driver is a
controlling @dfn{tty}, the signal is sent to the associated process group.  A @dfn{Stream} becomes the
controlling @dfn{tty} for its process group if, on @manpage{open(2)}, a module or driver sends an @msg{M_SETOPTS}
message to the @dfn{Stream head} with the @stropt{SO_ISTTY} flag set.

If the signal is not @signal{SIGPOLL} and the @dfn{Stream} is not a controlling @dfn{tty}, no signal is sent,
except in case of @sockio{SIOCSPGRP} and @termio{TIOCSPGRP}.  These two ioctls set the process group field in the
@dfn{Stream head} so the @dfn{Stream} can generate signals even if it is not a controlling @dfn{tty}.

@end table

@node High Priority Messages
@section High Priority Messages

@table @msg

@item M_COPYIN
Generated by a module or driver and sent upstream to request that the @dfn{Stream head} perform a
@manpage{copyin(9)} on behalf of the module or driver.  It is valid only after receiving an @msg{M_IOCTL} message and
before an @msg{M_IOCACK} or @msg{M_IOCNAK}.

The message format is one @msg{M_COPYIN} message block containing a copyreq structure, defined in
<sys/stream.h> (see @dfn{STREAMS} Data Structures for a complete copyreq structure):

@smallexample
struct copyreq @{
    int cq_cmd;                 /* ioctl command (from ioc_cmd) */
    cred_t *cq_cr;              /* full credentials */
    unit cq_id;                 /* ioctl id (from ioc_id) */
    caddr_t cq_addr;            /* address to copy data to/from */
    unit cq_size;               /* number of bytes to copy */
    int cq_flag mblk_t *cq_private;     /* private state information */
    long cq_filler[4];          /* reserved for future use */
@};
@end smallexample

The first three members of the structure correspond to those of the iocblk structure in the
@msg{M_IOCTL} message which allows the same message block to be reused for both structures.  The
@dfn{Stream}
head will guarantee that the message block allocated for the @msg{M_IOCTL} message is large enough to
contain a copyreq structure.  The cq_addr field contains the user space address from which the
data are to be copied.  The cq_size field is the number of bytes to copy from user space.

The cq_private field can be used by a module to point to a message block containing the
module's state information relating to this @command{ioctl}.  The @dfn{Stream head} will copy (without
processing) the contents of this field to the @msg{M_IOCDATA} response message so that the
module can resume the associated state.  If an @msg{M_COPYIN} or @msg{M_COPYOUT} message is freed, @dfn{STREAMS}
will not free any message block pointed to by cq_private.  This is the module's responsibility.

This message should not be queued by a module or driver unless it intends to process the data for
the @command{ioctl}.

@item M_COPYOUT
Generated by a module or driver and sent upstream to request that the @dfn{Stream head} perform a
@manpage{copyout(9)} on behalf of the module or driver.  It is valid only after receiving an @msg{M_IOCTL} message
and before an @msg{M_IOCACK} or @msg{M_IOCNAK}.

The message format is one @msg{M_COPYOUT} message block followed by one or more @msg{M_DATA} blocks.  The
@msg{M_COPYOUT} message block contains a copyreq structure as described in the @msg{M_COPYIN} message with the
following differences: The cq_addr field contains the user space address to which the data are to
be copied.  The cq_size field is the number of bytes to copy to user space.

Data to be copied to user space is contained in the linked @msg{M_DATA} blocks.

This message should not be queued by a module or driver unless it intends to process the data for
the @command{ioctl} in some way.

@item M_ERROR
Sent upstream by modules or drivers to report some downstream error condition.  When the message
reaches the @dfn{Stream head}, the @dfn{Stream} is marked so that all subsequent system calls issued
to the @dfn{Stream}, excluding @manpage{close(2)} and @manpage{poll(2)}, will fail with @var{errno} set to
the first data byte of the message.  @constant{POLLERR} is set if the @dfn{Stream} is being polled
(see @manref{poll(2)}).  All processes sleeping on a system call to the @dfn{Stream} are awakened.
An @msg{M_FLUSH} message with @constant{FLUSHRW} is sent downstream.

The @dfn{Stream head} maintains two error fields, one for the read-side and one for the
write-side.  The one-byte format @msg{M_ERROR} message sets both of these fields to the error
specified by the first byte in the message.

The second style of the @msg{M_ERROR} message is two bytes long.  The first byte is the read error and
the second byte is the write error.  This allows modules to set a different error on the
read-side and write-side.  If one of the bytes is set to @constant{NOERROR}, then the field for the
corresponding side of the @dfn{Stream} is unchanged.  This allows a module to just an error on one side
of the @dfn{Stream}.  For example, if the @dfn{Stream head} was not in an error state and a module sent an
@msg{M_ERROR} message upstream with the first byte set to @errno{EPROTO} and the second byte set
to @constant{NOERROR},
all subsequent read-like system calls (for example, read, getmsg) will fail with @errno{EPROTO}, but all
write-like system calls (for example, write, putmsg) will still succeed.  If a byte is set to
0, the error state is cleared for the corresponding side of the @dfn{Stream}.  The values
@constant{NOERROR}
and 0 are not valid for the one-byte form of the @msg{M_ERROR} message.

@item M_FLUSH
Requests all modules and drivers that receive it to flush their message queues (discard all
messages in those queues) as indicated in the message.  An @msg{M_FLUSH} can originate at the
@dfn{Stream head}, or in any module or driver.  The first byte of the message contains flags that
specify one of the following actions:

@multitable @columnfractions .30 .70
@item @code{FLUSHR}: @tab Flush the read queue of the module.
@item @code{FLUSHW}: @tab Flush the write queue of the module.
@item @code{FLUSHRW}: @tab Flush both the read queue and the write queue of the module.
@item @code{FLUSHBAND}: @tab Flush the message according to the priority associated with the band.
@end multitable

Each module passes this message to its neighbour after flushing its appropriate queue(s), until the
message reaches one of the ends of the @dfn{Stream}.

Drivers are expected to include the following processing for @msg{M_FLUSH} messages.  When an
@msg{M_FLUSH}
message is sent downstream through the write queues in a @dfn{Stream}, the driver at the
@dfn{Stream} end
discards it if the message action indicates that the read queues in the @dfn{Stream} are not to be
flushed (only @constant{FLUSHW} set).  If the message indicates that the read queues are to be flushed,
the driver shuts off the @constant{FLUSHW} flag, and sends the message up the @dfn{Stream}'s read queues.  When a
flush message is sent up a @dfn{Stream}'s read-side, the @dfn{Stream head} checks to see if the write-side of
the @dfn{Stream} is to be flushed.  If only @constant{FLUSHR} is set, the @dfn{Stream head} discards the message.  However,
if the write-side of the @dfn{Stream} is to be flushed, the @dfn{Stream head} sets the
@msg{M_FLUSH} flag to
@constant{FLUSHW} and sends the message down the @dfn{Stream}'s write side.  All modules that enqueue messages
must identify and process this message type.

If @constant{FLUSHBAND} is set, the second byte of the message contains the value of the priority band to
flush.

@item M_HANGUP
Sent upstream by a driver to report that it can no longer send data upstream.  As example, this
might be due to an error, or to a remote line connection being dropped.  When the message
reaches the @dfn{Stream head}, the @dfn{Stream} is marked so that all subsequent @manpage{write(2)}
and @manpage{putmsg(2)}
system calls issued to the @dfn{Stream} will fail and return an @errno{ENXIO} error.  Those ioctls that cause
messages to be sent downstream are also failed.  @constant{POLLHUP} is set if the @dfn{Stream} is being polled (see
@manpage{poll(2)}).

However, subsequent @manpage{read(2)} or @manpage{getmsg(2)} calls to the @dfn{Stream} will not
generate an error.  These calls will return any messages (according to their function) that were on,
or in transit to, the @dfn{Stream head} read queue before the @msg{M_HANGUP} message was received.
When all such messages have been read, @manpage{read(2)} will return 0 and @manpage{getmsg(2)} will
set each of its two length fields to 0.

This message also causes a @signal{SIGHUP} signal to be sent to the controlling process instead of
the foreground process group, since the allocation and deallocation of controlling terminals to a
session is the responsibility of the controlling process.

@item M_IOCACK
Signals the positive acknowledgement of a previous @msg{M_IOCTL} message.  The message format is one
@msg{M_IOCACK} block (containing an iocblk structure, see @msg{M_IOCTL}) followed by zero or more @msg{M_DATA}
blocks.  The iocblk data structure may contain a value in ioc_rval to be returned to the user
process.  It may also contain a value in ioc_error to be returned to the user process in @var{errno}.

If this message is responding to an @streamio{I_STR} ioctl (see @manref{streamio(7)}), it may contain data
from the receiving module or driver to be sent to the user process.  In this case, message format
is one @msg{M_IOCACK} block followed by one or more @msg{M_DATA} blocks containing the user data.  The
@dfn{Stream head} returns the data to the user if there is a corresponding outstanding
@msg{M_IOCTL}
request.  Otherwise, the @msg{M_IOCACK} message is ignored and all blocks in the message are freed.

Data can not be returned in an @msg{M_IOCACK} message responding to a transparent @msg{M_IOCTL}.  The data
must have been sent with preceding @msg{M_COPYOUT} message(s).  If any @msg{M_DATA} blocks follow the
@msg{M_IOCACK} block, the @dfn{Stream head} will ignore and free them.

The format and use of this message type is described further under @msg{M_IOCTL}.

@item M_IOCDATA
Generated by the @dfn{Stream head} and sent downstream as a response to an @msg{M_COPYIN} or
@msg{M_COPYOUT}
message.  The message format is one @msg{M_IOCDATA} message block followed by zero or more @msg{M_DATA} blocks.
The @msg{M_IOCDATA} message block contains a copyresp structure, defined in <sys/stream.h> (see
@dfn{STREAMS} Data Structures for a complete copyresp structure):

@smallexample
struct copyresp @{
    int cp_cmd;                 /* ioctl command (from ioc_cmd) */
    cred_t *cp_cr;              /* full credentials */
    unit cp_id;                 /* ioctl id (from ioc_id) */
    caddr_t cp_rval;            /* status of request: 0 -> success
                                   non_zero -> failure */
    unit cp_pad1;               /* reserved */
    int cp_pad2;                /* reserved */
    mblk_t *cp_private;         /* private state info (from
                                   cq_private) */
    long cp_filler[4];          /* reserved for future use */
@};
@end smallexample

The first three members of the structure correspond to those of the iocblk structure in the
@msg{M_IOCTL} message which allows the same message blocks to be reused for all of the related
transparent messages (@msg{M_COPYIN}, @msg{M_COPYOUT}, @msg{M_IOCACK}, @msg{M_IOCNAK}).  The cp_rval field contains the
result of the request at the @dfn{Stream head}.  Zero indicates success and non-zero indicates
failure.  If failure is indicated, the module should not generate an @msg{M_IOCNAK} message.
It must abort all ioctl processing, clean up its data structures, and return.

The cp_private field is copied from the cq_private field in the associated @msg{M_COPYIN} or
@msg{M_COPYOUT}
message.  It is included in the @msg{M_IOCDATA} message so the message can be self-describing.  This is
intended to simplify ioctl processing by modules and drivers.

If the message is in response to an @msg{M_COPYIN} message and success is indicated, the
@msg{M_IOCDATA} block will be followed by @msg{M_DATA} blocks containing the data copied in.  If
an @msg{M_IOCDATA}
block is reused, any unused fields defined for the resultant message block should be cleared
(particularly in an @msg{M_IOCACK} or @msg{M_IOCNAK}).

This message should not be queued by a module or driver unless it intends to process the data for
the ioctl in some way.

@item M_IOCNAK
Signals the negative acknowledgement (failure) of a previous @msg{M_IOCTL} message.  Its form is one
@msg{M_IOCNAK} block containing an iocblk data structure ( see @msg{M_IOCTL}).  The iocblk structure may contain
a value in ioc_error to be returned to the user process in @var{errno}.  Unlike the @msg{M_IOCACK}, no user data
or return value can be sent with this message.  If any @msg{M_DATA} blocks follow the M_IOCNAK block,
the @dfn{Stream head} will ignore and free them.  When the @dfn{Stream head} receives an M_IOCNAK, the
outstanding ioctl request, if any, will fail.  The format and usage of this message type is
described further under @msg{M_IOCTL}.

@item M_PCPROTO
As the @msg{M_PROTO} message type, except for the priority and the following additional attributes.

When an @msg{M_PCPROTO} message is placed on a queue, its service procedure is always enabled.  The
@dfn{Stream head} will allow only one @msg{M_PCPROTO} message to be placed in its read queue at a time.  If an
@msg{M_PCPROTO} message is already in the queue when another arrives, the second message is silently
discarded and its message blocks freed.

This message is intended to allow data and control information to be sent outside the normal flow
control constraints.

The @manpage{getmsg(2)} and @manpage{putmsg(2)} system calls refer to @msg{M_PCPROTO} messages as high priority messages.

@item M_PCRSE
Reserved for internal use.  Modules that do not recognize this message must pass it on.  Drivers
that do not recognize it must free it.

@item M_PCSIG
As the @msg{M_SIG} message, except for the priority.

@msg{M_PCSIG} is often preferable to the @msg{M_SIG} message especially in @dfn{tty} applications, because
@msg{M_SIG} may
be queued while @msg{M_PCSIG} is more guaranteed to get through quickly.  For example, if one generates
an @msg{M_SIG} message when the @key{DEL} (delete) key is hit on the terminal and one has already typed ahead,
the @msg{M_SIG} message becomes queued and the user does not get the call until it's too late; it becomes
impossible to kill or interrupt a process by hitting a delete key.

@item M_READ
Generated by the @dfn{Stream head} and sent downstream for a @manpage{read(2)} system call if no messages are
waiting to be read at the @dfn{Stream head} and if read notification has been enabled.  Read
notification is enabled with the @stropt{SO_MREADON} flag of the @msg{M_SETOPTS} message and disabled by
use of the @stropt{SO_MREADOFF} flag.  The message content is set to the value of the nbyte parameter (the
number of bytes to be read) in the @manpage{read(2)} call.

@msg{M_READ} is intended to notify modules and drivers of the occurrence of a read.  It is
also intended to support communication between Streams that reside in separate
processors.  The use of the @msg{M_READ} message is developer dependent.  Modules may take specific
action and pass on or free the @msg{M_READ} message.  Modules that do not recognize this message must
pass it on.  All other drivers may or may not take action and then free the message.

This message cannot be generated by a user-level process and should not be generated by a
module or driver.  It is always discarded if passed to the @dfn{Stream head}.

@item M_START
@itemx M_STOP
Request devices to start or stop their output.  They are intended to produce momentary
pauses in a device's output, not to turn devices on or off.

The message format is not defined by @dfn{STREAMS} and its use is developer dependent.  These
messages may be considered special cases of an @msg{M_CTL} message.  These messages cannot be
generated by a user-level process and each is always discarded if passed to the @dfn{Stream head}.

@item M_STARTI
@itemx M_STOPI
As @msg{M_START} and @msg{M_STOP} except that @msg{M_STARTI} and @msg{M_STOPI} are used to start and stop input.

@end table

@node STREAMS Utilities
@appendix STREAMS Utilities
@cindex STREAMS utilities
@menu
* Utility Descriptions::
* DKI Interface::
* Utility Routine Summary::
@end menu

This appendix specifies the set of utility routines provided by @dfn{STREAMS} to assist development
of modules and drivers.

The general purpose of the utilities is to perform functions that are commonly used in modules and
drivers.  However, some utilities also provide the required interrupt environment.  A utility
routine must always be used when operating on a message queue and when accessing the buffer pool.

The utility routines contained in this appendix represent an interface that will be maintained in
subsequent versions of @cite{UNIX@registeredsymbol{} System V}.  Other than these utilities (also
@pxref{Accessible Symbols and Functions}), functions contained in the @dfn{STREAMS} kernel code may
change between versions.

Structure definitions are contained in @ref{@dfn{STREAMS} Data Structures}.  Routine references are
found in this appendix.  The following definitions are used:

@table @dfn
@item Blocked
A queue that can not be enabled due to flow control.

@item Enable
To schedule a queue's service procedure to run.

@item Free
To deallocate a @dfn{STREAMS} message or other data structure.

@item Message block (@code{bp})
A triplet consisting of an @mantype{msgb(9)} structure, a @mantype{datab(9)} structure, and a data
buffer.  It is referenced by its type definition @mantype{mblk_t(9)}.

@item Message (@code{mp})
One or more linked message blocks.  A message is referenced by its first message block.

@item Message queue
Zero or more linked messages associated with a queue (queue structure).

@item Queue (@code{q})
A @mantype{queue(9)} structure.  When it appears with "message" in certain utility description
lines, it means "message queue."

@item Schedule
To place a queue on the internal linked list of queues which will subsequently have their
service procedure called by the @dfn{STREAMS} scheduler.

@end table

The word @dfn{module} will generally mean @dfn{STREAMS} module and/or driver.  The phrase
"next/following module" will generally refer to a module, driver, or @dfn{Stream head}.

@node Utility Descriptions
@appendixsec Utility Descriptions

The @dfn{STREAMS} utility routines are described below.  A summary table is contained at the end of this
appendix.

@appendixsubsec adjmsg-trim bytes in a message

@smallexample
int adjmsg(mblk_t *mp, register int len);
@end smallexample

@manpage{adjmsg(9)} trims bytes from either the head or tail of the message specified by @var{mp}.
If @var{len} is greater than zero, it removes @samp{len} bytes from the beginning of @var{mp}.  If
@var{len} is less than zero, it removes @samp{(-)len} bytes from the end of @var{mp}.  If @var{len}
is zero, @manpage{adjmsg(9)} does nothing.

@manpage{adjmsg(9)} only trims bytes across message blocks of the same type.  It fails if @var{mp}
points to a message containing fewer than @var{len} bytes of similar type at the message position
indicated.

@manpage{adjmsg(9)} returns @samp{1} on success and @samp{0} on failure.

@appendixsubsec allocb-allocate a message and data block

@smallexample
struct msgb *allocb(int size, uint pri);
@end smallexample

@manpage{allocb(9)} returns a pointer to a message block of type @msg{M_DATA}, in which the data
buffer contains at least @var{size} bytes.  @var{pri} is one of @constant{BPRI_LO},
@constant{BPRI_MED}, or @constant{BPRI_HI} and indicates how critically the module needs the buffer.
@var{pri} is currently unused and is maintained only for compatibility with applications developed
prior to @cite{UNIX@registeredsymbol{} System V Release 4.0}.  If a block can not be allocated as
requested, @manpage{allocb(9)} returns a @samp{NULL} pointer.  @cite{UNIX@registeredsymbol{} System
V Release 4.0}.  If a block can not be allocated as requested, @manpage{allocb(9)} returns a
@samp{NULL} pointer.

When a message is allocated via @manpage{allocb(9)} the @member{b_band} field of the @type{mblk_t}
is initially set to zero.  Modules and drivers may set this field if so desired.

@appendixsubsec backq-get pointer to the queue behind a given queue

@smallexample
queue_t *backq(register queue_t *q);
@end smallexample

@manpage{backq(9)} returns a pointer to the queue behind a given queue.  That is, it returns a
pointer to the queue whose @member{q_next}
@c (see @type{queue} structure in @ref{STREAMS Data Structures})
(@pxref{queue})
pointer is @var{q}.  If no such queue exists (as when @var{q} is at a @dfn{Stream end}),
@manpage{backq(9)} returns @samp{NULL}.

@appendixsubsec bcanput-test for flow control in the given priority band

@smallexample
int bcanput(register queue_t *q, unsigned char pri);
@end smallexample

@manpage{bcanput(9)} provides modules and drivers with a way to test flow control in the given
priority band.  It returns @samp{1} if a message of priority @var{pri} can be placed on the queue.
It returns @samp{0} if the priority band is flow controlled and sets the @constant{QWANTW} flag to
zero band (@constant{QB_WANTW} to nonzero band).

If the band does not yet exist on the queue in question, @samp{1} is returned.

The call @samp{bcanput(q, 0)} is equivalent to the call @samp{canput(q)}.

@appendixsubsec bcanputnext-test for flow control in the given priority band

@smallexample
int bcanputnext(register queue_t *q, unsigned char pri);
@end smallexample

@manpage{bacnputnext(9)} provides modules and drivers with a way to test flow control in a given
priority band for the queue pointed to by @samp{q->q_next}.  It returns 1 if the message of priority
@var{pri} can be placed in the queue.  It returns 0 if the priority band is flow controlled and sets
the @constant{QWANTQ} flag for band zero (@constant{QB_WANTW} for a non-zero band).

@manpage{bcanputnext(9)} searches through the @dfn{Stream} (starting at @samp{q->q_next}) until it
finds a queue containing a @command{service} routine, or until it reaches the end of the
@dfn{Stream}.  If found, the queue containing the @command{service} routine is tested to see if a
message in priority band @var{pri} can be enqueued.  If the band is full, @manpage{bcanputnext(9)}
marks the queue to automatically back-enable the caller's service routine when the amount of data in
messages on the queue has reached its low water mark.

If the band does not yet exist on the queue in question, 1 is returned.

@appendixsubsec bufcall-recover from failure of allocb

@smallexample
int bufcall(uint size, int pri, void (*func)(long), long arg);
@end smallexample

@manpage{bufcall(9)} is provided to assist in the event of a block allocation failure.  If
@manref{allocb(9)} returns @samp{NULL}, indicating a message block is not currently available,
@manpage{bufcall(9)} may be invoked.

@manpage{bufcall(9)} arranges for @samp{(*func)(arg)} to be called when a buffer of @var{size} bytes
is available.  @var{pri} is as described in @manref{allocb(9)}.  When @var{func} is called, it has
no user context.  It cannot reference the
@c @code{u_area}
@code{current} @code{task_struct} structure,
and must return without sleeping.  @manpage{bufcall(9)} does not guarantee that the desired buffer
will be available when @var{func} is called since interrupt processing may acquire it.

@manpage{bufcall(9)} returns @samp{1} on success, indicating that the request has been successfully
recorded, and @samp{0} on failure.  On a failure return, @var{func} will never be called.  A failure
indicates a (temporary) inability to allocate required internal data structures.

@appendixsubsec canput-test for room in a queue

@smallexample
int canput(regsiter queue_t *q);
@end smallexample

@manpage{canput(9)} determines if there is room left in a message queue.  If @var{q} does not have a
@command{service} procedure, @manpage{canput(9)} will search further in the same direction in the
@dfn{Stream} until it finds a queue containing a @command{service} procedure (this is the first
queue on which the passed message can actually be enqueued).  If such a queue cannot be found, the
search terminates on the queue at the end of the @dfn{Stream}.  @manpage{canput(9)} tests the queue
found by the search.  If the message queue in this queue is not full, @manpage{canput(9)} returns
@samp{1}.  This return indicates that a message can be put to queue @var{q}.  If the message queue
is full, @manpage{canput(9)} returns @samp{0}.  In this case, the caller is generally referred to as
blocked.

@manpage{canput(9)} only takes into account normal data flow control.

@appendixsubsec canputnext-test for room in the next queue

@smallexample
int canputnext(register queue_t *q);
@end smallexample

@manpage{canputnext(9)} determines if there is room left in a message queue, pointed to by
@samp{q->q_next}.  If the queue does not have a @command{service} procedure, @manpage{canputnext(9)}
will search further in the same direction in the @dfn{Stream} until it finds a queue containing a
@command{service} procedure (this is the first queue on which the passed message can actually be
queued.)  If such a queue cannot be found, the search terminates on the queue at the end of the
@dfn{Stream}.  @manpage{canputnext(9)} tests the queue found by the search.  If the message queue is
in this queue is not full, @manpage{canputnext)9)} returns 1.  This return indicates that a message
can be @manpage{put(9)} to queue @var{q}.  If the message queue is full, @manpage{canputnext(9)}
returns 0.  In this case, the caller is generally referred to as @dfn{blocked}.
@manpage{canputnext(9)} only takes into account  normal data flow control.

@appendixsubsec copyb-copy a message block

@smallexample
mblk_t *copyb(register mblk_t *bp);
@end smallexample

@manpage{copyb(9)} copies the contents of the message block pointed at by @var{bp} into a
newly-allocated message block of at least the same size.  @manpage{copyb(9)} allocates a new block
by calling @manref{allocb(9)}.  All data between the @member{b_rptr} and @member{b_wptr} pointers of
a message block are copied to the new block, and these pointers in the new block are given the same
offset values they had in the original message block.

On successful completion, @manpage{copyb(9)} returns a pointer to the new message block containing
the copied data.  Otherwise, it returns a @samp{NULL} pointer.  The copy is rounded to full word
boundary.

@appendixsubsec copymsg-copy a message

@smallexample
mblk_t *copymsg(register mblk_t *bp);
@end smallexample

@manpage{copymsg(9)} uses @manref{copyb(9)} to copy the message blocks contained in the message
pointed at by @var{bp} to newly allocated message blocks, and links the new message blocks to form
the new message.

On successful completion, @manpage{copymsg(9)} returns a pointer to the new message.  Otherwise, it
returns a @samp{NULL} pointer.

@appendixsubsec datamsg-test whether message is a data message

@smallexample
int datamsg(unsigned char type);

#define datamsg(type) ((type) == M_DATA||(type) == M_PROTO \
        || (type) == M_PCPROTO ||(type) == M_DELAY)
@end smallexample

The @manpage{datamsg(9)} function
(or macro)@footnote{Note that in @cite{UNIX@registeredsymbol{} System V Release 4}
@manpage{datamsg(9)} was defined as a macro instead of a function call.}
returns @constant{TRUE} if @samp{mp->b_datap->db_type} (where @code{mp} is declared as @samp{mblk_t
*mp}) is a data type message (that is, not a control message).  In this case, a data type is
@msg{M_DATA}, @msg{M_PROTO}, @msg{M_PCPROTO}, or @msg{M_DELAY}.  If @samp{mp->b_datap->db_type} is
any other message type, @manpage{datamsg(9)} returns @constant{FALSE}.

@appendixsubsec dupb-duplicate a message block descriptor

@smallexample
mblk_t *dupb(mblk_t *bp);
@end smallexample

@manpage{dupb(9)} duplicates the message block descriptor (@type{mblk_t}) pointed at by @var{bp} by
copying it into a newly allocated message block descriptor.  A message block is formed with the new
message block descriptor pointing to the same data block as the original descriptor.  The reference
count in the data block descriptor (@type{dblk_t}) is incremented.  @manpage{dupb(9)} does not copy
the data buffer, only the message block descriptor.

On successful completion, @manpage{dupb(9)} returns a pointer to the new message block.  If
@manpage{dupb(9)} cannot allocate a new message block descriptor, it returns @samp{NULL}.

This routine allows message blocks that exist on different queues to reference the same data block.
In general, if the contents of a message block with a reference count greater than @samp{1} are to
be modified, @manref{copymsg(9)} should be used to create a new message block and only the new
message block should be modified.  This insures that other references to the original message block
are not invalidated by unwanted changes.

@appendixsubsec dupmsg-duplicate a message

@smallexample
mblk_t *dupmsg(mblk_t *bp);
@end smallexample

@manpage{dupmsg(9)} calls @manref{dupb(9)} to duplicate the message pointed at by @var{bp}, by
copying all individual message block descriptors, and then linking the new message blocks to form
the new message.  @manpage{dupmsg(9)} does not copy data buffers, only message block descriptors.

On successful completion, @manpage{dupmsg(9)} returns a pointer to the new message.  Otherwise, it
returns @samp{NULL}.

@appendixsubsec enableok-re-allow a queue to be scheduled for service

@smallexample
void enableok(queue_t *q);
@end smallexample

@manpage{enableok(9)} cancels the effect of an earlier @manref{noenable(9)} on the same queue
@var{q}.  It allows a queue to be scheduled for service that had previously been excluded from queue
service by a call to @manpage{noenable(9)}.

@appendixsubsec esballoc-allocate message and data blocks

@smallexample
mblk_t *esballoc(unsigned char *base, int size, int pri, frtn_t *fr_rtn);
@end smallexample

@manpage{esballoc(9)} allocates message and data blocks that point directly to a client-supplied
buffer.  @manpage{esballoc(9)} sets @member{db_base}, @member{b_rptr}, and @member{b_wptr} fields to
@var{base} (data buffer start) and @member{db_lim} to @samp{base + size}.  The pointer to struct
@type{free_rtn} is placed in the @member{db_freep} field of the data block.

The success of @manpage{esballoc(9)} depends on the success of @manref{allocb(9)} and that
@var{base}, @var{size}, and @var{fr_rtn} are not @samp{NULL}, in which case @manpage{esballoc(9)}
returns a pointer to a message block.

If an error occurs, @manpage{esballoc(9)} returns @samp{NULL}.

The method by which @type{free_rtn} is called is implementation specific.  Do not assume that
@member{free_func} will or will not be called directly from @dfn{STREAMS} utility routines like
@manpage{freeb(9)}.  The @member{free_func} function must not call another module's @command{put}
procedure nor attempt to acquire a private lock which may be held by another thread across a call to
a @dfn{STREAMS} utility function which could free a message block.  Otherwise, the possibility for
lock recursion and/or deadlock exists.

Note that modules and drivers using @manpage{esballoc(9)} must be prepared to handle calls to the
@manpage{esballoc(9)}'s callback free function after the last instance of the module or driver has
been closed.  To prevent the module text form being unloaded while there are outstanding
@manpage{esballoc(9)} callbacks, modules using @manpage{esballoc(9)} must perform their own kernel
module reference counting.

@appendixsubsec esbbcall - call function when buffer is available

@smallexample
int esbbcall(int pri, void (*func)(long), long arg);
@end smallexample

@manpage{esbbcall(9)}, like @manref{bufcall(9)}, serves as a @manref{timeout(9)} call of
indeterminate length.  If @manpage{esbbcall(9)} is unable to allocate a message and data block
header to go with its externally supplied data buffer, @manpage{esbbcall(9)} can be used to schedule
the routine @var{func}, to be called with the argument @var{arg} when a buffer becomes available.

@appendixsubsec flushband-flush the messages in a given priority band

@smallexample
void flushband(register queue_t *q, unsigned char pri, int flag);
@end smallexample

@manpage{flushband(9)} provides modules and drivers with the capability to flush the messages
associated in a given priority band.  @var{flag} is defined the same as in @manref{flushq(9)}.  If
@var{pri} is zero, only ordinary messages are flushed.  Otherwise, messages are flushed from the
band specified by @var{pri} according to the value of @var{flag}.

@appendixsubsec flushq-flush a queue

@smallexample
void flushq(register queue_t *q, int flag);
@end smallexample

@manpage{flushq(9)} removes messages from the message queue in queue @var{q} and frees them, using
@manref{freemsg(9)}.  If @var{flag} is set to @constant{FLUSHDATA}, @manpage{flushq(9)} discards all
@msg{M_DATA}, @msg{M_PROTO}, @msg{M_PCPROTO}, and @msg{M_DELAY} messages, but leaves all other
messages on the queue.  If @var{flag} is set to @constant{FLUSHALL}, all messages are removed from
the message queue and freed.  @constant{FLUSHALL} and @constant{FLUSHDATA} are defined in
@header{sys/stream.h}.

If a queue behind @var{q} is blocked, @manpage{flushq(9)} may enable the blocked queue, as described
in @manref{putq(9)}.

@appendixsubsec freeb-free a single message block

@smallexample
void freeb(struct msgb *bp);
@end smallexample

@manpage{freeb(9)} will free (deallocate) the message block descriptor pointed at by @var{bp}, and
free the corresponding data block if the reference count (see @manref{dupb(9)}) in the data block
descriptor (@type{datab} structure) is equal to @samp{1}.  If the reference count is greater than
@samp{1}, @manpage{freeb(9)} will not free the data block, but will decrement the reference count.

If the reference count is @samp{1} and if the message was allocated by @manref{esballoc(9)}, the
function specified by the @samp{db_frtnp->free_func} pointer is called with the parameter specified
by @samp{db_frtnp->free_arg}.

@manpage{freeb(9)} cannot be used to free a multi-block message (see @manref{freemsg(9)}).

Note that results will be unpredictable if the @manpage{freeb(9)} is called with a null argument.
One should always check that pointer is non-@dfn{NULL} before using @manpage{freeb(9)}.

@appendixsubsec freemsg-free all message blocks in a message

@smallexample
void freemsg(mblk_t *bp);
@end smallexample

@manpage{freemsg(9)} uses @manref{freeb(9)} to free all message blocks and their corresponding data
blocks for the message pointed at by @var{bp}.

@appendixsubsec freezestr-freeze a stream

@smallexample
void freezestr(queue_t *q);
@end smallexample

@manpage{freezestr(9)} freezes the state of the entire @dfn{STREAM} containing the queue @var{q}.  A
frozen @dfn{STREAM} blocks any thread attempting to enter any @command{open}, @command{close},
@command{put}, or @command{service} routine belonging to any queue instance in the @dfn{Stream}, and
blocks any thread currently within the @dfn{Stream} if it attempts to put messages onto or take
messages off of any queue within the @dfn{Stream} (with the sole exception of the caller).  Threads
blocked by this mechanism remain so until the @dfn{Stream} is thawed by a call to
@manref{unfreezestr(9)}.

Freezing the @dfn{Stream} does not automatically stop all functions that are running within the
@dfn{Stream}; functions will continue to run until they attempt to perform some operation which
changes the state of the @dfn{Stream}, at which point they will be forced to wait for the
@dfn{Stream} to be unfrozen by a call to @manref{unfreezestr(9)}.

@appendixsubsec getadmin-return the pointer to the module

@smallexample
int (*getadmin(ushort mid)) (void);
@end smallexample

@manpage{getadmin(9)} returns the @member{qadmin} pointer to the module identified by @var{mid}.  It
returns @samp{NULL} on error.

@appendixsubsec getmid-return a module id

@smallexample
ushort getmid(char *name);
@end smallexample

@manpage{getmid(9)} returns the module id for the module identified by name.  It returns @samp{0} on
error.

@appendixsubsec getq-get a message from a queue

@smallexample
mblk_t *getq(register queue_t *q);
@end smallexample

@manpage{getq(9)} gets the next available message from the queue pointed at by @var{q}.
@manpage{getq(9)} returns a pointer to the message and removes that message from the queue.  If no
message is queued, @manpage{getq(9)} returns @samp{NULL}.

@manpage{getq(9)}, and certain other utility routines, affect flow control in the @dfn{Stream} as
follows: If @manpage{getq(9)} returns @samp{NULL}, the queue is marked with @constant{QWANTR} so
that the next time a message is placed on it, it will be scheduled for service (enabled, see
@manref{qenable(9)}).  If the data in the enqueued messages in the queue drop below the low water
mark, @member{q_lowat}, and a queue behind the current queue had previously attempted to place a
message in the queue and failed (i.e., was blocked, see @manref{canput(9)}), then the queue behind
the current queue is scheduled for service.

The queue count is maintained on a per-band basis.  Priority band 0 (normal messages) uses
@member{q_count}, @member{q_lowat}, etc.  Nonzero priority bands use the fields in their respective
@mantype{qband(9)} structures (@member{qb_count}, @member{qb_lowat}, etc).  All messages appear on
the same list, linked via their @member{b_next} pointers.

@member{q_count} does not reflect the size of all messages on the queue; it only reflects those
messages in the normal band of flow.

@appendixsubsec insq-put a message at a specific place in a queue

@smallexample
int insq(register queue_t *q, register mblk_t *emp, register mblk_t *mp);
@end smallexample

@manpage{insq(9)} places the message pointed at by @var{mp} in the message queue contained in the
queue pointed at by @var{q} immediately before the already enqueued message pointed at by @var{emp}.
If @var{emp} is @samp{NULL}, the message is placed at the end of the queue.  If @var{emp} is
non-@samp{NULL}, it must point to a message that exists on the queue @var{q}, or a system panic
could result.

If an attempt is made to insert a message out of order in a queue via @manpage{insq(9)}, the message
will not be inserted and the routine fails.

The queue class of the new message is ignored.  However, the priority band of the new message must
adhere to the following ordering:

@smallexample
emp->b_prev->b_band >= mp->b_band >= emp->b_band.
@end smallexample

This routine returns @samp{1} on success and @samp{0} on failure.

The @dfn{Stream} must be frozen by the caller when calling @manpage{insq(9)}.

@appendixsubsec linkb-concatenate two messages into one

@smallexample
void linkb(register mblk_t *mp, register mblk_t *bp);
@end smallexample

@manpage{linkb(9)} puts the message pointed at by @var{bp} at the tail of the message pointed at by
@var{mp}.

@appendixsubsec msgdsize-get the number of data byptes in a message

@smallexample
int msgdsize(register mblk_t *bp);
@end smallexample

@manpage{msgdsize(9)} returns the number of bytes of data in the message pointed at by @var{bp}.
Only bytes included in data blocks of type @msg{M_DATA} are included in the total.

@appendixsubsec msgpullup-concatentate bytes in a message

@smallexample
int msgpullup(mblk_t *mp, int len);
@end smallexample

@manpage{msgpullup(9)} concatenates and aligns the first @var{len} data bytes of the message pointed
to by @var{mp}, copying the data into a new message.  Any remaining bytes in the remaining message
blocks will be copied and linked onto the new message.  The original message is unaltered.

@appendixsubsec noenable-prevent a queue from being scheduled

@smallexample
void noenable(queue_t *q);
@end smallexample

@manpage{noenable(9)} prevents the queue @var{q} from being scheduled for service by
@manref{putq(9)} or @manref{putbq(9)} when these routines enqueue an ordinary priority message, or
by @manref{insq(9)} when it enqueues any message.  @manpage{noenable(9)} does not prevent the
scheduling of queues when a high priority message is enqueued, unless it is enqueued by
@manref{insq(9)}.

@appendixsubsec OTHERQ-get pointer to the mate queue

@smallexample
queue_t *OTHERQ(queue_t *q);

#define OTHERQ(q) ((q)->q_flag & QREADR ? (q)+1 : (q)-1)
@end smallexample

The @manpage{OTHERQ(9)} function
(or macro)@footnote{Note that in @cite{UNIX@registeredsymbol{} System V Release 4}
@manpage{OTHERQ(9)} was implemented as a macro instead of a function call.}
returns a pointer to the mate queue of @var{q}.

If @var{q} is the read queue for the module, it returns a pointer to the module's write queue.  If
@var{q} is the write queue for the module, it returns a pointer to the read queue.

@appendixsubsec pullupmsg-concatenate and align bytes in a message

@smallexample
int pullupmsg(struct msgb *mp, register int len);
@end smallexample

@manpage{pullupmsg(9)} concatenates and aligns the first @var{len} data bytes of the passed message
into a single, contiguous message block.  Proper alignment is hardware-dependent.
@manpage{pullupmsg(9)} only concatenates across message blocks of similar type.  It fails if
@var{mp} points to a message of less than @var{len} bytes of similar type.  If @var{len} is
@samp{-1} @manpage{pullupmsg(9)} concatenates all the like-type blocks in the beginning of the
message pointed at by @var{mp}.

On success, @manpage{pullupmsg(9)} returns @samp{1} and, as a result of the concatenation, it may
have altered the contents of the message pointed to by @var{mp}.  On failure, it returns @samp{0}.

@appendixsubsec put-call a @dfn{STREAMS} put procedure

@smallexample
void put(queue_t *q, mblk_t *mp);
@end smallexample

@manpage{put(9)} calls the @command{put} procedure for the @dfn{STREAMS} queue specified by @var{q},
passing it the message block referenced by @var{mp}.  It is typically used by a driver or module to
call its own @command{put} procedure.

@appendixsubsec putbq-return a message to the beginning of a queue

@smallexample
int putbq(register queue_t *q, register mblk_t *bp);
@end smallexample

@manpage{putbq(9)} puts the message pointed at by @var{bp} at the beginning of the queue pointed at
by @var{q}, in a position in accordance with the message type.  High priority messages are placed at
the head of the queue, followed by priority band messages and ordinary messages.  Ordinary messages
are placed after all high priority and priority band messages, but before all other ordinary
messages already in a queue.  The queue will be scheduled in accordance with the same rules
described in @manref{putq(9)}.  This utility is typically used to replace a message on a queue from
which it was just removed.

A @command{service} procedure must never put a high priority message back on its own queue, as this
would result in an infinitive loop.

@manpage{putbq(9)} returns @samp{1} on success and @samp{0} on failure.

@appendixsubsec putctl-put a control message

@smallexample
int putctl(queue_t *q, int type);
@end smallexample

On @manpage{putctl(9)} creates a control message of type type, and calls the put procedure of the
queue pointed at by @var{q}, with a pointer to the created message as an argument.
@manpage{putctl(9)} allocates new blocks by calling @manref{allocb(9)}.

On successful completion, @manpage{putctl(9)} returns @samp{1}.  It returns @samp{0}, if it cannot
allocate a message block, or if type @msg{M_DATA}, @msg{M_PROTO}, @msg{M_PCPROTO}, or @msg{M_DELAY}
was specified.

@appendixsubsec putctl1-put a control message with a one-byte parameter

@smallexample
int putctl1(queue_t *q, int type, int param);
@end smallexample

@manpage{putctl1(9)} creates a control message of type type with a one-byte parameter @var{param},
and calls the put procedure of the queue pointed at by @var{q}, with a pointer to the created
message as an argument.  @manpage{putctl1(9)} allocates new blocks by calling @manref{allocb(9)}.

On successful completion, @manpage{putctl1(9)} returns @samp{1}.  It returns @samp{0}, if it cannot
allocate a message block, or if type @msg{M_DATA}, @msg{M_PROTO}, or @msg{M_PCPROTO} was specified.
@msg{M_DELAY} is allowed.@footnote{This might be the answer to the @msg{M_DELAY} mystery: it looks
as though @msg{M_DELAY} is acceptable for @manref{putctl1(9)} but not for @manref{putctl(9)}.}

@appendixsubsec putnext-put a message to the next queue

@smallexample
int putnext(queue_t *q, mblk_t *mp);

#define putnext(q, mp) ((*(q)->q_next->q_qinfo->qi_putq)((q)->q_next, (mp)))
@end smallexample

The @manpage{putnext(9)} function
(or macro)@footnote{Note that in @cite{UNIX@registeredsymbol{} System V Release 4}
@manpage{putnext(9)} was implemented as a macro instead of a function call.}
calls the @command{put}
procedure of the next queue in a @dfn{Stream} and passes it a message pointer as an argument.
@var{q} is the calling queue (not the next queue) and @var{mp} is the message to be passed.
@manpage{putnext(9)} is the typical means of passing messages to the next queue in a @dfn{Stream}.

@appendixsubsec putnextctl-put a control message

@smallexample
int putnextctl(queue_t *q, int type);
@end smallexample

@manpage{putnextctl(9)} calls @manref{putctl(9)}, passing the queue pointed to by @samp{q->q_next},
and the message type @var{type}.

@appendixsubsec putnextctl1-put a control message

@smallexample
int putnextctl1(queue_t *q, int type, int param);
@end smallexample

@manpage{putnextctl1(9)} call @manref{putctl1(9)}, passing the queue pointed to by @samp{q->q_next},
the message type @var{type} and the one byte parameter @var{param}.

@appendixsubsec putq-put a message on a queue

@smallexample
int putq(register queue_t *q, register mblk_t *bp);
@end smallexample

@manpage{putq(9)} puts the message pointed at by @var{bp} on the message queue contained in the
queue pointed at by @var{q} and enables that queue.  @manpage{putq(9)} queues messages based on
message queueing priority.

The priority classes are high priority (@samp{type >= QPCTL}), priority band (@samp{type < QPCTL &&
band > 0}), and normal (@samp{type < QPCTL && band == 0}).

@manpage{putq(9)} always enables the queue when a high priority message is queued.
@manpage{putq(9)} is allowed to enable the queue (@constant{QNOENAB} is not set) if the message is
the priority band message, or the @constant{QWANTR} flag is set indicating that the
@command{service} procedure is ready to read the queue.

Note that the @command{service} procedure must never put a priority message back on its own queue,
as this would result in an infinite loop.

@manpage{putq(9)} enables the queue when an ordinary message is queued if the following condition is
set, and enabling is not inhibited by @manref{noenable(9)}: the condition is set if the module has
just been pushed, or if no message was queued on the last @manref{getq(9)} call, and no message has
been queued since.

@manpage{putq(9)} only looks at the priority band in the first message block of a message.  If a
high priority message is passed to @manpage{putq(9)} with a nonzero @member{b_band} value,
@member{b_band} is reset to @samp{0} before placing the message on the queue.  If the message is
passed to @manpage{putq(9)} with @member{b_band} value that is greater than the number of
@mantype{qband(9)} structures associated with the queue, @manpage{putq(9)} tries to allocate a new
@type{qband} structure for each band up to and including the band of the
message.@footnote{@cite{@value{PACKAGE_TITLE}} only allocates the requested band and not
intermediate bands.}

@manpage{putq(9)} is intended to be used from the @command{put} procedure in the same queue in which
the message will be queued.  A module should not call @manpage{putq(9)} directly to pass messages to
a neighbouring module.  @manpage{putq(9)} may be used as the @member{qi_putp} @command{put} procedure
value in either or both of a module's @mantype{qinit(9)} structures.  This effectively bypasses any
@command{put} procedure processing and uses only the module's @command{service} procedure(s).

@manpage{putq(9)} returns @samp{1} on success and @samp{0} on failure.

@appendixsubsec qenable-enable a queue

@smallexample
void qenable(register queue_t *q);
@end smallexample

@manpage{qenable(9)} places the queue pointed at by @var{q} on the linked list of queues that are
ready to be called by the @dfn{STREAMS} scheduler.

@appendixsubsec qprocsoff-disable the put and service routines of a driver or module

@smallexample
void qprocsoff(queue_t *q);
@end smallexample

@manpage{qprocsoff(9)} disables the @command{put} and @command{service} routines of the
@dfn{STREAMS} driver or module.  When the routines are disabled in a module, messages flow around
the module as if it were not present in the @dfn{Stream}.

@manpage{qprocsoff(9)} must be called by the @command{close} routine of an @dfn{MP-SAFE} driver or
module before releasing any resources on which the driver/module's @command{put} and
@command{service} routines depend.  @manpage{qprocsoff(9)} will remove the queue's @command{service}
routines from the list of service routines to be run,@footnote{Check whether
@cite{@value{PACKAGE_TITLE}} does this.} and waits until any concurrent @command{put} or
@command{service} routines are finished.

@dfn{STREAMS} drivers and modules should call @manpage{qprocsoff(9)} exactly once to disable
@command{put} and @command{service} procedures.  An additional effect of calling
@manpage{qprocsoff(9)} is that both read and write queues are flushed.@footnote{Flushing of queues
is only mentioned in @cite{SUPER-UX} documentation.}

The caller cannot have the @dfn{Stream} frozen with @manref{freezestr(9)} when calling this
function.

@appendixsubsec qprocson-enable the put and service routines of a driver or module

@smallexample
void qprocson(queue_t *q);
@end smallexample

@manpage{qprocson(9)} enables the @command{put} and @command{service} routines of the @dfn{STREAMS}
driver or module.  Prior to the call to @command{qprocson(9)}, the @command{put} and
@command{service} procedures of a newly pushed module or newly opened driver are disabled.  For the
module, messages flow around it as if it were not present in the @dfn{Stream}.
@manpage{qproceson(9)} must be called by the first open of an @dfn{MP-SAFE} module or driver after
allocation and initialization of any resource on which the @command{put} and @command{service}
routines depend.

@dfn{STREAMS} drivers and modules should call @manpage{qprocson(9)} exactly once to enable
@command{put} and @command{service} procedures.  @manref{qprocsoff(9)} is called (also exactly once)
to disable these @command{put} and @command{service} procedures.

The caller cannot have the @dfn{Stream} frozen with @manref{freezestr(9)} when calling this
function.

@appendixsubsec qreply-send a message on a @dfn{Stream} in the reverse direction

@smallexample
void qreply(register queue_t *q, mblk_t *bp);
@end smallexample

@manpage{qreply(9)} sends the message pointed at by @var{bp} up (or down) the @dfn{Stream} in the
reverse direction from the queue pointed at by @var{q}.  This is done by locating the partner of
@var{q} (see @manref{OTHERQ(9)}), and then calling the @command{put} procedure of that queue's
neighbour (as in @manref{putnext(9)}).  @manpage{qreply(9)} is typically used to send back a response
(@msg{M_IOCACK} or @msg{M_IOCNAK} message) to an @msg{M_IOCTL} message.

@appendixsubsec qsize-find the number of messages on a queue

@smallexample
int qsize(register queue_t *qp);
@end smallexample

@manpage{qsize(9)} returns the number of messages present in queue @var{qp}.  If there are no
messages on the queue, @manpage{qsize(9)} returns @samp{0}.

@appendixsubsec RD-get pointer to the read queue

@smallexample
queue_t *RD(queue_t *q);

#define RD(q) ((q)-1)
@end smallexample

The @manpage{RD(9)} function
(or macro)@footnote{Note that in @cite{UNIX@registeredsymbol{} System V Release 4}
@manpage{RD(9)} was implemented as a macro instead of a function call.}
accepts a write queue pointer, @var{q}, as an argument and returns a
pointer to the read queue for the same module.

@appendixsubsec rmvb-remove a message block from a message

@smallexample
mblk_t *rmvb(register mblk_t *mp, register mblk_t *bp);
@end smallexample

@manpage{rmvb(9)} removes the message block pointed at by @var{bp} from the message pointed at by
@var{mp}, and then restores the linkage of the message blocks remaining in the message.
@manpage{rmvb(9)} does not free the removed message block.  @manpage{rmvb(9)} returns a pointer to
the head of the resulting message.  If @var{bp} is not contained in @var{mp}, @manpage{rmvb(9)}
returns a @samp{-1}.  If there are no message blocks in the resulting message, @manpage{rmvb(9)}
returns a @samp{NULL} pointer.

@appendixsubsec rmvq-remove a message from a queue

@smallexample
void rmvq(register queue_t *q, register mblk_t *mp);
@end smallexample

@manpage{rmvq(9)} removes the message pointed at by @var{mp} from the message queue in the queue
pointed at by @var{q}, and then restores the linkage of the messages remaining on the queue.  If
@var{mp} does not point to a message that is present on the queue @var{q}, a system panic could
result.

The @dfn{Stream} must be frozen by the caller when calling @manpage{rmvq(9)}.

@appendixsubsec splstr-set processor level

@manpage{splstr(9)} increases the system processor level to block interrupts at a level appropriate
for @dfn{STREAMS} modules and drivers when they are executing critical portions of their code.
@manpage{splstr(9)} returns the processor level at the time of its invocation.  Module developers
are expected to use the standard kernel function @manref{splx(9)}, where the argument @var{s} is the
integer value returned by @manpage{splstr(9)}, to restore the processor level to its previous value
after the critical portions of code are passed.@footnote{@manpage{splstr(9)} alone is unsuitable for
use on @dfn{MP} system.  Use basic locks instead.}

@appendixsubsec strlog-submit messages for logging

@smallexample
int strlog(short mid, short sid, char level, unsigned short flags, char *fmt, unsigned arg1, ...);
@end smallexample

@manpage{strlog(9)} submits messages containing specified information to the @manref{log(7)} driver.
Required definitions are contained in @header{sys/strlog.h} and @header{sys/log.h}.  @var{mid} is
the @dfn{STREAMS} module id number for the module or driver submitting the log message.  @var{sid}
is an internal sub-id number usually used to identify a particular minor device of a driver.
@var{level} is a tracing level that allows selective screening of messages from the tracer.
@var{flags} are any combination of:

@itemize @bullet
@item @constant{SL_ERROR} (the message is for the error logger),
@item @constant{SL_TRACE} (the message is for the tracer),
@item @constant{SL_FATAL} (advisory notification of a fatal error),
@item @constant{SL_NOTIFY} (request that a copy of the message be mailed to the system administrator) (Note that SL_NOTIFY is not an option by itself, but rather a modifier to the SL_ERROR flag),
@item @constant{SL_CONSOLE} (log the message to the console),
@item @constant{SL_WARN} (warning message), and
@item @constant{SL_NOTE} (notice the message).
@end itemize

@var{fmt} is a @manref{printf(3)} style format string, except that @option{%s}, @option{%e},
@option{%E}, @option{%g}, and @option{%G} conversion specifications are not handled.  Up to
@constant{NLOGARGS} numeric or character arguments can be provided.  (See @manref{log(7)}.)

@appendixsubsec strqget-obtain information about a queue or band of the queue

@smallexample
int strqget(register queue_t *q, qfields_t what, register unsigned char pri, long *valp);
@end smallexample

@manpage{strqget(9)} allows modules and drivers to get information about a queue or particular band
of the queue.  The information is returned in the long referenced by @var{valp}.  The fields that
can be obtained are defined by the following:

@smallexample
typedef enum qfields @{
    QHIWAT = 0,
    QLOWAT = 1,
    QMAXPSZ = 2,
    QMINPSZ = 3,
    QCOUNT = 4,
    QFIRST = 5,
    QLAST = 6,
    QFLAG = 7,
    QBAD = 8
@} qfields_t;
@end smallexample

@manpage{strqget(9)} returns @samp{0} on success and an error number on failure.

The @dfn{Stream} must be frozen by the caller when calling @manpage{strqget(9)}.

@appendixsubsec strqset-change information about a queue or band of the queue

@smallexample
int strqset(register queue_t *q, qfields_t what, register unsigned char pri, long val);
@end smallexample

@manpage{strqset(9)} allows modules and drivers to change information about a queue or particular
band of the queue.  The updated information is provided by @var{val}.  This routine returns @samp{0} on
success and an error number on failure.  If the field is intended to be read-only, then the error
@errno{EPERM} is returned and the field is left unchanged.

The @dfn{Stream} must be frozen by the caller when calling @manpage{strqset(9)}.

@appendixsubsec testb-check for an available buffer

@smallexample
int testb(register size, uint pri);
@end smallexample

@manpage{testb(9)} checks for the availability of a message buffer of size @var{size} without
actually retrieving the buffer.  @manpage{testb(9)} returns @samp{1} if the buffer is available, and
@samp{0} if no buffer is available.  A successful return value from @manpage{testb(9)} does not
guarantee that a subsequent @manref{allocb(9)} call will succeed (e.g., in the case of an interrupt
routine taking buffers).

@var{pri} is as described in @manref{allocb(9)}.

@appendixsubsec unbufcall-cancel a bufcall request

@smallexample
void unbufcall(register int id);
@end smallexample

@manpage{unbufcall(9)} cancels a @manref{bufcall(9)} request.  @var{id} identifies an event returned
by the @manref{bufcall(9)} request.

@strong{Caution}: If a @manref{bufcall(9)} request is made and the callback has not occurred before
closing the driver, an @manpage{unbufcall(9)} must be made to cancel the scheduled callback.
Otherwise a system crash may occur.

@appendixsubsec unfreezestr-unfreeze a stream

@smallexample
void unfreezestr(queue_t *q);
@end smallexample

Unfreeze the entire @dfn{Stream} pointed to by the queue @var{q}.

@appendixsubsec unlinkb-remove a message block from the head of a message

@smallexample
mblk_t *unlinkb(register mblk_t *bp);
@end smallexample

@manpage{unlinkb(9)} removes the first message block pointed at by @var{bp} and returns a pointer to
the head of the resulting message.  @manpage{unlinkb(9)} returns a @samp{NULL} pointer if there are
no more message blocks in the message.

@appendixsubsec WR-get pointer to the write queue

@smallexample
queue_t *WR(queue_t *q);

#define WR(q) ((q)+1)
@end smallexample

The @manpage{WR(9)} function
(or macro)@footnote{Note that in @cite{UNIX@registeredsymbol{} System V Release 4}
@manpage{WR(9)} was implemented as a macro instead of a function call.}
accepts a read queue pointer, @var{q}, as an argument and returns a
pointer to the write queue for the same module.

@node DKI Interface
@appendixsec DKI Interface

With the @dfn{DKI} interface (@pxref{Modules and Drivers}), the following @dfn{STREAMS}
utilities are implemented as functions: @manref{datamsg(9)}, @manref{OTHERQ(9)},
@manref{putnext(9)}, @manref{RD(9)}, @manref{splstr(9)}, and @manref{WR(9)}.  @header{sys/ddi.h}
must be included after @header{sys/stream.h} to get function definitions instead of the macros.

@node Utility Routine Summary
@appendixsec Utility Routine Summary

@multitable @columnfractions .30 .70
@item @b{ROUTINE} @tab @b{DESCRIPTION}
@item @command{adjmsg} @tab trim bytes in a message
@item @command{allocb} @tab allocate a message block
@item @command{backq} @tab get pointer to the queue behind a given queue
@item @command{bcanput} @tab test for flow control in a given priority band
@item @command{bcanputnext} @tab test for flow control in the given priority band
@item @command{bufcall} @tab recover from failure of allocb
@item @command{canput} @tab test for room in a queue
@item @command{canputnext} @tab test for room in the next queue
@item @command{copyb} @tab copy a message block
@item @command{copymsg} @tab copy a message
@item @command{datamsg} @tab test whether message is a data message
@item @command{dupb} @tab duplicate a message block descriptor
@item @command{dupmsg} @tab duplicate a message
@item @command{enableok} @tab re-allow a queue to be scheduled for service
@item @command{esballoc} @tab allocate message and data blocks
@item @command{esbbcall} @tab call function when buffer is available
@item @command{flushband} @tab flush messages in a given priority band
@item @command{flushq} @tab flush a queue
@item @command{freeb} @tab free a message block
@item @command{freemsg} @tab free all message blocks in a message
@item @command{freezestr} @tab freeze a stream
@item @command{getadmin} @tab return a pointer to a module
@item @command{getmid} @tab return the module id
@item @command{getq} @tab get a message from a queue
@item @command{insq} @tab put a message at a specific place in a queue
@item @command{linkb} @tab concatenate two messages into one
@item @command{msgdsize} @tab get the number of data bytes in a message
@item @command{msgpullup} @tab concatenate bytes in a message
@item @command{noenable} @tab prevent a queue from being scheduled
@item @command{OTHERQ} @tab get pointer to the mate queue
@item @command{pullupmsg} @tab concatenate and align bytes in a message
@item @command{put} @tab call a @dfn{Stream}'s @command{put} procedure
@item @command{putbq} @tab return a message to the beginning of a queue
@item @command{putctl} @tab put a control message
@item @command{putctl1} @tab put a control message with a one-byte parameter
@item @command{putnext} @tab put a message to the next queue
@item @command{putnextctl} @tab put a control message
@item @command{putnextctl1} @tab put a control message
@item @command{putq} @tab put a message on a queue
@item @command{qenable} @tab enable a queue
@item @command{qprocsoff} @tab disable the put and service routines of a driver or module
@item @command{qprocson} @tab enable the put and service routines of a driver or module
@item @command{qreply} @tab send a message on a @dfn{Stream} in the reverse direction
@item @command{qsize} @tab find the number of messages on a queue
@item @command{RD} @tab get pointer to the read queue
@item @command{rmvb} @tab remove a message block from a message
@item @command{rmvq} @tab remove a message from a queue
@item @command{splstr} @tab set processor level
@item @command{strlog} @tab submit messages for logging
@item @command{strqget} @tab obtain information on a queue or a band of the queue
@item @command{strqset} @tab change information on a queue or a band of the queue
@item @command{testb} @tab check for an available buffer
@item @command{unbufcall} @tab cancel bufcall request
@item @command{unfreezestr} @tab unfreeze a stream
@item @command{unlinkb} @tab remove a message block from the head of a message
@item @command{WR} @tab get pointer to the write queue
@end multitable

@node STREAMS Debugging
@appendix STREAMS Debugging
@cindex STREAMS debugging
@menu
* Debugging::
* crash Command::
* Dump Module Example::
* Error and Trace Logging::
@end menu

@node Debugging
@appendixsec Debugging

This appendix provides some tools to assist in debugging @dfn{STREAMS}-based applications.

The kernel routine @manref{cmn_err(9)} allows printing of formatted strings on a system  console. It
displays a specified message on the console and/or stores  it  in  the  @dfn{putbuf} that is a
circular array in the kernel and contains output from @manref{cmn_err(9)}. Its format is:

@smallexample
#include <sys/cmn_err.h>
cmn_err(level, fmt, ARGS)
        int level;
        char *fmt;
        int ARGS;
@end smallexample

where level can take the following values:

@itemize @bullet
@item @constant{CE_CONT} may be used as simple @manref{printf(3)}. It is used to continue
another message or to display an informative message not associated with an error.

@item @constant{CE_NOTE} report system events. It is used to display a message preceded with
@samp{NOTICE:} This message is used to report system events that do not necessarily require user
action, but may interest the system administrator. For example, a sector on a disk needing to be
accessed repeatedly before it can be accessed correctly might be such an event.

@item @constant{CE_WARN} system events that require user action. This is used to display a
message preceded with @samp{WARNING:} This message is used to report system events that require
immediate attention, such as those where if an action is not taken, the system may panic. For
example, when a peripheral device does not initialize correctly, this level should be used.

@item @constant{CE_PANIC} system panic. This is used to display a message preceded with
@samp{PANIC:} Drivers should specify this level only under the most severe conditions. A valid
use of this level is when the system cannot continue to function. If the error is recoverable,
not essential to continued system operation, do not panic the system. This level halts all
processing.

@item @constant{CE_IPANIC} generates a system panic like @constant{CE_PANIC}, but does not
synchronize the file system before the panic. See @constant{CE_PANIC} for more information.

@end itemize

@var{fmt} and @var{ARGS} are passed to the kernel routine @manref{printf(3)} that runs at
@manref{splhi(9)} and should be used sparingly. If the first character of fmt begins with @key{!}
(an exclamation point) output is directed to @dfn{putbuf}. @dfn{putbuf} can be accessed with the
@manref{crash(1M)} command.  If the destination character begins with @key{^} (a caret) output goes
to the console.  If no destination character is specified, the message is directed to both the
@dfn{putbuf} array and the console.  @manpage{cmn_err(9)} appends each fmt with @samp{\n}, except
for the @constant{CE_CONT} level, even when a message is sent to the @dfn{putbuf} array. @var{ARGS}
specifies a set arguments passed when the message is displayed.  Valid specifications are
@option{%s} (string), @option{%u} (unsigned decimal), @option{%d} (decimal), @option{%o} (octal),
and @option{%x} (hexadecimal). @manpage{cmn_err(9)} does not accept length specifications in
conversion specifications.  For example, @samp{%3d} is ignored.

@node crash Command
@appendixsec crash Command

The   @manpage{crash(1M)}   command   is   used  to  examine  kernel  structures interactively. It
can be used on system dump and on active system.

The following lists crash functions related to STREAMS:

@itemize @bullet
@item @code{dbfree} print data block header free list.
@item @code{dblock} print allocated Streams data block headers.
@item @code{linkblk} print the linkblk table.
@item @code{mbfree} print free Streams message block headers.
@item @code{mblock} print allocated Streams message block headers.
@item @code{pty}  print  pseudo  ttys presently configured. The -l option gives information  on  the  line discipline module ldterm, the -h option provides  information on the pseudo-tty emulation module ptem, and the -s option gives information on the packet module pckt.
@item @code{qrun} print a list of scheduled queues.
@item @code{queue} print STREAMS queues.
@item @code{stream} print the stdata table.
@item @code{strstat} print STREAMS statistics.
@item @code{tty}  print  the  tty table. The -l option prints out details about the line discipline module.
@end itemize

The crash functions @command{dblock}, @command{linkblk}, @command{mblock}, @command{queue}, and
@command{stream} take an optional  table  entry argument or address that is the address of the data
structure.  The  @command{strstat} command gives information about @dfn{STREAMS} event  cells  and
linkblks in addition to message blocks, data blocks, queues,  and  @dfn{Streams}.  On  the output
report represents the number of structures  currently configured. It may change because resources
are allocated as needed.

The following example is a sample output from @manpage{crash(1M)}:

@ignore
Output from @manpage{crash(1M)} may look different depending on the version is used.
Examples in the section were produced using UXP/V, and they were also formatted for easier reference.
@end ignore

@smallexample
    $ crash dump/dump stand/unix
    dumpfile = dump/dump, namelist = stand/unix, outfile = stdout
    >strstat
    ITEM                  CONFIG   ALLOC     FREE       TOTAL       MAX       FAIL
    streams                  102     102        0         826       108       0
    queues                   546     546        0        2689       576       0
    message blocks           175      76       99       62390       399       0
    data blocks              147      76       71       57265       368       0
    link blocks                7       7        0           7         7       0
    streams events             5       4        1           7         5       0

    Count of scheduled queues: 0

    >stream
    STREAM TABLE SIZE = 102
    STREAM TABLE SIZE = 102
     ADDRESS      WRQ     IOCB    VNODE  PUSHCNT  RERR/WERR FLAG
    7bff8900 7c083540   1706f0 7c468904      1 0/0 rslp mrd pdis spip
    7c0c9e00 7c139840   182248 7c139e04      3 0/0 istty mnds ondel
    7bffdb00 7c139c40   1822b4 7c139904      1 0/0 istty
    7c0c8300 7c0cb640   1706f0 7c139d04      1 0/0 mrd pdis spip
    7bff8a00 7c0ca240   182248 7c071604      3 0/0 rslp istty mrd ondel
    7c0c8580 7c0ca640   1822b4 7c0ca304      0 0/0 istty
    7c0c8e00 7c0cab40   1706f0 7c0ca704      1 0/0 mrd pdis spip
@end smallexample

The  following  example  illustrates  debugging  of  a  line  printer.  Knowledge  of  the  data
structures  of  the  driver  is  needed  for debugging. The example starts with the following data
structure of the line printer driver:

@smallexample
struct lp @{
    short lp_flags;
    queue_t *lp_qptr;           /* back pointer to write queue */
@};
extern struct lp lp_lp[];
@end smallexample

The  first  command  @samp{nm lp_lp}  prints the value and type for the line printer  driver  data
structure.  The  second  command @samp{rd 40275750 20} prints  @samp{20}  values  starting from the
location @samp{40275750} (note that the function  @command{rd}  is  alias of @command{od}). The
third command @samp{size queue} gives the size of the queue structure. The next two functions again
give the @samp{20} values  starting at the specified locations in the hexadecimal format.  The
command  @samp{rd -c 4032bf40 32} gives the character representation of the  value  in  the given
location.  The option @option{-x} gives a value in the hexadecimal representation and the option
@option{-a} produces the same in the @dfn{ASCII} format.

@smallexample
 $ /usr/sbin/crash
 dumpfile - /dev/mem, namelist = /stand/unix, outfile = stdout

 >nm lp_lp
 lp_lp 40275750 bss

 >rd 40275750 20
 40275750: 00000000  00000000  00000000  40262f60
 40275760: 00000000  00000000  00000000  00000000
 40275770: 00000000  00000000  00000000  00000000
 40275780: 00000000  00000000  00000000  00000000
 40275790: 00000000  00000000  00000000  00000000

 >size queue
 36

 >rd 40262f60 20
 40262f60: 4017315c  402624a4  4026257c  00000000
 40262f70: 00000000  40275758  0200002e  00000200
 40262f80: 02000100  00000000  00000000  00000000
 40262f90: 00000000  00000000  00000000  00000000
 40262fa0: 00000000  00000000  00000000  00000000

 >rd 402624a4 20
 402624a4: 40262624  00000000  00000000  4032bf40
 402624b4: 4032bf5f  40236884  4026233c  00000000
 402624c4: 00000000  40331fd9  40331fd9  00000000
 402624d4: 00000000  00000000  00000000  4032bf80
 402624e4: 4032bf80  40236894  40262564  00000000

 >rd -c 4032bf40 32
 4032bf40: little red light
 4032bf50:   on the highway

 >rd -x 40262624 20
 40262624: 40262594  402624a4  00000000  4032bd40
 40262634: 4032bd5f  40236804  00000000  00000000
 40262644: 00000000  4030c800  4030c800  402319e4
 40262654: 00000000  00000000  00000000  4032be40
 40262664: 4032be40  40236844  4026239c  00000000

 >rd -a 4032bd40 31
 little red light on the highway
@end smallexample

@node Dump Module Example
@appendixsec Dump Module Example

The following dump module example represents only one way of debugging @dfn{STREAMS} modules and
drivers; using the @manref{strlog(9)} function is another way.  @manpage{strlog(9)} is discussed
later in the chapter.

The @command{dump} module (its creator calls it "primitive but handy at times when a driver is not
working properly or some other anomalies occur") has advantages over logging messages in that it
will print all data passing to and from the module in the order they are received.  One can modify
this module to print more detailed information on the particular types of messages (e.g., special
@msg{M_IOCTL} messages) that a user is interested in.

This @command{dump} module is useful for looking at the sequence of messages passing on a
@dfn{Stream} and to know who is doing what and when.  For example, if a user is faced with a
situation where a module is not passing through some messages correctly and user processes are hung
waiting the messages to be returned, this module may help diagnose the problem.  Another example is
a situation where @msg{M_IOCTL} messages are causing problems in a driver.  This module can help to
pinpoint the messages and their sequence without going back to the source of the programs and trying
to figure out what is happening in particular cases.  This module is also useful in debugging
inter-module communication protocols (e.g., @msg{M_CTL} or @msg{M_PROTO} between two cooperating
modules).

This example should not be used as is for debugging in more than one place.  However, it can be
modified quite easily to print minor device numbers along with each message, so that it can be
inserted in two places around a particular module for looking at both ends of the module
simultaneously.

There are two disadvantages in this module approach: this module cannot be used to debug the console
driver, and it drastically alters the timing characteristics of the machine and the @dfn{Stream} in
which it is running.  Therefore, this example module is not meant to be used for discovering
timing-related problems such as interrupt timing and priority level changes.

The @command{dump} module is given here only as an illustration and a possible aid to developers in
debugging their applications.  First the appropriate header file is provided followed by the master
file and the code.

@smallexample
/* 
 * dump.h Header for DUMP module.
 */
#define DUMPIOC             ('Q' << 8)  /* define to be unique */

#define DUMP_VERB  (DUMPIOC | 1)
#define DUMP_TERSE (DUMPIOC | 2)

#define D_FREE    0             /* slot free */
#define D_USED    1             /* slot in use */

#define D_OUT     1             /* outgoing data */
#define D_IN      2             /* incoming data */

#define D_VERB    0x01          /* verbose option on */

struct dm_str @{
    char dm_use;                /* non-zero if in use */
    char dm_state;              /* for state during console output */
    char dm_flags;              /* flags */
@};
@end smallexample

@smallexample
 *
 * DUMP - STREAMS message dump module
 *
 *FLAG #VEC PREFIX sort #DEV IPL DEPENDENCIES/VARIABLES
   m   -    dump
                                 dump_users[#C](%c%c%c)
                                 dm_ucnt (%1) = (#C)
@end smallexample

@smallexample
/*
 *  DUMP module.   This module prints data and ioctls going to and
 *  from a device in real time.   Printout is on the console.  Usage
 *  is to push it into a Stream between any other modules.
 *
 *  DUMP_VERB    Verbose printing of M_DATA (default)
 *  DUMP_THRSE   Terse printing of data (optional)
 *
 *  The messages it prints begin with "I:" for incoming, "O:" for
 *  outgoing data.   "Ci" or "Co" are for non-data (control) messages.
 *  Data is printed in character or hexadecimal format delimited by ((
 *  and )) at message boundaries.
 */

#include <sys/types.h>		/* required in all modules and
				   drivers */
#include <sys/stream.h>		/* required in all modules and
				   drivers */
#include <sys/param.h>
#include <sys/fcntl.h>
#include <sys/cmn_err.h>
#include <dump.h>		/* local ioctls */
#include <sys/termio.h>

static struct module_info dumprinfo =
    @{ 0x6475, "dump", 0, INFPSZ, 0, 0 @};
static struct module_info dumpwinfo =
    @{ 0x6475, "dump", 0, INFPSZ, 0, 0 @};
static int dumpopen(), dumprput(), dumpwput(), dumpclose();

static struct qinit rinit = @{
    dumprput, NULL, dumpopen, dumpclose, NULL, &dumprinfo, NULL
@};

static struct qinit winit = @{
    dumpwput, NULL, NULL, NULL,, NULL, &dumprinfo, NULL
@};

struct streamtab dumpinfo = @{ &rinit, &winit, NULL, NULL @};

extern int dm_ucnt;		/* count of dm_users */

extern struct dm_str dm_users[]
@end smallexample

@smallexample
/*
 * dumpopen          open us and turn us on.
 */
static int
dumpopen(q, dev, flag, sflag)
	queue_t *q;		/* pointer to read queue */
	dev_t dev;		/* major/minor device number */
	int flag;		/* file open flag */

	int sflag;		/* stream open flag */
@{
    register int i;

    if (q->q_ptr != NULL) @{
	cmn_err(CE_CONT, "^DUMP: re-open slot %d",
		((struct dm_str *) q->q_ptr - dm_users));
	if (flag & O_NDELAY)
	    cmn_err(CE_CONT, "^dump: re-open: O_NDELAY set 0");
	return 0;
    @}
    for (i = 0; i < dm_ucnt; i++) @{
	if (dm_users[i].dm_use = D_FREE) @{
	    dm_users[i].dm_use = D_USED;
	    dm_users[i].dm_state = 0;
	    dm_users[i].dm_flags = D_VERB;
	    q->q_ptr = (caddr_t) &dm_users[1];
	    wr(q)->q_ptr = (caddr_t) &dm_users[1];
	    if (flag & O_NDELAY)
		cmn_err(CE_CONT, "^DUMP: open: O_NDELAY set0");
	    return 0;
	@}
    @}
    return OPENFAIL;
@}
@end smallexample
@smallexample
/* 
 * dumpclose      Close us down.
 */
static int
dumpclose(q, flag)
	queue_t *q;		/* pointer to the read queue */
	int flag;		/* file flags */
@{
    struct dm_str *d;

    d = (struct dm_str *) q->q_ptr;
    d->dm_use = D_FREE;
    d->dm_flags = 0;
    q->q_ptr = 0;
    wr(q)->q_ptr = 0;
    return;
@}
@end smallexample
@smallexample
/* 
 *  dumpwput      Put procedure for WRITE side of module.  Gathers
 *                data from all passing M_DATA messages.  Calls
 *                riutine to handle ioctl calls.
 */
static int
dumpwput(q, mp)
	queue_t *q;		/* pointer to the write queue */
	mblk_t *mp;		/* message pointer */
@{
    struct iocblk *iocp;
    struct dm_str *d;

    d = (struct dm_str *) q->q_ptr;
    if (mp->b_datap->db_type == M_IOCTL) @{
	iocp = (struct iocblk *) mp->b_rptr;
	if ((iocp->ioc_cmd & DUMPIOC) == DUMPIOC) @{
	    dumpioc(q, mp);
	    return;
	@} else @{
	    cmn_err(CE_CONT, "^0o:M_IOCTL %x, cnt %d ",
		    iocp->ioc_cmd, iocp->ioc_count);
	    if ((d->dm_flags & D_VERB) && mp->b_cont)
		dumpshow(mp->b_cont, iocp->ioc_cmd);
	    d->dm_state = 0;
	    putnext(q, mp);
	@}
    @} else if (mp->b_datap->db_type == M_DATA) @{
	dumpgather(q, mp, D_OUT);
	putnext(q, mp);
    @} else @{
	dumpctl(q, mp, d, D_OUT);
	d->dm_state = 0;
	putnext(q, mp);		/* pass message through */
    @}
@}
@end smallexample
@smallexample
/* 
 * dumprput        Read side put procedure.   Snag all M_DATA
 *                 messages.
 */
static int
dumprput(q, mp)
	queue_t *q;		/* pointer to the read queue */
	mklk_t *mp;		/* message pointer */
@{
    struct dm_str *d;

    d = (struct dm_str *) q->q_ptr;
    if (mp->b_datap->db_type == M_DATA) @{
	dumpgather(q, mp, D_IN);

    @} else @{
	dumpctl(q, mp, d, D_IN);
	d->dm_state = 0;
    @}
    putnext(q, mp);		/* pass message through */
@}
@end smallexample
@smallexample
/*
 * dumpgather     Gather info from this data message and print it.  We
 *                do not "putnext", as that is dine by the caller, in
 *                the appropriate direction.
 */
dumpgather(q, mp, dir)
	queue_t *q;
	mblk_t *mp;
	int dir;
@{
    register struct dm_str *d;
    register int sx;
    register unsigned char *readp;
    register mblk_t *tmp;
    int counter;
    char junk[2];

    d = (struct dm_str *) q->q_ptr;
    /* 
     * when dumping to console, check state & print I/O if it
     * changes.
     */
    if (d->dm_state != dir) @{
	d->dm_state = dir;
	cmn_err(CE_CONT, "^lls", ((dir == D_IN) ? "I:" : "O:"));
    @}
    if ((!mp->b_datap) || ((mp->b_wptr) && (mp->b_cont == NULL))) @{
	/* Trap zero length messages going past! */
	cmn_err(CE_CONT, "^DUMP: 0 len data msg %s. ",
		(dir == D_OUT) ? "OUT" : "IN");
	return;
    @}
    cmn_err(CE_CONT, "^@{@{");
    tmp = mp;
    counter = 0;
    sx = splstr();
    junk[1] = ' ';
  more:readp = tmp->b_rptr;
    while (readp < tmp->b_wptr) @{

	if (d->dm_flags & D_VERB) @{
	    if ((*readp >= ' ') && (*readp <= '~')
		&& !(*READP & 0x80)) @{
		junk[0] = *readp;
		cmn_err(CE_CONT, "^%s", junk);
	    @} else
		cmn_err(CE_CONT, "^0x%x", *readp);
	@} else @{
	    ++counter;
	@}
	++readp;
    @}
    if ((tmp->b_cont) && (tmp->b_datap->db_type == M_DATA)) @{
	tmp = tmp->b_cont;
	goto more;
    @}
    if (!(d->dm_flags & D_VERB))
	cmn_err(CE_CONT, "^%d", counter);
    cmn_err(CE_CONT, "^@}@}");
    if (tmp->b_cont && (tmp->b_datap->db_type != M_DATA))
	cmn_err(CE_CONT, "^DUMP: non-data b_cont");
    splx(sx);
@}
@end smallexample
@smallexample
/* 
 * dumpioc         Completely handle one of our ioctl calls, including
 *                 the greply of the message.
 */
dumpioc(q, mp)

	queue_t *q;
	mblk_t *mp;
@{
    register struct iocblk *iocp;
    register struct dm_str *d, *ret;

    d = (struct dm_str *) q->q_ptr;
    iocp = (struct iocblk *) mb->b_datap->db_base;
    cmn_err(CE_CONT, "^DUMP: own ioctl is ");
    switch (iocp->ioc_cmd) @{
    case DUMP_VERB:
	d->dm_flags |= D_VERB;
	cmn_err(CE_CONT, "^DUMP_VERB0");
	break;

    case DUMP_TERSE:
	d->dm_flags &= ~D_VERB;
	cmn_err(CE_CONT, "^DUMP_TERSE0");
	break;

    default:
	mp->b_datap->db_type = M_IOCNAK;
	cmd_err(CE_CONT, "^UNKNOWN DUMP IOCTL x%x0", iocp->ioc_cmd);
	greply(q, mp);
	return;
    @}
    mp->b_datap->db_type = M_IOCACK;
    iocp->ioc_count = 0;
    greply(q, mp);
@}
@end smallexample
@smallexample
/*
 * dumpctl        Display information about control messages.
 */
dumpctl(q, mp, d, dir)
	queue_t *q;
	mblk_t *mp;
	struct dm_str *d;
	int dir;
@{
    cmn_err(CE_CONT, "^0%s: M_", ((dir == D_IN) ? "i" : "o"));
    switch (mp->b_datap->db_type) @{
    case M_DATA:		/* just in case */
	cmn_err(CE_CONT, "^DATA");
	break;

    case M_READ:
	cmn_err(CE_CONT, "^READ");
	break;

    case M_IOCTL:
	cmn_err(CE_CONT, "^IOCTL");
	break;

    case M_IOCACK:
	cmn_err(CE_CONT, "^IOCACK");
	break;

    case M_IOCNAK:
	cmn_err(CE_CONT, "^IOCNAK");
	break;

    case M_IODATA:
	cmn_err(CE_CONT, "^IODATA");
	break;

    case M_CTL:
	cmn_err(CE_CONT, "^CTL");
	break;

    case M_PROTO:
	cmn_err(CE_CONT, "^PROTO");
	break;

    case M_PCPROTO:
	cmn_err(CE_CONT, "^PCPROTO");
	break;

    case M_BREAK:
	cmn_err(CE_CONT, "^BREAK");
	break;

    case M_DELAY:
	cmn_err(CE_CONT, "^DELAY");
	break;

    case M_PASSFP:
	cmn_err(CE_CONT, "^PASSFP");
	break;

    case M_SETOPTS:
	cmn_err(CE_CONT, "^SETOPTS");
	break;

    case M_SIG:
	cmn_err(CE_CONT, "^SIG");
	cmn_err(CE_CONT, "^(%d) ", (int) *mp->b_rptr);
	break;

    case M_ERROR:
	cmn_err(CE_CONT, "^ERROR");
	break;

    case M_HANGUP:
	cmn_err(CE_CONT, "^HANGUP");
	break;

    case M_FLUSH:
	cmn_err(CE_CONT, "^FLUSH");
	break;

    case M_PCSIG:
	cmn_err(CE_CONT, "^PCSIG");
	cmn_err(CE_CONT, "^ (%d) ", (int) *mp->b_rptr);
	break;

    case M_COPYOUT:
	cmn_err(CE_CONT, "^COPYOUT");
	break;

    case M_COPYIN:
	cmn_err(CE_CONT, "^COPYIN");
	break;

    case M_START:
	cmn_err(CE_CONT, "^START");
	break;

    case M_STOP:
	cmn_err(CE_CONT, "^STOP");
	break;

    case M_STARTI:
	cmn_err(CE_CONT, "^STARTI");
	break;

    case M_STOPI:
	cmn_err(CE_CONT, "^STOPI");
	break;

    default:
	cmn_err(CE_CONT, "^Unknown! 07 07");
    @}
@}
@end smallexample
@smallexample
/* 
 * dumpshow          Display information about known ioctls.
 */
dumpshow(mp, cmd)
	mblk_t *mp;		/* pointer to cont block of ioctl
				   message */
	int cmd;		/* ioc_cmd field */
@{
    int i;
    struct timeio *t;

    /* 
     * This is an example of printing data from IOCTL messages that
     * we're interested in. Add others as needed.
     */
    switch (cmd) @{
    case TCSETAF:
	cmn_err(CE_CONT, "^TCSETAF ");
	goto prtall;

    case TCSETA:
	cmn_err(CE_CONT, "^TCSETA ");
	goto prtall;

    case TCSETAW:
	cmn_err(CE_CONT, "^TCSETAW ");
      prtall:
	t = (struct termio *) mp->b_rptr;
	cmn_err(CE_CONT, "^if=%x ; of=%x ; cf=%x ; lf=%x0_cc=",
		t->c_iflag, t->c_oflag, t->c_cflag, t->c_lflag);
	for (i = 0; i < NCC; i++)
	    cmn_err(CE_CONT, "^0x%x ", (int) t->c_cc[1]);
	cmn_err(CE_CONT, "^0");
	break;
    default:
	return;
    @}
@}
@end smallexample

The situation with "cooperating modules" that seems to contradict the basic idea of reuse and
independence of modules has risen in the internationalization context (@pxref{STREAMS-based Terminal
Subsystem}) related to input methods of languages. It turns out that some back-end processing for
input methods can be re-used and the size of the kernel reduced from what would be necessary by
having two different full modules when only front-end processing needs to be different for different
input methods. In this situation, one will save as much space as the size of the back-end module.
The way this relates to the @command{dump} module is that this @command{dump} module can be used to
help debug the protocol between the front-end and back-end modules. (The protocol is standard across
various front-ends.)

@node Error and Trace Logging
@appendixsec Error and Trace Logging

@dfn{STREAMS} error and trace loggers are provided for debugging and for administering @dfn{STREAMS}
modules and drivers. This facility consists of @manref{log(7)}, @manref{strace(1)},
@manref{strclean(1)}, @manref{strerr(1)}, and the @manref{strlog(9)} function.

Any module or driver in any @dfn{Stream} can call the @dfn{STREAMS} logging function
@manpage{strlog(9)}, described in @manref{log(7)}. @manpage{strlog(9)} is also described in
@ref{STREAMS Utilities}. When called, @manpage{strlog(9)} will send formatted text to the error
logger @manpage{strerr(1)}, the trace logger @manpage{strace(1)}, or the console logger.

@figuresized{SPG_fig46,46,Error and Trace Logging,5.5in}

@manpage{strerr(1)} is intended to operate as a daemon process initiated at system startup. A call
to @manpage{strlog(9)} requesting an error to be logged causes an @msg{M_PROTO} message to be sent
to @manpage{strerr(1)}, which formats the contents and places them in a daily file. The utility
@manpage{strclean(1)} is provided to purge daily log files that have not been modified for 3 days.

A call to @manpage{strlog(9)} requesting trace information to be logged causes a similar
@msg{M_PROTO} message to be sent to @manpage{strace(1)}, which places it in a user designated file.
@manpage{strace(1)} is intended to be initiated by a user.  The user can designate the
modules/drivers and severity level of the messages to be accepted for logging by @manpage{strace(1)}.

A user process can submit its own @msg{M_PROTO} messages to the @manpage{log(4)} driver for
inclusion in the logger of its choice through @manref{putmsg(2)}. The messages must be in the same
format required by the logging processes and will be switched to the logger(s) requested in the
message.

The output to the log files is formatted, @dfn{ASCII} text. The files can be processed by standard
system commands such as @manref{grep(1)} or @manref{ed(1)}, or by developer-provided routines.

@node STREAMS Configuration
@appendix STREAMS Configuration
@cindex STREAMS configuration
@menu
* Configuration::
@end menu

@node Configuration
@appendixsec Configuration
@menu
* Configuring STREAMS Modules and Drivers::
* Autopush Facility::
@end menu

@ignore
This appendix contains information about configuring @dfn{STREAMS} modules and drivers into UXP/V.
@end ignore
The information is incremental and presumes the reader is familiar with the configuration mechanism,
which may vary on different processors. An example of how to configure a driver and a module is
included.

This appendix also includes a list of @dfn{STREAMS} related tunable parameters and describes the
autopush facility.

@node Configuring STREAMS Modules and Drivers
@appendixsubsec Configuring STREAMS Modules and Drivers

Each character device that is configured into a @cite{UNIX} system results in an entry being placed in the
kernel @code{cdevsw} table. Entries for @dfn{STREAMS} drivers are also placed in this table. However,
because system calls to @dfn{STREAMS} drivers must be processed by the @dfn{STREAMS} routines, the
configuration mechanism distinguishes between @dfn{STREAMS} drivers and character device drivers in
their associated @code{cdevsw} entries.

The distinction is contained in the @var{d_str} field of the @code{cdevsw} structure. The @var{d_str} field
provides the appropriate single entry point for all system calls on @dfn{STREAMS} files, as shown
below:

@smallexample
extern struct cdevsw @{
   .
   .
   .
   struct streamtab *d_str;
@} cdevsw[]:
@end smallexample

The configuration mechanism forms the @var{d_str} entry name by appending the string "info" to the
@dfn{STREAMS} driver prefix. The "info" entry is a pointer to a streamtab structure (@pxref{STREAMS
Data Structures}) that contains pointers to the qinit structures for the read and write queues of
the driver. The driver must contain the external definition:

@smallexample
struct streamtab prefixinfo =   @{...
@end smallexample

If the @var{d_str} entry contains a non-null pointer, the operating system will recognize the device
as a @dfn{STREAMS} driver and will call the appropriate @dfn{STREAMS} routine. If the entry is null,
a traditional character I/O device @code{cdevsw} interface is used. NOTE that only the streamtab structure
must be externally defined in @dfn{STREAMS} drivers and modules. The streamtab is used to identify
the appropriate open, close, put, service, and administration routines. These driver and module
routines should generally be declared static.

The configuration mechanism supports various combinations of block, character, @dfn{STREAMS}
devices, and @dfn{STREAMS} modules. For example, it is possible to identify a device as a block and
@dfn{STREAMS} device (although this is very unlikely), and entries will be inserted in the
appropriate system switch tables.

When a @dfn{STREAMS} module is configured, an @code{fmodsw} table entry is generated by the
configuration mechanism. The @code{fmodsw} contains the following:

@smallexample
#define FMNAMESZ 8

extern struct fmodsw @{
    char     f_name[FMNAMESZ+1];
    struct   streamtab *f_str;
    int      *f_flag;  /* same as device flag */
@} fmodsw[];
@end smallexample

where @var{f_name} is the name of the module used in @dfn{STREAMS} related ioctl calls. @var{f_str}
is similar to the @var{d_str} entry in the @code{cdevsw} table. It is a pointer to a streamtab structure
which contains pointers to the qinit structures for the read and write queues of this @dfn{STREAMS}
module (as in @dfn{STREAMS} drivers).  The module must contain the external definition:

@smallexample
struct streamtab prefixinfo =   @{ ...
@end smallexample

@appendixsubsubsec Configuration Examples

This section shows examples of configuring the following @dfn{STREAMS} driver and module:

@table @command
@item loop
the @dfn{STREAMS} loop-around software driver of Drivers
@item crmod
the conversion module of Modules
@end table

To configure the @dfn{STREAMS} software (pseudo device) driver, variables, the following must appear
in the master file.

@smallexample
* LOOP - STREAMS loop-around software driver
*
*FLAG  #VEC  PREFIX  SOFT  #DEV  IPL  DEPENDENCIES/VARIABLES
fs     -     loop    62    -     -
                                      loop_loop[NLP ](%i%i)
                                      loop_cnt (%i) = @{NLP @}
$$$$
NLP = 2
@end smallexample

The flag field is set to "fs" which signifies that it is a @dfn{STREAMS} driver and a software
driver. The prefix "loop" requires that the streamtab structure for the driver be defined as
loopinfo. "62" is an arbitrary, software driver major number. The #dev field is "-" which shows that
there are no sub-devices. The next field, dependencies/variables, is optional and contains a list of
other drivers and modules that must be present in the configuration of this driver.

To configure the @dfn{STREAMS} module crmod, the following must appear in the chmod master file.

@smallexample
* CRMOD stream conversion module
*
*FLAG  #VEC  PREFIX  SOFT  #DEV  IPL  DEPENDENCIES/VARIABLES
m      -     crmd
@end smallexample

The flag field is set to "m" which signifies that it is a @dfn{STREAMS} module. The prefix "crmd"
requires that the streamtab structure for the module be defined as crmdinfo. The configuration
mechanism uses the name of the master file (crmod in this case) to create the module name field
(@var{f_name}) of the associated @code{fmodsw} entry. The prefix and module name can be different.

Neither of the given examples are hardware drivers. Configuring a @dfn{STREAMS} hardware driver is
similar to configuring a character I/O hardware driver.

At times, it is useful to make a module both a module and a driver.  There are not many good reasons
to do so, but in some cases it's a good way to solve odd problems. It is done in the following way:

We called our module-driver combination thing in this description.  First, the module open routine
is handled differently. We also need to keep the state flag sflag that tells for any particular
instantiation whether thing is to behave as a module or a driver, because ioctl handling is usually
different depending on whether the thing is a driver or a module. Then, we need to make sure that
the flags are set properly in the master file. Here is a sample master file for thing:

@smallexample
*
*FLAG  #VEC  PREFIX  SOFT  #DEV  IPL  DEPENDENCIES/VARIABLES
fsm    -     can     52    -     -    canstr[#C] (%0x40)
                                      can_cnt (%i) = @{#C@}
$$$$
@end smallexample

Notice the flag field contains "f" for being a Streams driver, "s" for being a software driver, and
"m" for being a Streams module. We need to make sure that the module has a character device node in
the file system, either as a cloneable driver or a regular driver. Once we have rebooted our system,
thing can be opened by its name.

There is a trick in the open routine where sflag is checked:

@smallexample
.
.
.
if (sflag == MODOPEN)
	  /* then the module is being pushed */

else if (sflag == CLONEOPEN)
	  /* then its being opened as a cloneable driver */

else
	  /* its being opened as a reqular driver */
.
.
.
@end smallexample

File systems that support @dfn{STREAMS} devices go through @code{cdevsw} to get the driver open
routine. If @var{d_str} is set, then thing is a @dfn{STREAMS} driver, and it goes to the
@code{fmodsw} to get the open routine. When one pushes a Streams module, the push code also goes to
the @code{fmodsw} looking for the module by name.  Depending on which way the open routine is called
the sflag argument will be MODOPEN, CLONEOPEN, or zero.

@anchor{Tunable Parameters}
@appendixsubsubsec Tunable Parameters

Certain system parameters referenced by @dfn{STREAMS} are configurable when a new operating system
is being built. (Refer to the System Administrator's Guide for more information.). These parameters
are:

@table @constant
@item NSTRPUSH
Maximum number (should be at least 8) of modules that may be pushed onto a single Stream.
@item STRMSGSZ
Maximum number of bytes of information that a single system call can pass to a Stream to be placed
into the data part of a message (in M_DATA blocks). Any @manpage{write(2)} exceeding this size will be broken
into multiple messages. A @manpage{putmsg(2)} with a data part exceeding this size will fail with ERANGE.  If
STRMSGSZ is set to 0, then the number of bytes passed to a Stream is effectively infinitive.
@item STRCTLSZ
Maximum number of bytes of information that a single system call can pass to a Stream to be placed
into the control part of a message (in an M_PROTO or M_PCPROTO block). A @manpage{putmsg(2)} with a control
part exceeding this size will fail with ERANGE.
@end table

@node Autopush Facility
@appendixsubsec Autopush Facility

The Autopush facility (see @manref{autopush(8)}) is a general mechanism that configures the list of
modules for a @dfn{STREAMS} device. It automatically pushes a pre-specified list of modules onto the
Stream when the @dfn{STREAMS} device is opened and the device is not already open.

The @dfn{STREAMS} Administrative Driver (SAD) (see @manref{sad(7)}) provides an interface to the autopush
mechanism. System administrators can open the SAD driver and set or get autopush information on
other drivers.  The SAD driver caches the list of modules to push for each driver.  When the driver
is opened, if not already open, the Stream head checks the SAD's cache to see if the device opened
has been configured to have modules pushed automatically. If an entry is found, the modules are
pushed. If the device has already been opened but has not yet been closed, another open would not
cause the list of the pre-specified modules to be pushed again.

Three options are available to configure the module list:

@itemize @bullet
@item Configure for each minor device that is, a specific major and minor device number.
@item Configure for a range of minor devices within a major device.
@item Configure for all minor devices within a major device.
@end itemize

When the configuration list is cleared, a range of minor devices has to be cleared as a range and
not in parts.

@appendixsubsubsec User Interface

The SAD driver can be accessed via the node /dev/sad/admin or /dev/sad/user. After the device is
initialized, a program can be run to perform any needed autopush configuration. The program should
open the SAD driver, read a configuration file to find out what modules are needed to be configured
for which devices, format the information into strapush structures, and perform the necessary
SAD_SAP ioctls.

All autopush operations are performed through an @manpage{ioctl(2)} command to set or get autopush
information. Only the superuser may set autopush information, but any user may get the autopush
information for a device.

The ioctl is a form of ioctl(fd, cmd, arg), where fd is the file descriptor of the SAD driver, cmd
is either SAD_SAP (set autopush information) or SAD_GAP (get autopush information), and arg is a
pointer to the structure strapush.

The structure strapush is defined as:

@smallexample
/* 
 * maximum number fo modules that can be pushed on a Stream using the
 * autopush feature should be less than NSTRPUSH
 */
#define MAXAPUSH  8

	 /* autopush information common to user and kernel */

struct apcommon @{
    uint apc_cmd;		/* command - see below */
    long apc_major;		/* major device number */
    long apc_minor;		/* minor device number */
    long apc_lastminor;		/* last minor device number for range 
				 */
    uint apc_npush;		/* number of modules to push */
@};

	 /* ap_cmd - various options of autopush */

#define  SAP_CLEAR  0		/* remove configuration list */
#define  SAP_ONE    1		/* configure one minor device */
#define  SAP_RANGE  2		/* configure range of minor device */
#define  SAP_ALL    3		/* configure all minor devices */

	 /* format of autopush ioctls */

struct strapush @{
    struct apcommon sap_common;
    char sap_list[MAXAPUSH][FMNAMESZ + 1];	/* module list */
@};

#define  sap_cmd          sap_common.apc_cmd
#define  sap_major        sap_common.apc_major
#define  sap_minor        sap_common.apc_minor
#define  sap_lastminor    sap_common.apc_lastminor
#define  sap_npush        sap_common.apc_npush
@end smallexample

A device is identified by its major device number, sap_major. The SAD_SAP ioctl (sap_cmd) can take
the following options:

@itemize @bullet
@item @constant{SAP_ONE} configures a single minor device, sap_minor, of a driver.
@item @constant{SAP_RANGE} configures a range of minor devices from sap_minor to sap_lastminor, inclusive.
@item @constant{SAP_ALL} configures all minor devices of a device.
@item @constant{SAP_CLEAR} clears the previous settings by removing the entry with the matching sap_major and sap_minor fields.
@end itemize

The list of modules is specified as a list of module names in sap_list. The maximum number of
modules to push automatically is defined by MAXAPUSH.

A user may query the current configuration status of a given major/minor device by issuing the
SAD_GAP ioctl with sap_major and sap_minor values of the device set. On successful return from this
system call, the strapush structure will be filled in with the corresponding information for that
device.

The following is an example of an autopush configuration file:

@smallexample
21 5 0 mod1 mod2       # configure a single minor device
22 -1 0 mod0 mod5 mod9 # configure all minor devices for major 22
39 3 18 mod7           # configure a range of minor devices
@end smallexample

The first line represents the configuration for a single minor device whose major and minor numbers
are 21 and 5 respectively. Two modules, mod1 and mod2, are automatically pushed on the Stream for
this minor device. mod1 is pushed first, and mod2 is pushed next. The second line represents the
configuration for all minor devices whose major number is 22. Three modules, mod0, mod5, and mod9,
are pushed automatically on the Stream. The last line represents the configuration for the range of
minor devices from 3 to 18 whose major device number is 39.  Only the module, mod7, is pushed with
this configuration.

The maximum number of entries the SAD driver can cache is determined by the tunable parameter
NAUTOPUSH found in the SAD driver's master file.


@node Conformance
@appendix Conformance
@cindex conformance
@menu
* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX comptatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
@end menu

@node SVR 4.2 Compatibility
@appendixsec SVR 4.2 MP DDI/DKI Compatibility
@cindex SVR 4.2 MP, compatibility
@cindex compatibility, SVR 4.2 MP
@cindex SVR 4.2 MP

@node AIX Compatibility
@appendixsec AIX 5L Version 5.1 Compatibility
@cindex AIX 5L Version 5.1, compatibility
@cindex compatibility, AIX 5L Version 5.1
@cindex AIX PSE

@node HP-UX Compatibility
@appendixsec HP-UX 11.0i v2 Compatibility
@cindex HP-UX 11.0i v2, compatibility
@cindex compatibility, HP-UX 11.0i v2
@cindex HP-UX

@node OSF/1 Compatibility
@appendixsec OSF/1 1.2/Digital UNIX Compatibility
@cindex OSF/1 1.2/Digital UNIX, compatibility
@cindex compatibility, OSF/1 1.2/Digital
@cindex OSF/1

@node UnixWare Compatibility
@appendixsec UnixWare 7.1.3 Compatibility
@cindex UnixWare 7.1.3 (OpenUnix 8), compatibility
@cindex compatibility, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@node Solaris Compatibility
@appendixsec Solaris 9/SunOS 5.9 Compatibility
@cindex Solaris 9/SunOS 5.9, compatibility
@cindex compatibility, Solaris 9/SunOS 5.9
@cindex Solaris

@node SUX Compatibility
@appendixsec Super/UX Compatibility
@cindex Super/UX, compatibility
@cindex compatibility, Super/UX
@cindex Super/UX

@node UXP Compatibility
@appendixsec UXP/V Compatibility
@cindex UXP/V, compatibility
@cindex compatibility, UXP/V
@cindex UXP/V

@node Portability
@appendix Portability
@cindex portability

Although each of the manual pages of supported functions and structures provides compatibility and
porting information, this document attempts to gather together pertinent information concerning
porting from various @cite{UNIX} operating system supporting @dfn{STREAMS}.

The porting information is organized by the operating system from which porting is being attempted.
Note that, aside from configuration details, any system not listed here that is based on @cite{SVR
4.2 MP}
@cindex SVR 4.2 MP
or on a another of the implementations, should start with that implementation's portability
information.

Porting information is organized into sections as follows:

@menu
* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3 (OpenUnix 8)
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* Development::			Developing Portable STREAMS Modules
@end menu

@node Core Function Support
@appendixsec Porting with Core Function Support
@cindex porting, core function support

@menu
* Core Message Functions::
* Core UP Queue Functions::
* Core MP Queue Functions::
* Core DDI/DKI Functions::
* Some Common Extension Functions::
* Some Internal Functions::
* Some Oddball Functions::
@end menu

@node Core Message Functions
@appendixsubsec Core Message Functions
@cindex core message functions

@multitable @columnfractions .30 .70
@item @manpage{adjmsg(9)} @tab trim bytes from the front or back of a @dfn{STREAMS} message
@item @manpage{allocb(9)} @tab allocate a @dfn{STREAMS} message and data block
@item @manpage{bufcall(9)} @tab install a buffer callback
@item @manpage{copyb(9)} @tab copy a @dfn{STREAMS} message block
@item @manpage{copymsg(9)} @tab copy a @dfn{STREAMS} message
@item @manpage{datamsg(9)} @tab tests a @dfn{STREAMS} message type for data
@item @manpage{dupb(9)} @tab duplicate a @dfn{STREAMS} message block
@item @manpage{dupmsg(9)} @tab duplicate a @dfn{STREAMS} message
@item @manpage{esballoc(9)} @tab allocate a @dfn{STREAMS} message and data block with a caller supplied data buffer
@item @manpage{freeb(9)} @tab frees a @dfn{STREAMS} message block
@item @manpage{freemsg(9)} @tab frees a @dfn{STREAMS} message
@item @manpage{linkb(9)} @tab link a message block to a @dfn{STREAMS} message
@item @manpage{msgdsize(9)} @tab calculate the size of the data in a @dfn{STREAMS} message
@item @manpage{msgpullup(9)} @tab pull up bytes in a @dfn{STREAMS} message
@item @manpage{pcmsg(9)} @tab test a data block message type for priority control
@item @manpage{pullupmsg(9)} @tab pull up the bytes in a @dfn{STREAMS} message
@item @manpage{rmvb(9)} @tab remove a message block from a @dfn{STREAMS} message
@item @manpage{testb(9)} @tab test if a @dfn{STREAMS} message can be allocated
@item @manpage{unbufcall(9)} @tab remove a @dfn{STREAMS} buffer callback
@item @manpage{unlinkb(9)} @tab unlink a message block from a @dfn{STREAMS} message
@end multitable

@node Core UP Queue Functions
@appendixsubsec Core UP Queue Functions
@cindex core queue functions, UP

@multitable @columnfractions .30 .70
@item @manpage{backq(9)} @tab find the upstream or downstream queue
@item @manpage{bcanput(9)} @tab test flow control on a @dfn{STREAMS} message queue
@item @manpage{canenable(9)} @tab test whether a @dfn{STREAMS} message queue can be scheduled
@item @manpage{enableok(9)} @tab allow a @dfn{STREAMS} message queue to be scheduled
@item @manpage{flushband(9)} @tab flushes band @dfn{STREAMS} messages from a message queue
@item @manpage{flushq(9)} @tab flushes messages from a @dfn{STREAMS} message queue
@item @manpage{getq(9)} @tab gets a message from a @dfn{STREAMS} message queue
@item @manpage{insq(9)} @tab inserts a message into a @dfn{STREAMS} message queue
@item @manpage{noenable(9)} @tab disable a @dfn{STREAMS} message queue from being scheduled
@item @manpage{OTHERQ(9)} @tab return the other queue of a @dfn{STREAMS} queue pair
@item @manpage{putbq(9)} @tab put a message back on a @dfn{STREAMS} message queue
@item @manpage{putctl(9)} @tab put a control message on a @dfn{STREAMS} message queue
@item @manpage{putctl1(9)} @tab put a 1 byte control message on a @dfn{STREAMS} message queue
@item @manpage{putq(9)} @tab put a message on a @dfn{STREAMS} message queue
@item @manpage{qenable(9)} @tab schedules a @dfn{STREAMS} message queue service routine
@item @manpage{qreply(9)} @tab replies to a message from a @dfn{STREAMS} message queue
@item @manpage{qsize(9)} @tab return the number of message on a queue
@item @manpage{RD(9)} @tab return the read queue of a @dfn{STREAMS} queue pair
@item @manpage{rmvq(9)} @tab remove a message from a @dfn{STREAMS} message queue
@item @manpage{SAMESTR(9)} @tab test for @dfn{STREAMS} pipe or @dfn{FIFO}
@item @manpage{WR(9)} @tab return the write queue of a @dfn{STREAMS} queue pair
@end multitable

@node Core MP Queue Functions
@appendixsubsec Core MP Queue Functions
@cindex core queue functions, MP

@multitable @columnfractions .30 .70
@item @manpage{canputnext(9)} @tab test flow control on a message queue
@item @manpage{canputnext(9)} @tab test flow control on a message queue
@item @manpage{freezestr(9)} @tab freeze the state of a stream queue
@item @manpage{put(9)} @tab invoke the put procedure for a @dfn{STREAMS} module or driver with a @dfn{STREAMS} message
@item @manpage{putnext(9)} @tab put a message on the downstream @dfn{STREAMS} message queue
@item @manpage{putnextctl1(9)} @tab put a 1 byte control message on the downstream @dfn{STREAMS} message queue
@item @manpage{putnextctl(9)} @tab put a control message on the downstream @dfn{STREAMS} message queue
@item @manpage{qprocsoff(9)} @tab disables @dfn{STREAMS} message queue processing for multi-processing
@item @manpage{qprocson(9)} @tab enables @dfn{STREAMS} message queue processing for multi-processing
@item @manpage{strqget(9)} @tab gets information about a @dfn{STREAMS} message queue
@item @manpage{strqset(9)} @tab sets attributes of a @dfn{STREAMS} message queue
@item @manpage{unfreezestr(9)} @tab thaw the state of a stream queue
@end multitable

@node Core DDI/DKI Functions
@appendixsubsec Core DDI/DKI Functions
@cindex core ddi/dki functions
@cindex DDI/DKI

@multitable @columnfractions .30 .70
@item @manpage{kmem_alloc(9)} @tab allocate kernel memory
@item @manpage{kmem_free(9)} @tab deallocates kernel memory
@item @manpage{kmem_zalloc(9)} @tab allocate and zero kernel memory
@item @manpage{cmn_err(9)} @tab print a kernel command error
@item @manpage{bcopy(9)} @tab copy byte strings
@item @manpage{bzero(9)} @tab zero a byte string
@item @manpage{copyin(9)} @tab copy user data in from user space to kernel space
@item @manpage{copyout(9)} @tab copy user data in from kernel space to user space
@item @manpage{delay(9)} @tab postpone the calling process for a number of clock ticks
@item @manpage{drv_getparm(9)} @tab driver retrieve kernel parameter
@item @manpage{drv_hztomsec(9)} @tab convert kernel tick time between microseconds or milliseconds
@item @manpage{drv_htztousec(9)} @tab convert kernel tick time between microseconds or milliseconds
@item @manpage{drv_msectohz(9)} @tab convert kernel tick time between microseconds or milliseconds
@item @manpage{drv_priv(9)} @tab check if the current process is privileged
@item @manpage{drv_usectohz(9)} @tab convert kernel tick time between microseconds or milliseconds
@item @manpage{drv_usecwait(9)} @tab delay for a number of microseconds
@item @manpage{min(9)} @tab determine the minimum of two integers
@item @manpage{max(9)} @tab determine the maximum of two integers
@item @manpage{getmajor(9)} @tab get the internal major device number for a device
@item @manpage{getminor(9)} @tab get the extended minor device number for a device
@item @manpage{makedevice(9)} @tab create a device from a major and minor device numbers
@item @manpage{strlog(9)} @tab pass a message to the @dfn{STREAMS} logger
@item @manpage{timeout(9)} @tab start a timer
@item @manpage{untimeout(9)} @tab stop a timer
@end multitable

@multitable @columnfractions .30 .70
@item @manpage{mknod(9)} @tab make block or character special files
@item @manpage{mount(9)} @tab mount and unmount file systems
@item @manpage{umount(9)} @tab mount and unmount file systems
@item @manpage{unlink(9)} @tab remove a file
@end multitable

@node Some Common Extension Functions
@appendixsubsec Some Common Extension Functions
@cindex common extension functions

@multitable @columnfractions .30 .70
@item @manpage{linkmsg(9)} @tab link a message block to a @dfn{STREAMS} message
@item @manpage{putctl2(9)} @tab put a two byte control message on a @dfn{STREAMS} message queue
@item @manpage{putnextctl2(9)} @tab put a two byte control message on the downstream @dfn{STREAMS} message queue
@item @manpage{weldq(9)} @tab weld two (or four) queues together
@item @manpage{unweldq(9)} @tab unweld two (or four) queues
@end multitable

@node Some Internal Functions
@appendixsubsec Some Internal Functions
@cindex internal functions

@multitable @columnfractions .30 .70
@item @manpage{allocq(9)} @tab allocate a @dfn{STREAMS} queue pair
@item @manpage{bcanget(9)} @tab test for message arrival on a band on a stream
@item @manpage{canget(9)} @tab test for message arrival on a stream
@item @manpage{freeq(9)} @tab deallocate a @dfn{STREAMS} queue pair
@item @manpage{qattach(9)} @tab attach a module onto a @dfn{STREAMS} file
@item @manpage{qclose(9)} @tab close a @dfn{STREAMS} module or driver
@item @manpage{qdetach(9)} @tab detach a module from a @dfn{STREAMS} file
@item @manpage{qopen(9)} @tab call a @dfn{STREAMS} module or driver open routine
@item @manpage{setq(9)} @tab set sizes and procedures associated with a @dfn{STREAMS} message queue
@end multitable

@node Some Oddball Functions
@appendixsubsec Some Oddball Functions
@cindex oddball functions

@multitable @columnfractions .30 .70
@item @manpage{appq(9)} @tab append one @dfn{STREAMS} message after another @*
@item @manpage{esbbcall(9)} @tab install a buffer callback for an extended @dfn{STREAMS} message block @*
@item @manpage{isdatablk(9)} @tab test a @dfn{STREAMS} data block for data type @*
@item @manpage{isdatamsg(9)} @tab test a @dfn{STREAMS} data block for data type @*
@item @manpage{kmem_zalloc_node(9)} @tab allocate and zero memory on a node @*
@item @manpage{msgsize(9)} @tab calculate the size of the message blocks in a @dfn{STREAMS} message @*
@item @manpage{qcountstrm(9)} @tab add all counts on all @dfn{STREAMS} message queues in a stream @*
@item @manpage{xmsgsize(9)} @tab calculate the size of message blocks in a @dfn{STREAMS} message @*
@end multitable

@node SVR 4.2 Portability
@appendixsec Porting from SVR 4.2 MP
@cindex porting, SVR 4.2 MP
@cindex SVR 4.2 MP, portability
@cindex SVR 4.2 MP

This section captures portability information for @cite{SVR 4.2 MP} based systems.  If the operating system
from which you are porting more closely fits one of the other portability sections, please see that
section.

@menu
* Differences from SVR 4.2 MP::
* Commonalities with SVR 4.2 MP::
* Compatibility functions for SVR 4.2 MP::
* Configuration ala SVR 4.2 MP::
@end menu

@node Differences from SVR 4.2 MP
@appendixsubsec Differences from SVR 4.2 MP
@cindex differences, SVR 4.2 MP
@cindex SVR 4.2 MP, differences
@cindex SVR 4.2 MP

@dfn{@value{PACKAGE_TITLE}} has very few differences from @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
Not all @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions are implemented in the base @dfn{@value{PACKAGE_TITLE}} kernel modules.  Some functions are
included in the @cite{SVR 4.2 MP} compatibility module, @file{streams-svr4compat.o}.

@node Commonalities with SVR 4.2 MP
@appendixsubsec Commonalities with SVR 4.2 MP
@cindex commonalities, SVR 4.2 MP
@cindex SVR 4.2 MP, commonalities
@cindex SVR 4.2 MP

@node Compatibility functions for SVR 4.2 MP
@appendixsubsec Compatibility functions for SVR 4.2 MP
@cindex compatibility functions, SVR 4.2 MP
@cindex SVR 4.2 MP, compatibility functions
@cindex SVR 4.2 MP

@multitable @columnfractions .30 .70
@item @manpage{itimeout(9)} @tab Perform a timeout at an interrupt level.
@item @manpage{lbolt(9)} @tab Time in ticks since reboot.
@item @manpage{sleep(9)} @tab Put a process to sleep.
@item @manpage{wakeup(9)} @tab Wake a process.
@item @manpage{vtop(9)} @tab Convert virtual to physical address.
@end multitable

@appendixsubsubsec Priority Levels

@b{Linux} has a different concept of priority levels than @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
@b{Linux} has basically 4 priority levels as follows:

@enumerate

@item Preemptive

At this priority level, software and hardware interrupts are enabled and the kernel is executing
with preemption enabled.  This means that the currently executing kernel thread could preempt and
sleep in favour of another thread of kernel execution.

This priority level only exists on preemptive (mostly 2.6) kernels.

@item Non-Preemptive

At this priority level, software and hardware interrupts are enabled and the kernel is executing
with preemption disabled.  This means that the currently executing kernel thread will only be
interrupted by software or hardware interrupts.

This priority level exists in all kernels.

@item Software Interrupts Disabled

At this priority level, software interrupts are disabled and the kernel is executing with preemption
disabled.  This means that the currently executing kernel thread will only be interrupted by
hardware interrupts.

This is the case when the executing thread is processing a software interrupt, or when the currently
executing thread has disabled software interrupts.

This priority level exists in all kernels.

@item Interrupt Service Routines Disabled

At this priority level, hardware interrupts are disabled and the kernel is executing with preemption
disabled.  This means that the currently executing kernel thread will not be interrupted.

This is the case when the executing thread is processing a hardware interrupt, or when the currently
executing thread has disabled hardware interrupts.

This priority level exists in all kernels.

@end enumerate

@multitable @columnfractions .30 .70
@item @manpage{spl0(9)} @tab Set priority level 0.
@item @manpage{spl1(9)} @tab Set priority level 1.
@item @manpage{spl2(9)} @tab Set priority level 2.
@item @manpage{spl3(9)} @tab Set priority level 3.
@item @manpage{spl4(9)} @tab Set priority level 4.
@item @manpage{spl5(9)} @tab Set priority level 5.
@item @manpage{spl7(9)} @tab Set priority level 6.
@item @manpage{spl7(9)} @tab Set priority level 7.
@item @manpage{spl(9)} @tab Set priority level.
@item @manpage{splx(9)} @tab Set priority level x.
@end multitable

@appendixsubsubsec Atomic Integers

@multitable @columnfractions .30 .70
@item @manpage{ATOMIC_INT_ADD(9)} @tab Add an integer value to an atomic integer.
@item @manpage{ATOMIC_INT_ALLOC(9)} @tab Allocate and initialize an atomic integer.
@item @manpage{ATOMIC_INT_DEALLOC(9)} @tab Deallocate an atomic integer.
@item @manpage{ATOMIC_INT_DECR(9)} @tab Decrement and test an atomic integer.
@item @manpage{ATOMIC_INT_INCR(9)} @tab Increment an atomic integer.
@item @manpage{ATOMIC_INT_INIT(9)} @tab Initialize an atomic integer.
@item @manpage{ATOMIC_INT_READ(9)} @tab Read an atomic integer.
@item @manpage{ATOMIC_INT_SUB(9)} @tab Subtract and integer value from an atomic integer.
@item @manpage{ATOMIC_INT_WRITE(9)} @tab Write an integer value to an atomic integer.
@end multitable

@appendixsubsubsec Basic Locks

@multitable @columnfractions .30 .70
@item @manpage{LOCK(9)} @tab Lock a basic lock.
@item @manpage{LOCK_ALLOC(9)} @tab Allocate a basic lock.
@item @manpage{LOCK_DEALLOC(9)} @tab Deallocate a basic lock.
@item @manpage{LOCK_OWNED(9)} @tab Determine whether a basic lock is head by the caller.
@item @manpage{TRYLOCK(9)} @tab Try to lock a basic lock.
@item @manpage{UNLOCK(9)} @tab Unlock a basic lock.
@end multitable

@appendixsubsubsec STREAMS Locks

@multitable @columnfractions .30 .70
@item @manpage{MPSTR_QLOCK(9)} @tab Release a queue from exclusive access.
@item @manpage{MPSTR_QRELE(9)} @tab Acquire a queue for exclusive access.
@item @manpage{MPSTR_STPLOCK(9)} @tab Acquire a stream head for exclusive access.
@item @manpage{MPSTR_STPRELE(9)} @tab Release a stream head from exclusive access.
@end multitable

@appendixsubsubsec Read/Write Locks

@multitable @columnfractions .30 .70
@item @manpage{RW_ALLOC(9)} @tab Allocate and initialize a read/write lock.
@item @manpage{RW_DEALLOC(9)} @tab Deallocate a read/write lock.
@item @manpage{RW_RDLOCK(9)} @tab Acquire a read/write lock in read mode.
@item @manpage{RW_TRYRDLOCK(9)} @tab Attempt to acquire a read/write lock in read mode.
@item @manpage{RW_TRYWRLOCK(9)} @tab Attempt to acquire a read/write lock in write mode.
@item @manpage{RW_UNLOCK(9)} @tab Release a read/write lock.
@item @manpage{RW_WRLOCK(9)} @tab Acquire a read/write lock in write mode.
@end multitable

@appendixsubsubsec Sleep Locks

@multitable @columnfractions .30 .70
@item @manpage{SLEEP_ALLOC(9)} @tab Allocate a sleep lock.
@item @manpage{SLEEP_DEALLOC(9)} @tab Deallocate a sleep lock.
@item @manpage{SLEEP_LOCK(9)} @tab Acquire a sleep lock.
@item @manpage{SLEEP_LOCKAVAIL(9)} @tab Determine whether a sleep lock is available.
@item @manpage{SLEEP_LOCKOWNED(9)} @tab Determine whether a sleep lock is held by the caller.
@item @manpage{SLEEP_LOCK_SIG(9)} @tab Acquire a sleep lock.
@item @manpage{SLEEP_TRYLOCK(9)} @tab Attempt to acquire a sleep lock.
@item @manpage{SLEEP_UNLOCK(9)} @tab Release a sleep lock.
@end multitable

@appendixsubsubsec Synchronization Variables

@multitable @columnfractions .30 .70
@item @manpage{SV_ALLOC(9)} @tab Allocate a basic condition variable.
@item @manpage{SV_BROADCAST(9)} @tab Broadcast a basic condition variable.
@item @manpage{SV_DEALLOC(9)} @tab Deallocate a basic condition variable.
@item @manpage{SV_SIGNAL(9)} @tab Signal a basic condition variable.
@item @manpage{SV_WAIT(9)} @tab Wait on a basic condition variable.
@item @manpage{SV_WAIT_SIG(9)} @tab Interruptible wait on a basic condition variable.
@end multitable

@appendixsubsubsec Resource Allocation

@multitable @columnfractions .30 .70
@item @manpage{rmalloc(9)} @tab Allocate a number of units from a resource map.
@item @manpage{rmallocmap(9)} @tab Allocated a resource map.
@item @manpage{rmallocmap_wait(9)} @tab Allocated a resource map.
@item @manpage{rmalloc_wait(9)} @tab Allocate a number of units from a resource map.
@item @manpage{rmfree(9)} @tab Free a number of units from a resource map.
@item @manpage{rmfreemap(9)} @tab Free a resource map.
@item @manpage{rmget(9)} @tab Allocated a number of units from a resource map.
@item @manpage{rminit(9)} @tab Initialize a resource map.
@item @manpage{rmsetwant(9)} @tab Wait for resources on a resource map.
@item @manpage{rmwanted(9)} @tab Waiters on a resource map.
@end multitable

@appendixsubsubsec Device Numbering

@multitable @columnfractions .30 .70
@item @manpage{major(9)} @tab Get the internal major number of a device.
@item @manpage{makedev(9)} @tab Make a device number from internal major and minor device numbers.
@item @manpage{minor(9)} @tab Get the internal minor number of a device.
@end multitable

@node Configuration ala SVR 4.2 MP
@appendixsubsec Configuration ala SVR 4.2 MP
@cindex configuration, SVR 4.2 MP
@cindex SVR 4.2 MP, configuration
@cindex SVR 4.2 MP


@node AIX Portability
@appendixsec Porting from AIX 5L Version 5.1
@cindex porting, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, portability
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@menu
* Differences from AIX 5L Version 5.1::
* Commonalities with AIX 5L Version 5.1::
* Compatibility Functions for AIX 5L Version 5.1::
* Configuration ala AIX 5L Version 5.1::
@end menu

@node Differences from AIX 5L Version 5.1
@appendixsubsec Differences from AIX 5L Version 5.1
@cindex differences, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, differences
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@node Commonalities with AIX 5L Version 5.1
@appendixsubsec Commonalities with AIX 5L Version 5.1
@cindex commonalities, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, commonalities
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@node Compatibility Functions for AIX 5L Version 5.1
@appendixsubsec Compatibility Functions for AIX 5L Version 5.1
@cindex compatibility functions, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, compatibility functions
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@appendixsubsubsec Core Extensions

@multitable @columnfractions .30 .70
@item @manpage{putctl2(9)} @tab Put a 2 byte control message on a @dfn{STREAMS} message queue.  @manpage{putctl2(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{splstr(9)} @tab Set or restore priority levels.  @manpage{splstr(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{splx(9)} @tab Set or restore priority levels.  @manpage{splx(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{weldq(9)} @tab Weld together two pairs of @dfn{STREAMS} message queues.  @manpage{weldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{unweldq(9)} @tab Unweld two pairs of @dfn{STREAMS} message queues.  @manpage{unweldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@end multitable

@appendixsubsubsec Common Module Utilities

@multitable @columnfractions .30 .70
@item @manpage{mi_bufcall(9)} @tab Reliable alternative to @manpage{buffcall(9)}.
@item @manpage{mi_close_comm(9)} @tab @dfn{STREAMS} common minor device close utility.
@item @manpage{mi_next_ptr(9)} @tab @dfn{STREAMS} minor device list traversal.
@item @manpage{mi_open_comm(9)} @tab @dfn{STREAMS} common minor device open utility.
@item @manpage{mi_prev_ptr(9)} @tab @dfn{STREAMS} minor device list traversal.
@end multitable

@appendixsubsubsec Registration

@multitable @columnfractions .30 .70
@item @manpage{str_install(9)} @tab Install a @dfn{STREAMS} module or driver.
@end multitable

@appendixsubsubsec Message Filtering

@multitable @columnfractions .30 .70
@item @manpage{wantio(9)} @tab Perform direct I/O from a @dfn{STREAMS} driver.
@item @manpage{wantmsg(9)} @tab Provide a filter of wanted messages from a @dfn{STREAMS} module.
@end multitable

@node Configuration ala AIX 5L Version 5.1
@appendixsubsec Configuration ala AIX 5L Version 5.1
@cindex configuration, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, configuration
@cindex AIX PSE


@node HP-UX Portability
@appendixsec Porting from HP-UX 11.0i v2
@cindex porting, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, portability
@cindex HP-UX 11.0i v2
@cindex HP-UX

@menu
* Differences from HP-UX 11.0i v2::
* Commonalities with HP-UX 11.0i v2::
* Compatibility Functions for HP-UX 11.0i v2::
* Configuration ala HP-UX 11.0i v2::
@end menu

@node Differences from HP-UX 11.0i v2
@appendixsubsec Differences from HP-UX 11.0i v2
@cindex differences, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, differences
@cindex HP-UX 11.0i v2
@cindex HP-UX

@node Commonalities with HP-UX 11.0i v2
@appendixsubsec Commonalities with HP-UX 11.0i v2
@cindex commonalities, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, commonalities
@cindex HP-UX 11.0i v2
@cindex HP-UX

@node Compatibility Functions for HP-UX 11.0i v2
@appendixsubsec Compatibility Functions for HP-UX 11.0i v2
@cindex compatibility functions, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, compatibility functions
@cindex HP-UX 11.0i v2
@cindex HP-UX

@appendixsubsubsec Core Extensions

@multitable @columnfractions .30 .70
@item @manpage{streams_put(9)} @tab Invoke the put procedure for a @dfn{STREAMS} module or driver with a @dfn{STREAMS} message.  @manpage{streams_put(9)} is implemented using @manpage{put(9)}.  @manpage{put(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{putctl2(9)} @tab Put a 2 byte control message on a @dfn{STREAMS} message queue.  @manpage{putctl2(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{putnextctl2(9)} @tab Put a 2 byte control message on the downstream @dfn{STREAMS} message queue.  @manpage{putnextctl2(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{unweldq(9)} @tab Unweld two pairs of streams queues.  @manpage{unweldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{weldq(9)} @tab Weld together two pairs of streams queues.  @manpage{weldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@end multitable

@appendixsubsubsec Registration

@multitable @columnfractions .30 .70
@item @manpage{str_install(9)} @tab Install a @dfn{STREAMS} module or driver.
@item @manpage{str_uninstall(9)} @tab Uninstall a @dfn{STREAMS} module or driver.
@end multitable

@appendixsubsubsec Sleeping

@multitable @columnfractions .30 .70
@item @manpage{streams_get_sleep_lock(9)} @tab Provide access to the global sleep lock.
@end multitable

@node Configuration ala HP-UX 11.0i v2
@appendixsubsec Configuration ala HP-UX 11.0i v2
@cindex configuration, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, configuration
@cindex HP-UX 11.0i v2
@cindex HP-UX


@node OSF/1 Portability
@appendixsec Porting from OSF/1 1.2/Digital UNIX
@cindex porting, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, portability
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@menu
* Differences from OSF/1 1.2/Digital UNIX::
* Commonalities with OSF/1 1.2/Digital UNIX::
* Compatibility Functions for OSF/1 1.2/Digital UNIX::
* Configuration ala OSF/1 1.2/Digital UNIX::
@end menu

@node Differences from OSF/1 1.2/Digital UNIX
@appendixsubsec Differences from OSF/1 1.2/Digital UNIX
@cindex differences, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, differences
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@node Commonalities with OSF/1 1.2/Digital UNIX
@appendixsubsec Commonalities with OSF/1 1.2/Digital UNIX
@cindex commonalities, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, commonalities
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@node Compatibility Functions for OSF/1 1.2/Digital UNIX
@appendixsubsec Compatibility Functions for OSF/1 1.2/Digital UNIX
@cindex compatibility functions, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, compatibility functions
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@appendixsubsubsec Core Extensions

@multitable @columnfractions .30 .70
@item @manpage{lbolt(9)} @tab Time in ticks since reboot @manpage{lbolt(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{puthere(9)} @tab Invoke the put procedure for a @dfn{STREAMS} module or driver with a @dfn{STREAMS} message.  @manpage{puthere(9)} is implemented using @manpage{put(9)}.  @manpage{put(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{weldq(9)} @tab Weld together two pairs of streams queues.  @manpage{weldq(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@item @manpage{unweldq(9)} @tab Unweld two pairs of streams queues.  @manpage{unweldq(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@end multitable

@appendixsubsubsec Common Module Utilities

@multitable @columnfractions .30 .70
@item @manpage{streams_close_comm(9)} @tab Common minor device close utility.
@item @manpage{streams_open_comm(9)} @tab Common minor device open utility.
@item @manpage{streams_open_ocomm(9)} @tab Common minor device open utility.
@end multitable

@appendixsubsubsec Registration

@multitable @columnfractions .30 .70
@item @manpage{strmod_add(9)} @tab Add a @dfn{STREAMS} module.
@item @manpage{strmod_del(9)} @tab Delete a @dfn{STREAMS} module or driver from the kernel.
@end multitable

@appendixsubsubsec Others

@multitable @columnfractions .30 .70
@item @manpage{time(9)} @tab (undoc).
@end multitable

@node Configuration ala OSF/1 1.2/Digital UNIX
@appendixsubsec Configuration ala OSF/1 1.2/Digital UNIX
@cindex configuration, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, configuration
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1


@node UnixWare Portability
@appendixsec Porting from UnixWare 7.1.3 (OpenUnix 8)
@cindex porting, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), portability
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@menu
* Differences from UnixWare 7.1.3 (OpenUnix 8)::
* Commonalities with UnixWare 7.1.3 (OpenUnix 8)::
* Compatibility Functions for UnixWare 7.1.3 (OpenUnix 8)::
* Configuration ala UnixWare 7.1.3 (OpenUnix 8)::
@end menu

@node Differences from UnixWare 7.1.3 (OpenUnix 8)
@appendixsubsec Differences from UnixWare 7.1.3 (OpenUnix 8)
@cindex differences, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), differences
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@node Commonalities with UnixWare 7.1.3 (OpenUnix 8)
@appendixsubsec Commonalities with UnixWare 7.1.3 (OpenUnix 8)
@cindex commonalities, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), commonalities
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@cite{UnixWare} provides most of the core functions provide by @cite{@value{PACKAGE_TITLE}} along with
all of the compatibility functions provided by the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
compatibility module.  In addition the functions provided here in the @cite{UnixWare} compatibility
module are provided.

@node Compatibility Functions for UnixWare 7.1.3 (OpenUnix 8)
@appendixsubsec Compatibility Functions for UnixWare 7.1.3 (OpenUnix 8)
@cindex compatibility functions, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), compatibility functions
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

The following compatibility functions are in addition to all @cite{SVR 4.2}
@cindex SVR 4.2
compatibility functions.

@appendixsubsubsec Device Numbering

Device numbering has evolved since @cite{UNIX Sytem V Release 3.0} and provides internal, external
and extended device numbering.  These functions are provided for backward compatibility with some
drivers that were written for the older system.  These are core functions in the
@dfn{@value{PACKAGE_TITLE}} implementation.

@multitable @columnfractions .30 .70
@item @manpage{emajor(9)} @tab Get the external (real) major device number from the device number.
@item @manpage{eminor(9)} @tab Get the external extended minor device number from the device number.
@item @manpage{etoimajor(9)} @tab Convert an external major device number to an internal major device number.
@item @manpage{getemajor(9)} @tab Get the external (real) major device number.
@item @manpage{geteminor(9)} @tab Get the external minor device number.
@item @manpage{itoemajor(9)} @tab Convert an internal major device number to an external major device number.
@end multitable

@appendixsubsubsec Memory Alignment

In attempting to unify several disparaging @cite{UNIX}-based systems (in particular @cite{XENIX}
@cindex XENIX
and @cite{UnixWare},
@cindex UnixWare
it became necessary to sometimes address the alignment of data buffers.  Certainly a better way to
accomplish this would be to allocate data buffers using other allocators that provide the required
alignment and other buffer characteristics and then allocating a message and data block with a call
to @manpage{esballoc(9)}.
Nevertheless, these functions were provided for making message blocks, data blocks and data buffers
meet specific physical requirements.

@dfn{@value{PACKAGE_TITLE}} provides these functions for compatibility, however, most of the physical
requirements provided are ignored.

@multitable @columnfractions .30 .70
@item @manpage{allocb_physreq(9)} @tab Allocate a @dfn{STREAMS} message and data block.
@item @manpage{msgphysreq(9)} @tab Cause a message block to meet physical requirements.
@item @manpage{msgpullup_physreq(9)} @tab Pull up bytes in a @dfn{STREAMS} message.
@item @manpage{msgscgth(9)} @tab (undoc).
@end multitable

@appendixsubsubsec Direct @dfn{STREAMS} Input-Output Controls

@multitable @columnfractions .30 .70
@item @manpage{strioccall(9)} @tab (undoc).
@end multitable

@node Configuration ala UnixWare 7.1.3 (OpenUnix 8)
@appendixsubsec Configuration ala UnixWare 7.1.3 (OpenUnix 8)
@cindex configuration, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), configuration
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare


@node Solaris Portability
@appendixsec Porting from Solaris 9/SunOS 5.9
@cindex porting, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, portability
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@menu
* Differences from Solaris 9/SunOS 5.9::
* Commonalities with Solaris 9/SunOS 5.9::
* Compatibility Functions for Solaris 9/SunOS 5.9::
* Configuration ala Solaris 9/SunOS 5.9::
@end menu

@node Differences from Solaris 9/SunOS 5.9
@appendixsubsec Differences from Solaris 9/SunOS 5.9
@cindex differences, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, differences
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@node Commonalities with Solaris 9/SunOS 5.9
@appendixsubsec Commonalities with Solaris 9/SunOS 5.9
@cindex commonalities, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, commonalities
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@node Compatibility Functions for Solaris 9/SunOS 5.9
@appendixsubsec Compatibility Functions for Solaris 9/SunOS 5.9
@cindex compatibility functions, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, compatibility functions
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@appendixsubsubsec STREAMS Queue Referenced Callbacks

@multitable @columnfractions .30 .70
@item @manpage{qbufcall(9)} @tab Install a @dfn{STREAMS} buffer callback.
@item @manpage{qunbufcall(9)} @tab Cancel a @dfn{STREAMS} buffer callback.
@item @manpage{qtimeout(9)} @tab Start a timer associated with a queue.
@item @manpage{quntimeout(9)} @tab Stop a timer associated with a queue.
@item @manpage{qwait(9)} @tab Wait for a queue message.
@item @manpage{qwait_sig(9)} @tab Wait for a queue message or signal.
@item @manpage{queclass(9)} @tab Return the class of a @dfn{STREAMS} message.
@item @manpage{qwriter(9)} @tab @dfn{STREAMS} mutex upgrade.
@end multitable

@appendixsubsubsec STREAMS Registration

@multitable @columnfractions .30 .70
@item @manpage{install_driver(9)} @tab Install a device driver.
@item @manpage{mod_info(9)} @tab Provides information on a loadable kernel module to the @dfn{STREAMS} executive.
@item @manpage{mod_install(9)} @tab Installs a loadable kernel module in the @dfn{STREAMS} executive.
@item @manpage{mod_remove(9)} @tab Removes a loadable module from the @dfn{STREAMS} executive.
@end multitable

@appendixsubsubsec DDI
@cindex DDI/DKI

@cite{Solaris} provides a wide array of Device Driver Interface functions available for use by device
drivers.  Many of these functions are useful for @dfn{STREAMS} device and pseudo-device drivers and
modules.  Almost all of these functions, however, are @cite{Solaris}-specific and are completely
non-portable to other @cite{UNIX}-based operating systems.  To make matters worse for portability,
many of these functions have no @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
equivalents.

@multitable @columnfractions .40 .60
@item @manpage{ddi_create_minor_node(9)} @tab Create a minor node for this device.
@item @manpage{ddi_remove_minor_node(9)} @tab Remove a minor node for a device.
@item @manpage{ddi_driver_major(9)} @tab Find the major device number associated with a driver.
@item @manpage{ddi_getiminor(9)} @tab Get the internal minor device number.
@item @manpage{ddi_driver_name(9)} @tab Return normalized driver name.
@item @manpage{ddi_get_cred(9)} @tab Get a reference to the credentials of the current user.
@item @manpage{ddi_get_instance(9)} @tab Get device instance number.
@item @manpage{ddi_get_lbolt(9)} @tab Get the current value of the system tick clock.
@item @manpage{ddi_get_pid(9)} @tab Get the process id of the current process.
@item @manpage{ddi_get_time(9)} @tab Get the current time in seconds since the epoch.
@item @manpage{ddi_removing_power(9)} @tab
@item @manpage{ddi_get_soft_state(9)} @tab
@item @manpage{ddi_soft_state(9)} @tab
@item @manpage{ddi_soft_state_fini(9)} @tab
@item @manpage{ddi_soft_state_free(9)} @tab
@item @manpage{ddi_soft_state_init(9)} @tab
@item @manpage{ddi_soft_state_zalloc(9)} @tab
@item @manpage{ddi_umem_alloc(9)} @tab Allocate page aligned kernel memory.
@item @manpage{ddi_umem_free(9)} @tab Free page aligned kernel memory.
@end multitable

@appendixsubsubsec Loadable Module Interface

@multitable @columnfractions .30 .70
@item @manpage{_fini(9)} @tab
@item @manpage{_info(9)} @tab
@item @manpage{_init(9)} @tab
@item @manpage{attach(9)} @tab Attach a device to the system or resume a suspended device.
@item @manpage{getinfo(9)} @tab
@item @manpage{identify(9)} @tab Determine if a driver is associated with a device.
@item @manpage{detach(9)} @tab Detach a device from the system or suspend a device.
@item @manpage{power(9)} @tab Power a device attached to the system.
@item @manpage{probe(9)} @tab
@end multitable

@node Configuration ala Solaris 9/SunOS 5.9
@appendixsubsec Configuration ala Solaris 9/SunOS 5.9
@cindex configuration, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, configuration
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS


@node SUX Portability
@appendixsec Porting from Super/UX
@cindex porting, Super/UX
@cindex Super/UX, portability
@cindex Super/UX

@menu
* Differences from Super/UX::
* Commonalities with Super/UX::
* Compatibility Functions for Super/UX::
* Configuration ala Super/UX::
@end menu

@node Differences from Super/UX
@appendixsubsec Differences from Super/UX
@cindex differences, Super/UX
@cindex Super/UX, differences
@cindex Super/UX

@node Commonalities with Super/UX
@appendixsubsec Commonalities with Super/UX
@cindex commonalities, Super/UX
@cindex Super/UX, commonalities
@cindex Super/UX

@node Compatibility Functions for Super/UX
@appendixsubsec Compatibility Functions for Super/UX
@cindex compatibility functions, Super/UX
@cindex Super/UX, compatibilty functions
@cindex Super/UX

@multitable @columnfractions .30 .70
@item @manpage{lbolt(9)} @tab time in ticks since reboot
@end multitable

@node Configuration ala Super/UX
@appendixsubsec Configuration ala Super/UX
@cindex configuration, Super/UX
@cindex Super/UX, configuration
@cindex Super/UX


@node UXP Portability
@appendixsec Porting from UXP/V
@cindex porting, UXP/V
@cindex UXP/V, portability
@cindex UXP/V

@menu
* Differences from UXP/V::
* Commonalities with UXP/V::
* Compatibility Functions for UXP/V::
* Configuration ala UXP/V::
@end menu

@node Differences from UXP/V
@appendixsubsec Differences from UXP/V
@cindex differences, UXP/V
@cindex UXP/V, differences
@cindex UXP/V

@node Commonalities with UXP/V
@appendixsubsec Commonalities with UXP/V
@cindex commonalities, UXP/V
@cindex UXP/V, commonalities
@cindex UXP/V

@node Compatibility Functions for UXP/V
@appendixsubsec Compatibility Functions for UXP/V
@cindex compatibility functions, UXP/V
@cindex UXP/V, compatibility functions
@cindex UXP/V

@node Configuration ala UXP/V
@appendixsubsec Configuration ala UXP/V
@cindex configuration, UXP/V
@cindex UXP/V, configuration
@cindex UXP/V


@node Development
@appendixsec Developing Portable STREAMS Modules
@cindex developing portable streams modules

In the process of creating the @dfn{@value{PACKAGE_TITLE}} subsystem in such a way so as to facilitate
portability of @dfn{STREAMS} drivers and modules from a wide range of @cite{UNIX} operating system
variants, a number of guidelines for the development of portable @dfn{STREAMS} drivers and modules
have been developed.  These guidelines, when adhered to, will allow the resulting driver or module
to be ported to another @dfn{STREAMS} implementation with minimal effort.  These portability
guidelines are collected here.

@menu
* Memory Allocation::
* Alignment of Message Buffers::
* Disabling and Enabling Queue Procedures::
* Freezing and Unfreezing Streams::
* Passing Messages from Interrupt Service Routines::
* Timeout Call Back and Link Identifiers::
* Synchronization with Timeouts and Callback Functions::
* Synchronization with Callout Functions::
* Synchronization of Drivers and Modules::
* Special STREAMS Message Types::
* Use of Message Allocation Priorities::
* Device Numbering::
* Registration and Deregistration::
@end menu

@node Memory Allocation
@appendixsubsec Memory Allocation

Portable @dfn{STREAMS} modules and drivers will always allocate memory using the @cite{SVR4}
@cindex SVR4
memory allocators/deallocators: @manpage{kmem_alloc(9)}, @manpage{kmem_zalloc(9)} and
@manpage{kmem_free(9)}.

Additional eligible allocators are:

@manpage{rmallocmap(9)}
@manpage{rmfreemap(9)}
@manpage{rmalloc(9)}
@manpage{rmalloc_wait(9)}
@manpage{rmfree(9)}
@manpage{rminit(9)}
@manpage{rmsetwant(9)}
@manpage{rmwanted(9)}

Unfortunately, these resource map allocators are not available on @cite{AIX}
@cindex AIX
so, if portability to the @cite{AIX}
@cindex AIX
is important, then do not use these allocators.

Additional eligible allocators are:

@manpage{kmem_fast_alloc(9)}
@manpage{kmem_fast_free(9)}

@node Alignment of Message Buffers
@appendixsubsec Alignment of Message Buffers

@node Disabling and Enabling Queue Procedures
@appendixsubsec Disabling and Enabling Queue Procedures

Portable @dfn{STREAMS} modules and drivers will always call @manpage{qprocson(9)} before returning
from its queue open procedure (see @manpage{qopen(9)}.

Portable @dfn{STREAMS} modules and drivers will always call @manpage{qprocsoff(9)} upon entering
its queue close procedure (see @manpage{qclose(9)}).

@node Freezing and Unfreezing Streams
@appendixsubsec Freezing and Unfreezing Streams

@node Passing Messages from Interrupt Service Routines
@appendixsubsec Passing Messages from Interrupt Service Routines

@node Timeout Call Back and Link Identifiers
@appendixsubsec Timeout Call Back and Link Identifiers

Although buffer callbacks identifiers (see @manpage{bufcall(9)}), timeout identifiers (see
@manpage{timeout(9)}), and multiplexing driver link identifiers (see @streamio{I_LINK}
and @streamio{I_PLINK} under
@manpage{streamio(7)}), are often illustrated as small integer numbers, with some @dfn{STREAMS}
implementations, including @dfn{@value{PACKAGE_TITLE}}, these identifiers are kernel addresses
(pointers) and are never small integer values like 1, 2, or 3.

Also, there is no guarantee that the identifier will be positive.  It is guaranteed that the
returned identifier will not be zero (0).  Zero is used by these function as a return value to
indicate an error.

Portable @dfn{STREAMS} drivers and modules will not depend upon the returned identifier from
@manpage{bufcall(9)}, @manpage{timeout(9)} or @manpage{streamio(7)} as being any specific range of
value.  Portable drivers and modules will save any returned identifiers in data types that will not
loose the precision of the identifier.

@node Synchronization with Timeouts and Callback Functions
@appendixsubsec Synchronization with Timeouts and Callback Functions

@node Synchronization with Callout Functions
@appendixsubsec Synchronization with Callout Functions

@node Synchronization of Drivers and Modules
@appendixsubsec Synchronization of Drivers and Modules

@node Special STREAMS Message Types
@appendixsubsec Special @dfn{STREAMS} Message Types

@node Use of Message Allocation Priorities
@appendixsubsec Use of Message Allocation Priorities

@node Registration and Deregistration
@appendixsubsec Registration and Deregistration

@node Device Numbering
@appendixsubsec Device Numbering

@subsubheading UNIX Device Numbering

@quotation
In versions of @cite{UNIX System V} previous to @cite{Release 4}, the major and minor device numbers
were each 8 bit, and they were packed into a 16 bit word (usually a C Language @var{short}
variable).  Under @cite{UNIX System V Release 4}, the device numbers are held in a @type{dev_t}
variable, which is often implemented as a 32 bit integer.  The minor device number is held as 14
bits, and a further 8 bits are used for the major device number.  @type{dev_t}
is ofter referred to as the "expanded device type", since it allows many more minor devices than
before.

Many drivers were written for earlier releases, an may eventually be ported to @cite{UNIX System V
Release 4}.  In earlier releases, some manufacturers got around the 256 minor device number limit by
using multiple major device numbers for a device.  Devices were created with different major device
numbers (the external major device number) but they all mapped to the same device driver entry in
the device switch tables (the internal device number).  Even under this scheme, each major device
could only support 256 minor devices, but the driver could support many more.  This has been
recognized in @cite{UNIX System V Release 4}, and functions are provided to do this mapping; for
example, the function @manref{etoimajor(9)} and so on, give a machine independent interface to the
device number mapping.@footnote{@cite{The Magic Garden Explained}}
@end quotation

@subsubheading Linux Device Numbering

Versions of the @b{Linux} kernel in the 2.4 kernel series and prior to 2.6 also provided an 8 bit
major device number and an 8 bit minor device number grouped into a 16-bit combined device number.
Linux 2.6 kernels (and some patched 2.4 kernels) now have larger device numbers.  These extended
device numbers are 12 bits for major device number and 20 bits for minor device number, with 32 bits
for the combined device number.

@subsubheading @value{PACKAGE_TITLE} Device Numbering

@dfn{@value{PACKAGE_TITLE}} began with extended device numbering.  The @file{specfs} shadow special
character device file system used by @dfn{@value{PACKAGE_TITLE}} uses the @samp{inode} number to hold the
@type{dev_t}
device number instead of the @samp{inode->i_rdev}, which on older kernels is only a 16-bit
@var{short}.

In earlier versions of @dfn{@value{PACKAGE_TITLE}}, the internal device numbering is 16-bits for major
device number and 16-bits for minor device number.  This will soon be changed to 12-bits for major
device number and 20-bits for minor device number to accommodate the newer @b{Linux} scheme.

On 2.6 @b{Linux} kernels that support the newer extended device numbers, external device numbers and
internal device numbers will be the same.  On 2.4 @b{Linux} kernels with the older 16-bit device
numbers, external device number and internal device numbers will differ.  In some situations, an
internal device number can exists with no corresponding external device number (accessed only via a
clone device or direct access to the mounted @file{specfs} shadow special character device
file system).

@multitable @columnfractions .30 .70
@item @manpage{etoimajor(9)} @tab change external to internal major device number
@item @manpage{getemajor(9)} @tab get external major device number
@item @manpage{geteminor(9)} @tab get external minor device number
@item @manpage{itoemajor(9)} @tab change internal to external major device number
@end multitable

@node Copying
@appendix Copying

@menu
* GNU Affero General Public License::	AGPL
* GNU Free Documentation License::	FDL
@end menu

@page
@include texi/agpl3.texi
@page
@include texi/fdl13.texi

@node Glossary
@unnumbered Glossary

@multitable @columnfractions .30 .70

@item @dfn{anchor} @tab
@cindex anchor
A @dfn{STREAMS} locking mechanism that prevents the removal of @dfn{STREAMS} modules with the
@streamio{I_POP} @command{ioctl}.  Anchors are placed on @dfn{STREAMS} modules by adding the
@samp{[anchor]} flag to @manref{autopush(8)} configuration files or directly with the
@streamio{I_ANCHOR} @command{ioctl}.

@item @dfn{autopush} @tab
@cindex autopush
A @dfn{STREAMS} mechanism that enables a pre-specified list of modules to be pushed automatically
onto a @dfn{Stream} when a @dfn{STREAMS} device is opened.  This mechanism is used only for
administrative purposes.

@item @dfn{back-enable} @tab
@cindex back-enable
To enable (by @dfn{STREAMS}) a preceding blocked queue's @command{service} procedure when
@dfn{STREAMS} determines that a succeeding queue has reached its low-water mark.

@item @dfn{blocked} @tab
@cindex blocked
A queue's @command{service} procedure that cannot be enabled due to flow control.

@item @dfn{clone device} @tab
@cindex clone device
A @dfn{STREAMS} device that returns an unused major/minor device number when initially opened,
rather than requiring the minor device to be specified by name in the @command{open} call.

@item @dfn{close procedure} @tab
@cindex close procedure
A routine that is called when a module is popped from a @dfn{Stream} or when a driver is closed.
A pointer to this procedure is specified in the @member{qi_qopen} member of the @mantype{queue(9)}
structure associated with the read side of the module's queue pair.

@item @dfn{control Stream} @tab
@cindex control Stream
A @dfn{Stream} above a multiplexing driver used to establish lower multiplexer connections.
Multiplexed @dfn{Stream} configurations are maintained through the controlling @dfn{Stream} to a
multiplexing driver.

@item @dfn{Device Driver Interface} @tab
@cindex Device Driver Interface
An interface that facilitates driver portability across different @cite{UNIX} system versions.

@item @dfn{device driver} @tab
@cindex device driver
A @dfn{Stream} component whose principle functions are handling an associated physical device and
transforming data and information between the external interface and the @dfn{Stream}.

@item @dfn{Driver Kernel Interface} @tab
@cindex Driver Kernel Interface
An interface between the @cite{UNIX} system kernel and different types of drivers.  It consists of a
set of driver defined functions that are called by the kernel.  These functions are entry points
into a driver.

@item @dfn{downstream} @tab
@cindex downstream
A direction of data flow going from the @dfn{Stream head} toward a driver.  Also called the
@dfn{write-side} and @dfn{output-side}.

@item @dfn{driver} @tab
@cindex driver
A module that forms the @dfn{Stream end}.  It can be a device driver or a pseudo-device driver.  It
is a required component in @dfn{STREAMS} (except in @dfn{STREAMS}-based pipes and FIFOs), and is
physically identical to a module.  It typically handles data transfer between the kernel and a
device and does little or no processing of data.

@item @dfn{enable} @tab
@cindex enable
A term used to describe scheduling of a queue's @command{service} procedure.

@item @dfn{FIFO} @tab
@cindex FIFO
@dfn{First In, First Out}.  A term used in @dfn{STREAMS} for named pipes.  This term is also used in
queue scheduling.

@item @dfn{flow control} @tab
@cindex flow control
A @dfn{STREAMS} mechanism that regulates the rate of message transfer within a @dfn{Strema} and from
user space into a @dfn{Stream}.

@item @dfn{hardware emulation module} @tab
@cindex hardware emulation module
A module required when the terminal line discipline is on a @dfn{Stream} but there is no terminal
driver at the @dfn{Stream end}.  This module recognizes all @manref{termio(7)} @command{ioctl}s
necessary to support terminal semantics specified by @mantype{termio(9)} and @mantype{termios(9)}.

@item @dfn{input side} @tab
@cindex input side
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{read-side} and @dfn{upstream}.

@item @dfn{line discipline} @tab
@cindex line discipline
A @dfn{STREAMS} module that performs @manref{termio(7)} canonical and non-canonical processing.  It
shares some @manref{termio(7)} processing with a driver in a @dfn{STREAMS} terminal subsystem.

@item @dfn{lower Stream} @tab
@cindex lower Stream
A @dfn{Stream} connected beneath a multiplexing pseudo-device driver, by means of an
@streamio{I_LINK} or @streamio{I_PLINK} @command{ioctl}.  The far end of a lower @dfn{Stream}
terminates at a device driver or another multiplexer driver.

@item @dfn{master driver} @tab
@cindex master driver
A @dfn{STREAMS}-based device supported by the pseudo-terminal subsystem.  It is the controlling part
of the pseudo-terminal subsystem (also called @samp{ptm}).

@item @dfn{message} @tab
@cindex message
One or more linked message blocks.  A message is referenced by its first message block and its type
is defined by the message type of that block.

@item @dfn{message block} @tab
@cindex message block
A triplet consisting of a data buffer and associated control structures, a @mantype{msgb(9)}
structure, a @mantype{datab(9)} structure.  It carries data or information, as identified by its
message type, in a @dfn{Stream}.

@item @dfn{message queue} @tab
@cindex message queue
A linked list of zero or more messages connected together.

@item @dfn{message type} @tab
@cindex message type
A enumerated set of values identifying the contents of a message.

@item @dfn{module} @tab
@cindex module
A defined set of kernel-level routines and data structure used to process data, status, and control
information on a @dfn{Stream}.  It is an optional element, but there can be many modules in one
@dfn{Stream}.  It consists of a pair of queues (read queue and write queue), and it communicates to
other components in a @dfn{Stream} by passing messages.

@item @dfn{multiplexer} @tab
@cindex multiplexer
A @dfn{STREAMS} mechanism that allows message to be routed among multiple @dfn{Streams} in the
kernel.  A multiplexing configuration includes at least one multiplexing pseudo-device driver
connected to one or more upper @dfn{Streams} and one or more lower @dfn{Streams}.

@item @dfn{named Stream} @tab
@cindex named Stream
A @dfn{Stream}, typically a pipe, with a name associated with it by way of a call to
@manref{fattach(3)} (that is, a @manref{mount(2)} operation).  This is different from a named pipe
(FIFO) in two ways: a named pipe (FIFO) is unidirectional while a named @dfn{Stream} is
bidirectional; a name @dfn{Stream} need not refer to a pipe, but can be another type of
@dfn{Stream}.

@item @dfn{open routine} @tab
@cindex open routine
A procedure in each @dfn{STREAMS} driver and module called by @dfn{STREAMS} on each @command{open}
system call made on the @dfn{Stream}.  A module's @command{open} procedure is also called when the
module is pushed.

@item @dfn{packet mode} @tab
@cindex packet mode
A feature supported by the @dfn{STREAMS}-based pseudo-terminal subsystem.  It is used to inform a
process on the master side when state changes occur on the slave side of a pseudo-TTY.  It is
enabled by pushing a module called @samp{pckt} on the master side.

@item @dfn{persistent link} @tab
@cindex persistent link
A connection below a multiplexer that can exist without having an open controlling @dfn{Stream}
associated with it.

@item @dfn{pipe} @tab
@cindex pipe
See @dfn{STREAMS}-based pipe.

@item @dfn{pop} @tab
@cindex pop
A term used when a module that is immediately below the @dfn{Stream} head is removed.

@item @dfn{pseudo-device driver} @tab
@cindex pseudo-device driver
A software driver, not directly associated with a physical device, that performs functions internal
to a @dfn{Stream} such as a multiplexer or @manref{log(4)} driver.

@item @dfn{pseudo-terminal subsystem} @tab
@cindex pseudo-terminal subsystem
A user interface identical to a terminal subsystem except that there is a process in place of a
hardware device.  It consists of at least a master device, slave device, line discipline module, and
hardware emulation module.

@item @dfn{push} @tab
@cindex push
A term used when a module is inserted in a @dfn{Stream} immediately below the @dfn{Stream head}.

@item @dfn{pushable module} @tab
@cindex pushable module
A module put between the @dfn{Stream head} and driver.  It performs intermediate transformations on
messages flowing between the @dfn{Stream head} and driver.  A driver is a non-pushable module.

@item @dfn{put procedure} @tab
@cindex put procedure
A routine in a module or driver associated with a queue that receives messages from the preceding
queue.  It is the single entry point into a queue from a preceding queue.  It may perform processing
on the message and will then generally either queue the message for subsequent processing by this
queue's @command{service} procedure, or will pass the message to the @command{put} procedure of the
following queue (using @manref{putnext(9)}).

@item @dfn{queue} @tab
@cindex queue
A data structure that contains status information, a pointer to routines processing message, and
pointers for administering a @dfn{Stream}.  It typically contains pointer to @command{put} and
@command{service} procedures, a message queue, and private data.

@item @dfn{read-side} @tab
@cindex read-side
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{upstream} and @dfn{input-side}.

@item @dfn{read queue} @tab
@cindex read queue
A message queue in a module or driver containing messages moving @dfn{upstream}.  Associated with
the @manref{read(2)} system call and input from a driver.

@item @dfn{remote mode} @tab
@cindex remote mode
A feature available with the pseudo-terminal subsystem.  It is used for applications that perform
the canonical and echoing functions normally done by line discipline module and TTY driver.  It
enables applications on the master side to turn off the canonical processing.

@item @dfn{STREAMS Administrative Driver} @tab
@cindex STREAMS Administrative Driver
A @dfn{STREAMS} Administrative Driver that provides an interface to the @manref{autopush(8)}
mechanism.

@item @dfn{schedule} @tab
@cindex schedule
To place a queue on the internal list of queues that will subsequently have their service procedure
called by the @dfn{STREAMS} scheduler.  @dfn{STREAMS} scheduling is independent of @cite{Linux}
process scheduling.

@item @dfn{service interface} @tab
@cindex service interface
A set of primitives that define a service at the boundary between a service user and a service
provider and the rules (typically represented by a state machine) for allowable sequences of the
primitives across the boundary.  At a @dfn{Stream}/user boundary, the primitives are typically
contained in the control part of a message; within a @dfn{Stream}, in @msg{M_PROTO} or
@msg{M_PCPROTO} message blocks.

@item @dfn{service procedure} @tab
@cindex service procedure
A module or driver routine associated with a queue that receives messages queue for it by the
@command{put} procedure is called by the @dfn{STREAMS} scheduler.  It may perform processing on the
message and generally passes the message to the @command{put} procedure of the following queue.

@item @dfn{service provider} @tab
@cindex service provider
An entity in a service interface that responds to request primitives from the service user with
response and event primitives.

@item @dfn{service user} @tab
@cindex service user
An entity in a service interface that generates request primitives for the service provider and
consumes response and event primitives.

@item @dfn{slave driver} @tab
@cindex slave driver
A @dfn{STREAMS}-based device supported by the pseudo-terminal subsystem.  It is also called
@samp{pts} and works with a line discipline module and hardware emulation module to provide an
interface to a user process.

@item @dfn{standard pipe} @tab
@cindex standard pipe
A mechanism for the unidirectional flow of data between two processes where data written by one
process becomes data read by the other process.

@item @dfn{Stream} @tab
@cindex Stream
A kernel level aggregate created by connecting @dfn{STREAMS} components, resulting from an
application of the @dfn{STREAMS} mechanism.  The primary components are the @dfn{Stream head}, the
driver (or @dfn{Stream end}), and zero or more pushable modules between the @dfn{Stream head} and
driver.

@item @dfn{STREAMS-based pipe} @tab
@cindex STREAMS-based pipe
A mechanism used for bidirectional data transfer implemented using @dfn{STREAMS}, and sharing the
properties of @dfn{STREAMS}-based devices.

@item @dfn{Stream end} @tab
@cindex Stream end
A @dfn{Stream} component furthest from the user process that contains a driver.

@item @dfn{Stream head} @tab
@cindex Stream head
A @dfn{Stream} component closest to the user process.  It provides the interface between the
@dfn{Stream} and the user process.

@item @dfn{STREAMS} @tab
@cindex STREAMS
A kernel mechanism that provides the framework for network services and data communication.  It
defines interface standards for character input/output within the kernel, and between the kernel
and user level.  The @dfn{STREAMS} mechanism includes integral functions, utility routines, kernel
facilities, and a set of structures.

@item @dfn{TTY driver} @tab
@cindex TTY driver
A @dfn{STREAMS}-based device used in a terminal subsystem.

@item @dfn{upper stream} @tab
@cindex upper stream
A @dfn{Stream} that terminates above a multiplexing driver.  The beginning of an upper @dfn{Stream}
originates at the @dfn{Stream head} or another multiplexing driver.

@item @dfn{upstream} @tab
@cindex upstream
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{read-side} and @dfn{input side}.

@item @dfn{water mark} @tab
@cindex water mark
A limit value used in flow control.  Each queue has a high-water mark and a low-water mark.  The
high-water mark value indicates the upper limit related to the number of bytes contained on the
queue.  When the queued character reaches its high water mark, @dfn{STREAMS} causes another queue
that attempts to send a message to this queue to become blocked.  When the characters in this queue
are reduced to the low-water mark value, the other queue is unblocked by @dfn{STREAMS}.

@item @dfn{write queue} @tab
@cindex write queue
A message queue in a module or driver containing messages moving downstream.  Associated with the
@manref{write(2)} system call and output from a user process.

@item @dfn{write-side} @tab
@cindex write-side
A direction of data flow going from the @dfn{Stream head} toward a driver.  Also called downstream
and output side.

@end multitable

@ifnotinfo
@node List of Figures
@unnumbered List of Figures

@listoffloats Figure
@end ifnotinfo

@node Index
@unnumbered Index

@c @page
@c @node Indices
@c @unnumbered Indices
@c @menu
@c * Concept Index::		Index of Concepts
@c * Type Index::			Index of Data Types
@c * Function Index::		Index of Functions and Macros
@c * Variable Index::		Index of Variables and Constants
@c * File Index::			Index of Files and Programs
@c @end menu
@c 
@c @page
@c @node Concept Index
@c @unnumberedsec Concept Index
@printindex cp

@c @page
@c @node Type Index
@c @unnumberedsec Type Index
@c @printindex tp
@c 
@c @page
@c @node Function Index
@c @unnumberedsec Function and Macro Index
@c @printindex fn
@c 
@c @page
@c @node Variable Index
@c @unnumberedsec Variable and Constant Macro Index
@c @printindex vr
@c 
@c @page
@c @node File Index
@c @unnumberedsec Program and File Index
@c @printindex pg

@page
@shortcontents
@page
@contents
@bye

