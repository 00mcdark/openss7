%% -*- tex -*- vim: ft=tex tw=78 nocin nosi
%% =========================================================================
%%
%% @(#) $Id: testresults.tex,v 1.1.2.1 2009-06-21 10:42:30 brian Exp $
%%
%% =========================================================================
%%
%% Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
%%
%% All Rights Reserved.
%%
%% Permission is granted to make and distribute verbatim copies of this
%% manual provided the copyright notice and this permission notice are
%% preserved on all copies.
%%
%% Permission is granted to copy and distribute modified versions of this
%% manual under the conditions for verbatim copying, provided that the
%% entire resulting derived work is distributed under the terms of a
%% permission notice identical to this one.
%% 
%% Since the Linux kernel and libraries are constantly changing, this
%% manual page may be incorrect or out-of-date.  The author(s) assume no
%% responsibility for errors or omissions, or for damages resulting from
%% the use of the information contained herein.  The author(s) may not
%% have taken the same level of care in the production of this manual,
%% which is licensed free of charge, as they might when working
%% professionally.
%% 
%% Formatted or processed versions of this manual, if unaccompanied by
%% the source, must acknowledge the copyright and authors of this work.
%%
%% -------------------------------------------------------------------------
%%
%% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
%% on behalf of the U.S. Government ("Government"), the following
%% provisions apply to you.  If the Software is supplied by the Department
%% of Defense ("DoD"), it is classified as "Commercial Computer Software"
%% under paragraph 252.227-7014 of the DoD Supplement to the Federal
%% Acquisition Regulations ("DFARS") (or any successor regulations) and the
%% Government is acquiring only the license rights granted herein (the
%% license rights customarily provided to non-Government users).  If the
%% Software is supplied to any unit or agency of the Government other than
%% DoD, it is classified as "Restricted Computer Software" and the
%% Government's rights in the Software are defined in paragraph 52.227-19
%% of the Federal Acquisition Regulations ("FAR") (or any successor
%% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
%% NASA Supplement to the FAR (or any successor regulations).
%%
%% =========================================================================
%% 
%% Commercial licensing and support of this software is available from
%% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
%% 
%% =========================================================================
%%
%% Last Modified $Date: 2009-06-21 10:42:30 $ by $Author: brian $
%%
%% =========================================================================

\documentclass[letterpaper,final,notitlepage,twocolumn,10pt,twoside]{article}
\usepackage{ftnright}
\usepackage{makeidx}
\usepackage{pictex}
%\usepackage{psfig}
%\usepackage{graphics}
\usepackage{graphicx}
\usepackage{eepic}
%\usepackage{epsfig}
%\usepackage[dvips]{graphicx,epsfig}
%\usepackage[dvips]{epsfig}
%\usepackage{epsf}
\usepackage{natbib}
\usepackage{placeins}
%\usepackage{placeins}

\setlength{\voffset}{-1.2in}
\setlength{\topmargin}{0.2in}
\setlength{\headheight}{0.2in}
\setlength{\headsep}{0.3in}
\setlength{\topskip}{0.0in}
\setlength{\footskip}{0.3in}
\setlength{\textheight}{10.0in}

\setlength{\hoffset}{-1.0in}
\setlength{\oddsidemargin}{0.5in}
\setlength{\evensidemargin}{0.5in}
\setlength{\textwidth}{7.5in}

\setlength{\marginparwidth}{0.0in}
\setlength{\marginparsep}{0.0in}

\setlength{\columnsep}{0.3in}
\setlength{\columnwidth}{3.6in}
%\setlength{\columnseprule}{0.25pt}

\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}

\let\Huge = \huge
\let\huge = \LARGE
\let\LARGE = \Large
\let\Large = \large
\let\large = \normalsize
\let\normalsize = \small
\let\small = \footnotesize
\let\footnotesize = \scriptsize
\let\scriptsize = \tiny

\makeatletter
\renewcommand\section{\@startsection {section}{1}{\z@}%
                                   {-2ex \@plus -1ex \@minus -.2ex}%
                                   {1ex \@plus .2ex}%
                                   {\normalfont\large\bfseries}}
\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
                                     {-1.5ex \@plus -.5ex \@minus -.2ex}%
                                     {1ex \@plus .2ex}%
                                     {\normalfont\normalsize\bfseries}}
\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
                                     {-1.25ex\@plus -.5ex \@minus -.2ex}%
                                     {1ex \@plus .2ex}%
                                     {\normalfont\normalsize\bfseries}}
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
                                    {1.5ex \@plus .5ex \@minus .2ex}%
                                    {-1em}%
                                    {\normalfont\normalsize\bfseries\slshape}}
\renewcommand\subparagraph{\@startsection{subparagraph}{5}{\parindent}%
                                       {0ex \@plus 0ex \@minus 0ex}%
                                       {-1em}%
                                      {\normalfont\normalsize\bfseries\slshape}}
\makeatother

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{6}

\pagestyle{plain}
%\pagestyle{myheadings}
%\markboth{B. Bidulock}{B. Bidulock}

\makeglossary

\newcommand{\topfigrule}{\vspace{0.5ex}\rule{\columnwidth}{0.4pt}\vspace{0.5ex} }
\newcommand{\botfigrule}{\vspace{0.5ex}\rule{\columnwidth}{0.4pt}\vspace{0.5ex} }
\newcommand{\dblfigrule}{\vspace{0.5ex}\rule{\textwidth}{0.4pt}\vspace{0.5ex} }

%\bibliographystyle{unsrtnat}
%\bibliographystyle{plainnat}
%\bibliographystyle{ieeetr}
%\bibliographystyle{abbrvnat}
%\bibliographystyle{acm}
%\bibliographystyle{plainnat}
\bibliographystyle{alpha}

\begin{document}

%\begin{titlepage}
%\begin{center}
%    STREAMS vs. Sockets Performance Comparison\\
%    Experimental Test Results
%\end{center}
%\end{titlepage}

\title{STREAMS vs. Sockets Performance Comparison for UDP\\[0.5ex]
	{\large \textsl{Experimental Test Results for Linux}}}
\author{Brian F. G. Bidulock\thanks{bidulock@openss7.org}\\
	OpenSS7 Corporation}
\date{June 16, 2007}
\maketitle

\begin{abstract}
\addcontentsline{toc}{section}{Abstract}
With the objective of contrasting performance between STREAMS and legacy approaches to system
facilities, a comparison is made between the tested performance of the \textsl{Linux Native Sockets} UDP
implementation and STREAMS TPI UDP and XTIoS UDP
implementations using the \textsl{Linux Fast-STREAMS} package \cite[]{LfS}.
\end{abstract}

%\tableofcontents

\section[Background]{Background}

UNIX networking has a rich history.  The TCP/IP protocol suite was first implemented by BBN using
Sockets under a DARPA research project on 4.1aBSD and then incorporated by the CSRG into 4.2BSD
\cite[]{bsd}.  Lachmann and Associates (Legent) subsequently implemented one of the first TCP/IP
protocol suite based on the Transport Provider Interface (TPI) \cite[]{tli} and STREAMS
\cite[]{magic}.  Two other predominant TCP/IP implementations on STREAMS surfaced at about the same
time: Wollongong and Mentat.

\subsection[STREAMS]{STREAMS}

STREAMS is a facility first presented in a paper by Dennis M. Ritchie in 1984 \cite[]{Ritchie84},
originally implemented on 4.1BSD and later part of \textsl{Bell Laboratories Eighth Edition UNIX},
incorporated into \textsl{UNIX System V Release 3} and enhanced in \textsl{UNIX Sysvem V Release 4}
and further in \textsl{UNIX System V Release 4.2}.  STREAMS was used in SVR4 for terminal
input-output, pseudo-terminals, pipes, named pipes (FIFOs), interprocess communication and
networking.  STREAMS was used in SVR3 for networking (with the NSU package).  Since its release in
\textsl{System V Release 3}, STREAMS has been implemented across a wide range of UNIX, UNIX-like and
UNIX-based systems, making its implementation and use an ipso facto standard.

STREAMS is a facility that allows for a reconfigurable full duplex communications path,
\textit{Stream}, between a user process and a driver in the kernel.   Kernel protocol modules can be
pushed onto and popped from the \textit{Stream} between the user process and driver.  The
\textit{Stream} can be reconfigured in this way by a user process.  The user process, neighbouring
protocol modules and the driver communicate with each other using a message passing scheme.  This
permits a loose coupling between protocol modules, drivers and user processes, allowing a
third-party and loadable kernel module approach to be taken toward the provisioning of protocol
modules on platforms supporting STREAMS.

On \textsl{UNIX System V Release 4.2}, STREAMS was used for terminal input-output, pipes, FIFOs
(named pipes), and network communications.  Modern UNIX, UNIX-like and UNIX-based systems providing
STREAMS normally support some degree of network communications using STREAMS; however, many do not
support STREAMS-based pipe and FIFOs\footnote{For example, AIX.} or terminal
input-output.\footnote{For example, HP-UX.}

\textsl{UNIX System V Release 4.2} supported four Application Programmer Interfaces (APIs) for
accessing the network communications facilities of the kernel:

\begin{description}

\item[{\it Transport Layer Interface (TLI).}]

\textsl{TLI} is an acronym for the \textit{Transport Layer Interface} \cite[]{tli}.  The
\textsl{TLI} was the non-standard interface provided by SVR4, later standardized by \textit{X/Open}
as the \textsl{XTI} described below.  This interface is now deprecated.

\item[{\it X/Open Transport Interface (XTI).}]

\textsl{XTI} is an acronym for the \textsl{X/Open Transport Interface} \cite[]{xti}.  The
\textsl{X/Open Transport Interface} is a standardization of the \textsl{UNIX System V Release 4},
\textsl{Transport Layer Interface}.  The interface consists of an Application Programming Interface
implemented as a shared object library.  The shared object library communicates with a transport
provider Stream using a service primitive interface called the \textsl{Transport Provider
Interface}.

While \textsl{XTI} was implemented directly over STREAMS devices supporting the \textit{Transport
Provider Interface (TPI)} \cite[]{tpi} under SVR4, several non-traditional approaches exist in
implementation:

\item[{\it Berkeley Sockets.}]

Sockets uses the BSD interface that was developed by BBN for TCP/IP protocol suite under DARPA
contract on 4.1aBSD and released in 4.2BSD.  BSD Sockets provides a set of primary API functions
that are typically implemented as system calls.  The BSD Sockets interface is non-standard and is
now deprecated in favour of the POSIX/SUS standard Sockets interface.

\item[{\it POSIX Sockets.}]

Sockets were standardized by the \textit{OpenGroup} \cite[]{opengroup} and \textit{IEEE} in the
POSIX standardization process.  They appear in XNS 5.2 \cite[]{xns}, SUSv1 \cite[]{susv1}, SUSv2
\cite[]{susv2} and SUSv3 \cite[]{susv3}.

\end{description}

On systems traditionally supporting Sockets and then retrofitted to support STREAMS, there is one
approach toward supporting \textsl{XTI} without refitting the entire networking stack:\footnote{This
approach is taken by True64 (Digital) UNIX.}

\begin{description}

\item[{\it XTI over Sockets.}]

Several implementations of STREAMS on UNIX utilize the concept of \textsl{TPI} over Sockets.
Following this approach, a STREAMS pseudo-device driver is provided that hooks directly into
internal socket system calls to implement the driver, and yet the networking stack remains
fundamentally BSD in style.

\end{description}

Typically there are two approaches to implementing XTI on systems not supporting STREAMS:

\begin{description}

\item[{\it XTI Compatibility Library.}]

Several implementations of XTI on UNIX utilize the concept of an XTI compatibility
library.\footnote{One was even available for Linux at one point.}  This is purely a shared object
library approach to providing \textsl{XTI}.  Under this approach it is possible to use the
\textsl{XTI} application programming interface, but it is not possible to utilize any of the STREAMS
capabilities of an underlying \textit{Transport Provider Interface (TPI)} stream.

\item[{\it TPI over Sockets.}]

An alternate approach, taken by the \textsl{Linux iBCS} package was to provide a pseudo-transport
provider using a legacy character device to present the appearance of a STREAMS transport provider.

\end{description}

Conversely, on systems supporting STREAMS, but not traditionally supporting Sockets (such as SVR4),
there are four approaches toward supporting BSD and POSIX Sockets based on STREAMS:

\begin{description}

\item[{\it Compatibility Library}]

Under this approach, a compatibility library (\texttt{libsocket.o}) contains the socket calls as
library functions that internally invoke the TLI or TPI interface to an underlying STREAMS transport
provider.  This is the approach originally taken by SVR4 \cite[]{magic}, but this approach has
subsequently been abandoned due to the difficulties regarding fork(2) and fundamental
incompatibilities deriving from a library only approach.

\item[{\it Library and cooperating \sl STREAMS module.}]

Under this approach, a cooperating module, normally called \texttt{sockmod}, is pushed on a
Transport Provider Interface (TPI) Stream.  The library, normally called \texttt{socklib} or simply
\texttt{socket}, and cooperating \texttt{sockmod} module provide the BBN or POSIX Socket API.
\cite[]{impbsd} \cite[]{socklib}

\item[{\it Library and System Calls.}]

Under this approach, the BSD or POSIX Sockets API is implemented as system calls with the sole
exception of the \textbf{\texttt{socket}}(3) call.  The underlying transport provider is still an
\textsl{TPI}-based STREAMS transport provider, it is just that system calls instead of library calls
are used to implement the interface.  \cite[]{socklib}

\item[{\it System Calls.}]

Under this approach, even the socket(3) call is moved into the kernel.  Conversion between POSIX/BSD
Sockets calls and TPI service primitives is performed completely within the kernel.  The
sock2path(5) configuration file is used to configure the mapping between STREAMS devices and socket
types and domains \cite[]{socklib}.

\end{description}

\subsubsection[Standardization]{Standardization.}

During the POSIX standardization process, networking and Sockets interfaces were given special
treatment to ensure that both the legacy Sockets approach and the STREAMS approach to networking
were compatible. POSIX has standardized both the XTI and Sockets programmatic interface to
networking.  STREAMS networking has been POSIX compliant for many years, BSD Sockets, POSIX Sockets,
TLI and XTI interfaces, and were compliant in the \textsl{SVR4.2} release.  The STREAMS networking
provided by \textsl{Linux Fast-STREAMS} package provides POSIX compliant networking.

Therefore, any application utilizing a Socket or Stream in a POSIX compliant manner will also be
compatible with STREAMS networking.\footnote{This compatibility is exemplified by the
\texttt{netperf} program which does not distinguish between BSD or STREAMS based networking in their
implementation or use.}

\subsection[Linux Fast-STREAMS]{Linux Fast-STREAMS}

The first STREAMS package for Linux that provided SVR4 STREAMS capabilities was the \textsl{Linux
STREAMS (LiS)} package originally available from GCOM \cite[]{LiS}.  This package exhibited
incompatibilities with SVR 4.2 STREAMS and other STREAMS implementations, was buggy and performed
very poorly on Linux.  These difficulties prompted the OpenSS7 Project \cite[]{openss7} to implement
an SVR 4.2 STREAMS package from scratch, with the objective of production quality and
high-performance, named \textsl{Linux Fast-STREAMS} \cite[]{LfS}.

The OpenSS7 Project also maintains public and internal versions of the \textsl{LiS} package.  The
last public release was \textit{LiS-2.18.3}; the current internal release version is
\textit{LiS-2.18.6}.  The current production public release of \textsl{Linux Fast-STREAMS} is
\textit{streams-0.9.3}.

\section[Objective]{Objective}

The question has been asked whether there are performance differences between a purely BSD-style
approach and a STREAMS approach to TCP/IP networking, cf.  \cite[]{demux}.  However, there did not
exist a system which permitted both approaches to be tested on the same operating system.
\textsl{Linux Fast-STREAMS} running on the GNU/Linux operating system now permits this comparison to
be made.  The objective of the current study, therefore, was to determine whether, for the Linux
operating system, a STREAMS-based approach to TCP/IP networking is a viable replacement for the
BSD-style sockets approach provided by Linux, termed NET4.

When developing STREAMS, the authors oft times found that there were a number of preconceptions
espoused by Linux advocates about both STREAMS and STREAMS-based networking, as follows:

\begin{itemize}

\item STREAMS is slow.

\item STREAMS is more flexible, but less efficient \cite{lkmlfaq}.

\item STREAMS performs poorly on uniprocessor and ever poorer on SMP.

\item STREAMS networking is slow.

\item STREAMS networking is unnecessarily complex and cumbersome.

\end{itemize}

For example, the Linux kernel mailing list has this to say about STREAMS:

\footnotesize
\begin{quote}

\begin{description}

\item[(REG)] STREAMS allow you to "push" filters onto a network stack.  The idea is that you can
have a very primitive network stream of data, and then "push" a filter ("module") that implements
TCP/IP or whatever on top of that.  Conceptually, this is very nice, as it allows clean separation
of your protocol layers.  Unfortunately, implementing STREAMS poses many performance problems.  Some
Unix STREAMS based server telnet implementations even ran the data up to user space and back down
again to a pseudo-tty driver, which is very inefficient.

STREAMS will \textbf{never} be available in the standard Linux kernel, it will remain a separate
implementation with some add-on kernel support (that come with the STREAMS package).  Linus and his
networking gurus are unanimous in their decision to keep STREAMS out of the kernel.  They have
stated several times on the kernel list when this topic comes up that even optional support will not
be included.

\item[(REW, quoting Larry McVoy)] "It's too bad, I can see why some people think they are cool, but
the performance cost - both on uniprocessors and even more so on SMP boxes - is way too high for
STREAMS to ever get added to the Linux kernel."

Please stop asking for them, we have agreement amoungst the head guy, the networking guys, and the
fringe folks like myself that they aren't going in.

\item[(REG, quoting Dave Grothe, the STREAMS guy)] STREAMS is a good framework for implementing
complex and/or deep protocol stacks having nothing to do with TCP/IP, such as SNA.  It trades some
efficiency for flexibility.  You may find the Linux STREAMS package (LiS) to be quite useful if you
need to port protocol drivers from Solaris or UnixWare, as Caldera did.

\end{description}

The Linux STREAMS (LiS) package is available for download if you want to use STREAMS for Linux.  The
following site also contains a dissenting view, which supports STREAMS.

\end{quote}
\normalsize

The current study attempts to determine the validity of these preconceptions.

\section[Description]{Description}

Three implementations are tested:

\begin{description}

\item {\it Linux Kernel UDP ({\tt udp}).}

The native Linux socket and networking system.

\item {\it OpenSS7 STREAMS XTIoS {\tt inet} Driver.}

A STREAMS pseudo-device driver that communicates with a socket internal to the kernel.

The OpenSS7 implementation of STREAMS XTI over Sockets implementation of UDP.  While the
implementation uses the Transport Provider Interface and STREAMS to communicate with the driver,
internal to the driver a UDP Socket is opened and conversion between STREAMS and Sockets performed.

\item {\it OpenSS7 STREAMS TPI UDP Driver {\tt udp}.}

A STREAMS pseudo-device driver that fully implements UDP and communicates with the IP layer in the
kernel.

\end{description}

The three implementations tested vary in their implementation details.  These implementation details
are described below.

\subsection[Linux Kernel UDP]{Linux Kernel UDP}
\label{section:lkudp}

Normally, in BSD-style implementations of Sockets, Sockets is not merely the Application Programmer
Interface, but also consists of a more general purpose network protocol stack implementation
\cite[]{bsd}, even though the mechanism is not used for more than TCP/IP networking.  \cite[]{magic}

Although BSD networking implementations consist of a number of networking layers with soft
interrupts used for each layer of the networking stack \cite[]{bsd}, the Linux implementation,
although based on the the BSD approach, tightly integrates the socket, protocol, IP and interface
layers using specialized interfaces.  Although roughly corresponding to the BSD stack as illustrated
in \textit{Figure \ref{figure:sockets}}, the socket, protocol and interface layers in the BSD stack
have well defined, general purpose interfaces applicable to a wider range of networking protocols.

\begin{figure}[htp]
\center\includegraphics[height=3.5in]{sockets}
\caption[Sockets: BSD and Linux]{Sockets: BSD and Linux}
\label{figure:sockets}
\end{figure}

Both Linux UDP implementations are
a good example of the tight integration between the components of the Linux networking stack.

\paragraph*{Write side processing.}

On the write side of the Socket, bytes are copied from the user into allocated socket buffers.
Write side socket buffers are charged against the send buffer.  Socket buffers are immediately
dispatched to the IP layer for processing.  When the IP layer (or a driver) consumes the socket
buffer, it releases the amount of send buffer space that was charged for the send buffer.  If there
is insufficient space in the send buffer to accommodate the write, the calling processed is either
blocked or the system call returns an error (\texttt{ENOBUFS}).

For loop-back operation, immediately sending the socket buffer to the IP layer has the additional
ramification that the socket buffer is immediately struck from the send buffer and immediately added
to the receive buffer on the receiving socket.  Therefore, the size of the send buffer or the send
low water mark, have no effect.

%Primarily where Linux differs from BSD and STREAMS approaches is in dispatching socket buffers to
%the protocol and the network layers.  Under BSD, the \texttt{mbuf} is queued against the UDP
%protocol layer and the UDP layer software interrupt is raised \cite[]{bsd}.  When the buffer is
%later processed, it is queued against the IP protocol layer and the IP layer software interrupt is
%raised.  When the buffer is later processed, it is delivered to the driver.

%Linux, on the other hand, passes the socket buffer to the device driver in user context without
%intermediate queueing.

%Because of this fundamental difference, it is expected that comparisons between the Linux Socket
%implementation and STREAMS will differ radically from any such comparison between a true
%\textsl{BSD} Socket implementation and STREAMS.

\paragraph*{Read side processing.}

On the read side of the Socket, the network layer calls the protocol's receive function.  The
receive function checks if socket is locked (by a reading or writing user).  If the socket is locked
the socket buffer placed in the socket's backlog queue.  The backlog queue can hold a maximum number
of socket buffers.  If this maximum is exceeded, the packet is dropped.  If the socket is unlocked,
and the socket buffer will fit in the socket's receive buffer, the socket buffer is charged against
the receive buffer.  If the socket buffer will not fit in the receive buffer, the socket buffer is
dropped.

Read side processing under Linux does not differ from BSD, except for loop-back devices.  Normally,
for non-loop-back devices, \texttt{skbuff}s received by the device are queued against the IP layer
and the IP layer software interrupt is raised.  When the software interrupt runs, \texttt{skbuffs}s
are delivered directly to the transport protocol layer without intermediate queueing \cite[]{bsd}.

For loop-back operation, however, Linux skips queueing at the IP protocol layer (which does not
exist as it does in BSD) and, instead, delivers \texttt{skbuff}s directly to the transport protocol.

Due to this difference between Linux and \textsl{BSD} on the read side, it is expected that
performance results for Linux would vary from that of \textsl{BSD}, and the results of this testing
would therefore not be directly applicable to \textsl{BSD}.

\paragraph*{Buffering.}

Buffering at the Socket consist of a send buffer and low water mark and a receive buffer and low
water mark.  When the send buffer is consumed with outstanding messages, writing processes will
either block or the system call will fail with an error (\texttt{ENOBUFS}).   When the send buffer
is full higher than the low water mark, a blocked writing process will not be awoken (regardless of
whether the process is blocked in write or blocked in poll/select).  The send low water mark for
Linux is fixed at one-half of the send buffer.

It should be noted that for loop-back operation under Linux, the send buffering mechanism is
effectively defeated.

When the receive buffer is consumed with outstanding messages, received messages will be discarded.
This is in rather stark contrast to BSD where messages are effectively returned to the network layer
when the socket receive buffer is full and the network layer can determine whether messages should
be discarded or queued further \cite[]{bsd}.

When there is no data in the receive buffer, the reading process will either block or return from
the system call with an error (\texttt{ENOBUFS} again).  When the receive buffer has fewer bytes of
data in it than the low water mark, a blocked reading process will not be awoken (regardless of
whether the process is blocked in write or blocked in poll/select).  The receive low water mark for
Linux is typically set to BSD default of 1 byte.\footnote{The fact that Linux sets the receive low
water mark to 1 byte is an indication that the buffering mechanism on the read side simply does not
work.}

It should be noted that the Linux buffering mechanism does not have hysteresis like that of STREAMS.
When the amount of data in the send buffer exceeds the low water mark, poll will cease to return
\texttt{POLLOUT}; when the receive buffer is less than the low water mark, poll will cease to return
\texttt{POLLIN}.

\paragraph*{Scheduling.}

Scheduling of processes and the buffering mechanism are closely related.

Writing processes for loop-back operation under UDP are allowed to spin wildly.  Written data
charged against the send buffer is immediately released when the loop-back interface is encountered
and immediately delivered to the receiving socket (or discarded).  If the writing process is writing
data faster that the reading process is consuming it, the excess will simply be discarded, and no
back-pressure signalled to the sending socket.

If receive buffer sizes are sufficiently large, the writing process will lose the processor on
uniprocessor systems and the reading process scheduled before the buffer overflows; if they are not,
the excess will be discarded.  On multiprocessor systems, provided that the read operation takes
less time than the write operation, the reading process will be able to keep pace with the writing
process.  If the receiving process is run with a very low priority, the writing process will always
have the processor and a large percentage of the written messages will be discarded.

It should be noted that this is likely a Linux-specific deficiency as the BSD system introduces
queueing, even on loop-back.

Reading processes for loop-back operation under UDP are awoken whenever a single byte is received
(due to the default receive low water mark).  If the reading process has higher priority than the
writing process on uniprocessors, the reading process will be awoken for each message sent and the
reading process will read that message before the writing process is permitted to write another.  On
SMP systems, because reading processes will likely have the socket locked while reading each
message, backlog processing will likely be invoked.

\subsection[Linux Fast-STREAMS]{Linux Fast-STREAMS}

\textsl{Linux Fast-STREAMS} is an implementation of \textsl{SVR4.2 STREAMS} for the
\textsl{GNU/Linux} system developed by the \textsl{OpenSS7 Project} \cite[]{openss7} as a
replacement for the buggy, under-performing and now deprecated \textsl{Linux STREAMS (LiS)} package.
\textsl{Linux Fast-STREAMS} provides the STREAMS executive and interprocess communication facilities
(pipes and FIFOs).  Add-on packages provide compatibility between \textsl{Linux Fast-STREAMS} and
other STREAMS implementations, a complete \textsl{XTI} shared object library, and transport
providers.  Transport providers for the TCP/IP suite consist of an \texttt{inet} driver that uses
the \textit{XTI over Sockets} approach as well as a full STREAMS implementation of SCTP (Stream
Control Transmission Protocol), UDP (User Datagram Protocol) and RAWIP (Raw Internet Protocol).

\subsubsection[XTI over Sockets]{XTI over Sockets}
\label{section:xtios}

The XTI over Sockets implementation is the \texttt{inet} STREAMS driver developed by the
\textsl{OpenSS7 Project} \cite[]{openss7}. As illustrated in \textit{Figure \ref{figure:xtios}},
this driver is implemented as a STREAMS pseudo-device driver and uses STREAMS for passing TPI
service primitives to and from upstream modules or the \textit{Stream head}.  Within the driver,
data and other TPI service primitives are translated into kernel socket calls to a socket that was
opened by the driver corresponding to the transport provider instance.  Events received from this
internal socket are also translated into transport provider service primitives and passed upstream.

\begin{figure}[htp]
\center\includegraphics[height=3.5in]{xtios}
\caption[XTI over Sockets \texttt{inet} Driver]{XTI over Sockets \texttt{inet} Driver}
\label{figure:xtios}
\end{figure}

\paragraph*{Write side processing.}

Write side processing uses standard STREAMS flow control mechanisms as are described for TPI, below,
with the exception that once the message blocks arrive at the driver they are passed to the internal
socket.  Therefore, a unique characteristic of the write side processing for the XTI over Sockets
driver is that data is first copied from user space into STREAMS message blocks and then copied
again from the STREAMS message blocks to the socket.  This constitutes two copies per byte versus
one copy per byte and has a significant impact on the performance of the driver at large message
sizes.\footnote{This expectation of peformance impact is held up by the test results.}

\paragraph*{Read side processing.}

Read side processing uses standard STREAMS flow control mechanisms as are described for TPI, below.
A unique characteristic of the read side processing fro the XTI over Sockets driver is that data is
first copied from the internal socket to a STREAMS message block and then copied again from the
STREAMS message block to user space.  This constitutes two copies per byte versus one copy per byte
and has a significant impact on the performance of the driver at large message sizes.\footnote{This
expectation of peformance impact is held up by the test results.}

\paragraph*{Buffering.}

Buffering uses standard STREAMS queueing and flow control mechanisms as are described for TPI,
below.

\paragraph*{Scheduling.}

Scheduling resulting from queueing and flow control are the same as described for TPI below.
Considering that the internal socket used by the driver is on the loop-back interface, data written
on the sending socket appears immediately at the receiving socket or is discarded.

\subsubsection[STREAMS TPI]{STREAMS TPI}
\label{section:tpiudp}

The STREAMS TPI implementation of UDP is a direct STREAMS implementation that uses the
\texttt{udp} driver developed by the \textsl{OpenSS7 Project} \cite[]{openss7}.  As illustrated in
\textit{Figure \ref{figure:udp}}, this driver interfaces to Linux at the network layer, but
provides a complete STREAMS implementation of the transport layer.  Interfacing with Linux at the
network layer provides for de-multiplexed STREAMS architecture \cite[]{demux}.  The driver presents
the Transport Provider Interface (TPI) \cite[]{tpi} for use by upper level modules and the XTI
library \cite[]{xti}.

\begin{figure}[htp]
\center\includegraphics[height=3.5in]{udp}
\caption[STREAMS \texttt{udp} Driver]{STREAMS \texttt{udp} Driver}
\label{figure:udp}
\end{figure}

\textsl{Linux Fast-STREAMS} also provides a raw IP driver (\texttt{raw}) and an SCTP driver
(\texttt{sctp}) that operate in the same fashion as the \texttt{udp} driver.  That is, performing
all transport protocol functions within the driver and interfacing to the Linux NET4 IP layer.  One
of the project objectives of performing the current testing was to determine whether it would be
worth the effort to write a STREAMS transport implementation of TCP, the only missing component in
the TCP/IP suite that necessitates the continued support of the XTI over Sockets (\texttt{inet})
driver.

\paragraph*{Write side processing.}

Write side processing follows standard STREAMS flow control.  When a write occurs at the
\textit{Stream head}, the \textit{Stream head} checks for downstream flow control on the write
queue.  If the \textit{Stream} is flow controlled, the calling process is blocked or the write
system call fails (\texttt{EAGAIN}).  When the \textit{Stream} is not flow controlled, user data is
transferred to allocated message blocks and passed downstream.  When the message blocks arrive at a
downstream queue, the count of the data in the message blocks is added to to the queue count.  If
the queue count exceeds the high water mark defined for the queue, the queue is marked full and
subsequent upstream flow control tests will fail.

\paragraph*{Read side processing.}

Read side processing follows standard STREAMS flow control.  When a read occurs at the
\textit{Stream head}, the \textit{Stream head} checks the read queue for messages.  If the read
queue has no messages queued, the queue is marked to be enabled when messages arrive and the calling
process is either blocked or the system call returns an error (\texttt{EAGAIN}).  If messages exist
on the read queue, they are dequeued and data copied from the message blocks to the user supplied
buffer.  If the message block is completely consumed, it is freed; otherwise, the message block is
placed back on the read queue with the remaining data.

\paragraph*{Buffering.}

Buffering follows the standard STREAMS queueing and flow control mechanisms.  When a queue is found
empty by a reading process, the fact that the queue requires service is recorded.  Once the first
message arrives at the queue following a process finding the queue empty, the queue's service
procedure will be scheduled with the STREAMS scheduler.  When a queue is tested for flow control and
the queue is found to be full, the fact that a process wishes to write the to queue is recorded.
When the count of the data on the queue falls beneath the low water mark, previous queues will be
back enabled (that is, their service procedures will be scheduled with the STREAMS scheduler).

\paragraph*{Scheduling.}

When a queue downstream from the \textit{stream head} write queue is full, writing processes either
block or fail with an error (\texttt{EAGAIN}).  When the forward queue's count falls below its
\textit{low water mark}, the \textit{stream head} write queue is back-enabled.  Back-enabling
consists of scheduling the queue's service procedure for execution by the STREAMS scheduler.  Only
later, when the STREAMS scheduler runs pending tasks, does any writing process blocked on flow
control get woken.

When a \textit{stream head} read queue is empty and a reading processes either block or fail with an
error (\textit{EAGAIN}).  When a message arrives at the \textit{stream head} read queue, the service
procedure associated with the queue is scheduled for later execution by the STREAMS scheduler.  Only
later, when the STREAMS scheduler runs pending tasks, does any reading process blocked awaiting
messages get awoken.

\section[Method]{Method}

To test the performance of STREAMS networking, the \textsl{Linux Fast-STREAMS} package was used
\cite[]{LfS}.  The \textsl{Linux Fast-STREAMS} package builds and installs Linux loadable kernel
modules and includes the modified \texttt{netperf} and \texttt{iperf} programs used for testing.

\paragraph*{Test Program.}

One program used is a version of the \texttt{netperf} network performance measurement tool developed
and maintained by Rick Jones for \textit{Hewlett-Packard}.  This modified version is available from
the \textit{OpenSS7 Project} \cite[]{netperf}.  While the program is able to test using both POSIX
Sockets and XTI STREAMS interfaces, modifications were required to the package to allow it to
compile for \textsl{Linux Fast-STREAMS}.

The \texttt{netperf} program has many options.  Therefore, a benchmark script (called
\texttt{netperf\_benchmark}) was used to obtain repeatable raw data for the various machines and
distributions tested.  This benchmark script is included in the \texttt{netperf} distribution
available from the \textit{OpenSS7 Project} \cite[]{netperf}.  A listing of this script is provided
in \textit{Appendix \ref{section:script}}.

\subsection[Implementations Tested]{Implementations Tested}

The following implementations were tested:

\paragraph*{UDP Sockets}

This is the Linux NET4 Sockets implementation of UDP, described in \textsl{Section
\ref{section:lktcp}}, with normal scheduling priorities.  Normal scheduling priority means invoking
the sending and receiving processes without altering their run-time scheduling priority.

\paragraph*{UDP Sockets with artificial process priorities.}

\paragraph*{STREAMS XTIoS UDP.}

This is the OpenSS7 STREAMS implementation of XTI over Sockets for UDP, described in \textsl{Section
\ref{section:xtios}}.  This implementation is tested using normal run-time scheduling priorities.

\paragraph*{STREAMS TPI SCTP.}

This is the OpenSS7 STREAMS implementation of UDP using XTI/TPI directly, described in
\textsl{Section \ref{section:tpiudp}}.  This implementation is tested using normal run-time
scheduling priorities.

\subsection[Distributions Tested]{Distributions Tested}

To remove the dependence of test results on a particular Linux kernel or machine, various Linux
distributions were used for testing.  The distributions tested are as follows:

\small
\setlength{\tabcolsep}{0.4em}
\setlength{\arraycolsep}{0.4em}
\begin{tabular}{ll}\\
Distribution & Kernel\\
\hline
RedHat 7.2 & 2.4.20-28.7\\
WhiteBox 3 & 2.4.27\\
CentOS 4 & 2.6.9-5.0.3.EL\\
SuSE 10.0 OSS & 2.6.13-15-default\\
Ubuntu 6.10 & 2.6.17-11-generic\\
Ubuntu 7.04 & 2.6.20-15-server\\
Fedora Core 6 & 2.6.20-1.2933.fc6\\
\end{tabular}\\
\normalsize

\subsection[Test Machines]{Test Machines}

To remove the dependence of test results on a particular machine, various machines were used for
testing as follows:

\small
\setlength{\tabcolsep}{0.4em}
\setlength{\arraycolsep}{0.4em}
\begin{tabular}{llll}\\
Hostname & Processor & Memory & Architecture\\
\hline
porky & 2.57GHz PIV & 1Gb (333MHz) & i686 UP\\
pumbah & 2.57GHz PIV & 1Gb (333MHz) & i686 UP\\
daisy & 3.0GHz i630 HT & 1Gb (400MHz) & x86\_64 SMP\\
mspiggy & 1.7GHz PIV & 1Gb (333MHz) & i686 UP\\
\end{tabular}
\normalsize

\section[Results]{Results}

The results for the various distributions and machines is tabulated in \textit{Appendix
\ref{section:rawdata}}.  The data is tabulated as follows:

\begin{description}

\item[{\it Performance.}]

Performance is charted by graphing the number of messages sent and received per second against the
logarithm of the message send size.

\item[{\it Delay.}]

Delay is charted by graphing the number of seconds per send and receive against the sent message
size.  The delay can be modelled as a fixed overhead per send or receive operation and a fixed
overhead per byte sent.  This model results in a linear graph with the zero x-intercept representing
the fixed per-message overhead, and the slope of the line representing the per-byte cost.  As all
implementations use the same primary mechanism for copying bytes to and from user space, it is
expected that the slope of each graph will be similar and that the intercept will reflect most
implementation differences.

\item[{\it Throughput.}]

Throughput is charted by graphing the logarithm of the product of the number of messages per second
and the message size against the logarithm of the message size.  It is expected that these graphs
will exhibit strong log-log-linear (power function) characteristics.  Any curvature in these graphs
represents throughput saturation.

\item[{\it Improvement.}]

Improvement is charted by graphing the quotient of the bytes per second of the implementation and
the bytes per second of the Linux sockets implementation as a percentage against the message size.
Values over 0\% represent an improvement over Linux sockets, whereas values under 0\% represent the
lack of an improvement.

\end{description}

The results are organized in the sections that follow in order of the machine tested.

\subsection[Porky]{Porky}

Porky is a 2.57GHz Pentium IV (i686) uniprocessor machine with 1Gb of memory.  Linux distributions
tested on this machine are as follows:

\small
\setlength{\tabcolsep}{0.4em}
\setlength{\arraycolsep}{0.4em}
\begin{tabular}{ll}\\
Distribution & Kernel\\
\hline
Fedora Core 6 & 2.6.20-1.2933.fc6\\
CentOS 4 & 2.6.9-5.0.3.EL\\
SuSE 10.0 OSS & 2.6.13-15-default\\
Ubuntu 6.10 & 2.6.17-11-generic\\
Ubuntu 7.04 & 2.6.20-15-server\\
\end{tabular}
\normalsize

\subsubsection[Fedora Core 6]{Fedora Core 6}

Fedora Core 6 is the most recent full release Fedora distribution.  This distribution sports a
2.6.20-1.2933.fc6 kernel with the latest patches.  This is the \texttt{x86} distribution with recent
updates.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:fc6perf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

\item[Delay.]

\textit{Figure \ref{figure:fc6dly}}
plots the average message delay of UDP Sockets compared to XTI over Socket and XTI approaches.
STREAMS demonstrates significant improvements at message sizes of less than 1024 bytes.

From the figure, it can be seen that the slope of the delay graph for STREAMS and Sockets are about
the same.  This is expected as both implementations use the same function to copy message bytes to
and from user space.  The slope of the XTI over Sockets graph is over twice the slope of the Sockets
graph which reflects the fact that XTI over Sockets performs multiple copies of the data: two copies
on the send side and two copies on the receive side.

The intercept for STREAMS is lower than Sockets, indicating that STREAMS has a lower per-message
overhead than Sockets, despite the fact that the destination address is being copied to and from
user space for each message.

\item[Throughput.]

\textit{Figure \ref{figure:fc6thrput}}
plots the effective throughput of UDP Sockets compared to XTI over Socket and XTI approaches.
STREAMS demonstrates significant improvements at all message sizes.

As can be seen from the figure, all implementations exhibit strong power function characteristics
(at least at lower write sizes), indicating structure and robustness for each implementation.  The
slight concave downward curvature of the graphs at large message sizes indicates some degree of
saturation.

\item[Improvement.]

\textit{Figure \ref{figure:fc6comp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements (approx. 30\% improvement) at message sizes below 1024 bytes.  Perhaps
surprising is that the XTI over Sockets approach rivals (95\%) Sockets alone at small message sizes
(where multiple copies are not controlling).

\end{description}

The results for Fedora Core 6 on Porky are, for the most part, similar to the results from other
distributions on the same host and also similar to the results for other distributions on other
hosts.

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_fc6_perf}
\caption[Fedora Core 6 on Porky Performance]{Fedora Core 6 on Porky Performance}
\label{figure:fc6perf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_fc6_delay}
\caption[Fedora Core 6 on Porky Delay]{Fedora Core 6 on Porky Delay}
\label{figure:fc6dly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_fc6_thrput}
\caption[Fedora Core 6 on Porky Throughput]{Fedora Core 6 on Porky Throughput}
\label{figure:fc6thrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_fc6_comp}
\caption[Fedora Core 6 on Porky Comparison]{Fedora Core 6 on Porky Comparison}
\label{figure:fc6comp}
\end{figure}

\subsubsection[CentOS 4.0]{CentOS 4.0}
CentOS 4.0 is a clone of the RedHat Enterprise 4 distribution.  This is the
\texttt{x86} version of the distribution.  The distribution sports a
2.6.9-5.0.3.EL kernel.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:centosperf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

As can be seen from the figure, \textsl{Linux Fast-STREAMS} outperforms Linux at all message sizes.
Also, and perhaps surprisingly, the XTI over Sockets implementation also performs as well as Linux
at lower message sizes.

\item[Delay.]

\textit{Figure \ref{figure:centosdly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

Both STREAMS and Sockets exhibit the same slope, and XTI over Sockets exhibits over twice the slope,
indicating that copies of data control the per-byte characteristics.  STREAMS exhibits a lower
intercept than both other implementations, indicating that STREAMS has the lowest per-message
overhead, regardless of copying the destination address to and from the user with each sent and
received message.

\item[Throughput.]

\textit{Figure \ref{figure:centosthrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

As can be seen from the figure, all implementations exhibit strong power function characteristics
(at least at lower write sizes), indicating structure and robustness for each implementation.
Again, the slight concave downward curvature at large memory sizes indicates memory bus saturation.

\item[Improvement.]

\textit{Figure \ref{figure:centoscomp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements (approx. 30-40\% improvement) at message sizes below 1024 bytes.  Perhaps
surprising is that the XTI over Sockets approach rivals (97\%) Sockets alone at small message sizes
(where multiple copies are not controlling).

\end{description}

The results for CentOS on Porky are, for the most part, similar to the results from other
distributions on the same host and also similar to the results for other distributions on other
hosts.

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_centos_perf}
\caption[CentOS on Porky Performance]{CentOS on Porky Performance}
\label{figure:centosperf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_centos_delay}
\caption[CentOS on Porky Delay]{CentOS on Porky Delay}
\label{figure:centosdly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_centos_thrput}
\caption[CentOS on Porky Throughput]{CentOS on Porky Throughput}
\label{figure:centosthrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_centos_comp}
\caption[CentOS on Porky Comparison]{CentOS on Porky Comparison}
\label{figure:centoscomp}
\end{figure}

\subsubsection[SuSE 10.0 OSS]{SuSE 10.0 OSS}

SuSE 10.0 OSS is the public release version of the SuSE/Novell distribution.  There have been two
releases subsequent to this one: the 10.1 and recent 10.2 releases.  The SuSE 10 release sports a
2.6.13 kernel and the 2.6.13-15-default kernel was the tested kernel.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:suseperf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

\item[Delay.]

\textit{Figure \ref{figure:susedly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

Again, STREAMS and Sockets exhibit the same slope, and XTI over Sockets more than twice the slope.
STREAMS again has a significantly lower intercept and the XTI over Sockets and Sockets intercepts
are similar, indicating that STREAMS has a smaller per-message overhead, despite copying destination
addresses with each message.

\item[Throughput.]

\textit{Figure \ref{figure:susethrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:susethrput}}, all implementations exhibit strong
power function characteristics (at least at lower write sizes), indicating structure and robustness
for each implementation.

\item[Improvement.]

\textit{Figure \ref{figure:susecomp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements (25-30\%) at all message sizes.

\end{description}

The results for SuSE 10 OSS on Porky are, for the most part, similar to the results from other
distributions on the same host and also similar to the results for other distributions on other
hosts.

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_suse_perf}
\caption[SuSE on Porky Performance]{SuSE on Porky Performance}
\label{figure:suseperf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_suse_delay}
\caption[SuSE on Porky Delay]{SuSE on Porky Delay}
\label{figure:susedly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_suse_thrput}
\caption[SuSE on Porky Throughput]{SuSE on Porky Throughput}
\label{figure:susethrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_suse_comp}
\caption[SuSE on Porky Comparison]{SuSE on Porky Comparison}
\label{figure:susecomp}
\end{figure}

\subsubsection[Ubuntu 6.10]{Ubuntu 6.10}

Ubuntu 6.10 is the current release of the Ubuntu distribution.  The Ubuntu 6.10 release sports a
2.6.15 kernel.  The tested distribution had current updates applied.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:ubuntuperf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates marginal improvements (approx. 5\%) at all message sizes.

\item[Delay.]

\textit{Figure \ref{figure:ubuntudly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates marginal improvements at all message sizes.

Although STREAMS exhibits the same slope (per-byte processing overhead) as Sockets, Ubuntu and the
2.6.17 kernel are the only combination where the STREAMS intercept is not significantly lower than
Sockets.  Also, the XTI over Sockets slope is steeper and the XTI over Sockets intercept is much
larger than Sockets alone.

\item[Throughput.]

\textit{Figure \ref{figure:ubuntuthrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates marginal improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:ubuntuthrput}}, all implementations exhibit strong
power function characteristics (at least at lower write sizes), indicating structure and robustness
for each implementation.

\item[Improvement.]

\textit{Figure \ref{figure:ubuntucomp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
marginal improvements (approx. 5\%) at all message sizes.

Unbuntu is the only distribution tested where STREAMS does not show significant improvements over
Sockets.  Nevertheless, STREAMS does show marginal improvement (approx. 5\%) over all message sizes
and performed better than Sockets at all message sizes.

\end{description}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_ubuntu_perf}
\caption[Ubuntu 6.10 on Porky Performance]{Ubuntu 6.10 on Porky Performance}
\label{figure:ubuntuperf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_ubuntu_delay}
\caption[Ubuntu 6.10 on Porky Delay]{Ubuntu 6.10 on Porky Delay}
\label{figure:ubuntudly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_ubuntu_thrput}
\caption[Ubuntu 6.10 on Porky Throughput]{Ubuntu 6.10 on Porky Throughput}
\label{figure:ubuntuthrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_ubuntu_comp}
\caption[Ubuntu 6.10 on Porky Comparison]{Ubuntu 6.10 on Porky Comparison}
\label{figure:ubuntucomp}
\end{figure}

\subsubsection[Ubuntu 7.04]{Ubuntu 7.04}

Ubuntu 7.04 is the current release of the Ubuntu distribution.  The Ubuntu 7.04 release sports a
2.6.20 kernel.  The tested distribution had current updates applied.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:u704perf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements (approx. 20-60\%) at all message sizes.

\item[Delay.]

\textit{Figure \ref{figure:u704dly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

STREAMS and Sockets exhibit the slope, and XTI over Sockets more than twice the slope.  STREAMS,
however, has a significantly lower intercept and XTI over Sockets and Sockets intercepts are
similar, indicating that STREAMS has a smaller per-message overhead, despite copying destination
addresses with each message.

\item[Throughput.]

\textit{Figure \ref{figure:u704thrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:u704thrput}}, all implementations exhibit strong
power function characteristics (at least at lower write sizes), indicating structure and robustness
for each implementation.

\item[Improvement.]

\textit{Figure \ref{figure:u704comp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements (approx. 20-60\%) at all message sizes.

\end{description}

The results for Ubuntu 7.04 on Porky are, for the most part, similar to the results from other
distributions on the same host and also similar to the results for other distributions on other
hosts.

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_u704_perf}
\caption[Ubuntu 7.04 on Porky Performance]{Ubuntu 7.04 on Porky Performance}
\label{figure:u704perf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_u704_delay}
\caption[Ubuntu 7.04 on Porky Delay]{Ubuntu 7.04 on Porky Delay}
\label{figure:u704dly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_u704_thrput}
\caption[Ubuntu 7.04 on Porky Throughput]{Ubuntu 7.04 on Porky Throughput}
\label{figure:u704thrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_u704_comp}
\caption[Ubuntu 7.04 on Porky Comparison]{Ubuntu 7.04 on Porky Comparison}
\label{figure:u704comp}
\end{figure}

\subsection[Pumbah]{Pumbah}
Pumbah is a 2.57GHz Pentium IV (i686) uniprocessor machine with 1Gb of memory.
This machine differs from Porky in memory type only (Pumbah has somewhat
faster memory than Porky.) Linux distributions tested on this machine are as
follows:

\small
\setlength{\tabcolsep}{0.4em}
\setlength{\arraycolsep}{0.4em}
\begin{tabular}{ll}\\
Distribution & Kernel\\
\hline
RedHat 7.2 & 2.4.20-28.7\\
\end{tabular}\\[1.0ex]
\normalsize

Pumbah is a control machine and is used to rule out differences between recent 2.6 kernels and one
of the oldest and most stable 2.4 kernels.

\subsubsection[RedHat 7.2]{RedHat 7.2}

RedHat 7.2 is one of the oldest (and arguably the most stable) glibc2 based releases of the RedHat
distribution.  This distribution sports a 2.4.20-28.7 kernel.  The distribution has all available
updates applied.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:rh7perf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes, and staggering improvements at large
message sizes.

\item[Delay.]

\textit{Figure \ref{figure:rh7dly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes, and staggering improvements at large
message sizes.

The slope of the STREAMS delay curve is much lower than (almost half that of) the Sockets delay
curve, indicating that STREAMS is exploiting some memory efficiencies not possible in the Sockets
implementation.

%On Linux 2.6 kernels, STREAMS uses RCU for memory caches for message blocks.  on Linux 2.4 kernels,
%RCU is not available, and STREAMS uses its own hot free list for message blocks.  This would in
%part expain the significantly faster per-byte performance of STREAMS, if it were not for the
%Mspiggy control machine that exhibits the same characteristic on a 2.6 kernel.

\item[Throughput.]

\textit{Figure \ref{figure:rh7thrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:rh7thrput}}, all implementations exhibit strong power
function characteristics (at least at lower write sizes), indicating structure and robustness for
each implementation.

The Linux NET4 UDP implementation results deviate more sharply from power function behaviour at high
message sizes.  This also, is rather different that the 2.6 kernel situation.  One contributing
factor is the fact that neither the send nor receive buffers can be set above 65,536 bytes on this
version of Linux 2.4 kernel.  Tests were performed with send and receive buffer size requests of
131,072 bytes.  Both the STREAMS XTI over Sockets UDP implementation and the Linux NET4 UDP
implementation suffer from the maximum buffer size, whereas, the STREAMS UDP implementation
implements and permits the larger buffers.

\item[Improvement.]

\textit{Figure \ref{figure:rh7comp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements all message sizes.

The more dramatic improvements over Linux NET4 UDP and XTI over Sockets UDP is likely due in part to
the restriction on buffer sizes in 2.4 as described above.

Unfortunately, the RedHat 7.2 system does not appear to have acted as a very good control system.
The differences in maximum buffer size make any differences from other tested behaviour obvious.

\end{description}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_rh7_perf}
\caption[RedHat 7.2 on Pumbah Performance]{RedHat 7.2 on Pumbah Performance}
\label{figure:rh7perf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_rh7_delay}
\caption[RedHat 7.2 on Pumbah Delay]{RedHat 7.2 on Pumbah Delay}
\label{figure:rh7dly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_rh7_thrput}
\caption[RedHat 7.2 on Pumbah Throughput]{RedHat 7.2 on Pumbah Throughput}
\label{figure:rh7thrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_rh7_comp}
\caption[RedHat 7.2 on Pumbah Comparison]{RedHat 7.2 on Pumbah Comparison}
\label{figure:rh7comp}
\end{figure}

\subsection[Daisy]{Daisy}
Daisy is a 3.0GHz i630 (x86\_64) hyper-threaded machine with 1Gb of memory.
Linux distributions tested on this machine are as follows:

\small
\setlength{\tabcolsep}{0.4em}
\setlength{\arraycolsep}{0.4em}
\begin{tabular}{ll}\\
Distribution & Kernel\\
\hline
Fedora Core 6 & 2.6.20-1.2933.fc6\\
CentOS 5.0 & 2.6.18-8.1.3.el5\\
\end{tabular}\\[1.0ex]
\normalsize

This machine is used as an SMP control machine.  Most of the tests were performed on uniprocessor
non-hyper-threaded machines.  This machine is hyper-threaded and runs full SMP kernels.  This
machine also supports EMT64 and runs \texttt{x86\_64} kernels.  It is used to rule out both SMP
differences as well as 64-bit architecture differences.

\subsubsection[Fedora Core 6 (x86\_64)]{Fedora Core 6 (x86\_64)}

Fedora Core 6 is the most recent full release Fedora distribution.  This distribution sports a
2.6.20-1.2933.fc6 kernel with the latest patches.  This is the \texttt{x86\_64} distribution with
recent updates.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:smpperf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

\item[Delay.]

\textit{Figure \ref{figure:smpdly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

The slope of the delay curve either indicates that Sockets is using slightly larger buffers than
STREAMS, or that Sockets is somehow exploiting some per-byte efficiencies at larger message sizes
not achieved by STREAMS.  Nevertheless, the STREAMS intercept is so low that the delay curve for
STREAMS is everywhere beneath that of Sockets.

\item[Throughput.]

\textit{Figure \ref{figure:smpthrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:smpthrput}}, all implementations exhibit strong power
function characteristics (at least at lower write sizes), indicating structure and robustness for
each implementation.

\item[Improvement.]

\textit{Figure \ref{figure:smpcomp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements (approx. 40\% improvement) at message sizes below 1024 bytes.  That STREAMS
UDP gives a 40\% improvement over a wide range of message sizes on SMP is a dramatic improvement.
Statements regarding STREAMS networking running poorer on SMP than on UP are quite wrong, at least
with regard to \textsl{Linux Fast-STREAMS}.

\end{description}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_smp_perf}
\caption[Fedora Core 6 on Daisy Performance]{Fedora Core 6 on Daisy Performance}
\label{figure:smpperf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_smp_delay}
\caption[Fedora Core 6 on Daisy Delay]{Fedora Core 6 on Daisy Delay}
\label{figure:smpdly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_smp_thrput}
\caption[Fedora Core 6 on Daisy Throughput]{Fedora Core 6 on Daisy Throughput}
\label{figure:smpthrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_smp_comp}
\caption[Fedora Core 6 on Daisy Comparison]{Fedora Core 6 on Daisy Comparison}
\label{figure:smpcomp}
\end{figure}

\subsubsection[CentOS 5.0 (x86\_64)]{CentOS 5.0 (x86\_64)}

CentOS 5.0 is the most recent full release CentOS distribution.  This distribution sports a
2.6.18-8.1.3.el5 kernel with the latest patches.  This is the \texttt{x86\_64} distribution with
recent updates.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:cos5perf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

\item[Delay.]

\textit{Figure \ref{figure:cos5dly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at message sizes of less than 1024 bytes.

The slope of the delay curve either indicates that Sockets is using slightly larger buffers than
STREAMS, or that Sockets is somehow exploiting some per-byte efficiencies at larger message sizes
not achieved by STREAMS.  Nevertheless, the STREAMS intercept is so low that the delay curve for
STREAMS is everywhere beneath that of Sockets.

\item[Throughput.]

\textit{Figure \ref{figure:cos5thrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:cos5thrput}}, all implementations exhibit strong
power function characteristics (at least at lower write sizes), indicating structure and robustness
for each implementation.

\item[Improvement.]

\textit{Figure \ref{figure:cos5comp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements (approx. 40\% improvement) at message sizes below 1024 bytes.  That STREAMS
UDP gives a 40\% improvement over a wide range of message sizes on SMP is a dramatic improvement.
Statements regarding STREAMS networking running poorer on SMP than on UP are quite wrong, at least
with regard to \textsl{Linux Fast-STREAMS}.

\end{description}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_cos5_perf}
\caption[CentOS 5.0 on Daisy Performance]{CentOS 5.0 on Daisy Performance}
\label{figure:cos5perf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_cos5_delay}
\caption[CentOS 5.0 on Daisy Delay]{CentOS 5.0 on Daisy Delay}
\label{figure:cos5dly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_cos5_thrput}
\caption[CentOS 5.0 on Daisy Throughput]{CentOS 5.0 on Daisy Throughput}
\label{figure:cos5thrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_cos5_comp}
\caption[CentOS 5.0 on Daisy Comparison]{CentOS 5.0 on Daisy Comparison}
\label{figure:cos5comp}
\end{figure}

\subsection[Mspiggy]{Mspiggy}
Mspiggy is a 1.7Ghz Pentium IV (M-processor) uniprocessor notebook (Toshiba
Satellite 5100) with 1Gb of memory.  Linux distributions tested on this
machine are as follows:

\small
\setlength{\tabcolsep}{0.4em}
\setlength{\arraycolsep}{0.4em}
\begin{tabular}{ll}\\
Distribution & Kernel\\
\hline
SuSE 10.0 OSS & 2.6.13-15-default\\
\end{tabular}\\[1.0ex]
\normalsize

Note that this is the same distribution that was also tested on Porky.  The purpose of testing on
this notebook is to rule out the differences between machine architectures on the test results.
Tests performed on this machine are control tests.

\subsubsection[SuSE 10.0 OSS]{SuSE 10.0 OSS}

SuSE 10.0 OSS is the public release version of the SuSE/Novell distribution.  There have been two
releases subsequent to this one: the 10.1 and recent 10.2 releases.  The SuSE 10 release sports a
2.6.13 kernel and the 2.6.13-15-default kernel was the tested kernel.

\begin{description}

\item[Performance.]

\textit{Figure \ref{figure:nbperf}}
plots the measured performance of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes, and staggering improvements at large
message sizes.

\item[Delay.]

\textit{Figure \ref{figure:nbdly}}
plots the average message delay of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates significant improvements at all message sizes, and staggering improvements at large
message sizes.

The slope of the STREAMS delay curve is much lower than (almost half that of) the Sockets delay
curve, indicating that STREAMS is exploiting some memory efficiencies not possible in the Sockets
implementation.

\item[Throughput.]

\textit{Figure \ref{figure:nbthrput}}
plots the effective throughput of Sockets compared to XTI over Socket and XTI approaches.  STREAMS
demonstrates improvements at all message sizes.

As can be seen from \textit{Figure \ref{figure:nbthrput}}, all implementations exhibit strong power
function characteristics (at least at lower write sizes), indicating structure and robustness for
each implementation.

The Linux NET4 UDP implementation results deviate more sharply from power function behaviour at high
message sizes.  One contributing factor is the fact that neither the send nor receive buffers can be
set above about 111,000 bytes on this version of Linux 2.6 kernel running on this speed of
processor.  Tests were performed with send and receive buffer size requests of 131,072 bytes.  Both
the STREAMS XTI over Sockets UDP implementation and the Linux NET4 UDP implementation suffer from
the maximum buffer size, whereas, the STREAMS UDP implementation implements and permits the larger
buffers.

\item[Improvement.]

\textit{Figure \ref{figure:nbcomp}}
plots the comparison of Sockets to XTI over Socket and XTI approaches.  STREAMS demonstrates
significant improvements all message sizes.

The more dramatic improvements over Linux NET4 UDP and XTI over Sockets UDP is likely due in part to
the restriction on buffer sizes in 2.6 on slower processors as described above.

Unfortunately, this SuSE 10.0 OSS system does not appear to have acted as a very good control
system.  The differences in maximum buffer size make any differences from other tested behaviour
obvious.

\end{description}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_nb_perf}
\caption[SuSE 10.0 OSS Mspiggy Performance]{SuSE 10.0 OSS Mspiggy Performance}
\label{figure:nbperf}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_nb_delay}
\caption[SuSE 10.0 OSS Mspiggy Delay]{SuSE 10.0 OSS Mspiggy Delay}
\label{figure:nbdly}
\end{figure}

\begin{figure}[p]
\center\includegraphics[width=\columnwidth]{netperf_nb_thrput}
\caption[SuSE 10.0 OSS Mspiggy Throughput]{SuSE 10.0 OSS Mspiggy Throughput}
\label{figure:nbthrput}
\end{figure}

\begin{figure}[pt]
\center\includegraphics[width=\columnwidth]{netperf_nb_comp}
\caption[SuSE 10.0 OSS Mspiggy Comparison]{SuSE 10.0 OSS Mspiggy Comparison}
\label{figure:nbcomp}
\end{figure}

\section[Analysis]{Analysis}

With some caveats as described at the end of this section, the results are consistent enough across
the various distributions and machines tested to draw some conclusions regarding the efficiency of
the implementations tested.  This section is responsible for providing an analysis of the results
and drawing conclusions consistent with the experimental results.

\subsection[Discussion]{Discussion}

The test results reveal that the maximum throughput performance, as tested by the \texttt{netperf}
program, of the STREAMS implementation of UDP is superior to that of the Linux NET4 Sockets
implementation of UDP.  In fact, STREAMS implementation performance at smaller message sizes is
significantly (as much as 30-40\%) greater than that of Linux NET4 UDP.  As the common belief is
that STREAMS would exhibit poorer performance, this is perhaps a startling result to some.

Looking at both implementations, the differences can be described by implementation similarities and
differences:

\paragraph*{Send processing.}

When Linux NET4 UDP receives a send request, the available send buffer space is checked.  If the
current data would cause the send buffer fill to exceed the send buffer maximum, either the calling
process blocks awaiting available buffer, or the system call returns with an error
(\texttt{ENOBUFS}).  If the current send request will fit into the send buffer, a socket buffer
(\texttt{skbuff}) is allocated, data is copied from user space to the buffer, and the socket buffer
is dispatched to the IP layer for transmission.

Linux 2.6 kernels have an amazing amount of special case code that gets executed for even a simple
UDP send operation.  Linux 2.4 kernels are far more direct.  The result is the same, even though they
are different in the depths to which they must delve before discovering that a send is just a simple
send.  This might explain part of the rather striking differences between the performance comparison
between STREAMS and NET4 on 2.6 and 2.4 kernels.

When the STREAMS Stream head receives a putmsg(2) request, it checks downstream flow control.  If
the Stream is flow controlled downstream, either the calling process blocks awaiting succession of
flow control, or the putmsg(2) system call returns with an error (\texttt{EAGAIN}).  if the Stream
is not flow controlled on the write side, message blocks are allocated to hold the control and data
portions of the request and the message blocks are passed downstream to the driver.  When the driver
receives an \texttt{M\_DATA} or \texttt{M\_PROTO} message block from the Stream head, in its put
procedure, it simply queues it to the driver write queue with putq(9).  putq(9) will result in the
enabling of the service procedure for the driver write queue under the proper circumstances.  When
the service procedure runs, messages will be dequeued from the driver write queue transformed into
IP datagrams and sent to the IP layer for transmission on the network interface.

\textsl{Linux Fast-STREAMS} has a feature whereby the driver can request that the Stream head
allocate a Linux socket buffer (\texttt{skbuff}) to hold the data buffer associated with an
allocated message block.  The STREAMS UDP driver utilizes this feature (but the STREAMS XTIoS UDP
driver cannot).  STREAMS also has the feature that a write offset can be applied to all data block
allocated and passed downstream.  The STREAMS UDP driver uses this capability also.  The write
offset set by the tested driver was a maximum hard header length.

\paragraph*{Network processing.}

Network processing (that is the bottom end under the transport protocol) for both implementations is
effectively the same, with only minor differences.  In the STREAMS UDP implementation, no
\texttt{sock} structure exists, so issuing socket buffers to the network layer is performed in a
slightly more direct fashion.

Loop-back processing is identical as this is performed by the Linux NET4 IP layer in both cases.

For Linux Sockets UDP, when the IP layer frees or orphans the socket buffer, the amount of data
associated with the socket buffer is subtracted from the current send buffer fill.  If the current
buffer fill is less than 1/2 of the maximum, all processes blocked on write or blocked on poll are
are woken.

For STREAMS UDP, when the IP layer frees or orphans the socket buffer, the amount of data
associated with the socket buffer is subtracted from the current send buffer fill.  If the current
send buffer fill is less than the send buffer low water mark (\texttt{SO\_SNDLOWAT} or
\texttt{XTI\_SNDLOWAT}), and the write queue is blocked on flow control, the write queue is enabled.

One disadvantage that it is expected would slow STREAMS UDP performance is the fact that on the
sending side, a STREAMS buffer is allocated along with a \texttt{skbuff} and the \texttt{skbuff} is
passed to Linux NET4 IP and the loop-back device.  For Linux Sockets UDP, the same \texttt{skbuff}
is reused on both sides of the interface.  For STREAMS UDP, there is (currently) no mechanism for
passing through the original STREAMS message block and a new message block must be allocated.  This
results in two message block allocations per \texttt{skbuff}.

\paragraph*{Receive processing.}

Under Linux Sockets UDP, when a socket buffer is received from the network layer, a check is
performed whether the associated socket is locked by a user process or not.  If the associated
socket is locked, the socket buffer is placed on a backlog queue awaiting later processing by the
user process when it goes to release the lock.  A maximum number of socket buffers are permitted to
be queued against the backlog queue per socket (approx. 300).

If the socket is not locked, or if the user process is processing a backlog before releasing the
lock, the message is processed: the receive socket buffer is checked and if the received message
would cause the buffer to exceed its maximum size, the message is discarded and the socket buffer
freed.  If the received message fits into the buffer, its size is added to the current send buffer
fill and the message is queued on the socket receive queue.  If a process is sleeping on read or in
poll, an immediate wakeup is generated.

In the STREAMS UDP implementation on the receive side, again there is no \texttt{sock} structure,
so the socket locking and backlog techniques performed by UDP at the lower layer do not apply.
When the STREAMS UDP implementation receives a socket buffer from the network layer, it tests the
receive side of the Stream for flow control and, when not flow controlled, allocates a STREAMS
buffer using esballoc(9) and passes the buffer directly to the upstream queue using putnext(9).
When flow control is in effect and the read queue of the driver is not full, a STREAMS message block
is still allocated and placed on the driver read queue.  When the driver read queue is full, the
received socket buffer is freed and the contents discarded.  While different in mechanism from the
socket buffer and backlog approach taken by Linux Sockets UDP, this bottom end receive mechanism is
similar in both complexity and behaviour.

\paragraph*{Buffering.}

For Linux Sockets, when a send side socket buffer is allocated, the true size of the socket buffer
is added to the current send buffer fill.  After the socket buffer has been passed to the IP layer,
and the IP layer consumes (frees or orphans) the socket buffer, the true size of the socket buffer
is subtracted from the current send buffer fill.  When the resulting fill is less than 1/2 the send
buffer maximum, sending processes blocked on send or poll are woken up.  When a send will not fit
within the maximum send buffer size considering the size of the transmission and the current send
buffer fill, the calling process blocks or is returned an error (\texttt{ENOBUFS}).  Processes that
are blocked or subsequently block on poll(2) will not be woken up until the send buffer fill drops
beneath 1/2 of the maximum; however, any process that subsequently attempts to send and has data
that will fit in the buffer will be permitted to proceed.

STREAMS networking, on the other hand, performs queueing, flow control and scheduling on both the
sender and the receiver.  Sent messages are queued before delivery to the IP subsystem.  Received
messages from the IP subsystem are queued before delivery to the receiver.  Both side implement full
hysteresis high and low water marks.  Queues are deemed full when they reach the \textit{high water
mark} and do not enable feeding processes or subsystems until the queue subsides to the \textit{low
water mark}.

\paragraph*{Scheduling.}

Linux Sockets schedule by waking a receiving process whenever data is available in the receive
buffer to be read, and waking a sending process whenever there is one-half of the send buffer
available to be written.  While accomplishing buffering on the receive side, full hysteresis flow
control is only performed on the sending side.  Due to the way that Linux handles the loop-back
interface, the full hysteresis flow control on the sending side is defeated.

STREAMS networking, on the other hand, uses the queueing, flow control and scheduling mechanism of
STREAMS.  When messages are delivered from the IP layer to the receiving \textit{stream head} and a
receiving process is sleeping, the service procedure for the reading \textit{stream head}'s read
queue is scheduled for later execution.  When the STREAMS scheduler later runs, the receiving
process is awoken.  When messages are sent on the sending side they are queued in the driver's write
queue and the service procedure for the driver's write queue is scheduled for later execution.  When
the STREAMS scheduler later runs, the messages are delivered to the IP layer.  When sending
processes are blocked on a full driver write queue, and the count drops to the \textit{low water
mark} defined for the queue, the service procedure of the sending \textit{stream head} is scheduled
for later execution.  When the STREAMS scheduler later runs, the sending process is awoken.

\textsl{Linux Fast-STREAMS} is designed to run tasks queued to the STREAMS scheduler on the same
processor as the queueing processor or task.  This avoid unnecessary context switches.

The STREAMS networking approach results in fewer blocking and wakeup events being generated on both
the sending and receiving side.  Because there are fewer blocking and wakeup events, there are fewer
context switches.  The receiving process is permitted to consume more messages before the sending
process is awoken; and the sending process is permitted to generate more messages before the reading
process is awoken.

\paragraph*{Result}

The result of the differences between the Linux NET and the STREAMS approach is that better flow
control is being exerted on the sending side because of intermediate queueing toward the IP layer.
This intermediate queueing on the sending side, not present in BSD-style networking, is in fact
responsible for reducing the number of blocking and wakeup events on the sender, and permits the
sender, when running, to send more messages in a quantum.

On the receiving side, the STREAMS queueing, flow control and scheduling mechanisms are similar to
the BSD-style software interrupt approach.  However, Linux does not use software interrupts on
loop-back (messages are passed directly to the socket with possible backlogging due to locking).
The STREAMS approach is more sophisticated as it performs backlogging, queueing and flow control
simultaneously on the read side (at the \textit{stream head}).

\subsection[Caveats]{Caveats}

The following limitations in the test results and analysis must be considered:

\subsubsection[Loop-back Interface]{Loop-back Interface}

Tests compare performance on loop-back interface only.  Several characteristics of the loop-back
interface make it somewhat different from regular network interfaces:

\begin{enumerate}

\item Loop-back interfaces do not require checksums.

\item Loop-back interfaces have a null hard header.

This means that there is less difference between putting each data chunk in a single packet versus
putting multiple data chunks in a packet.

\item Loop-back interfaces have negligible queueing and emission times, making RTT times negligible.

\item Loop-back interfaces do not normally drop packets.

\item Loop-back interfaces preserve the socket buffer from sending to receiving interface.

This also provides an advantage to Sockets TCP.  Because STREAMS SCTP cannot pass a message block
along with the socket buffer (socket buffers are orphaned before passing to the loop-back
interface), a message block must also be allocated on the receiving side.

\end{enumerate}

%\subsubsection[Effective Bandwidth]{Effective Bandwidth}

\section[Conclusions]{Conclusions}

These experiments have shown that the \textsl{Linux Fast-STREAMS} implementation of STREAMS UDP
as well as STREAMS UDP using XTIoS networking outperforms the Linux Sockets UDP implementation by a
significant amount (up to 40\% improvement).

\begin{quote}
\textit{The \textsl{Linux Fast-STREAMS} implementation of STREAMS UDP networking is
superior by a significant factor across all systems and kernels tested.}
\end{quote}

All of the conventional wisdom with regard to STREAMS and STREAMS networking is undermined by these
test results for \textsl{Linux Fast-STREAMS}.

\begin{itemize}

\item \textit{STREAMS is fast.}

Contrary to the preconception that STREAMS must be slower because it is more general purpose, in
fact the reverse has been shown to be true in these experiments for \textsl{Linux Fast-STREAMS}.
The STREAMS flow control and scheduling mechanisms serve to adapt well and increase both code and
data cache as well as scheduler efficiency.

\item \textit{STREAMS is more flexible {\em and} more efficient.}

Contrary to the preconception that STREAMS trades flexibility or general purpose architecture for
efficiency (that is, that STREAMS is somehow less efficient because it is more flexible and general
purpose), in fact has shown to be untrue.  \textsl{Linux Fast-STREAMS} is {\em both} more flexible
{\em and} more efficient.  Indeed, the performance gains achieved by  STREAMS appear to derive from
its more sophisticated queueing, scheduling and flow control model.

\item \textit{STREAMS better exploits parallelisms on SMP better than other approaches.}

Contrary to the preconception that STREAMS must be slower due to complex locking and synchronization
mechanisms, \textsl{Linux Fast-STREAMS} performed better on SMP (hyperthreaded) machines than on UP
machines and outperformed Linux Sockets UDP by and even more significant factor (about 40\%
improvement at most message sizes).  Indeed, STREAMS appears to be able to exploit inherent
parallelisms that Linux Sockets is unable to exploit.

\item \textit{STREAMS networking is fast.}

Contrary to the preconception that STREAMS networking must be slower because STREAMS is more general
purpose and has a rich set of features, the reverse has been shown in these experiments for
\textsl{Linux Fast-STREAMS}.  By utilizing STREAMS queueing, flow control and scheduling, STREAMS
UDP indeed performs better than Linux Sockets UDP.

\item \textit{STREAMS networking is neither unnecessarily complex nor cumbersome.}

Contrary to the preconception that STREAMS networking must be poorer because of use of a complex yet
general purpose framework has shown to be untrue in these experiments for \textsl{Linux
Fast-STREAMS}.  Also, the fact that STREAMS and Linux conform to the same standard (POSIX), means
that they are no more cumbersome from a programming perspective.  Indeed a POSIX conforming
application will not known the difference between the implementation (with the exception that
superior performance will be experienced on STREAMS networking).

\end{itemize}

\section[Future Work]{Future Work}

\subsection*{Local Transport Loop-back}

UNIX domain sockets are the advocated primary interprocess communications mechanism in the 4.4BSD
system: 4.4BSD even implements pipes using UNIX domain sockets \cite[]{bsd}.  Linux also implements
UNIX domain sockets, but uses the 4.1BSD/SVR3 legacy approach to pipes.  XTI has an equivalent to
the UNIX domain socket.  This consists of connectionless, connection oriented, and connection
oriented with orderly release loop-back transport providers.  The \texttt{netperf} program has the
ability to test UNIX domain sockets, but does not currently have the ability to test the XTI
equivalents.

BSD claims that in 4.4BSD pipes were implemented using sockets (UNIX domain sockets) instead of
using the file system as they were in 4.1BSD \cite[]{bsd}.  One of the reasons cited for
implementing pipes on Sockets and UNIX domain sockets using the networking subsystems was
performance.  Another paper released by the \textsl{OpenSS7 Project} \cite[]{openss7} shows that
experimental results on Linux file-system based pipes (using the SVR3 or 4.1BSD approaches) perform
poorly when compared to STREAMS-based pipes.  Because Linux uses a similar approach to file-system
based pipes in implementation of UNIX domain sockets, it can be expected that UNIX domain sockets
under Linux will also perform poorly when compared to loop-back transport providers under STREAMS.

\subsection*{Sockets interface to STREAMS}

There are several mechanisms to providing BSD/POSIX Sockets interfaces to STREAMS networking
\cite[]{impbsd} \cite[]{socklib}.  The experiments in this report indicate that it could be
worthwhile to complete one of these implementations for \textsl{Linux Fast-STREAMS} \cite[]{strsock}
and test whether STREAMS networking using the Sockets interface is also superior to Linux Sockets,
just as it has been shown to be with the XTI/TPI interface.

\section[Related Work]{Related Work}

A separate paper comparing the STREAMS-based pipe implementation of \textsl{Linux Fast-STREAMS} to
the legacy 4.1BSD/SVR3-style Linux pipe implementation has also been prepared.  That paper also
shows significant performance improvements for STREAMS attributable to similar causes.

A separate paper comparing a STREAMS-based SCTP implementation of \textsl{Linux Fast-STREAMS} to the
Linux NET4 Sockets approach has also been prepared.  That paper also shows significant performance
improvements for STREAMS attributable to similar causes.

\FloatBarrier
\addcontentsline{toc}{section}{References}
\bibliography{testresults}

\clearpage
\begin{appendix}

\section[Netperf Benchmark Script]{Netperf Benchmark Script}
\label{section:script}

Following is a listing of the \texttt{netperf\_benchmark} script used to generate raw data points
for analysis:

\footnotesize
\begin{verbatim}
#!/bin/bash
set -x
(
  sudo killall netserver
  sudo netserver >/dev/null </dev/null 2>/dev/null &
  sleep 3
  netperf_udp_range -x /dev/udp2 \
    --testtime=10 --bufsizes=131071 --end=16384 ${1+"$@"}
  netperf_udp_range \
    --testtime=10 --bufsizes=131071 --end=16384 ${1+"$@"}
  netperf_udp_range -x /dev/udp \
    --testtime=10 --bufsizes=131071 --end=16384 ${1+"$@"}
  sudo killall netserver
) 2>&1 | tee `hostname`.`date -uIminutes`.log
\end{verbatim}
\normalsize

\section[Raw Data]{Raw Data}
\label{section:rawdata}

Following are the raw data points captured using the \texttt{netperf\_benchmark} script:

\textit{Table \ref{table:fc6data}} lists the raw data from the \texttt{netperf} program that was
used in preparing graphs for Fedora Core 6 (i386) on Porky.

\textit{Table \ref{table:centosdata}} lists the raw data from the \texttt{netperf} program that was
used in preparing graphs for CentOS 4 on Porky.

\textit{Table \ref{table:susedata}} lists the raw data from the \texttt{netperf} program that was
used in preparing graphs for SuSE OSS 10 on Porky.

\textit{Table \ref{table:ubuntudata}} lists the raw data from the \texttt{netperf} program that was
used in preparing graphs for Ubuntu 6.10 on Porky.

%\textit{Table \ref{table:u704data}} lists the raw data from the \texttt{netperf} program that was
%used in preparing graphs for Ubuntu 7.04 on Porky.

\textit{Table \ref{table:rh7data}} lists the raw data from the \texttt{netperf} program that was
used in preparing graphs for RedHat 7.2 on Pumbah.

\textit{Table \ref{table:smpdata}} lists the raw data from the \texttt{netperf} program that was
used in preparing graphs for Fedora Core 6 (x86\_64) HT on Daisy.

\textit{Table \ref{table:nbdata}} lists the raw data from the \texttt{netperf} program that was used
in preparing graphs for SuSE 10.0 OSS on Mspiggy.

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 714927 & 714928 & 947084 & 947085 & 740775 & 728170\\
2 & 717371 & 717372 & 934792 & 934793 & 745202 & 732710\\
4 & 713453 & 713454 & 938505 & 938506 & 750541 & 730419\\
8 & 704000 & 704001 & 935024 & 935025 & 745011 & 724798\\
16 & 697051 & 697052 & 930898 & 930899 & 746454 & 731250\\
32 & 688597 & 688598 & 931763 & 931764 & 748286 & 731657\\
64 & 686784 & 686785 & 939694 & 939695 & 740980 & 722478\\
128 & 674447 & 674448 & 930575 & 930576 & 742196 & 723733\\
256 & 657051 & 657052 & 907451 & 907452 & 740007 & 717115\\
512 & 651677 & 651678 & 902984 & 902985 & 718341 & 708200\\
1024 & 619363 & 619364 & 868516 & 868517 & 712384 & 693917\\
2048 & 559866 & 559867 & 793259 & 793260 & 684433 & 674277\\
4096 & 459220 & 459221 & 706605 & 706606 & 629194 & 612532\\
8192 & 367311 & 367312 & 627682 & 627683 & 554245 & 541436\\
16384 & 249573 & 249574 & 469472 & 469473 & 446906 & 437599\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[FC6 on Porky Raw Data]{FC6 on Porky Raw Data}
\label{table:fc6data}
\end{table}

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 849555 & 849556 & 1167336 & 1167337 & 861219 & 860982\\
2 & 845106 & 845107 & 1171086 & 1171087 & 860981 & 860257\\
4 & 848669 & 848670 & 1171198 & 1171199 & 863027 & 862307\\
8 & 828520 & 828521 & 1158247 & 1158248 & 859350 & 858899\\
16 & 835946 & 835947 & 1163405 & 1163406 & 856881 & 856418\\
32 & 837624 & 837625 & 1145328 & 1145329 & 861550 & 861133\\
64 & 824114 & 824115 & 1156624 & 1156625 & 850320 & 849599\\
128 & 811344 & 811345 & 1160676 & 1160677 & 847531 & 846980\\
256 & 813958 & 813959 & 1154616 & 1154617 & 842601 & 841396\\
512 & 804584 & 804585 & 1164623 & 1164624 & 833461 & 832452\\
1024 & 767812 & 767813 & 1118676 & 1118677 & 808018 & 806991\\
2048 & 693760 & 693761 & 1050507 & 1050508 & 766594 & 765236\\
4096 & 561885 & 561886 & 920261 & 920262 & 682312 & 681197\\
8192 & 437609 & 437610 & 678034 & 678035 & 598846 & 597855\\
16384 & 268808 & 268809 & 590358 & 590359 & 478197 & 477303\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[CentOS 4 on Porky Raw Data]{CentOS 4 on Porky Raw Data}
\label{table:centosdata}
\end{table}

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 573781 & 573782 & 713504 & 713505 & 594660 & 594467\\
2 & 567733 & 567734 & 720039 & 720040 & 587883 & 587791\\
4 & 569997 & 569998 & 729645 & 729646 & 589438 & 589229\\
8 & 567197 & 567198 & 734516 & 734517 & 589559 & 589416\\
16 & 568657 & 568658 & 686428 & 686429 & 593745 & 593600\\
32 & 571096 & 571097 & 689929 & 689930 & 594827 & 594671\\
64 & 570663 & 570664 & 705258 & 705259 & 593679 & 593128\\
128 & 567062 & 567063 & 706918 & 706919 & 592829 & 592829\\
256 & 568372 & 568373 & 716627 & 716628 & 585737 & 585338\\
512 & 565382 & 565383 & 675129 & 675130 & 581023 & 580381\\
1024 & 546251 & 546252 & 633631 & 633632 & 576955 & 576220\\
2048 & 510822 & 510823 & 627276 & 627277 & 556534 & 555734\\
4096 & 437420 & 437421 & 577926 & 577927 & 518700 & 517611\\
8192 & 353468 & 353469 & 528576 & 528577 & 458838 & 458081\\
16384 & 258953 & 258954 & 455257 & 455258 & 378575 & 377998\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[SuSE OSS 10 on Porky Raw Data]{SuSE OSS 10 on Porky Raw Data}
\label{table:susedata}
\end{table}

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 529545 & 529546 & 662574 & 662575 & 615243 & 615243\\
2 & 529833 & 529834 & 662749 & 662750 & 615219 & 615219\\
4 & 529409 & 529410 & 662601 & 662602 & 614769 & 614769\\
8 & 526374 & 526375 & 652110 & 652111 & 614941 & 614941\\
16 & 527462 & 527463 & 654046 & 654047 & 614494 & 614494\\
32 & 525083 & 525084 & 649961 & 649962 & 614532 & 614532\\
64 & 524388 & 524389 & 648902 & 648903 & 613586 & 613586\\
128 & 521954 & 521955 & 650092 & 650093 & 612867 & 612867\\
256 & 508588 & 508589 & 644845 & 644846 & 598102 & 598102\\
512 & 505348 & 505349 & 642097 & 642098 & 595758 & 595758\\
1024 & 481918 & 481919 & 623680 & 623681 & 590474 & 590474\\
2048 & 451341 & 451342 & 600956 & 600957 & 568011 & 568011\\
4096 & 390587 & 390588 & 552289 & 552290 & 529874 & 529874\\
8192 & 304485 & 304486 & 499277 & 499278 & 466069 & 466069\\
16384 & 232667 & 232668 & 405488 & 405489 & 391741 & 391741\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[Ubuntu 6.10 on Porky Raw Data]{Ubuntu 6.10 on Porky Raw Data}
\label{table:ubuntudata}
\end{table}

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 1133043 & 1133044 & 1560516 & 1560517 & 1422429 & 1422429\\
2 & 1136533 & 1136534 & 1562461 & 1562462 & 1418493 & 1418493\\
4 & 1136695 & 1136696 & 1578993 & 1578994 & 1415739 & 1415129\\
8 & 1142312 & 1142313 & 1578110 & 1578111 & 1415738 & 1415129\\
16 & 1139623 & 1139624 & 1571645 & 1571646 & 1412013 & 1411527\\
32 & 1140659 & 1140660 & 1573956 & 1573957 & 1418429 & 1418429\\
64 & 1136007 & 1136008 & 1574064 & 1574065 & 1406332 & 1406332\\
128 & 1106231 & 1106232 & 1541064 & 1541065 & 1370828 & 1370828\\
256 & 1073676 & 1073677 & 1535408 & 1535409 & 1358240 & 1357444\\
512 & 1026932 & 1026933 & 1517692 & 1517693 & 1299434 & 1299434\\
1024 & 941481 & 941482 & 1455261 & 1455262 & 1211158 & 1211158\\
2048 & 793802 & 793803 & 1351690 & 1351691 & 1073543 & 1073543\\
4096 & 610252 & 610253 & 1216734 & 1216735 & 872281 & 872281\\
8192 & 416164 & 416165 & 1033488 & 1033489 & 644953 & 644953\\
16384 & 248762 & 248763 & 780198 & 779901 & 419478 & 419478\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[RedHat 7.2 on Pumbah Raw Data]{RedHat 7.2 on Pumbah Raw Data}
\label{table:rh7data}
\end{table}

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 553383 & 553384 & 1009820 & 1009820 & 731713 & 731713\\
2 & 550020 & 550021 & 1005658 & 1005659 & 726596 & 726596\\
4 & 549600 & 549601 & 993347 & 993348 & 733634 & 733634\\
8 & 549073 & 549074 & 1000195 & 1000196 & 724320 & 724320\\
16 & 549514 & 549515 & 1000525 & 1000526 & 725440 & 725440\\
32 & 548447 & 548447 & 1007185 & 1007186 & 728707 & 728707\\
64 & 545329 & 545330 & 994739 & 994740 & 720612 & 720612\\
128 & 540519 & 540520 & 999002 & 999003 & 722801 & 722801\\
256 & 521171 & 521172 & 994474 & 994475 & 723606 & 723606\\
512 & 508589 & 508590 & 982028 & 982029 & 709207 & 709207\\
1024 & 483899 & 483900 & 951564 & 951565 & 707136 & 707136\\
2048 & 446004 & 446005 & 897395 & 897396 & 688775 & 688775\\
4096 & 387509 & 387510 & 795327 & 795328 & 650128 & 650128\\
8192 & 302141 & 302142 & 677573 & 677573 & 605011 & 605011\\
16384 & 211149 & 211150 & 505129 & 505130 & 503729 & 503729\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[Fedora Core 6 (x86\_64) HT on Daisy Raw Data]{Fedora Core 6 (x86\_64) HT on Daisy Raw Data}
\label{table:smpdata}
\end{table}

\begin{table}[hbp]
\footnotesize
\begin{center}
\setlength{\tabcolsep}{0.2em}
\setlength{\arraycolsep}{0.2em}
\begin{tabular}{rrrrrrr}\\
Message & \multicolumn{2}{c}{XTIoS} & \multicolumn{2}{c}{XTI} & \multicolumn{2}{c}{Sockets}\\
Size & Tx & Rx & Tx & Rx & Tx & Rx\\
\hline
\hline
1 & 479564 & 479565 & 591461 & 591462 & 482975 & 481652\\
2 & 480678 & 480679 & 592805 & 592806 & 481606 & 480276\\
4 & 478366 & 478367 & 593255 & 593256 & 480746 & 479680\\
8 & 473615 & 473616 & 589930 & 589931 & 479021 & 477301\\
16 & 471973 & 471974 & 585814 & 585815 & 478449 & 476241\\
32 & 474980 & 474981 & 585272 & 585273 & 480508 & 478812\\
64 & 466618 & 466619 & 587244 & 587245 & 474745 & 472577\\
128 & 465623 & 465624 & 582449 & 582450 & 472031 & 470381\\
256 & 458158 & 458159 & 587534 & 587534 & 466018 & 463747\\
512 & 446356 & 446357 & 586409 & 586410 & 450769 & 448312\\
1024 & 421072 & 421073 & 567213 & 567214 & 435038 & 433157\\
2048 & 368990 & 368991 & 543818 & 543819 & 397745 & 395329\\
4096 & 290402 & 290403 & 500380 & 500381 & 344058 & 341942\\
8192 & 218918 & 218919 & 438956 & 438957 & 265907 & 264098\\
16384 & 137005 & 137006 & 348956 & 348957 & 192224 & 191737\\
\hline
\end{tabular}
\end{center}
\normalsize
\caption[SuSE 10.0 OSS on Mspiggy Raw Data]{SuSE 10.0 OSS on Mspiggy Raw Data}
\label{table:nbdata}
\end{table}

\end{appendix}

\end{document}
