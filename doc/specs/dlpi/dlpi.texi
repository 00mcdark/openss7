% -*- texinfo -*- vim: ft=texinfo
% vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
% =========================================================================
%
% @(#) $Id: dlpi.texi,v 1.1.2.1 2009-06-21 10:53:25 brian Exp $
%
% =========================================================================
%
% Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
% Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
% Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.3 or
% any later version published by the Free Software Foundation; with no
% Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
% copy of the license is included in the section entitled "GNU Free
% Documentation License".
%
% Permission to use, copy and distribute this documentation without
% modification, for any purpose and without fee or royalty is hereby
% granted, provided that both the above copyright notice and this
% permission notice appears in all copies and that the name of OpenSS7
% Corporation not be used in advertising or publicity pertaining to
% distribution of this documentation or its contents without specific,
% written prior permission.  OpenSS7 Corporation makes no representation
% about the suitability of this documentation for any purpose.  It is
% provided "as is" without express or implied warranty.
% 
% Permission is granted to process this file through Tex and print the
% results, provided the printed document carries copying permission
% notice identical to this one except for the removal of this paragraph
% (this paragraph not being relevant to the printed manual).
% 
% OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
% DOCUMENTATION INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE
% CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE
% IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY
% PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN NO EVENT SHALL
% OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
% CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
% USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
% THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS
% THEREOF.
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2009-06-21 10:53:25 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename dlpi.info
@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE Data Link Provider Interface
@set MANUAL_TYPE Specification
@settitle @value{MANUAL_TITLE}

@dircategory OpenGroup
@direntry
* DLPI: (dlpi).                 Data Link Provider Interface Specification
@end direntry

@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE Data Link Provider Interface
@set MANUAL_TYPE Specification

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file documents the X/Open Data Link Provider Interface.

This is Edition @value{PACKAGE_VERSION}, last updated @value{PACKAGE_DATE}, for
@value{PACKAGE_TITLE} version @value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
published by @uref{http://www.openss7.com/,OpenSS7 Corporation}.
This specification was originally published by UNIX International OSI Work Group
in Revision: 2.0.0 (1991/08/20).

Copyright @copyright{} 2008-2009  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2001  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
Copyright @copyright{} 1991       UNIX International, Inc.

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this manual provided the copyright
notice and this permission notice are preserved on all copies.

@ignore
Permission is granted to process this file through Tex and print the results, provided the printed
document carries copying permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
Permission to use, copy, modify, and distribute this documentation for any purpose and without fee
is hereby granted, provided that the above copyright notice appears in all copies and that both that
copyright notice and this permission notice appear in supporting documentation, and that the name
UNIX International not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  UNIX International makes no representations
about the suitability of this documentation for any purpose.  It is provided ``as is'' without
express or implied warranty.

Permission is granted to copy and distribute modified versions of this manual under the conditions
for verbatim copying, provided the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual into another language,
under the above conditions for modified versions.
@end ifinfo

@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE Data Link Provider Interface
@set MANUAL_TYPE Specification

@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle UNIX International
@subtitle OSI Work Group
@subtitle Revision: 2.0.0
@subtitle August 20, 1991
@sp 0.2
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@sp 2
@subtitle Copyright @copyright{} 2008-2009  Monavacon Limited
@subtitle Copyright @copyright{} 2001-2008  OpenSS7 Corporation
@subtitle Copyright @copyright{} 1991 UNIX International, Inc.
@subtitle All Rights Reserved.
@sp 4
@quotation
@chapheading Abstract
This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7. It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.  It provides abstraction of the
data link interface to these components as well as providing a basis for data link control for other
data link protocols.
@end quotation
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll

@chapheading Published by:

@center UNIX International
@center Waterview Corporate Center
@center 20 Waterview Boulevard
@center Parsippany, NJ 07054
@sp 1
@center for further information, contact:
@center Vice President of Marketing
@sp 1
@center Phone: +1 201-263-8400
@center Fax: +1 201-263-8401
@sp 1

@ignore
@chapheading International Offices:

@multitable @columnfractions .33 .33 .34
@item

@noindent
UNIX International @*
Asian/Pacific Office @*
Shinei Bldg. 1F @*
Kameido @*
Koto-ku, Tokyo 136 @*
Japan

@noindent
Phone: (81) 3-3636-1122 @*
Fax: (81) 3-3636-1121

@tab

@noindent
UNIX International @*
Australian Office @*
22/74 - 76 Monarch St. @*
Cremorne, NSW 2090 @*
Australia

@noindent
Phone: (61) 2-953-7838 @*
Fax: (61) 2 953-3542

@tab

@noindent
UNIX International @*
Pacific Basin Office @*
Cintech II @*
75 Science Park Drive @*
Singapore Science Park @*
Singapore 0511 @*
Singapore

@noindent
Phone: (32) 2-672-3700 @*
Fax: (32) 2-672-4415

@end multitable

@multitable @columnfractions .5 .5
@item

@noindent
UNIX International @*
European Office @*
25, Avenue de Beaulieu @*
1160 Brussels @*
Belgium

@noindent
Phone: (65) 776-0313 @*
Fax: (65) 776-0421

@tab

@noindent
@ 

@end multitable
@end ignore

@noindent
Copyright @copyright{} 2008-2009  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2001  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
Copyright @copyright{} 1991       UNIX International, Inc. @*

@noindent
All Rights Reserved.

@noindent
Permission is granted to make and distribute verbatim copies of this manual provided the copyright
notice and this permission notice are preserved on all copies.

@noindent
Permission to use, copy, modify, and distribute this documentation for any purpose and without fee
is hereby granted, provided that the above copyright notice appears in all copies and that both that
copyright notice and this permission notice appear in supporting documentation, and that the name
UNIX International not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  UNIX International makes no representations
about the suitability of this documentation for any purpose.  It is provided ``as is'' without
express or implied warranty.

@noindent
@b{UNIX INTERNATIONAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS DOCUMENTATION, INCLUDING ALL
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL UNIX INTERNATIONAL BE LIABLE
FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS DOCUMENTATION.}

@chapheading Notice:

@noindent
This document is based on the UNIX System Laboratories Data Link Provider Interface (DLPI)
specification which was used with permission by the UNIX International OSI Work Group (UI OSIWG).
Participation in the UI OSIWG is open to UNIX International members and other interested parties.
For further information contact UNIX International at the addresses above.

@noindent
UNIX International is making this documentation available as a reference point for the industry.
While UNIX International believes that these interfaces are well defined in this release of the
document, minor changes may be made prior to products conforming to the interfaces being made
available from UNIX System Laboratories or UNIX International members.

@chapheading Trademarks:

@noindent
UNIX@registeredsymbol{} is a registered trademark of UNIX System Laboratories in
the United States and other countries.
X/Open(TM) is a trademark of the X/Open Company Ltd. in the UK and other
countries.
OpenSS7(TM) is a trademark of OpenSS7 Corporation in the United States and other
countries.

@page
@vskip 0pt plus 1filll

@chapheading Published by:

@sp 1

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Copyright @copyright{} 2008-2009  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
All Rights Reserved.

@noindent
Unauthorized distribution or duplication is prohibited.

@sp 1

@ignore
@noindent
This software and related documentation is protected by copyright and distributed under licenses
restricting its use, copying, distribution and decompilation.  No part of this software or related
documentation may be reproduced in any form by any means without the prior written authorization of
the copyright holder, and licensors, if any.

@noindent
The recipient of this document, by its retention and use, warrants that the recipient will protect
this information and keep it confidential, and will not disclose the information contained in this
document without the written permission of its owner.

@noindent
Monavacon Limited and OpenSS7 Corporation reserve the right to revise this software and
documentation for any reason, including but not limited to, conformity with standards promulgated by
various agencies, utilization of advances in the state of the technical arts, or the reflection of
changes in the design of any techniques, or procedures embodied, described, or referred to herein.
Monavacon Limited and OpenSS7 Corporation are under no obligation to provide any feature listed
herein.
@end ignore

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of Monavacon Limited and OpenSS7
Corporation not be used in advertising or publicity pertaining to distribution of this documentation
or its contents without specific, written prior permission.  Monavacon Limited and OpenSS7
Corporation make no representation about the suitability of this documentation for any purpose.  It
is provided ``as is'' without express or implied warranty.

@chapheading Notice:

@noindent
@b{Monavacon Limited and OpenSS7 Corporation disclaim all warranties with regard to this
documentation including all implied warranties of merchantability, fitness for a particular purpose,
non-infringement, or title; that the contents of the document are suitable for any purpose, or that
the implementation of such contents will not infringe on any third party patents, copyrights,
trademarks or other rights.  In no event shall Monavacon Limited or OpenSS7 Corporation be liable
for any direct, indirect, special or consequential damages or any damages whatsoever resulting from
loss of use, data or profits, whether in an action of contract, negligence or other tortious action,
arising out of or in connection with any use of this document or the performance or implementation
of the contents thereof.}

@sp 1

@noindent
Monavacon Limited and OpenSS7 Corporation reserve the right to revise this software and
documentation for any reason, including but not limited to, conformity with standards promulgated by
various agencies, utilization of advances in the state of the technical arts, or the reflection of
changes in the design of any techniques, or procedures embodied, described, or referred to herein.
Monavacon Limited and OpenSS7 Corporation are under no obligation to provide any feature listed
herein.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defcodeindex pr
@c Define an index of primitive values
@defcodeindex pv
@c Define an index of primitive error values
@defcodeindex pe
@c Define an index of protocol states
@defcodeindex st
@c Define an index of input-output controls
@defcodeindex ct
@c Define an index of manual pages.
@defcodeindex mp
@c Define an index of MIB objects.
@defcodeindex mo

@c frags out automake
@c @ifnottex
@c @c concatenate indices for text, html and info
@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex pe cp
@syncodeindex st cp
@syncodeindex mp cp
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex ct cp
@syncodeindex mo cp
@c @end ifnottex

@include texi/macros.texi
@include texi/versions.texi
@include texi/prims.texi

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@heading About This Manual
This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of
@cite{The @value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version
@value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} of the
@value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Introduction::
* Model of the Data Link Layer::
* DLPI Services::
* DLPI Primitives::
* Quality of Data Link Service::
* Optional Primitives to perform Essential Management Functions::
* Allowable Sequence of DLPI Primitives::
* Precedence of DLPI Primitives::
* Glossary of DLPI Terms and Acronyms::
* Guidelines for Protocol Independent DLS Users::
* Required Information for DLS Provider-Specific Addenda::
* DLPI Header File::
* References::
* Index::
@end menu

@iftex
@c insert list of figures and tables for printed manuals
@page
@heading List of Figures
@listoffloats Figure
@page
@heading List of Tables
@listoffloats Table
@end iftex

@node Introduction
@chapter Introduction

This document specifies a @acronym{STREAMS} kernel-level instantiation of the ISO
Data Link Service Definition DIS 8886@footnote{International Organization for
Standardization, "Data Link Service Definition for Open Systems
Interconnection," DIS 8886, February 1987.} and Logical Link Control DIS 8802/2
(LLC)@footnote{ International Organization for Standardization, "Logical Link
Control," DIS 8802/2, 1985.}.  Where the two standards do not conform, DIS 8886
prevails.

The @cite{Data Link Provider Interface (@acronym{DLPI})} enables a data link service user to
access and use any of a variety of conforming data link service providers
without special knowledge of the provider's protocol.  Specifically, the
interface is intended to support X.25 LAPB, BX.25 level 2, SDLC, ISDN LAPD,
Ethernet(TM), CSMA/CD, FDDI, token ring, token bus, and Bisync.  Among the
expected data link service users are implementations of the OSI network layer
and SNA path control.

The interface specifies access to data link service providers, and does not
define a specific protocol implementation.  Thus, issues of network management,
protocol performance, and performance analysis tools are beyond the scope of
this document and should be addressed by specific implementations of a data link
provider.  However, accompanying each provider implementation should be
information that describes the protocol-specific behavior of that provider.
Currently, there are plans to come up with a set of implementor's
agreements/guidelines for common data link providers.  These agreements will
address issues such as @acronym{DLSAP} address space, subsequent addresses,
@acronym{PPA} access and control, @acronym{QoS}, supported services, etc.

This specification assumes the reader is familiar with OSI Reference Model[4]
terminology, OSI Data Link Services, and @acronym{STREAMS}.

@section Document Organization

This specification is organized as follows:

@itemize @bullet

@item @ref{Model of the Data Link Layer},
presents background on the structure of the data link layer of the OSI Reference
Model, and explains the intended architecture in the @acronym{STREAMS} environment.
Data link addressing concepts are also presented.

@item @ref{DLPI Services},
presents an overview of the services provided by @acronym{DLPI}.

@item @ref{DLPI Primitives},
describes the detailed syntax and semantics of each @acronym{DLPI} primitive that crosses
the data link interface.

@item @ref{Quality of Data Link Service},
describes the quality-of-service parameters supported by @acronym{DLPI} and the rules for
negotiating/selecting the values of those parameters.

@item @ref{Optional Primitives to perform Essential Management Functions},
optional primitives to perform certain essential management functions.

@item @ref{Allowable Sequence of DLPI Primitives},
describes the allowable sequence of @acronym{DLPI} primitives that may be issued across
the interface.

@item @ref{Precedence of DLPI Primitives},
presents a summary of the precedence of @acronym{DLPI} primitives as they are queued by the
DLS provider and/or DLS user.

@item @ref{Glossary of DLPI Terms and Acronyms},
presents a Glossary of @acronym{DLPI} Terms and Acronyms.

@item @ref{Guidelines for Protocol Independent DLS Users},
summarizes guidelines a DLS user implementation must follow to be fully
protocol-independent.

@item @ref{Required Information for DLS Provider-Specific Addenda},
presents the information that should be documented for each DLS provider
implementation.

@item @ref{DLPI Header File},
presents the header file containing @acronym{DLPI} structure and constant definitions
needed by a DLS user or provider implemented to use the interface.

@end itemize

@node Model of the Data Link Layer
@chapter Model of the Data Link Layer

@menu
* Model of the Service Interface::
* Modes of Communication::
* DLPI Addressing::
* The Connection Management Stream::
@end menu

The data link layer (layer 2 in the OSI Reference Model) is responsible for the
transmission and error-free delivery of bits of information over a physical
communications medium.

The model of the data link layer is presented here to describe concepts that are
used throughout the specification of @acronym{DLPI}.  It is described in terms of an
interface architecture, as well as addressing concepts needed to identify
different components of that architecture.  The description of the model
assumes familiarity with the OSI Reference Model.

@node Model of the Service Interface
@section Model of the Service Interface

Each layer of the OSI Reference Model has two standards:

@itemize @bullet
@item one that defines the services provided by the layer, and
@item one that defines the protocol through which layer services are provided.
@end itemize

@acronym{DLPI} is an implementation of the first type of standard.  It specifies an
interface to the services of the data link layer.  The following figure depicts
the abstract view of @acronym{DLPI}.

@figuresized{dlpi_fig1,1,Abstract View of DLPI,4in}

The data link interface is the boundary between the network and data link layers
of the OSI Reference Model.  The network layer entity is the user of the services
of the data link interface (DLS user), and the data link layer entity is the
provider of those services (DLS provider).  This interface consists of a set
of primitives that provide access to the data link layer services, plus the rules
for using those primitives (state transition rules).  A data link interface
service primitive might request a particular service or indicate a pending event.

To provide uniformity among the various UNIX system networking products, an
effort is underway to develop service interfaces that map to the OSI Reference
Model.  A set of kernel-level interfaces, based on the @acronym{STREAMS}
development environment, constitute a major portion of this effort.  The service
primitives that make up these interfaces are defined as @acronym{STREAMS} messages
that are transferred between the user and provider of the service.
@acronym{DLPI} is one
such kernel-level interface, and is targeted for @acronym{STREAMS} protocol modules
that either use or provide data link services.  In addition, user programs that
wish to access a @acronym{STREAMS}-based data link provider directly may do so
using the putmsg(2) and getmsg(2) system calls.

Referring to the abstract view of @acronym{DLPI} (@figref{1}), the DLS provider is
configured as a @acronym{STREAMS} driver, and the DLS user accesses the provider
using open(2) to establish a stream to the DLS provider.  The stream acts as a
@cpindex Communication endpoint
communication endpoint between a DLS user and the DLS provider.  After the
stream is created, the DLS user and DLS provider communicate via the messages
presented later in this specification.

@acronym{DLPI} is intended to free data link users from specific knowledge of the
characteristics of the data link provider.  Specifically, the definition of
@acronym{DLPI}
hopes to achieve the goal of allowing a DLS user to be implemented independent
of a specific communications medium.  Any data link provider (supporting any
communications medium) that conforms to the @acronym{DLPI} specification may be
substituted beneath the DLS user to provide the data link services.  Support of
a new DLS provider should not require any changes to the implementation of the
DLS user.

@node Modes of Communication
@section Modes of Communication

@menu
* Connection-mode Service (1)::
* Connectionless-mode Service::
* Acknowledged Connectionless-mode Service::
@end menu

@cpindex Connectionless mode
The data link provider interface supports three modes of communication:
connection, connectionless and acknowledged connectionless.  The connection mode
@cpindex Connection mode
is circuit-oriented and enables data to be transferred over a pre-established
connection in a sequenced manner.  Data may be lost or corrupted in this service
mode, however, due to provider-initiated resynchronization or connection aborts.

@cpindex Connectionless mode
The connectionless mode is message-oriented and supports data transfer in
self-contained units with no logical relationship required between units.
Because there is no acknowledgment of each data unit transmission, this service
mode can be unreliable in the most general case.  However, a specific DLS
provider can provide assurance that messages will not be lost, duplicated, or
reordered.

@cpindex Connectionless mode
The acknowledged connectionless mode provides the means by which a data link
user can send data and request the return of data at the same time.  Although
the exchange service is connectionless, in-sequence delivery is guaranteed for
data sent by the initiating station.  The data unit transfer is point-to-point.

@node Connection-mode Service (1)
@subsection Connection-mode Service
@cpindex Connection mode
The connection-mode service is characterized by four phases of communication:
@cpindex Connection establishment
local management, connection establishment, data transfer, and connection
release.

@subsubsection Local Management
This phase enables a DLS user to initialize a stream for use in communication
and establish an identity with the DLS provider.

@subsubsection Connection Establishment
@cpindex Called DLS user
@cpindex Calling DLS user
@cpindex Connection establishment
This phase enables two DLS users to establish a data link connection between
them to exchange data.  One user (the calling DLS user) initiates the connection
@cpindex Connection establishment
establishment procedures, while another user (the called DLS user) waits for
incoming connect requests.  The called DLS user is identified by an address
associated with its stream (as will be discussed shortly).

A called DLS user may either accept or deny a request for a data link
connection.  If the request is accepted, a connection is established between the
DLS users and they enter the data transfer phase.  For both the calling and
called DLS users, only one connection may be established per stream.  Thus, the
@cpindex Communication endpoint
stream is the communication endpoint for a data link connection.  The called DLS
user may choose to accept a connection on the stream where it received the
connect request, or it may open a new stream to the DLS provider and accept the
connection on this new, responding stream.  By accepting the connection on a
separate stream, the initial stream can be designated as a listening stream
through which all connect requests will be processed.  As each request arrives,
@cpindex Communication endpoint
a new stream (communication endpoint) can be opened to handle the connection,
enabling subsequent requests to be queued on a single stream until they can be
processed.

@subsubsection Data Transfer
In this phase, the DLS users are considered peers and may exchange data
simultaneously in both directions over an established data link connection.
Either DLS user may send data to its peer DLS user at any time.  Data sent by a
DLS user is guaranteed to be delivered to the remote user in the order in which
it was sent.

@subsubsection Connection Release
This phase enables either the DLS user, or the DLS provider, to break an
established connection.  The release procedure is considered abortive, so any
data that has not reached the destination user when the connection is released
may be discarded by the DLS provider.

@node Connectionless-mode Service
@subsection Connectionless-mode Service
@cpindex Connection establishment
@cpindex Connectionless mode
The connectionless mode service does not use the connection establishment and
@cpindex Connection mode
release phases of the connection-mode service.  The local management phase is
still required to initialize a stream.  Once initialized, however, the
connectionless data transfer phase is immediately entered.  Because there is
no established connection, however, the connectionless data transfer phase
requires the DLS user to identify the destination of each data unit to be
transferred.  The destination DLS user is identified by the address associated
with that user (as will be discussed shortly).

Connectionless data transfer does not guarantee that data units will be
delivered to the destination user in the order in which they were sent.
Furthermore, it does not guarantee that a given data unit will reach the
destination DLS user, although a given DLS provider may provide assurance that
data will not be lost.

@node Acknowledged Connectionless-mode Service
@subsection Acknowledged Connectionless-mode Service
@cpindex Connection establishment
@cpindex Connectionless mode
The acknowledged connectionless mode service also does not use the connection
@cpindex Connection mode
establishment and release phases of the connection-mode service.  The local
management phase is still required to initialize a stream.  Once initialized, the
acknowledged connectionless data transfer phase is immediately entered.

Acknowledged connectionless data transfer guarantees that data units will be
delivered to the destination user in the order in which they were sent.  A data
link user entity can send a data unit to the destination DLS User, request a
previously prepared data unit from the destination DLS User, or exchange data
units.

@node DLPI Addressing
@section DLPI Addressing

@menu
* Physical Attachment Identification::
* Data Link User Identification::
@end menu

Each user of @acronym{DLPI} must establish an identity to communicate with other data link
users.  This identity consists of two pieces.  First, the DLS user must somehow
identify the physical medium over which it will communicate.  This is
particularly evident on systems that are attached to multiple physical
media.  Second, the DLS user must register itself with the DLS provider so that
the provider can deliver protocol data units destined for that user.  The
following figure illustrates the components of this identification approach,
which are explained below.

@figuresized{dlpi_fig2,2,Data Link Addressing Components,4in}

@node Physical Attachment Identification
@subsection Physical Attachment Identification

The physical point of attachment (@acronym{PPA} in @figref{2}) is the point at
which a system attaches itself to a physical communications medium.  All
communication on that physical medium funnels through the @acronym{PPA}.  On
systems where a DLS provider supports more than one physical medium, the DLS
user must identify which medium it will communicate through.  A @acronym{PPA} is
identified by a unique @acronym{PPA} identifier .  For media that support
physical layer multiplexing of multiple channels over a single physical medium
(such as the B and D channels of ISDN), the @acronym{PPA} identifier must
identify the specific channel over which communication will occur.

Two styles of DLS provider are defined by @acronym{DLPI}, distinguished by the way they
enable a DLS user to choose a particular @acronym{PPA}.  The style 1 provider
assigns a @acronym{PPA} based on the major/minor device the DLS user opened.
One possible implementation of a style 1 driver would reserve a major device for
each @acronym{PPA} the data link driver would support.  This would allow the
@acronym{STREAMS} clone open feature to be used for each @acronym{PPA} configured.
This style of provider is appropriate when few PPAs will be supported.

If the number of PPAs a DLS provider will support is large, a style 2 provider
implementation is more suitable.  The style 2 provider requires a DLS user to
explicitly identify the desired @acronym{PPA} using a special attach service
primitive.  For a style 2 driver, the open(2) creates a stream between the DLS
user and DLS provider, and the attach primitive then associates a particular
@acronym{PPA} with that stream.  The format of the @acronym{PPA} identifier is
specific to the DLS provider, and should be described in the provider-specific
addendum documentation.

@acronym{DLPI} provides a mechanism to get and/or modify the physical address.  The
primitives to handle these functions are described in @ref{Optional Primitives
to perform Essential Management Functions}.  The physical address value can be
modified in a post-attached state.  This would modify the value for all streams
for that provider for a particular @acronym{PPA}.  The physical address cannot
be modified if even a single stream for that @acronym{PPA} is in the bound
state.

The DLS User uses the supported primitives (@prim{DL_ATTACH_REQ},
@prim{DL_BIND_REQ}, @prim{DL_ENABMULTI_REQ}, @prim{DL_PROMISCON_REQ}) to define
a set of enabled physical and SAP address components on a per Stream basis.  It
is invalid for a DLS Provider to ever send upstream a data message for which the
DLS User on that stream has not requested.  The burden is on the provider to
enforce by any means that it chooses, the isolation of SAP and physical address
space effects on a per-stream basis.

@node Data Link User Identification
@subsection Data Link User Identification

A data link user's identity is established by associating it with a data link
service access point (@acronym{DLSAP}), which is the point through which the
user will communicate with the data link provider.  A @acronym{DLSAP} is
identified by a @acronym{DLSAP} address.

The @acronym{DLSAP} address identifies a particular data link service access
point that is
@cpindex Communication endpoint
associated with a stream (communication endpoint).  A bind service primitive
enables a DLS user to either choose a specific @acronym{DLSAP} by specifying its
@acronym{DLSAP} address, or to determine the @acronym{DLSAP} associated with a
stream by retrieving the bound @acronym{DLSAP} address.  This @acronym{DLSAP}
address can then be used by other DLS users to access a specific DLS user.  The
format of the @acronym{DLSAP} address is specific to the DLS provider, and
should be described in the provider-specific addendum documentation.  However,
@acronym{DLPI} provides a mechanism for decomposing the @acronym{DLSAP} address into
component pieces.  The @prim{DL_INFO_ACK} primitive returns the length of the
SAP component of the @acronym{DLSAP} address, along with the total length of the
@acronym{DLSAP} address.

Certain DLS Providers require the capability of binding on multiple
@acronym{DLSAP} addresses.  This can be achieved through subsequent binding of
@acronym{DLSAP} addresses.  @acronym{DLPI} supports peer and hierarchical binding of
DLSAPs.  When the User requests peer addressing, the @acronym{DLSAP} specified
in a subsequent bind may be used in lieu of the @acronym{DLSAP} bound in the
@prim{DL_BIND_REQ}.  This will allow for a choice to be made between a number of
DLSAPs on a stream when determining traffic based on @acronym{DLSAP} values.  An
example of this would be to specify various ether_type values as DLSAPs.  The
@prim{DL_BIND_REQ}, for example, could be issued with ether_type value of IP,
and a subsequent bind could be issued with ether type value of ARP.  The
Provider may now multiplex off of the ether_type field and allow for either IP
or ARP traffic to be sent up this stream.

When the DLS User requests hierarchical binding, the subsequent bind will
specify a @acronym{DLSAP} that will be used in addition to the @acronym{DLSAP}
bound using a @prim{DL_BIND_REQ}.  This will allow additional information to be
specified, that will be used in a header or used for de-multiplexing.  An
example of this would be to use hierarchical bind to specify the OUI
(Organizationally Unique Identifier) to be used by SNAP.

If a DLS Provider supports peer subsequent bind operations, the first SAP that
is bound is used as the source SAP when there is ambiguity.

@acronym{DLPI} supports the ability to associate several streams with a single
@acronym{DLSAP},
@cpindex Communication endpoint
where each stream may be a unique data link connection endpoint.  However, not
all DLS providers can support such configurations because some DLS providers may
have no mechanism beyond the @acronym{DLSAP} address for distinguishing multiple
connections.  In such cases, the provider will restrict the DLS user to one
stream per @acronym{DLSAP}.

@node The Connection Management Stream
@section The Connection Management Stream

@cpindex Connection management stream
@cpindex Connection mode
The earlier description of the connection-mode service assumed that a DLS user
bound a @acronym{DLSAP} to the stream it would use to receive connect requests.
In some instances, however, it is expected that a given service may be accessed
through any one of several DLSAPs.  To handle this scenario, a separate stream
would be required for each possible destination @acronym{DLSAP}, regardless of
whether any DLS user actually requested a connection to that @acronym{DLSAP}.
Obvious resource problems can result in this scenario.

To obviate the need for tying up system resources for all possible destination
@cpindex Connection management stream DLSAPs, a "connection management stream"
utility is defined in @acronym{DLPI}.  A
@cpindex Connection management stream connection
management stream is one that receives any connect requests that are not
destined for currently bound DLSAPs capable of receiving connect indications.
With this mechanism, a special listener can handle incoming
@cpindex Connection management stream
connect requests intended for a set of DLSAPs by opening a connection management
stream to the DLS provider that will retrieve all connect requests arriving
through a particular @acronym{PPA}.  In the model, then, there may be a
connection management stream per @acronym{PPA}.

@node DLPI Services
@chapter DLPI Services

@menu
* Local Management Services::
* Connection-mode Services::
* Connectionless-mode Services::
* Acknowledged Connectionless-mode Services::
* An Example::
@end menu

The various features of the @acronym{DLPI} interface are defined in terms of the services
provided by the DLS provider, and the individual primitives that may flow
between the DLS user and DLS provider.

@cpindex Connectionless mode
The data link provider interface supports three modes of service: connection,
@cpindex Connection mode
connectionless and acknowledged connectionless.  The connection mode is
circuit-oriented and enables data to be transferred over an established
connection in a sequenced manner.  The connectionless mode is message-oriented
and supports data transfer in self-contained units with no logical relationship
required between units.  The acknowledged connectionless mode is
message-oriented and guarantees that data units will be delivered to the
destination user in the order in which they were sent.  This specification also
defines a set of local management functions that apply to all modes of service.

The XID and TEST services that are supported by @acronym{DLPI} are listed below.  The DLS
User can issue an XID or TEST request to the DLS Provider.  The Provider will
transmit an XID or TEST frame to the peer DLS Provider.  On receiving a
response, the DLS Provider sends a confirmation primitive to the DLS User.  On
receiving an XID or TEST frame from the peer DLS Provider, the local DLS
Provider sends up an XID or TEST indication primitive to the DLS User.  The User
must respond with an XID or TEST response frame to the Provider.

The services are tabulated below and described more fully in the remainder of
this section.

@tabfig{dlpi_tab1,1a,Cross-Reference of DLS Services and Primitives}
@tabfig{dlpi_tab2,1b,Cross-Reference of DLS Services and Primitives}
@tabfig{dlpi_tab3,1c,Cross-Reference of DLS Services and Primitives}

@node Local Management Services
@section Local Management Services

@menu
* Information Reporting Service::
* Attach Service::
* Bind Service::
@end menu

@cpindex Connectionless mode
The local management services apply to the connection, connectionless and
acknowledged connectionless modes of transmission.  These services, which fall
outside the scope of standards specifications, define the method for
initializing a stream that is connected to a DLS provider.  DLS provider
information reporting services are also supported by the local management
facilities.

@node Information Reporting Service
@subsection Information Reporting Service
This service provides information about the @acronym{DLPI} stream to the DLS user.  The
message
@prim{DL_INFO_REQ}
requests the DLS provider to return operating information about the stream.  The
DLS provider returns the information in a
@prim{DL_INFO_ACK}
message.

@figuresized{dlpi_fig3,3,Message Flow: Information Reporting,4in}

@node Attach Service
@subsection Attach Service
The attach service assigns a physical point of attachment (@acronym{PPA}) to a
stream.  This service is required for style 2 DLS providers (@pxref{Physical
Attachment Identification}) to specify the physical medium over which
communication will occur.  The DLS provider indicates success with a
@prim{DL_OK_ACK}; failure with a @prim{DL_ERROR_ACK}.  The normal message
sequence is illustrated in the following figure.

@figuresized{dlpi_fig4,4,Message Flow: Attaching a Stream to a Physical Line,4in}

A @acronym{PPA} may be disassociated with a stream using the
@prim{DL_DETACH_REQ}.  The normal message sequence is illustrated in the
following figure.

@figuresized{dlpi_fig5,5,Message Flow: Detaching a Stream from a Physical Line,4in}

@node Bind Service
@subsection Bind Service
The bind service associates a data link service access point (@acronym{DLSAP})
with a stream.  The @acronym{DLSAP} is identified by a @acronym{DLSAP} address.

@cpindex Connection establishment
@prim{DL_BIND_REQ} requests that the DLS provider bind a @acronym{DLSAP} to a
stream.  It also notifies the DLS provider to make the stream active with
respect to the @acronym{DLSAP} for processing
@cpindex Connectionless mode
connectionless and acknowledged connectionless data transfer and connection
establishment requests.  Protocol-specific actions taken during activation
should be described in DLS provider-specific addenda.

The DLS provider indicates success with a @prim{DL_BIND_ACK}; failure with a
@prim{DL_ERROR_ACK}.

Certain DLS providers require the capability of binding on multiple
@acronym{DLSAP} addresses.  @prim{DL_SUBS_BIND_REQ} provides that added
capability.  The DLS provider indicates success with a @prim{DL_SUBS_BIND_ACK};
failure with a @prim{DL_ERROR_ACK}.  The normal flow of messages is illustrated
in the following figure.

@figuresized{dlpi_fig6,6,Message Flow: Binding a Stream to a @acronym{DLSAP},4in}

@prim{DL_UNBIND_REQ} requests the DLS provider to unbind all @acronym{DLSAP}(s)
from a stream.  The @prim{DL_UNBIND_REQ} also unbinds all the subsequently bound
DLSAPs that have not been unbound.  The DLS provider indicates success with a
@prim{DL_OK_ACK}; failure with a @prim{DL_ERROR_ACK}.

@prim{DL_SUBS_UNBIND_REQ} requests the DLS Provider to unbind the subsequently
bound @acronym{DLSAP}.  The DLS Provider indicates success with a
@prim{DL_OK_ACK}; failure with a @prim{DL_ERROR_ACK}.

@figuresized{dlpi_fig7,7,Message Flow: Unbinding a Stream from a @acronym{DLSAP},4in}

@prim{DL_ENABMULTI_REQ} requests the DLS Provider to enable specific multicast
addresses on a per stream basis.  The Provider indicates success with a
@prim{DL_OK_ACK}; failure with a @prim{DL_ERROR_ACK}.

@figuresized{dlpi_fig8,8,Message Flow: Enabling a specific multicast address on a Stream,4in}

@prim{DL_DISABMULTI_REQ} requests the DLS Provider to disable specific multicast
addresses on a per Stream basis.  The Provider indicates success with a
@prim{DL_OK_ACK}; failure with a @prim{DL_ERROR_ACK}.

@figuresized{dlpi_fig9,9,Message Flow: Disabling a specific multicast address on a Stream,4in}

@prim{DL_PROMISCON_REQ} requests the DLS Provider to enable promiscuous mode on
a per Stream basis, either at the physical level or at the SAP level.  The
Provider indicates success with a @prim{DL_OK_ACK}; failure with a
@prim{DL_ERROR_ACK}.

@figuresized{dlpi_fi10,10,Message Flow: Enabling promiscuous mode on a Stream,4in}

@prim{DL_PROMISCOFF_REQ} requests the DLS Provider to disable promiscuous mode
on a per Stream basis, either at the physical level or at the SAP level.  The
Provider indicates success with a @prim{DL_OK_ACK}; failure with a
@prim{DL_ERROR_ACK}.

@figuresized{dlpi_fi11,11,Message Flow: Disabling promiscuous mode on a Stream,4in}

@node Connection-mode Services
@section Connection-mode Services
@cpindex Connection mode
The connection-mode services enable a DLS user to establish a data link
connection, transfer data over that connection, reset the link, and release the
connection when the conversation has terminated.

@menu
* Connection Establishment Service::
* Data Transfer Service::
* Connection Release Service::
* Reset Service::
@end menu

@node Connection Establishment Service
@subsection Connection Establishment Service
@cpindex Connection establishment

@menu
* Normal Connection Establishment::
* Connection Establishment Rejections::
@end menu

@cpindex Connection establishment
The connection establishment service establishes a data link connection between
a local DLS user and a remote DLS user for the purpose of sending data.  Only
one data link connection is allowed on each stream.

@node Normal Connection Establishment
@subsubsection Normal Connection Establishment
@cpindex Called DLS user
@cpindex Calling DLS user
@cpindex Connection establishment
In the connection establishment model, the calling DLS user initiates connection
establishment, while the called DLS user waits for incoming requests.
@prim{DL_CONNECT_REQ} requests that the DLS provider establish a connection.
@prim{DL_CONNECT_IND} informs the called DLS user of the request, which may be
accepted using @prim{DL_CONNECT_RES}.  @prim{DL_CONNECT_CON} informs the calling
DLS user that the connection has been established.

@cpindex Connection establishment
The normal sequence of messages is illustrated in the following figure.

@figuresized{dlpi_fi12,12,Message Flow: Successful Connection Establishment,4in}

Once the connection is established, the DLS users may exchange user data using
@prim{DL_DATA_REQ} and @prim{DL_DATA_IND}.

The DLS user may accept an incoming connect request on either the stream where
the connect indication arrived or an alternate, responding stream.  The
responding stream is indicated by a token in the @prim{DL_CONNECT_RES}.  This
token is a value associated with the responding stream, and is obtained by
issuing a @prim{DL_TOKEN_REQ} on that stream.  The DLS provider responds to this
request by generating a token for the stream and returning it to the DLS user in
a @prim{DL_TOKEN_ACK}.  The normal sequence of messages for obtaining a token is
illustrated in the following figure.

@figuresized{dlpi_fi13,13,Message Flow: Token Retrieval,4in}

@cpindex Called DLS user
@cpindex Connection establishment
In the typical connection establishment scenario, the called DLS user processes
one connect indication at a time, accepting the connection on another stream.
Once the user responds to the current connect indication, the next connect
indication (if any) can be processed.  @acronym{DLPI} also enables the called DLS user to
multi-thread incoming connect indications.  The user can receive multiple
connect indications before responding to any of them.  This enables the DLS user
to establish priority schemes on incoming connect requests.

@node Connection Establishment Rejections
@subsubsection Connection Establishment Rejections
@cpindex Connection establishment
In certain situations, the connection establishment request cannot be completed.
The following paragraphs describe the occasions under which
@prim{DL_DISCONNECT_REQ}
and @prim{DL_DISCONNECT_IND}
primitives will flow during connection establishment, causing the connect
request to be aborted.

@cpindex Called DLS user
The following figure illustrates the situation where the called DLS user chooses
to reject the connect request by issuing @prim{DL_DISCONNECT_REQ} instead of
@cpindex Connection establishment @prim{DL_CONNECT_RES}.

@figuresized{dlpi_fi14,14,Message Flow: Called DLS User Rejection of Connection Establishment Attempt,4in}

The following figure illustrates the situation where the DLS provider rejects a
connect request for lack of resources or other reason.  The DLS provider sends
@prim{DL_DISCONNECT_IND} in response to
@cpindex Connection establishment
@prim{DL_CONNECT_REQ}.

@figuresized{dlpi_fi15,15,Message Flow: DLS Provider Rejection of a Connection Establishment Attempt,4in}

@cpindex Calling DLS user
The following figures illustrate the situation where the calling DLS user
chooses to abort a previous connection attempt.  The DLS user issues
@prim{DL_DISCONNECT_REQ} at some point following a @prim{DL_CONNECT_REQ}.  The
resulting sequence of primitives depends on the relative timing of the
primitives involved, as defined in the following time sequence diagrams.

@figuresized{dlpi_fi16,16,Message Flow: Both Primitives are Destroyed by Provider,4in}

@figuresized{dlpi_fi17,17,Message Flow: DL_DISCONNECT Indication Arrives before DL_CONNECT Response is Sent,4in}

@figuresized{dlpi_fi18,18,Message Flow: DL_DISCONNECT Indication Arrives after DL_CONNECT Response is Sent,4in}

@node Data Transfer Service
@subsection Data Transfer Service
@cpindex Called DLS user
@cpindex Connection mode
The connection-mode data transfer service provides for the exchange of user data
in either direction or in both directions simultaneously between DLS users.
Data is transmitted in logical groups called data link service data units
(DLSDUs).  The DLS provider preserves both the sequence and boundaries of DLSDUs
as they are transmitted.

Normal data transfer is neither acknowledged nor confirmed.  It is up to the DLS
users, if they so choose, to implement a confirmation protocol.

Each @prim{DL_DATA_REQ} primitive conveys a @acronym{DLSDU} from the local DLS
user to the DLS provider.  Similarly, each @prim{DL_DATA_IND} primitive conveys
a @acronym{DLSDU} from the DLS provider to the remote DLS user.  The normal flow
of messages is illustrated in the figure below.

@figuresized{dlpi_fi19,19,Message Flow: Normal Data Transfer,4in}

@node Connection Release Service
@subsection Connection Release Service
The connection release service provides for the DLS users or the DLS provider to
initiate the connection release.  Connection release is an abortive operation,
and any data in transit (has not been delivered to the DLS user) may be
discarded.

@prim{DL_DISCONNECT_REQ} requests that a connection be released.
@prim{DL_DISCONNECT_IND} informs the DLS user that a connection has been
released.  Normally, one DLS user requests disconnection and the DLS provider
issues an indication of the ensuing release to the other DLS user, as
illustrated by the message flow in the following figure.

@figuresized{dlpi_fi20,20,Message Flow: DLS User-Invoked Connection Release,4in}

The next figure illustrates that when two DLS users independently invoke the
connection release service, neither receives a @prim{DL_DISCONNECT_IND}.

@figuresized{dlpi_fi21,21,Message Flow: Simultaneous DLS User Invoked Connection Release,4in}

The next figure illustrates that when the DLS provider initiates the connection
release service, each DLS user receives a @prim{DL_DISCONNECT_IND}.

@figuresized{dlpi_fi22,22,Message Flow: DLS Provider Invoked Connection Release,4in}

The next figure illustrates that when the DLS provider and the local DLS user
simultaneously invoke the connection release service, the remote DLS user
receives a @prim{DL_DISCONNECT_IND}.

@figuresized{dlpi_fi23,23,Message Flow: Simultaneous DLS User & DLS Provider Invoked Connection Release,4in}

@node Reset Service
@subsection Reset Service
The reset service may be used by the DLS user to resynchronize the use of a data
link connection, or by the DLS provider to report detected loss of data
unrecoverable within the data link service.

Invocation of the reset service will unblock the flow of DLSDUs if the data link
connection is congested; DLSDUs may be discarded by the DLS provider.  The DLS
user or users that did not invoke the reset will be notified that a reset has
occurred.  A reset may require a recovery procedure to be performed by the DLS
users.

The interaction between each DLS user and the DLS provider will be one of the
following:

@itemize @bullet
@item a
@prim{DL_RESET_REQ} from the DLS user, followed by a
@prim{DL_RESET_CON} from the DLS provider;
@item a
@prim{DL_RESET_IND} from the DLS provider, followed by a
@prim{DL_RESET_RES} from the DLS user.
@end itemize

The @prim{DL_RESET_REQ}
acts as a synchronization mark in the stream of DLSDUs that are transmitted by
the issuing DLS user; the
@prim{DL_RESET_IND}
acts as a synchronization mark in the stream of DLSDUs that are received by the
peer DLS user.  Similarly, the
@prim{DL_RESET_RES}
acts as a synchronization mark in the stream of DLSDUs that are transmitted by
the responding DLS user; the
@prim{DL_RESET_CON}
acts as a synchronization mark in the stream of DLSDUs that are received by the
DLS user which originally issued the reset.

The resynchronizing properties of the reset service are that:

@itemize @bullet

@item No @acronym{DLSDU} transmitted by the DLS user before the synchronization
mark in that transmitted stream will be delivered to the other DLS user after
the synchronization mark in that received stream.

@item The DLS provider will discard all DLSDUs submitted before the issuing of
the
@prim{DL_RESET_REQ}
that have not been delivered to the peer DLS user when the DLS provider issues
the
@prim{DL_RESET_IND}.

@item The DLS provider will discard all DLSDUs submitted before the issuing of
the
@prim{DL_RESET_RES}
that have not been delivered to the initiator of the
@prim{DL_RESET_REQ}
when the DLS provider issues the
@prim{DL_RESET_CON}.

@item No @acronym{DLSDU} transmitted by a DLS user after the synchronization
mark in that transmitted stream will be delivered to the other DLS user before
the synchronization mark in that received stream.

@end itemize

The complete message flow depends on the origin of the reset, which may be the
DLS provider or either DLS user.  The following figure illustrates the message
flow for a reset invoked by one DLS user.

@figuresized{dlpi_fi24,24,Message Flow: DLS User-Invoked Connection Reset,4in}

The following figure illustrates the message flow for a reset invoked by both
DLS users simultaneously.

@figuresized{dlpi_fi25,25,Message Flow: Simultaneous DLS User-Invoked Connection Reset,4in}

The following figure illustrates the message flow for a reset invoked by the DLS
provider.

@figuresized{dlpi_fi26,26,Message Flow: DLS Provider-Invoked Connection Reset,4in}

The following figure illustrates the message flow for a reset invoked
simultaneously by one DLS user and the DLS provider.

@figuresized{dlpi_fi27,27,Message Flow: Simultaneous DLS User & DLS Provider Invoked Connection Reset,4in}

@node Connectionless-mode Services
@section Connectionless-mode Services

@menu
* Connectionless Data Transfer Service::
* QOS Management Service (1)::
* Error Reporting Service (1)::
* XID and TEST Service::
@end menu

@cpindex Connectionless mode
The connectionless-mode services enable a DLS user to transfer units of data to
peer DLS users without incurring the overhead of establishing and releasing a
connection.  The connectionless service does not, however, guarantee reliable
delivery of data units between peer DLS users (e.g.  lack of flow control may
cause buffer resource shortages that result in data being discarded).

Once a stream has been initialized via the local management services, it may be
used to send and receive connectionless data units.

@node Connectionless Data Transfer Service
@subsection Connectionless Data Transfer Service
@cpindex Connectionless mode
The connectionless data transfer service provides for the exchange of user data
(DLSDUs) in either direction or in both directions simultaneously without having
to establish a data link connection.  Data transfer is neither acknowledged nor
confirmed, and there is no end-to-end flow control provided.  As such, the
connectionless data transfer service cannot guarantee reliable delivery of data.
However, a specific DLS provider can provide assurance that messages will not be
lost, duplicated, or reordered.

@prim{DL_UNITDATA_REQ} conveys one @acronym{DLSDU} to the DLS provider.
@prim{DL_UNITDATA_IND} conveys one @acronym{DLSDU} to the DLS user.  The normal
flow of messages is illustrated
@cpindex Connectionless mode
in the figure below.

@figuresized{dlpi_fi28,28,Message Flow: Connectionless Data Transfer,4in}

@node QOS Management Service (1)
@subsection QOS Management Service
The @acronym{QoS} (Quality of Service) management service enables a DLS user to specify
@cpindex Connectionless mode
the quality of service it can expect for each invocation of the connectionless
data transfer service.  The @prim{DL_UDQOS_REQ} directs the DLS provider to set
the @acronym{QoS} parameters to the specified values.  The
@cpindex Connectionless mode
normal flow of messages is illustrated in the figure below.

@figuresized{dlpi_fi29,29,Message Flow: Connectionless Data Transfer,4in}

@node Error Reporting Service (1)
@subsection Error Reporting Service
@cpindex Connectionless mode
The connectionless-mode error reporting service may be used to notify a DLS user
that a previously sent data unit either produced an error or could not be
delivered.  This service does not, however, guarantee that an error indication
will be issued for every undeliverable data unit.

@figuresized{dlpi_fi29b,29b,-,4in}

@node XID and TEST Service
@subsection XID and TEST Service

The XID and TEST service enables the DLS User to issue an XID or TEST request to
the DLS Provider.  On receiving a response for the XID or TEST frame transmitted
to the peer DLS Provider, the DLS Provider sends up an XID or TEST confirmation
primitive to the DLS User.  On receiving an XID or TEST frame from the peer DLS
Provider, the local DLS Provider sends up an XID or TEST indication respectively
to the DLS User.  The DLS User must respond with an XID or TEST response
primitive.

If the DLS User requested automatic handling of the XID or TEST response, at
bind time, the DLS Provider will send up an error acknowledgment on receiving an
XID or TEST request.  Also, no indications will be generated to the DLS User on
receiving XID or TEST frames from the remote side.

The normal flow of messages is illustrated in the figure below.

@figuresized{dlpi_fi30,30,Message Flow: XID Service,4in}

@figuresized{dlpi_fi31,31,Message Flow: TEST Service,4in}

@node Acknowledged Connectionless-mode Services
@section Acknowledged Connectionless-mode Services

@menu
* Acknowledged Connectionless-mode Data Transfer Services::
* QOS Management Service (2)::
* Error Reporting Service (2)::
@end menu

@cpindex Connectionless mode
The acknowledged connectionless-mode services are designed for general use for
the reliable transfer of informations between peer DLS Users.  These services
are intended for applications that require acknowledgment of cross-LAN data unit
transfer, but wish to avoid the complexity that is viewed as being associated
@cpindex Connection mode
with the connection-mode services.  Although the exchange service is
connectionless, in sequence delivery is guaranteed for data sent by the
initiating station.

@node Acknowledged Connectionless-mode Data Transfer Services
@subsection Acknowledged Connectionless-mode Data Transfer Services
@cpindex Connectionless mode
The acknowledged connectionless-mode data transfer services provide the means by
which the DLS User scan exchange DLSDUs which are acknowledged at the LLC
@cpindex Connection establishment
sublayer, without the establishment of a Data Link connection.  The services
provide a means by which a local DLS User can send a data unit to the peer DLS
User, request a previously prepared data unit, or exchange data units with the
@cpindex Connectionless mode
peer DLS User.

@figuresized{dlpi_fi32,32,Message Flow: Acknowledged Connectionless-Mode Data Unit Transmission service,4in}

The next figure illustrates the acknowledged connectionless-mode data unit
@cpindex Connectionless mode
exchange service.

@figuresized{dlpi_fi33,33,Message Flow: Acknowledged Connectionless-Mode Data Unit Exchange service,4in}

@cpindex Connectionless mode
The next figure illustrates the Reply Data Unit Preparation service.

@figuresized{dlpi_fi34,34,Message Flow: Acknowledged Connectionless-Mode Reply Data Unit Preparation Service,4in}

@node QOS Management Service (2)
@subsection QOS Management Service
@cpindex Connectionless mode
The Quality of Service (@acronym{QoS}) management service enables a DLS User to
specify the quality of service it can expect for each invocation of the
acknowledged connectionless data transfer service.  The @prim{DL_UDQOS_REQ}
directs the DLS provider to set the @acronym{QoS} parameters to the specified
values.  The normal flow of messages is illustrated in @ref{Connectionless-mode
Services}.

@node Error Reporting Service (2)
@subsection Error Reporting Service
@cpindex Connectionless mode
The acknowledged connectionless mode error reporting service is the same as the
unacknowledged connectionless-mode error reporting service.  For the message
flow, refer to @ref{Error Reporting Service (1)}.


@node An Example
@section An Example
To bring it all together, the following example illustrates the primitives that
@cpindex Connection mode
flow during a complete, connection-mode sequence between stream open and stream
@cpindex Connection mode
close.

@figuresized{dlpi_fi35,35,Message Flow: A Connection-mode Example,3.75in}

@node DLPI Primitives
@chapter DLPI Primitives

@menu
* Local Management Service Primitives::
* Connection-mode Service Primitives::
* Connectionless-mode Service Primitives::
* Primitives to handle XID and TEST operations::
* Acknowledged Connectionless-mode Service Primitives::
@end menu

The kernel-level interface to the data link layer defines a @acronym{STREAMS}-based
message interface between the provider of the data link service (DLS provider)
and the consumer of the data link service (DLS user).  @acronym{STREAMS} provides
the mechanism in which @acronym{DLPI} primitives may be passed between the DLS user and
DLS provider.

Before @acronym{DLPI} primitives can be passed between the DLS user and the DLS provider,
the DLS user must establish a stream to the DLS provider using open(2).  The DLS
provider must therefore be configured as a @acronym{STREAMS} driver.  When
interactions between the DLS user and DLS provider have completed, the stream
may be closed.

The @acronym{STREAMS} messages used to transport data link service primitives
across the interface have one of the following formats:

@itemize @bullet
@item One @msg{M_PROTO} message block followed by zero or more @msg{M_DATA}
blocks.  The @msg{M_PROTO} message block contains the data link layer service
primitive type and all relevant parameters associated with the primitive.  The
@msg{M_DATA} block(s) contain any DLS user data that might be associated with
the service primitive.
@item One @msg{M_PCPROTO} message block containing the data link layer service
primitive type and all relevant parameters associated with the service
primitive.
@item One or more @msg{M_DATA} message blocks conveying user data.
@end itemize

The information contained in the @msg{M_PROTO} or @msg{M_PCPROTO} message blocks
must begin on a byte boundary that is appropriate for structure alignment (e.g.
word-aligned on the AT&T 3B2 Computer).  @acronym{STREAMS} will allocate buffers
that begin on such a boundary.  However, these message blocks may contain
information whose representation is described by a length and an offset within
the block.  An example is the @acronym{DLSAP} address (dl_addr_length and
dl_addr_offset) in the @prim{DL_BIND_ACK} primitive.  The offset of such
information within the message block is not guaranteed to be properly aligned
for casting the appropriate data type (such as an int or a structure).

@ref{Allowable Sequence of DLPI Primitives}, defines the sequence in which
@acronym{DLPI}
primitives can be passed between DLS user and DLS provider, and @ref{Precedence
of DLPI Primitives}, summarizes the precedence rules associated with each
primitive for ordering the primitives on the DLS provider and DLS user queues.

The following sections describe the format of the primitives that support the
services described in the previous section.  The primitives are grouped into
four general categories for presentation:

@itemize @bullet
@item Local Management Service Primitives
@item Connection-mode Service Primitives
@cpindex Connection mode
@item Connectionless-mode Service Primitives
@cpindex Connectionless mode
@item Acknowledged Connectionless-mode Service Primitives
@cpindex Connectionless mode
@end itemize


@node Local Management Service Primitives
@section Local Management Service Primitives

@menu
* PPA Initialization / De-initialization::
* Message DL_INFO_REQ (dl_info_req_t)::
* Message DL_INFO_ACK (dl_info_ack_t)::
* Message DL_ATTACH_REQ (dl_attach_req_t)::
* Message DL_DETACH_REQ (dl_detach_req_t)::
* Message DL_BIND_REQ (dl_bind_req_t)::
* Message DL_BIND_ACK (dl_bind_ack_t)::
* Message DL_UNBIND_REQ (dl_unbind_req_t)::
* Message DL_SUBS_BIND_REQ (dl_subs_bind_req_t)::
* Message DL_SUBS_BIND_ACK (dl_subs_bind_ack_t)::
* Message DL_SUBS_UNBIND_REQ (dl_subs_unbind_req_t)::
* Message DL_ENABMULTI_REQ (dl_enabmulti_req_t)::
* Message DL_DISABMULTI_REQ (dl_disabmulti_req_t)::
* Message DL_PROMISCON_REQ (dl_promiscon_req_t)::
* Message DL_PROMISCOFF_REQ (dl_promiscoff_req_t)::
* Message DL_OK_ACK (dl_ok_ack_t)::
* Message DL_ERROR_ACK (dl_error_ack_t)::
@end menu

@cpindex Connectionless mode
This section describes the local management service primitives that are common
to the connection, connectionless and acknowledged connectionless service modes.
These primitives support the Information Reporting, Attach, Bind,
enabling/disabling of multicast addresses and turning on/off the promiscuous
mode.  Once a stream has been opened by a DLS user, these primitives initialize
the stream, preparing it for use.

@node PPA Initialization / De-initialization
@subsection PPA Initialization / De-initialization
The @acronym{PPA} associated with each stream must be initialized before the DLS
provider can transfer data over the medium.  The initialization and
de-initialization of the @acronym{PPA} is a network management issue, but
@acronym{DLPI}
must address the issue because of the impact such actions will have on a DLS
user.  More specifically, @acronym{DLPI} requires the DLS provider to initialize the
@acronym{PPA} associated with a stream at some point before it completes the
processing of the @prim{DL_BIND_REQ}.  Guidelines for initialization and
de-initialization of a @acronym{PPA} by a DLS provider are presented here.

A DLS provider may initialize a @acronym{PPA} using the following methods:

@itemize @bullet
@item pre-initialized by some network management mechanism before the
@prim{DL_BIND_REQ} is received; or
@item automatic initialization on receipt of a @prim{DL_BIND_REQ} or
@prim{DL_ATTACH_REQ}.
@end itemize

A specific DLS provider may support either of these methods, or possibly some
combination of the two, but the method implemented has no impact on the DLS
user.  From the DLS user's viewpoint, the @acronym{PPA} is guaranteed to be
initialized on receipt of a @prim{DL_BIND_ACK}.  For automatic initialization,
this implies that the @prim{DL_BIND_ACK} may not be issued until the
initialization has completed.

If pre-initialization has not been performed and/or automatic initialization
fails, the DLS provider will fail the @prim{DL_BIND_REQ}.  Two errors,
@perr{DL_INITFAILED} and @perr{DL_NOTINIT}, may be returned in the
@prim{DL_ERROR_ACK} response to a @prim{DL_BIND_REQ} if @acronym{PPA}
initialization fails.  @perr{DL_INITFAILED} is returned when a DLS provider
supports automatic @acronym{PPA} initialization, but the initialization attempt
failed.  @perr{DL_NOTINIT} is returned when the DLS provider requires
pre-initialization, but the @acronym{PPA} is not initialized before the
@prim{DL_BIND_REQ} is received.

A DLS provider may handle @acronym{PPA} de-initialization using the following
methods:

@itemize @bullet
@item automatic de-initialization upon receipt of the final @prim{DL_DETACH_REQ}
(for style 2 providers) or @prim{DL_UNBIND_REQ} (for style 1 providers), or upon
closing of the last stream associated with the @acronym{PPA};
@item automatic de-initialization after expiration of a timer following the last
@prim{DL_DETACH_REQ}, @prim{DL_UNBIND_REQ}, or close as appropriate; or
@item no automatic de-initialization; administrative intervention is required to
de-initialize the @acronym{PPA} at some point after it is no longer being
accessed.
@end itemize

A specific DLS provider may support any of these methods, or possibly some
combination of them, but the method implemented has no impact on the DLS user.
From the DLS user's viewpoint, the @acronym{PPA} is guaranteed to be initialized
and available for transmission until it closes or unbinds the stream associated
with the @acronym{PPA}.

DLS provider-specific addendum documentation should describe the method chosen
for @acronym{PPA} initialization and de-initialization.

@page
@node Message DL_INFO_REQ (dl_info_req_t)
@subsection Message DL_INFO_REQ (dl_info_req_t)
@tpindex dl_info_req_t
Requests information of the DLS provider about the @acronym{DLPI} stream.  This
information includes a set of provider-specific parameters, as well as the
current state of the interface.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_info_req_t;
@tpindex dl_info_req_t
@end example

@subsubheading Parameters

@table @parm

@item dl_primitive
conveys
@prim{DL_INFO_REQ}.

@end table

@subsubheading State
The message is valid in any state in which a local acknowledgment is not
pending, as described in @ref{Allowable Sequence of DLPI Primitives}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The DLS provider responds to the information request with a
@prim{DL_INFO_ACK}.


@page
@node Message DL_INFO_ACK (dl_info_ack_t)
@subsection Message DL_INFO_ACK (dl_info_ack_t)
@tpindex dl_info_ack_t
This message is sent in response to
@prim{DL_INFO_REQ};
it conveys information about
the @acronym{DLPI} stream to the DLS user.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_max_sdu;
        ulong dl_min_sdu;
        ulong dl_addr_length;
        ulong dl_mac_type;
        ulong dl_reserved;
        ulong dl_current_state;
        long dl_sap_length;
        ulong dl_service_mode;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_qos_range_length;
        ulong dl_qos_range_offset;
        ulong dl_provider_style;
        ulong dl_addr_offset;
        ulong dl_version;
        ulong dl_brdcst_addr_length;
        ulong dl_brdcst_addr_offset;
        ulong dl_growth;
@} dl_info_ack_t;
@tpindex dl_info_ack_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_INFO_ACK}.

@item dl_max_sdu
conveys the maximum number of bytes that may be transmitted in a
@acronym{DLSDU}.  This value must be a positive integer that is greater than or
equal to the value of dl_min_sdu.

@item dl_min_sdu
conveys the minimum number of bytes that may be transmitted in a
@acronym{DLSDU}.  The value is never less than one.

@item dl_addr_length
conveys the length, in bytes, of the provider's @acronym{DLSAP} address.  In the
case of a hierarchical subsequent bind, the length returned is the total length
i.e.  Physical address + SAP + subsequent address length.

@item dl_mac_type
conveys the type of medium supported by this @acronym{DLPI} stream.  Possible values
include:

@table @pval
@item DL_CSMACD
The medium is Carrier Sense Multiple Access with Collision Detection (ISO8802/3).
@item DL_TPB
The medium is Token-Passing Bus (ISO 8802/4).
@item DL_TPR
The medium is Token-Passing Ring (ISO 8802/5).
@item DL_METRO
The medium is Metro Net (ISO 8802/6).
@item DL_ETHER
The medium is Ethernet Bus.
@item DL_HDLC
The medium is a bit synchronous communication line.
@item DL_CHAR
The medium is a character synchronous communication line (e.g.  BISYNC).
@item DL_CTCA
The medium is a channel-to-channel adapter.
@item DL_FDDI
The medium is a Fiber Distributed Data Interface.
@item DL_OTHER
Any other medium not listed above.
@end table

@item dl_reserved
is a reserved field whose value must be set to zero.

@item dl_current_state
conveys the state of the @acronym{DLPI} interface for the stream when the DLS provider
issued this acknowledgment.  See @ref{Allowable Sequence of DLPI Primitives},
for a list of @acronym{DLPI} states and an
explanation of each.
@item dl_sap_length
indicates the current length of the SAP component of the @acronym{DLSAP}
address.  It may have a negative, zero or positive value.  A positive value
indicates the ordering of the SAP and PHYSICAL component within the
@acronym{DLSAP} address as SAP component followed by PHYSICAL component.  A
negative value indicates PHYSICAL followed by the SAP.  A zero value indicates
that no SAP has yet been bound.  The absolute value of the dl_sap_length
provides the length of the SAP component within the @acronym{DLSAP} address.
@item dl_service_mode
if returned before the @prim{DL_BIND_REQ}
@cpindex Connection mode
is processed, this conveys which service modes (connection-mode,
@cpindex Connectionless mode
connectionless-mode or acknowledged connectionless-mode, or any combination of
these modes) the DLS provider can support.  It contains a bit-mask specifying
one or more than one of the following values:

@table @pval
@item DL_CODLS
connection-oriented data link service;
@item DL_CLDLS
@cpindex Connectionless mode
connectionless data link service;
@item DL_ACLDLS
@cpindex Connectionless mode
acknowledged connectionless data link service;
@end table

Once a specific service mode has been bound to the stream, this field returns
that specific service mode.

@item dl_qos_length
conveys the length, in bytes, of the negotiated/selected values of the quality
of service (@acronym{QoS}) parameters.  @ref{Quality of Data Link Service},
describes quality of service and its associated parameters completely.  For
@cpindex Connection mode
connection-mode service, the returned values are those agreed during
@cpindex Connectionless mode
negotiation.  For connectionless-mode service, the values are those currently
selected by the DLS user.  If quality of service has not yet been negotiated,
default values will be returned; these values correspond to those that will be
@cpindex Connection mode
applied by the DLS provider on a connect request in connection-mode service, or
those that will be applied to each data unit transmission in connectionless-mode
@cpindex Connection mode
service.  If the DLS provider supports both connection-mode and
connectionless-mode services but the DLS user has not yet bound a specific
@cpindex Connection mode
service mode, the DLS provider may return either connection-mode or
@cpindex Connectionless mode
connectionless-mode @acronym{QoS} parameter values.

The @acronym{QoS} values are conveyed in the structures defined in @ref{QOS Data
Structures}.  For any parameter the DLS provider does not support or cannot
determine, the corresponding entry will be set to @pval{DL_UNKNOWN}.  If the DLS
provider does not support any @acronym{QoS} parameters, this length field will
be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the @msg{M_PCPROTO} block where the
current quality of service parameters begin.

@item dl_qos_range_length
@cpindex Calling DLS user
conveys the length, in bytes, of the available range of @acronym{QoS} parameter
values
@cpindex Connection mode
supported by the DLS provider.  For connection-mode service, this is the range
@cpindex Connectionless mode
available to the calling DLS user in a connect request.  For connectionless-mode,
this is the range available for each data unit transmission.  If the DLS
@cpindex Connection mode
provider supports both connection-mode and connectionless-mode services but the
DLS user has not yet bound a specific service mode, the DLS provider may return
@cpindex Connection mode
either connection-mode or connectionless-mode @acronym{QoS} parameter values.
The range of available @acronym{QoS} values is conveyed in the structures
defined in @ref{QOS Data
Structures}.  For any parameter the DLS provider does not support or cannot
determine, the corresponding entry will be set to
@pval{DL_UNKNOWN}.
If the DLS provider does not support any @acronym{QoS} parameters, this length
field will be set to zero.

@item dl_qos_range_offset
conveys the offset from the beginning of the @msg{M_PCPROTO} block where the
available range of quality of service parameters begins.

@item dl_provider_style
conveys the style of DLS provider associated with the @acronym{DLPI} stream
(@pxref{Physical Attachment Identification}).  The following provider classes
are defined:

@table @pval
@item DL_STYLE1
The @acronym{PPA} is implicitly attached to the @acronym{DLPI} stream by opening the
appropriate major/minor device number.
@item DL_STYLE2
The DLS user must explicitly attach a @acronym{PPA} to the @acronym{DLPI} stream using
@prim{DL_ATTACH_REQ}.
@end table

DLS users implemented in a protocol-independent manner must access this
parameter to determine whether the DLS attach service must be invoked explicitly.

@item dl_addr_offset
conveys the offset of the address that is bound to the associated stream.  If
the DLS user issues a @prim{DL_INFO_REQ} prior to binding a @acronym{DLSAP}, the
value of dl_addr_len will be 0 and consequently indicate that there has been no
address bound.

@item dl_version
indicates the current version of the @acronym{DLPI} that's supported.

@item dl_brdcst_addr_length
indicates the length of the physical broadcast address.

@item dl_brdcst_addr_offset
indicates the offset of the physical broadcast address from the beginning of the
@msg{M_PCPROTO} block.

@item dl_growth
conveys a growth field for future use.  The value of this field will be zero.

@end table

@subsubheading State
The message is valid in any state in response to a
@prim{DL_INFO_REQ}.

@subsubheading New State
The resulting state is unchanged.


@page
@node Message DL_ATTACH_REQ (dl_attach_req_t)
@subsection Message DL_ATTACH_REQ (dl_attach_req_t)
@tpindex dl_attach_req_t
Requests the DLS provider associate a physical point of attachment
(@acronym{PPA}) with a stream.  @prim{DL_ATTACH_REQ} is needed for style 2 DLS
providers to identify the physical medium over which communication will
transpire.  The request may not be issued to a style 1 DLS provider; doing so
may cause errors.

The DLS provider may initialize the physical line on receipt of this primitive
or the @prim{DL_BIND_REQ}.  Otherwise, the line must be initialized through some
management mechanism before this request is issued by the DLS user.  Either way,
the physical link must be initialized and ready for use on successful completion
of the @prim{DL_BIND_REQ}.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_ppa;
@} dl_attach_req_t;
@tpindex dl_attach_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_ATTACH_REQ}.

@item dl_ppa
conveys the identifier of the physical point of attachment to be associated with
the stream.  The format of the identifier is provider-specific, and it must
contain sufficient information to distinguish the desired @acronym{PPA} from all
possible PPAs on a system.

At a minimum, this must include identification of the physical medium over which
communication will transpire.  For media that multiplex multiple channels over a
single physical medium, this identifier should also specify a specific channel
to be used for communication(where each channel on a physical medium is
associated with a separate @acronym{PPA}).

Because of the provider-specific nature of this value, DLS user software that is
to be protocol independent should avoid hard-coding the @acronym{PPA}
identifier.  The DLS user should retrieve the necessary @acronym{PPA} identifier
from some other entity (such as a management entity) and insert it without
inspection into the
@prim{DL_ATTACH_REQ}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_UNATTACHED}.

@subsubheading New State
The resulting state is
@psta{DL_ATTACH_PENDING}.

@subsubheading Response
If the attach request is successful,
@prim{DL_OK_ACK}
is sent to the DLS user resulting
in state
@psta{DL_UNBOUND}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure

@table @perr
@item DL_BADPPA
The specified @acronym{PPA} is invalid.
@item DL_ACCESS
The DLS user did not have proper permission to use the requested @acronym{PPA}.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the
@prim{DL_ERROR_ACK}.
@end table


@page
@node Message DL_DETACH_REQ (dl_detach_req_t)
@subsection Message DL_DETACH_REQ (dl_detach_req_t)
@tpindex dl_detach_req_t
For style 2 DLS providers, this requests the DLS provider detach a physical
point of attachment (@acronym{PPA}) from a stream.  The request may not be
issued to a style 1 DLS provider; doing so may cause errors.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_detach_req_t;
@tpindex dl_detach_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_DETACH_REQ}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_UNBOUND}.

@subsubheading New State
The resulting state is
@psta{DL_DETACH_PENDING}.

@subsubheading Response
If the detach request is successful,
@prim{DL_OK_ACK}
is sent to the DLS user resulting in state
@psta{DL_UNATTACHED}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure

@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the
@prim{DL_ERROR_ACK}.
@end table

@page
@node Message DL_BIND_REQ (dl_bind_req_t)
@subsection Message DL_BIND_REQ (dl_bind_req_t)
@tpindex dl_bind_req_t
Requests the DLS provider bind a @acronym{DLSAP} to the stream.  The DLS user
must identify the address of the @acronym{DLSAP} to be bound to the stream.  For
@cpindex Connection mode
connection-mode service, the DLS user also indicates whether it will accept
incoming connection requests on the stream.  Finally, the request directs the
DLS provider to activate the stream associated with the @acronym{DLSAP}.

A stream is viewed as active when the DLS provider may transmit and receive
protocol data units destined to or originating from the stream.  The
@acronym{PPA} associated with each stream must be initialized upon completion of
the processing of the @prim{DL_BIND_REQ} (@pxref{@acronym{PPA} Initialization /
De-initialization}).  More specifically, the DLS user is ensured that the
@acronym{PPA} is initialized when the @prim{DL_BIND_ACK} is received.  If the
@acronym{PPA} cannot be initialized, the @prim{DL_BIND_REQ} will fail.

@cpindex Connection management stream
A stream may be bound as a "connection management" stream, such that it will
receive all connect requests that arrive through a given @acronym{PPA}
(@pxref{The Connection Management Stream}).  In this case, the dl_sap will be
ignored.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_sap;
        ulong dl_max_conind;
        ushort dl_service_mode;
        ushort dl_conn_mgmt;
        ulong dl_xidtest_flg;
@} dl_bind_req_t;
@tpindex dl_bind_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys @prim{DL_BIND_REQ}.

@item dl_sap
conveys sufficient information to identify the @acronym{DLSAP} that will be
bound to the @acronym{DLPI} stream (@pxref{DLPI Addressing}, for a description of
@acronym{DLSAP} addresses).  The format of this information is specific to a
given DLS provider, and may contain the full @acronym{DLSAP} address or some
portion of that address sufficient to uniquely identify the @acronym{DLSAP} in
question.  The full address of the bound @acronym{DLSAP} will be returned in the
@prim{DL_BIND_ACK}.

The following rules are used by the DLS provider when binding a @acronym{DLSAP} address.

@itemize @bullet
@item The DLS provider must define and manage its @acronym{DLSAP} address space.

@item @acronym{DLPI} allows the same @acronym{DLSAP} to be bound to multiple streams, but
a given DLS provider may need to restrict its address space to allow one stream
per
@acronym{DLSAP}.

@item The DLS provider may not be able to bind the specified @acronym{DLSAP}
address for the following reasons:

@enumerate
@item the DLS provider may statically associate a specific @acronym{DLSAP} with
each stream; or
@item the DLS provider may only support one stream per @acronym{DLSAP} and the
DLS user attempted to bind a @acronym{DLSAP} that was already bound to another
stream.
@end enumerate

In case (1), the value of dl_sap is ignored by the DLS provider and the
@prim{DL_BIND_ACK} returns the @acronym{DLSAP} address that is already
associated with the stream.  In case (2), if the DLS provider cannot bind the
given @acronym{DLSAP} to the stream, it may attempt to choose an alternate
@acronym{DLSAP} and return that on the @prim{DL_BIND_ACK}.  If an alternate
@acronym{DLSAP} cannot be chosen, the DLS provider will return a
@prim{DL_ERROR_ACK} and set dl_errno to @perr{DL_NOADDR}.
@end itemize

Because of the provider-specific nature of the @acronym{DLSAP} address, DLS user
software that is to be protocol independent should avoid hard-coding this value.
The DLS user should retrieve the necessary @acronym{DLSAP} address from some
other entity (such as a management entity or higher layer protocol entity) and
insert it without inspection into the @prim{DL_BIND_REQ}.

@item dl_max_conind
conveys the maximum number of outstanding @prim{DL_CONNECT_IND} messages allowed
on the @acronym{DLPI} stream.  If the value is zero, the stream cannot accept any
@prim{DL_CONNECT_IND} messages.  If greater than zero, the DLS user will accept
@prim{DL_CONNECT_IND} messages up to the given value before having to respond
with a @prim{DL_CONNECT_RES} or a @prim{DL_DISCONNECT_REQ}
(@pxref{Multi-threaded Connection Establishment}, for details on how this value
is used to support multi-threaded connect processing).  The DLS provider may not
be able to support the value supplied in dl_max_conind, as specified by the
following rules.

@itemize @bullet
@item If the provider cannot support the specified number of outstanding connect
indications, it should set the value down to a number it can support.

@item Only one stream that is bound to the indicated @acronym{DLSAP} may have an
allowed number of maximum outstanding connect indications greater than zero.  If
a @prim{DL_BIND_REQ} specifies a value greater than zero, but another stream has
already bound itself to the @acronym{DLSAP} with a value greater than zero, the
DLS provider will fail the request, setting dl_errno to @perr{DL_BOUND} on the
@prim{DL_ERROR_ACK}.

@item If a stream with dl_max_conind greater than zero is used to accept a
connection, the stream will be found busy during the duration of the connection,
and no other streams may be bound to the same @acronym{DLSAP} with a value of
dl_max_conind greater than zero.  This restriction prevents more than one stream
bound to the same @acronym{DLSAP} from receiving connect indications and
accepting connections.  Accepting a connection on such a stream is only allowed
if there is just a single outstanding connect indication being processed.

@item A DLS user should always be able to request a dl_max_conind value of zero,
since this indicates to the DLS provider that the stream will only be used to
originate connect requests.

@item A stream with a negotiated value of dl_max_conind that is greater than
zero may not originate connect requests.

@end itemize

@cpindex Connectionless mode
This field is ignored in connectionless-mode service.

@item dl_service_mode
conveys the desired mode of service for this stream, and may contain one of the
following:

@table @pval
@item DL_CODLS
connection-oriented data link service;
@item DL_CLDLS
@cpindex Connectionless mode
connectionless data link service.
@item DL_ACLDLS
@cpindex Connectionless mode
acknowledged connectionless data link service.
@end table

If the DLS provider does not support the requested service mode, a
@prim{DL_ERROR_ACK}
will be generated, specifying
@perr{DL_UNSUPPORTED}.

@item dl_conn_mgmt
@cpindex Connection management stream
if non-zero, indicates that the stream is the "connection management" stream for
the @acronym{PPA} to which the stream is attached.  When an incoming connect
request arrives, the DLS provider will first look for a stream bound with
dl_max_conind greater than zero that is associated with the destination
@acronym{DLSAP}.  If such a stream is found, the connect indication will be
issued on that stream.  Otherwise, the DLS provider will issue the connect
indication on the "connection management" stream for that @acronym{PPA}, if one
exists.  Only one "connection management" stream is allowed per @acronym{PPA},
so an attempt to bind a second
@cpindex Connection management stream
"connection management" stream on a @acronym{PPA} will fail with the
@acronym{DLPI} error
set to @perr{DL_BOUND}.  When dl_conn_mgmt is non-zero, the value of dl_sap will
be ignored.
@cpindex Connectionless mode
In connectionless-mode service, dl_conn_mgmt is ignored by the DLS provider.

@item dl_xidtest_flg
indicates to the DLS Provider that XID and/or TEST responses for this stream are
to be automatically generated by the DLS Provider.  The DLS Provider will not
generate @prim{DL_XID_IND} and/or @prim{DL_TEST_IND}, and will error a
@prim{DL_XID_REQ} and/or @prim{DL_TEST_REQ}.  If the DLS Provider does not
support automatic handling of XID and/or TEST responses, a @prim{DL_ERROR_ACK}
will be generated, specifying @perr{DL_NOAUTO}, @perr{DL_NOXIDAUTO} or
@perr{DL_NOTESTAUTO}.  If the Provider receives an XID or TEST request from the
DLS User, a @prim{DL_ERROR_ACK} will be generated specifying @perr{DL_XIDAUTO}
or @perr{DL_TESTAUTO} respectively.

The dl_xidtest_flg contains a bit-mask specifying zero or more of the following
values:

@table @pval
@item DL_AUTO_XID
Automatically respond to XID commands.
@item DL_AUTO_TEST
Automatically respond to TEST commands.
@end table

@end table

@subsubheading State
The message is valid in state
@psta{DL_UNBOUND}.

@subsubheading New State
The resulting state is
@psta{DL_BIND_PENDING}.

@subsubheading Response
If the bind request is successful,
@prim{DL_BIND_ACK}
is sent to the DLS user resulting in state
@psta{DL_IDLE}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure

@table @perr
@item DL_BADADDR
The @acronym{DLSAP} address information was invalid or was in an incorrect
format.
@item DL_INITFAILED
Automatic initialization of the @acronym{PPA} failed.
@item DL_NOTINIT
The @acronym{PPA} had not been initialized prior to this request.
@item DL_ACCESS
The DLS user did not have proper permission to use the requested @acronym{DLSAP}
address.
@item DL_BOUND
The DLS user attempted to bind a second stream to a @acronym{DLSAP} with
dl_max_conindgreater than zero, or the DLS user attempted to bind a second
@cpindex Connection management stream
"connection management" stream to a @acronym{PPA}.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_NOADDR
The DLS provider could not allocate a @acronym{DLSAP} address for this stream.
@item DL_UNSUPPORTED
The DLS provider does not support requested service mode on this stream.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the @prim{DL_ERROR_ACK}.
@item DL_NOAUTO
Automatic handling of XID and TEST responses not supported.
@item DL_NOXIDAUTO
Automatic handling of XID response not supported.
@item DL_NOTESTAUTO
Automatic handling of TEST response not supported.
@end table

@page
@node Message DL_BIND_ACK (dl_bind_ack_t)
@subsection Message DL_BIND_ACK (dl_bind_ack_t)
@tpindex dl_bind_ack_t
Reports the successful bind of a @acronym{DLSAP} to a stream, and returns the
bound @acronym{DLSAP} address to the DLS user.  This primitive is generated in
response to a @prim{DL_BIND_REQ}.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_sap;
        ulong dl_addr_length;
        ulong dl_addr_offset;
        ulong dl_max_conind;
        ulong dl_xidtest_flg;
@} dl_bind_ack_t;
@tpindex dl_bind_ack_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_BIND_ACK}.

@item dl_sap
conveys the @acronym{DLSAP} address information associated with the bound
@acronym{DLSAP}.  It corresponds to the dl_sap field of the associated
@prim{DL_BIND_REQ}, which contains either part or all of the @acronym{DLSAP}
address.  For that portion of the @acronym{DLSAP} address conveyed in the
@prim{DL_BIND_REQ}, this field contains the corresponding portion of the address
for the @acronym{DLSAP} that was actually bound.

@item dl_addr_length
conveys the length of the complete @acronym{DLSAP} address that was bound to the
@acronym{DLPI} stream (@pxref{DLPI Addressing}, for a description of @acronym{DLSAP}
addresses).  The bound @acronym{DLSAP} is chosen according to the guidelines
presented under the description of @prim{DL_BIND_REQ}.

@item dl_addr_offset
conveys the offset from the beginning of the @msg{M_PCPROTO} block where the
@acronym{DLSAP} address begins.

@item dl_max_conind
conveys the allowed, maximum number of outstanding @prim{DL_CONNECT_IND}
messages to be supported on the @acronym{DLPI} stream.  If the value is zero, the stream
cannot accept any @prim{DL_CONNECT_IND} messages.  If greater than zero, the DLS
user will accept @prim{DL_CONNECT_IND} messages up to the given value before
having to respond with a @prim{DL_CONNECT_RES} or a @prim{DL_DISCONNECT_REQ}.
The rules for negotiating this value are presented under the description of
@prim{DL_BIND_REQ}.

@item dl_xidtest_flg
conveys the XID and TEST responses supported by the provider.
@table @pval
@item DL_AUTO_XID
XID response handled automatically.
@item DL_AUTO_TEST
TEST response handled automatically.
@end table
If no value is specified in dl_xidtest_flg, it indicates that automatic handling
of XID and TEST responses is not supported by the Provider.

@end table

@subsubheading State
The message is valid in state
@psta{DL_BIND_PENDING}.

@subsubheading New State
The resulting state is
@psta{DL_IDLE}.

@page
@node Message DL_UNBIND_REQ (dl_unbind_req_t)
@subsection Message DL_UNBIND_REQ (dl_unbind_req_t)
@tpindex dl_unbind_req_t
Requests the DLS provider to unbind the @acronym{DLSAP} that had been bound by a
previous @prim{DL_BIND_REQ} from this stream.  If one or more DLSAPs were bound
to the stream using a @prim{DL_SUBS_BIND_REQ}, and have not been unbound using a
@prim{DL_SUBS_UNBIND_REQ}, the @prim{DL_UNBIND_REQ} will unbind all the
subsequent DLSAPs for that stream along with the @acronym{DLSAP} bound using the
previous @prim{DL_BIND_REQ}.

At the successful completion of the request, the DLS user may issue a new
@prim{DL_BIND_REQ} for a potentially new @acronym{DLSAP}.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_unbind_req_t;
@tpindex dl_unbind_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_UNBIND_REQ}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is
@psta{DL_UNBIND_PENDING}.

@subsubheading Response
If the unbind request is successful,
@prim{DL_OK_ACK}
is sent to the DLS user resulting in state
@psta{DL_UNBOUND}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure

@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the
@prim{DL_ERROR_ACK}.
@end table


@page
@node Message DL_SUBS_BIND_REQ (dl_subs_bind_req_t)
@subsection Message DL_SUBS_BIND_REQ (dl_subs_bind_req_t)
@tpindex dl_subs_bind_req_t
Requests the DLS provider bind a subsequent @acronym{DLSAP} to the stream.  The
DLS user must identify the address of the subsequent @acronym{DLSAP} to be bound
to the stream.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_subs_sap_offset;
        ulong dl_subs_sap_length;
        ulong dl_subs_bind_class;
@} dl_subs_bind_req_t;
@tpindex dl_subs_bind_req_t
@end example


@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_SUBS_BIND_REQ}.

@item dl_subs_sap_offset
conveys the offset of the @acronym{DLSAP} from the beginning of the
@msg{M_PROTO} block.

@item dl_subs_sap_length
conveys the length of the specified @acronym{DLSAP}.

@item dl_subs_bind_class
Specifies either peer or hierarchical addressing
@table @pval
@item DL_PEER_BIND
specifies peer addressing.  The @acronym{DLSAP} specified is used in lieu of the
@acronym{DLSAP} bound in the BIND request.

@item DL_HIERARCHICAL_BIND
specifies hierarchical addressing.  The @acronym{DLSAP} specified is used in
addition to the @acronym{DLSAP} specified using the BIND request.

@end table
@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is
@psta{DL_SUBS_BIND_PND}.

@subsubheading Response
If the subsequent bind request is successful,
@prim{DL_SUBS_BIND_ACK}
is sent to the DLS user resulting instate
@psta{DL_IDLE}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure

@table @perr
@item DL_BADADDR
The @acronym{DLSAP} address information was invalid or was in an incorrect
format.

@item DL_ACCESS
The DLS user did not have proper permission to use the requested @acronym{DLSAP}
address.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_SYSERR
A System error has occurred and the UNIX system error is indicated in the
@prim{DL_ERROR_ACK}.

@item DL_UNSUPPORTED
Requested addressing class not supported.

@item DL_TOOMANY
Limit exceeded on the maximum number of DLSAPs per stream.
@end table

@page
@node Message DL_SUBS_BIND_ACK (dl_subs_bind_ack_t)
@subsection Message DL_SUBS_BIND_ACK (dl_subs_bind_ack_t)
@tpindex dl_subs_bind_ack_t
Reports the successful bind of a subsequent @acronym{DLSAP} to a stream, and
returns the bound @acronym{DLSAP} address to the DLS user.  This primitive is
generated in response to a @prim{DL_SUBS_BIND_REQ}.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_subs_sap_offset;
        ulong dl_subs_sap_length;
@} dl_subs_bind_ack_t;
@tpindex dl_subs_bind_ack_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_SUBS_BIND_ACK}.
@item dl_subs_sap_offset
conveys the offset of the @acronym{DLSAP} from the beginning of the
@msg{M_PCPROTO} block.
@item dl_subs_sap_length
conveys the length of the specified @acronym{DLSAP}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_SUBS_BIND_PND}

@subsubheading New State
The resulting state is
@psta{DL_IDLE}.

@page
@node Message DL_SUBS_UNBIND_REQ (dl_subs_unbind_req_t)
@subsection Message DL_SUBS_UNBIND_REQ (dl_subs_unbind_req_t)
@tpindex dl_subs_unbind_req_t
Requests the DLS Provider to unbind the @acronym{DLSAP} that had been bound by a
previous @prim{DL_SUBS_BIND_REQ} from this stream.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the
following structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_subs_sap_offset;
        ulong dl_subs_sap_length;
@} dl_subs_unbind_req_t;
@tpindex dl_subs_unbind_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_SUBS_UNBIND_REQ}.
@item dl_subs_sap_offset
conveys the offset of the @acronym{DLSAP} from the beginning of the
@msg{M_PROTO} block.
@item dl_subs_sap_length
conveys the length of the specified @acronym{DLSAP}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is
@psta{DL_SUBS_UNBIND_PND}.

@subsubheading Response
If the unbind request is successful, a
@prim{DL_OK_ACK}
is sent to the DLS User.  The resulting state is
@psta{DL_IDLE}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for failure

@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the @prim{DL_ERROR_ACK}.
@item DL_BADADDR
The @acronym{DLSAP} address information was invalid or was in an incorrect format.
@end table

@page
@node Message DL_ENABMULTI_REQ (dl_enabmulti_req_t)
@subsection Message DL_ENABMULTI_REQ (dl_enabmulti_req_t)
@tpindex dl_enabmulti_req_t
Requests the DLS Provider to enable specific multicast addresses on a per Stream
basis.  It is invalid for a DLS Provider to pass upstream messages that are
destined for any address other than those explicitly enabled on that Stream by
the DLS User.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_enabmulti_req_t;
@tpindex dl_enabmulti_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_ENABMULTI_REQ}
@item dl_addr_length
conveys the length of the multicast address
@item dl_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
multicast address begins
@end table

@subsubheading State
This message is valid in any state in which a local acknowledgment is not
pending with the exception of
@psta{DL_UNATTACHED}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the enable request is successful, a
@prim{DL_OK_ACK}
is sent to the DLS user.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for failure

@table @perr
@item DL_BADADDR
Address information was invalid or was in an incorrect format.
@item DL_TOOMANY
Too many multicast address enable attempts.  Limit exceeded.
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_NOTSUPPORTED
The primitive is known, but not supported by the DLS Provider.
@end table


@page
@node Message DL_DISABMULTI_REQ (dl_disabmulti_req_t)
@subsection Message DL_DISABMULTI_REQ (dl_disabmulti_req_t)
@tpindex dl_disabmulti_req_t
Requests the DLS Provider to disable specific multicast addresses on a per
Stream basis.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_disabmulti_req_t;
@tpindex dl_disabmulti_req_t
@end example

@subsubheading Parameters

@table @parm
@item dl_primitive
conveys
@prim{DL_DISABMULTI_REQ}
@item dl_addr_length
conveys the length of the physical address
@item dl_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
multicast address begins
@end table

@subsubheading State
This message is valid in any state in which a local acknowledgment is not
pending with the exception of
@psta{DL_UNATTACHED}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the disable request is successful, a
@prim{DL_OK_ACK}
is sent to the DLS user.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for failure
@table @perr
@item DL_BADADDR
Address information was invalid or in an incorrect format.
@item DL_NOTENAB
Address specified is not enabled.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_NOTSUPPORTED
Primitive is known, but not supported by the DLS Provider.
@end table

@page
@node Message DL_PROMISCON_REQ (dl_promiscon_req_t)
@subsection Message DL_PROMISCON_REQ (dl_promiscon_req_t)
@tpindex dl_promiscon_req_t
This primitive requests the DLS Provider to enable promiscuous mode on a per
Stream basis, either at the physical level or at the SAP level.

The DL Provider will route all received messages on the media to the DLS User
until either a
@prim{DL_DETACH_REQ}
or a
@prim{DL_PROMISCOFF_REQ}
is received or the Stream is
closed.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_level;
@} dl_promiscon_req_t;
@tpindex dl_promiscon_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_PROMISCON_REQ}
@item dl_level
indicates promiscuous mode at the physical or SAP level
@table @pval
@item DL_PROMISC_PHYS
indicates promiscuous mode at the physical level
@item DL_PROMISC_SAP
indicates promiscuous mode at the SAP level
@item DL_PROMISC_MULTI
indicates promiscuous mode for all multicast addresses
@end table
@end table

@subsubheading State
The message is valid in any state when there is no pending acknowledgment.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If enabling of promiscuous mode is successful, a
@prim{DL_OK_ACK}
is returned.  Otherwise, a
@prim{DL_ERROR_ACK}
is returned.

@subsubheading Reasons for Failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in the
@prim{DL_ERROR_ACK}.
@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider
@item DL_UNSUPPORTED
Requested service is not supplied by the provider.
@end table

@page
@node Message DL_PROMISCOFF_REQ (dl_promiscoff_req_t)
@subsection Message DL_PROMISCOFF_REQ (dl_promiscoff_req_t)
@tpindex dl_promiscoff_req_t
This primitive requests the DLS Provider to disable promiscuous mode on a per
Stream basis, either at the physical level or at the SAP level.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, which contains the following
structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_level;
@} dl_promiscoff_req_t;
@tpindex dl_promiscoff_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_PROMISCOFF_REQ}
@item dl_level
indicates promiscuous mode at the physical or SAP level
@table @pval
@item DL_PROMISC_PHYS
indicates promiscuous mode at the physical level
@item DL_PROMISC_SAP
indicates promiscuous mode at the SAP level
@item DL_PROMISC_MULTI
indicates promiscuous mode for all multicast addresses
@end table
@end table

@subsubheading State
The message is valid in any state in which the promiscuous mode is enabled and
there is no pending acknowledgment.

@subsubheading New State
The resulting state is unchanged.

@subheading Response
If the promiscuous mode disabling is successful, a
@prim{DL_OK_ACK}
is returned.  Otherwise, a
@prim{DL_ERROR_ACK}
is returned.

@subsubheading Reasons for Failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state
@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in the
@prim{DL_ERROR_ACK}.
@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider
@item DL_NOTENAB Mode not enabled.
@end table

@page
@node Message DL_OK_ACK (dl_ok_ack_t)
@subsection Message DL_OK_ACK (dl_ok_ack_t)
@tpindex dl_ok_ack_t
Acknowledges to the DLS user that a previously issued request primitive was
received successfully.  It is only initiated for those primitives that require a
positive acknowledgment.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correct_primitive;
@} dl_ok_ack_t;
@tpindex dl_ok_ack_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_OK_ACK}.
@item dl_correct_primitive
identifies the successfully received primitive that is being acknowledged.
@end table

@subsubheading State
The message is valid in response to a
@prim{DL_ATTACH_REQ},
@prim{DL_DETACH_REQ},
@prim{DL_UNBIND_REQ},
@prim{DL_CONNECT_RES},
@prim{DL_RESET_RES},
@prim{DL_DISCONNECT_REQ},
@prim{DL_SUBS_UNBIND_REQ},
@prim{DL_PROMISCON_REQ},
@prim{DL_ENABMULTI_REQ},
@prim{DL_DISABMULTI_REQ} or
@prim{DL_PROMISCOFF_REQ}
from any of several states as defined in @ref{Allowable Sequence of DLPI
Primitives}.

@subsubheading New State
The resulting state depends on the current state and is defined fully in
@ref{Allowable Sequence of DLPI Primitives}.

@page
@node Message DL_ERROR_ACK (dl_error_ack_t)
@subsection Message DL_ERROR_ACK (dl_error_ack_t)
@tpindex dl_error_ack_t
Informs the DLS user that a previously issued request or response was invalid.
It conveys the identity of the primitive in error, a @acronym{DLPI} error code, and if
appropriate, a UNIX system error code.

Whenever this primitive is generated, it indicates that the @acronym{DLPI} state is
identical to what it was before the erroneous request or response.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_error_primitive;
        ulong dl_errno;
        ulong dl_unix_errno;
@} dl_error_ack_t;
@tpindex dl_error_ack_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_ERROR_ACK}.
@item dl_error_prim
identifies the primitive in error.
@item dl_errno
conveys the @acronym{DLPI} error code associated with the failure.  See the individual
request or response for the error codes that are applicable.  In addition to
those errors:
@itemize --
@item DL_BADPRIM
error is returned if an unrecognized primitive is issued by the DLS user.
@item DL_NOTSUPPORTED
error is returned if an unsupported primitive is issued by the DLS user.
@end itemize
@item dl_unix_errno
conveys the UNIX system error code associated with the failure.  This value
should be non-zero only when dl_errno is set to
@perr{DL_SYSERR}.
It is used to report UNIX system failures that prevent the processing of a given
request or response.
@end table

@subsubheading State
The message is valid in every state where an acknowledgment or confirmation of a
previous request or response is pending.

@subsubheading New State
The resulting state is that from which the acknowledged request or response was
generated.

@page
@node Connection-mode Service Primitives
@section Connection-mode Service Primitives
@cpindex Connection establishment
@cpindex Connection mode
This section describes the service primitives that support the connection-mode
service of the data link layer.  These primitives support the connection
@cpindex Connection mode
establishment, connection-mode data transfer, and connection release services
described earlier.

@menu
* Multi-threaded Connection Establishment::
* Message DL_CONNECT_REQ (dl_connect_req_t)::
* Message DL_CONNECT_IND (dl_connect_ind_t)::
* Message DL_CONNECT_RES (dl_connect_res_t)::
* Message DL_CONNECT_CON (dl_connec t_con_t)::
* Message DL_TOKEN_REQ (dl_token_req_t)::
* Message DL_TOKEN_ACK (dl_token_ack_t)::
* Message DL_DATA_REQ::
* Message DL_DATA_IND::
* Message DL_DISCONNECT_REQ (dl_disconnect_req_t)::
* Message DL_DISCONNECT_IND (dl_disc onnect_ind_t)::
* Message DL_RESET_REQ (dl_reset_req_t)::
* Message DL_RESET_IND (dl_reset_ind_t)::
* Message DL_RESET_RES (dl_reset_res_t)::
* Message DL_RESET_CON (dl_reset_con_t)::
@end menu

@node Multi-threaded Connection Establishment
@subsection Multi-threaded Connection Establishment
@cpindex Called DLS user
@cpindex Calling DLS user
@cpindex Connection establishment
In the connection establishment model, the calling DLS user initiates a request
for a connection, and the called DLS user receives each request and either
accepts or rejects it.  In the simplest form (single threaded), the called DLS
user is passed a connect indication and the DLS provider holds any subsequent
indications until a response for the current outstanding indication is received.
At most one connect indication is outstanding at any time.

@acronym{DLPI} also enables a called DLS user to multi-thread connect indications and
responses.  This capability is desirable, for example, when imposing a priority
scheme on all DLS users attempting to establish a connection.  The DLS provider
will pass all connect indications to the called DLS user (up to some
pre-established limit as set by @prim{DL_BIND_REQ} and @prim{DL_BIND_ACK}).  The
called DLS user may then respond to the requests in any order.

To support multi-threading, a correlation value is needed to associate responses
with the appropriate connect indication.  A correlation value is contained in
each @prim{DL_CONNECT_IND}, and the DLS user must use this value in the
@prim{DL_CONNECT_RES} or @prim{DL_DISCONNECT_REQ} primitive used to accept or
reject the connect request.  The DLS user can also receive a
@prim{DL_DISCONNECT_IND} with a correlation value when the calling DLS user or
the DLS provider abort a connect request.

Once a connection has been accepted or rejected, the correlation value has no
meaning to a DLS user.  The DLS provider may reuse the correlation value in
another @prim{DL_CONNECT_IND}.  Thus, the lifetime of a correlation value is the
duration of the connection
@cpindex Connection establishment
establishment phase, and as good programming practice it should not be used for
any other purpose by the DLS provider.

The DLS provider assigns the correlation value for each connect indication.
Correlation values must be unique among all outstanding connect indications on a
given stream.  The values may, but need not, be unique across all streams to the
DLS provider.  The correlation value must be a positive, non-zero value.  There
is no implied sequencing of connect indications using the correlation value; the
values do not have to increase sequentially for each new connect indication.

@page
@node Message DL_CONNECT_REQ (dl_connect_req_t)
@subsection Message DL_CONNECT_REQ (dl_connect_req_t)
@tpindex dl_connect_req_t
@cpindex Called DLS user
@cpindex Connection establishment
Requests the DLS provider establish a data link connection with a remote DLS
user.  The request contains the @acronym{DLSAP} address of the remote (called)
DLS user and quality of service parameters to be negotiated during connection
establishment.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_req_t;
@tpindex dl_connect_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_CONNECT_REQ}.

@item dl_dest_addr_length
@cpindex Called DLS user
conveys the length of the @acronym{DLSAP} address that identifies the DLS user
with whom a connection is to be established.  If the called user is implemented
using @acronym{DLPI}, this address is the full @acronym{DLSAP} address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the destination @acronym{DLSAP} address begins.

@item dl_qos_length
conveys the length of the quality of service (@acronym{QoS}) parameter values
desired by the DLS user initiating a connection.  The desired @acronym{QoS}
values are conveyed in the appropriate structure defined in @ref{QOS Data
Structures}.  A full specification of these @acronym{QoS} parameters and rules
for negotiating their values is presented in @ref{Quality of Data Link Service}.

If the DLS user does not wish to specify a particular @acronym{QoS} value, the
value @pval{DL_QOS_DONT_CARE} may be specified.  If the DLS user does not care
to specify any @acronym{QoS} parameter values, this field may be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value
must be set to zero.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is
@psta{DL_OUTCON_PENDING}.

@subsubheading Response
@cpindex Called DLS user
@cpindex Calling DLS user
There is no immediate response to the connect request.  However, if the connect
request is accepted by the called DLS user,
@prim{DL_CONNECT_CON}
is sent to the calling DLS user, resulting in state
@psta{DL_DATAXFER}.

If the connect request is rejected by the called DLS user, the called DLS user
cannot be reached, or the DLS provider and/or called DLS user do not agree on the
specified quality of service, a
@prim{DL_DISCONNECT_IND}
is sent to the calling DLS user, resulting in state
@psta{DL_IDLE}.

If the request is erroneous, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure
@table @perr
@item DL_BADADDR
The destination @acronym{DLSAP} address was in an incorrect format or contained
invalid information.
@item DL_BADQOSPARAM
The quality of service parameters contained invalid values.
@item DL_BADQOSTYPE
The quality of service structure type was not supported by the DLS provider.
@item DL_ACCESS
The DLS user did not have proper permission to use the requested @acronym{DLSAP}
address.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the
@prim{DL_ERROR_ACK}.
@end table


@page
@node Message DL_CONNECT_IND (dl_connect_ind_t)
@subsection Message DL_CONNECT_IND (dl_connect_ind_t)
@tpindex dl_connect_ind_t
@cpindex Called DLS user
@cpindex Calling DLS user
Conveys to the local DLS user that a remote (calling) DLS user wishes to
establish a data link connection.  The indication contains the @acronym{DLSAP}
address of the calling and called DLS user, and the quality of service
parameters as specified by the calling DLS user and negotiated by the DLS
provider.

The @prim{DL_CONNECT_IND} also contains a number that allows the DLS user to
correlate a subsequent @prim{DL_CONNECT_RES}, @prim{DL_DISCONNECT_REQ}, or
@prim{DL_DISCONNECT_IND} with the indication (@pxref{Multi-threaded Connection
Establishment}).

The number of outstanding @prim{DL_CONNECT_IND} primitives issued by the DLS
provider must not exceed the value of dl_max_conind as returned on the
@prim{DL_BIND_ACK}.  If this limit is reached and an additional connect request
arrives, the DLS provider must not pass the corresponding connect indication to
the DLS user until a response is received for an already outstanding indication.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_called_addr_length;
        ulong dl_called_addr_offset;
        ulong dl_calling_addr_length;
        ulong dl_calling_addr_offset;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_ind_t;
@tpindex dl_connect_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_CONNECT_IND}.

@item dl_correlation
conveys the correlation number to be used by the DLS user to associate this
message with the
@prim{DL_CONNECT_RES},
@prim{DL_DISCONNECT_REQ},
or
@prim{DL_DISCONNECT_IND}
that is to follow.  This value, then, enables the DLS user to multi-thread
connect indications and responses.  All outstanding connect indications must
have a distinct, non-zero correlation value set by the DLS provider.

@item dl_called_addr_length
@cpindex Calling DLS user
conveys the length of the address of the @acronym{DLSAP} for which this
@prim{DL_CONNECT_IND} primitive is intended.  This address is the full
@acronym{DLSAP} address specified by the calling DLS user and is typically the
value returned on the @prim{DL_BIND_ACK} associated with the given stream.

@item dl_called_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the called @acronym{DLSAP} address begins.

@item dl_calling_addr_length
conveys the length of the address of the @acronym{DLSAP} from which the
@prim{DL_CONNECT_REQ} primitive was sent.

@item dl_calling_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the calling @acronym{DLSAP} address begins.

@item dl_qos_length
@cpindex Calling DLS user
conveys the range of quality of service parameter values desired by the calling
DLS user and negotiated by the DLS provider.  The range of @acronym{QoS} values
is conveyed in the appropriate structure defined in @ref{QOS Data Structures}.
A full specification of these @acronym{QoS} parameters and rules for negotiating
their values is presented in @ref{Quality of Data Link Service}.

For any parameter the DLS provider does not support or cannot determine, the
corresponding parameter values will be set to @pval{DL_UNKNOWN}.  If the DLS
provider does not support any @acronym{QoS} parameters, this length field will
be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value
will be set to zero.
@end table

@subsubheading State
The message is valid in state @psta{DL_IDLE}, or state @psta{DL_INCON_PENDING}
when the maximum number of outstanding @prim{DL_CONNECT_IND} primitives has not
been reached on this stream.

@subsubheading New State
The resulting state is @psta{DL_INCON_PENDING}, regardless of the current state.

@subsubheading Response
The DLS user must eventually send either @prim{DL_CONNECT_RES} to accept the
connect request or @prim{DL_DISCONNECT_REQ} to reject the connect request.  In
either case, the responding message must convey the correlation number received
in the @prim{DL_CONNECT_IND}.  The DLS provider will use the correlation number
to identify the connect request to which the DLS user is responding.

@page
@node Message DL_CONNECT_RES (dl_connect_res_t)
@subsection Message DL_CONNECT_RES (dl_connect_res_t)
@tpindex dl_connect_res_t
@cpindex Calling DLS user
Directs the DLS provider to accept a connect request from a remote (calling) DLS
user on a designated stream.  The DLS user may accept the connection on the same
stream where the connect indication arrived, or on a different stream that has
been previously bound.  The response contains the correlation number from the
corresponding @prim{DL_CONNECT_IND}, selected quality of service parameters, and
an indication of the stream on which to accept the connection.

@cpindex Connection establishment
After issuing this primitive, the DLS user may immediately begin transferring
data using the @prim{DL_DATA_REQ} primitive.  If the DLS provider receives one
or more @prim{DL_DATA_REQ} primitives from the local DLS user before it has
completed connection establishment, however, it must queue the data transfer
requests internally until the connection is successfully established.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_resp_token;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_res_t;
@tpindex dl_connect_res_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_CONNECT_RES}.

@item dl_correlation
conveys the correlation number that was received with the @prim{DL_CONNECT_IND}
associated with the connection request.  The DLS provider will use the
correlation number to identify the connect indication to which the DLS user is
responding.

@item dl_resp_token
if non-zero, conveys the token associated with the responding stream on which
the DLS provider is to establish the connection; this stream must be in the
state @psta{DL_IDLE}.  The token value for a stream can be obtained by issuing a
@prim{DL_TOKEN_REQ} on that stream.  If the DLS user is accepting the connection
on the stream where the connect indication arrived, this value must be zero.
@xref{Multi-threaded Connection Establishment}, for a description of the
connection response model.

@item dl_qos_length
@cpindex Called DLS user
conveys the length of the quality of service parameter values selected by the
called DLS user.  The selected @acronym{QoS} values are conveyed in the
appropriate structure as defined in @ref{QOS Data Structures}.  A full
specification of these @acronym{QoS} parameters and rules for negotiating their
values is presented in @ref{Quality of Data Link Service}.

If the DLS user does not care which value is selected for a particular
@acronym{QoS} parameter, the value @pval{DL_QOS_DONT_CARE} may be specified.  If
the DLS user does not care which values are selected for all @acronym{QoS}
parameters, this field may be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value
must be set to zero.
@end table

@subsubheading State
The primitive is valid in state
@psta{DL_INCON_PENDING}.

@subsubheading New State
The resulting state is
@psta{DL_CONN_RES_PENDING}.

@subsubheading Response
If the connect response is successful,
@prim{DL_OK_ACK}
is sent to the DLS user.  If no outstanding connect indications remain, the
resulting state for the current stream is
@psta{DL_IDLE};
otherwise it remains
@psta{DL_INCON_PENDING}.
For the responding stream (designated by the parameter dl_resp_token), the
resulting state is
@psta{DL_DATAXFER}.
If the current stream and responding stream are the same, the resulting state of
that stream is
@psta{DL_DATAXFER}.
These streams may only be the same when the response corresponds to the only
outstanding connect indication.

If the request fails,
@prim{DL_ERROR_ACK}
is returned on the stream where the
@prim{DL_CONNECT_RES}
primitive was received, and the resulting state of that stream and the
responding stream is unchanged.

@subsubheading Reasons for Failure
@table @perr
@item DL_BADTOKEN
The token for the responding stream was not associated with a currently open
stream.  The quality of service parameters contained invalid values.
@item DL_BADQOSTYPE
The quality of service structure type was not supported by the DLS provider.
@item DL_BADCORR
The correlation number specified in this primitive did not correspond to a
pending connect indication.
@item DL_ACCESS
The DLS user did not have proper permission to use the responding stream.
@item DL_OUTSTATE
The primitive was issued from an invalid state, or the responding stream was not
in a valid state for establishing a connection.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the
@prim{DL_ERROR_ACK}.
@item DL_PENDING
Current stream and responding stream is the same and there is more than
one outstanding connect indication.
@end table

@page
@node Message DL_CONNECT_CON (dl_connec t_con_t)
@subsection Message DL_CONNECT_CON (dl_connec t_con_t)
@tpindex dl_connect_con_t
Informs the local DLS user that the requested data link connection has been
established.  The primitive contains the @acronym{DLSAP} address of the
responding DLS user and the quality of service parameters as selected by the
responding DLS user.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_resp_addr_length;
        ulong dl_resp_addr_offset;
        ulong dl_qos_length;
        ulong dl_qos_offset;
        ulong dl_growth;
@} dl_connect_con_t;
@tpindex dl_connect_con_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_CONNECT_CON}.

@item dl_resp_addr_length
conveys the length of the address of the responding @acronym{DLSAP} associated
with the newly established data link connection.

@item dl_resp_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the responding @acronym{DLSAP} address begins.

@item dl_qos_length
conveys the length of the quality of service parameter values selected by the
responding DLS user.  The selected @acronym{QoS} values are conveyed in the
appropriate structure defined in @ref{QOS Data Structures}.  A full
specification of these @acronym{QoS} parameters and rules for negotiating their
values is presented in @ref{Quality of Data Link Service}.

For any parameter the DLS provider does not support or cannot determine, the
corresponding parameter value will be set to @pval{DL_UNKNOWN}.  If the DLS
provider does not support any @acronym{QoS} parameters, this length field will
be set to zero.

@item dl_qos_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where
the quality of service parameters begin.

@item dl_growth
defines a growth field for future enhancements to this primitive.  Its value
will be set to zero.

@end table

@subsubheading State
The message is valid in state
@psta{DL_OUTCON_PENDING}.

@subsubheading New State
The resulting state is
@psta{DL_DATAXFER}.


@node Message DL_TOKEN_REQ (dl_token_req_t)
@subsection Message DL_TOKEN_REQ (dl_token_req_t)
@tpindex dl_token_req_t
Requests that a connection response token be assigned to the stream and returned
to the DLS user.  This token can be supplied in the @prim{DL_CONNECT_RES}
primitive to indicate the stream on which a connection will be established.
Message Format The message consists of one @msg{M_PCPROTO} message block, which
contains the following structure.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_token_req_t;
@tpindex dl_token_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_TOKEN_REQ}.
@end table

@subsubheading State
The message is valid in any state in which a local acknowledgment is not
pending, as described in @ref{Allowable Sequence of DLPI Primitives}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The DLS provider responds to the information request with a
@prim{DL_TOKEN_ACK}.

@page
@node Message DL_TOKEN_ACK (dl_token_ack_t)
@subsection Message DL_TOKEN_ACK (dl_token_ack_t)
@tpindex dl_token_ack_t
This message is sent in response to
@prim{DL_TOKEN_REQ};
it conveys the connection response token assigned to the stream.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block, which contains the
following structure.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_token;
@} dl_token_ack_t;
@tpindex dl_token_ack_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_TOKEN_ACK}.
@item dl_token
conveys the connection response token associated with the stream.  This value
must be a non-zero value.  The DLS provider will generate a token value for each
stream upon receipt of the first
@prim{DL_TOKEN_REQ}
primitive issued on that stream.  The same token value will be returned in
response to all subsequent
@prim{DL_TOKEN_REQ}
primitives issued on a stream.
@end table

@subsubheading State
The message is valid in any state in response to a
@prim{DL_TOKEN_REQ}.

@subsubheading New State
The resulting state is unchanged.


@page
@node Message DL_DATA_REQ
@subsection Message DL_DATA_REQ
Conveys a complete @acronym{DLSDU} from the DLS user to the DLS provider for
transmission over the data link connection.

The DLS provider guarantees to deliver each @acronym{DLSDU} to the remote DLS
user in the same order as received from the local DLS user.  If the DLS provider
detects unrecoverable data loss during data transfer, this may be indicated to
the DLS user by a @prim{DL_RESET_IND}, or by a @prim{DL_DISCONNECT_IND} (if the
connection is lost).

@subsubheading Message Format
The message consists of one or more @msg{M_DATA} message blocks containing at
least one byte of data.

To simplify support of a read(2)/write(2) interface to the data link layer, the
DLS provider must recognize and process messages that consist of one or more
@msg{M_DATA} message blocks with no preceding @msg{M_PROTO} message block.  This
message type may originate from the write(2) system call.@footnote{This does not
imply that @acronym{DLPI} will directly support a pure read(2)/write(2).  If such an
interface is desired, a @acronym{STREAMS} module could be implemented to be pushed
above the DLS provider.}

@subsubheading State
The message is valid in state @psta{DL_DATAXFER}.  If it is received in state
@psta{DL_IDLE} or @psta{DL_PROV_RESET_PENDING}, it should be discarded without
generating an error.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is valid, no response is generated.

If the request is erroneous, a @acronym{STREAMS} @msg{M_ERROR} message should be
issued to the DLS user specifying an errno value of EPROTO.  This action should
be interpreted as a fatal, unrecoverable, protocol error.  A request is
considered erroneous under the following conditions.

@itemize --
@item The primitive was issued from an invalid state.  If the request is issued
in state @psta{DL_IDLE} or @psta{DL_PROV_RESET_PENDING}, however, it is silently
discarded with no fatal error generated.
@item The amount of data in the current @acronym{DLSDU} is not within the DLS
provider's acceptable bounds as specified by dl_min_sdu and dl_max_sdu in the
@prim{DL_INFO_ACK}.
@end itemize

@subsubheading Note (Support of Direct User-Level Access)
A @acronym{STREAMS} module would implement "more" field processing itself to
support direct user-level access.  This module could collect messages and send
them in one larger message to the DLS provider, or break large DLSDUs passed to
the DLS user into smaller messages.  The module would only be pushed if the DLS
user was a user-level process.


@page
@node Message DL_DATA_IND
@subsection Message DL_DATA_IND
Conveys a @acronym{DLSDU} from the DLS provider to the DLS user.  The DLS
provider guarantees to deliver each @acronym{DLSDU} to the local DLS user in the
same order as received from the remote DLS user.  If the DLS provider detects
unrecoverable data loss during data transfer, this may be indicated to the DLS
user by a @prim{DL_RESET_IND}, or by a @prim{DL_DISCONNECT_IND} (if the
connection is lost).

@subsubheading Message Format
The message consists of one or more @msg{M_DATA} blocks containing at least one
byte of data.

@subsubheading State
The message is valid in state @psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_DISCONNECT_REQ (dl_disconnect_req_t)
@subsection Message DL_DISCONNECT_REQ (dl_disconnect_req_t)
@tpindex dl_disconnect_req_t
Requests the DLS provider to disconnect an active data link connection or one
that was in the process of activation, either outgoing or incoming, as a result
of an earlier @prim{DL_CONNECT_IND} or @prim{DL_CONNECT_REQ}.  If an incoming
@prim{DL_CONNECT_IND} is being refused, the correlation number associated with
that connect indication must be supplied.  The message indicates the reason for
the disconnect.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_reason;
        ulong dl_correlation;
@} dl_disconnect_req_t;
@tpindex dl_disconnect_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_DISCONNECT_REQ}.
@item dl_reason
conveys the reason for the disconnect.
@subsubheading Reasons for Disconnect
@table @pval
@item DL_DISC_NORMAL_CONDITION
normal release of a data link connection
@item DL_DISC_ABNORMAL_CONDITION
abnormal release of a data link connection
@item DL_CONREJ_PERMANENT_COND
a permanent condition caused the rejection of a connect request
@item DL_CONREJ_TRANSIENT_COND
a transient condition caused the rejection of a connect request
@item DL_DISC_UNSPECIFIED
reason unspecified
@end table

@item dl_correlation
if non-zero, conveys the correlation number that was contained in the
@prim{DL_CONNECT_IND}
being rejected (@pxref{Multi-threaded Connection Establishment}).  This value
permits the DLS provider to associate the primitive with the proper
@prim{DL_CONNECT_IND}
when rejecting an incoming connection.  If the disconnect request is releasing a
connection that is already established, or is aborting a
previously sent
@prim{DL_CONNECT_REQ},
the value of dl_correlation should be zero.
@end table


@subsubheading State
The message is valid in any of the states:
@psta{DL_DATAXFER},
@psta{DL_INCON_PENDING},
@psta{DL_OUTCON_PENDING},
@psta{DL_PROV_RESET_PENDING},
@psta{DL_USER_RESET_PENDING}.

@subsubheading New State
The resulting state is one of the disconnect pending states, as defined in
@ref{Allowable Sequence of DLPI Primitives}.

@subsubheading Response
If the disconnect is successful,
@prim{DL_OK_ACK}
is sent to the DLS user resulting in state
@psta{DL_IDLE}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned, and the resulting state is unchanged.

@subsubheading Reasons for Failure
@table @perr
@item DL_BADCORR
The correlation number specified in this primitive did not correspond to a
pending connect indication.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the @prim{DL_ERROR_ACK}.

@end table


@page
@node Message DL_DISCONNECT_IND (dl_disc onnect_ind_t)
@subsection Message DL_DISCONNECT_IND (dl_disc onnect_ind_t)
@tpindex dl_disconnect_ind_t
Informs the DLS user that the data link connection on this stream has been
disconnected, or that a pending connection (either @prim{DL_CONNECT_REQ} or
@prim{DL_CONNECT_IND}) has been aborted.

The primitive indicates the origin and the cause of the disconnect.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_originator;
        ulong dl_reason;
        ulong dl_correlation;
@} dl_disconnect_ind_t;
@tpindex dl_disconnect_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_DISCONNECT_IND}.

@item dl_originator
conveys whether the disconnect was DLS user or DLS provider originated
(@pval{DL_USER}
or
@pval{DL_PROVIDER},
respectively).

@item dl_reason
conveys the reason for the disconnect.

@subsubheading Reasons for Disconnect

@table @pval
@item DL_DISC_PERMANENT_CONDITION
connection released due to permanent condition

@item DL_DISC_TRANSIENT_CONDITION
connection released due to transient condition

@item DL_CONREJ_DEST_UNKNOWN
unknown destination for connect request

@item DL_CONREJ_DEST_UNREACH_PERMANENT
could not reach destination for connect request - permanent condition

@item DL_CONREJ_DEST_UNREACH_TRANSIENT
could not reach destination for connect request - transient condition

@item DL_CONREJ_QOS_UNAVAIL_PERMANENT
@cpindex Connection establishment
requested quality of service parameters permanently unavailable during
connection establishment

@item DL_CONREJ_QOS_UNAVAIL_TRANSIENT
@cpindex Connection establishment
requested quality of service parameters temporarily unavailable during
connection establishment

@item DL_DISC_UNSPECIFIED
reason unspecified
@end table

@item dl_correlation
if non-zero, conveys the correlation number that was contained in the
@prim{DL_CONNECT_IND} that is being aborted (@pxref{Multi-threaded Connection
Establishment}).  This value permits the DLS user to associate the message with
the proper @prim{DL_CONNECT_IND}.  If the disconnect indication is indicating
the release of a connection that is already established, or is indicating the
rejection of a previously sent @prim{DL_CONNECT_REQ}, the value of
dl_correlation will be zero.
@end table

@subsubheading State
The message is valid in any of the states:
@psta{DL_DATAXFER},
@psta{DL_INCON_PENDING},
@psta{DL_OUTCON_PENDING},
@psta{DL_PROV_RESET_PENDING},
@psta{DL_USER_RESET_PENDING}.

@subsubheading New State
The resulting state is
@psta{DL_IDLE}.

@page
@node Message DL_RESET_REQ (dl_reset_req_t)
@subsection Message DL_RESET_REQ (dl_reset_req_t)
@tpindex dl_reset_req_t
Requests that the DLS provider initiate the resynchronization of a data link
connection.  This service is abortive, so no guarantee of delivery can be
assumed about data that is in transit when the reset request is initiated.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure
shown below.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_reset_req_t;
@tpindex dl_reset_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_RESET_REQ}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is
@psta{DL_USER_RESET_PENDING}.

@subsubheading Response
There is no immediate response to the reset request.  However, as
resynchronization completes,
@prim{DL_RESET_CON}
is sent to the initiating DLS user, resulting in state
@psta{DL_DATAXFER}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in the
@prim{DL_ERROR_ACK}.
@end table

@page
@node Message DL_RESET_IND (dl_reset_ind_t)
@subsection Message DL_RESET_IND (dl_reset_ind_t)
@tpindex dl_reset_ind_t
Informs the DLS user that either the remote DLS user is resynchronizing the data
link connection, or the DLS provider is reporting loss of data for which it can
not recover.  The indication conveys the reason for the reset.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_originator;
        ulong dl_reason;
@} dl_reset_ind_t;
@tpindex dl_reset_ind_t
@end example

@subsubheading Parameters
@table @parm

@item dl_primitive
conveys
@prim{DL_RESET_IND}.

@item dl_originator
conveys whether the reset was originated by the DLS user or DLS provider
(@pval{DL_USER}
or
@pval{DL_PROVIDER},
respectively).

@item dl_reason
conveys the reason for the reset.

@subsubheading Reasons for Reset

@table @pval

@item DL_RESET_FLOW_CONTROL
indicates flow control congestion

@item DL_RESET_LINK_ERROR
indicates a data link error situation

@item DL_RESET_RESYNCH
indicates a request for resynchronization of a data link connection.

@end table
@end table

@subsubheading State
The message is valid in state
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is
@psta{DL_PROV_RESET_PENDING}.

@subsubheading Response
The DLS user should issue a
@prim{DL_RESET_RES}
primitive to continue the resynchronization procedure.

@page
@node Message DL_RESET_RES (dl_reset_res_t)
@subsection Message DL_RESET_RES (dl_reset_res_t)
@tpindex dl_reset_res_t
Directs the DLS provider to complete resynchronizing the data link connection.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_reset_res_t;
@tpindex dl_reset_res_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_RESET_RES}.
@end table

@subsubheading State
The primitive is valid in state
@psta{DL_PROV_RESET_PENDING}.

@subsubheading New State
The resulting state is
@psta{DL_RESET_RES_PENDING}.

@subsubheading Response
If the reset response is successful,
@prim{DL_OK_ACK}
is sent to the DLS user resulting in state
@psta{DL_DATAXFER}.

If the reset response is erroneous,
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_SYSERR
A system error has occurred and the UNIX system error is indicated in
the
@prim{DL_ERROR_ACK}.

@end table


@page
@node Message DL_RESET_CON (dl_reset_con_t)
@subsection Message DL_RESET_CON (dl_reset_con_t)
@tpindex dl_reset_con_t
Informs the reset-initiating DLS user that the reset has completed.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
@} dl_reset_con_t;
@tpindex dl_reset_con_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_RESET_CON}.
@end table

@subsubheading State
The message is valid in state
@psta{DL_USER_RESET_PENDING}.

@subsubheading New State
The resulting state is
@psta{DL_DATAXFER}.

@page
@node Connectionless-mode Service Primitives
@section Connectionless-mode Service Primitives
@cpindex Connectionless mode
This section describes the primitives that support the connectionless-mode
service of the data link layer.  These primitives support the connectionless data
transfer service described earlier.

@menu
* Message DL_UNITDATA_REQ (dl_unitdata_req_t)::
* Message DL_UNITDATA_IND (dl_unitdata_ind_t)::
* Message DL_UDERROR_IND (dl_uderror_ind_t)::
* Message DL_UDQOS_REQ (dl_udqos_req_t)::
@end menu

@page
@node Message DL_UNITDATA_REQ (dl_unitdata_req_t)
@subsection Message DL_UNITDATA_REQ (dl_unitdata_req_t)
@tpindex dl_unitdata_req_t
Conveys one @acronym{DLSDU} from the DLS user to the DLS provider for transmission to a
peer DLS user.

@cpindex Connectionless mode
Because connectionless data transfer is an unacknowledged service, the DLS
provider makes no guarantees of delivery of connectionless DLSDUs.  It is the
responsibility of the DLS user to do any necessary sequencing or retransmission
of DLSDUs in the event of a presumed loss.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below, followed by one or more @msg{M_DATA} blocks containing at least one byte of
data.  The amount of user data that may be transferred in a single
@acronym{DLSDU} is
limited.  This limit is conveyed by the parameter dl_max_sdu in the
@prim{DL_INFO_ACK}
primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        dl_priority_t dl_priority;
@} dl_unitdata_req_t;
@tpindex dl_unitdata_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_UNITDATA_REQ}.

@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS user.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_priority
indicates the priority value within the supported range for this particular
@acronym{DLSDU}.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the DLS provider accepts the data for transmission, there is no response.
This does not, however, guarantee that the data will be delivered to the
@cpindex Connectionless mode
destination DLS user, since the connectionless data transfer is not a confirmed
service.

If the request is erroneous, message
@prim{DL_UDERROR_IND}
is returned, and the resulting state is unchanged.

If for some reason the request cannot be processed, the DLS provider may
generate a
@prim{DL_UDERROR_IND}
to report the problem.  There is, however, no guarantee that such an error
@cpindex Connectionless mode
report will be generated for all undeliverable data units, since connectionless
data transfer is not a confirmed service.

@subsubheading Reasons for Failure
@table @perr
@item DL_BADADDR
The destination @acronym{DLSAP} address was in an incorrect format or contained
invalid information.

@item DL_BADDATA
The amount of data in the current @acronym{DLSDU} exceeded the DLS provider's @acronym{DLSDU} limit.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_UNSUPPORTED
Requested priority not supplied by provider.

@end table

@page
@node Message DL_UNITDATA_IND (dl_unitdata_ind_t)
@subsection Message DL_UNITDATA_IND (dl_unitdata_ind_t)
@tpindex dl_unitdata_ind_t
Conveys one @acronym{DLSDU} from the DLS provider to the DLS user.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below, followed by one or more @msg{M_DATA} blocks containing at least one byte of
data.  The amount of user data that may be transferred in a single
@acronym{DLSDU} is
limited.  This limit is conveyed by the parameter dl_max_sdu in the
@prim{DL_INFO_ACK}
primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_group_address;
@} dl_unitdata_ind_t;
@tpindex dl_unitdata_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_UNITDATA_IND}.

@item dl_dest_addr_length
conveys the length of the address of the @acronym{DLSAP} where this
@prim{DL_UNITDATA_IND}
is intended to be delivered.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the @acronym{DLSAP} address of the sending DLS user.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@item dl_group_address
is set by the DLS Provider upon receiving and passing upstream a data message
when the destination address of the data message is a multicast or broadcast
address.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_UDERROR_IND (dl_uderror_ind_t)
@subsection Message DL_UDERROR_IND (dl_uderror_ind_t)
@tpindex dl_uderror_ind_t
Informs the DLS user that a previously sent
@prim{DL_UNITDATA_REQ}
produced an error or could not be delivered.  The primitive indicates the
destination @acronym{DLSAP} address associated with the failed request, and conveys an
error value that specifies the reason for failure.

@subsubheading Message Format
The message consists of either one @msg{M_PROTO} message block or one
@msg{M_PCPROTO}
message block containing the structure shown below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_unix_errno;
        ulong dl_errno;
@} dl_uderror_ind_t;
@tpindex dl_uderror_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_UDERROR_IND}.

@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS user.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_unix_errno
conveys the UNIX system error code associated with the failure.  This value
should be non-zero only when dl_errno is set to
@perr{DL_SYSERR}.
It is used to report UNIX system failures that prevent the processing of a given
request.

@item dl_errno
conveys the @acronym{DLPI} error code associated with the failure.  See Reasons for
Failure in the description of
@prim{DL_UNITDATA_REQ}
for the error codes that apply to an erroneous
@prim{DL_UNITDATA_REQ}.
In addition, the error value
@perr{DL_UNDELIVERABLE}
may be returned if the request was valid but for some reason the DLS provider
could not deliver the data unit (e.g.  due to lack of sufficient local buffering
to store the data unit).  There is, however, no guarantee that such an error
report will be generated for all
@cpindex Connectionless mode
undeliverable data units, since connectionless data transfer is not a confirmed
service.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.


@page
@node Message DL_UDQOS_REQ (dl_udqos_req_t)
@subsection Message DL_UDQOS_REQ (dl_udqos_req_t)
@tpindex dl_udqos_req_t
Requests the DLS provider to apply the specified quality of service parameter
values to subsequent data unit transmissions.  These new values will remain in
effect until another
@prim{DL_UDQOS_REQ}
is issued.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_qos_length;
        ulong dl_qos_offset;
@} dl_udqos_req_t;
@tpindex dl_udqos_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_UDQOS_REQ}.

@item dl_qos_length
conveys the length, in bytes, of the requested quality of service parameter
values.  The values are conveyed in the appropriate structure defined in
@ref{QOS Data Structures}.  The available range of @acronym{QoS} values that may be
selected is specified by the dl_qos_range_length and dl_qos_range_offset
parameters in the
@prim{DL_INFO_ACK}
primitive.

For any parameter whose value the DLS user does not wish to select, the value
@pval{DL_QOS_DONT_CARE}
may be set and the DLS provider will maintain the current value for that
parameter.  @xref{Quality of Data Link Service}, for a full description of the
quality of service parameters.

@item dl_qos_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
quality of service parameters begin.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is
@psta{DL_UDQOS_PENDING}.

@subsubheading Response
If the quality of service request is successful,
@prim{DL_OK_ACK}
is sent to the DLS user and the resulting state is
@psta{DL_IDLE}.

If the request fails, message
@prim{DL_ERROR_ACK}
is returned and the resulting state is unchanged.

@subsubheading Reasons for Failure
@table @perr
@item DL_BADQOSPARAM
The quality of service parameters contained values outside the range of those
supported by the DLS provider.

@item DL_BADQOSTYPE
The quality of service structure type was not supported by the DLS provider.

@item DL_OUTSTATE
The primitive was issued from an invalid state.

@end table

@page
@node Primitives to handle XID and TEST operations
@section Primitives to handle XID and TEST operations

@menu
* Message DL_TEST_REQ (dl_test_req_t)::
* Message DL_TEST_IND (dl_test_ind_t)::
* Message DL_TEST_RES (dl_test_res_t)::
* Message DL_TEST_CON (dl_test_con_t)::
* Message DL_XID_REQ (dl_xid_req_t)::
* Message DL_XID_IND (dl_xid_ind_t)::
* Message DL_XID_RES (dl_xid_res_t)::
* Message DL_XID_CON (dl_xid_con_t)::
@end menu

This section describes the service primitives that support the XID and TEST
operations.  The DLS User can issue these primitives to the DLS Provider
requesting the provider to send an XID or a TEST frame.  On receipt of an XID or
TEST frame from the remote side, the DLS Provider can send the appropriate
indication to the User.

@page
@node Message DL_TEST_REQ (dl_test_req_t)
@subsection Message DL_TEST_REQ (dl_test_req_t)
@tpindex dl_test_req_t
Conveys one TEST command @acronym{DLSDU} from the DLS User to the DLS Provider for
transmission to a peer DLS Provider.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_test_req_t;
@tpindex dl_test_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys @prim{DL_TEST_REQ}

@item dl_flag
indicates flag values for the request as follows:

@table @pval
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in states
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
On an invalid TEST command request, a
@prim{DL_ERROR_ACK}
is issued to the user.  If the DLS Provider receives a response from the remote
side, a
@prim{DL_TEST_CON}
is issued to the DLS User.  It is recommended that the DLS User use a timeout
procedure to recover from a situation when there is no response from the peer
DLS User.

@subsubheading Reasons for failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state

@item DL_BADADDR
The @acronym{DLSAP} address information was invalid or was in an incorrect format.

@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in
the @prim{DL_ERROR_ACK}.

@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider

@item DL_TESTAUTO
Previous bind request specified automatic handling of TEST responses.

@item DL_UNSUPPORTED
Requested service not supplied by provider.

@end table

@page
@node Message DL_TEST_IND (dl_test_ind_t)
@subsection Message DL_TEST_IND (dl_test_ind_t)
@tpindex dl_test_ind_t
Conveys the TEST response/indication @acronym{DLSDU} from the DLS Provider to the DLS
User.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_test_ind_t;
@tpindex dl_test_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_TEST_IND}

@item dl_flag
indicates the flag values associated with the received TEST frame:

@table @pval
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the source @acronym{DLSAP} address.  If the source user is
implemented using @acronym{DLPI}, this address if the full @acronym{DLSAP} address returned on the
@prim{DL_BIND_ACK}.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in states
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_TEST_RES (dl_test_res_t)
@subsection Message DL_TEST_RES (dl_test_res_t)
@tpindex dl_test_res_t
Conveys the TEST response @acronym{DLSDU} from the DLS User to the DLS Provider in
response to a
@prim{DL_TEST_IND}.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_test_res_t;
@tpindex dl_test_res_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_TEST_RES}

@item dl_flag
indicates the flag values for the response as follows:

@table @pval
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in states
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_TEST_CON (dl_test_con_t)
@subsection Message DL_TEST_CON (dl_test_con_t)
@tpindex dl_test_con_t
Conveys the TEST response @acronym{DLSDU} from the DLS Provider to the DLS User in
response to a
@prim{DL_TEST_REQ}.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_test_con_t;
@tpindex dl_test_con_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_TEST_RES}

@item dl_flag
indicates the flag values for the request as follows:

@table @pval
@item DL_POLL_FINAL
indicates if the poll/final bit is set.

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the source @acronym{DLSAP} address.  If the source user is
implemented using @acronym{DLPI}, this address is the full @acronym{DLSAP} address returned on the
@prim{DL_BIND_ACK}.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in states
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_XID_REQ (dl_xid_req_t)
@subsection Message DL_XID_REQ (dl_xid_req_t)
@tpindex dl_xid_req_t
Conveys one XID @acronym{DLSDU} from the DLS User to the DLS Provider for transmission to
a peer DLS User.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_xid_req_t;
@tpindex dl_xid_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive conveys
@prim{DL_XID_REQ}

@item dl_flag
indicates the flag values for the response as follows:

@table @pval
@item DL_POLL_FINAL
indicates status of the poll/final bit in the xid frame.

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the @prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
On an invalid XID request, a
@prim{DL_ERROR_ACK}
is issued to the user.  If the remote side responds to the XID request, a
@prim{DL_XID_CON}
will be sent to the User.  It is recommended that the DLS User use a timeout
procedure on an XID_REQ.  The timeout may be used if the remote side does not
respond to the XID request.

@subsubheading Reasons for failure
@table @perr
@item DL_BADDATA
The amount of data in the current @acronym{DLSDU} exceeded the DLS Provider's @acronym{DLSDU} limit.

@item DL_XIDAUTO
Previous bind request specified Provider would handle XID.

@item DL_OUTSTATE
The primitive was issued from an invalid state

@item DL_BADADDR
The @acronym{DLSAP} address information was invalid or was in an incorrect format.

@item DL_SYSERR
A System error has occurred and the UNIX System error is indicated in
the @prim{DL_ERROR_ACK}.

@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider

@end table

@page
@node Message DL_XID_IND (dl_xid_ind_t)
@subsection Message DL_XID_IND (dl_xid_ind_t)
@tpindex dl_xid_ind_t
Conveys an XID @acronym{DLSDU} from the DLS Provider to the DLS User.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_xid_ind_t;
@tpindex dl_xid_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_XID_IND}

@item dl_flag
conveys the flag values associated with the received XID frame.

@table @pval
@item DL_POLL_FINAL
indicates if the received xid frame had the poll/final bit set.

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the source @acronym{DLSAP} address.  If the source user is
implemented using @acronym{DLPI}, this address if the full @acronym{DLSAP} address returned on the
@prim{DL_BIND_ACK}.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in state
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The DLS User must respond with a
@prim{DL_XID_RES}.

@page
@node Message DL_XID_RES (dl_xid_res_t)
@subsection Message DL_XID_RES (dl_xid_res_t)
@tpindex dl_xid_res_t
Conveys an XID @acronym{DLSDU} from the DLS User to the DLS Provider in response to a
@prim{DL_XID_IND}.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is
as follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
@} dl_xid_res_t;
@tpindex dl_xid_res_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive conveys
@prim{DL_XID_RES}

@item dl_flag
conveys the flag values associated with the received XID frame.

@table @pval
@item DL_POLL_FINAL

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in states
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_XID_CON (dl_xid_con_t)
@subsection Message DL_XID_CON (dl_xid_con_t)
@tpindex dl_xid_con_t
Conveys an XID @acronym{DLSDU} from the DLS Provider to the DLS User in response to a
@prim{DL_XID_REQ}.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block, followed by zero or more
@msg{M_DATA} blocks containing zero or more bytes of data.  The message structure is as
follows:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_flag;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_xid_con_t;
@tpindex dl_xid_con_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_XID_CON}

@item dl_flag
conveys the flag values associated with the received XID frame.

@table @pval
@item DL_POLL_FINAL

@end table
@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the source @acronym{DLSAP} address.  If the source user is
implemented using @acronym{DLPI}, this address is the full @acronym{DLSAP} address returned on the
@prim{DL_BIND_ACK}.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@end table

@subsubheading State
The message is valid in states
@psta{DL_IDLE}
and
@psta{DL_DATAXFER}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Acknowledged Connectionless-mode Service Primitives
@section Acknowledged Connectionless-mode Service Primitives

@menu
* Message DL_DATA_ACK_REQ (dl_data_ack_req_t)::
* Message DL_DATA_ACK_IND (dl_data_ack_ind_t)::
* Message DL_DATA_ACK_STATUS_IND (dl_data_ack_status_ind_t)::
* Message DL_REPLY_REQ (dl_reply_req_t)::
* Message DL_REPLY_IND (dl_reply_ind_t)::
* Message DL_REPLY_STATUS_IND (dl_reply_status_ind_t)::
* Message DL_REPLY_UPDATE_REQ (dl_reply_update_req_t)::
* Message DL_REPLY_UPDATE_STATUS_IND (dl_reply_update_status_ind_t)::
@end menu

@cpindex Connectionless mode
This section describes the primitives that support the acknowledged
connectionless-mode service of the data link layer.  These primitives support the
acknowledged connectionless data transfer service described earlier.

@page
@node Message DL_DATA_ACK_REQ (dl_data_ack_req_t)
@subsection Message DL_DATA_ACK_REQ (dl_data_ack_req_t)
@tpindex dl_data_ack_req_t
@cpindex Connectionless mode
This request is passed to the Data Link Provider to request that a
@acronym{DLSDU} be sent
to a peer DLS User using acknowledged connectionless mode data unit transmission
procedures.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below,
followed by one or more @msg{M_DATA} blocks containing one or more bytes of data.  The
amount of user data that may be transferred in a single @acronym{DLSDU} is limited.  This
limit is conveyed by the parameter dl_max_sdu in the
@prim{DL_INFO_ACK}
primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_data_ack_req_t;
@tpindex dl_data_ack_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_DATA_ACK_REQ}

@item dl_correlation
Conveys a unique identifier which will be returned in the
@prim{DL_DATA_ACK_STATUS_IND}
primitive to allow the DLS User to correlate the status to the appropriate
@prim{DL_DATA_ACK_REQ} primitive.

@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the @acronym{DLSAP} address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@item dl_priority
indicates the priority value within the supported range for this particular
@acronym{DLSDU}.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@table @pval
@item DL_RQST_RSP
Request acknowledgment service from the medium access control sublayer
if supported

@item DL_RQST_NORSP
No acknowledgment service requested from the medium access control sublayer.

@end table
@end table

@subsubheading State
This message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is erroneous, message
@prim{DL_ERROR_ACK}
is returned, and the resulting state is unchanged.

If the DLS Provider accepts the data for transmission, a
@prim{DL_DATA_ACK_STATUS_IND} is returned.

@cpindex Connectionless mode
This indication will indicate the success or failure of the data transmission.
Although the exchange service is connectionless, in-sequence delivery is
guaranteed for data sent by the initiating station.

@subsubheading Reasons for Failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_BADADDR
The destination @acronym{DLSAP} address was in an incorrect format or contained invalid
information.

@item DL_NOTSUPPORTED
Primitive is valid, but not supported.

@item DL_BADDATA
The amount of data in the current @acronym{DLSDU} exceeded the DLS provider's @acronym{DLSDU} limit.

@item DL_UNSUPPORTED
Requested service or priority not supported by Provider (Request with response at
the Medium Access Control sublayer).

@end table

@page
@node Message DL_DATA_ACK_IND (dl_data_ack_ind_t)
@subsection Message DL_DATA_ACK_IND (dl_data_ack_ind_t)
@tpindex dl_data_ack_ind_t
Conveys one @acronym{DLSDU} from the DLS Provider to the DLS User.  This primitive
indicates the arrival of anon-null, non-duplicate @acronym{DLSDU} from a peer Data Link
User entity.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below,
followed by one or more @msg{M_DATA} blocks containing one or more bytes of data.  The
amount of user data that may be transferred in a single @acronym{DLSDU} is limited.  This
limit is conveyed by the parameter dl_max_sdu in the
@prim{DL_INFO_ACK}
primitive.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_data_ack_ind_t;
@tpindex dl_data_ack_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_DATA_ACK_IND}

@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the @acronym{DLSAP} address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.  address returned on the
@prim{DL_BIND_ACK}.

@item dl_priority
priority provided for the data unit transmission.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@table @pval
@item DL_RQST_RSP
Use acknowledgment service in the medium access control sublayer.

@item DL_RQST_NORSP No
acknowledgment service to be used in the medium access control sublayer.

@end table
@end table

@subsubheading State
This message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_DATA_ACK_STATUS_IND (dl_data_ack_status_ind_t)
@subsection Message DL_DATA_ACK_STATUS_IND (dl_data_ack_status_ind_t)
@tpindex dl_data_ack_status_ind_t
Conveys the results of the previous associated
@prim{DL_DATA_ACK_REQ}
from the DLS Provider to the DLS User.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below.
@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_status;
@} dl_data_ack_status_ind_t;
@tpindex dl_data_ack_status_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_DATA_ACK_STATUS_IND}

@item dl_correlation
conveys the unique identifier passed with the
@prim{DL_DATA_ACK_REQ}
primitive, to allow the DLS User correlate the status to the appropriate
@prim{DL_DATA_ACK_REQ}.

@item dl_status
@cpindex Connectionless mode
indicates the success or failure of the previous associated acknowledged
connectionless-mode data unit transmission request.

@table @pval
@item DL_CMD_OK
Command accepted.

@item DL_CMD_RS
Unimplemented or inactivated service.

@item DL_CMD_UE
LLC User Interface error

@item DL_CMD_PE
Protocol error

@item DL_CMD_IP
Permanent implementation dependent error

@item DL_CMD_UN
Resources temporarily unavailable.

@item DL_CMD_IT
Temporary implementation dependent error.

@end table
@end table

@subsubheading State
This message is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_REPLY_REQ (dl_reply_req_t)
@subsection Message DL_REPLY_REQ (dl_reply_req_t)
@tpindex dl_reply_req_t
@cpindex Connectionless mode
This request primitive is passed to the DLS Provider by the DLS User to request
that a @acronym{DLSDU} be returned from a peer DLS Provider or that DLSDUs be exchanged
between stations using acknowledged connectionless mode data unit exchange
procedures.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below,
followed by one or more @msg{M_DATA} blocks with one or more bytes of data.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_reply_req_t;
@tpindex dl_reply_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_REPLY_REQ}

@item dl_correlation
Conveys a unique identifier which will be returned in the
@prim{DL_REPLY_STATUS_IND}
primitive to allow the DLS User to correlate the status to the appropriate
@prim{DL_REPLY_REQ} primitive.

@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the @acronym{DLSAP} address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@item dl_priority
priority provided for the data unit transmission.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@end table

@subsubheading State
This primitive is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is erroneous, message
@prim{DL_ERROR_ACK}
is returned, and the resulting state is unchanged.  If the message is valid, a
@prim{DL_REPLY_STATUS_IND} is returned.
@cpindex Connectionless mode
This will indicate the success or failure of the previous associated acknowledged
connectionless-mode data unit exchange.

@subsubheading Reasons for Failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_BADADDR
The destination @acronym{DLSAP} address was in an incorrect format or contained
invalid information.

@item DL_NOTSUPPORTED
Primitive is valid, but not supported.

@item DL_BADDATA
The amount of data in the current @acronym{DLSDU} exceeded the DLS provider's @acronym{DLSDU} limit.

@item DL_UNSUPPORTED
Requested service not supported by Provider (Request with response at the Medium
Access Control sublayer).

@end table

@page
@node Message DL_REPLY_IND (dl_reply_ind_t)
@subsection Message DL_REPLY_IND (dl_reply_ind_t)
@tpindex dl_reply_ind_t
This primitive is the service indication primitive for the acknowledged
@cpindex Connectionless mode
connectionless-mode data unit exchange service.  It is passed from the DLS
Provider to the DLS User to indicate either a successful request of a
@acronym{DLSDU} from
the peer data
link user entity, or exchange of DLSDUs with a peer data link user entity.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below,
followed by zero or more @msg{M_DATA} blocks.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_dest_addr_length;
        ulong dl_dest_addr_offset;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
        ulong dl_priority;
        ulong dl_service_class;
@} dl_reply_ind_t;
@tpindex dl_reply_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys @prim{DL_REPLY_IND}

@item dl_dest_addr_length
conveys the length of the @acronym{DLSAP} address of the destination DLS User.  If the
destination user is implemented using @acronym{DLPI}, this address is the full
@acronym{DLSAP}
address returned on the
@prim{DL_BIND_ACK}.

@item dl_dest_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
destination @acronym{DLSAP} address begins.

@item dl_src_addr_length
conveys the length of the @acronym{DLSAP} address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@item dl_priority
priority provided for the data unit transmission.

@item dl_service_class
Specifies whether or not an acknowledge capability in the medium access control
sublayer is to be used for the data unit transmission.

@end table

@subsubheading State
This primitive is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_REPLY_STATUS_IND (dl_reply_status_ind_t)
@subsection Message DL_REPLY_STATUS_IND (dl_reply_status_ind_t)
@tpindex dl_reply_status_ind_t
This indication primitive is passed from the DLS Provider to the DLS User to
indicate the success or failure of the previous associated acknowledged
@cpindex Connectionless mode
connectionless mode data unit exchange request.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below,
followed by zero or more @msg{M_DATA} blocks.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_status;
@} dl_reply_status_ind_t;
@tpindex dl_reply_status_ind_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_REPLY_STATUS_IND}

@item dl_correlation
conveys the unique identifier passed with the
@prim{DL_REPLY_REQ}
primitive, to allow the DLS User correlate the status to the appropriate
@prim{DL_REPLY_REQ}.

@item dl_status
Indicates the success or failure of the previous associated acknowledged
@cpindex Connectionless mode
connectionless-mode data unit exchange request.

@table @pval
@item DL_CMD_OK
Command accepted.

@item DL_CMD_RS
Unimplemented or inactivated service.

@item DL_CMD_UE
LLC User Interface error

@item DL_CMD_PE
Protocol error

@item DL_CMD_IP
Permanent implementation dependent error

@item DL_CMD_UN
Resources temporarily available.

@item DL_CMD_IT
Temporary implementation dependent error.

@item DL_RSP_OK
Response @acronym{DLSDU} present.

@item DL_RSP_RS
Unimplemented or inactivated service.

@item DL_RSP_NE
Response @acronym{DLSDU} never submitted.

@item DL_RSP_NR
Response @acronym{DLSDU} not requested.

@item DL_RSP_UE
LLC User interface error.

@item DL_RSP_IP
Permanent implementation dependent error.

@item DL_RSP_UN
Resources temporarily unavailable.

@item DL_RSP_IT
Temporary implementation dependent error.

@end table
@end table

@subsubheading State
This primitive is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_REPLY_UPDATE_REQ (dl_reply_update_req_t)
@subsection Message DL_REPLY_UPDATE_REQ (dl_reply_update_req_t)
@tpindex dl_reply_update_req_t
Conveys a @acronym{DLSDU} to the DLS Provider from the DLS User to be held by the DLS
Provider and sent out At later time when requested to do so by the peer DLS
Provider.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below,
followed by one or more @msg{M_DATA} blocks.

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_src_addr_length;
        ulong dl_src_addr_offset;
@} dl_reply_update_req_t;
@tpindex dl_reply_update_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_REPLY_UPDATE_REQ}

@item dl_correlation
conveys context specific information to be returned in the
@prim{DL_REPLY_UPDATE_STATUS_IND}
primitive to allow the DLS User correlate the status to the appropriate previous
request.

@item dl_src_addr_length
conveys the length of the @acronym{DLSAP} address of the source DLS User.

@item dl_src_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block where the
source @acronym{DLSAP} address begins.

@end table

@subsubheading State
This primitive is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
If the request is erroneous, a
@prim{DL_ERROR_ACK}
is returned with the appropriate error code.  Otherwise, a
@prim{DL_REPLY_UPDATE_STATUS_IND}
is returned, which indicates the success or failure of the
@prim{DL_REPLY_UPDATE_REQ}.

@subsubheading Reasons for failure
@table @perr
@item DL_OUTSTATE
The primitive was issued from an invalid state.

@item DL_BADDATA
The amount of data in the @acronym{DLSDU} exceeded the DLS Provider's
@acronym{DLSDU} limit.

@item DL_NOTSUPPORTED
Primitive is known, but not supported.

@end table

@page
@node Message DL_REPLY_UPDATE_STATUS_IND (dl_reply_update_status_ind_t)
@subsection Message DL_REPLY_UPDATE_STATUS_IND (dl_reply_update_status_ind_t)
@tpindex dl_reply_update_status_ind_t
This primitive is the service confirmation primitive for the reply data unit
preparation service.  This primitive is sent to the DL User from the DLS Provider
to indicate the success or failure of the previous associated data unit
preparation
request.

@subsubheading Message Format
Consists of one @msg{M_PROTO} message block containing the structure shown below.
@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_correlation;
        ulong dl_status;
@} dl_reply_update_req_t;
@tpindex dl_reply_update_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
DL_UPDATE_STATUS_IND

@item dl_correlation
Indicates the context information passed with the
@prim{DL_REPLY_UPDATE_REQ}
to allow the DLS User correlate the status with the appropriate previous
request.

@item dl_status
indicates the success or failure of the previous associated data unit
preparation request.

@table @pval
@item DL_CMD_OK
Command accepted.

@item DL_CMD_RS
Unimplemented or inactivated service.

@item DL_CMD_UE
LLC User Interface error

@item DL_CMD_PE
Protocol error

@item DL_CMD_IP
Permanent implementation dependent error

@item DL_CMD_UN
Resources temporarily available.

@item DL_CMD_IT
Temporary implementation dependent error.

@item DL_RSP_OK
Response @acronym{DLSDU} present.

@item DL_RSP_RS
Unimplemented or inactivated service.

@item DL_RSP_NE
Response @acronym{DLSDU} never submitted.

@item DL_RSP_NR
Response @acronym{DLSDU} not requested.

@item DL_RSP_UE
LLC User interface error.

@item DL_RSP_IP
Permanent implementation dependent error.

@item DL_RSP_UN
Resources temporarily unavailable.

@item DL_RSP_IT
Temporary implementation dependent error.

@end table
@end table

@subsubheading State
This primitive is valid in state
@psta{DL_IDLE}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Quality of Data Link Service
@chapter Quality of Data Link Service

@menu
* Overview of Quality of Service::
* QOS Parameter Definitions::
* QOS Data Structures::
* Procedures for QOS Negotiation and Selection::
@end menu

The quality of data link service is defined by the term "Quality of Service"
(@acronym{QoS}), and describes certain characteristics of transmission between two DLS
users.  These characteristics are attributable solely to the DLS provider, but
are observable by the DLS users.  The visibility of @acronym{QoS} characteristics enables a
DLS user to determine, and possibly negotiate, the characteristics of
transmission needed to communicate with the remote DLS user.

@page
@node Overview of Quality of Service
@section Overview of Quality of Service

@menu
* Connection-mode Service (2)::
* QOS for Connectionless-mode and Acknowledged Connectionless-mode Service::
@end menu

Quality of service characteristics apply to both the connection and
@cpindex Connectionless mode
connectionless modes of service.  The semantics for each mode are discussed below.

@page
@node Connection-mode Service (2)
@subsection Connection-mode Service
@cpindex Connection mode
"Quality of Service" (@acronym{QoS}) refers to certain characteristics of a data link
@cpindex Communication endpoint
connection as observed between the connection endpoints.  @acronym{QoS} describes the
specific aspects of a data link connection that are attributable to the DLS
provider.  @acronym{QoS} is defined in terms of @acronym{QoS} parameters.  The parameters give DLS
users a means of specifying their needs.  These parameters are divided into two
groups, based on how their values are determined:

@itemize @bullet
@item @acronym{QoS} parameters that are negotiated on a per-connection basis during
@cpindex Connection establishment
connection establishment; and
@item @acronym{QoS} parameters that are not negotiated during connection establishment.
@cpindex Connection establishment
The values are determined or known through other methods, usually administrative.
@end itemize

@cpindex Connection establishment
The @acronym{QoS} parameters that can be negotiated during connection establishment are:
throughput, transit delay, priority, and protection.  The @acronym{QoS} parameters for
throughput and transit delay are negotiated end-to-end between the two DLS users
and the DLS provider.  The @acronym{QoS} parameters for priority and protection
are negotiated locally by each DLS user with the DLS provider.  The
@acronym{QoS} parameters
that cannot be negotiated are residual error rate and resilience.
@ref{Procedures for QOS Negotiation and Selection}, describes the rules for
@acronym{QoS}
negotiation.

@cpindex Connection establishment
Once the connection is established, the agreed @acronym{QoS} values are not renegotiated
at any point.  There is no guarantee by any DLS provider that the original
@acronym{QoS}
values will be maintained, and the DLS users are not informed if @acronym{QoS} changes.
The DLS provider also need only record those @acronym{QoS} values selected at connection
establishment for return in response to the
@prim{DL_INFO_REQ}
primitive.

@node QOS for Connectionless-mode and Acknowledged Connectionless-mode Service
@subsection QOS for Connectionless-mode and Acknowledged Connectionless-mode Service
@cpindex Connectionless mode
The @acronym{QoS} for connectionless-mode and acknowledged connectionless-mode
service refers to characteristics of the data link layer between two DLSAPs,
attributable to the DLS provider.  The @acronym{QoS} applied to each
@prim{DL_UNITDATA_REQ}/@prim{DL_DATA_ACK_REQ} primitive may be independent of
the @acronym{QoS} applied to preceding and following
@prim{DL_UNITDATA_REQ}/@prim{DL_DATA_ACK_REQ} primitives.  @acronym{QoS} cannot
be negotiated between two DLS users as in the
@cpindex Connection mode
connection-mode service.  Every @prim{DL_UNITDATA_REQ}/@prim{DL_DATA_ACK_REQ}
primitive may have certain @acronym{QoS} values associated with it.  The
supported range of @acronym{QoS} parameter values is made known to the DLS user
in response to the @prim{DL_INFO_REQ} primitive.  The DLS user may select
specific @acronym{QoS} parameter values to be associated with subsequent data
unit transmissions using the @prim{DL_UDQOS_REQ} primitive.  This selection is a
strictly local management function.  If different @acronym{QoS} values are to be
associated with each transmission, @prim{DL_UDQOS_REQ} may be issued to alter
those values before each @prim{DL_UNITDATA_REQ}/@prim{DL_DATA_ACK_REQ} is
issued.

@page
@node QOS Parameter Definitions
@section QOS Parameter Definitions

@menu
* Throughput::
* Transit Delay::
* Priority::
* Protection::
* Residual Error Rate::
* Resilience::
@end menu

@cpindex Connection establishment
This section describes the quality of service parameters supported by
@acronym{DLPI} for
@cpindex Connectionless mode
@cpindex Connection mode
both connection-mode and connectionless-mode services.  The following table
summarizes the supported parameters.  It indicates to which service mode
(connection, connectionless, or both) the parameter applies.  For those
@cpindex Connection mode
parameters supported by the connection-mode service, the table also indicates
whether the parameter value is negotiated during connection establishment.  If
so, the table further indicates whether the @acronym{QoS} values are negotiated
end-to-end among both DLS users and the DLS provider, or locally for each DLS
user independently with the DLS provider.

@tabfig{dlpi_tab4,1x,-}

Parameter Service Mode Negotiation throughput connection end-to-end transit
delay both end-to-end priority both local protection both local residual error
rate both none resilience connection none

@page
@node Throughput
@subsection Throughput
@cpindex Connection mode
Throughput is a connection-mode @acronym{QoS} parameter that has end-to-end
significance.  It is defined as the total number of @acronym{DLSDU} bits
successfully transferred by a @prim{DL_DATA_REQ}/@prim{DL_DATA_IND} primitive
sequence divided by the input/output time, in seconds, for that sequence.
Successful transfer of a @acronym{DLSDU} is defined to occur when the
@acronym{DLSDU} is delivered to the intended user without error, in proper
sequence, and before connection termination by the receiving DLS user.  The
input/output time for a @prim{DL_DATA_REQ}/@prim{DL_DATA_IND} primitive sequence
is the greater of:

@itemize @bullet
@item the time between the first and last
@prim{DL_DATA_REQ}
in a sequence; and
@item the time between the first and last
@prim{DL_DATA_IND}
in the sequence.
@end itemize

@cpindex Connection establishment
Throughput is only meaningful for a sequence of complete DLSDUs.  Throughput is
specified and negotiated for the transmit and receive directions independently
at connection establishment.  The throughput specification defines the target and
minimum acceptable values for a connection.  Each specification is an average
rate.  The DLS user can delay the receipt or sending of DLSDUs.  The delay caused
by a DLS user is not included in calculating the average throughput values.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_target_value;
        long dl_accept_value;
@} dl_through_t;
@tpindex dl_through_t
@end example

This typedef is used to negotiate the transmit and receive throughput values.
@table @parm
@item dl_target_value
specifies the desired throughput value for the connection in bits/second.

@item dl_accept_value
specifies the minimum acceptable throughput value for the connection in
bits/second.

@end table

@page
@node Transit Delay
@subsection Transit Delay
@cpindex Connectionless mode
Connection and connectionless modes can specify a transit delay, which indicates
the elapsed time between a
@prim{DL_DATA_REQ}
or
@prim{DL_UNITDATA_REQ}
primitive and the corresponding
@prim{DL_DATA_IND}
or
@prim{DL_UNITDATA_IND}
primitive.  The elapsed time is only computed for DLSDUs successfully
transferred, as described previously for throughput.

@cpindex Connection establishment
@cpindex Connection mode
In connection mode, transit delay is negotiated on an end-to-end basis during
connection establishment.  For each connection, transit delay is negotiated for
the transmit and receive directions separately by specifying the target value
@cpindex Connectionless mode
and maximum acceptable value.  For connectionless-mode service, a DLS user selects
a particular value within the supported range using the
@prim{DL_UDQOS_REQ}
primitive, and the value may be changed for each @acronym{DLSDU} submitted for
@cpindex Connectionless mode
connectionless transmission.  The transit delay for an individual
@acronym{DLSDU} may be
increased if the receiving DLS user flow controls the interface.  The average
and maximum transit delay values exclude any DLS user flow control of the
interface.  The values are specified in milliseconds, and assume a
@acronym{DLSDU} size of
128 octets.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_target_value;
        long dl_accept_value;
@} dl_transdelay_t;
@tpindex dl_transdelay_t
@end example

This typedef is used to negotiate the transmit and receive transit delay values.
@table @parm
@item dl_target_value
specifies the desired transit delay value.

@item dl_accept_value
specifies the maximum acceptable transit delay value.

@end table

@page
@node Priority
@subsection Priority
Priority is negotiated locally between each DLS user and the DLS provider in
@cpindex Connectionless mode
@cpindex Connection mode
connection-mode service, and can also be specified for connectionless-mode
service.  The specification of priority is concerned with the relationship
@cpindex Connectionless mode
between connections or the relationship between connectionless data transfer
requests.  The parameter specifies the relative importance of a connection with
respect to:

@itemize @bullet
@item the order in which connections are to have their @acronym{QoS} degraded,
if necessary; and

@item the order in which connections are to be released to recover resources, if
necessary;

@end itemize

@cpindex Connectionless mode
For connectionless-mode service, the parameter specifies the relative importance
of unitdata objects with respect to gaining use of shared resources.

@cpindex Connection establishment
@cpindex Connection mode
For connection-mode service, each DLS user negotiates a particular priority
value with the DLS provider during connection establishment.  The value is
specified by a minimum and a maximum within a given range.  For
@cpindex Connectionless mode
connectionless-mode service, a DLS user selects a particular priority value
within the supported range using the
@prim{DL_UDQOS_REQ}
primitive, and the value may be changed for each @acronym{DLSDU} submitted for
@cpindex Connectionless mode
connectionless transmission.  This parameter only has meaning in the context of
some management entity or structure able to judge relative importance.  The
priority has local significance only, with a value of zero being the highest
priority and 100 being the lowest priority.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_min;
        long dl_max;
@} dl_priority_t;
@tpindex dl_priority_t
@end example

@table @parm
@item dl_min
specifies the minimum acceptable priority.

@item dl_max
specifies the maximum desired priority.

@end table

@page
@node Protection
@subsection Protection
Protection is negotiated locally between each DLS user and the DLS provider in
@cpindex Connectionless mode
@cpindex Connection mode
connection-mode service, and can also be specified for connectionless-mode
service.  Protection is the extent to which a DLS provider attempts to prevent
unauthorized monitoring or manipulation of DLS user-originated
information.  Protection is specified by a minimum and maximum protection option
within the following range of possible protection options:

@table @pval
@item DL_NONE
DLS provider will not protect any DLS user data

@item DL_MONITOR
DLS provider will protect against passive monitoring

@item DL_MAXIMUM
DLS provider will protect against modification, replay, addition, or deletion of
DLS user data

@end table

@cpindex Connection establishment
@cpindex Connection mode
For connection-mode service, each DLS user negotiates a particular value with
the DLS provider during connection establishment.  The value is specified by a
@cpindex Connectionless mode
minimum and a maximum within a given range.  For connectionless-mode service, a
DLS user selects a particular value within the supported range using
the
@prim{DL_UDQOS_REQ}
primitive, and the value may be changed for each @acronym{DLSDU} submitted for
@cpindex Connectionless mode
connectionless transmission.  Protection has local significance only.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_min;
        long dl_max;
@} dl_protect_t;
@tpindex dl_protect_t
@end example

@table @parm
@item dl_min
specifies the minimum acceptable protection.

@item dl_max
specifies the maximum desired protection.

@end table

@page
@node Residual Error Rate
@subsection Residual Error Rate
Residual error rate is the ratio of total incorrect, lost and duplicate DLSDUs
to the total DLSDUs transferred between DLS users during a period of time.  The
relationship between these quantities is defined below:

@example
       DLSDUl + DLSDUi + DLSDUe
RER = ---------------------------
             DLSDUtot
@end example

where

@table @var
@item DLSDUtot
= total DLSDUs transferred, which is the total of DLSDUl,  DLSDUi, DLSDUe, and
correctly received DLSDUs.

@item DLSDUe
= DLSDUs received 2 or more times.

@item DLSDUi
= incorrectly received DLSDUs.

@item DLSDUl
= DLSDUs sent, but not received.

@end table

@subsubheading Parameter Format

@example
long dl_residual_error;
@end example

The residual error value is scaled by a factor of 1,000,000, since the parameter
is stored as a long integer in the @acronym{QoS} data structures.  Residual
error rate is not a negotiated @acronym{QoS} parameter.  Its value is determined
by procedures outside the definition of @acronym{DLPI}.  It is assumed to be set by an
administrative mechanism, which is informed of the value by network management.

@page
@node Resilience
@subsection Resilience
@cpindex Connection mode
Resilience is meaningful in connection mode only, and represents the probability
of either: DLS provider-initiated disconnects or DLS provider-initiated resets
during a time interval of 10,000 seconds on a connection.  Resilience is not a
negotiated @acronym{QoS} parameter.  Its value is determined by procedures
outside the definition of @acronym{DLPI}.  It is assumed to be set by an administrative
mechanism, which is informed of the value by network management.

@subsubheading Parameter Format
@example
typedef struct @{
        long dl_disc_prob;
        long dl_reset_prob;
@} dl_resilience_t;
@tpindex dl_resilience_t
@end example

@table @parm
@item dl_disc_prob
specifies the probability of receiving a provider-initiated disconnect, scaled
by 10000.

@item dl_reset_prob
specifies the probability of receiving a provider-initiated reset, scaled by
10000.

@end table

@page
@node QOS Data Structures
@section QOS Data Structures

@menu
* Structure DL_QOS_CO_RANGE1::
* Structure DL_QOS_CO_SEL1::
* Structure DL_QOS_CL_RANGE1::
* Structure DL_QOS_CL_SEL1::
@end menu

To simplify the definition of the primitives containing @acronym{QoS} parameters
and the discussion of @acronym{QoS} negotiation, the @acronym{QoS} parameters
are organized into four structures.  This section defines the structures and
indicates which structures apply to which primitives.  Each structure is tagged
with a type field contained in the first four bytes of the structure, similar to
the tagging of primitives.  The type field has been defined because of the
current volatility of @acronym{QoS} parameter definition within the
international standards bodies.  If new @acronym{QoS} parameter sets are defined
in the future for the data link layer, the type field will enable @acronym{DLPI} to
accommodate these sets without breaking existing DLS user or provider
implementations.  However, DLS user and provider software should be cognizant of
the possibility that new @acronym{QoS} structure types may be defined in future
issues of the @acronym{DLPI} specification.  If a DLS provider receives a structure type
that it does not understand in a given primitive, the error @perr{DL_BADQOSTYPE}
should be returned to the DLS user in a @prim{DL_ERROR_ACK} primitive.

Currently the following @acronym{QoS} structure types are defined:

@table @pval
@item DL_QOS_CO_RANGE1
@cpindex Connection mode
@acronym{QoS} range structure for connection-mode service for Issue 1 of
@acronym{DLPI}

@item DL_QOS_CO_SEL1
@cpindex Connection mode
@acronym{QoS} selection structure for connection-mode service for Issue 1 of
@acronym{DLPI}

@item DL_QOS_CL_RANGE1
@cpindex Connectionless mode
@acronym{QoS} range structure for connectionless-mode service for Issue 1 of
@acronym{DLPI}

@item DL_QOS_CL_SEL1
@cpindex Connectionless mode
@acronym{QoS} selection structure for connectionless-mode service for Issue 1 of @acronym{DLPI}

@end table

The syntax and semantics of each structure type is presented in the remainder of
this section.

@page
@node Structure DL_QOS_CO_RANGE1
@subsection Structure DL_QOS_CO_RANGE1
Structure type
@pval{DL_QOS_CO_RANGE1}
enables a DLS user and DLS provider to pass
@cpindex Connection mode
between them a range of @acronym{QoS} parameter values in the connection-mode service.  The
format of this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        dl_through_t dl_rcv_throughput;
        dl_transdelay_t dl_rcv_trans_delay;
        dl_through_t dl_xmt_throughput;
        dl_transdelay_t dl_xmt_trans_delay;
        dl_priority_t dl_priority;
        dl_protect_t dl_protection;
        long dl_residual_error;
        dl_resilience_t dl_resilience;
@} dl_qos_co_range1_t;
@tpindex dl_qos_co_range1_t
@end example

where the value of dl_qos_type is
@pval{DL_QOS_CO_RANGE1}.
The fields of this structure correspond to the parameters defined in @ref{QOS
Parameter Definitions}.  The throughput and transit delay parameters are
specified for each direction of transmission on a data link connection.

This structure type is returned in the dl_qos_range_length and
dl_qos_range_offset fields of the
@prim{DL_INFO_ACK},
and specifies the supported ranges of service quality supported by the DLS
provider.  In other words, it specifies the available range of @acronym{QoS} parameter
values that may be specified on a
@prim{DL_CONNECT_REQ}.

For the
@prim{DL_CONNECT_REQ}
and
@prim{DL_CONNECT_IND}
primitives, this structure specifies
@cpindex Connection mode
the negotiable range of connection-mode @acronym{QoS} parameter values.  @xref{Procedures
for QOS Negotiation and Selection}, for the semantics of this structure in these
primitives.

@page
@node Structure DL_QOS_CO_SEL1
@subsection Structure DL_QOS_CO_SEL1
Structure type
@pval{DL_QOS_CO_SEL1}
conveys selected @acronym{QoS} parameter values for
@cpindex Connection mode
connection-mode service between the DLS user and DLS provider.  The format of
this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        long dl_rcv_throughput;
        long dl_rcv_trans_delay;
        long dl_xmt_throughput;
        long dl_xmt_trans_delay;
        long dl_priority;
        long dl_protection;
        long dl_residual_error;
        dl_resilience_t dl_resilience;
@} dl_qos_co_sel1_t;
@tpindex dl_qos_co_sel1_t
@end example

where the value of dl_qos_type is
@pval{DL_QOS_CO_SEL1}.
The fields of this structure correspond to the parameters defined in @ref{QOS
Parameter Definitions}.  The throughput and transit delay parameters are
specified for each direction of transmission on a data link connection.

@cpindex Connection establishment
This structure type is returned in the dl_qos_length and dl_qos_offset fields of
the
@prim{DL_INFO_ACK},
and specifies the current or default @acronym{QoS} parameter values associated with a
stream.  Default values are returned prior to connection establishment, and
currently negotiated values are returned when a connection is active on the
stream.

@cpindex Calling DLS user
The structure type is used in the
@prim{DL_CONNECT_RES}
to enable the responding DLS user to select particular @acronym{QoS} parameter values from
the available range.  The
@prim{DL_CONNECT_CON}
primitive returns the selected values to the calling DLS user in this structure.
@xref{Procedures for QOS Negotiation and Selection}, for the semantics of this
structure in these primitives.

@page
@node Structure DL_QOS_CL_RANGE1
@subsection Structure DL_QOS_CL_RANGE1
Structure type
@pval{DL_QOS_CL_RANGE1}
enables a DLS user and DLS provider to pass
@cpindex Connectionless mode
between them a range of @acronym{QoS} parameter values in the connectionless-mode service.
The format of this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        dl_transdelay_t dl_trans_delay;
        dl_priority_t dl_priority;
        dl_protect_t dl_protection;
        long dl_residual_error;
@} dl_qos_cl_range1_t;
@tpindex dl_qos_cl_range1_t
@end example

where the value of dl_qos_type is
@pval{DL_QOS_CL_RANGE1}.
The fields of this structure correspond to the parameters defined in @ref{QOS
Parameter Definitions}.

This structure type is returned in the dl_qos_range_length and
dl_qos_range_offset fields of the
@prim{DL_INFO_ACK},
@cpindex Connectionless mode
and specifies the range of connectionless-mode @acronym{QoS} parameter values supported by
the DLS provider on the stream.  The DLS user may select specific values from
this range using the
@prim{DL_UDQOS_REQ}
primitive, as described in @ref{Procedures for QOS Negotiation and Selection}.

@page
@node Structure DL_QOS_CL_SEL1
@subsection Structure DL_QOS_CL_SEL1
Structure type
@pval{DL_QOS_CL_SEL1}
conveys selected @acronym{QoS} parameter values for
@cpindex Connectionless mode
connectionless-mode service between the DLS user and DLS provider.  The format
of this structure type is:

@example
typedef struct @{
        ulong dl_qos_type;
        long dl_trans_delay;
        long dl_priority;
        long dl_protection;
        long dl_residual_error;
@} dl_qos_cl_sel1_t;
@tpindex dl_qos_cl_sel1_t
@end example

where the value of dl_qos_type is
@pval{DL_QOS_CL_SEL1}.
The fields of this structure correspond to the parameters defined in @ref{QOS
Parameter Definitions}.

This structure type is returned in the dl_qos_length and dl_qos__offset fields
of the
@prim{DL_INFO_ACK},
and specifies the current or default @acronym{QoS} parameter values associated with a
stream.  Default values are returned until the DLS user issues a
@prim{DL_UDQOS_REQ}
to change the values, after which the currently selected values will be
returned.  The structure type is also used in the
@prim{DL_UDQOS_REQ}
primitive to enable a DLS user to select particular @acronym{QoS} parameter values from
the supported range, as described in @ref{Procedures for QOS Negotiation and
Selection}.

@page
@node Procedures for QOS Negotiation and Selection
@section Procedures for QOS Negotiation and Selection

@menu
* Connection-mode QOS Negotiation::
* Connectionless-mode QOS Selection::
@end menu

@cpindex Connection establishment
This section describes the methods used for negotiating and/or selecting
@acronym{QoS}
@cpindex Connection mode
parameter values.  In the connection-mode service, some @acronym{QoS} parameter values may
@cpindex Connectionless mode
be negotiated during connection establishment.  For connectionless-mode service,
parameter values may be selected for subsequent data transmission.

Throughout this section, two special @acronym{QoS} values are referenced.  These are
defined for all the parameters used in @acronym{QoS} negotiation and selection.  The
values are:

@table @pval
@item DL_UNKNOWN
This value indicates that the DLS provider does not know the value for the field
or does not support that parameter.

@item DL_QOS_DONT_CARE
This value indicates that the DLS user does not care to what value the
@acronym{QoS}
parameter is set.

@end table

These values are used to distinguish between DLS providers that support and
negotiate @acronym{QoS} parameters and those that cannot.  The following sections include
the interpretation of these values during @acronym{QoS} negotiation and selection.

@page
@node Connection-mode QOS Negotiation
@subsection Connection-mode QOS Negotiation
@cpindex Connection mode
The current connection-mode @acronym{QoS} parameters can be divided into three types as
follows:

@itemize @bullet
@item Those that are negotiated end-to-end between peer DLS users and the DLS
@cpindex Connection establishment
provider during connection establishment (throughput and transit delay);

@item those that are negotiated locally between each DLS user and the DLS
@cpindex Connection establishment
provider during connection establishment (priority and protection); and

@item those that cannot be negotiated (residual error rate and resilience).
@end itemize

The rules for processing these three types of parameters during connection
@cpindex Connection establishment
establishment are described in this section.

The current definition of most existing data link protocols does not describe a
@cpindex Connection establishment
mechanism for negotiating @acronym{QoS} parameters during connection establishment.  As
such, @acronym{DLPI} does not require every DLS provider implementation to support
@acronym{QoS}
negotiation.  If a given DLS provider implementation cannot support
@acronym{QoS} negotiation, two alternatives are available:

@itemize
@item The DLS provider may specify that any or all @acronym{QoS} parameters are unknown.
This is indicated to the DLS user in the
@prim{DL_INFO_ACK},
where the values in the @acronym{QoS} range field (indicated by dl_qos_range_length and
dl_qos_range_offset) and the current @acronym{QoS} field (indicated by dl_qos_length and
dl_qos_offset) of this primitive are set to
@pval{DL_UNKNOWN}.
This value will also be indicated on the
@prim{DL_CONNECT_IND}
and
@prim{DL_CONNECT_CON}
primitives.  If the DLS provider does not support any @acronym{QoS} parameters, the @acronym{QoS}
length field may be set to zero in each of these of these primitives.

@item The DLS provider may interpret @acronym{QoS} parameters with strictly local
significance, and their values in the
@prim{DL_CONNECT_IND}
primitive will be set to
@pval{DL_UNKNOWN}.
@end itemize

A DLS user need not select a specific value for each @acronym{QoS} parameter.  The special
@acronym{QoS} parameter value,
@pval{DL_QOS_DONT_CARE},
is used if the DLS user does not care what quality of service is provided for a
particular parameter.  The negotiation procedures presented below explain the
exact semantics of this value during
@cpindex Connection establishment
connection establishment.

If @acronym{QoS} parameters are supported by the DLS provider, the provider will define a
set of default @acronym{QoS} parameter values that are used whenever
@pval{DL_QOS_DONT_CARE}
is specified for a @acronym{QoS} parameter value.  These default values can be defined for
all DLS users or can be defined on a per DLS user basis.  The default parameter
value set is returned in the @acronym{QoS} field (indicated by dl_qos_length and
dl_qos_offset) of the
@prim{DL_INFO_ACK}
before a DLS user negotiates @acronym{QoS} parameter values.

DLS provider addendum documentation must describe the known ranges of support
for the @acronym{QoS} parameters and the default values, and also specify whether they are
used in a local manner only.  The following procedures are used to negotiate
@acronym{QoS}
@cpindex Connection establishment
parameter values during connection establishment.

@table @asis
@item (1)
@cpindex Calling DLS user
The
@prim{DL_CONNECT_REQ}
specifies the DLS user's desired range of @acronym{QoS} values in the dl_qos_co_range1_t
structure.  The target and least-acceptable values are specified for throughput
and transit delay, as described in @ref{Throughput}, and @ref{Transit Delay}.
The target value is the value desired by the calling DLS user for the
@acronym{QoS}
parameters.  The least acceptable value is the lowest value the calling user
will accept.  These values are specified separately for both the transmit and
receive directions of the connection.

If either value is set to
@pval{DL_QOS_DONT_CARE}
the DLS provider will supply a default value, subject to the following
consistency constraints:

@itemize --
@item If
@pval{DL_QOS_DONT_CARE}
is specified for the target value, the value chosen by the DLS provider may not
be less than the least-acceptable value.

@item If
@pval{DL_QOS_DONT_CARE}
is specified for the least-acceptable value, the value set by the DLS provider
cannot be greater than the target value.

@item If
@pval{DL_QOS_DONT_CARE}
is specified for both the target and least-acceptable value, the DLS provider is
free to select any value, without constraint, for the target and least
acceptable values.
@end itemize

For priority and protection, the
@prim{DL_CONNECT_REQ}
specifies a minimum and maximum desired value as defined in @ref{Priority}, and
@ref{Protection}.  As with throughput and transit delay, the DLS user may
specify a value of
@pval{DL_QOS_DONT_CARE}
for either the minimum or maximum value.  The DLS provider will interpret this
value subject to the following consistency constraints:

@itemize --
@item If
@pval{DL_QOS_DONT_CARE}
is specified for the maximum value, the value chosen by the DLS provider may not
be less than the minimum value.

@item If
@pval{DL_QOS_DONT_CARE}
is specified for the minimum value, the value set by the DLS provider cannot be
greater than the maximum value.

@item If
@pval{DL_QOS_DONT_CARE}
is specified for both the minimum and maximum values, the DLS provider is free
to select any value, without constraint, for the maximum and minimum values.
@end itemize

The values of the residual error rate and resilience parameters in the
@prim{DL_CONNECT_REQ}
have no meaning and are ignored by the DLS provider.

If the value of dl_qos_length in the
@prim{DL_CONNECT_REQ}
is set to zero by the DLS user, the DLS provider should treat all @acronym{QoS} parameter
values as if they were set to
@pval{DL_QOS_DONT_CARE},
selecting any value in its supported range.

@cpindex Calling DLS user
If the DLS provider cannot support throughput, transit delay, priority, and
protection values within the ranges specified in the
@prim{DL_CONNECT_REQ},
a
@prim{DL_DISCONNECT_IND}
should be sent to the calling DLS user.

@item (2)
@cpindex Called DLS user
If the requested ranges of values for throughput and transit delay in the
@prim{DL_CONNECT_REQ}
are acceptable to the DLS provider, the @acronym{QoS} parameters will be adjusted to
values the DLS provider will support.  Only the target value may be adjusted,
and it is set to a value the DLS provider is willing to provide (which may be of
lower @acronym{QoS} than the target value).  The least-acceptable value cannot be
modified.  The updated @acronym{QoS} range is then sent to the called DLS user in the
dl_qos_co_range1_t structure of the
@prim{DL_CONNECT_IND},
where it is interpreted as the available range of service.

@cpindex Calling DLS user
If the requested range of values for priority and protection in the
@prim{DL_CONNECT_REQ}
is acceptable to the DLS provider, an appropriate value within the range is
selected and saved for each parameter; these selected values will be returned to
the DLS user in the corresponding
@prim{DL_CONNECT_CON}
primitive.  Because priority and protection are negotiated locally, the
@prim{DL_CONNECT_IND}
will not contain values selected during negotiation with the calling DLS user.
Instead, the DLS provider will offer a range of values in the
@prim{DL_CONNECT_IND}
that will be supported locally for the called DLS user.

The DLS provider will also include the supported values for residual error rate
and resilience in the
@prim{DL_CONNECT_IND}
that is passed to the called DLS user.

If the DLS provider does not support negotiation of throughput, transit delay,
priority, or protection, a value of
@pval{DL_UNKNOWN}
should be set in the least-acceptable, target, minimum, and maximum value fields
of the
@prim{DL_CONNECT_IND}.
Also, if the DLS provider does not support any particular @acronym{QoS}
parameter,
@pval{DL_UNKNOWN}
should be specified in all value fields for that parameter.  If the DLS provider
does not support any @acronym{QoS} parameters, the value of dl_qos_length may be set to
zero in the
@prim{DL_CONNECT_IND}.

@item (3)
@cpindex Called DLS user
Upon receiving the
@prim{DL_CONNECT_IND},
the called DLS user examines the @acronym{QoS} parameter values and selects a specific
value from the proffered range of the throughput, transit delay, priority, and
protection parameters.  If the called DLS user does not agree on values in the
given range, the connection should be refused with a
@prim{DL_DISCONNECT_REQ}
primitive.  Otherwise, the selected values are returned to the DLS provider in
the dl_qos_co_sel1_t structure of the
@prim{DL_CONNECT_RES}
primitive.

The values of residual error rate and resilience in the
@prim{DL_CONNECT_RES}
are ignored by the DLS provider.  These parameters may not be negotiated by the
called DLS user.  The selected values of throughput and transit delay are
meaningful, however, and are adopted for the connection by the DLS provider.
Similarly, the selected priority and protection values are adopted with local
significance for the called DLS user.

If the user specifies
@pval{DL_QOS_DONT_CARE}
for either throughput, transit delay, priority, or protection on the
@prim{DL_CONNECT_RES},
the DLS provider will select a value from the range specified for that parameter
in the
@prim{DL_CONNECT_IND}
primitive.  Also, a value of zero in the dl_qos_length field of the
@prim{DL_CONNECT_RES}
is equivalent to
@pval{DL_QOS_DONT_CARE}
for all @acronym{QoS} parameters.

@item (4)
@cpindex Called DLS user
@cpindex Calling DLS user
@cpindex Connection establishment
Upon completion of connection establishment, the values of throughput and
transit delay as selected by the called DLS user are returned to the calling DLS
user in the dl_qos_co_sel1_t structure of the
@prim{DL_CONNECT_CON}
primitive.  The values of priority and protection that were selected by the DLS
provider from the range indicated in the
@prim{DL_CONNECT_REQ}
will also be returned in the
@prim{DL_CONNECT_CON}.
This primitive will also contain the values of residual error rate and
resilience associated with the newly established connection.  The DLS provider
also saves the negotiated @acronym{QoS} parameter values for the connection, so that they
may be returned in response to a
@prim{DL_INFO_REQ}
primitive.

As with
@prim{DL_CONNECT_IND},
if the DLS provider does not support negotiation of throughput, transit delay,
priority, or protection, a value of
@pval{DL_UNKNOWN}
should be returned in the selected value fields.  Furthermore, if the DLS
provider does not support any particular @acronym{QoS} parameter,
@pval{DL_UNKNOWN}
should be specified in all value fields for that parameter, or the value of
dl_qos_length may be set to zero in the
@prim{DL_CONNECT_CON}
primitive.

@end table

@page
@node Connectionless-mode QOS Selection
@subsection Connectionless-mode QOS Selection
@cpindex Connectionless mode
This section describes the procedures for selecting @acronym{QoS} parameter values that
will be associated with the transmission of connectionless data or acknowledged
connectionless data.

@cpindex Connection mode
As with connection-mode protocols, the current definition of most existing
(acknowledged) connectionless data link protocols does not define a quality of
service concept.  As such, @acronym{DLPI} does not require every DLS provider
implementation to support @acronym{QoS} parameter selection.  The DLS provider may specify
that any or all @acronym{QoS} parameters are unsupported.  This is indicated to the DLS user
in the
@prim{DL_INFO_ACK},
where the values in the supported range field (indicated by dl_qos_range_length
and dl_qos_range_offset)and the current @acronym{QoS} field (indicated by dl_qos_length
and dl_qos_offset) of this primitive are set to
@pval{DL_UNKNOWN}.

If the DLS provider supports no @acronym{QoS} parameters, the @acronym{QoS} length fields in the
@prim{DL_INFO_ACK}
may be set to zero.  If the DLS provider supports @acronym{QoS} parameter selection, the
@prim{DL_INFO_ACK}
primitive will specify the supported range of parameter values for transit
delay, priority, protection and residual error rate.  Default values are also
returned in the
@prim{DL_INFO_ACK}.

For each
@prim{DL_UNITDATA_REQ}/@prim{DL_DATA_ACK_REQ},
the DLS provider should apply the currently selected @acronym{QoS} parameter values to the
transmission.  If no values have been selected, the default values should be
used.

At any point during data transfer, the DLS user may issue a
@prim{DL_UDQOS_REQ}
primitive to select new values for the transit delay, priority, and protection
parameters.  These values are selected using the dl_qos_cl_sel1_t structure.
The residual error rate parameter is ignored by this primitive and cannot be
set by a DLS user.

In the
@prim{DL_UDQOS_REQ},
the DLS user need not require a specific value for every @acronym{QoS} parameter.
@pval{DL_QOS_DONT_CARE}
may be specified if the DLS user does not care what quality of service is
provided for a particular parameter.  When specified, the DLS provider should
retain the current (or default if no previous selection has occurred) value for
that parameter.

@node Optional Primitives to perform Essential Management Functions
@appendix Optional Primitives to perform Essential Management Functions

@menu
* Message DL_PHYS_ADDR_REQ (dl_phys_addr_req_t)::
* Message DL_PHYS_ADDR_ACK (dl_phys_addr_ack_t)::
* Message DL_SET_PHYS_ADDR_REQ (dl_set_phys_addr_req_t)::
* Message DL_GET_STATISTICS_REQ (dl_get_statistics_req_t)::
* Message DL_GET_STATISTICS_ACK (dl_get_statistics_ack_t)::
@end menu

This appendix presents the optional primitives to perform essential management
functions.  The management functions supported are get and set of physical
address, and statistics gathering.

@page
@node Message DL_PHYS_ADDR_REQ (dl_phys_addr_req_t)
@appendixsec Message DL_PHYS_ADDR_REQ (dl_phys_addr_req_t)
@tpindex dl_phys_addr_req_t
This primitive requests the DLS provider to return either the default (factory)
or the current value of the physical address associated with the stream depending
upon the value of the address type selected in the request.

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_type;
@} dl_phys_addr_req_t;
@tpindex dl_phys_addr_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_PHYS_ADDR_REQ};

@item dl_addr_type
conveys the type of address requested - factory physical address or current
physical address

@table @pval
@item DL_FACT_PHYS_ADDR
factory physical address
DL_CURR_PHYS_ADDR
current physical address

@end table
@end table

@subsubheading State
The message is valid in any attached state in which a local acknowledgment is
not pending.  For a style 2provider, this would be after a @acronym{PPA} is attached using
the
@prim{DL_ATTACH_REQ}.
For a Style 1 provider, the @acronym{PPA} is implicitly attached after the stream is
opened.

@subsubheading New State
The resulting state is unchanged.

@subsubheading Response
The provider responds to the request with a
@prim{DL_PHYS_ADDR_ACK}
if the request is supported.  Otherwise, a
@prim{DL_ERROR_ACK}
is returned.

@subsubheading Reasons for failure
@table @perr
@item DL_NOTSUPPORTED
Primitive is known, but not supported by the DLS Provider.
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@end table

@page
@node Message DL_PHYS_ADDR_ACK (dl_phys_addr_ack_t)
@appendixsec Message DL_PHYS_ADDR_ACK (dl_phys_addr_ack_t)
@tpindex dl_phys_addr_ack_t
This primitive returns the value for the physical address to the link user in
response to a
@prim{DL_PHYS_ADDR_REQ}.

@subsubheading Message Format
The message consists of @msg{M_PCPROTO} message block containing the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_phys_addr_ack_t;
@tpindex dl_phys_addr_ack_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_PHYS_ADDR_ACK}

@item dl_addr_length
conveys length of the physical address.  dl_addr_offset conveys the offset from
the beginning of the @msg{M_PCPROTO} message block.

@end table

@subsubheading State
The message is valid in any state in response to a
@prim{DL_PHYS_ADDR_REQ}.

@subsubheading New State
The resulting state is unchanged.

@page
@node Message DL_SET_PHYS_ADDR_REQ (dl_set_phys_addr_req_t)
@appendixsec Message DL_SET_PHYS_ADDR_REQ (dl_set_phys_addr_req_t)
@tpindex dl_set_phys_addr_req_t
Sets the physical address value for all streams for that provider for a
particular @acronym{PPA}.

@subsubheading Message Format
The message consists of @msg{M_PROTO} message block which contains the following
structure:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_addr_length;
        ulong dl_addr_offset;
@} dl_set_phys_addr_req_t;
@tpindex dl_set_phys_addr_req_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_SET_PHYS_ADDR_REQ}

@item dl_addr_offset
conveys the offset from the beginning of the @msg{M_PROTO} message block
dl_addr_length conveys the length of the requested hardware address

@end table

@subsubheading State
The message is valid in any attached state in which a local acknowledgment is
not pending.  For a Style 2provider, this would be after a @acronym{PPA} is attached using
the
@prim{DL_ATTACH_REQ}.
For a Style 1 provider, the @acronym{PPA} is implicitly attached after the stream is
opened.

@subsubheading New State
The resulting state is unchanged

@subsubheading Response
The provider responds to the request with a
@prim{DL_OK_ACK}
on successful completion.  Otherwise, a
@prim{DL_ERROR_ACK}
is returned.

@subsubheading Reasons for failure
@table @perr
@item DL_BADADDR
The address information was invalid or was in an incorrect format.
@item DL_NOTSUPPORTED
Primitive is known, but not supported by the DLS Provider.
@item DL_SYSERR
A system error has occurred
@item DL_OUTSTATE
The primitive was issued from an invalid state.
@item DL_BUSY
One or more streams for that particular @acronym{PPA} are in the bound
(@psta{DL_IDLE})
state.
@end table

@page
@node Message DL_GET_STATISTICS_REQ (dl_get_statistics_req_t)
@appendixsec Message DL_GET_STATISTICS_REQ (dl_get_statistics_req_t)
@tpindex dl_get_statistics_req_t
Directs the DLS provider to return statistics

@subsubheading Message Format
The message consists of one @msg{M_PROTO} message block containing the structure shown
below:

@example
typedef struct @{
        ulong dl_primitive;
@} dl_get_statistics_req_t;
@tpindex dl_get_statistics_req_t
@end example

@subsubheading Parameters
@table @parm
dl_primitive conveys
@prim{DL_GET_STATISTICS_REQ}
@end table

@subsubheading State
The message is valid in any state in which a local acknowledgment is not
pending.

@subsubheading New State
The resulting state is unchanged

@subsubheading Response
The DLS Provider responds to this request with a
@prim{DL_GET_STATISTICS_ACK} if the
primitive is supported.  Otherwise, a
@prim{DL_ERROR_ACK}
is returned.

@subsubheading Reasons for failure
@table @perr
@item DL_NOTSUPPORTED
Primitive is known but not supported by the DLS Provider.
@end table

@page
@node Message DL_GET_STATISTICS_ACK (dl_get_statistics_ack_t)
@appendixsec Message DL_GET_STATISTICS_ACK (dl_get_statistics_ack_t)
@tpindex dl_get_statistics_ack_t
Returns statistics in response to the
@prim{DL_GET_STATISTICS_REQ}.
The contents of the statistics block is defined in the DLS Provider specific
addendum.

@subsubheading Message Format
The message consists of one @msg{M_PCPROTO} message block containing the structure
shown below:

@example
typedef struct @{
        ulong dl_primitive;
        ulong dl_stat_length;
        ulong dl_stat_offset;
@} dl_get_statistics_ack_t;
@tpindex dl_get_statistics_ack_t
@end example

@subsubheading Parameters
@table @parm
@item dl_primitive
conveys
@prim{DL_GET_STATISTICS_ACK}

@item dl_stat_len
conveys the length of the statistics structure dl_stat_offset conveys the offset
from the beginning of the M_PCROTO message block where the statistics
information resides.

@end table

@subsubheading State
The message is valid in any state in which a local acknowledgment is not
pending.

@subsubheading New State
The resulting state is unchanged

@page
@node Allowable Sequence of DLPI Primitives
@appendix Allowable Sequence of DLPI Primitives

@menu
* DLPI States::
* Variables and Actions for State Transition Table::
* DLPI User-Originated Events::
* DLPI Provider-Originated Events::
* DLPI State Transition Table::
@end menu

This appendix presents the allowable sequence of @acronym{DLPI} primitives.  The sequence
is described using a state transition table that defines possible states as
viewed by the DLS user.  The state transition table describes transitions based
on the current state of the interface and a given @acronym{DLPI} event.  Each
transition consists of a state change and possibly an interface action.  The
states, events, and related transition actions are described below, followed by
the state transition table itself.

@page
@node DLPI States
@appendixsec DLPI States
The following table describes the states associated with @acronym{DLPI}.  It presents the
state name used in the state transition table, the corresponding @acronym{DLPI} state name
used throughout this specification, a brief description of the state, and an
indication of whether the state is valid for connection-oriented data link
@cpindex Connectionless mode
service
(@pval{DL_CODLS}),
connectionless data link service
(@pval{DL_CLDLS}),
acknowledged connectionless data link service
(@pval{DL_ACLDLS})
or all.

@tabfig{dlpi_tab5,2a,DLPI States}
@tabfig{dlpi_tab6,2b,DLPI States}
@tabfig{dlpi_tab7,2c,DLPI States}

@page
@node Variables and Actions for State Transition Table
@appendixsec Variables and Actions for State Transition Table
The following tables describe variables and actions used to describe the
@acronym{DLPI}
state transitions.  The variables are used to distinguish various uses of the
same @acronym{DLPI} primitive.  For example, a
@prim{DL_CONNECT_RES}
causes a different state transition depending on the current number of
outstanding connect indications.  To distinguish these different connect
response events, a variable is used to track the number of outstanding connect
indications.

@tabfig{dlpi_tab8,3,DPLI State Transition Table Variables}

The actions represent steps the DLS provider must take during certain state
transitions to maintain the interface state.  When an action is indicated in the
state transition table, the DLS provider should change the state as indicated
and perform the specified action.

@tabfig{dlpi_tab9,4,DPLI State Transition Actions}

@page
@node DLPI User-Originated Events
@appendixsec DLPI User-Originated Events
The following table describes events initiated by the DLS user that correspond
to the various request and response primitives of @acronym{DLPI}.  The table presents the
event name used in the state transition table, a brief description of the event
(including the corresponding @acronym{DLPI} primitive), and an indication of whether
the event is valid for connection-oriented data link service
(@pval{DL_CODLS}),
@cpindex Connectionless mode
connectionless data link service
(@pval{DL_CLDLS}),
acknowledged connectionless data link service
(@pval{DL_ACLDLS})
or all.

@tabfig{dlpi_ta10,5,DLPI User-Originated Events}

@page
@node DLPI Provider-Originated Events
@appendixsec DLPI Provider-Originated Events
The following table describes the events initiated by the DLS provider that
correspond to the various indication, confirmation, and acknowledgment
primitives of @acronym{DLPI}.  The table presents the event name used in the state
transition table, a brief description of the event (including the corresponding
@acronym{DLPI} primitive), and an indication of whether the event is valid for
@cpindex Connectionless mode
connection-oriented data link service
(@pval{DL_CODLS}),
connectionless data link service
(@pval{DL_CLDLS}),
acknowledged connectionless service
(@pval{DL_ACDLS})
or all.

@tabfig{dlpi_ta11,6,DLPI Provider-Originated Events}

@page
@node DLPI State Transition Table
@appendixsec DLPI State Transition Table
@tabref{7}, @tabref{8}, @tabref{9} and @tabref{10} describe the @acronym{DLPI} state
transitions.  Each column represents a state of @acronym{DLPI} (@tabref{2a}) and each row
represents a @acronym{DLPI} event (@tabref{5} and @tabref{6}).  The intersecting transition
cell defines the resulting state transition (i.e.  next state) and associated
actions, if any, that must be executed by the DLS provider to maintain the
interface state.  Each cell may contain the following:

@center @image{dlpi_ta12}

The
@prim{DL_INFO_REQ},
@prim{DL_INFO_ACK},
@prim{DL_TOKEN_REQ}, and
@prim{DL_TOKEN_ACK} primitives
are excluded from the state transition table because they can be issued from many
states and, when fully processed, do not cause a state transition to occur.
However, the DLS user may not issue a
@prim{DL_INFO_REQ} or
@prim{DL_TOKEN_REQ} if any local
acknowledgments are pending.  In other words, these two primitives may not be
issued until the DLS user receives the acknowledgment for any previously issued
primitive that is expecting local positive acknowledgment.  Thus, these
primitives may not be issued from the
@psta{DL_ATTACH_PENDING},
@psta{DL_DETACH_PENDING},
@psta{DL_BIND_PENDING},
@psta{DL_SUBS_BIND_PND},
@psta{DL_SUBS_UNBIND_PND},
@psta{DL_UNBIND_PENDING},
@psta{DL_UDQOS_PENDING},
@psta{DL_CONN_RES_PENDING},
@psta{DL_RESET_RES_PENDING},
@psta{DL_DISCON8_PENDING},
@psta{DL_DISCON9_PENDING},
@psta{DL_DISCON11_PENDING},
@psta{DL_DISCON12_PENDING}, or
@psta{DL_DISCON13_PENDING} states.  Failure to
comply by this restriction may result in loss of primitives at the stream head
if the DLS user is a user process.  Once a
@prim{DL_INFO_REQ} or
@prim{DL_TOKEN_REQ}
has been issued, the DLS provider must respond with the appropriate
acknowledgment primitive.

The following rules apply to the maintenance of @acronym{DLPI} state:

@itemize @bullet
@item The DLS provider is responsible for keeping a record of the state of the
interface as viewed by the DLS user, to be returned in the
@prim{DL_INFO_ACK}.

@item The DLS provider may never generate a primitive that places the interface
out of state (i.e.  would correspond to a "-" cell entry in the state transition
table below).

@item If the DLS provider generates a @acronym{STREAMS} @msg{M_ERROR} message upstream, it
should free any further primitives processed by it's write side put or service
procedure.

@item The close of a stream is considered an abortive action by the DLS user,
and may be executed from any state.  The DLS provider must issue appropriate
indications to the remote DLS user when a close occurs.  For example, if the
@acronym{DLPI}
state is
@psta{DL_DATAXFER},
a
@prim{DL_DISCONNECT_IND}
should be sent to the remote DLS user.
The DLS provider should free any resources associated with that stream and reset
the stream to its unopened condition.  The following points clarify the state
transition table.

@item If the DLS provider supports connection-mode service, the value of the
@cpindex Connection mode
outcnt state variable must be initialized to zero for each stream when that
stream is first opened.

@item The initial and final state for a style 2 DLS provider is
@psta{DL_UNATTACHED}.
However, because a style 1 DLS provider implicitly attaches a @acronym{PPA} to a stream
when it is opened, the initial and final @acronym{DLPI} state for a style 1 provider is
@psta{DL_UNBOUND}.
The DLS user should not issue
@prim{DL_ATTACH_REQ}
or @prim{DL_DETACH_REQ}
primitives to a style 1 DLS provider.

@item A DLS provider may have multiple connect indications outstanding (i.e.  the
DLS user has not responded to them) at one time (@pxref{Multi-threaded Connection
Establishment}).  As the state transition table points out, the stream on which
those indications are outstanding will remain in the
@psta{DL_INCON_PENDING}
state until the DLS provider receives a response for all indications.

@item The @acronym{DLPI} state associated with a given stream may be transferred to
another stream only when the
@prim{DL_CONNECT_RES}
primitive indicates this behavior.  In this case, the responding stream (where
the connection will be established) must be in the
@psta{DL_IDLE}
state.  This state transition is indicated by the PASS_CONN event in
@tabref{9}.

@item The labeling of the states
@psta{DL_PROV_RESET_PENDING}
and
@psta{DL_USER_RESET_PENDING}
indicate the party that started the local interaction, and does not necessarily
indicate the originator of the reset procedure.

@item A
@prim{DL_DATA_REQ}
primitive received by the DLS provider in the
state
@psta{DL_PROV_RESET_PENDING}
(i.e.  after a
@prim{DL_RESET_IND}
has been passed to the DLS
user) or the state
@psta{DL_IDLE}
(i.e.  after a data link connection has been released) should be discarded by
the DLS provider.

@item A @prim{DL_DATA_IND} primitive received by the DLS user after the user has
issued a @prim{DL_RESET_REQ} should be discarded.  To ensure accurate processing
of @acronym{DLPI} primitives, the DLS provider must adhere to the following rules
concerning the receipt and generation of @acronym{STREAMS} @msg{M_FLUSH} messages
during various state transitions.

@item The DLS provider must be ready to receive @msg{M_FLUSH} messages from
upstream and flush it's queues as specified in the message.

@item The DLS provider must issue an @msg{M_FLUSH} message upstream to flush
both the read and write queues after receiving a successful @prim{DL_UNBIND_REQ}
primitive but before issuing the @prim{DL_OK_ACK}.

@item If an incoming disconnect occurs when the interface is in the
@psta{DL_DATAXFER}, @psta{DL_USER_RESET_PENDING}, or
@psta{DL_PROV_RESET_PENDING} state, the DLS provider must send up an
@msg{M_FLUSH} message to flush both the read and write queues before sending up
a @prim{DL_DISCONNECT_IND}.

@item If a @prim{DL_DISCONNECT_REQ} is issued in the @psta{DL_DATAXFER},
@psta{DL_USER_RESET_PENDING}, or @psta{DL_PROV_RESET_PENDING} states, the DLS
provider must issue an @msg{M_FLUSH} message upstream to flush both the read and
write queues after receiving the successful @prim{DL_DISCONNECT_REQ} but before
issuing the @prim{DL_OK_ACK}.

@item If a reset occurs when the interface is in the @psta{DL_DATAXFER} or
@psta{DL_USER_RESET_PENDING} state, the DLS provider must send up an
@msg{M_FLUSH} message to flush both the read and write queues before sending up
a @prim{DL_RESET_IND} or @prim{DL_RESET_CON}.

@end itemize

The following table presents the allowed sequence of @acronym{DLPI} primitives for the
common local management phase of communication.

@tabfig{dlpi_ta13,7,DLPI State Transition Table - Local Management Phase}

The following table presents the allowed sequence of @acronym{DLPI} primitives for the
connectionless data transfer phase.

@tabfig{dlpi_ta14,8,DLPI State Transition Table - Connectionless-mode Data Transfer Phase}

@tabfig{dlpi_ta15,9,DLPI State Transition Table - Acknowledged Connectionless-mode Data Transfer Phase}

The following table presents the allowed sequence of @acronym{DLPI} primitives for the
connection establishment phase of connection mode service.

@tabfig{dlpi_ta16,10,DLPI State Transition Table - Connection Establishment Phase}

The following table presents the allowed sequence of @acronym{DLPI} primitives for the
connection mode data transfer phase.

@tabfig{dlpi_ta17,11,DLPI State Transition Table - Connection-mode Data Transfer Phase}

@node Precedence of DLPI Primitives
@appendix Precedence of DLPI Primitives

@menu
* Write Queue Precedence::
* Read Queue Precedence::
@end menu

This appendix presents the precedence of @acronym{DLPI} primitives relative to one
another.  Two queues are used to describe @acronym{DLPI} precedence rules.  One queue
contains DLS user-originated primitives and corresponds to the @acronym{STREAMS}
write queue of the DLS provider.  The other queue contains DLS
provider-originated primitives and corresponds to the @acronym{STREAMS} read queue
of the DLS user.  The DLS provider is responsible for determining precedence on
its write queue and the DLS user is responsible for determining precedence on
its read queue as indicated in the precedence tables below.  For each precedence
table, the rows (labeled PRIM X) correspond to primitives that are on the given
queue and the columns (labeled PRIM Y) correspond to primitives that are about
to be placed on that queue.  Each pair of primitives (PRIM X, PRIM Y) may be
manipulated resulting in:

@itemize @bullet
@item Change of order, where the order of a pair of primitives is reversed if,
and only if, the second primitive in the pair (PRIM Y) is of a type defined to
be able to advance ahead of the first primitive in the pair (PRIM X).

@item Deletion, where a primitive (PRIM X) may be deleted if, and only if, the
primitive that follows it(PRIM Y) is defined to be destructive with respect to
that primitive.  Destructive primitives may always be added to the queue.  Some
primitives may cause both primitives in the pair to be destroyed.  The
precedence rules define the allowed manipulations of a pair of @acronym{DLPI} primitives.
Whether these actions are performed is the choice of the DLS provider for
user-originated primitives and the choice of the DLS user for
provider-originated primitives.
@end itemize

@page
@node Write Queue Precedence
@appendixsec Write Queue Precedence
The following table presents the precedence rules for DLS user-originated
primitives on the DLS provider's @acronym{STREAMS} write queue.  It assumes that
only non-local primitives (i.e.  those that generate protocol data units to a
peer DLS user) are queued by the DLS provider.

@cpindex Connection establishment
For connection establishment primitives, this table represents the possible
pairs of @acronym{DLPI} primitives when connect indications/responses are single-threaded.
For the multi-threading scenario, the following rules apply:

@itemize @bullet

@item A @prim{DL_CONNECT_RES} primitive has no precedence over either a
@prim{DL_CONNECT_RES} or a @prim{DL_DISCONNECT_REQ} primitive that is associated
with another connection correlation number (dl_correlation), and should
therefore be placed on the queue behind such primitives.

@item Similarly, a @prim{DL_DISCONNECT_REQ} primitive has no precedence over
either a @prim{DL_CONNECT_RES} or a @prim{DL_DISCONNECT_REQ} primitive that is
associated with another connection correlation number, and should therefore be
placed on the queue behind such primitives.  Notice, however, that a
@prim{DL_DISCONNECT_REQ} does have precedence over a @prim{DL_CONNECT_RES}
primitive that is associated with the same correlation number (this is indicated
in the table below).
@end itemize

@tabfig{dlpi_ta18,12,Write Queue Precedence}

@page
@node Read Queue Precedence
@appendixsec Read Queue Precedence
The following table presents the precedence rules for DLS provider-originated
primitives on the DLS user's @acronym{STREAMS} read queue.

@cpindex Connection establishment
For connection establishment primitives, this table represents the possible
pairs of @acronym{DLPI} primitives when connect indications/responses are single-threaded.
For the multi-threading scenario, the following rules apply:

@enumerate
@item A @prim{DL_CONNECT_IND} primitive has no precedence over either a
@prim{DL_CONNECT_IND} or a @prim{DL_DISCONNECT_IND} primitive that is associated
with another connection correlation number (dl_correlation), and should
therefore be placed on the queue behind such primitives.

@item Similarly, a @prim{DL_DISCONNECT_IND} primitive has no precedence over
either a @prim{DL_CONNECT_IND} or a @prim{DL_DISCONNECT_IND} primitive that is
associated with another connection correlation number, and should therefore be
placed on the queue behind such primitives.

@item A @prim{DL_DISCONNECT_IND} does have precedence over a
@prim{DL_CONNECT_IND} primitive that is associated with the same correlation
number (this is indicated in the table below).  If a @prim{DL_DISCONNECT_IND} is
about to be placed on the DLS user's read queue, the user should scan the read
queue for a possible @prim{DL_CONNECT_IND} primitive with a matching correlation
number.  If a match is found, both the @prim{DL_DISCONNECT_IND} and matching
@prim{DL_CONNECT_IND} should be removed.
@end enumerate

If the DLS user is a user-level process, it's read queue is the stream head read
queue.  Because a user process has no control over the placement of DLS
primitives on the stream head read queue, a DLS user cannot straightforwardly
initiate the actions specified in the following precedence table.  Except for
the connection
@cpindex Connection establishment
establishment scenario, the DLS user can ignore the precedence rules defined in
the table below.  This is equivalent to saying the DLS user's read queue
contains at most one primitive.  The only exception to this rule is the
processing of connect indication/response primitives.  A problem arises if a
user issues a @prim{DL_CONNECT_RES} primitive when a @prim{DL_DISCONNECT_IND} is
on the stream head read queue.  The DLS provider will not be expecting the
connect response because it has forwarded the disconnect indication to the DLS
user and is in the @psta{DL_IDLE} state.  It will therefore generate an error
upon seeing the @prim{DL_CONNECT_RES}.  To avoid this error, the DLS user should
not respond to a @prim{DL_CONNECT_IND} primitive if the stream head read queue
is not empty.  The assumption here is a nonempty queue may be holding a
disconnect indication that is associated with the connect indication that is
being processed.

When connect indications/responses are single-threaded, a non-empty read queue
can only contain a @prim{DL_DISCONNECT_IND}, which must be associated with the
outstanding @prim{DL_CONNECT_IND}.  This @prim{DL_DISCONNECT_IND} primitive
indicates to the DLS user that the @prim{DL_CONNECT_IND} is to be removed.  The
DLS user should not issue a response to the @prim{DL_CONNECT_IND} if a
@prim{DL_DISCONNECT_IND} is received.  The multi-threaded scenario is slightly
more complex, because multiple @prim{DL_CONNECT_IND} and
@prim{DL_DISCONNECT_IND} primitives may be interspersed on the stream head read
queue.  In this scenario, the DLS user should retrieve all indications on the
queue before responding to a given connect indication.  If a queued primitive is
a @prim{DL_CONNECT_IND}, it should be stored by the user process for eventual
response.  If a queued primitive is a @prim{DL_DISCONNECT_IND}, it should be
matched (using the correlation number) against any stored connect indications.
The matched connect indication should then be removed, just as is done in the
single-threaded scenario.

@tabfig{dlpi_ta19,13,Read Queue Precedence}

@node Glossary of DLPI Terms and Acronyms
@appendix Glossary of DLPI Terms and Acronyms

@menu
* Acronyms::
* Terms::
@end menu

@node Acronyms
@appendixsec Acronyms
The following acronyms apply to the Data Link Provider Interface:
@table @b
@item DLPI
@cpindex DLPI, Data Link Provder Interface
Data Link Provider Interface
@item DLS
@cpindex DLS, Data Link Service
Data Link Service
@item DLSAP
@cpindex DLSAP, Data Link Service Access Point
Data Link Service Access Point
@item DLSDU
@cpindex DLSDU, Data Link Service Data Unit
Data Link Service Data Unit
@item ISO
@cpindex ISO, International Organization for Standardization
International Organization for Standardization
@item OSI
@cpindex OSI, Open Systems Interconnection
Open Systems Interconnection
@item @acronym{PPA}
@cpindex PPA, Physical Point of Attachment
Physical Point of Attachment
@item QOS
@cpindex QOS, Quality of Service
Quality of Service
@end table

@node Terms
@appendixsec Terms
The following terms apply to the Data Link Provider Interface:
@table @emph
@item Called DLS user
@cpindex Called DLS user
The DLS user in connection mode that processes requests for connections from
other DLS users.

@item Calling DLS user
@cpindex Calling DLS user
The DLS user in connection mode that initiates the establishment of a data link
connection.

@item Communication endpoint
@cpindex Communication endpoint
The local communication channel between a DLS user and DLS provider.

@item Connection establishment
@cpindex Connection establishment
The phase in connection mode that enables two DLS users to create a data link
connection between them.

@item Connectionless mode
@cpindex Connectionless mode
A mode of transfer in which data is passed from one user to another in
self-contained units with no logical relationship required among the units.

@item Connection management stream
@cpindex Connection management stream
A special stream that will receive all incoming connect indications destined for
@acronym{DLSAP} addresses that are not bound to any other streams associated with a
particular @acronym{PPA}.

@item Connection mode
@cpindex Connection mode
A circuit-oriented mode of transfer in which data is passed from one user to
another over an established connection in a sequenced manner.

@item Connection release
@cpindex Connection release
The phase in connection mode that terminates a previously established data link
connection.

@item Data link service data unit
@cpindex Data link service data unit
A grouping of DLS user data whose boundaries are preserved from one end of a
data link connection to the other.

@item Data transfer
@cpindex Data transfer
The phase in connection and connectionless modes that supports the transfer of
data between two DLS users.

@item DLSAP
@cpindex DLSAP, Data Link Service Access Point
An point at a DLS user attaches itself to a DLS provider to access data link
services.

@item DLSAP address
@cpindex DLSAP address
An identifier used to differentiate and locate specific DLS user access points
to a DLS provider.

@item DLS provider
@cpindex DLS provider
The data link layer protocol that provides the services of the Data Link
Provider Interface.

@item DLS user
@cpindex DLS user
The user-level application or user-level or kernel-level protocol that accesses
the services of the data link layer.

@item Local management
@cpindex Local management
The phase in connection and connectionless modes in which a DLS user initializes
a stream and binds a @acronym{DLSAP} to the stream.  Primitives in this phase generate
local operations only.

@item @acronym{PPA}
@cpindex PPA, Physical Point of Attachment
The point at which a system attaches itself to a physical communications medium.

@item @acronym{PPA} identifier
@cpindex PPA identifier
An identifier of a particular physical medium over which communication
transpires.

@item Quality of service
@cpindex Quality of service
Characteristics of transmission quality between two DLS users.

@end table

@node Guidelines for Protocol Independent DLS Users
@appendix Guidelines for Protocol Independent DLS Users
@acronym{DLPI} enables a DLS user to be implemented in a protocol-independent manner such
that the DLS user can operate over many DLS providers without changing the DLS
user software.  DLS user implementors must adhere to the following guidelines,
however, to achieve this independence.

@itemize @bullet
@item The protocol-specific service limits returned in the
@prim{DL_INFO_ACK}
primitive (e.g.  dl_max_sdu) mustn't be exceeded.  The DLS user should access
these limits and adhere to them while interacting with the DLS provider.

@item Protocol-specific @acronym{DLSAP} address and @acronym{PPA} identifier formats should be
hidden from DLS user software.  Hard-coded addresses and identifiers must be
avoided.  The DLS user should retrieve the necessary information from some other
entity (such as a management entity or a higher layer protocol entity) and insert
it without inspection into the appropriate primitives.

@item The DLS user should not be written to a specific style of DLS provider
(i.e.  style 1 vs.  style 2).  The
@prim{DL_INFO_ACK}
returns sufficient information to identify which style of provider has been
accessed, and the DLS user should perform (or not perform) a
@prim{DL_ATTACH_REQ}
accordingly.

@item The names of devices should not be hard-coded into user-level programs
that access a DLS provider.

@item The DLS user should access the dl_service_mode field of the
@prim{DL_INFO_ACK}
primitive to determine whether connection or connectionless services are
available on a given stream.

@end itemize

@node Required Information for DLS Provider-Specific Addenda
@appendix Required Information for DLS Provider-Specific Addenda
@acronym{DLPI} is a general interface to the services of any DLS provider.  However, areas
have been documented in this specification where DLS provider-specific
information can be conveyed and interpreted.  This appendix summarizes all
provider-specific issues as an aid to developers of DLS provider implementations.
As such, it forms a checklist of required information that should be documented
in some manner as part of the provider implementation.  The areas DLS
provider-specific addendum documentation must address are:

@itemize @bullet
@item DLSAP Address Space

@item @acronym{PPA} Access and Control

@item Quality of Service

@item @prim{DL_INFO_ACK} Values

@item Supported Services
@end itemize

For each area listed, a brief description of the provider-specific item(s)
associated with it will be presented, including references to the appropriate
section in this specification.

@acronym{DLSAP} Address Space (Sections 2.3.2 and 4.1.6) The format of a @acronym{DLSAP} address is
specific to each DLS provider, as is the management of that address space.
There are no restriction on the format or style of a @acronym{DLSAP} address.  As such, a
specific implementation should document the format, size, and restrictions of a
@acronym{DLSAP} address, as well as information on how the address space is managed.  For
example, @acronym{DLPI} enables a DLS user to choose a specific @acronym{DLSAP} address to be bound
to a stream, but a given implementation may pre-associate addresses with streams
based, for example, on the major/minor device number of the stream.  In this
case, the DLS user could only retrieve the address associated with a stream.  If
the DLS provider enables a user to select the @acronym{DLSAP} address for a stream, the
implementation must document the contents of the dl_sap field in the
@prim{DL_BIND_REQ}.  This field must contain sufficient information to enable
the DLS provider to determine the chosen @acronym{DLSAP} address.  This may be the full
@acronym{DLSAP} address (if it is not larger than sizeof(ulong)), or some distinguishable
part of that address.  For example, an implementation of a DLS provider
conforming to the ISO 8802/2 address space might allow the DSAP or SSAP portion
of the @acronym{DLSAP} address to be specified here, where the MAC address portion remains
constant over all @acronym{DLSAP} addresses managed by that provider.

Another aspect of address management is whether the provider supports the
ability to dynamically allocate DLSAPs other than the requested @acronym{DLSAP} in a
@prim{DL_BIND_REQ}.  Restrictions on DLSAPs might cover the range of supported
@acronym{DLSAP} values, services
@cpindex Connection management stream
provided by a @acronym{DLSAP}, connection management, and multiplexing.  An example of
connection management restrictions is the number of connections allowed per
@acronym{DLSAP}.  Examples of multiplexing restrictions include the number of DLSAPs per
@acronym{PPA}, and requirements that certain DLSAPs are attached to specific PPAs.

Subsequent @acronym{DLSAP} Addresses (Section 4.1.9)
The IEEE 802.2 link layer standard allows two ways of specifying a
@acronym{DLSAP} value:

@itemize @bullet
@item Using an IEEE reserved @acronym{DLSAP} which corresponds to a well-defined protocol.

@item Using a privately defined @acronym{DLSAP}.  Previously, subnetworks used privately
defined @acronym{DLSAP} values.  As these subnetworks move into the OSI world, they may
exist in environments with other vendors machines.  This presents a problem
because there are only 64 privately definable DLSAPS and any other vendor may
choose to use these same @acronym{DLSAP} values.
@end itemize

IEEE 802.1 has defined a third way of assigning @acronym{DLSAP} values that will allow for
unique private protocol de-multiplexing.  The @prim{DL_SUBS_BIND_REQ} may be
used to support this method.  The Subsequent binding of DLSAPs can be peer or
hierarchical.  When the User requests peer addressing, the
@prim{DL_SUBS_BIND_REQ} will specify a @acronym{DLSAP} that may be used in lieu of the
@acronym{DLSAP} that was bound in the @prim{DL_BIND_REQ}.  This will allow for a choice to
be made between a number of DLSAPs on a stream when determining traffic based on
@acronym{DLSAP} values.  An example of this would be to various ether_type values as
DLSAPs.  The @prim{DL_BIND_REQ}, for example, could be issued with ether_type
value of IP, and a subsequent bind could be issued with ether type value of ARP.
The Provider may now multiplex off of the ether_type field and allow for either
IP or ARP traffic to be sent up this stream.  When the DLS User requests
hierarchical binding, the @prim{DL_SUBS_BIND_REQ} will specify a @acronym{DLSAP} that will
be used in addition to the @acronym{DLSAP} bound using a @prim{DL_BIND_REQ}.  This will
allow additional information to be specified, that will be used in a header or
used for de-multiplexing.  An example of this would be to use hierarchical bind
to specify the OUI (organizationally unique identifier) to be used by SNAP.  If
a DLS Provider supports peer subsequent bind operations, the first SAP that is
bound is used as the source SAP when there is ambiguity.

@acronym{PPA} Access and Control (Sections 2.3.1 and 4.1.1)
A physical point of attachment (@acronym{PPA}) is referenced in @acronym{DLPI} by a @acronym{PPA} identifier,
which is of type 'ulong'.  The format of this identifier is provider-specific.
The DLS provider addendum documentation should describe the format and
generation of @acronym{PPA} identifiers for all physical media it is expected to control.
It should also describe how a @acronym{PPA} is controlled, the capabilities of the
@acronym{PPA},
the number of PPAs supported, and the administrative interface.  Multiplexing
capabilities of a @acronym{PPA} should also be described in the DLS provider addendum
documentation.  This conveys information on the number of DLSAPs that may be
supported per @acronym{PPA}, and the number of PPAs supported.  Another item that should
be described is the manner in which a @acronym{PPA} is initialized.  Section 4.1.1,
@acronym{PPA}
Initialization/De-initialization, presents the alternative methods supported by
@acronym{DLPI} for initializing a @acronym{PPA}.  The interactions of auto-initialization or
pre-initialization with the Attach and Bind services should be discussed, and
the following items should be addressed.

@itemize @bullet
@item Is auto-initialization, pre-initialization, or both supported for a
@acronym{PPA}?

@item Can the method of initialization be restricted on a @acronym{PPA} basis?
@end itemize

Quality of Service (Section 5)
Support of @acronym{QoS} parameter negotiation and selection is a provider-specific issue
that must be described for each implementation.  The DLS provider addendum
documentation should describe which, if any, @acronym{QoS} parameters are supported by the
provider.  For parameters that are negotiated end-to-end, the addendum should
describe whether the provider supports end-to-end negotiation, or whether these
parameters are negotiated in a local manner only.  Finally, default
@acronym{QoS}
parameter values should be documented.

@prim{DL_INFO_ACK} Values (Section 4.1.3)
The
@prim{DL_INFO_ACK}
primitive specifies information on a DLS provider's restrictions
and capabilities.  The DLS provider addendum documentation should describe the
values for all fields in the
@prim{DL_INFO_ACK}, and how they are determined (static,
tunable, dynamic).  At a minimum, the addendum must describe the provider style
and the service modes supported by the DLS provider.

Supported Services (Section 3)
The overall services that a specific DLS provider supports should be described.
@cpindex Connection mode
These include whether a provider supports connection-mode service,
connectionless-mode service (acknowledged or OSI Work Group unacknowledged), or
both, and how a DLS user selects the appropriate mode.  For example, the mode
maybe mapped directly to a specific major/minor device, and the user selects an
appropriate mode by opening the corresponding special file.  Alternatively, a
DLS provider that supports both modes may enable a DLS user to select the
service mode on the @prim{DL_BIND_REQ}.

The file name(s) used to access a particular DLS provider and/or specific
service modes of that provider must also be documented.

@node DLPI Header File
@appendix DLPI Header File
This appendix contains a listing of the @acronym{DLPI} header file needed by
implementations of both DLS user and DLS provider software.

@smallformat
@verbatiminclude dlpi.h
@end smallformat

@node References
@unnumbered References

@enumerate 1

@item International Organization for Standardization, "Data Link Service
Definition for Open Systems Interconnection," DIS 8886, February 1987.

@item International Organization for Standardization, "Logical Link Control,"
DIS 8802/2, 1985.

@item

@item CCITT Recommendation X.200, "Reference Model of Open Systems
Interconnection for CCITT Applications," 1984.

@end enumerate

@ifnotplaintext
@c skip indexes for plain text (regex search works better)
@c @iftex
@c @node Indices
@c @unnumbered Indices
@c @end iftex

@c @ifnottex
@c @c concatenate indices for html and info
@node Index
@unnumbered Index
@printindex cp
@c @end ifnottex

@c @iftex
@c @menu
@c * Concept Index::
@c * Protocol State Index::
@c * Primitive Index::
@c * Primitive Structure and Type Index::
@c * Primitive Structure Field Index::
@c * Primitive Values Index::
@c * Primitive Error Values Index::
@c * Input-Output Control Index::
@c * MIB Object Index::
@c * Manual Page Index::
@c @end menu
@c 
@c @node Concept Index
@c @section Concept Index
@c @printindex cp
@c 
@c @page
@c @node Protocol State Index
@c @section Protocol State Index
@c @printindex st
@c 
@c @page
@c @node Primitive Index
@c @section Primitive Index
@c @printindex pr
@c 
@c @page
@c @node Primitive Structure and Type Index
@c @section Primitive Structure and Type Index
@c @printindex tp
@c 
@c @page
@c @node Primitive Structure Field Index
@c @section Primitive Structure Field Index
@c @printindex vr
@c 
@c @page
@c @node Primitive Values Index
@c @section Primitive Values Index
@c @printindex pv
@c 
@c @page
@c @node Primitive Error Values Index
@c @section Primitive Error Values Index
@c @printindex pe
@c 
@c @page
@c @node Input-Output Control Index
@c @section Input-Output Control Index
@c @printindex ct
@c 
@c @page
@c @node MIB Object Index
@c @section MIB Object Index
@c @printindex mo
@c 
@c @page
@c @node Manual Page Index
@c @section Manual Page Index
@c @printindex mp
@c @end iftex
@end ifnotplaintext

@page
@shortcontents
@page
@contents
@bye
