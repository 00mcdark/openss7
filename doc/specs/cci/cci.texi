\input texinfo
@c -*- texinfo -*- vim: ft=texinfo
@c vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
@c =========================================================================
@c
@c @(#) doc/specs/cci/cci.texi
@c
@c =========================================================================
@c
@c Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
@c Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
@c Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
@c
@c All Rights Reserved.
@c
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.3 or
@c any later version published by the Free Software Foundation; with no
@c Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
@c copy of the license is included in the section entitled "GNU Free
@c Documentation License".
@c
@c Permission to use, copy and distribute this documentation without
@c modification, for any purpose and without fee or royalty is hereby
@c granted, provided that both the above copyright notice and this
@c permission notice appears in all copies and that the name of OpenSS7
@c Corporation not be used in advertising or publicity pertaining to
@c distribution of this documentation or its contents without specific,
@c written prior permission.  OpenSS7 Corporation makes no representation
@c about the suitability of this documentation for any purpose.  It is
@c provided "as is" without express or implied warranty.
@c 
@c Permission is granted to process this file through Tex and print the
@c results, provided the printed document carries copying permission
@c notice identical to this one except for the removal of this paragraph
@c (this paragraph not being relevant to the printed manual).
@c 
@c OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
@c DOCUMENTATION INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
@c FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE
@c CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE
@c IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY
@c PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN NO EVENT SHALL
@c OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
@c CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
@c USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
@c OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
@c THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS
@c THEREOF.
@c 
@c Since the Linux kernel and libraries are constantly changing, this
@c manual page may be incorrect or out-of-date.  The author(s) assume no
@c responsibility for errors or omissions, or for damages resulting from
@c the use of the information contained herein.  The author(s) may not
@c have taken the same level of care in the production of this manual,
@c which is licensed free of charge, as they might when working
@c professionally.
@c 
@c Formatted or processed versions of this manual, if unaccompanied by
@c the source, must acknowledge the copyright and authors of this work.
@c
@c -------------------------------------------------------------------------
@c
@c U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
@c on behalf of the U.S. Government ("Government"), the following
@c provisions apply to you.  If the Software is supplied by the Department
@c of Defense ("DoD"), it is classified as "Commercial Computer Software"
@c under paragraph 252.227-7014 of the DoD Supplement to the Federal
@c Acquisition Regulations ("DFARS") (or any successor regulations) and the
@c Government is acquiring only the license rights granted herein (the
@c license rights customarily provided to non-Government users).  If the
@c Software is supplied to any unit or agency of the Government other than
@c DoD, it is classified as "Restricted Computer Software" and the
@c Government's rights in the Software are defined in paragraph 52.227-19
@c of the Federal Acquisition Regulations ("FAR") (or any successor
@c regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
@c NASA Supplement to the FAR (or any successor regulations).
@c
@c =========================================================================
@c 
@c Commercial licensing and support of this software is available from
@c OpenSS7 Corporation at a fee.  See http://www.openss7.com/
@c 
@c =========================================================================
@c

@setfilename cci.info
@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE Call Control Interface (CCI)
@set MANUAL_TYPE Specification
@settitle @value{MANUAL_TITLE}

@dircategory OpenSS7
@direntry
* CCI: (cci).				Call Control Interface
@end direntry

@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE Call Control Interface (CCI)
@set MANUAL_TYPE Specification

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}.

Copyright @copyright{} 2008-2015  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2001  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*

All Rights Reserved.

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled @ref{GNU Free Documentation License}.

Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@ignore
Permission is granted to process this file through Tex and print the results, provided the printed
document carries copying permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT
THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE IMPLEMENTATION OF SUCH
CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN
NO EVENT SHALL OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.
@end ifinfo

@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE Call Control Interface (CCI)
@set MANUAL_TYPE Specification

@set PART Call Control
@set LONG Call Control
@set SHORT CC
@set INTERFACE CCI

@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 1
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@subtitle Updated @value{PACKAGE_PDATE}
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@sp 2
@subtitle Copyright @copyright{} 2008-2015  Monavacon Limited
@subtitle All Rights Reserved.
@sp 4
@quotation
@chapheading Abstract:
This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.  It provides abstraction of the
@value{LONG} (@value{SHORT}) interface to these components as well as providing a basis for
@value{LONG} control for other @value{LONG} protocols.
@end quotation
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll

@chapheading Published by:

@sp 1

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Copyright @copyright{} 2008-2015  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*

@noindent
All Rights Reserved.

@sp 1

@noindent
Unauthorized distribution or duplication is prohibited.

@sp 1

@noindent
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled @ref{GNU Free Documentation License}.

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@chapheading Notice:

@noindent
@strong{OpenSS7 Corporation disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights.  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.}

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defcodeindex pr
@c Define an index of primitive values
@defcodeindex pv
@c Define an index of primitive error values
@defcodeindex pe
@c Define an index of protocol states
@defcodeindex st
@c Define an index of input-output controls
@defcodeindex ct
@c Define an index of manual pages.
@defcodeindex mp
@c Define an index of MIB objects.
@defcodeindex mo

@c frags out automake
@c @ifnottex
@c @c concatenate indices for text, html and info
@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex pe cp
@syncodeindex st cp
@syncodeindex mp cp
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex ct cp
@syncodeindex mo cp
@c @end ifnottex

@include texi/macros.texi
@include texi/versions.texi
@include texi/prims.texi

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@heading About This Manual
This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of
@cite{The @value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version
@value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} of the
@value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Preface::
* Introduction::
* The Call Control Layer::
* CCI Services Definition::
* CCI Primitives::
* Diagnostics Requirements::
* Addendum for Q.931 Conformance::
* Addendum for Q.764 Conformance::
* Addendum for ETSI EN 300 356-1 V3.2.2 Conformance::
* Mapping of CCI Primitives to Q.931::
* Mapping of CCI Primitives to Q.764::
* State/Event Tables::
* Primitive Precedence Tables::
* CCI Header File Listing::
* Glossary::
* Acronyms::
* References::
* Licenses::
@c @iftex
@c * Indices::
@c @end iftex
@c @ifnottex
* Index::
@c @end ifnottex
@end menu

@shortcontents
@contents

@node Preface
@unnumbered Preface

@section Notice

Software in this document and related software is released under the AGPL (@pxref{GNU Affero General
Public License}).  Please note, however, that there are different licensing terms for some of the
manual package and some of the documentation.  Consult permission notices contained in the
documentation of those components for more information.

This document is released under the FDL (@pxref{GNU Free Documentation License}) with no invariant
sections, no front-cover texts and no back-cover texts.

@section Abstract

This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.

@noindent
This document specifies a @value{MANUAL_TITLE} Specification in support of the OpenSS7 Integrated
Service Digital Network (ISDN) and ISDN User Part (ISUP) protocol stacks.@footnote{As a future
extension to the interface, H.225, BSSAP, and SIP will be supported.} It provides abstraction of the
call control interface to these components as well as providing a basis for call control for other
call control signalling protocols.

@subsection Purpose
@cpindex STREAMS

The purpose of this document is to provide technical documentation of the @value{MANUAL_TITLE}.
This document is intended to be included with the OpenSS7 @acronym{STREAMS} software package released
by @cite{OpenSS7 Corporation}.  It is intended to assist software developers, maintainers and users
of the @value{MANUAL_TITLE} with understanding the software architecture and technical interfaces
that are made available in the software package.

@subsection Intent

It is the intent of this document that it act as the primary source of information concerning the
@value{MANUAL_TITLE}.  This document is intended to provide information for writers of OpenSS7
@value{MANUAL_TITLE} applications as well as writers of OpenSS7 @value{MANUAL_TITLE} Users.

@subsection Audience

The audience for this document is software developers, maintainers and users and integrators of the
@value{MANUAL_TITLE}.  The target audience is developers and users of the OpenSS7 SS7 and ISDN stack.

@section Revision History

Take care that you are working with a current version of this documentation: you will not be
notified of updates.  To ensure that you are working with a current version, check the
@uref{http://www.openss7.org/,OpenSS7 Project} website for a current version.

A current version of this specification is normally distributed with the @cite{@value{PACKAGE_TITLE}}
package, @file{@value{PACKAGE}-@value{VERSION}}.@footnote{@url{http://www.openss7.org/repos/tarballs/@value{PACKAGE}-@value{VERSION}.tar.bz2}}

@subsection Version Control

@noindent
Although the author has attempted to ensure that the information in this document is complete and
correct, neither the Author nor OpenSS7 Corporation will take any responsibility in it.
@cite{OpenSS7 Corporation} is making this documentation available as a reference point for the
industry.  While @cite{OpenSS7 Corporation} believes that these interfaces are well defined in this
release of the document, minor changes may be made prior to products conforming to the interfaces
being made available.  @cite{OpenSS7 Corporation} reserves the right to revise this software and
documentation for any reason, including but not limited to, conformity with standards promulgated by
various agencies, utilization of advances in the state of the technical arts, or the reflection of
changes in the design of any techniques, or procedures embodied, described, or referred to herein.
@cite{OpenSS7 Corporation} is under no obligation to provide any feature listed herein.

@smallexample
@verbatim
$Log: cci.texi,v $
Revision 1.1.2.2  2011-02-07 02:21:37  brian
- updated manuals

Revision 1.1.2.1  2009-06-21 10:52:47  brian
- added files to new distro

@end verbatim
@end smallexample

@section ISO 9000 Compliance

Only the @TeX{}, texinfo, or roff source for this maual is controlled.  An opaque (printed,
postscript or portable document format) version of this manual is a @strong{UNCONTROLLED VERSION}.

@subsection Disclaimer

@noindent
@strong{@cite{OpenSS7 Corporation} disclaims all warranties with regard to this documentation
including all implied warranties of merchantability, fitness for a particular purpose,
non-infrincement, or title; that the contents of the manual are suitable for any purpose, or that
the implementation of such contents will not infringe on any third party patents, copyrights,
trademarks or other rights.  In no event shall @cite{OpenSS7 Corporation} be liable for any direct,
indirect, special or consequential damages or any damages whatsoever resulting from loss of use,
data or profits, whether in an action or contract, negligence or other tortious action, arising out
of or in connection with any use of this documentation or the performance or implementation of the
contents thereof.}

@subsection U.S. Government Restricted Rights

If you are licensing this Software on behalf of the U.S. Government ("Government"), the following
provisions apply to you.  If the Software is supplied by the Department of Defense ("DoD"), it is
classified as "Commercial Computer Software" under paragraph 252.227-7014 of the DoD Supplement to
the Federal Aquisition Regulations ("DFARS") (or any successor regulations) and the Government is
acquiring only the license rights granded herein (the license rights customarily provided to
non-Government users).  If the Software is supplied to any unit or agency of the Government other
than DoD, it is classified as "Restricted Computer Software" and the Government's rights in the
Software are defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR") (or any
successor regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplerment
to the FAR (or any successor regulations).

@section Acknowledgements

@url{http://www.openss7.org/,The OpenSS7 Project} was funded in part by:

@itemize @bullet
@item @url{http://www.monavacon.com/,Monavacon Limited}
@item @url{http://www.openss7.com/,OpenSS7 Corporation}
@end itemize

Thanks to the subscribers to and sponsors of @url{http://www.openss7.org/, The OpenSS7 Project}.
Without their support, open software like this would not be possible.

As with most open source projects, this project would not have been possible without the valiant
efforts and productive software of the @url{http://www.fsf.org/,Free Software Foundation}, the
@url{http://www.kernel.org/,Linux Kernel Community}, and the open source software movement at large.

@node Introduction
@chapter Introduction
@cpindex STREAMS

This document specifies a @acronym{STREAMS}-based kernel-level instantiation of the ITU-T
@value{MANUAL_TITLE} definition.  The @value{MANUAL_TITLE} enables the user of a call control
service to access and use any of a variety of conforming call control service providers without
specific knowledge of the provider's protocol.  The service interface is designed to support any
network call control protocol and user call control protocol.  This interface only specifies access
to call control service providers, and does not address issues concerning call control and circuit
management, protocol performance, and performance analysis tools.

This specification assumes that the reader is familiar with ITU-T state machines
and call control interfaces (e.g., Q.764, Q.931), and @acronym{STREAMS}.
@cpindex STREAMS

@section Related Documentation

@itemize ---
@item @strong{1993 ITU-T Q.764 Recommendation}
@item @strong{1993 ITU-T Q.931 Recommendation}
@item @strong{System V Interface Definition, Issue 2 - Volume 3}
@end itemize

@subsection Role

This document specifies an interface that supports the services provided by the @dfn{Integrated
Services Digital Network (ISDN)} and @dfn{ISDN User Part (ISUP)} for ITU-T applications as described
in ITU-T Recommendation Q.931 and ITU-T Recommendation Q.764.@footnote{In a later version of this
document H.225, BSSAP, and SIP will also be supported.} These specifications are targeted for use by
developers and testers of protocol modules that require call control service.

@section Definitions, Acronyms, Abbreviations

@table @dfn
@item Application Context
@item Object Identifier
@item Calling Party
The Calling Party.
@item Called Party
The Called Party.
@item Operations Class
One of 5 ISO/OSI Transport Protocol Classes.
@item MAP
Mobile Applications Part
@item TCAP
Transaction Capabilities Application Part
@item SCCP
Service Connection Control Part
@item MTP
Message Transfer Part
@item TR
Transaction Sub-Layer
@item TC
Component Sub-Layer
@item IMSI
International Mobile Station Identifier
@item MSISDN
Mobile Station ISDN Directory Number (E.164)
@item ITU
International Telecommunications Union
@item ITU-T
International Telecommunications Union -- Telecom Sector
@item OSI
Open Systems Interconnect
@item ISO
International Organization for Standardization
@item MAP User
A user of the Mobile Application Part (MAP) Interface.
@item MAP Provider
A provider of the Mobile Application Part (MAP) Interface.
@item MAPI
The Mobile Application Part (MAP) Interface.
@item MS
Mobile Station.
@item Components
Transaction components as defined in ITU-T Recommendation Q.771.
@item QoS
Quality of Service
@item STREAMS
@cpindex STREAMS
A communication services development facility first available with UNIX System V Release 3.
@end table

@node The Call Control Layer
@chapter The Call Control Layer

@menu
* Model of the CCI::
* CCI Services::
@end menu

The Call Control Layer provides the means to manage the connection and disconnection of calls.  It
is responsible for the routing and management of call control signalling between call control-user
entities.

@node Model of the CCI
@section Model of the CCI
@cpindex STREAMS

The CCI defines the services provided by the call control layer to the call control-user at the
boundary between the call control provider and the call control user entity.  The interface consists
of a set of primitives defined as @acronym{STREAMS} messages that provide access to the call control
layer services, and are transferred between the CCS user entity and the CCS provider.  These
primitives are of two types; ones that originate from the CCS user, and others that originate from
the CCS provider.  The primitives that originate from the CCS user make requests to the CCS
provider, or respond to an indication of an event of the CCS provider.  The primitives that
originate from the CCS provider are either confirmations of a request or are indications to the CCS
user that an event has occurred.  @figref{1} shows the model of the CCI.

@figuresized{cci01,1,Model of the CCI,4.0in}

The CCI allows the CCS provider to be configured with any call control layer user (such as an ISDN
user call control application) that also conforms to the CCI.  A call control layer user can also be
a user program that conforms to the CCI and accesses the CCS provider via @manref{putmsg(2s)} and
@manref{getmsg(2s)} system calls.

@node CCI Services
@section CCI Services

The features of the CCI are defined in terms of the services provided by the CCS provider, and the
individual primitives that may flow between the CCS user and the CCS provider.

The services supported by the CCI are based on three distinct modes of communication, user-network
interface (UNI) User mode, user-network interface (UNI) Network mode, and network-network interface
(NNI).  In addition, the CCI supports services for local management.

@subsection UNI

The main features of the User-Network Interface mode of communication are:

@enumerate
@item It is call oriented.
@item It employs facility associated signalling in that the signalling interface and circuits that
are controlled by that signalling interface are bound by physical configuration.  (For example,
23B+D, 2B+D).
@item The protocol has two aspects to the interface: one side of the interface follows the User
protocol whereas the other side of the interface follows the Network protocol.
@item The user side of the protocol has no formal maintenance or monitoring procedures and therefore
reports most if not all system events to the user.
@item The network side of the protocol has formal maintenance and monitoring procedures and
therefore reports most if not all system events to maintenance.
@end enumerate

@subsubsection Address Formats

Addresses specifying all the calls and channels known to the provider are specified with scope @pval{ISDN_SCOPE_DF} and
identifier zero (0).

@subsubheading Customer/Provider Group

A customer/provider group has a different interpretation on the User and Network side of the call
control interface.  In User mode, the provider group is a group of all equipment groups that are
serviced by the same network provider.  In Network mode, the customer group is a group of all
equipment groups to which the same service is provided to the same customer by the network.

Customer/provider groups are identifier using a unique customer/provider group identifier within the
CCS provider.  Addresses specifying all of the equipment groups in a customer/provider group and
specified with scope @pval{ISDN_SCOPE_XG} and the customer/provider group identifier. 

@subsubheading Equipment Group

An equipment group is a group of all transmission groups (B- and D-channels) terminating at the same
location.  For User mode this corresponds to all the B- and D-channels terminating on the same
network provider exchange.  For Network mode this corresponds to all the B- and D-channels
terminating on the same customer site.

Equipment groups are identified using a unique equipment group identifier within the CCS provider.
Addresses specifying all of the B- and D-channels making up an equipment group are specified with
scope @pval{ISDN_SCOPE_EG} and the equipment group identifier.

@subsubheading Facility Group

A facility group is a group of D-channels (data links) controlling a set of B-channels.  This
corresponds to the signalling interface.  For regular interfaces, a signalling relation consists of
a single signalling interface.  Where multiple signalling interfaces are used to control the same
range of channels (e.g. primary and backup interfaces), all signalling interfaces belong to the same
facility group.

The B-channels that make up a facility group are channels that share the same dial plan and routing
characteristics for telephone calls.  A facility group is associated with an equipment group.

Facility groups are identified using a unique facility group identifier within the CCS provider.
Addresses specifying all of the channels in a facility group are specified with scope
@pval{ISDN_SCOPE_FG} and the facility group identifier.

An ISDN Channel Identifier is only unique within a facility group.

@subsubheading Transmission Group

A transmission group is the group of all D- and B-Channels associated with a given Q.931 signalling
interface.  For example, a typical PRI interface would consist of 23B+D, where there is one
signalling interface (the D-Channel) with 23 B-Channels associated with the D-Channel.  The 1
D-Channel and 23 B-Channels form a single transmission group associated with the physical interface.
Every D- or B-Channel belongs to one transmission group and occupies a single time slot within that
transmission group.

Transmission groups are identified using a unique transmission group identifier within the CCS
provider.  Addresses specifying all of the channels in a transmission group are specified with scope
@pval{ISDN_SCOPE_TG} and the transmission group identifier.  Transmission groups can also be
specified using scope @pval{ISDN_SCOPE_FG} and the Channel Identifier of one of the channels in the
facility group.

@subsubheading Channel

A channel refers to a specific B-Channel within a transmission and facility group.

Channels are identified using a unique channel identifier within the CCS provider.  Addresses
specifying a specific channel are specified with scope @pval{ISDN_SCOPE_CH} and the channel
identifier.  Channels can also be specified using scope @pval{ISDN_SCOPE_FG}, the facility group
identifier, and the Channel Identity of the channel within the facility group.

@subsubheading Data Link

A data link corresponds to a specific D-channel used for the control of channels.  Data links can be
grouped into facility groups.

Data links are identified using a unique data link identifier within the CCS provider.  Addresses
specifying all of the channels controlled by a data link are specified with scope
@code{ISDN_SCOPE_DL} and the data link identifier.

@figuresized{cci01a,2,UNI Data Model,4.0in}

@subsection NNI

The main features of the Network-Network Interface mode of communication are:

@enumerate
@item It is circuit oriented.
@item It employs quasi-associated signalling in that the path taken by signalling and the path taken by the circuits are
not necessarily related.
@item The protocol has one aspect and is peer-to-peer: that is, both sides of a signalling interface follow the same
protocol in the same way.
@item The network side of the protocol has formal maintenance and monitoring procedures and therefore reports most if
not all system events to maintenance.
@end enumerate

@subsubsection Address Formats

Addresses specifying all of the circuits known to the provider are specified with scope @pval{ISUP_SCOPE_DF} and
identifier zero (0).

@subsubheading Signalling Points

A signalling point is the SS7 signalling point (central office) that the provider represents.  A CCS provider can
represent more than one signalling point.

A signalling point is identifier using a unique signalling point identifier within the CCS provider.  Addresses
specifying all of the circuits in signalling point are specified with scope @pval{ISUP_SCOPE_SP} and the signalling
point identifier.

@subsubheading Signalling Relations

A signalling relation is a relationship between a local signalling point and a remote signalling point.  A signalling
relation consists of a single signalling interface.

Signalling relations are identified using a unique signalling relation identifier within the CCS provider.  Addresses
specifying all of the circuits in a signalling relation are specified with scope @pval{ISUP_SCOPE_SR} and the signalling
relation identifier.

An ISUP Circuit Identification Code is only unique within a signalling relation.

@subsubheading Trunk Groups

A trunk group is a group of circuits that share the same routing characteristics for telephone calls.  A trunk group is
associated with a signalling relation.  For the NNI, a signalling relation is the combination of local MTP Point Code
and remote MTP Point Code.

A trunk group is identified using a unique trunk group identifier within the CCS provider.  Addresses specifying all of
the circuits in a trunk group are specified with scope @pval{ISUP_SCOPE_TG} and the trunk group identifier.

@subsubheading Circuit Groups

A circuit group is a group of circuits that share the same common transmission facility (e.g, E1 span) and is therefore
impacted by any failure of the transmission facility.  All of the individual channels of an E1 span that are used to
carry calls are members of the circuit group.

Circuits groups are identified using a unique circuit group identifier within the CCS provider.  Addresses specifying
all of the circuits within a circuit group are specified with scope @pval{ISUP_SCOPE_CG} and the circuit group
identifier.  Circuit groups can also be specified using scope @pval{ISUP_SCOPE_SR} and the Circuit Identification Code
of one of the circuits within the circuit group.

@subsubheading Circuits

A circuit refers to a specific time slot within a digital facility.

Circuits are identified using a unique circuit identifier within the CCS provider.  Addresses specifying a specific
circuit are specified with scope @pval{ISUP_SCOPE_CT} and the circuit identifier.  Circuits can also be specified using
scope @pval{ISUP_SCOPE_CG}, the circuit group identifier, and the Circuit Identification Code of the circuit within the
group.  Circuits can also be specified using scope @pval{ISUP_SCOPE_SR}, the signalling relation identifier, and the
Circuit Identification Code of the circuit within the signalling relation.

@figuresized{cci01b,3,NNI Data Model,4.0in}

@subsection Local Management

The CCI specifications also define a set of local management functions that apply to UNI and NNI modes of communication.
These services have local significance only.  Tables 1, 2 and 3 summarizes the CCI service primitives by their state and
service.

@node CCI Services Definition
@chapter CCI Services Definition

This section describes the services of the CCI primitives.  Time-sequence diagrams that illustrate the sequence of
primitives are included.  (Conventions for the time-sequence diagrams are defined in ITU-T X.210.)  The format of the
primitives will be defined later in this document.

@tabfigsized{cci_tab1,1,CCI Service Primitives,4.0in}

@page
@section Local Management Services Definition

The services defined in this section are outside the scope of international standards.  These services apply to UNI
(User and Network), and NNI modes of communication.  They are invoked for the initialization/de-initialization of a
stream connected to the CCS provider.  They are also used to manage options supported by the CCS provider and to report
information on the supported parameter values.

@subsection Call Control Information Reporting Service

This service provides information on the options supported by the CCS provider.

@itemize @bullet
@item @prim{CC_INFO_REQ}:
This primitive request that the CCS provider return the values of all the supported protocol parameters.  This request
may be invoked during any phase.
@item @prim{CC_INFO_ACK}:
This primitive is in response to the N_INFO_REQ primitive and returns the values of the supported protocol parameters to
the CCS user.
@end itemize

The sequence of primitive for call control information management is shown in @figref{4}.

@figuresized{cci02,4,Sequence of Primitives: Call Control Information Reporting Service,4.0in}

@subsection CCS Address Service

This service allows a CCS user to determine the bound call control address and the connected call control address for a
given call reference associated with a stream.  It permits the CCS user to not necessarily retain this information
locally, and allows the CCS user to determine this information from the CCS provider at any time.

@itemize @bullet
@item @prim{CC_ADDR_REQ}:
This primitive requests that the CCS provider return information concerning which call control address the CCS user is
bound as well as the call control address upon which the CCS user is currently engaged in a call for the specified call
reference.
@item @prim{CC_ADDR_ACK}:
This primitive is in response to the @prim{CC_ADDR_REQ}
primitive and indicates to the CCS user the requested information.
@end itemize

The sequence of primitives is shown in @figref{5}.

@figuresized{cci42,5,Sequence of Primitives: Call Control User Address Service,4.0in}

@subsection CCS User Bind Service

This service allows a call control address to be associated with a stream.  It allows the CCS user to negotiate the
number of setup indications that can remain unacknowledged for that CCS user (a setup indication is considered
unacknowledged while it is awaiting a corresponding setup response or release request from the CCS user).  This service
also defines a mechanism that allows a stream (bound to a call control address of the CCS user) to be reserved to handle
incoming calls only.  This stream is referred to as the listener stream.

@itemize @bullet
@item @prim{CC_BIND_REQ}:
This primitive request that the CCS user be bound to a particular call control address and negotiate the number of
allowable outstanding setup indications for that address.
@item @prim{CC_BIND_ACK}:
This primitive is in response to the @prim{CC_BIND_REQ}
primitive and indicates to the user that the specified CCS user has been bound to a call control address.
@end itemize

The sequence of primitives is shown in @figref{6} .

@figuresized{cci03,6,Sequence of Primitives: Call Control User Bind Service,4.0in}

@subsection CCS User Unbind Service

This service allows the CCS user to be unbound from a call control address.

@itemize @bullet
@item @prim{CC_UNBIND_REQ}:
This primitive request that the CCS user be unbound from the call control address that it had previously been bound to.
@end itemize

The sequence of primitives is shown in @figref{7}.

@figuresized{cci04,7,Sequence of Primitives: Call Control User Unbind Service,4.0in}

@subsection Receipt Acknowledgement Service

@itemize @bullet
@item @prim{CC_OK_ACK}:
This primitive indicates to the CCS user that the previous (indicated) CCS user originated primitive was received
successfully by the CCS provider.
@end itemize

An example showing the sequence of primitives for successful receipt acknowledgement is depicted in @figref{8}.

@figuresized{cci05,8,Sequence of Primitives: Call Control Receipt Acknowledgement Service,4.0in}

@subsection Options Management Service

This service allows the CCS user to manage options parameter values associated with the CCS provider.

@itemize @bullet
@item @prim{CC_OPTMGMT_REQ}:
This primitive allows the CCS user to select default values for options parameters within the range supported by the CCS
provider.
@end itemize

@figref{9} shows the sequence of primitives for call control options management.

@figuresized{cci06,9,Sequence of Primitives: Call Control Options Management Service,4.0in}

@subsection Error Acknowledgement Service

@itemize @bullet
@item @prim{CC_ERROR_ACK}:
This primitive indicates to the CCS user that a non-fatal error has occurred in the last CCS user originated request or
response primitive (listed in @figref{10}), on the stream.
@end itemize

@figref{10} shows the sequence or primitives for the error management primitive.

@figuresized{cci07,10,Sequence of Primitives: Call Control Error Acknowledgement Service,4.0in}

@page
@section User-Network Interface Services Definition

This section describes the required call control service primitives that define the UNI interface.

The queue model for UNI is discussed in more detail in ITU-T Q.931.  For Q.931 specific conformance considerations, see
@ref{Addendum for Q.931 Conformance}.

The queue model represents the operation of a call control connection in the abstract by a pair of queues linking the
two call control addresses.  There is one queue for each direction of signalling transfer.  The ability of a user to add
objects to a queue will be determined by the behaviour of the user removing objects from that queue, and the state of
the queue.  The pair of queues is considered to be available for each potential call.  Objects that are entered or
removed from the queue are either as a result of interactions at the two call control addresses, or as the result of CCS
provider initiatives.

@itemize @bullet
@item A queue is empty until a setup object has been entered and can be returned to this state, with loss of its
contents, by the CCS provider.
@item Objects may be entered into a queue as a result of the action of the source CCS user, subject to control by the
CCS provider.
@item Objects may also be entered into a queue by the CCS provider.
@item Objects are removed from the queue under the control of the receiving CCS user.
@item Objects are normally removed under the control of the CCS user in the same order as they were entered except:
@itemize @bullet
@item if the object is of a type defined to be able to advance ahead of the preceding object, or
@item if the following object is defined to be destructive with respect to the preceding object on the queue.  If
necessary, the last object on the queue will be deleted to allow a destructive object to be entered \- they will
therefore always be added to the queue.  For example, "release" objects are defined to be destructive with respect to
all other objects.
@end itemize
@end itemize

@tabref{3} shows the ordering relationship among the queue model objects.

@figuresized{cci30,11,Sequence of Primitives: Call Control UNI Overview,4.0in}

@subsection Call Setup Phase

A pair of queues is associated with a call between two call control addresses (facility group and channel(s)) when the
CCS provider receives a @prim{CC_SETUP_REQ} primitive at one of the call control addresses resulting in a setup object
being entered into the queue.  The queues will remain associated with the call until a @prim{CC_RELEASE_REQ} or
@prim{CC_RELEASE_IND} (resulting in a release object) is either entered into or removed from a queue.  Similarly, in the
queue from the called CCS user, objects can be entered into the queue only after the setup object associated with the
@prim{CC_SETUP_RES} has been entered into the queue.  Alternatively, the called CCS user can enter a release object into
the queue instead of the setup object to terminate the call.

The call establishment procedure will fail if the CCS provider is unable to establish the call, or if the destination
CCS user is unable to accept the @prim{CC_SETUP_IND} (see call failure and call reject primitive definitions).

@subsubsection User Primitives for Successful Call Setup

@itemize @bullet
@item @prim{CC_SETUP_REQ}:
This primitive requests that the CCS provider setup a call to the specified destination (called party number).
@item @prim{CC_MORE_INFO_REQ}:
This primitive requests that the CCS provider provide more information to establish the call.  This primitive is not
issued for @emph{en bloc} signalling mode.
@item @prim{CC_INFORMATION_REQ}:
This primitive requests that the CCS provider provide more information (digits) in addition to the destination (called
party number) already specified in the @prim{CC_SETUP_REQ}
and subsequent @prim{CC_INFORMATION_REQ}
primitives.  This primitive is not issued for @emph{en block} signalling mode.
@item @prim{CC_SETUP_RES}:
This primitive requests that the CCS provider accept a previous call setup indication on the specified stream.
@end itemize

@subsubsection Provider Primitives for Successful Call Setup

@itemize @bullet
@item @prim{CC_CALL_REATTEMPT_IND}:
This primitive indicates to the calling CCS user that an event has caused call setup to fail on the selected address and
that a reattempt should be made (or has been made) on another call control address (facility group and channel(s)).
This primitive is only issued by the CCS provider if the CCS user is bound at the channel level rather than the facility
group  or equipment group levels.
@item @prim{CC_SETUP_IND}:
This primitive indicates to the CCS user that a call setup request has been made by a user at the specified call control
address (facility group and channel(s)).
@item @prim{CC_MORE_INFO_IND}:
This primitive indicates to the CCS user that more information is required to establish the call.  This primitive is not
issued for @emph{en block} signalling mode.
@item @prim{CC_INFORMATION_IND}:
This primitive indicates to the CCS user more information (digits) in addition to the destination (called party number)
already indicated in the @prim{CC_SETUP_IND}
and subsequent @prim{CC_INFORMATION_IND}
primitives.  This primitive is not issued for @emph{en block} signalling mode.
@item @prim{CC_INFO_TIMEOUT_IND}:
This primitive indicates to the called CCS user that a timeout occurred while waiting for additional information (called
party number).  The receiving CCS User should determine whether sufficient address digits have been received and either
disconnect the call with the @prim{CC_DISCONNECT_REQ}
primitive or continue the call with @prim{CC_SETUP_RES}.
This primitive is not issued for @emph{en block} signalling mode.
@item @prim{CC_SETUP_CON}:
This primitive indicates to the CCS user that a call setup request has been confirmed on the indicated call control
address (channel(s)).
@end itemize

The sequence of primitives in a successful call setup is defined by the time sequence diagram shown in @figref{12}.  The
sequence of primitives for the call response token value determination is shown in @figref{13} (procedures for call
response token value determination are discussed in section 4.1.3 and 4.1.4.)

@figuresized{cci24,12,Sequence of Primitives: Call Control Call Setup Service,4.0in}

@figuresized{cci25,13,Sequence of Primitives: Call Control Token Request Service,4.0in}

If the CCS provider is unable to establish a call, it indicates this to the request by a @prim{CC_CALL_REATTEMPT_IND}.
This is shown in @figref{14}.

@figuresized{cci23,14,Sequence of Primitives: Call Reattempt - CCS Provider,4.0in}

The sequence of primitives for call reattempt on dual seizure are shown in @figref{15}.

@figuresized{cci39,15,Sequence of Primitives: Call Reattempt - Dual Seizure,4.0in}

@subsection Call Establishment Phase

During the call establishment phase, a pair of queues has already been associated with the call between the selected
call control addresses (facility group and channel(s)) during the setup phase.

@subsubsection User Primitives for Successful Call Establishment

@itemize @bullet
@item @prim{CC_PROCEEDING_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the call is proceeding and that all
necessary information has been received.
@item @prim{CC_ALERTING_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the terminating user is being
alerted.
@item @prim{CC_PROGRESS_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the specified progress event has
occurred.
@item @prim{CC_IBI_REQ} (@prim{CC_DISCONNECT_REQ}):
This primitive requests that the CCS provider indicate to the call control peer that in-band information is now
available.  This will also invite the peer to release the call.
@item @prim{CC_CONNECT_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the call has been connected.
@item @prim{CC_SETUP_COMPLETE_REQ}:
This primitive request that the CCS provider complete the call setup.
@end itemize

@subsubsection Provider Primitives for Successful Call Establishment

@itemize @bullet
@item @prim{CC_PROCEEDING_IND}:
This primitive indicates to the CCS user that the call control peer is proceeding and that all necessary information has
been received.
@item @prim{CC_ALERTING_IND}:
This primitive indicates to the CCS user that the terminating user is being alerted.
@item @prim{CC_PROGRESS_IND}:
This primitive indicates to the CCS user that the specified progress event has occurred.
@item @prim{CC_IBI_IND} (@prim{CC_DISCONNECT_IND}):
This primitive indicates to the CCS user that in-band information is now available.  It also invites the CCS user to
release the call.
@item @prim{CC_CONNECT_IND}:
This primitive indicates to the CCS user that the call has been connected.
@item @prim{CC_SETUP_COMPLETE_IND}:
This primitive indicates to the CCS user that the call has completed setup.
@end itemize

@subsubsection Provider Primitives for Successful Call Setup

The sequence of primitives in a successful call establishment is defined by the time sequence diagrams as shown in
@figref{16}.

@figuresized{cci46,16,Sequence of Primitives: Call Control Successful Call Establishment Service,4.0in}

@subsection Call Established Phase

Flow control of the call is done by management of the queue capacity, and by allowing objects of certain types to be
inserted to the queues, as shown in Table X.

@subsubsection Suspend Service

@subsubheading User Primitives for Suspend Service

@itemize @bullet
@item @prim{CC_SUSPEND_REQ}:
This primitives requests that the CCS provider temporarily suspend a call at the network, or indicate user suspension of
a call.
@item @prim{CC_SUSPEND_RES}:
This primitive indicates to the CCS provider that the CCS user (Network) is accepting the request for suspension of the
call.
@item @prim{CC_SUSPEND_REJECT_REQ}:
This primitive indicates to the CCS provider that the CCS user (Network) is rejecting the request for suspension of the
call, and the cause for rejection.
@end itemize

@subsubheading Provider Primitives for Suspend Service

@itemize @bullet
@item @prim{CC_SUSPEND_IND}:
This primitive indicates to the CCS user that an established call has been temporarily suspended at the network, or by
the remote user.
@item @prim{CC_SUSPEND_CON}:
This primitive confirms to the requesting CCS user (User) that the call has been temporarily suspended at the network.
@item @prim{CC_SUSPEND_REJECT_IND}:
This primitive indicates to the requesting CCS user (User) that the request to suspend the call has been rejected by the
network, and the cause for rejection.
@end itemize

@figref{17} and @figref{18} show the sequence of primitives for suspend service.  The sequence of primitives may remain
incomplete if a @prim{CC_RESET} or a @prim{CC_RELEASE} primitive occurs.

The sequence of primitives to suspend a call is defined in the time sequence diagram as shown in @figref{17} and
@figref{18}.

@figuresized{cci32,17,Sequence of Primitives: Call Control Network Suspend Service: Successful,4.0in}

@figuresized{cci33,18,Sequence of Primitives: Call Control Network Suspend Service: Unsuccessful,4.0in}

@figuresized{cci44,19,Sequence of Primitives: Call Control User Suspend Service,4.0in}

@subsubsection Resume Service

@subsubheading User Primitives for Resume Service

@itemize @bullet
@item @prim{CC_RESUME_REQ}:
This primitive request that the CCS provider resume a previously network suspended call, or indicates that the user has
resumed a call.
@item @prim{CC_RESUME_RES}:
This primitive indicates to the CCS provider that the CCS user (Network) is accepting the request for resumption of the
call.
@item @prim{CC_RESUME_REJECT_REQ}:
This primitive indicates to the CCS provider that the CCS user (Network) is rejecting the request for resumption of the
call, and the cause for rejection.
@end itemize

@subsubheading Provider Primitives for Resume Service

@itemize @bullet
@item @prim{CC_RESUME_IND}:
This primitive indicates to the CCS user that a previously suspended call has been resumed at the network, or by the
remote user.
@item @prim{CC_RESUME_CON}:
This primitive confirms to the requesting CCS user (User) that the call has been resumed at the network.
@item @prim{CC_RESUME_REJECT_IND}:
This primitive indicates to the requesting CCS user (User) that the request to resume the call has been rejected by the
network, and the cause for rejection.
@end itemize

@figref{20} and @figref{21} show the sequence of primitives for resume service.  The sequence of primitives may remain
incomplete if a @prim{CC_RESET} or a @prim{CC_RELEASE} primitive occurs.

The sequence of primitives to resume a call is defined in the time sequence diagram as shown in @figref{20}
and @figref{21}.

@figuresized{cci34,20,Sequence of Primitives: Call Control Resume Service: Successful,4.0in}

@figuresized{cci35,21,Sequence of Primitives: Call Control Resume Service: Unsuccessful,4.0in}

@figuresized{cci45,22,Sequence of Primitives: Call Control User Resume Service,4.0in}

The sequence of primitives as shown above may remain incomplete if a @prim{CC_RESET} or @prim{CC_RELEASE} primitive
occurs (see Table 3).  A CCS user must not issue a @prim{CC_RESUME_REQ} primitive if no @prim{CC_SUSPEND_REQ} has been
sent previously.  Following a reset procedure (@prim{CC_RESET_REQ} or @prim{CC_RESET_IND}), a CCS user may not issue a
@prim{CC_RESUME_REQ} to resume a call suspended before the reset procedure was signalled.

@subsection Call Termination Phase

@subsubsection Call Reject Service

@subsubheading User Primitives for Call Reject Service

@itemize @bullet
@item @prim{CC_REJECT_REQ}:
This primitive indicates that the CCS user receiving the specified @prim{CC_SETUP_IND}
requests that the specified call indication be rejected.
@end itemize

@subsubheading Provider Primitives for Call Reject Service

@itemize @bullet
@item @prim{CC_REJECT_IND}:
This primitive indicates to the calling CCS user that the call has been rejected.
@end itemize

The sequence of events for rejecting a call setup attempt at the UNI is defined in the time sequence diagram shown
in @figref{23}.

@figuresized{cci36,23,Sequence of Primitives: Rejecting a Call Setup,4.0in}

@subsubsection Call Failure Service

@subsubheading Provider Primitives for Call Failure Service

@itemize @bullet
@item @prim{CC_CALL_FAILURE_IND}:
This primitive indicates to the called CCS user that an event has caused the call to fail and indicates the reason for
the failure and the cause value associated with the failure.  The CCS user is required to release the call using the
indicated cause value in a @prim{CC_DISCONNECT_REQ}
primitive.
@end itemize

The sequence of events for error indications is described in the time sequence diagram shown in @figref{24}.

@figuresized{cci37,24,Sequence of Primitives: Call Failure,4.0in}

@subsubsection Call Release Service

The call release procedure is initialized by the insertion of a release object (associated with a
@prim{CC_DISCONNECT_REQ}, @prim{CC_RELEASE_REQ}, or @prim{CC_REJECT_REQ}) in the queue.  As shown in Table 3, the
release procedure is destructive with respect to other objects in the queue, and eventually results in the emptying of
queues and termination of the call.

The Release procedure invokes the following interactions:
@enumerate A
@item A @prim{CC_DISCONNECT_REQ}
from the CCS user, followed by a @prim{CC_RELEASE_IND}
from the CCS provider and a subsequent @prim{CC_RELEASE_RES}
from the CCS user; or
@item A @prim{CC_DISCONNECT_IND}
from the CCS provider, followed by a @prim{CC_RELEASE_REQ}
from the CCS user and a subsequent @prim{CC_RELEASE_CON}
from the CCS provider.
@end enumerate

The sequence of primitive depends on the origin of the release action.  The sequence may be:
@enumerate
@item invoked by the CCS user, with a request from that CCS user, leading to interaction (A) with that CCS user and
interaction (B) with the peer CCS user;
@item invoked by both CCS users, with a request from each of the CCS users, leading to interaction (A) with both CCS
users;
@item invoked by the CCS provider, leading to interaction (B) with both CCS users.
@item invoked independently by one CCS user and the CCS provider, leading to interaction (A) with the originating CCS
user and (B) with the peer CCS user.
@end enumerate

@subsubheading User Primitives for Release Service

@itemize @bullet
@item @prim{CC_DISCONNECT_REQ}:
This primitive request that the CCS provider disconnect the B-Channel or indicate tones and announcements present.
Tones and announcements should be requested in the @prim{CC_IBI_REQ}
primitive rather than the @prim{CC_DISCONNECT_REQ}
primitive.
@item @prim{CC_RELEASE_REQ}:
This primitive requests that the CCS provider disconnect the B-Channel (if not already disconnected) and release the
call reference.
@item @prim{CC_RELEASE_RES}:
This primitive indicates to the CCS provider that the CCS user has accepted a release indication and has released the
call reference.
@end itemize

@subsubheading Provider Primitives for Release Service

@itemize @bullet
@item @prim{CC_DISCONNECT_IND}:
This primitive indicates that the remote CCS user or provider has disconnected the B-Channel or has made tones and
announcements available.  The CCS provider should indicate tones and announcements present only with the
@prim{CC_IBI_IND}
primitive rather than the @prim{CC_DISCONNECT_IND}
primitive.
@item @prim{CC_RELEASE_IND}:
This primitive indicates that the remote CCS has disconnected the B-Channel and released the call reference.
@item @prim{CC_RELEASE_CON}:
This primitive confirms that the remove CCS has disconnected the B-Channel and released the call reference.
@end itemize

The sequence of primitives as shown in @figref{25}, @figref{26}, @figref{27}, and @figref{28} may remain incomplete if a
@prim{CC_RESTART} primitive occurs.

A CCS user can release a call establishment attempt by issuing a @prim{CC_DISCONNECT_REQ}.  The sequence of events is
shown in @figref{25}, @figref{26}, @figref{27}, and @figref{28}.

@figuresized{cci41,25,Sequence of Primitives: CCS User Invoked Release,4.0in}

@figuresized{cci48,26,Sequence of Primitives: Simultaneous CCS User Invoked Release,4.0in}

@figuresized{cci49,27,Sequence of Primitives: CCS Provider Invoked Release,4.0in}

@figuresized{cci43,28,Sequence of Primitives: Simultaneous CCS User and CCS Provider Invoked Release,4.0in}

@subsection Call Management

@subsubsection User Primitives for Call Management

@itemize @bullet
@item @prim{CC_RESTART_REQ}:
This primitive requests the CCS provider to restart all the call control addresses (signalling interface and channels)
for the UNI interface.
@end itemize

@subsubsection Provider Primitives for Call Management

@itemize @bullet
@item @prim{CC_RESTART_CON}:
This primitive confirms to the requesting CCS user that all call control addresses (signalling interface and channels)
for the UNI interface have been restarted and all calls are in the @psta{CCS_IDLE}
state.
@stindex CCS_IDLE
@item @prim{CC_MAINT_IND}:
This primitive indicates to CCS user that various events have occurred requiring maintenance notification (e.g., restart
indication).
@end itemize

@page
@section Network-Network Interface Services Definition

This section describes the required call control service primitives that define the NNI interface.

The queue model for NNI is discussed in more detail in ITU-T Q.764.  For Q.764 specific conformance considerations, see
@ref{Addendum for Q.764 Conformance}.  For ETSI EN 300 356-1 V3.2.2 specific conformance considerations, see
@ref{Addendum for ETSI EN 300 356-1 V3.2.2 Conformance}.

@figuresized{cci31,29,Sequence of Primitives: Call Control NNI Overview,4.0in}

@subsection Call Setup Phase

A pair of queues is associated with a call between the two call control addresses when the CCS provider receives a
@prim{CC_SETUP_REQ} primitive at one of the call control addresses resulting in a setup object being entered into the
queue.  The queues will remain associated with the call until a @prim{CC_RELEASE_REQ} (resulting in a release object) is
either entered into or removed from a queue.  Similarly, in the queue from the called CCS user, objects can be entered
into the queue only after the setup object associated with the @prim{CC_SETUP_RES} has been entered into the queue.
Alternatively, the called CCS user can enter a release object into the queue instead of the setup object to terminate
the call.

The call establishment procedure will fail if the CCS provider is unable to establish the call, or if the destination
CCS user is unable to accept the @prim{CC_SETUP_IND} (see call release primitive definition).

@subsubsection User Primitives for Successful Call Setup

@itemize @bullet
@item @prim{CC_SETUP_REQ}:
This primitive requests that the CCS provider setup a call to the specified destination (called party address).
@item @prim{CC_MORE_INFO_REQ}:
This primitive requests that the CCS provider provide more information to establish the call.  This primitive is not
issued for @emph{en block} signalling mode.
@item @prim{CC_INFORMATION_REQ}:
This primitive requests that the CCS provider provide more information (digits) in addition to the destination (called
party number) already specified in the @prim{CC_SETUP_REQ}
and subsequent @prim{CC_INFORMATION_REQ}
primitives.  This primitive is not issued for @emph{en block} signalling mode.
@item @prim{CC_SETUP_RES}:
This primitive requests that the CCS provider accept a previous call setup indication on the specified stream.
@end itemize

@subsubsection Provider Primitives for Successful Call Setup

@itemize @bullet
@item @prim{CC_CALL_REATTEMPT_IND}:
This primitive indicates to the calling CCS user that an event has caused call setup to fail on the selected address and
that a reattempt should be made (or has been made) on another call control address (signalling interface and
circuit(s)).  This primitive is only issued by the CCS provider if the CCS user is bound at the circuit level rather
than the circuit group or trunk group level.
@item @prim{CC_SETUP_IND}:
This primitive indicates to the CCS user that a call setup request has been made by a user at the specified call control
address (circuit(s)).
@item @prim{CC_MORE_INFO_IND}:
This primitive indicates to the CCS user that more information is required to establish the call.  This primitive is not
issued for @emph{en block} signalling mode.
@item @prim{CC_INFORMATION_IND}:
This primitive indicates to the CCS user more information (digits) in addition to the destination (called party number)
already indicated in the @prim{CC_SETUP_IND}
and subsequent @prim{CC_INFORMATION_IND}
primitives.  This primitive is not issued for @emph{en block} signalling mode.
@item @prim{CC_INFO_TIMEOUT_IND}:
This primitive indicates to the called CCS user that a timeout occurred while waiting for additional information (called
party number).  The receiving CCS User should determine whether sufficient address digits have been received and either
disconnect the call with the @prim{CC_DISCONNECT_REQ}
primitive or continue the call with @prim{CC_SETUP_RES}.
@item @prim{CC_SETUP_CON}:
This primitive indicates to the CCS user that a call setup request has been confirmed on the indicated call control
address (circuits(s)).
@end itemize

The sequence of primitives in a successful call setup is defined by the time sequence diagrams as shown in @figref{30}
and @figref{31}.

The sequence of primitives for the call response token value determination is shown in @figref{32} (procedures for call
response token value determination are discussed in section 4.1.3 and 4.1.4.)

@c @figuresized{ccixx,30,Sequence of Primitives: Call Control Call Setup Service: En Bloc Sending,4.0in}

@figuresized{cci08,31,Sequence of Primitives: Call Control Call Setup Service: Overlap Sending,4.0in}

@figuresized{cci09,32,Sequence of Primitives: Call Control Token Request Service,4.0in}

If the CCS provider is unable to establish a call, it indicates this to the request by a @prim{CC_CALL_REATTEMPT_IND}.
This is shown in @figref{33}.

@figuresized{cci23,33,Sequence of Primitives: Call Reattempt - CCS Provider,4.0in}

The sequence of primitives for call reattempt on dual seizure are shown in @figref{34}.

@figuresized{cci47,34,Sequence of Primitives: Call Reattempt - Dual Seizure,4.0in}

@subsection Continuity Test Phase

The continuity test service is only applicable to the NNI.

During the continuity test phase, a pair of queues has already been associated with the call between the selected call
control addresses (signalling interface and circuit(s)) during the setup phase.  The continuity test phase begins when
the CCS provider returns a @prim{CC_CONT_TEST_IND} primitive in response to a @prim{CC_SETUP_REQ} primitive that had the
@pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set in the call flags.  The continuity test phase also begins when the CCS user
responds with a @prim{CC_CONT_TEST_REQ} primitive in response to a @prim{CC_SETUP_IND} primitive that had the
@pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set in the call flags.

Upon entering the continuity test phase, it is the responsibility of the CCS user to establish a loop back on the call
control address (signalling interface and circuit(s)) or to attach tone generation and detection devices to the call
control address (signalling interface and circuit(s)).

@subsubsection Continuity Test Successful

@subsubheading User Primitives for Successful Continuity Test

@itemize @bullet
@item @prim{CC_SETUP_REQ}:
This primitive, with the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, requests that the CCS provider setup a call and include
a continuity check before the call is established.
@item @prim{CC_CONT_CHECK_REQ}:
This primitive requests that the CCS provider perform a continuity check on the specified call control address
(signalling interface and circuit(s)).  This primitive is only necessary for performing continuity checks that are not
in conjunction with a call.
@item @prim{CC_CONT_TEST_REQ}:
This primitive requests that the CCS provider accept an outstanding call setup indication.  When the @prim{CC_SETUP_IND}
had the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, it indicates to the CCS provider that the necessary loop back device has
been install on the call control address (signalling interface and circuit(s)).
@item @prim{CC_CONT_REPORT_REQ}:
This primitive requests that the CCS provider indicate to the remote CCS user that the continuity test has succeeded
(cc_result is set to @pval{ISUP_COT_SUCCESS}).
@end itemize

@subsubheading Provider Primitives for Successful Continuity Test

@itemize @bullet
@item @prim{CC_SETUP_IND}:
This primitive, with the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, indicates to the CCS user that a call setup including a
continuity check is requested.
@item @prim{CC_CONT_CHECK_IND}:
This primitive indicates to the CCS user that a continuity check was requested on the specified call control address
(signalling interface and circuit(s)).  This primitive is only necessary for performing continuity checks that are not
in conjunction with a call.
@item @prim{CC_CONT_TEST_IND}:
This primitive indicates that the remote CCS user has accepted a call setup indication on the specified call control
address (signalling interface and circuit(s)).  When the @prim{CC_SETUP_IND}
primitive had the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, it indicates to the CCS user that the necessary loop back
device has been installed on the remote end of the call control address (signalling interface and circuit(s)).  The CCS
user receiving this primitive must attach the necessary tone generation and detection devices to the circuit(s) and
perform the continuity test.
@item @prim{CC_CONT_REPORT_IND}:
This primitive indicates to the CCS user that the continuity test was successful.
@end itemize

The sequence of primitives in a successful continuity test associated with call setup when continuity check is
required on the circuit(s) is defined by the time sequence diagrams as shown in
@figref{35}.

@figuresized{cci10,35,Sequence of Primitives: Call Setup Continuity Test Service: Required: Successful,4.0in}

The sequence of primitives in a successful continuity test associated with call setup when continuity check is being
performed on a previous circuit is defined by the time sequence diagrams as shown in @figref{36}.

@figuresized{cci10c,36,Sequence of Primitives: Call Setup Continuity Test Service: Previous: Successful,4.0in}

The sequence of primitives in a successful continuity test not associated with call setup is defined by the time
sequence diagrams as shown in @figref{37}.

@figuresized{cci10d,37,Sequence of Primitives: Continuity Test Service: Successful,4.0in}

@subsubsection Continuity Test Unsuccessful

@subsubheading User Primitives for Unsuccessful Continuity Test

@itemize @bullet
@item @prim{CC_SETUP_REQ}:
This primitive, with the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, requests that the CCS provider setup a call and include
a continuity check before the call is established.
@item @prim{CC_CONT_TEST_REQ}:
This primitive requests that the CCS provider accept an outstanding call setup indication.  When the @prim{CC_SETUP_IND}
had the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, it also indicates to the CCS provider that the necessary loop back device
has been install on the call control address (signalling interface and circuit(s)).
@item @prim{CC_CONT_REPORT_REQ}:
This primitive requests that the CCS provider indicate to the remote CCS user that the continuity test has failed
(cc_result is set to @pval{ISUP_COT_FAILURE}).
@end itemize

@subsubheading Provider Primitives for Unsuccessful Continuity Test

@itemize @bullet
@item @prim{CC_SETUP_IND}:
This primitive, with the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, indicates to the CCS user that a call setup including a
continuity check is requested.
@item @prim{CC_CONT_TEST_IND}:
This primitive indicates that the remote CCS user has accepted a call setup indication on the specified call control
address (signalling interface and circuit(s)).  When the @prim{CC_SETUP_IND} primitive had the
@pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set, it indicates to the CCS user that the necessary loop back device hass been
installed on the remote end of the call control address (signalling interface and circuit(s)).  The CCS user receiving
this primitive must attach the necessary tone generation and detection devices to the circuit(s) and perform the
continuity test.
@item @prim{CC_CONT_REPORT_IND}:
This primitive indicates to the CCS user that the continuity test failed.
@item @prim{CC_CALL_REATTEMPT_IND}:
This primitive indicates to the calling CCS user that the continuity test failed and that a reattempt should be made (or
has been made) on another call control address (signalling interface and circuit(s)).  This primitive is only issued by
the CCS provider if the CCS user is bound at the circuit level rather than the circuit group or trunk group level.
@end itemize

The sequence of primitives for an unsuccessful continuity test associated with a call setup is defined by the time
sequence diagrams as shown in @figref{38}.

@figuresized{cci11,38,Sequence of Primitives: Call Setup Continuity Test Service: Unsuccessful,4.0in}

The sequence of primitives for an unsuccessful continuity test not associated with a call setup is defined by the time
sequence diagrams as shown in @figref{39}.

@figuresized{cci10b,39,Sequence of Primitives: Continuity Test Service: Unsuccessful,4.0in}

@subsection Call Establishment Phase

During the call establishment phase, a pair of queues has already been associated with the call between the selected
call control addresses (signalling interface and circuit(s)) during the setup phase.  The call establishment phase
begins when the CCS provider returns a @prim{CC_SETUP_CON}
primitive (or receives a @prim{CC_CONT_REPORT_REQ}
primitive) in response to a @prim{CC_SETUP_REQ}
primitive (that had the ISUP_NCI_CONT_CHECK_REQUIRED flag set).  The call establishment phase also begins when the CCS
user responds with a @prim{CC_SETUP_RES}
primitive (or receives a @prim{CC_CONT_REPORT_IND}
primitive) in response to a @prim{CC_SETUP_IND}
primitive (that had the @pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set).

Upon entering the call establishment phase, it is the responsibility of the CCS user to remove any loop back from the
call control address (signalling interface and circuit(s)) or to remove tone generation and detection devices from the
call control address (signalling interface and circuit(s)).

@subsubsection User Primitives for Successful Call Establishment

@itemize @bullet
@item @prim{CC_PROCEEDING_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the call is proceeding.
@item @prim{CC_ALERTING_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the terminating user is being
alerted.
@item @prim{CC_PROGRESS_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the specified progress event has
occurred.
@item @prim{CC_IBI_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that interworking has been encountered
and in-band information is now available.  This will also inform the peer CCS user that no connect indication is
pending.
@item @prim{CC_CONNECT_REQ}:
This primitive requests that the CCS provider indicate to the call control peer that the call has been connected.
@item @prim{CC_SETUP_COMPLETE_REQ}:
This primitive requests that the CCS provider complete the call setup.  This primitive is used in NNI mode for
interworking with UNI mode.
@end itemize

@subsubsection Provider Primitives for Successful Call Establishment

@itemize @bullet
@item @prim{CC_PROCEEDING_IND}:
This primitive indicates to the CCS user that the call control peer is proceeding.
@item @prim{CC_ALERTING_IND}:
This primitive indicates to the CCS user that the terminating user is being alerted.
@item @prim{CC_PROGRESS_IND}:
This primitive indicates to the CCS user that the specified progress event has occurred.
@item @prim{CC_IBI_IND}:
This primitive indicates to the CCS user that interworking has been encountered and in-band information is now
available.  It also indicates to the CCS user that no connect indication is pending.
@item @prim{CC_CONNECT_IND}:
This primitive indicates to the CCS user that the call has been connected.
@item @prim{CC_SETUP_COMPLETE_IND}:
This primitive indicates to the CCS user that the call has completed setup.  This primitive is used in NNI mode for
interworking with UNI mode.
@end itemize

The sequence of primitives in a successful call establishment is defined by the time sequence diagrams as shown in
@figref{40}.

@figuresized{cci12,40,Sequence of Primitives: Call Control Successful Call Establishment Service,4.0in}

@subsection Call Established Phase

Flow control of the call is done by management of the queue capacity, and by allowing objects of certain types to be
inserted to the queues, as shown in Table X.

@subsubsection User Primitives for Established Calls

@itemize @bullet
@item @prim{CC_SUSPEND_REQ}:
This primitives requests that the CCS provider temporarily suspend a call.
@item @prim{CC_RESUME_REQ}:
This primitive request that the CCS provider resume a previously suspended call.
@end itemize

@subsubsection Provider Primitives for Established Calls

@itemize @bullet
@item @prim{CC_SUSPEND_IND}:
This primitive indicates to the CCS user that an established call has been temporarily suspended.
@item @prim{CC_RESUME_IND}:
This primitive indicates to the CCS user that a previously suspended call has been resumed.
@end itemize

@figref{41} shows the sequence of primitives for suspension and resumption of established calls.  The sequence of
primitives may remain incomplete if a @prim{CC_RESET} or a @prim{CC_RELEASE} primitive occurs.  The sequence of primitives to
successfully suspend and resume a call is defined in the time sequence diagram as shown in @figref{41}.

@figuresized{cci13,41,Sequence of Primitives: Call Control Suspend and Resume Service,4.0in}

The sequence of primitives as shown above may remain incomplete if a @prim{CC_RESET} or @prim{CC_RELEASE} primitive
occurs (see Table 3).  A CCS user must not issue a @prim{CC_RESUME_REQ} primitive if no @prim{CC_SUSPEND_REQ} has been
sent previously.  Following a reset procedure (@prim{CC_RESET_REQ} or @prim{CC_RESET_IND}), a CCS user may not issue a
@prim{CC_RESUME_REQ} to resume a call suspended before the reset procedure was signalled.

@subsection Call Termination Phase

@subsubsection Call Reject Service

@subsubheading User Primitives for Call Reject Service

@itemize @bullet
@item @prim{CC_REJECT_REQ}:
This primitive indicates that the CCS user receiving the specified @prim{CC_SETUP_IND}
requests that the specified call indication be rejected.
@end itemize

@subsubheading Provider Primitives for Call Reject Service

@itemize @bullet
@item @prim{CC_REJECT_IND}:
This primitive indicates to the calling CCS user that the call has been rejected.
@end itemize

The sequence of events for rejecting a call setup attempt at the NNI is defined in the time sequence diagram shown
@figref{42}.

@figuresized{cci22,42,Sequence of Primitives: CCS User Rejection of a Call Setup Attempt,4.0in}

@subsubsection Call Failure Service

The call error procedure is indicated by the removal of a reattempt or failure object (associated with a local
event) from the queue.  The error procedure is destructive with respect to other objects in the queue, and
eventually results in the emptying of queues and termination of the call.

@subsubheading Provider primitives for the Call Failure Service

@itemize @bullet
@item @prim{CC_CALL_FAILURE_IND}:
This primitive indicates to the CCS user that an event has caused the call to fail and indicates the reason for the
failure and the cause value associated with the failure.  The CCS user is required to immediately disconnect the
circuit(s) and release the call on any previous legs using the indicated cause value in the primitive.
@end itemize

The sequence of primitives for call failure are shown in @figref{43}.

@figuresized{cci40,43,Sequence of Primitives: Call Failure,4.0in}

@subsubsection Call Release Service

The call release procedure is initialized by the insertion of a release object (associated with a @prim{CC_RELEASE_REQ})
into the queue.  As shown in Table 3, the release procedure is destructive with respect to other objects in the queue,
and eventually results in the emptying of queues and termination of the call.

The release procedure invokes the following interactions:
@enumerate A
@item a @prim{CC_RELEASE_REQ}
from the CCS user, followed by a @prim{CC_RELEASE_CON}
from the CCS provider; or
@item A @prim{CC_RELEASE_IND}
from the CCS provider, followed by a @prim{CC_RELEASE_REQ}
from the CCS user.
@end enumerate

The sequence of primitives depends on the origin of the release action.  The sequence may be:
@enumerate
@item invoked by one CCS user, with a request from that CCS user, leading to interaction (A) with that CCS user and
interaction (B) with the peer CCS user;
@item invoked by both CCS users, with a request from each of the CCS users, leading to interaction (A) with both CCS
users;
@item invoked by the CCS provider, leading to interaction (B) with both CCS users;
@item invoked independently by on CCS user and the CCS provider, leading to interaction (A) with the originating CCS
user and (B) with the peer CCS user.
@end enumerate

@subsubheading User primitives for the Release Service

@itemize @bullet
@item @prim{CC_RELEASE_REQ}:
This primitive request that the CCS provider release the call.
@item @prim{CC_RELEASE_RES}:
This primitive indicates to the CCS provider that the CCS user has accepted a release indication.
@end itemize

@subsubheading Provider primitives for the Release Service

@itemize @bullet
@item @prim{CC_RELEASE_IND}:
This primitive indicates to the CCS user that the call has been released.
@item @prim{CC_RELEASE_CON}:
This primitive indicates to the CCS user that the release request has been confirmed.
@end itemize

The sequence of primitives as shown in @figref{44}, @figref{45}, @figref{46}, and @figref{47}, may remain incomplete if
a @prim{CC_RESET} primitive occurs.

A CCS user can release a call establishment attempt by issuing a @prim{CC_RELEASE_REQ}.  The sequence of events is shown
in @figref{44}, @figref{45}, @figref{46}, and @figref{47}.

@figuresized{cci18,44,Sequence of Primitives: CCS User Invoked Release,4.0in}

@figuresized{cci19,45,Sequence of Primitives: Simultaneous CCS User Invoked Release,4.0in}

@figuresized{cci20,46,Sequence of Primitives: CCS Provider Invoked Release,4.0in}

@figuresized{cci21,47,Sequence of Primitives: Simultaneous CCS User and CCS Provider Invoked Release,4.0in}

@subsection Circuit Management Services

@subsubsection Reset Service

The reset service is used by the CCS user or management to resynchronize the use of the call, or by the CCS provider to
report detected loss of a unrecoverable call.

The reset service is only applicable to the NNI.

The reset procedure invokes the following interactions:
@enumerate A
@item a @prim{CC_RESET_REQ}
from the CCS user, followed by a @prim{CC_RESET_CON}
from the CCS provider; or
@item a @prim{CC_RESET_IND}
from the CCS provider, followed by a @prim{CC_RESET_RES}
from the CCS user.
@end enumerate

The complete sequence of primitives depends upon the origin of the reset action.  The reset service may be:
@enumerate
@item invoked by one CCS user, leading to interaction (A) with that CCS user and interaction (B) with the peer CCS user.
@item invoked by both CCS users, leading to interaction (A) with both CCS users;
@item invoked by the CCS provider, leading to interaction (B) with both CCS users;
@item invoked by one CCS user and the CCS provider, leading to interaction (A) with the originating CCS user and (B)
with the peer CCS user.
@end enumerate

@subsubheading User Primitives for Reset Service

@itemize @bullet
@item @prim{CC_RESET_REQ}:
This primitive requests that the CCS provider reset the specified call control address (circuit or circuit group).
@item @prim{CC_RESET_RES}:
This primitive indicates to the CCS provider that the CCS user has accepted a reset indication and has performed local
reset of the specified call control address (circuit or circuit group).@footnote{Note that the @prim{CC_RESET_RES}
primitive is not required and is only provided for completeness.  The CCS provider is allowed to acknowledge the reset
request to the peer CCS user upon receipt of the necessary protocol messages.  This permits automatic completion of the
reset service at the receiving CCS provider without he presence or involvement of a management entity associated with
the receiving provider.
}
@end itemize

@subsubheading Provider Primitives for Reset Service

@itemize @bullet
@item @prim{CC_RESET_IND}:
This primitive indicates to the CCS user that the user should reset the specified call control address (circuit or
circuit group).
@item @prim{CC_RESET_CON}:
This primitive indicates to the CCS user that the specified call control address (circuit or circuit group) has been
successfully reset by the peer.
@end itemize

The sequence of primitives are shown in @figref{48}, @figref{49}, @figref{50}, and @figref{51}.

@figuresized{cci14,48,Sequence of Primitives: CCS User Invoked Reset,4.0in}
@footnote{Note that in @figref{48} additional primitives may be issued by the CCS provider to a CCS call control user if
a CCS call control user is engaged in a call.}

@figuresized{cci15,49,Sequence of Primitives: Simultaneous CCS User Invoked Reset,4.0in}
@footnote{Note that in @figref{49} additional primitives may be issued by the CCS provider to a CCS call control user if
a CCS call control user is engaged in a call.}

@figuresized{cci16,50,Sequence of Primitives: CCS Provider Invoked Reset,4.0in}
@footnote{Note that in @figref{50} additional primitives may be issued by the CCS provider to a CCS call control user if
a CCS call control user is engaged in a call.}

@figuresized{cci17,51,Sequence of Primitives: Simultaneous CCS user and CCS Provider Invoked Reset,4.0in}
@footnote{Note that in @figref{51}  additional primitives may be issued by the CCS provider to a CCS call control user
if a CCS call control user is engaged in a call.}

@subsubsection Blocking Service

The blocking service is used by the CCS user or management to effect local maintenance or hardware blocking on circuits,
or by the CCS provider to indicate to CCS user or management the remote maintenance or hardware blocking of circuits.

The blocking service is only applicable to the NNI.

The blocking service provides for the local and remote blocking of call control addresses (signalling interface and
circuit or circuit group) either for maintenance oriented or hardware failure purposes.

Blocking should only be invoked from streams that are listening on a circuit group that includes the circuits for which
blocking is requested, or the @pval{CC_DEFAULT_LISTENER}.  Maintenance blocking will also only be indicated on streams
that are listening on circuit group that includes the circuits for which blocking is requested, or in the absence of
such a stream, the @pval{CC_DEFAULT_LISTENER}.  When no stream is available to report maintenance blocking indications,
the indication should be responded to by the CCS provider without user or management indication.

@subsubheading User Primitives for Blocking Service

@itemize @bullet
@item @prim{CC_BLOCKING_REQ}:
This primitive requests that the specified call control address(es) (signalling interface and circuit or circuit group)
be locally blocked either for maintenance oriented or hardware failure purposes.
@item @prim{CC_BLOCKING_RES}:
This primitive accepts a request and indicates the call control address(es) (circuit or circuit group) that were
remotely blocked for maintenance oriented or hardware failure purposes.@footnote{Note that the @prim{CC_BLOCKING_RES}
primitive is not required and is only provided for completeness.  The CCS provider is allowed to acknowledge the
blocking request to the peer CCS user upon receipt of the necessary protocol messages.  This permits automatic
completion of the blocking service at the receiving CCS provider without he presence or involvement of a management
entity associated with the receiving provider.
}
@end itemize

@subsubheading Provider Primitives for Blocking Service

@itemize @bullet
@item @prim{CC_BLOCKING_IND}:
This primitive indicates that the CCS user has requested that the specified call control address(es) (signalling
interface and circuit or circuit group) be remotely blocked either for maintenance oriented or hardware failure
purposes.
@item @prim{CC_BLOCKING_CON}:
This primitive indicates that the remote CCS user has confirmed the specified call control address(es) (signalling
interfaces and circuit or circuit group) as locally blocked either for maintenance oriented or hardware failure purposes
@end itemize

The sequence of primitives are shown in @figref{52}.

@figuresized{cci26,52,Sequence of Primitives: Successful Blocking Service,4.0in}

@subsubsection Unblocking Service

The unblocking service is only applicable to the NNI.

The unblocking service provides for the local and remote unblocking of call control addresses (signalling interface and
circuit or circuit group) either for maintenance oriented or hardware failure purposes.

@subsubheading User Primitives for Unblocking Service

@itemize @bullet
@item @prim{CC_UNBLOCKING_REQ}:
This primitive requests that the specified call control address(es) (signalling interfaces and circuit or circuit
groups) be locally unblocked either for maintenance oriented or hardware failure purposes.
@item @prim{CC_UNBLOCKING_RES}:
This primitive accepts a request and indicates the call control address(es) (circuit or circuit group) that were
remotely unblocked for maintenance oriented or hardware failure purposes.@footnote{Note that the @prim{CC_UNBLOCKING_RES}
primitive is not required and is only provided for completeness.  The CCS provider is allowed to acknowledge the
unblocking request to the peer CCS user upon receipt of the necessary protocol messages.  This permits automatic
completion of the unblocking service at the receiving CCS provider without he presence or involvement of a management
entity associated with the receiving provider.
}
@end itemize

@subsubheading Provider Primitives for Unblocking Service

@itemize @bullet
@item @prim{CC_UNBLOCKING_IND}:
This primitive indicates that the CCS user has requested that the specified call control address(es) (signalling
interface and circuit or circuit group) be remotely blocked either for maintenance oriented or hardware failure
purposes.
@item @prim{CC_UNBLOCKING_CON}:
This primitive indicates that the remote CCS user has confirmed the specified call control address(es) (signalling
interfaces and circuit or circuit group) as locally unblocked either for maintenance oriented or hardware failure
purposes.
@end itemize

The sequence of primitives are shown in @figref{53}.

@figuresized{cci27,53,Sequence of Primitives: Successful Unblocking Service,4.0in}

@subsubsection Query Service

The query service is only applicable to the NNI.

The query service provides for the query of the remote state and blocking level of call control addresses (signalling
interface and circuit group).

@subsubheading User Primitives for Query Service

@itemize @bullet
@item @prim{CC_QUERY_REQ}:
This primitive request that the specified call control address(es) (signalling interfaces and circuit group) be queried
for remote state and blocking level.
@item @prim{CC_QUERY_RES}:
This primitive accepts a request and indicates the local state and blocking level for the previously requested specified
call control addresses (circuit group).@footnote{Note that the @prim{CC_QUERY_RES}
primitive is not required and is only provided for completeness.  The CCS provider is allowed to acknowledge the query
request to the peer CCS user upon receipt of the necessary protocol messages.  This permits automatic completion of the
query service at the receiving CCS provider without he presence or involvement of a management entity associated with
the receiving provider.
}
@end itemize

@subsubheading Provider Primitives for Query Service

@itemize @bullet
@item @prim{CC_QUERY_IND}:
This primitive indicates that the CCS user has requested that the local state and blocking level for the call control
address(es) (signalling interface and circuit group).
@item @prim{CC_QUERY_CON}:
This primitive indicates that the remote CCS user has confirmed the specified call control addresses (signalling
interface and circuit group) and has returned the remote state and blocking level for each address.
@end itemize

The sequence of primitives are shown in @figref{54}.

@figuresized{cci38,54,Sequence of Primitives: Successful Query Service,4.0in}

@node CCI Primitives
@chapter CCI Primitives

This section describes the format and parameters of the CCI primitives (@ref{Mapping of CCI Primitives to Q.931} and
@ref{Mapping of CCI Primitives to Q.764}.  shows the mapping of CCI primitives of the primitives defined in Q.931 and
Q.764).  In addition, it discusses the states the primitive is valid in, the resulting state, and the acknowledgement
that the primitive expects.  (The state/event tables for these primitives are shown in @ref{State/Event Tables}.  The
precedence tables for the CCI primitives are shown in @ref{Primitive Precedence Tables}.)  Rules for ITU-T conformance
are described in @ref{Addendum for Q.931 Conformance} and @ref{Addendum for Q.764 Conformance} to this document.

Tables 5, 6, and 7 provide a summary of the CCS primitives and their parameters.

@page
@section Management Primitives

These primitives apply to UNI (User and Network) and NNI.

@subsection Call Control Information Request

@subsubheading CC_INFO_REQ
@prindex CC_INFO_REQ

This primitive request the CCS provider to return the values of all supported protocol parameters (see under
@prim{CC_INFO_ACK}), and also the current state of the CCS provider (as defined in @ref{State/Event Tables}).  This
primitive does not affect the state of the CCS provider and does not appear in the state tables.

@subsubheading Format

The format of the message is one @msg{M_PCPROTO} message block and its structure is as follows:

@smallexample
@verbatim
typedef struct CC_info_req {
        ulong cc_primitive;             /* always CC_INFO_REQ */
} CC_info_req_t;
@end verbatim
@tpindex struct CC_info_req
@tpindex CC_info_req_t
@end smallexample

@subsubheading Parameters

@vtable @parm
@item cc_primitive
Indicates the primitive type.
@end vtable

@subsubheading Valid States

This primitive is valid in any state where a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Acknowledgements

This primitive requires the CCS provider to generate one of the following acknowledgements upon receipt of the
primitive:
@itemize ---
@item @emph{Successful}:  Acknowledgement of the primitive via the @prim{CC_INFO_ACK}
primitive.
@item @emph{Non-fatal errors}:  There are no errors associated with the issuance of this primitive.
@end itemize

@page
@subsection Call Control Information Acknowledgement

@subsubheading CC_INFO_ACK
@prindex CC_INFO_ACK

This primitive indicates to the CCS user any relevant protocol-dependent parameters.  It should be initiated in
response to the @prim{CC_INFO_REQ} primitive described above.

@subsubheading Format

The format of this message is one @msg{M_PCPROTO} message block and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_info_ack {
        ulong cc_primitive;             /* always CC_INFO_ACK */
        /* FIXME ... more ... */
} CC_info_ack_t;
@end verbatim
@tpindex struct CC_info_ack
@tpindex CC_info_ack_t
@end smallexample

@subsubheading Parameters

The above fields have the following meaning:
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@end vtable

@subsubheading Flags

@subsubheading Valid States

This primitive is valid in any state in response to a @prim{CC_INFO_REQ} primitive.

@subsubheading New State

The state remains the same.

@page
@subsection Protocol Address Request

@subsubheading CC_ADDR_REQ
@prindex CC_ADDR_REQ

This primitive requests that the CCS provider return information concerning the call control addresses upon which the
CCS user is bound or engage in a call.

The format of the message is one @msg{M_PROTO} message block and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_addr_req {
        ulong cc_primitive;             /* always CC_ADDR_REQ */
        ulong cc_call_ref;              /* call reference */
} CC_addr_req_t;
@end verbatim
@tpindex struct CC_addr_req
@tpindex CC_addr_req_t
@end smallexample

@subsubheading Parameters

@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference for which to obtain the connected address.
@end vtable

@subsubheading Valid States
This primitive is valid in any state.

@subsubheading New State
The new state is @psta{CCS_WACK_AREQ}.
@stindex CCS_WACK_AREQ

@subsubheading Rules

@itemize @bullet
@item If the call reference is specified as zero (0), then no connected address information will be returned in the
@prim{CC_ADDR_ACK}.
@end itemize

@subsubheading Acknowledgements

The CCS provider will generate on of the following acknowledgements upon receipt of the @prim{CC_ADDR_REQ}
primitive:
@itemize ---
@item @emph{Successful}: Correct acknowledgement of the primitive is indicated via the @prim{CC_ADDR_ACK}
primitive.
@item @emph{Unsuccessful (Non-fatal errors)}: These errors will be indicated via the @prim{CC_ERROR_ACK}
primitive.  The applicable non-fatal errors are as follows:
@table @asis
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsection Protocol Address Acknowledgement

@subsubheading CC_ADDR_ACK
@prindex CC_ADDR_ACK

This primitive acknowledges the corresponding request primitive and is used by the CCS provider to return
information concerning the bound and connected protocol addresses for the stream.

The format of the message is one @msg{M_PROTO} message block and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_addr_ack {
        ulong cc_primitive;             /* always CC_ADDR_ACK */
        ulong cc_bind_length;           /* length of bound address */
        ulong cc_bind_offset;           /* offset of bound address */
        ulong cc_call_ref;              /* call reference */
        ulong cc_conn_length;           /* length of connected address */
        ulong cc_conn_offset;           /* offset of connected address */
} CC_addr_ack_t;
@end verbatim
@tpindex struct CC_addr_ack
@tpindex CC_addr_ack_t
@end smallexample

@subsubheading Parameters

@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_bind_length
Indicates the length of the bound call control address.
@item cc_bind_offset
Indicates the offset of the bound call control address.
@item cc_call_ref
Indicates the call reference for the connected call control address.
@item cc_conn_length
Indicates the length of the connected call control address.
@item cc_conn_offset
Indicates the offset of the connected call control address.
@end vtable

@subsubheading Valid State

This primitive is valid in state @psta{CC_WACK_AREQ}.

@subsubheading New State

The new state is the state previous to the @prim{CC_ADDR_REQ}.

@subsubheading Rules

@itemize @bullet
@item If the requesting stream is not bound to a call control address, the CCS provider will code the
@parm{cc_bind_length} and @parm{cc_bind_offset} fields to zero.  Otherwise, the CCS provider will return the same call
control address that was returned in the @prim{CC_BIND_ACK}.
@item If the requesting stream is not connected to a call, the CCS provider will code the @parm{cc_conn_length} and
@parm{cc_conn_offset} fields to zero.  Otherwise, the CCS provider will indicate the call control address (circuit) upon
which the call is connected.
@end itemize

@page
@subsection Bind Protocol Address Request

@subsubheading CC_BIND_REQ
@prindex CC_BIND_REQ

This primitive requests that the CCS provider bind a CCS user entity to a call control address (circuit, circuit
group) and negotiate the number of setup indications allowed to be outstanding by the CCS provider for the specified
CCS user entity being bound.

@subsubheading Format

The format of the message is one @msg{M_PROTO} message block and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_bind_req {
        ulong cc_primitive;             /* always CC_BIND_REQ */
        ulong cc_addr_length;           /* length of address */
        ulong cc_addr_offset;           /* offset of address */
        ulong cc_setup_ind;             /* req # of setup inds to be queued */
        ulong cc_bind_flags;            /* bind options flags */
} CC_bind_req_t;
@end verbatim
@tpindex struct CC_bind_req
@tpindex CC_bind_req_t
@verbatim
/* Flags associated with CC_BIND_REQ */
#define CC_DEFAULT_LISTENER             0x000000001UL
#define CC_TOKEN_REQUEST                0x000000002UL
#define CC_MANAGEMENT                   0x000000004UL
#define CC_TEST                         0x000000008UL
#define CC_MAINTENANCE                  0x000000010UL
#define CC_MONITOR                      0x000000020UL
@end verbatim
@end smallexample

@subsubheading Parameters

@vtable @parm
@item cc_primitive
Is the primitive type.
@item cc_addr_length
Is the length in bytes of the call control (circuit, circuit group) address to be bound to the stream.
@item cc_addr_offset
Is the offset from the beginning of the @msg{M_PROTO} block where the call control (circuit, circuit group) address
begins.
@item cc_setup_ind
Is the requested number of setup indications (simultaneous incoming calls) allowed to be outstanding by the CCS
provider for the specified protocol address.  (If the number of outstanding setup indications equals cc_setup_ind,
the CCS provider need not discard further incoming setup indications, but may choose to queue them internally until
the number of outstanding setup indications drops below the cc_setup_ind number.)  Only one stream per call control
address is allowed to have a cc_setup_ind number value greater than zero.  This indicates to the CCS provider that
this stream is the listener stream for the CCS user.  This stream will be used by the CCS provider for setup
indications for that call control address.

if a stream is bound as a listener stream, it is still able to initiate outgoing call setup requests.
@item cc_bind_flags
See "Flags" below.
@end vtable

@subsubheading Flags

@table @pval
@item CC_DEFAULT_LISTENER
When set, this flag specifies that this stream is the "default listener stream."  This stream is used to pass setup
indications (or continuity check requests) for all incoming calls that contain protocol identifiers that are not
bound to any other listener, or when a listener stream with cc_setup_ind value of greater than zero is not found.
Also, the default listener will receive all incoming call indications that contain no user data (i.e., test calls)
and all maintenance indications (i.e., @prim{CC_MAINT_IND}).  Only one default listener stream is allowed per occurrence
of CCI.  An attempt to bind a default listener stream when one is already bound should result in an error (of type
@perr{CCADDRBUSY}).
@item CC_TOKEN_REQUEST
When set, this flag specifies to the CCS provider that the CCS user has requested that a "token" be assigned to the
stream (to be used in the call response message), and the token value be returned to the CCS user via the
@prim{CC_BIND_ACK} primitive.  The token assigned by the CCS provider can then be used by the CCS user in a subsequent
@prim{CC_SETUP_RES} primitive to identify the stream on which the call is to be established.
@item CC_MANAGEMENT
When set, this flag specifies to the CCS provider that this stream is to be used for circuit management indications
for the specified addresses.
@item CC_TEST
When set, this flag specifies to the CCS provider that this stream is to be used for continuity and test call
indications for the specified addresses.
@item CC_MAINTENANCE
When set, this flag specifies to the CCS provider that this stream is to be used for maintenance indications for the
specified addresses.
@end table

@subsubheading Valid States

This primitive is valid in state @psta{CCS_UNBND} (see @ref{State/Event Tables}).
@stindex CCS_UNBND

@subsubheading New State

The new state is @psta{CCS_WACK_BREQ}.
@stindex CCS_WACK_BREQ

@subsubheading Acknowledgements

The CCS provider will generate one of the following acknowledgements upon receipt of the @prim{CC_BIND_REQ}
primitive:
@itemize ---
@item @emph{Successful}:  Correct acknowledgement of the primitive is indicated via the @prim{CC_BIND_ACK}
primitive.
@item @emph{Non-fatal errors}:  These errors will be indicated via the @prim{CC_ERROR_ACK}
primitive.  The applicable non-fatal errors are as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADADDR}
The call control address was in an incorrect format or the address contained illegal information.  It is not
intended to indicate protocol errors.
@c @item @perr{CCBADDIGS}
@c @item @perr{CCBADOPT}
@item @perr{CCNOADDR}
The CCS user did not provide a call control address and the CCS provider could not allocate an address to the user.
@item @perr{CCADDRBUSY}
The CCS user attempted to bind a second stream to a call control address with the cc_setup_ind number set to a
non-zero value, or attempted to bind a second stream with the @pval{CC_DEFAULT_LISTENER}
flag value set to non-zero.
@c @item @perr{CCBADCLR}
@c @item @perr{CCBADTOK}
@item @perr{CCBADFLAG}
The flags were invalid or unsupported, or the combination of flags was invalid.  This error is returned if more than
one of @pval{CC_TEST}, @pval{CC_MANAGEMENT}, or @pval{CC_MAINTENANCE} flags are set.
@c @item @perr{CCNOTSUPP}
@item @perr{CCBADPRIM}
@c @item @perr{CCBADOPTTYPE}
The primitive format was incorrect (i.e. too short).
@item @perr{CCACCESS}
The user did not have proper permissions.
@end table
@end itemize

@page
@subsection Bind Protocol Address Acknowledgement

@subsubheading CC_BIND_ACK
@prindex CC_BIND_ACK

This primitive indicates to the CCS user that the specified call control user entity has been bound to the requested
call control address and that the specified number of connect indications are allowed to be queued by the CCS
provider for the specified network address.

@subsubheading Format

The format of the message is one @msg{M_PCPROTO} message block, and its structure is the following:
@smallexample
@verbatim
typedef struct CC_bind_ack {
        ulong cc_primitive;             /* always CC_BIND_ACK */
        ulong cc_addr_length;           /* length of address */
        ulong cc_addr_offset;           /* offset of address */
        ulong cc_setup_ind;             /* setup indications */
        ulong cc_token_value;           /* setup response token value */
} CC_bind_ack_t;
@end verbatim
@tpindex struct CC_bind_ack
@tpindex CC_bind_ack_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_addr_length
Is the length of the call control address that was bound.
@item cc_addr_offset
Is the offset from the beginning of the @msg{M_PCPROTO} block where the call control address begins.
@item cc_setup_ind
Is the accepted number of setup indications allowed to be outstanding by the CCS provider for the specified call control
address.  If its value is zero, this stream cannot accept @prim{CC_SETUP_IND} messages.  If its value is greater than
zero, then the CCS user can accept @prim{CC_SETUP_IND} messages up to the value specified in this parameter before
having to respond with a @prim{CC_SETUP_RES} or a @prim{CC_DISCONNECT_REQ} message.
@item cc_token_value
Conveys the value of the "token" assigned to this stream that can be used by the CCS user in a @prim{CC_SETUP_RES}
primitive to accept a call on this stream.  It is a non-zero value, and is unique to all streams bound to the CCS
provider.
@end vtable

The proper alignment of the address in the @msg{M_PCPROTO} message block is not guaranteed.

@subsubheading Rules

The following rules apply to the binding of the specified call control address to the stream:
@itemize @bullet
@item
If the @parm{cc_addr_length} field in the @prim{CC_BIND_REQ}
primitive is zero, then the CCS provider is to assign a call control address to the user.
@item
The CCS provider is to bind the call control address as specified in the @prim{CC_BIND_REQ} primitive.  If the CCS
provider cannot bind the specified address, it may assign another call control address to the user.  It is the call
control user's responsibility to check the call control address returned in the @prim{CC_BIND_ACK} primitive to see if
it is the same as the one requested.
@end itemize

The following rules apply to negotiating cc_setup_ind argument:

@itemize @bullet

@item
The @parm{cc_setup_ind} number in the @prim{CC_BIND_ACK} primitive must be less than or equal to the corresponding
requested number as indicated in the @prim{CC_BIND_REQ} primitive.

@item
Only one stream that is bound to the indicated call control address may have a negotiated accepted number of maximum
setup indications greater than zero.  If a @prim{CC_BIND_REQ} primitive specifies a value greater than zero, but another
stream has already bound itself to the given call control address with a value greater than zero, the CCS provider
should assign another protocol address to the user.

@item
If a stream with @parm{cc_setup_ind} number greater than zero is used to accept a call, the stream will be found busy
during the duration of that call and no other streams may be bound to that call control address with a
@parm{cc_setup_ind} number greater than zero.  This will prevent more than one stream bound to the identical call
control address from accepting setup indications.

@item
A stream requesting a @parm{cc_setup_ind} number of zero should always be legal.  This indicates to the CCS provider
that the stream is to be used to request call setup only.

@item
A stream with a negotiated @parm{cc_setup_ind} number greater than zero may generate setup requests or accept setup
indications.

@end itemize

@emph{If the above rules result in an error condition, then the CCS provider must issue a @prim{CC_ERROR_ACK}}
@emph{primitive to the CCS user specifying the error as defined in the description of the @prim{CC_BIND_REQ}}
@emph{primitive.}

@subsubheading Valid States

This primitive is in response to a @prim{CC_BIND_REQ} primitive and is valid in the state @psta{CCS_WACK_BREQ}.
@stindex CCS_WACK_BREQ

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@page
@subsection Unbind Protocol Address Request

@subsubheading CC_UNBIND_REQ
@prindex CC_UNBIND_REQ

This primitive request that the CCS provider unbind the CCS user entity that was previously bound to the call
control address.

@subsubheading Format

The format of the message is one @msg{M_PROTO} block, and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_unbind_req {
        ulong cc_primitive;             /* always CC_UNBIND_REQ */
} CC_unbind_req_t;
@end verbatim
@tpindex struct CC_unbind_req
@tpindex CC_unbind_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@end vtable

@subsubheading Valid States

This primitive is valid in the @psta{CCS_IDLE} state.
@stindex CCS_IDLE

@subsubheading New State

The new state is @psta{CCS_WACK_UREQ}.

@subsubheading Acknowledgements

This primitive requires the CCS provider to generate the following acknowledgements upon receipt of the primitive:
@itemize ---
@item
@emph{Successful}:  Correct acknowledgement of the primitive is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  These errors will be indicated via the @prim{CC_ERROR_ACK} primitive.  The
applicable non-fatal errors are as follows:
@table @asis
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsection Call Processing Options Management Request

@subsubheading CC_OPTMGMT_REQ
@prindex CC_OPTMGMT_REQ

This primitive allows the CCS user to manage the call processing parameter values associated with the stream.

@subsubheading Format

The format of the message is one @msg{M_PROTO} message block, and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_optmgmt_req {
        ulong cc_primitive;             /* always CC_OPTMGMT_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* length of option values */
        ulong cc_opt_offset;            /* offset of option values */
        ulong cc_opt_flags;             /* option flags */
} CC_optmgmt_req_t;
@end verbatim
@tpindex struct CC_optmgmt_req
@tpindex CC_optmgmt_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference for which to manage options.
@item cc_opt_length
Specifies the length of the default values of the options parameters as selected by the CCS user.  These values will
be used in subsequent @prim{CC_SETUP_REQ} primitives on the stream that do not specify values for these options.  If the
CCS user cannot determine the value of an option, it value should be set to CC_UNKNOWN.  If the CCS user does not
specify any option paramter values, the length of this field should be set to zero.
@item cc_opt_offset
Specifies the offset of the options parameters from the beginning of the @msg{M_PROTO} message block.
@item cc_opt_flags
See "Flags" below.
@end vtable

@subsubheading Flags

@subsubheading Valid States

This primitive is valid in the @psta{CCS_IDLE}
state.
@stindex CCS_IDLE

@subsubheading New State

The new state is @psta{CCS_WACK_OPTREQ}.

@subsubheading Acknowledgements

The @prim{CC_OPTMGMT_REQ} primitive requires the CCS provider to generate one of the following acknowledgements upon receipt
of the primitive:
@itemize ---
@item
@emph{Successful}:  Acknowledgement is via the @prim{CC_OK_ACK} primitive.  At successful completions, the resulting state is
@psta{CCS_IDLE}.
@stindex CCS_IDLE
@item
@emph{Non-fatal errors}:  These errors are indicated in the @prim{CC_ERROR_ACK} primitive.  The resulting state remains
unchanged.  The applicable non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@c @item @perr{CCBADADDR}
@c @item @perr{CCBADDIGS}
@item @perr{CCBADOPT}
The option parameter values specified are outside the range supported by the
CCS provider.
@c @item @perr{CCNOADDR}
@c @item @perr{CCADDRBUSY}
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@c @item @perr{CCBADTOK}
@item @perr{CCBADFLAG}
The flags were invalid or unsupported, or the combination of flags was invalid.
@c @item @perr{CCNOTSUPP}
@item @perr{CCBADPRIM}
The primitive format was incorrect (i.e. too short).
@item @perr{CCACCESS}
The user did not have proper permissions.
@c @item CCBADOPTTYPE
@c The option structure tupe is not supported by the CCS provider.
@end table
@end itemize

@page
@subsection Call Processing Options Management Acknowledgement

@subsubheading CC_OPTMGMT_ACK

This primitive allows the CCS user to manage the call processing parameter values associated with the stream.

@subsubheading Format

The format of the message is one @msg{M_PCPROTO} message block, and it structure is as follows:
@smallexample
@verbatim
typedef struct CC_optmgmt_ack {
        ulong cc_primitive;             /* always CC_OPTMGMT_ACK */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* length of option values */
        ulong cc_opt_offset;            /* offset of option values */
        ulong cc_opt_flags;             /* option flags */
} CC_optmgmt_ack_t;
@end verbatim
@tpindex struct CC_optmgmt_ack
@tpindex CC_optmgmt_ack_t
@end smallexample

@subsubheading Parameters

@subsubheading Flags

@subsubheading Valid States

This primitive is valid in any state.

@subsubheading New State

The new state is unchanged.

@subsubheading Acknowledgements

@page
@subsection Error Acknowledgement

@subsubheading CC_ERROR_ACK
@prindex CC_ERROR_ACK

This primitive indicates to the CCS user that a non-fatal error has occurred in the last CCS user originated
primitive.  This may only be initiated as an acknowledgement for those primitives that require one.  It also
indicates to the user that no action was taken on the primitive that caused the error.

@subsubheading Format

The format of the mssage is one @msg{M_PCPROTO} message block, and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_error_ack {
        ulong cc_primitive;             /* always CC_ERROR_ACK */
        ulong cc_error_primitive;       /* primitive in error */
        ulong cc_error_type;            /* CCI error code */
        ulong cc_unix_error;            /* UNIX system error code */
        ulong cc_state;                 /* current state */
        ulong cc_call_ref;              /* call reference */
} CC_error_ack_t;
@end verbatim
@tpindex struct CC_error_ack
@tpindex CC_error_ack_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Identifies the primitive type.
@item cc_error_primitive
Identifies the primitive type that cause the error.
@item cc_error_type
Contains the Call Control Interface error code.
@item cc_unix_error
Contains the UNIX system error code.  This may only be non-zero if the cc_error_type is equal to @perr{CCSYSERR}.
@item cc_state
Identifies the state of the interface at the time that the @prim{CC_ERROR_ACK} primitive was issued by the CCS provider.
@item cc_call_ref
Identifies the CCS provider or CCS user call reference associated with the request or response primitive that was in
error.  If no call reference is associated with the request or response primitive that caused the error, this field
is coded zero (0) by the CCS provider.
@end vtable

@subsubheading Valid Error Codes

@emph{The following error codes are allows to be returned:}
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADADDR}
The call control address as specified in the primitive was in an incorrect format, or the address contained illegal
information.
@item @perr{CCBADDIGS}
The digits provided in the called party number or subsequent number specified in the primitive are of an incorrect
format or are invalid.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCNOADDR}
The CCS provider could not allocate an address.
@item @perr{CCADDRBUSY}
The CCS provider could not use the specified address because the specified address is already in use.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADTOK}
Token used is not associated with an open stream.
@item @perr{CCBADFLAG}
The flags specified in the primitive were incorrect or illegal.
@item @perr{CCNOTSUPP}
Specified primitive type is not known to the CCS provider.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out of range).
@item @perr{CCACCESS}
The user did not have proper permissions.
@end table

@subsubheading Valid States

This primitive is valid in all states that have a pending acknowledgement or confirmation.

@subsubheading New State

The new state is the same as the one from which the acknowledged request or response was issued.

@page
@subsection Successful Receipt Acknowledgements

@subsubheading CC_OK_ACK
@prindex CC_OK_ACK

The primitive indicates to the CCS user that the previous call control user originated primitive was received
successfully by the call control provider.  It does not indicate to the CCS user any call control protocol action taken
due to the issuance of the last primitive.  The @prim{CC_OK_ACK} primitive may only be initiated as an acknowledgement
for those user-originated primitives that have no other means of confirmation.

@subsubheading Format

The format of the message is one @msg{M_PCPROTO} message block, and its structure is as follows:
@smallexample
@verbatim
typedef struct CC_ok_ack {
        ulong cc_primitive;             /* always CC_OK_ACK */
        ulong cc_correct_prim;          /* primitive being acknowledged */
        ulong cc_state;                 /* current state */
        ulong cc_call_ref;              /* call reference */
} CC_ok_ack_t;
@end verbatim
@tpindex struct CC_ok_ack
@tpindex CC_ok_ack_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Identifies the primitive.
@item cc_correct_prim
Identifies the successfully received primitive type.
@item cc_state
Identifies the state of the interface at the time that the @prim{CC_OK_ACK} primitive was issued by the CCS provider.
@item cc_call_ref
Identifies the CCS provider or CCS user call reference associated with the request or response primitive that was in
error.  If no call reference is associated with the request or response primitive that caused the error, this field
is coded zero (0) by the CCS provider.
@end vtable

@subsubheading Valid States

This primitive is issued in states @psta{CCS_WACK_UREQ} and @psta{CCS_WACK_OPTREQ}.

@subsubheading New State

The resulting state depends on the current state (see @ref{State/Event Tables}, Tables B-7 and B-8.).

@page
@section Primitive Format and Rules

This section describes the format of the UNI (User and Newtork) and NNI primitives and the rules associated with
these primitives.  The default values of the options parameters associated with a call may be selected via the
@prim{CC_OPTMGMT_REQ} primitive.

@subsection Call Setup Phase

The following call control service primitives pertain to the setup of a call, provided the CCS users exist, and are
known to the CCS provider.

@subsubsection Call Control Setup Request

@subsubheading CC_SETUP_REQ
@prindex CC_SETUP_REQ

This primitive requests that the CCS provider make a call to the specified destination.

@subsubheading Format

The format of the message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_setup_req {
        ulong cc_primitive;             /* always CC_SETUP_REQ */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_type;             /* call type */
        ulong cc_call_flags;            /* call flags */
        ulong cc_cdpn_length;           /* called party number length */
        ulong cc_cdpn_offset;           /* called party number offset */
        ulong cc_opt_length;            /* optional parameters length */
        ulong cc_opt_offset;            /* optional parameters offset */
        ulong cc_addr_length;           /* connect to address length */
        ulong cc_addr_offset;           /* connect to address offset */
} CC_setup_req_t;
@end verbatim
@tpindex struct CC_setup_req
@tpindex CC_setup_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_user_ref
Specifies a reference number known to the CCS user that uniquely identifies the current setup request.  When this
value is non-zero, it permits the CCS User to have multiple outstanding setup requests pending on the same stream.
Responses made by the CCS provider to the @prim{CC_SETUP_REQ} primitive will contain this CCS user call attempt reference.
@item cc_call_type
Specifies the type of call to be set up.  Call types supported are dependent upon the CCS provider and protocol, see
the addendum for call types for specific protocols.
@item cc_call_flags
Specifies a bit field of call options.  Call flags supported are depeddent upon the CCS provider and protocol, see
the addendum for call flags for specific protocols.
@item cc_cdpn_length
Specifies the length of the called party number parameter that conveys an address identifying the CCS user to which
the call is to be established.  This field will accommodate variable length numbers within a range supported by the
CCS provider.  If no called party address is provided by the CCS user, this field must be coded to zero.  The coding
of the called party number is protocol and provider-specific.
@item cc_cdpn_offset
Is the offset of the called party number from the beginning of the @msg{M_PROTO} message block.
@item cc_opt_length
Specifies the length of optional parameters to be conveyed in the call setup.  This field will accomodate variable
length addresses within a range supported by the CCS provider.  If no optional parameters are provided by the CCS
user, this field must be coded to zero.  The format of optional parameters are protocol and provider-specific, see
the addendum for the format of optional parameters for specific protocols.
@item cc_opt_offset
Specifies the offset of the optional parameters from the beginning of the @msg{M_PROTO} message block.
@item cc_addr_length
Specifies the length of the call control address parameter that conveys the call control address (circuit, circuit
group) of the CCS user entity to which the call is to be established.  The semantics of the values in the
@prim{CC_SETUP_REQ} is identical to the values in the @prim{CC_BIND_REQ}.
@item cc_addr_offset
Specifies the offset of the call control address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Rules

The following rules apply to the setup of calls to the specified addresses:
@itemize @bullet
@item
If the cc_cdpn_length field in the @prim{CC_SETUP_REQ} primitive is zero, then the CCS provider is to select a called party
number for the call.  If the CCS provider cannot select a called party number for the call, the CCS provider
responds with a @prim{CC_ERROR_ACK} primitive with error @perr{CCNOADDR}.
@item
If the cc_cdpn_length field in the @prim{CC_SETUP_REQ} primitive is non-zero, the CCS provider is to setup the call to the
specified number.  If the CCS provider cannot setup a call of the specified call type to the specified number the
call will fail and the CCS provider will return a @prim{CC_ERROR_ACK} with the appropriate error value (e.g., @perr{CCBADADDR}).
@end itemize

The following rules apply to the call control addresses (trunk groups and
circuit identifiers):
@itemize @bullet
@item
If the CCS user does not specify a call control address (i.e. cc_addr_length is set to zero), then the CCS provider
may attempt to assign a call control address, assign it a call reference and associate it with the stream for the
duration of the call.
@end itemize

The following rules apply to the CCS user call attempt reference:
@itemize @bullet
@item
If the CCS user does not specify a call attempt reference (i.e. the cc_user_ref is set to zero), then the CCS
provider can only support one outstanding outgoing call attempt for the stream.  If the CCS user specifies a call
attempt reference, all replies made by the CCS provider to this @prim{CC_SETUP_REQ} primitive will contain the CCS user
specified call attempt reference until either the call fails or is released, or after the CCS provider sends a
@prim{CC_SETUP_CON} primitive.
@end itemize

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE}.
@stindex CCS_IDLE

@subsubheading New State

The new state depends upon the information provided in the @prim{CC_SETUP_REQ} message as follows:
@itemize @bullet
@item
If the setup request specifies that a continuity check was performed on a previous circuit, the new state is
@psta{CCS_WREQ_CCREP}
@stindex CCS_WREQ_CCREP
(awaiting report of the result of continuity test performed on the previous circuit).
@item
If the setup request specifies that a continuity check is required on the circuit, the new state is @psta{CCS_WIND_CTEST}
(awaiting indication of remote loop back on the circuit).
@item
If the setup request specifies that no continuity test is required on this or a previous circuit and that the
called party address contains partial information, the new state is @psta{CCS_WIND_MORE}
@stindex CCS_WIND_MORE
(awaiting the indication that more information is required).
@item
If the setup request specifies that no continuity test is required on this or a previous circuit and that the called
party address contains complete information, the new state is @psta{CCS_WCON_SREQ}
@stindex CCS_WCON_SREQ
(awaiting confirmation of the setup request).
@end itemize

@subsubheading Acknowledgements

The following acknowledgements are valid for this primitive:
@itemize ---
@item
@emph{Successful Call Establishment}:
This is indicated via the @prim{CC_SETUP_CON} primitive.  This results in the Call Establishment state.  For @prim{CC_SETUP_REQ}
primitives where @pval{ISUP_NCI_CONT_CHECK_REQUIRED} is set, or where the CCS provider otherwise determines that a
continuity check is required on the circuit, success is still indicated via the @prim{CC_SETUP_CON} primitive.  In this
case, the @prim{CC_SETUP_CON} primitive is not sent by the CCS provider unless the continuity check is successful.  For
@psta{CCS_SETUP} primitives where @pval{ISUP_NCI_CONT_CHECK_PREVIOUS} is set, the @prim{CC_SETUP_CON} primitive is not sent by the CCS
provider until the CCS user sends a @prim{CC_CONT_REPORT_REQ} primitive indicating that continuity check on the previous
circuit has been successful.  Receipt of the @prim{CC_SETUP_CON} primitive always results in the Call Establishment state.
@item
@emph{Unsuccessful Call Establishment}:
This is indicated via the @prim{CC_CALL_REATTEMPT_IND}, @prim{CC_CALL_FAILURE_IND}, or @prim{CC_RELEASE_IND} primitives.  For example, a
call may be rejected because either the called CCS user cannot be reached, or the CCS provider and/or the called CCS
user did not agree on the specified call type or options.  This results in the Idle state.  Where the
@prim{CC_CALL_REATTEMPT_IND} or @prim{CC_RELEASE_IND} primitives are sent before the @prim{CC_SETUP_CON} primitive, the
@prim{CC_CALL_REATTEMPT_IND} or @prim{CC_RELEASE_IND} primitives will contain the CCS user specified call attempt reference.
@item
@emph{Non-fatal errors}:  These are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system eror is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADADDR}
The call control address as specified in the primitive was in an incorrect format, or the address contained illegal
information.
@item @perr{CCBADDIGS}
The called party number was in the incorrect format, or contained illegal information.  This is used only to handle
coding errors of the number and is not intended to provide for protocol errors.  Protocol errors should be conveyed
in the @prim{CC_CALL_REATTEMPT_IND}, @prim{CC_CALL_FAILURE_IND} or @prim{CC_RELEASE_IND} primitives.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCNOADDR}
The user did not provide a called party address field and one was required by the call type.  The CCS provider could
not select a called party address.
@item @perr{CCADDRBUSY}
The CCS provider could not use the specified address because the specified address is already in use.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal (not unique).
@c @item @perr{CCBADTOK}
@c @item @perr{CCBADFLAG}
@c @item @perr{CCNOTSUPP}
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out of range).
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@end table
@end itemize

@page
@subsubsection Call Control Setup Indication

@subsubheading CC_SETUP_IND
@prindex CC_SETUP_IND

This primitive indicates to the destination CCS user that a call setup request has been made by the user at the
specified source address.

@subsubheading Format

The format of the message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_setup_ind {
        ulong cc_primitive;             /* always CC_SETUP_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_call_type;             /* call type */
        ulong cc_call_flags;            /* call flags */
        ulong cc_cdpn_length;           /* called party number length */
        ulong cc_cdpn_offset;           /* called party number offset */
        ulong cc_opt_length;            /* optional parameters length */
        ulong cc_opt_offset;            /* optional parameters offset */
        ulong cc_addr_length;           /* connecting address length */
        ulong cc_addr_offset;           /* connecting address offset */
} CC_setup_ind_t;
@end verbatim
@tpindex struct CC_setup_ind
@tpindex CC_setup_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Identifies the call reference that can be used by the CCS user to associate this message with the @prim{CC_SETUP_RES} or
@prim{CC_RELEASE_REQ} primitive that is to follow.  This value must be unique among the outstanding @prim{CC_SETUP_IND} messages.
@item cc_call_type
Indicates the type of call to be set up.  Call types supported are dependent upon the CCS provider and protocol, see
the addendum for call types for specific protocols.
@item cc_call_flags
Indicates a bit field of call options.  Call flags supported are dependent upon the CCS provider and protocol, see
the addendum for call flags for specific protocols.
@item cc_cdpn_length
Indicates the length of the called party number address parameter that conveys an address identifying the CCS user
to which the call is to be established.  This field will accommodate variable length addresses within a range
supported by the CCS provider.
@item cc_cdpn_offset
Is the offset of the called party number address from the beginning of the @msg{M_PROTO} message block.
@item cc_opt_length
Indicates the length of the optional parameters that were used in the call setup.
@item cc_opt_offset
Indicates the offset of the optional parameters from the beginning of the @msg{M_PROTO} message block.
@item cc_addr_length
Indicates the length of the connecting address parameter that conveys the call control address the CCS user entity
(circuit) on which the call is being established.  The semantics of the values in the @prim{CC_SETUP_IND} is identical to
the values in the @prim{CC_BIND_ACK}.
@item cc_addr_offset
Indicates the offset of the connecting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE}
@stindex CCS_IDLE
for the indicated call reference.

@subsubheading New State

The new state depends upon the information provided in the @prim{CC_SETUP_IND} message as follows:
@itemize @bullet
@item
If the setup indication indicates that a continuity check was performed on a previous circuit, the new state is
@psta{CCS_WIND_CCREP}
@stindex CCS_WIND_CCREP
(awaiting the report of continuity test results).
@item
If the setup indication indicates that a continuity check is required on the circuit, the new state is
@psta{CCS_WREQ_CTEST} (awaiting confirmation of installation of loop back device on the circuit).
@item
If the setup indication indicates that no continuity tests are required on this or a previous circuit and that the
called party number contains partial information, the new state is @psta{CCS_WREQ_MORE}
@stindex CCS_WREQ_MORE
(awaiting the request for more information to confirm the partial address).
@item
If the setup indication indicates that no continuity tests are required on this or a previous circuit and that the
called party number contains complete information, the new state is @psta{CCS_WRES_SIND}
@stindex CCS_WRES_SIND
(awaiting response to the setup indication).
@end itemize

In any event, the number of outstanding setup indications waiting for user response is incremented by one.

@subsubheading Rules

The rules for issuing the @prim{CC_SETUP_IND} primitive are as follows:
@itemize @bullet
@item
This primitive will only be issued to streams that have been bound with a non-zero negotiated maximum number of
setup indications (i.e. on a listening stream), and where the number of outstanding setup indications (call
references) for the stream is less than the negotiated maximum number of setup indications.
@item
If the call setup indicated is for a normal call, the stream upon which it is indicated was not bound with the
@pval{CC_TEST}, @pval{CC_MANAGEMENT} or @pval{CC_MAINTENANCE} flags set.
@item
If the call setup indicated is for an ISUP test call, the stream upon which it is indicated was bound with the
@pval{CC_TEST} flag set and a non-zero number of negotiated maximum setup indications.
@end itemize

@page
@subsubsection Call Control Setup Response

@subsubheading CC_SETUP_RES
@prindex CC_SETUP_RES

This primitive allows the destination CCS user to request that the call control provider accept a previous setup
indication.
This primitive also indicates that overlap receiving is complete.  The CCS use is still expected to
complete the setup process by issuing the @psta{CCS_PROCEED_REQ}, @psta{CCS_ALERTING_REQ},
@psta{CCS_PROGRESS_REQ}, @psta{CCS_IBI_REQ}, @psta{CCS_CONNECT_REQ}, or @psta{CCS_DISCONNECT_REQ}
messages.
@stindex CCS_PROCEED_REQ
@stindex CCS_ALERTING_REQ
@stindex CCS_PROGRESS_REQ
@stindex CCS_IBI_REQ
@stindex CCS_CONNECT_REQ
@stindex CCS_DISCONNECT_REQ

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_setup_res {
        ulong cc_primitive;             /* always CC_SETUP_RES */
        ulong cc_call_ref;              /* call reference */
        ulong cc_token_value;           /* call response token value */
} CC_setup_res_t;
@end verbatim
@tpindex struct CC_setup_res
@tpindex CC_setup_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference of the @prim{CC_SETUP_RES} message.  It is used by the CCS provider to associated the
@prim{CC_SETUP_RES} message with an outstanding @prim{CC_SETUP_IND} message.  An invalid call reference should result in error
with the error type @perr{CCBADCLR}.
@item cc_token_value
Is used to identify the stream that the CCS user wants to establish the call on.  (Its value is determined by the
CCS user by issuing a @prim{CC_BIND_REQ} primitive with the @pval{CC_TOKEN_REQ} flag set.  The token value is returned in the
@prim{CC_BIND_ACK}.)  The value of this field should be non-zero when the CCS user wants to establish the call on a stream
other than the stream on which the @prim{CC_SETUP_IND} arrived.  If the CCS user wants to establish a call on the same
stream that the @prim{CC_SETUP_IND} arrived on, then the value of this field should be zero.
@end vtable

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WRES_SIND}.
@stindex CCS_WRES_SIND

@subsubheading New State

The new state is @psta{CCS_WREQ_PROCEED}.
@stindex CCS_WREQ_PROCEED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccesful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADTOK}
The token specified is not associated with an open stream.
@item @perr{CCBADPRIM}
The primitive format was incorrect (i.e. too short).
@end table
@end itemize

@page
@subsubsection Call Control Setup Confirm

@subsubheading CC_SETUP_CON
@prindex CC_SETUP_CON

This primitive indicates to the calling CCS user that the call control setup request has been sent on the specified
call control address (circuit, circuit group).  For calls that were requested setup with the
@pval{ISUP_NCI_CONT_CHECK_REQUIRED} flag set in the @prim{CC_SETUP_REQ}, or for which the CCS provider has otherwise decide to
perform continuity check, this also confirms that the continuity check was successful.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_setup_con {
        ulong cc_primitive;             /* always CC_SETUP_CON */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_addr_length;           /* connecting address length */
        ulong cc_addr_offset;           /* connecting address offset */
} CC_setup_con_t;
@end verbatim
@tpindex struct CC_setup_con
@tpindex CC_setup_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitives type.
@item cc_user_ref
Indicates the CCS user call attempt reference value which was provided by the CCS user in the @prim{CC_SETUP_REQ} message.
This permits the CCS user to associate this @prim{CC_SETUP_CON} primitive with the previous
@prim{CC_SETUP_REQ} primitive and
permits multiple outstanding @prim{CC_SETUP_REQ} primitives.
@item cc_call_ref
Indicates the CCS provider assigned call reference.  If the CCS user wishes to establish more than one simultaneous
call on a given stream, the CCS user must use this CCS provider indicated call reference in subsequent call control
primitives sent to the CCS provider.  This permits the CCS provider to associate a CCS user primitive with one of
multiple simultaneous calls associated with a given stream.
@item cc_addr_length
Indicates the length of the connecting address parameter that conveys the call control address of the CCS user
entity (circuit) on which the call is being established.  The semantics of the values in the
@prim{CC_SETUP_CON} is
identical to the values in the @prim{CC_BIND_REQ}.
@item cc_addr_offset
Indicates the offset of the connecting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_SREQ}
@stindex CCS_WCON_SREQ
and state @psta{CCS_WREQ_CCREP}.
@stindex CCS_WREQ_CCREP

@subsubheading New State

The new state depends on whether an end-of-pulsing signal was present in the called party number in the associated
@prim{CC_SETUP_REQ}
primitive.  If an ST signal was present, the new state is @psta{CCS_WREQ_PROCEED},
@stindex CCS_WREQ_PROCEED
otherwise the new state is
@psta{CCS_WREQ_MORE}.
@stindex CCS_WREQ_MORE
In either case, the call enters the Call Establishment Phase.

@page
@subsubsection Call Control Reattempt Indication

@subsubheading CC_CALL_REATTEMPT_IND
@prindex CC_CALL_REATTEMPT_IND

This primitive indicates to the calling CCS user that the selected address (circuit) is unavailable and that a
reattempt should be made on a new call control address (circuit).

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_call_reattempt_ind {
        ulong cc_primitive;             /* always CC_CALL_REATTEMPT_IND */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_reason;                /* reason for reattempt */
} CC_call_reattempt_ind_t;
@end verbatim
@tpindex struct CC_call_reattempt_ind
@tpindex CC_call_reattempt_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_user_ref
Indicates the CCS user call attempt reference value which was provided by the CCS user in the @prim{CC_SETUP_REQ} message.
This permits the CCS user to associate this @prim{CC_CALL_REATTEMPT_IND} primitive with the previous @prim{CC_SETUP_REQ} primitive
and permits multiple outstanding @prim{CC_SETUP_REQ} primitives.
@item cc_reason
Indicates the cause of the reattempt.  the cc_reason field is protocol and implementation specific.  See the
Addendum for protocol-specific values.
@end vtable

@subsubheading Valid Modes

This primitive is only valid in NNI mode.

@subsubheading Valid States

This primitive is valid in states
@psta{CCS_WCON_SREQ},
@stindex CCS_WCON_SREQ
@psta{CCS_WREQ_CCREP},
@stindex CCS_WREQ_CCREP
@psta{CCS_WIND_MORE},
@stindex CCS_WIND_MORE
@psta{CCS_WREQ_INFO}
@stindex CCS_WREQ_INFO
and
@psta{CCS_WIND_PROCEED}.
@stindex CCS_WIND_PROCEED

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@subsubheading Rules
@itemize @bullet
@item
The @prim{CC_CALL_REATTEMPT_IND} indicates that call repeat attempt should be made by the CCS user, and the reason for the
reattempt.
@item
If the @prim{CC_CALL_REATTEMPT_IND} is issued before the @prim{CC_SETUP_CON} primitive, the user reference value will be the same
value as appeared in the corresponding @prim{CC_SETUP_REQ} primitive, and the call reference value will be zero.
@item
If the CC_CALL_ATTEMPT_IND primitive is issued subsequent to the @prim{CC_SETUP_CON} primitive, the user reference value
will be zero, and the call reference value will be the same as appeared in the corresponding @prim{CC_SETUP_CON} primitive.
@end itemize

@page
@subsection Continuity Check Phase

The following call control service primitives pertain to the continuity check phase of a call.

@subsubsection Call Control Continuity Check Request

@subsubheading CC_CONT_CHECK_REQ
@prindex CC_CONT_CHECK_REQ

This primitive requests that the CCS provider perform a continuity check procedure.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_check_req {
        ulong cc_primitive;             /* always CC_CONT_CHECK_REQ */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_cont_check_req_t;
@end verbatim
@tpindex struct CC_cont_check_req
@tpindex CC_cont_check_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_addr_length
Specifies the length of the call control address (circuit identifier) upon which the CCS user is requesting a
continuity check.
@item cc_addr_offset
Specifies the offset of the call control address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Rules

The following rules apply to the continuity check of call control addresses (circuit identifiers):
@itemize @bullet
@item
If the CCS user does not specify a call control address (i.e, cc_addr_length is set to zero), then the CCS provider
may attempt to assign a call control address and associate it with the stream for the duration of the continuitu
test procedure.  This can be useful for automated continuity testing.
@end itemize


@subsubheading Valid Modes

This primitive is only valid in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE}
@stindex CCS_IDLE
for the selected circuit.

@subsubheading New State

The new state is CKS_WIND_CTEST for the selected address.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_CONT_TEST_IND} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the
primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCNOADDR}
The call control address was not provided (cc_addr_length coded zero).
@item @perr{CCBADADDR}
The call control address contained in the primitive were poorly formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling address was provided in the call control
address or the address was issued to a UNI CCS provider.
@item @perr{CCACCESS}
The user did not have sufficient permission to perform the operation on the specified call control addresses.
@end table
@end itemize

@page
@subsubsection Call Control Continuity Check Indication

@subsubheading CC_CONT_CHECK_IND
@prindex CC_CONT_CHECK_IND

This primitive indicates to the CCS user that a continuity check is being requested by the CCS user peer on the
specified call control address(es) (signalling interface and circuit identifiers).  Upon receipt of this primitive,
the CCS user should establish a loop back device on the specified channel and issues the
@prim{CC_CONT_TEST_REQ} primitive
confirming the loop back.  The CCS user should then wait for the @prim{CC_CONT_REPORT_IND} indicating the success or
failure of the continuity check.

This primitive is only delivered to listening streams listening on the specified call control addresses or to a
stream bound as a default listener in the same manner as the @prim{CC_SETUP_IND}.  (A continuity test indication is treated
as a special form of call setup.)

This primitive is only issued to CCS users that successfully bound using the @prim{CC_BIND_REQ} primitive with flag @pval{CC_TEST}
set and a non-zero number of setup indications was provided in the @prim{CC_BIND_REQ} and returned in the @prim{CC_BIND_ACK}.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_check_ind {
        ulong cc_primitive;             /* always CC_CONT_CHECK_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_cont_check_ind_t;
@end verbatim
@tpindex struct CC_cont_check_ind
@tpindex CC_cont_check_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Identifies the call reference that can be used by the CCS user to associate this message with the
@prim{CC_CONT_TEST_REQ}
or @prim{CC_RELEASE_REQ} primitive that is to follow.  This value must be unique among the outstanding @prim{CC_CONT_CHECK_IND}
messages.
@item cc_addr_length
Indicates the length of the call control address (circuit identifier) upon which a continuity check is indicated.
@item cc_addr_offset
Indicates the offset of the requesting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is only valid for addresses in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE}
@stindex CCS_IDLE
for the specified addresses.

@subsubheading New State

The new state is CKS_WREQ_CTEST for the specified addresses.

@page
@subsubsection Call Control Continuity Test Request

@subsubheading CC_CONT_TEST_REQ
@prindex CC_CONT_TEST_REQ

This message is used either to respond to a @prim{CC_SETUP_IND} primitive which contains the
@pval{ISUP_NCI_CONT_CHECK_REQUIRED}
flag, or to respond to a @prim{CC_CONT_CHECK_IND} primitive.  Before responding to either primitive, the CCS User should
install a loop back device on the requested channel and then respond with this response primitive to confirm the loop
back.


@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_test_req {
        ulong cc_primitive;             /* always CC_CONT_TEST_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_token_value;           /* token value */
} CC_cont_test_req_t;
@end verbatim
@tpindex struct CC_cont_test_req
@tpindex CC_cont_test_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference of the @prim{CC_CONT_TEST_REQ} message.  It is used by the CCS provider to associate the
@prim{CC_CONT_TEST_REQ} message with an outstanding @prim{CC_SETUP_IND} message.  An invalid call reference should result in error
with the error type @perr{CCBADCLR}.
@item cc_token_value
Is used to identify the stream that the CCS user wants to establish the continuity check call on.  (Its value is
determined by the CCS user by issuing a @prim{CC_BIND_REQ} primitive with the @pval{CC_TOKEN_REQ} flag set.  The token value
is returned in the @prim{CC_BIND_ACK}.)  The value of this field should be non-zero when the CCS user wants to establish
the call on a stream other than the stream on which the @prim{CC_CONT_CHECK_IND} arrived.  If the CCS user wants to
establish a call on the same stream that the @prim{CC_CONT_CHECK_IND} arrived on, then the value of this field should be
zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state CKS_WREQ_CTEST.

@subsubheading New State

The new state is CKS_WIND_CCREP.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_CONT_REPORT_IND} in the case that the primitive was
issued in response to a @prim{CC_SETUP_IND}, or @prim{CC_RELEASE_IND} primitive in the case that the primitive was issued in
response to the @prim{CC_CONT_CHECK_IND} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_CONT_REPORT_IND} primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCACCESS}
The user did not have proper permissions for the operation.
@item @perr{CCNOTSUPP}
The CCS provider does not support the operation.
@end table
@end itemize

@page
@subsubsection Call Control Continuity Test Indication

@subsubheading CC_CONT_TEST_IND
@prindex CC_CONT_TEST_IND

This message confirms to the testing CCS user that a loop back device has been (or will be) installed on the
specified call control address (circuit).  Upon receiving this message, the testing CCS user should connect tone
generation and detection equipment to the specified circuit, perform the continuity test and issue a report using
the @prim{CC_CONT_REPORT_REQ} primitive.

This primitive will only be issued to streams successfully bound with the @prim{CC_BIND_REQ} primitive with a non-zero
number of setup indications and the @pval{CC_TEST} bind flag set.

@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_test_ind {
        ulong cc_primitive;             /* always CC_CONT_TEST_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_cont_test_ind_t;
@end verbatim
@tpindex struct CC_cont_test_ind
@tpindex CC_cont_test_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference associated with the continuity check call for the specified call control address
(circuit identifier).
@item cc_addr_length
Indicates the length of the call control address (signalling interface and circuit identifier) upon which a
continuity check is confirmed.  The semantics of the values in the @prim{CC_CONT_TEST_IND} is identical to the values in
the @prim{CC_BIND_REQ}.
@item cc_addr_offset
Indicates the offset of the connecting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_CREQ}.
@stindex CCS_WCON_CREQ

@subsubheading New State

The new state is @psta{CCS_WAIT_COR}.
@stindex CCS_WAIT_COR

@page
@subsubsection Call Control Continuity Report Request

@subsubheading CC_CONT_REPORT_REQ
@prindex CC_CONT_REPORT_REQ

This primitive requests that the CCS provider indicate to the called CCS user that the continuity check succeeded or
failed.  The CCS user should remove any continuity test tone generator/detection device from the circuit and verify
silent code loop back before issuing this primitive.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_report_req {
        ulong cc_primitive;             /* always CC_CONT_REPORT_REQ */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_result;                /* result of continuity check */
} CC_cont_report_req_t;
@end verbatim
@tpindex struct CC_cont_report_req
@tpindex CC_cont_report_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_user_ref
Specifies the CCS user reference of the associated @prim{CC_SETUP_REQ} primitive.  This value is non-zero when the
@prim{CC_CONT_REPORT_REQ} primitive is issued subsequent to a @prim{CC_SETUP_REQ} primitive which had the flag
ISUP_NCI_CONTINUITY_CHECK_PREVIOUS set to indicate the result of the continuity check on the previous circuit.
Otherwise, this value is coded zero.
@item cc_call_ref
Specifies the call reference of the associated @prim{CC_CONT_TEST_IND} primitive for the continuity check call.  This value
is non-zero when the @prim{CC_CONT_REPORT_REQ} primitive is issued in response to a @prim{CC_CONT_TEST_IND} primitive.  Otherwise,
this value is coded zero.
@item cc_result
Specifies the result of the continuity test, whether success or failure.  The value of the cc_result is protocol
specific.  For values representing success and values representing failure, see the Addendum.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WREQ_CCREP}.
@stindex CCS_WREQ_CCREP

@subsubheading New State

When issued in response to the @prim{CC_CONT_TEST_IND}
primitive, the new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE
When issued subsequent to a @prim{CC_SETUP_REQ}
primitive, the new state is either @psta{CCS_WREQ_MORE}
@stindex CCS_WREQ_MORE
or @psta{CCS_WREQ_PROCEED},
@stindex CCS_WREQ_PROCEED
depending upon whether the sent address contain an ST pulse.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADPRIM}
The primitive format was incorrect.
@end table
@end itemize

@page
@subsubsection Call Control Continuity Report Indication

@subsubheading CC_CONT_REPORT_IND
@prindex CC_CONT_REPORT_IND

This primitive indicates to the called CCS user that the continuity check succeeded or failed.  The called CCS user
can remove the loop back or tone generation/detection devices from the circuit and the call either moves to the idle
state or a call setup state.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_report_ind {
        ulong cc_primitive;             /* always CC_CONT_REPORT_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_result;                /* result of continuity check */
} CC_cont_report_ind_t;
@end verbatim
@tpindex struct CC_cont_report_ind
@tpindex CC_cont_report_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference associated with the continuity check report as it appeared in the associated
@prim{CC_CONT_CHECK_IND} primitive.
@item cc_result
Indicates the result of the continuity test, whether success or failure.  The value of the cc_result is protocol
specific.  For values representing success and values representing failure, see the Addendum.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WREQ_CTEST} or @psta{CCS_WIND_CCREP}.
@stindex CCS_WIND_CCREP

@subsubheading New State

If the primitive is issued subsequent to the @prim{CC_SETUP_REQ},
the new state is @psta{CCS_WCON_SREQ}.
@stindex CCS_WCON_SREQ
If the primitive is issued in response to the @prim{CC_CONT_TEST_IND}
primitive, the new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@page
@subsection Collecting Information Phase

The following call control service primitive pertain to the collecting information phase of a call.  During this
phase requests for more information are issued and indicated, and additional information is provided.

@subsubsection Call Control More Information Request

@subsubheading CC_MORE_INFO_REQ
@prindex CC_MORE_INFO_REQ

This message request more information (digits in the called party address, or optional parameters) from the calling
CCS user.  This specifies to the CCS provider that overlap receiving is in effect and the number of digits received
are not sufficient to complete the call.

@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the
@msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_more_info_req {
        ulong cc_primitive;             /* always CC_MORE_INFO_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_more_info_req_t;
@end verbatim
@tpindex struct CC_more_info_req
@tpindex CC_more_info_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference for the @prim{CC_MORE_INFO_REQ} message.  It is used by the CCS provider to associated the
@prim{CC_MORE_INFO_REQ} message with an previous @prim{CC_SETUP_IND} message and identify the incoming call.
@item cc_opt_length
Indicates the length of the optional parameters associated with the nore information request.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (User and Network) mode and for compatibility in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WREQ_MORE}.
@stindex CCS_WREQ_MORE

@subsubheading New State

The new state is @psta{CCS_WIND_INFO}.
@stindex CCS_WIND_INFO

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_INFORMATION_IND} and
@prim{CC_INFO_TIMEOUT_IND}
primitives.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated by the @prim{CC_CALL_FAILURE_IND} primitive with a protocol
specific reason indicating that additional information was not provided within a sufficient period of time.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCNOTSUPP}
The CCS provider does not support the operation.
@item @perr{CCACCESS}
The user did not have proper permissions for the operation.
@item @perr{CCBADPRIM}
The primitive was incorrectly formatted (i.e. the @msg{M_PROTO} message block was too short).
@end table
@end itemize

@page
@subsubsection Call Control More Information Indication

@subsubheading CC_MORE_INFO_IND
@prindex CC_MORE_INFO_IND

This message indicates that the calling CCS user needs to provide additional information (called party address
digits) to complete call processing.  The CCS user should generate @prim{CC_INFORMATION_REQ} primitives, if possible.  This
is also an indication that overlap receiving is in effect.  Appropriate protocol timers will be started.

In contrast to the the @prim{CC_INFORMATION_REQ} primitive(s) which are sent by the CCS user in response to this message,
the @prim{CC_MORE_INFO_IND} message is normally only issued once per call setup.

@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_more_info_ind {
        ulong cc_primitive;             /* always CC_MORE_INFO_IND */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_more_info_ind_t;
@end verbatim
@tpindex struct CC_more_info_ind
@tpindex CC_more_info_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_user_ref
Indicates the user call reference of the @prim{CC_MORE_INFO_IND} message.  It is used by the CCS user to associate the
@prim{CC_MORE_INFO_IND} message with an outstanding @prim{CC_SETUP_REQ} message.
@item cc_opt_length
Indicates the length of the optional parameters associated with the more information indication.  If no optional
parameters are associated with the more information indications, this parameter must be coded zero by the CCS
provider.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (Network and User) mode, and for compatibility in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WIND_MORE}.
@stindex CCS_WIND_MORE

@subsubheading New State

The new state is @psta{CCS_WREQ_INFO}.
@stindex CCS_WREQ_INFO

@subsubsection Call Control Information Request

@subsubheading CC_INFORMATION_REQ
@prindex CC_INFORMATION_REQ

This message request that the CCS provider include the subsequent number information in addition to the called party
number information previously supplied with a @prim{CC_SETUP_REQ} primitive.

@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_information_req {
        ulong cc_primitive;             /* always CC_INFORMATION_REQ */
        ulong cc_user_ref;              /* call reference */
        ulong cc_subn_length;           /* subsequent number length */
        ulong cc_subn_offset;           /* subsequent number offset */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_information_req_t;
@end verbatim
@tpindex struct CC_information_req
@tpindex CC_information_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_user_ref
Specifies the user call reference.  It is used by the CCS user to associate
the message with an outstanding @prim{CC_SETUP_REQ} message.
@item cc_subn_length
Specifies the length of the subsequent called party address parameter that conveys more of an address identifying
the CCS user to which the call is to be established.  This field will accommodate variable length addresses within a
range supported by the CCS provider.  If no subsequent called party address is provided by the CCS user, this field
must be coded to zero.  The coding of the subsequent called party address is protocol and provider-specific.
@item cc_subn_offset
Is the offset of the subsequent called party address from the beginning of the @msg{M_PROTO} message block.
@item cc_opt_length
Specifies the length of the optional parameters associated with the alerting indication.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (both User and Network) and NNI.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WIND_MORE}
@stindex CCS_WIND_MORE
and @psta{CCS_WREQ_INFO}.
@stindex CCS_WREQ_INFO

@subsubheading New State

The new state is @psta{CCS_WIND_MORE}
@stindex CCS_WIND_MORE
if the subsequent number still does not contain complete address information or @psta{CCS_WIND_PROCEED}
@stindex CCS_WIND_PROCEED
if it does.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCNOADDR}
The user did not provide a subsequent called party address field and one was required by the call type.  The CCS
provider could not select a called party address.
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system eror is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The specified call reference was invalid.
@item @perr{CCBADADDR}
The subsequent called party address was in the incorrect format, or contained illegal information.  This is used
only to handle coding errors of the address and is not intended to provide for protocol errors.  Protocol errors
should be conveyed in the @prim{CC_CALL_FAILURE_IND} or @prim{CC_RELEASE_IND} primitives.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@item @perr{CCBADPRIM}
The primitive is of an incorrect format or an offset exceeds the size of the @msg{M_PROTO} block.
@end table
@end itemize

@page
@subsubsection Call Control Information Indication

@subsubheading CC_INFORMATION_IND
@prindex CC_INFORMATION_IND


@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_information_ind {
        ulong cc_primitive;             /* always CC_INFORMATION_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_subn_length;           /* subsequent number length */
        ulong cc_subn_offset;           /* subsequent number offset */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_information_ind_t;
@end verbatim
@tpindex struct CC_information_ind
@tpindex CC_information_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference of the message.  It is used by the CCS provider to associated the message with an
preceding @prim{CC_SETUP_IND} message.
@item cc_subn_length
Indicates the length of the subsequent called party address parameter that conveys more of an address identifying
the CCS user to which the call is to be established.  This field will accommodate variable length addresses within a
range supported by the CCS provider.  If no subsequent called party address is provided by the CCS user, this field
must be coded to zero.  The coding of the subsequent called party address is protocol and provider-specific.
@item cc_subn_offset
Is the offset of the subsequent called party address from the beginning of the @msg{M_PROTO} message block.
@item cc_opt_length
Indicates the length of the optional parameters associated with the alerting indication.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (both User and Network) and NNI.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WREQ_MORE}
@stindex CCS_WREQ_MORE
or @psta{CCS_WIND_INFO}.
@stindex CCS_WIND_INFO

@subsubheading New State

The new state is @psta{CCS_WREQ_MORE}
@stindex CCS_WREQ_MORE
if more information is still pending, or @psta{CCS_WREQ_PROCEED}
@stindex CCS_WREQ_PROCEED
if the information is complete.

@page
@subsubsection Call Control Information Timeout Indication

@subsubheading CC_INFO_TIMEOUT_IND
@prindex CC_INFO_TIMEOUT_IND

This message indicates that a timeout has occurred while waiting for additional digits.  It is up to the CCS user to
decide whether the digits collected are sufficient, in which case the call can proceed; or, to decide that the
digits collected are insufficient and begin tearing down the call with a @prim{CC_DISCONNECT_REQ} or @prim{CC_RELEASE_REQ} with
cause value CC_CAUS_ADDRESS_INCOMPLETE.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_info_timeout_ind {
        ulong cc_primitive;             /* always CC_INFO_TIMEOUT_IND */
        ulong cc_call_ref;              /* call reference */
} CC_info_timeout_ind_t;
@end verbatim
@tpindex struct CC_info_timeout_ind
@tpindex CC_info_timeout_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference of the @prim{CC_SETUP_IND} when the @prim{CC_INFO_TIMEOUT_IND} primitive is used in response to the
@prim{CC_SETUP_IND} on a listening stream.  Otherwise, this parameter is coded zero and is ignored by the CCS provider.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid State

This primitive is valid in state @psta{CCS_WIND_INFO}
@stindex CCS_WIND_INFO
or @psta{CCS_WREQ_INFO}.
@stindex CCS_WREQ_INFO

@subsubheading New State

The new state is unchanged.

@page
@subsection Call Establishment Phase

The following call control service primitives pertain to the establishment of a call.

@subsubsection Call Control Proceeding Request

@subsubheading CC_PROCEEDING_REQ
@prindex CC_PROCEEDING_REQ

This primitive requests that the CCS provider indicate to the calling CCS user that the call is proceeding towards
the called CCS user.  This also means that there is sufficient called party address information to complete the
call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_proceeding_req {
        ulong cc_primitive;             /* always CC_PROCEEDING_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* proceeding flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_proceeding_req_t;
@end verbatim
@tpindex struct CC_proceeding_req
@tpindex CC_proceeding_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference for the request.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Specifies proceeding flags associated with the proceeding request.  Proceeding flags are protocol specific (see the
Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the alerting indication.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid States

This primitive is valid in state CCS_ICC_WAIT_ACM.

@subsubheading New State

The new state is @psta{CCS_WREQ_MORE}
@stindex CCS_WREQ_MORE
or @psta{CCS_WIND_PROCEED}.
@stindex CCS_WIND_PROCEED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADFLAG}
The specified flags were incorrect or unsupported.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@item @perr{CCBADPRIM}
The primitive is of an incorrect format or an offset exceeds the size of the @msg{M_PROTO} block.
@end table
@end itemize

@page
@subsubsection Call Control Proceeding Indication

@subsubheading CC_PROCEEDING_IND
@prindex CC_PROCEEDING_IND

This primitive indicates to the calling CCS user that the call is proceeding to the called CCS user.  This also
means that there is sufficient called party address information to complete the call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_proceeding_ind {
        ulong cc_primitive;             /* always CC_PROCEEDING_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* proceeding flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_proceeding_ind_t;
@end verbatim
@tpindex struct CC_proceeding_ind
@tpindex CC_proceeding_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  It is used by the CCS provider to indicate the call.
@item cc_flags
Indicates the proceeding flags associated with the proceeding indication.  Proceeding flags are protocol specific
(see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the proceeding indication.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WREQ_MORE}
@stindex CCS_WREQ_MORE
or @psta{CCS_WIND_PROCEED}.
@stindex CCS_WIND_PROCEED

@subsubheading New State

The new state is @psta{CCS_WIND_ALERTING}.
@stindex CCS_WIND_ALERTING

@page
@subsubsection Call Control Alerting Request

@subsubheading CC_ALERTING_REQ
@prindex CC_ALERTING_REQ

This primitive requests that the CCS provider indicate to the calling CCS user that the called CCS user is being
alerted.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_alerting_req {
        ulong cc_primitive;             /* always CC_ALERTING_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* alerting flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_alerting_req_t;
@end verbatim
@tpindex struct CC_alerting_req
@tpindex CC_alerting_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  It is used by the CCS provider to identify the call.
@item cc_flags
Specifies the alerting flags associated with the alerting request.  Alerting flags are protocol specific (see
Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the alerting indication.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid States

This primiitve is valid in states @psta{CCS_WREQ_MORE},
@stindex CCS_WREQ_MORE
@psta{CCS_WREQ_PROCEED}
@stindex CCS_WREQ_PROCEED
and @psta{CCS_WREQ_ALERTING}
@stindex CCS_WREQ_ALERTING
states.

@subsubheading New State

The new state is @psta{CCS_WREQ_PROGRESS}.
@stindex CCS_WREQ_PROGRESS

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADFLAG}
The specified flags contained incorrect or unsupported information.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@item @perr{CCBADPRIM}
The primitive is of an incorrect format or an offset exceeds the size of the @msg{M_PROTO} block.
@end table
@end itemize

@page
@subsubsection Call Control Alerting Indication

@subsubheading CC_ALERTING_IND
@prindex CC_ALERTING_IND

This primitive indicates to the calling CCS user that the called CCS user is being alerted.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_alerting_ind {
        ulong cc_primitive;             /* always CC_ALERTING_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* alerting flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_alerting_ind_t;
@end verbatim
@tpindex struct CC_alerting_ind
@tpindex CC_alerting_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Indicates the alerting flags.
@item cc_opt_length
Indicates the length of the optional parameters associated with the alerting indication.  If no optional parameters
are associated with the alerting indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid States

This primitive is valid in states @psta{CCS_WREQ_MORE},
@stindex CCS_WREQ_MORE
@psta{CCS_WIND_PROCEED}
@stindex CCS_WIND_PROCEED
and @psta{CCS_WIND_ALERTING}.
@stindex CCS_WIND_ALERTING

@subsubheading New State

The new state is @psta{CCS_WIND_PROGRESS}.
@stindex CCS_WIND_PROGRESS

@page
@subsubsection Call Control Progress Request

@subsubheading CC_PROGRESS_REQ
@prindex CC_PROGRESS_REQ

This primitive requests that the CCS provider indicate to the calling CCS user that the call is progressing towards
the called CCS user, with the specified event.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_progress_req {
        ulong cc_primitive;             /* always CC_PROGRESS_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_event;                 /* progress event */
        ulong cc_flags;                 /* progress flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_progress_req_t;
@end verbatim
@tpindex struct CC_progress_req
@tpindex CC_progress_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_event
Specifies the progress event.  Progress events are protocol specific (see Addendum).
@item cc_flags
Indicates progress flags. Progress flags are protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the progress request.  If no optional parameters are
associated with the progress request, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid States

This primitive is valid in states @psta{CCS_WREQ_PROGRESS}.
@stindex CCS_WREQ_PROGRESS

@subsubheading New State

The new state is @psta{CCS_WREQ_PROGRESS}.
@stindex CCS_WREQ_PROGRESS

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADFLAG}
The specified flags contained incorrect or unsupported information.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@item @perr{CCBADPRIM}
The primitive is of an incorrect format or an offset exceeds the size of the @msg{M_PROTO} block.
@end table
@end itemize

@page
@subsubsection Call Control Progress Indication

@subsubheading CC_PROGRESS_IND
@prindex CC_PROGRESS_IND

This primitive indicates to the calling CCS user that the call is progressing towards the called CCS user with the
specified progress event.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_progress_ind {
        ulong cc_primitive;             /* always CC_PROGRESS_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_event;                 /* progress event */
        ulong cc_flags;                 /* progress flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_progress_ind_t;
@end verbatim
@tpindex struct CC_progress_ind
@tpindex CC_progress_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_event
Indicates the progress event.  Progress events are protocol specific (see Addendum).
@item cc_flags
Indicates progress flags.  Progress flags are protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the progress request.  If no optional parameters are
associated with the progress request, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (User or Network) or NNI mode.

@subsubheading Valid States

This primitive is valid instates @psta{CCS_WIND_PROGRESS}.
@stindex CCS_WIND_PROGRESS

@subsubheading New State

The new state is @psta{CCS_WIND_PROGRESS}.
@stindex CCS_WIND_PROGRESS

@page
@subsubsection Call Control In-Band Information Request

@subsubheading CC_IBI_REQ
@prindex CC_IBI_REQ

This primitive request that the CCS provider indicate to the calling CCS user that the in-band information is now
available.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_ibi_req {
        ulong cc_primitive;             /* always CC_IBI_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* ibi flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_ibi_req_t;
@end verbatim
@tpindex struct CC_ibi_req
@tpindex CC_ibi_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Specifies the flags associated with the primitive.  In band information flags are protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the in-band information request.  If no optional
parameters are associated with the in band information request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in NNI mode and in UNI (User and Network) mode for compatibility with the NNI.

@subsubheading Valid States

This primitive is valid in states @psta{CCS_WREQ_MORE},
@stindex CCS_WREQ_MORE
@psta{CCS_WREQ_PROCEED},
@stindex CCS_WREQ_PROCEED
@psta{CCS_WREQ_ALERTING},
@stindex CCS_WREQ_ALERTING
@psta{CCS_WREQ_PROGRESS}
@stindex CCS_WREQ_PROGRESS
and @psta{CCS_WREQ_CONNECT}.
@stindex CCS_WREQ_CONNECT

@subsubheading New State

The new state is @psta{CCS_WREQ_CONNECT}.
@stindex CCS_WREQ_CONNECT

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADFLAG}
The specified flags contained incorrect or unsupported information.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@item @perr{CCBADPRIM}
The primitive is of an incorrect format or an offset exceeds the size of the @msg{M_PROTO} block.
@end table
@end itemize

@page
@subsubsection Call Control In-Band Information Indication

@subsubheading CC_IBI_IND
@prindex CC_IBI_IND

This primitive indicates to the calling CCS user that there is in-band information now available in the voice
channel.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_ibi_ind {
        ulong cc_primitive;             /* always CC_IBI_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* ibi flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_ibi_ind_t;
@end verbatim
@tpindex struct CC_ibi_ind
@tpindex CC_ibi_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Indicates the flags associated with the primitive.  In band information flags are provider and protocol specific
(see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the in-band information indication.  If no optional
parameters are associated with the in band information request, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in NNI mode and in UNI (User and Network) mode for compatibility with the NNI.

@subsubheading Valid States

This primitive is valid in states @psta{CCS_WIND_MORE},
@stindex CCS_WIND_MORE
@psta{CCS_WIND_PROCEED},
@stindex CCS_WIND_PROCEED
@psta{CCS_WIND_ALERTING}
@stindex CCS_WIND_ALERTING
and @psta{CCS_WIND_PROGRESS}.
@stindex CCS_WIND_PROGRESS

@subsubheading New State

The new state is @psta{CCS_WIND_CONNECT}.
@stindex CCS_WIND_CONNECT

@page
@subsubsection Call Control Connect Request

@subsubheading CC_CONNECT_REQ
@prindex CC_CONNECT_REQ

This primitive requests that the CCS provide indicate to the remote CCS user that the call control setup has
complete and the called CCS use is connected on the call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_connect_req {
        ulong cc_primitive;             /* always CC_CONNECT_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* connect flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_connect_req_t;
@end verbatim
@tpindex struct CC_connect_req
@tpindex CC_connect_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.  The call
reference is the same value which was indicated in the corresponding @prim{CC_SETUP_IND} primitive for the incoming call.
@item cc_flags
Specifies the connect flags associated with the primitive.  Connect flags are protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the connect request.  If no optional parameters are
associated with the connect request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in NNI mode and in UNI (User) mode.

@subsubheading Valid States

This primitive is only valid for incoming calls in the @psta{CCS_WREQ_MORE},
@stindex CCS_WREQ_MORE
@psta{CCS_WREQ_PROCEED},
@stindex CCS_WREQ_PROCEED
@psta{CCS_WREQ_ALERTING},
@stindex CCS_WREQ_ALERTING
@psta{CCS_WREQ_PROGRESS},
@stindex CCS_WREQ_PROGRESS
@psta{CCS_WREQ_CONNECT}
@stindex CCS_WREQ_CONNECT
states.


@subsubheading New State

The new state is CCS_WIND_SCOMP (waiting for indication of setup complete).

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_SETUP_COMPLETE_IND} primitive.
@item
@emph{Unsuccessful}:  Unsuccessful completion is indicated via the @prim{CC_CALL_FAILURE_IND},
@prim{CC_DISCONNECT_IND} or
@prim{CC_RELEASE_IND} primitives.
@item
@emph{Non-fatal errors}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADFLAG}
The specified flags contained incorrect or unsupported information.
@item @perr{CCBADOPT}
The optional parameters were in an incorrect format, or contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions for the use of the requested address or options.
@item @perr{CCBADPRIM}
The primitive is of an incorrect format or an offset exceeds the size of the @msg{M_PROTO} block.
@end table
@end itemize

@page
@subsubsection Call Control Connect Indication

@subsubheading CC_CONNECT_IND
@prindex CC_CONNECT_IND

This primitive indicates that the called CCS user has connected to the call.  Upon receving this primitive the CCS
user operating in UNI (Network) mode should connect the calling CCS user to the call and acknowledge connection of
the calling CCS user by responding with the @prim{CC_SETUP_COMPLETE_REQ} primitive.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_connect_ind {
        ulong cc_primitive;             /* always CC_CONNECT_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* connect flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_connect_ind_t;
@end verbatim
@tpindex struct CC_connect_ind
@tpindex CC_connect_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.  The call
reference is the same value which was indicated in the corresponding @prim{CC_SETUP_CON} primitive for the outgoing call.
@item cc_flags
Indicates the connect flags associated with the primitive.  Connect flags are protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the connect indication.  If no optional parameters
are associated with the connect indication, then this parameter is coded zero by the CCS provider.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in NNI mode and in UNI (Network) mode.

@subsubheading Valid States

This primitive is valid in state CCS_WIND_SCOMP.

@subsubheading New State

The new state is @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@page
@subsubsection Call Control Setup Complete Request

@subsubheading CC_SETUP_COMPLETE_REQ
@prindex CC_SETUP_COMPLETE_REQ

This primitive request that the CCS provider indicate to the remote CCS user that the call control setup has
completed (the calling CCS user is connected) by the requesting CCS user.  It is used in response to the
@prim{CC_CONNECT_IND} primitive.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_setup_complete_req {
        ulong cc_primitive;             /* always CC_SETUP_COMPLETE_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_setup_complete_req_t;
@end verbatim
@tpindex struct CC_setup_complete_req
@tpindex CC_setup_complete_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Specifies the length of the optional parameters associated with the setup complete request.  If no optional
parameters are associated with the setup complete request, then this parameter must be coded zero.  The CCS provider
may include additional protocol-specific optional parameters.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI mode (Network only) and NNI mode for compatibility.

@subsubheading Valid States

This primitive is valid in state CCS_WREQ_SCOMP.

For compatibility between NNI mode and UNI Network mode, the CCS provider in NNI mode should acknowledge this
primitive with a @prim{CC_OK_ACK}
if it is issued in the @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
state.

@subsubheading New State

The new state is @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out of range).
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Setup Complete Indication

@subsubheading CC_SETUP_COMPLETE_IND
@prindex CC_SETUP_COMPLETE_IND

This primitive indicates to the called CCS user, operating in UNI (User) mode, that the call control setup was
completed (the call is answered and connected) by the calling CCS user.  In UNI (User) mode, the CCS user may defer
connecting the receive path to the called CCS user until this message is received.  In response to this primitive,
the CCS user should connect the receive path to the called CCS user and consider the call connected.

CCS users operating in UNI (Network) mode or NNI mode should ignore this primitive if issued by the CCS provider.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_setup_complete_ind {
        ulong cc_primitive;             /* always CC_SETUP_COMPLETE_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_setup_complete_ind_t;
@end verbatim
@tpindex struct CC_setup_complete_ind
@tpindex CC_setup_complete_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitives type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Indicates the length of the optional parameters associated with the setup complete indication.  If no optional
parameters were associated with the setup complete indication, then this parameter must be coded zero.  The CCS
provider may include additional optional protocol-specific optional parameters.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (User only) mode.

@subsubheading Valid States

This primitive is valid in states CCS_WIND_SCOMP and @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@subsubheading New State

The new state is @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@page
@subsection Call Established Phase

The following call control service primitives pertain to the Established phase of a call.

@subsubsection Forward Transfer Request

@subsubheading CC_FORWXFER_REQ

This message requests that the CCS provider forward transfer an established call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_forwxfer_req {
        ulong cc_primitive;             /* always CC_FORWXFER_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_forwxfer_req_t;
@end verbatim
@tpindex struct CC_forwxfer_req
@tpindex CC_forwxfer_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Specifies the length of the optional parameters associated with the forward transfer request.  If no optional
parameters were associated with the forward transfer request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes
This primitive is only valid in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@subsubheading New State

The new state is @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Forward Transfer Indication

@subsubheading CC_FORWXFER_IND
@prindex CC_FORWXFER_IND

This primitive indicates to the CCS user that the peer CCS user has requested a forward transfer of an established
call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_forwxfer_ind {
        ulong cc_primitive;             /* always CC_FORWXFER_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_forwxfer_ind_t;
@end verbatim
@tpindex struct CC_forwxfer_ind
@tpindex CC_forwxfer_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Specifies the length of the optional parameters associated with the forward transfer indication.  If no optional
parameters were associated with the forward transfer indication, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in NNI mode only.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@subsubheading New State

The new state is @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@page
@subsubsection Call Control Suspend Request

@subsubheading CC_SUSPEND_REQ
@prindex CC_SUSPEND_REQ

This message requests that the CCS provider suspend an established call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_suspend_req {
        ulong cc_primitive;             /* always CC_SUSPEND_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* suspend flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_suspend_req_t;
@end verbatim
@tpindex struct CC_suspend_req
@tpindex CC_suspend_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Specifies the suspend flags associated with the suspend request.  Suspend flags specify whether the request is for a
user suspend or a network suspend.  Suspend flags are provider and protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the suspend request.  If no optional parameters were
associated with the suspend request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (User) and NNI.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_CONNECTED}.
@stindex CCS_CONNECTED

@subsubheading New State

The new state is @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_SUSPEND_CON} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_SUSPEND_REJECT_IND} or
@prim{CC_RELEASE_IND}
primitive.  The cause value in the @prim{CC_SUSPEND_REJECT_IND} or @prim{CC_RELEASE_IND} primitive indicates the cause of failure.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Call Control Suspend Indication

@subsubheading CC_SUSPEND_IND
@prindex CC_SUSPEND_IND

This message indicates to the CCS user that the peer CCS user has requested the suspension of an establisehd call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_suspend_ind {
        ulong cc_primitive;             /* always CC_SUSPEND_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* suspend flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_suspend_ind_t;
@end verbatim
@tpindex struct CC_suspend_ind
@tpindex CC_suspend_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Indicates the options associated with the suspend.  Suspend flags are mode and protocol dependent, see the addendum.
Indicates the suspend flags associated with the suspend indication.  Suspend flags indicate whether the request is
for a user suspend or a network suspend.  Suspend flags are provider and protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the suspend indication.  If no optional parameters
were associated with the suspend indication, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (Network) and NNI.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
or @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading New State

The new state is CCS_WRES_SUSIND for UNI and @psta{CCS_SUSPENDED} for NNI.
@stindex CCS_SUSPENDED

@page
@subsubsection Call Control Suspend Response

@subsubheading CC_SUSPEND_RES
@prindex CC_SUSPEND_RES

This message requests that the CCS provider accept a previous suspend indication.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_suspend_res {
        ulong cc_primitive;             /* always CC_SUSPEND_RES */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_suspend_res_t;
@end verbatim
@tpindex struct CC_suspend_res
@tpindex CC_suspend_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Specifies the length of the optional parameters associated with the suspend response.  If no optional parameters
were associated with the suspend response, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (Network).

@subsubheading Valid States

This primitive is valid in state CCS_WRES_SUSIND.

@subsubheading New State

The new state is @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Call Control Suspend Confirmation

@subsubheading CC_SUSPEND_CON
@prindex CC_SUSPEND_CON

This message indicates to the CCS user that the CCS provider has confirmed the CCS user request to suspend an
established call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_suspend_con {
        ulong cc_primitive;             /* always CC_SUSPEND_CON */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_suspend_con_t;
@end verbatim
@tpindex struct CC_suspend_con
@tpindex CC_suspend_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Indicates the length of the optional parameters associated with the suspend indication.  If no optional parameters
were associated with the suspend indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (User).

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_SUSREQ}.
@stindex CCS_WCON_SUSREQ.

@subsubheading New State

The new state is @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@page
@subsubsection Call Control Suspend Reject Request

@subsubheading CC_SUSPEND_REJECT_REQ
@prindex CC_SUSPEND_REJECT_REQ

This message request that the CCS provider reject a previous suspend indication with the specified cause.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_suspend_reject_req {
        ulong cc_primitive;             /* always CC_SUSPEND_REJECT_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_suspend_reject_req_t;
@end verbatim
@tpindex struct CC_suspend_reject_req
@tpindex CC_suspend_reject_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS user to identify the call.  Its value should be
the same as the value returned by the CCS provider in the @prim{CC_SETUP_IND} or @prim{CC_SETUP_CON} primitive.
@item cc_cause
Indicates the cause for the rejection.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the suspend reject request.  If no optional
parameters are associated with the suspend reject request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameter are associated with the suspend reject request, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (Network).

@subsubheading Valid States

This primitive is valid in state CCS_WRES_SUSIND.

@subsubheading New State

The new state is @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
if the call is not still suspended in the opposite direction or another sense (network or user), otherwise the new state
remains @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Suspend Reject Confirmation

@subsubheading CC_SUSPEND_REJECT_IND
@prindex CC_SUSPEND_REJECT_IND

This message indicates to the requesting CCS user that a previous suspend request for an established call was
rejected and the cause for rejection.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_suspend_reject_ind {
        ulong cc_primitive;             /* always CC_SUSPEND_REJECT_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_suspend_reject_ind_t;
@end verbatim
@tpindex struct CC_suspend_reject_ind
@tpindex CC_suspend_reject_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_cause
Indicates the cause for the rejection.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the suspend reject indication.  If no optional
parameters are associated with the suspend reject indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameter are associated with the suspend reject indication, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (User).

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_SUSREQ}.
@stindex CCS_WCON_SUSREQ.

@subsubheading New State

The new state is @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
if the call is not still suspended in the opposite direction or another sense (network or user), otherwise the new state
remains @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@page
@subsubsection Call Control Resume Request

@subsubheading CC_RESUME_REQ
@prindex CC_RESUME_REQ

This message requests that the CCS provider resume a previously suspended call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_resume_req {
        ulong cc_primitive;             /* always CC_RESUME_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* suspend flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_resume_req_t;
@end verbatim
@tpindex struct CC_resume_req
@tpindex CC_resume_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS user to identify the call to the CCS provider.
The value should be the same as the value indicated by the CCS provider in a previous @prim{CC_SETUP_IND} or @prim{CC_SETUP_CON}
primitive.
@item cc_flags
Specifies the options associated with the resume.  Resume flags are provider and protocol dependent (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the resume request.  If no optional parameters are
associated with the resume request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameter are associated with the resume request, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (User) and NNI.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading New State

The new state is @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
if the call is not still suspended in the opposite direction or another sense (network or user), otherwise the new state
remains @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Resume Indication

@subsubheading CC_RESUME_IND
@prindex CC_RESUME_IND

This message indicates to the CCS user that the peer CCS user has requested that a previously suspended call be
resumed.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_resume_ind {
        ulong cc_primitive;             /* always CC_RESUME_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_flags;                 /* suspend flags */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_resume_ind_t;
@end verbatim
@tpindex struct CC_resume_ind
@tpindex CC_resume_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_flags
Indicates the options associated with the resume.  Resume flags are mode and protocol dependent, see the addendum.
@item cc_opt_length
Indicates the length of the optional parameters associated with the resume indication.  If no optional parameters
are associated with the resume indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameter are associated with the resume indication, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (Network) and NNI.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading New State

The new state is @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
if the call is not still suspended in the opposite direction or in another sense (network or user), otherwise the new
state remains @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@page
@subsubsection Call Control Resume Response

@subsubheading CC_RESUME_RES
@prindex CC_RESUME_RES

This message requests that the CCS provider accept a previous request to resume a suspended call.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_resume_res {
        ulong cc_primitive;             /* always CC_RESUME_RES */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_resume_res_t;
@end verbatim
@tpindex struct CC_resume_res
@tpindex CC_resume_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS user to identify the call to the CCS provider.
Its value should be the same as the value indicated by a previous @prim{CC_SETUP_IND} or @prim{CC_SETUP_CON} primitive for the
call.
@item cc_opt_length
Specifies the length of the optional parameters associated with the resume response.  If no optional parameters are
associated with the resume response, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameter are associated with the resume response, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (Network) and for compatibility in NNI mode.

@subsubheading Valid States

This primitive is valid in state CCS_WRES_SUSIND.

@emph{For compatibility with UNI, NNI should ignore, yet positively acknowledge, this primitive if received in the
@psta{CCS_CONNECTED}}
@stindex CCS_CONNECTED
@emph{or @psta{CCS_SUSPENDED}}
@stindex CCS_SUSPENDED
@emph{states where the all is not suspended in the sense confirmed.}

@subsubheading New State

The new state is @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
if the call is not still suspended in the opposite direction or another sense (network or user), otherwise the new state
remains @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Resume Confirmation

@subsubheading CC_RESUME_CON
@prindex CC_RESUME_CON

This message indicates to the requesting CCS user that a previous request to resume a suspended call has been
confirmed.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_resume_con {
        ulong cc_primitive;             /* always CC_RESUME_CON */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_resume_con_t;
@end verbatim
@tpindex struct CC_resume_con
@tpindex CC_resume_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_opt_length
Indicates the length of the optional parameters associated with the resume confirmation.  If no optional parameters
are associated with the resume confirmation, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameter are associated with the resume confirmation, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (User).

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_SUSREQ}.
@stindex CCS_WCON_SUSREQ.

@subsubheading New State

The new state is @psta{CCS_CONNECTED}
@stindex CCS_CONNECTED
if the call is not still suspended in the opposite direction or another sense (network or user), otherwise the new state
remains @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@page
@subsubsection Call Control Resume Reject Request

@subsubheading CC_RESUME_REJECT_REQ
@prindex CC_RESUME_REJECT_REQ

This message requests that the CCS provider reject a previous requst to resume a suspended call with the specified
cause.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_resume_reject_req {
        ulong cc_primitive;             /* always CC_RESUME_REJECT_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_resume_reject_req_t;
@end verbatim
@tpindex struct CC_resume_reject_req
@tpindex CC_resume_reject_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference.  The call reference is used by the CCS user to identify the call to the CCS provider.
Its value should be the same as the value indicated in a previous @prim{CC_SETUP_IND} or @prim{CC_SETUP_CON} primitive by the CCS
provider for the call.
@item cc_cause
Indicates the cause for the rejection.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the resume reject request.  If no optional
parameters are associated with the resume reject request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameters are associated with the resume reject request, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (Network).

@subsubheading Valid States

This primitive is valid in state CCS_WRES_SUSIND.

@subsubheading New State

The new state is @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Resume Reject Indication

@subsubheading CC_RESUME_REJECT_IND
@prindex CC_RESUME_REJECT_IND

This message indicates to the requesting CCS user that a previous request to resume a suspended call has been
rejected and the cause for rejection.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_resume_reject_ind {
        ulong cc_primitive;             /* always CC_RESUME_REJECT_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_resume_reject_ind_t;
@end verbatim
@tpindex struct CC_resume_reject_ind
@tpindex CC_resume_reject_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_cause
Indicates the cause for the rejection.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the resume reject indication.  If no optional
parameters are associated with the resume reject indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameters are associated with the resume reject indication, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in mode UNI (User).

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_SUSREQ}.
@stindex CCS_WCON_SUSREQ.

@subsubheading New State

The new state is @psta{CCS_SUSPENDED}.
@stindex CCS_SUSPENDED

@page
@subsection Call Termination Phase

The following call control service primitives pertain to the Termination phase of a call.

@subsubsection Call Control Reject Request

@subsubheading CC_REJECT_REQ
@prindex CC_REJECT_REQ

This message is used to reject a call before any request for more information, or request for indication of
proceeding, alerting, progress, or in-band information has been attempted.  The message also includes the cause of
the rejection.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_reject_req {
        ulong cc_primitive;             /* always CC_REJECT_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_reject_req_t;
@end verbatim
@tpindex struct CC_reject_req
@tpindex CC_reject_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_call_ref
Specifies the call reference of the @prim{CC_SETUP_IND} when the @prim{CC_REJECT_REQ} primitive is used in response to the
@prim{CC_SETUP_IND} on a listening stream.  Otherwise, this parameter is coded zero and is ignored by the CCS provider.
@item cc_cause
Specifies the cause for the rejection.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Specifies the length of the optional parameters associated with the reject request.  If no optional parameters are
associated with the reject request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameters are associated with the reject request, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is only valid in the UNI mode (User or Network).  (NNI users should use the @prim{CC_RELEASE_REQ} primitive
in the same situation.)

@subsubheading Valid State

This primitive is valid in state @psta{CCS_WRES_SIND}.
@stindex CCS_WRES_SIND

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Reject Indication

@subsubheading CC_REJECT_IND
@prindex CC_REJECT_IND

This message indicates to the CCS user that a previous setup request has been rejected by the peer CCS user and
indicates the cause of the rejection.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_reject_ind {
        ulong cc_primitive;             /* always CC_REJECT_IND */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_reject_ind_t;
@end verbatim
@tpindex struct CC_reject_ind
@tpindex CC_reject_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_user_ref
Indicates the CCS user reference of the associated @prim{CC_SETUP_REQ} primitive that was rejected.
@item cc_cause
Indicates the cause for the rejection.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the reject indication.  If no optional parameters
are associated with the reject indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameters are associated with the reject indication, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is only valid in the UNI mode (User or Network).

@subsubheading Valid State

This primitive is valid in state @psta{CCS_WCON_SREQ}.
@stindex CCS_WCON_SREQ

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@page
@subsubsection Call Control Call Failure Indication

@subsubheading CC_CALL_FAILURE_IND
@prindex CC_CALL_FAILURE_IND

This primitive indicates to the CCS user that the call on the selected address (circuit, circuit group) has failed.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_call_failure_ind {
        ulong cc_primitive;             /* always CC_CALL_FAILURE_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_reason;                /* reason for failure */
        ulong cc_cause;                 /* cause to use in release */
} CC_call_failure_ind_t;
@end verbatim
@tpindex struct CC_call_failure_ind
@tpindex CC_call_failure_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_reason
Indicates the reason for the failure.  Reasons are provider and protocol specific (see Addendum).
@item cc_cause
Indicates the cause value for the failure.  Cause values are provider and protocol specific (see Addendum).
@item cc_opt_length
Indicates the length of the optional parameters associated with the call failure indication.  If no optional
parameters are associated with the call failure indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.  If no optional
parameters are associated with the call failure indication, then this parameter must be coded zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid in NNI mode only.

@subsubheading Valid States

This primitive is valid in any state other than @psta{CCS_IDLE},
@stindex CCS_IDLE
@psta{CCS_WIND_MORE},
@stindex CCS_WIND_MORE
@psta{CCS_WREQ_INFO},
@stindex CCS_WREQ_INFO
@psta{CCS_WCON_SREQ},
@stindex CCS_WCON_SREQ
and @psta{CCS_WIND_PROCEED}.
@stindex CCS_WIND_PROCEED
In the aforementioned states (other than @psta{CCS_IDLE}),
@stindex CCS_IDLE
a @prim{CC_CALL_REATTEMPT_IND}
should be issued instead.

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@page
@subsubsection Call Control Disconnect Request

@subsubheading CC_DISCONNECT_REQ
@prindex CC_DISCONNECT_REQ

This primitive request that the CCS provider indicate to the calling CCS user that in-band information may now be
available in the voice channel reflecting the specified cause.  The @prim{CC_DISCONNECT_REQ} primitive is an invitation to
the remote CCS user to release the call channel.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_disconnect_req {
        ulong cc_primitive;             /* always CC_DISCONNECT_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_disconnect_req_t;
@end verbatim
@tpindex struct CC_disconnect_req
@tpindex CC_disconnect_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference of the @prim{CC_DISCONNECT_REQ} message.  It is used by the CCS provider to associated the
@prim{CC_DISCONNECT_REQ} message with an outstanding @prim{CC_SETUP_IND} message.  An invalid call reference should result in
error with the error type @perr{CCBADCLR}.
@item cc_cause
Indicates the cause value for the disconnect.
@item cc_opt_length
Indicates the length of the optional parameters associated with the disconnect request.  If no optional parameters
are associated with the disconnect request, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in UNI (Network or User) mode.

@subsubheading Valid States

This primitive is valid in states @psta{CCS_WREQ_MORE},
@stindex CCS_WREQ_MORE
@psta{CCS_WREQ_PROCEED},
@stindex CCS_WREQ_PROCEED
@psta{CCS_WREQ_ALERTING}
@stindex CCS_WREQ_ALERTING
and @psta{CCS_WREQ_PROGRESS}.
@stindex CCS_WREQ_PROGRESS

@subsubheading New State

The new state is @psta{CCS_WREQ_CONNECT}.
@stindex CCS_WREQ_CONNECT

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Disconnect Indication

@subsubheading CC_DISCONNECT_IND
@prindex CC_DISCONNECT_IND

This primitive indicates to the calling CCS user that there is in-band information now available in the voice
channel.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_disconnect_ind {
        ulong cc_primitive;             /* always CC_DISCONNECT_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_disconnect_ind_t;
@end verbatim
@tpindex struct CC_disconnect_ind
@tpindex CC_disconnect_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_cause
Indicates the cause value for the disconnect.
@item cc_opt_length
Indicates the length of the optional parameters associated with the in-band information request.  If no optional
parameters are associated with the in band information request, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid States

This primitive is valid in states @psta{CCS_WIND_MORE},
@stindex CCS_WIND_MORE
@psta{CCS_WREQ_INFO},
@stindex CCS_WREQ_INFO
@psta{CCS_WIND_PROCEED},
@stindex CCS_WIND_PROCEED
@psta{CCS_WIND_ALERTING},
@stindex CCS_WIND_ALERTING
@psta{CCS_WIND_PROGRESS}
@stindex CCS_WIND_PROGRESS
and @psta{CCS_WIND_CONNECT}.
@stindex CCS_WIND_CONNECT

@subsubheading New State

The new state is @psta{CCS_WIND_CONNECT}
@stindex CCS_WIND_CONNECT

@page
@subsubsection Call Control Release Request

@subsubheading CC_RELEASE_REQ
@prindex CC_RELEASE_REQ

This primitive request that the CCS provider release the call and provide the specified cause value to the remote
CCS user.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_release_req {
        ulong cc_primitive;             /* always CC_RELEASE_REQ */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_release_req_t;
@end verbatim
@tpindex struct CC_release_req
@tpindex CC_release_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_user_ref
Specifies the user call reference of the @prim{CC_SETUP_REQ} when the @prim{CC_RELEASE_REQ} primitive is used in response to the
@prim{CC_SETUP_REQ} and before a @prim{CC_SETUP_CON} is issued.  Otherwise, this parameter is coded zero and is ignored by the CCS
provider.
@item cc_call_ref
Specifies the call reference of the @prim{CC_SETUP_IND} when the @prim{CC_RELEASE_REQ} primitive is used in response to the
@prim{CC_SETUP_IND} on a listening stream.  Otherwise, this parameter is coded zero and is ignored by the CCS provider.
@item cc_cause
Specifies the cause of the release.  Cause values are CCS provider and protocol specific.  See the addendum for
protocol specific values.
@item cc_opt_length
Specifies the length of the optional parameters associated with the release request.  If no optional parameters are
associated with the release request, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (User or Network) and NNI modes.

@subsubheading Valid States

This primitive is valid from any call state other than @psta{CCS_IDLE}
@stindex CCS_IDLE
and @psta{CCS_WCON_RELREQ}.
@stindex CCS_WCON_RELREQ


@subsubheading New State

If the current state is @psta{CCS_WRES_RELIND},
@stindex CCS_WRES_RELIND
the new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE
If the current state is other than @psta{CCS_WRES_RELIND},
@stindex CCS_WRES_RELIND
the new state is @psta{CCS_WCON_RELREQ}.
@stindex CCS_WCON_RELREQ

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_RELEASE_IND} or
@prim{CC_RELEASE_CON} primitives.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCBADPRIM}
The primitive was of an incorrect format (i.e. too small, or an offset it out
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADOPT}
The options values as specified in the primitive were in an incorrect format, or they contained illegal information.
@item @perr{CCACCESS}
The user did not have proper permissions to request the operation or to use the options specified.
@item @perr{CCNOTSUPP}
The specified primitive type is not known to or not supported by the CCS provider.
@end table
@end itemize

@page
@subsubsection Call Control Release Indication

@subsubheading CC_RELEASE_IND
@prindex CC_RELEASE_IND

This primitive indicates that the remote CCS user or CCS provider hsa released the call with the specified cause
value.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_release_ind {
        ulong cc_primitive;             /* always CC_RELEASE_IND */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_cause;                 /* cause value */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_release_ind_t;
@end verbatim
@tpindex struct CC_release_ind
@tpindex CC_release_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_user_ref
Indicates the user call reference of the @prim{CC_SETUP_REQ} when the @prim{CC_RELEASE_IND} primitive is used in response to the
@prim{CC_SETUP_REQ} and before a @prim{CC_SETUP_CON} is issued.  Otherwise, this parameter is coded zero and is ignored by the CCS
provider.
@item cc_call_ref
Indicates the call reference of the @prim{CC_SETUP_IND} when the @prim{CC_RELEASE_IND} primitive is used in response to the
@prim{CC_SETUP_IND} on a listening stream.  Otherwise, this parameter is coded zero and is ignored by the CCS provider.
@item cc_cause
Indicates the cause of the release.  Cause values are CCS provider and protocol specific.  See the addendum for
protocol specific values.
@item cc_opt_length
Indicates the length of the optional parameters associated with the release indication.  If no optional parameters
are associated with the release indication, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (User or Network) and NNI modes.

@subsubheading Valid States

This primitive is valid in any setup or established call state other than @psta{CCS_IDLE}
@stindex CCS_IDLE
and @psta{CCS_WRES_RELIND}.
@stindex CCS_WRES_RELIND

@subsubheading New State

If the current state is @psta{CCS_WCON_RELREQ},
@stindex CCS_WCON_RELREQ
the new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE
If the current state is other than @psta{CCS_WCON_RELREQ},
@stindex CCS_WCON_RELREQ
then new state is @psta{CCS_WRES_RELIND}.
@stindex CCS_WRES_RELIND

@page
@subsubsection Call Control Release Response

@subsubheading CC_RELEASE_RES
@prindex CC_RELEASE_RES

This primitive indicates to the CCS provider that the release of the associated circuit is complete.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_release_res {
        ulong cc_primitive;             /* always CC_RELEASE_RES */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_release_res_t;
@end verbatim
@tpindex struct CC_release_res
@tpindex CC_release_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_user_ref
Specifies the user call reference of the @prim{CC_SETUP_REQ} when the @prim{CC_RELEASE_REQ} primitive is used in response to the
@prim{CC_SETUP_REQ} and before a @prim{CC_SETUP_CON} is issued.  Otherwise, this parameter is coded zero and is ignored by the CCS
provider.
@item cc_call_ref
Specifies the call reference of the @prim{CC_SETUP_IND} when the @prim{CC_RELEASE_REQ} primitive is used in response to the
@prim{CC_SETUP_IND} on a listening stream.  Otherwise, this parameter is coded zero and is ignored by the CCS provider.
@item cc_opt_length
Specifies the length of the optional parameters associated with the release response.  If no optional parameters are
associated with the release response, then this parameter must be coded zero.
@item cc_opt_offset
Specifies the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (User or Network) and NNI modes.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WRES_RELIND}.
@stindex CCS_WRES_RELIND

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Call Control Release Confirmation

@subsubheading CC_RELEASE_CON
@prindex CC_RELEASE_CON

This primitive indicates to the releasing CCS user that the release of the associated circuit is complete.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_release_con {
        ulong cc_primitive;             /* always CC_RELEASE_CON */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_opt_length;            /* optional parameter length */
        ulong cc_opt_offset;            /* optional parameter offset */
} CC_release_con_t;
@end verbatim
@tpindex struct CC_release_con
@tpindex CC_release_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_user_ref
Indicates the user call reference of the @prim{CC_SETUP_REQ} when the @prim{CC_RELEASE_IND} primitive is used in response to the
@prim{CC_SETUP_REQ} and before a @prim{CC_SETUP_CON} is issued.  Otherwise, this parameter is coded zero and is ignored by the CCS
provider.
@item cc_call_ref
Indicates the call reference of the @prim{CC_SETUP_IND} when the @prim{CC_RELEASE_IND} primitive is used in response to the
@prim{CC_SETUP_IND} on a listening stream.  Otherwise, this parameter is coded zero and is ignored by the CCS provider.
@item cc_opt_length
Indicates the length of the optional parameters associated with the release confirmation.  If no optional parameters
are associated with the release confirmation, then this parameter must be coded zero.
@item cc_opt_offset
Indicates the offset of the optional parameters from the start of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (User or Network) and NNI modes.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_RELREQ}.
@stindex CCS_WCON_RELREQ

@subsubheading New State

The new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@page
@section Management Primitive Formats and Rules

This section describes the format of the UNI (Network and User) and NNI management primitives and rules associated
with these primitives.

@subsection Interface Management Primitives

@subsubsection Interface Management Restart Request

@subsubheading CC_RESTART_REQ
@prindex CC_RESTART_REQ

This primitive request the CCS provider to restart all the call control addresses (signalling interface and
channels) for the specified UNI interface.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_restart_req {
        ulong cc_primitive;             /* always CC_RESTART_REQ */
        ulong cc_flags;                 /* restart flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_restart_req_t;
@end verbatim
@tpindex struct CC_restart_req
@tpindex CC_restart_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Indicates the length of the call control address (signalling interface and circuit identifiers) upon which a restart
was requested.  The semantics of the values in the @prim{CC_RESET_REQ} is identical to the values in the
@prim{CC_BIND_REQ}.
@item cc_addr_offset
Indicates the offset of the reporting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@page
@subsubsection Interface Management Restart Confirmation

@subsubheading CC_RESTART_CON
@prindex CC_RESTART_CON

This primitive confirms to the requesting CCS user that the restart of the requested call control addresses
(signalling interface and channels) for the specified UNI interface is complete.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_restart_ind {
        ulong cc_primitive;             /* always CC_RESTART_IND */
        ulong cc_flags;                 /* restart flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_restart_ind_t;
@end verbatim
@tpindex struct CC_restart_ind
@tpindex CC_restart_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Indicates the length of the call control address (signalling interface and circuit identifiers) upon which a restart
was requested.  The semantics of the values in the @prim{CC_RESET_REQ} is identical to the values in the
@prim{CC_BIND_REQ}.
@item cc_addr_offset
Indicates the offset of the reporting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@page
@subsection Circuit Management Primitives

@subsubsection Circuit Management Reset Request

@subsubheading CC_RESET_REQ
@prindex CC_RESET_REQ

This primitive requests that the CCS provider reset the specified call control address(es) (signalling interface and
circuit identifiers) with the CCS user peer.  For the NNI this primitive supports both the Circuit Reset Service as
well as the Circuit Group Reset Service.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_reset_req {
        ulong cc_primitive;             /* always CC_RESET_REQ */
        ulong cc_flags;                 /* reset flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_reset_req_t;
@end verbatim
@tpindex struct CC_reset_req
@tpindex CC_reset_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Indicates the length of the call control address (signalling interface and circuit identifiers) upon which a reset
is requested.  The semantics of the values in the @prim{CC_RESET_REQ} is identical to the values in the
@prim{CC_BIND_REQ}.
@item cc_addr_offset
Indicates the offset of the reporting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Rules

The following rules apply to the reset of call control addresses (signalling interface and circuit identifiers):
@itemize @bullet
@item
The call control address must contain a signalling interface identifier and one or more circuit identifiers.
@item
The signalling interface identifier must identify an NNI signalling interface.
@item
When the call control address contains one circuit identifier, a non-group reset will be performed.
@item
When the call control address contains more than one circuit identifier, the CCS provider may either issue
individual circuit resets, or may issue one or more group circuit resets.
@end itemize

@subsubheading Valid Modes

This primitive is only valid for call control address(es) in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE} for the requested address(es).
@stindex CCS_IDLE

@subsubheading New State

The new state is CCS_WCON_RESREQ for the specified address(es).

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_RESET_CON} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to perform the operation on the specified call control addresses.
@item @perr{CCNOADDR}
The call control address was not provided (cc_addr_length coded zero).
@item @perr{CCBADADDR}
The call control address(es) contained in the primitive were poorly formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling interface identifier was provided in the
call control address.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state for the requested address(es).
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Circuit Management Reset Indication

@subsubheading CC_RESET_IND
@prindex CC_RESET_IND

This primitive indicates that the peer CCS user has requested that the specified call control address(es)
(signalling interface and circuit identifiers) be reset.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_reset_ind {
        ulong cc_primitive;             /* always CC_RESET_IND */
        ulong cc_flags;                 /* reset flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_reset_ind_t;
@end verbatim
@tpindex struct CC_reset_ind
@tpindex CC_reset_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Indicates the length of the call control address(es) (signalling interface and circuit identifiers) that the peer
CCS user has requested be reset.
@item cc_addr_offset
Indicates the offset of the call control address(es) (signalling interface and circuit identifiers) from the
beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will not be issued for call control addresses in modes other than NNI mode.

@subsubheading Valid States

This primitive will only be issued for call control addresses for which no reset indication (@psta{CCS_IDLE}) is already
@stindex CCS_IDLE
pending.

@subsubheading New State

The new state is CCS_WRES_RESIND.

@page
@subsubsection Circuit Management Reset Response

@subsubheading CC_RESET_RES
@prindex CC_RESET_RES

This primitive request the CCS provider to complete the reset operation for the specified call control address(es)
(signalling interface and circuit identifiers) which was previously indicated with a
@prim{CC_RESET_IND}.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_reset_res {
        ulong cc_primitive;             /* always CC_RESET_RES */
        ulong cc_flags;                 /* reset flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_reset_res_t;
@end verbatim
@tpindex struct CC_reset_res
@tpindex CC_reset_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_flags
Indicates options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Indicates the length of the call control address(es) (signalling interface and circuit identifiers) upon which the
CCS user has accepted a reset.
@item cc_addr_offset
Indicates the offset of the call control address(es) (signalling interface and circuit identifiers) from the
beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Rules

The following rules apply to the reset of call control addresses (signalling interface and circuit identifiers):
@itemize @bullet
@item
The set of addresses specified must be a non-empty subset of the addresses which were specified in the indication
primitive to which this primitive is responding.
@item
Only once the primitive is successfully accepted by the CCS provider should the CCS provider take any actions
whatsoever with regard to reset.
@item
Call control addresses included in the call control address list which are not equipped may be ignored by the CCS
provider.
@end itemize

@subsubheading Valid States

This primitive is valid in state CCS_WRES_RESIND for the specified address(es).

@subsubheading New State

The new state is CCS_WACK_RESRES for the specified address(es).

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to perform the operation on the specified call control addresses.
@item @perr{CCNOADDR}
The call control address was not provided (cc_addr_length coded zero).
@item @perr{CCBADADDR}
The call control address(es) contained in the primitive were poorly formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling interface identifier was provided in the
call control address.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Circuit Management Reset Confirmation

@subsubheading CC_RESET_CON
@prindex CC_RESET_CON

This primitive confirms to the requesting CCS user that the specified call control address(es) (signalling interface
and circuit identifiers) have been successfully confirmed reset to the peer CCS user.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_reset_con {
        ulong cc_primitive;             /* always CC_RESET_CON */
        ulong cc_flags;                 /* reset flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_reset_con_t;
@end verbatim
@tpindex struct CC_reset_con
@tpindex CC_reset_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Indicates the length of the call control address(es) (signalling interface and circuit identifiers) upon which the
CCS provider has confirmed a reset.
@item cc_addr_offset
Indicates the offset of the call control address(es) (signalling interface and circuit identifiers) from the
beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for call control addresses in the NNI mode.

@subsubheading Valid States

This primitive is valid in state CCS_WCON_RESREQ for the specified addresses.

@subsubheading New State

The new state is @psta{CCS_IDLE} for the specified addresses.
@stindex CCS_IDLE

@page
@subsubsection Circuit Management Blocking Request

@subsubheading CC_BLOCKING_REQ
@prindex CC_BLOCKING_REQ

This primitive request that the CCS provider locally block the specified call control address(es) (signalling
interface and circuit or circuit group) with the peer CCS user.  For the NNI, this primitive supports both the
Circuit Blocking Service as well as the Circuit Group Blocking Service.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_blocking_req {
        ulong cc_primitive;             /* always CC_BLOCKING_REQ */
        ulong cc_flags;                 /* blocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_blocking_req_t;
@end verbatim
@tpindex struct CC_blocking_req
@tpindex CC_blocking_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers)
upon which local blocking is requested.  The semantics of the values in the call control address is described in
Section 2.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Rules

The following rules apply to the blocking of call control addresses (signalling interface and circuit or circuit
group identifiers):
@itemize @bullet
@item
If the stream upon which the blocking request is issued is not bound (see @prim{CC_BIND_REQ}), the call control address
must contain a signalling interface identifier and a circuit or circuit group identifier.
@item
If the stream upon which the blocking request is bound to a signalling interface and trunk group, and no call
control address(es) are provided (i.e, cc_addr_length is set to zero), the CCS provider may interpret the primitive
to be requesting blocking on all circuits in the trunk group.
@item
At any time that the primitive is issued without specifying a call control address (i.e, cc_addr_length is zero to
zero), the CCS provider may assign a call control address or addresses.
@item
If the CCS provider fails to assign a call control address or addresses, the primitive will fail with error
@perr{CCNOADDR}.
@end itemize

@subsubheading Valid Modes

This primitive is only valid for call control address(es) (signalling interfaces) in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE} for the requested address(es).
@stindex CCS_IDLE

@subsubheading New State

The new state is CCS_WCON_BLREQ for the specified address(es).

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive.
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_BLOCKING_CON} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_RELEASE_IND} or @prim{CC_RESET_IND} primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to invoke the operation on the specified addresses.
@item @perr{CCFLAGS}
The flags were invalid or unsupported.
@item @perr{CCNOADDR}
An address or addresses was not provided by the CCS user (i.e., cc_addr_length set to zero) and the CCS provider
could not assign an address or addresses.
@item @perr{CCBADADDR}
The call control address contained in the primitive were illegally formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling interface identifier was provided in the
call control address.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state for the requested address(es).
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize

@page
@subsubsection Circuit Management Blocking Indication

@subsubheading CC_BLOCKING_IND
@prindex CC_BLOCKING_IND

This primitive indicates that the peer CCS user has requested that the specified call control address(es)
(signalling interface and circuit identifiers) be remotely blocked.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_blocking_ind {
        ulong cc_primitive;             /* always CC_BLOCKING_IND */
        ulong cc_flags;                 /* blocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_blocking_ind_t;
@end verbatim
@tpindex struct CC_blocking_ind
@tpindex CC_blocking_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies the options flags.  See "Flags" below.
@item cc_addr_length
Indicates the length of the call control address(es) (signalling interface and circuit identifiers) that the peer
CCS user has requested to be remotely blocked.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive will only be issued by the CCS provider if the remote blocking state of the specified address(es) is
CCS_UNBLOCKED or CCS_BLOCKED.

@subsubheading New State

The new remote blocking state will be CCS_WRES_BLIND for the specified call control addresses.



@page
@subsubsection Circuit Management Blocking Response

@subsubheading CC_BLOCKING_RES
@prindex CC_BLOCKING_RES

This primitive requests that the CCS provider respond to the previous blocking indication.

@subsubheading Format

The format is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_blocking_res {
        ulong cc_primitive;             /* always CC_BLOCKING_RES */
        ulong cc_flags;                 /* blocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_blocking_res_t;
@end verbatim
@tpindex struct CC_blocking_res
@tpindex CC_blocking_res_t
@end smallexample

@subsubheading Parameters

@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers)
upon which local blocking is requested.  The semantics of the values in the call control address is described in
Section 2.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive is only valid for indications for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive is only valid for the previous @prim{CC_BLOCKING_IND} (call control addresses in the CCS_WRES_BLIND state).

@subsubheading New State

The new blocking state of the previously specified call control addresses is the CCS_BLOCKED state.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_RELEASE_IND} or CCS_RESET_IND primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to invoke the operation.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize


@page
@subsubsection Circuit Management Blocking Confirmation

@subsubheading CC_BLOCKING_CON
@prindex CC_BLOCKING_CON

This primitive confirms a previous blocking request (or indicates failure of a previous blocking request).

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_blocking_con {
        ulong cc_primitive;             /* always CC_BLOCKING_CON */
        ulong cc_flags;                 /* blocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_blocking_con_t;
@end verbatim
@tpindex struct CC_blocking_con
@tpindex CC_blocking_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies the options flags and result of the operation. (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers) for
which local blocking is confirmed.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive will only be issued by the CCS provider if the local blocking state of the specified address(es) is
CCS_WCON_BLREQ.

@subsubheading New State

The new local blocking state will be CCS_BLOCKED for the specified call control addresses.


@page
@subsubsection Circuit Management Unblocking Request

@subsubheading CC_UNBLOCKING_REQ
@prindex CC_UNBLOCKING_REQ

This primitive requests that the CCS provider locally unblock the specified call control address(es) (signalling
interface and circuit or circuit group) with the peer CCS user.  For the NNI, this primitive supports both Circuit
Unblocking Service as well as the Circuit Group Unblocking Service.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_unblocking_req {
        ulong cc_primitive;             /* always CC_UNBLOCKING_REQ */
        ulong cc_flags;                 /* unblocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_unblocking_req_t;
@end verbatim
@tpindex struct CC_unblocking_req
@tpindex CC_unblocking_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers)
upon which local unblocking is requested.  The semantics of the values in the call control address is described in
Section 2.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Rules

The following rules apply to the unblocking of call control addresses (signalling interface and circuit or circuit
group identifiers):
@itemize @bullet
@item
If the stream upon which the unblocking request is issued is not bound (see @prim{CC_BIND_REQ}), the call control address
must contain a signalling interface identifier and a circuit or circuit group identifier.
@item
If the stream upon which the unblocking request is bound to a signalling interface and trunk group, and no call
control address(es) are provided (i.e, cc_addr_length is set to zero), the CCS provider may interpret the primitive
to be requesting unblocking on all circuits in the trunk group.
@item
At any time that the primitive is issued without specifying a call control address (i.e, cc_addr_length is zero to
zero), the CCS provider may assign a call control address or addresses.
@item
If the CCS provider fails to assign a call control address or addresses, the primitive will fail with error
@perr{CCNOADDR}.
@end itemize

@subsubheading Valid Modes

This primitive is only valid for call control address(es) (signalling interfaces) in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE} for the requested address(es).
@stindex CCS_IDLE

@subsubheading New State

The new state is CCS_WCON_BLREQ for the specified address(es).

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive.
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_BLOCKING_CON} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_RELEASE_IND} or @prim{CC_RESET_IND} primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to invoke the operation on the specified addresses.
@item @perr{CCFLAGS}
The flags were invalid or unsupported.
@item @perr{CCNOADDR}
An address or addresses was not provided by the CCS user (i.e., cc_addr_length set to zero) and the CCS provider
could not assign an address or addresses.
@item @perr{CCBADADDR}
The call control address contained in the primitive were illegally formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling interface identifier was provided in the
call control address.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state for the requested address(es).
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize


@page
@subsubsection Circuit Management Unblocking Indication

@subsubheading CC_UNBLOCKING_IND
@prindex CC_UNBLOCKING_IND

This primitive indicates that the peer CCS user has requested that the specified call control address(es)
(signalling interface and circuit identifiers) be remotely unblocked.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_unblocking_ind {
        ulong cc_primitive;             /* always CC_UNBLOCKING_IND */
        ulong cc_flags;                 /* unblocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_unblocking_ind_t;
@end verbatim
@tpindex struct CC_unblocking_ind
@tpindex CC_unblocking_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies the options flags.  See "Flags" below.
@item cc_addr_length
\Indicates the length of the call control address(es) (signalling interface and circuit identifiers) that the peer
CCS user has requested to be remotely unblocked.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive will only be issued by the CCS provider if the remote blocking state of the specified address(es) is
CCS_UNBLOCKED or CCS_BLOCKED.

@subsubheading New State

The new remote blocking state will be CCS_WRES_UBIND for the specified call control addresses.


@page
@subsubsection Circuit Management Unblocking Response

@subsubheading CC_UNBLOCKING_RES
@prindex CC_UNBLOCKING_RES

This primitive requests that the CCS provider respond to the previous unblocking indication.

@subsubheading Format

The format is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_unblocking_res {
        ulong cc_primitive;             /* always CC_UNBLOCKING_RES */
        ulong cc_flags;                 /* blocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_unblocking_res_t;
@end verbatim
@tpindex struct CC_unblocking_res
@tpindex CC_unblocking_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers)
upon which local unblocking is requested.  The semantics of the values in the call control address is described in
Section 2.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive is only valid for indications for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive is only valid for the previous @prim{CC_BLOCKING_IND} (call control addresses in the CCS_WRES_BLIND state).

@subsubheading New State

The new blocking state of the previously specified call control addresses is the CCS_UNBLOCKED state.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_RELEASE_IND} or CCS_RESET_IND primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to invoke the operation.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize


@page
@subsubsection Circuit Management Unblocking Confirmation

@subsubheading CC_UNBLOCKING_CON
@prindex CC_UNBLOCKING_CON

This primitive confirms a previous unblocking request (or indicates failure of a previous unblocking request).

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_unblocking_con {
        ulong cc_primitive;             /* always CC_UNBLOCKING_CON */
        ulong cc_flags;                 /* unblocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_unblocking_con_t;
@end verbatim
@tpindex struct CC_unblocking_con
@tpindex CC_unblocking_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies the options flags and result of the operation. (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers) for
which local unblocking is confirmed.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive will only be issued by the CCS provider if the local unblocking state of the specified address(es) is
CCS_WCON_UBREQ.

@subsubheading New State

The new local unblocking state will be CCS_UNBLOCKED for the specified call control addresses.


@page
@subsubsection Circuit Management Query Request

@subsubheading CC_QUERY_REQ
@prindex CC_QUERY_REQ

This primitive requests that the CCS provider query specified call control address(es) (signalling interface and
circuit or circuit group) to the peer CCS user.  For the NNI, this primitive supports the Circuit Group Query
Service.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_query_req {
        ulong cc_primitive;             /* always CC_QUERY_REQ */
        ulong cc_flags;                 /* query flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_query_req_t;
@end verbatim
@tpindex struct CC_query_req
@tpindex CC_query_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers)
upon which the query is requested.  The semantics of the values in the call control address is described in Section
2.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Rules

The following rules apply to the querying of call control addresses (signalling interface and circuit or circuit
group identifiers):
@itemize @bullet
@item
If the stream upon which the query request is issued is not bound (see @prim{CC_BIND_REQ}), the call control address must
contain a signalling interface identifier and a circuit or circuit group identifier.
@item
If the stream upon which the query request is bound to a signalling interface and trunk group, and no call control
address(es) are provided (i.e, cc_addr_length is set to zero), the CCS provider may interpret the primitive to be
requesting status on all circuits in the trunk group.
@item
At any time that the primitive is issued without specifying a call control address (i.e, cc_addr_length is zero to
zero), the CCS provider may assign a call control address or addresses.
@item
If the CCS provider fails to assign a call control address or addresses, the primitive will fail with error
@perr{CCNOADDR}.
@end itemize

@subsubheading Valid Modes

This primitive is only valid for call control address(es) (signalling interfaces) in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE} for the requested address(es).
@stindex CCS_IDLE

@subsubheading New State

The new state is CCS_WCON_BLREQ for the specified address(es).

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive.
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_BLOCKING_CON} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_RELEASE_IND} or @prim{CC_RESET_IND} primitive.
@item
@emph{Non-fatal errors}: Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are
defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to invoke the operation on the specified addresses.
@item @perr{CCFLAGS}
The flags were invalid or unsupported.
@item @perr{CCNOADDR}
An address or addresses was not provided by the CCS user (i.e., cc_addr_length set to zero) and the CCS provider
could not assign an address or addresses.
@item @perr{CCBADADDR}
The call control address contained in the primitive were illegally formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling interface identifier was provided in the
call control address.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state for the requested address(es).
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize


@page
@subsubsection Circuit Management Query Indication

@subsubheading CC_QUERY_IND
@prindex CC_QUERY_IND

This primitive indicates that the peer CCS user has requested that the specified call control address(es)
(signalling interface and circuit identifiers) be queried.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_query_ind {
        ulong cc_primitive;             /* always CC_QUERY_IND */
        ulong cc_flags;                 /* query flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_query_ind_t;
@end verbatim
@tpindex struct CC_query_ind
@tpindex CC_query_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies the options flags.  See "Flags" below.
@item cc_addr_length
Indicates the length of the call control address(es) (signalling interface and circuit identifiers) that the peer
CCS user has requested to be queried.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive is valid in any state for the specified address(es).

@subsubheading New State

The new query state will be CCS_WRES_QIND for the specified call control addresses and the number of outstanding
queries for the specified call control addresses will be incremented.


@page
@subsubsection Circuit Management Query Response

@subsubheading CC_QUERY_RES
@prindex CC_QUERY_RES

This primitive requests that the CCS provider respond to the previous query indication.

@subsubheading Format

The format is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_query_res {
        ulong cc_primitive;             /* always CC_QUERY_RES */
        ulong cc_flags;                 /* blocking flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_query_res_t;
@end verbatim
@tpindex struct CC_query_res
@tpindex CC_query_res_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies options flags for the operation.  (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers)
upon which the query is requested.  The semantics of the values in the call control address is described in Section
2.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive is only valid for indications for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive is only valid for the previous @prim{CC_BLOCKING_IND} (call control addresses in the CCS_WRES_BLIND state).

@subsubheading New State

The new query state of the previously specified call control addresses is the @psta{CCS_IDLE} or CCS_WRES_QIND state and
@stindex CCS_IDLE
the query backlog is decremented.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}: Successful completion is indicated via the @prim{CC_OK_ACK} primitive.
@item
@emph{Unsuccessful}: Unsuccessful completion is indicated via the @prim{CC_RELEASE_IND} or CCS_RESET_IND primitive.
@item
@emph{Non-fatal errors}:
Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are defined as follows:
@table @asis
@item @perr{CCACCESS}
The user did not have sufficient permission to invoke the operation.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@end table
@end itemize


@page
@subsubsection Circuit Management Query Confirmation

@subsubheading CC_QUERY_CON
@prindex CC_QUERY_CON

This primitive confirms a previous query request (or indicates failure of a previous query request).

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_query_con {
        ulong cc_primitive;             /* always CC_QUERY_CON */
        ulong cc_flags;                 /* query flags */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_query_con_t;
@end verbatim
@tpindex struct CC_query_con
@tpindex CC_query_con_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_flags
Specifies the options flags and result of the operation. (See "Flags" below.)
@item cc_addr_length
Specifies the length of the call control address (signalling interface and circuit or circuit group identifiers) for
which status is confirmed.
@item cc_addr_offset
Specifies the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Flags

The options flags are protocol and provider-specific.  For additional information, see the Addendum.

@subsubheading Valid Modes

This primitive will only be issued by the CCS provider for signalling interfaces in the NNI mode.

@subsubheading Valid States

This primitive will only be issued by the CCS provider if the query state of the specified address(es) is
CCS_WCON_QREQ.

@subsubheading New State

The new query state will be @psta{CCS_IDLE} for the specified call control addresses.
@stindex CCS_IDLE

@page
@subsection Maintenance Primitives

@subsubsection Maintenance Indication

@subsubheading CC_MAINT_IND
@prindex CC_MAINT_IND

This primitive indicates that the CCS provider has observed an event on the indicated call control address(es) which
requires a maintenance action.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block followed by zero or more @msg{M_DATA} blocks.  The structure of
the @msg{M_PROTO} message block is as follows:
@smallexample
@verbatim
typedef struct CC_maint_ind {
        ulong cc_primitive;             /* always CC_MAINT_IND */
        ulong cc_reason;                /* reason for indication */
        ulong cc_call_ref;              /* call reference */
        ulong cc_addr_length;           /* length of address */
        ulong cc_addr_offset;           /* length of address */
} CC_maint_ind_t;
@end verbatim
@tpindex struct CC_maint_ind
@tpindex CC_maint_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_reason
Indicates the reason for the maintenance indication.  Maintenance indication reasons are protocol and
provider-specific.  For additional information see the Addendum.
@item cc_call_ref
Indicates the call reference.  The call reference is used by the CCS provider to identify the call.
@item cc_addr_length
Indicates the length of the call control address(es) (signalling interface and circuit identifiers) upon which the
CCS provider is giving a maintenance indication.
@item cc_addr_offset
Indicates the offset of the call control address(es) from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid in UNI (Network) mode and NNI mode.

@subsubheading Valid States

This primitive is valid in any state.

@subsubheading New State

The new state is unchanged.

@page
@subsection Circuit Continuity Test Primitives

This section describes the format of the NNI circuit continuity test primitives and rules associated with these
primitives.  Continuity test primitives are used by NNI management interfaces for performing continuity test
requests or responding to continuity test indications for specified or indicated circuits.  These primitives are
provided to allow the NNI to meet Q.764 conformance.

@subsubsection Circuit Continuity Check Request

@subsubheading CC_CONT_CHECK_REQ
@prindex CC_CONT_CHECK_REQ

This primitive requests that the CCS provider perform a continuity check procedure.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_check_req {
        ulong cc_primitive;             /* always CC_CONT_CHECK_REQ */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_cont_check_req_t;
@end verbatim
@tpindex struct CC_cont_check_req
@tpindex CC_cont_check_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_addr_length
Specifies the length of the call control address (circuit identifier) upon which the CCS user is requesting a
continuity check.
@item cc_addr_offset
Specifies the offset of the call control address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Rules

The following rules apply to the continuity check of call control addresses (circuit identifiers):
@itemize @bullet
@item
If the CCS user does not specify a call control address (i.e, cc_addr_length is set to zero), then the CCS provider
may attempt to assign a call control address and associate it with the stream for the duration of the continuity test
procedure.  This can be useful for automated continuity testing.
@end itemize


@subsubheading Valid Modes

This primitive is only valid in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE} for the selected circuit.
@stindex CCS_IDLE

@subsubheading New State

The new state is CKS_WIND_CTEST for the selected address.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_CONT_TEST_IND} primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCNOADDR}
The call control address was not provided (cc_addr_length coded zero).
@item @perr{CCBADADDR}
The call control address contained in the primitive were poorly formatted or contained invalid information.
@item @perr{CCNOTSUPP}
The primitive is not supported for the UNI interface and a UNI signalling address was provided in the call control
address or the address was issued to a UNI CCS provider.
@item @perr{CCACCESS}
The user did not have sufficient permission to perform the operation on the specified call control addresses.
@end table
@end itemize

@page
@subsubsection Circuit Continuity Check Indication

@subsubheading CC_CONT_CHECK_IND
@prindex CC_CONT_CHECK_IND

This primitive indicates to the CCS user that a continuity check is being requested by the CCS user peer on the
specified call control address(es) (signalling interface and circuit identifiers).  Upon receipt of this primitive,
the CCS user should establish a loop back device on the specified channel and issues the
@prim{CC_CONT_TEST_REQ} primitive
confirming the loop back.  The CCS user should then wait for the @prim{CC_CONT_REPORT_IND} indicating the success or
failure of the continuity check.

This primitive is only delivered to listening streams listening on the specified call control addresses or to a
stream bound as a default listener in the same manner as the @prim{CC_SETUP_IND}.  (A continuity test indication is treated
as a special form of call setup.)

This primitive is only issued to CCS users that successfully bound using the @prim{CC_BIND_REQ} primitive with flag @pval{CC_TEST}
set and a non-zero number of setup indications was provided in the @prim{CC_BIND_REQ} and returned in the @prim{CC_BIND_ACK}.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_check_ind {
        ulong cc_primitive;             /* always CC_CONT_CHECK_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_cont_check_ind_t;
@end verbatim
@tpindex struct CC_cont_check_ind
@tpindex CC_cont_check_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Identifies the call reference that can be used by the CCS user to associate this message with the
@prim{CC_CONT_TEST_REQ}
or @prim{CC_RELEASE_REQ} primitive that is to follow.  This value must be unique among the outstanding CC_CONT_CHECK_IND
messages.
@item cc_addr_length
Indicates the length of the call control address (circuit identifier) upon which a continuity check is indicated.
@item cc_addr_offset
Indicates the offset of the requesting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is only valid for addresses in the NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_IDLE} for the specified addresses.
@stindex CCS_IDLE

@subsubheading New State

The new state is CKS_WREQ_CTEST for the specified addresses.

@page
@subsubsection Circuit Continuity Test Request

@subsubheading CC_CONT_TEST_REQ
@prindex CC_CONT_TEST_REQ

This message is used either to respond to a @prim{CC_SETUP_IND} primitive which contains the
@pval{ISUP_NCI_CONT_CHECK_REQUIRED}
flag, or to respond to a CC_CONT_CHECK_IND primitive.  Before responding to either primitive, the CCS User should
install a loop back device on the requested channel and then respond with this response primitive to confirm the
loop back.


@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_test_req {
        ulong cc_primitive;             /* always CC_CONT_TEST_REQ */
        ulong cc_call_ref;              /* call reference */
        ulong cc_token_value;           /* token value */
} CC_cont_test_req_t;
@end verbatim
@tpindex struct CC_cont_test_req
@tpindex CC_cont_test_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference of the @prim{CC_CONT_TEST_REQ} message.  It is used by the CCS provider to associate the
@prim{CC_CONT_TEST_REQ} message with an outstanding @prim{CC_SETUP_IND} message.  An invalid call reference should result in error
with the error type @perr{CCBADCLR}.
@item cc_token_value
Is used to identify the stream that the CCS user wants to establish the continuity check call on.  (Its value is
determined by the CCS user by issuing a @prim{CC_BIND_REQ} primitive with the @pval{CC_TOKEN_REQ} flag set.  The token value
is returned in the @prim{CC_BIND_ACK}.)  The value of this field should be non-zero when the CCS user wants to establish
the call on a stream other than the stream on which the @prim{CC_CONT_CHECK_IND} arrived.  If the CCS user wants to
establish a call on the same stream that the @prim{CC_CONT_CHECK_IND} arrived on,
then the value of this field should be zero.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state CKS_WREQ_CTEST.

@subsubheading New State

The new state is CKS_WIND_CCREP.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon
receipt of this primitive:
@itemize ---
@item
@emph{Successful}:
Successful completion is indicated via the @prim{CC_CONT_REPORT_IND} in the case that the primitive was issued in response
to a @prim{CC_SETUP_IND}, or @prim{CC_RELEASE_IND} primitive in the case that the primitive was issued in response to the
@prim{CC_CONT_CHECK_IND} primitive.
@item
@emph{Unsuccessful}:
Unsuccessful completion is indicated via the @prim{CC_CONT_REPORT_IND} primitive.
@item
@emph{Non-fatal errors}:
Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable non-fatal errors are defined as follows:
@table @asis
@item @perr{CCSYSERR}
A system error has occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCACCESS}
The user did not have proper permissions for the operation.
@item @perr{CCNOTSUPP}
The CCS provider does not support the operation.
@end table
@end itemize

@page
@subsubsection Circuit Continuity Test Indication

@subsubheading CC_CONT_TEST_IND
@prindex CC_CONT_TEST_IND

This message confirms to the testing CCS user that a loop back device has been (or will be) installed on the
specified call control address (circuit).  Upon receiving this message, the testing CCS user should connect tone
generation and detection equipment to the specified circuit, perform the continuity test and issue a report using
the @prim{CC_CONT_REPORT_REQ} primitive.

This primitive will only be issued to streams successfully bound with the @prim{CC_BIND_REQ} primitive with a non-zero
number of setup indications and the @pval{CC_TEST} bind flag set.

@subsubheading Format

The format of this message is on @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_test_ind {
        ulong cc_primitive;             /* always CC_CONT_TEST_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_addr_length;           /* address length */
        ulong cc_addr_offset;           /* address offset */
} CC_cont_test_ind_t;
@end verbatim
@tpindex struct CC_cont_test_ind
@tpindex CC_cont_test_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference associated with the continuity check call for the specified call control address
(circuit identifier).
@item cc_addr_length
Indicates the length of the call control address (signalling interface and circuit identifier) upon which a
continuity check is confirmed.  The semantics of the values in the @prim{CC_CONT_TEST_IND} is identical to the values in
the @prim{CC_BIND_REQ}.
@item cc_addr_offset
Indicates the offset of the connecting address from the beginning of the @msg{M_PROTO} message block.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WCON_CREQ}.
@stindex CCS_WCON_CREQ


@subsubheading New State

The new state is CCS_WAIT_COR.

@page
@subsubsection Circuit Continuity Report Request

@subsubheading CC_CONT_REPORT_REQ
@prindex CC_CONT_REPORT_REQ

This primitive requests that the CCS provider indicate to the called CCS user that the continuity check succeeded or
failed.  The CCS user should remove any continuity test tone generator/detection device from the circuit and verify
silent code loop back before issuing this primitive.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_report_req {
        ulong cc_primitive;             /* always CC_CONT_REPORT_REQ */
        ulong cc_user_ref;              /* user call reference */
        ulong cc_call_ref;              /* call reference */
        ulong cc_result;                /* result of continuity check */
} CC_cont_report_req_t;
@end verbatim
@tpindex struct CC_cont_report_req
@tpindex CC_cont_report_req_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Specifies the primitive type.
@item cc_user_ref
Specifies the CCS user reference of the associated @prim{CC_SETUP_REQ} primitive.  This value is non-zero when the
@prim{CC_CONT_REPORT_REQ} primitive is issued subsequent to a @prim{CC_SETUP_REQ} primitive which had the flag
ISUP_NCI_CONTINUITY_CHECK_PREVIOUS set to indicate the result of the continuity check on the previous circuit.
Otherwise, this value is coded
zero.
@item cc_call_ref
Specifies the call reference of the associated @prim{CC_CONT_TEST_IND} primitive for the continuity check call.  This value
is non-zero when the @prim{CC_CONT_REPORT_REQ} primitive is issued in response to a @prim{CC_CONT_TEST_IND} primitive.  Otherwise,
this value is coded zero.
@item cc_result
Specifies the result of the continuity test, whether success or failure.  The value of the cc_result is protocol
specific.  For values representing success and values representing failure, see the Addendum.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state @psta{CCS_WREQ_CCREP}.
@stindex CCS_WREQ_CCREP

@subsubheading New State

When issued in response to the @prim{CC_CONT_TEST_IND} primitive, the new state is @psta{CCS_IDLE}.  When issued subsequent to a
@stindex CCS_IDLE
@prim{CC_SETUP_REQ} primitive, the new state is either @psta{CCS_WREQ_MORE} or @psta{CCS_WREQ_PROCEED}, depending upon whether the sent
@stindex CCS_WREQ_PROCEED
@stindex CCS_WREQ_MORE
address contain an ST pulse.

@subsubheading Acknowledgements

The CCS provider should generate one of the following acknowledgements upon
receipt of this primitive:
@itemize ---
@item
@emph{Successful}:  Successful completion is indicated via the @prim{CC_OK_ACK}
primitive.
@item
@emph{Unsuccessful (Non-fatal errors)}:  Errors are indicated via the @prim{CC_ERROR_ACK} primitive.  The applicable
non-fatal errors are defined as
follows:
@table @asis
@item @perr{CCSYSERR}
A system error occurred and the UNIX system error is indicated in the primitive.
@item @perr{CCOUTSTATE}
The primitive was issued from an invalid state.
@item @perr{CCBADCLR}
The call reference specified in the primitive was incorrect or illegal.
@item @perr{CCBADPRIM}
The primitive format was incorrect.
@end table
@end itemize

@page
@subsubsection Circuit Continuity Report Indication

@subsubheading CC_CONT_REPORT_IND
@prindex CC_CONT_REPORT_IND

This primitive indicates to the called CCS user that the continuity check succeeded or failed.  The called CCS user
can remove the loop back or tone generation/detection devices from the circuit and the call either moves to the idle
state or a call setup state.

@subsubheading Format

The format of this message is one @msg{M_PROTO} message block.  The structure of the @msg{M_PROTO} block is as follows:
@smallexample
@verbatim
typedef struct CC_cont_report_ind {
        ulong cc_primitive;             /* always CC_CONT_REPORT_IND */
        ulong cc_call_ref;              /* call reference */
        ulong cc_result;                /* result of continuity check */
} CC_cont_report_ind_t;
@end verbatim
@tpindex struct CC_cont_report_ind
@tpindex CC_cont_report_ind_t
@end smallexample

@subsubheading Parameters
@vtable @parm
@item cc_primitive
Indicates the primitive type.
@item cc_call_ref
Indicates the call reference associated with the continuity check report as it appeared in the associated
@prim{CC_CONT_CHECK_IND} primitive.
@item cc_result
Indicates the result of the continuity test, whether success or failure.  The value of the cc_result is protocol
specific.  For values representing success and values representing failure, see the Addendum.
@end vtable

@subsubheading Valid Modes

This primitive is valid only in NNI mode.

@subsubheading Valid States

This primitive is valid in state CCS_WREQ_CTEST or @psta{CCS_WIND_CCREP}.
@stindex CCS_WIND_CCREP

@subsubheading New State

If the primitive is issued subsequent to the @prim{CC_SETUP_REQ}, the new state is @psta{CCS_WCON_SREQ}.  If the primitive is
@stindex CCS_WCON_SREQ
issued in response to the @prim{CC_CONT_TEST_IND} primitive, the new state is @psta{CCS_IDLE}.
@stindex CCS_IDLE

@page
@subsection Collecting Information Phase

The following call control service primitive pertain to the collecting information phase of a call.

@page
@node Diagnostics Requirements
@chapter Diagnostics Requirements

Two error handling facilities should be provided to the call control service user: one to handle non-fatal errors,
ant the other to handle fatal errors.

@section Non-Fatal Error Handling Facility

These are errors that do not change the state of the call control service interface or the call reference as seen by
the call control service user, and provide the user the option of reissuing the call control service primitive with
the corrected options specification.  The non-fatal error handling is provided only to those primitive that require
acknowledgements, and uses the @prim{CC_ERROR_ACK} primitive to report these errors.  These errors retain the state of the
call control service interface and call reference the same as it was before the call control service provider
received the primitive that was in error.  Syntax errors and rule violations are reported via the non-fatal error
handling facility.

@section Fatal Error Handling Facility

These errors are issued by the CCS provider when it detects errors that are not correctable by the call control service
user, or if it is unable to report a correctable error to the call control service user.  Fatal errors are indicated via
the @acronym{STREAMS}
@cpindex STREAMS
message type @msg{M_ERROR} with the UNIX system error EPROTO.  The @msg{M_ERROR} @acronym{STREAMS}
@cpindex STREAMS
message type will result in the failure of all the UNIX system calls on the stream.  The call control service user can
recover from a fatal error by having all the processes close the files associated with the stream, and then reopening
them for processing.

@page
@node Addendum for Q.931 Conformance
@unnumbered Addendum for Q.931 Conformance

This addendum describes the formats and rules that are specific to ISDN Q.931.  The addendum must be used along with
the generic CCI as defined in the main document when implementing a CCS provider that will be configured with the
Q.931 call processing layer.

@section Primitives and Rules for Q.931 Conformance

The following are the rules that apply to the CCI primitives for Q.931 compatibility.

@subsection Common Primitive Parameters

@subsubsection Call Control Addresses

@subsubheading Format

The format of call control addresses is as follows:

@subsubheading Parameters
@vtable @parm
@item cc_addr_length
Specifies or indicates the length of the call control address.  If a call control address is not included in the
primitive, this parameter must be coded zero (0).
@item cc_addr_offset
Specifies or indicates the offset of the address from the begining of the primitive.  If a call control address is
not included with the primitive, this parameter must be coded zero (0).
@end vtable

@subsubheading Address Format

The format of the call control addresses for Q.931 conforming CCS providers is as follows:
@smallexample
@verbatim
typedef struct isdn_addr {
        ulong scope;            /* the scope of the identifier */
        ulong id;               /* the identifier within the scope */
        ulong ci;               /* channel identifier within the scope */
} isdn_addr_t;
@end verbatim
@tpindex struct isdn_addr
@tpindex isdn_addr_t
@verbatim

#define ISDN_SCOPE_CH       1   /* channel scope */
#define ISDN_SCOPE_FG       2   /* facility group scope */
#define ISDN_SCOPE_TG       3   /* transmission group scope */
#define ISDN_SCOPE_EG       4   /* equipment group scope */
#define ISDN_SCOPE_XG       5   /* customer/provider group scope */
#define ISDN_SCOPE_DF       6   /* default scope */
@end verbatim
@end smallexample

@subsubheading Address Fields
@vtable @pval
@item scope
Specifies or indicates the scope of the call control address.  See "Scope" below.
@item id
Specifies or indicates the identifier within the scope.
@item cic
Specifies or indicates the Channel Indicator significant within the scope.
@end vtable

@subsubheading Scope

The scope of the address is one of the following:
@vtable @pval
@item ISDN_SCOPE_CH
Specifies or indicates that the scope of the call control address is an ISDN B-channel.  The identifier within the
scope is an identifier which uniquely identifies the channel to the CCS provider.  Channel scope addresses may also
be used to specify or indicate transmission groups, equipment groups and customer/provider groups.  When used in an
indication or confirmation primitive, the CCS provider includes the Channel Identification associated with the
circuit in the address.

For multi-rate calls where multiple channels are involved, the channel scoped address specifies the lowest numerical
Channel Identifier in the group of circuits and the Channel Identifier provides the channel map of the group of
channels.
@item ISDN_SCOPE_FG
Specifies or indicates that the scope of the call control address is an ISDN facility group (group of one or more
redundant D-channels).  The identifier within the scope is an identifier which uniquely identifies the ISDN
interface to the CCS provider.  Facility group scope addresses may also be used to specify or indicate channels,
equipment groups or customer/provider groups.  When used in an indication or confirmation primitive, the CCS
provider includes the Channel Identifier associated with the indicated channels.
@item ISDN_SCOPE_TG
Specifies or indicates that the scope of the call control address is an ISDN transmission group (PRI interface).
The identifier within the scope is an indentifier which uniquely identifies the ISDN physical interface to the CCS
provider.  Transmission group scope addresses may also be used to specify or indicate equipment groups or
customer/provider groups.  When used in an indication or confirmation primitive, the CCS provider may include the
Channel Identifier associated with the facility group for the physical interface.
@item ISDN_SCOPE_EG
Specifies or indicates that the scope of the call control address is an ISDN equipment group.  The identifier within
the scope is an identifier that uniquely identifies the equipment group to the CCS provider.  Equipment group scoped
addresses may aslo be used to specify or indicate customer/provider groups.
@item ISDN_SCOPE_XG
Specifies or indicates that the scope of the call control address is an ISDN customer/provider group.  The
identifier within the scope is an identifier that uniquely identifies the customer/provider group to the CCS
provider.
@item ISDN_SCOPE_DF
Specifies or indicates that the scope of the call control address is the default scope.  The identifier within the
scope and Channel Identifier are unused and should be ignored by the CCS user and will be coded zero (0) by the CCS
provider.
@end vtable

@subsubheading Rules

@b{Rules for scope:}
@enumerate
@item
In primitives in which the address parameter occurs, the scope field setting indicates the scope of the address
parameter.
@item
Only one call control address can be specified with a signle scope.
@item
Not all scopes are necessarily supported by all primitives.  See the particular primitive in this addendum.
@end enumerate

@b{Rules for addresses:}
@enumerate
@item
The address contained in the primitive contains the following:
@itemize @bullet
@item
A scope.
@item
An identifier within the scope or zero (0).
@item
A channel indication within the scope or zero (0).
@end itemize
@item
If the scope of the address is @pval{ISDN_SCOPE_DF}, then both the identifier and channel indication fields should
be coded zero (0) and will be ignored by the CCS user or provider.
@item
If the scope of the address is @pval{ISDN_SCOPE_EG} or @pval{ISDN_SCOPE_XG}, then the channel indication field should be
coded zero (0) and will be ignored by the CCS user or provider.
@item
In all other scopes, the channel indication field is optional and is coded zero (0) if unused.
@end enumerate

@subsubsection Optional Information Elements

@subsubheading Format

The format of the optional information elements is as follows:

@subsubheading Parameters
@vtable @parm
@item cc_opt_length
Indicates the length of the optional information elements associated with the primitive.  For Q.931 conforming CCS
providers, the format of the optional information elements is the format of a Information Element list as specified
in Q.931.
@item cc_opt_offset
indicates the offset of the option information elements from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for optional information elements:}
@enumerate
@item
The optional information elements provided by the CCS user may be checked for syntax by the CCS provider.  If the
CCS provider discovers a syntax error in the format of the optional information elements, the CCS provider should
respond with a @prim{CC_ERROR_ACK} primitive with error @perr{CCBADOPT}.
@item
For some primitives, specific optional information elements might be interpreted by the CCS provider and alter the
function of some primitives.  See the specific primitive descriptions later in this addendum.
@item
Except for optional information elements interpreted by the CCS provider as specified later in this addendum, the
optional information elements are treated as opaque and the optional information element list only is checked for
syntax.  Opaque information elements will be passed to the ISDN message without examination by the CCS provider.
@item
To perform specific functions, additional optional information elements may be added to ISDN messages by the CCS
provider.
@item
To perform specific functions, optional information elements may be modified by the CCS provider before they are
added to ISDN messages.
@end enumerate

@subsection Local Management Primitives

@subsubsection CC_INFO_ACK
@prindex CC_INFO_ACK

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_BIND_REQ
@prindex CC_BIND_REQ

@subsubheading Parameters
@vtable @parm
@item cc_addr_length
Specifies the length of the address to bind.
@item cc_addr_offset
Specifies the offset of the address to bind.
@item cc_setup_ind
Specifies the requested maximum number of setup indications that will be outstanding for the listening stream.
@end vtable

@subsubheading Flags
@vtable @pval
@item CC_DEFAULT_LISTENER
@item CC_CHANNEL
@item CC_CHANNEL_GROUP
@item CC_TRUNK_GROUP
When on of these flags are set, it indicates that the address is interpreted by the CCS provider as unspecified
(@pval{CC_DEFAULT_LISTENER}),
a channel (@pval{CC_CHANNEL}), as a channel group (@pval{CC_CHANNEL_GROUP}), or as a trunk group
(@pval{CC_TRUNK_GROUP}).
@end vtable

@subsubheading Rules

@b{Rules for address specification:}
@enumerate
@item
The address contained in the primitive must be either a unspecified, a channel, a channel group or a trunk group.
@item
If the @pval{CC_DEFAULT_LISTENER}
flag is set, the address should be left unspecified by the CCS user and should be ignored
by the CCS provider.
@end enumerate

@b{Rules for setup indicatesion:}
@enumerate
@item
If the number of setup indications is non-zero, the stream is bound as a listening stream.  Listening streams will
receive all calls that are incoming on the address bound:
@itemize @bullet
@item
If the address bound is a channel (@pval{CC_CHANNEL} flag set), all incoming calls on the channel will be delivered to the
stream listening on the channel.  These streams will have a maximum number of setup indications of one (1).
@item
If the address bound is a channel group (@pval{CC_CHANNEL_GROUP} flag set), all incoming calls on the channel group will be
delivered to the stream listening on the channel group.  These streams will have a maximum number of setup
indications no higher than the number of channels in the channel group.
@item
If the address bound is a trunk group (@pval{CC_TRUNK_GROUP} flag set), all incoming calls on the trunk group will be
delivered to the stream listening on the trunk group.  These streams will have a maximum number of setup indications
no higher than the number of channels in the trunk group.
@end itemize
@end enumerate

@b{Rules for bind flags:}
@enumerate
@item
For Q.931 conforming CCS providers, the @pval{CC_DEFAULT_LISTENER}
will receive incoming calls that have no other listening
stream.  There can only be one stream bound with the @pval{CC_DEFAULT_LISTENER}
flag set.
@item
Only one of @pval{CC_DEFAULT_LISTENER},
@pval{CC_CHANNEL}, @pval{CC_CHANNEL_GROUP} or
@pval{CC_TRUNK_GROUP} may be set.
@end enumerate

@subsubsection CC_BIND_ACK
@prindex CC_BIND_ACK

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_OPTMGMT_REQ
@prindex CC_OPTMGMT_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsection Call Setup Primitives

@subsubsection Call Type and Flags

Call type and flags are used in the following primitives:

 @prim{CC_SETUP_REQ} and
 @prim{CC_SETUP_IND}.

@subsubheading Parameters
@vtable @parm
@item cc_call_type
Indicates the type of call to be set up.  For Q.931 conforming CCS providers, the call type can be one of the call
types listed under "Call Type" below.
@item cc_call_flags
Specifies the options flags associated with the call.  For Q.931 conforming CCS providers, the call flags can be any
of the flags listed under "Flags" below.
@end vtable

@subsubheading Call Type

The following call types are defined for Q.931 conforming CCS providers:
@vtable @pval
@item CC_CALL_TYPE_SPEECH
The call type is speech.  This call type corresponds to a Q.931 Information transfer capability of Speech, and an
Information transfer rate of 64kbit/s.
@item CC_CALL_TYPE_64KBS_UNRESTRICTED
The call type is 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of 64kbit/s.
@item CC_CALL_TYPE_3_1kHZ_AUDIO
The call type is 3.1 kHz audio.  This call type corresponds to a Q.931 Information transfer capability of
Unrestricted, and an Information transfer rate of 64kbits/s.
@item CC_CALL_TYPE_128KBS_UNRESTRICTED
The call type is 2 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of 2x64 kbit/s.
@item CC_CALL_TYPE_384KBS_UNRESTRICTED
The call type is 384 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of 384 kbit/s.
@item CC_CALL_TYPE_1536KBS_UNRESTRICTED
The call type is 1536 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of 1536 kbit/s.
@item CC_CALL_TYPE_1920KBS_UNRESTRICTED
The call type is 1920 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of 1920 kbit/s.
@item CC_CALL_TYPE_2x64KBS_UNRESTRICTED
The call type is 2 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 2.
@item CC_CALL_TYPE_3x64KBS_UNRESTRICTED
The call type is 3 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 3.
@item CC_CALL_TYPE_4x64KBS_UNRESTRICTED
The call type is 4 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 4.
@item CC_CALL_TYPE_5x64KBS_UNRESTRICTED
The call type is 5 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 5.
@item CC_CALL_TYPE_6x64KBS_UNRESTRICTED
The call type is 6 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 6.
@item CC_CALL_TYPE_7x64KBS_UNRESTRICTED
The call type is 7 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 7.
@item CC_CALL_TYPE_8x64KBS_UNRESTRICTED
The call type is 8 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 8.
@item CC_CALL_TYPE_9x64KBS_UNRESTRICTED
The call type is 9 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 9.
@item CC_CALL_TYPE_10x64KBS_UNRESTRICTED
The call type is 10 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 10.
@item CC_CALL_TYPE_11x64KBS_UNRESTRICTED
The call type is 11 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 11.
@item CC_CALL_TYPE_12x64KBS_UNRESTRICTED
The call type is 12 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 12.
@item CC_CALL_TYPE_13x64KBS_UNRESTRICTED
The call type is 13 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 13.
@item CC_CALL_TYPE_14x64KBS_UNRESTRICTED
The call type is 14 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 14.
@item CC_CALL_TYPE_15x64KBS_UNRESTRICTED
The call type is 15 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 15.
@item CC_CALL_TYPE_16x64KBS_UNRESTRICTED
The call type is 16 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 16.
@item CC_CALL_TYPE_17x64KBS_UNRESTRICTED
The call type is 17 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 17.
@item CC_CALL_TYPE_18x64KBS_UNRESTRICTED
The call type is 18 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 18.
@item CC_CALL_TYPE_19x64KBS_UNRESTRICTED
The call type is 19 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 19.
@item CC_CALL_TYPE_20x64KBS_UNRESTRICTED
The call type is 20 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 20.
@item CC_CALL_TYPE_21x64KBS_UNRESTRICTED
The call type is 21 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 21.
@item CC_CALL_TYPE_22x64KBS_UNRESTRICTED
The call type is 22 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 22.
@item CC_CALL_TYPE_23x64KBS_UNRESTRICTED
The call type is 23 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 23.
@item CC_CALL_TYPE_24x64KBS_UNRESTRICTED
The call type is 24 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 24.
@item CC_CALL_TYPE_25x64KBS_UNRESTRICTED
The call type is 25 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 25.
@item CC_CALL_TYPE_26x64KBS_UNRESTRICTED
The call type is 26 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 26.
@item CC_CALL_TYPE_27x64KBS_UNRESTRICTED
The call type is 27 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 27.
@item CC_CALL_TYPE_28x64KBS_UNRESTRICTED
The call type is 28 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 28.
@item CC_CALL_TYPE_29x64KBS_UNRESTRICTED
The call type is 29 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 29.
@item CC_CALL_TYPE_30x64KBS_UNRESTRICTED
The call type is 30 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.931 Information
transfer capability of Unrestricted, and an Information transfer rate of multi-rate with a base rate of 64 kbit/s
and a multiplier of 30.
@end vtable

@subsubheading Flags

The following call flags are defined for Q.931 conforming CCS providers:
@vtable @pval
@item CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS"
When set, this flag indicates that the unrestricted digital information includes tones and announcements.
@end vtable

@subsubheading Rules

@subsubsection CC_SETUP_REQ
@prindex CC_SETUP_REQ

@subsubheading Parameters
@vtable @parm
@item cc_call_type
Specifies the type of call to be set up.  For Q.931 conforming CCS providers, the call type can be one of the call
types listed under "Call Type and Flags" in this addendum.
@item cc_call_flags
Specifies the options flags associated with the call. For Q.931 conforming CCS providers, the call flags can be any
of the flags listed under "Call Type and Flags" in this addendum.
@item cc_cdpn_length
Specifies the length of the called party number.  For Q.931 conforming CCS providers, the format of the called party
number is the format of the Called Party Number parameter (without the parameter type or length octets) as specified
in Q.931.
@item cc_cdpn_offset
Specifies the offset of the called party number from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for call type:}
@enumerate
@item
A CCS provider need not support all of the call types listed.
@end enumerate

@b{Rules for call flags:}
@enumerate
@item
The CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS flag may only be set when the call type is unrestricted digital information.
When the call type is not unrestricted digital information, this flag should be ignored by the CCS provider.
@end enumerate

@b{Rules for called party number:}

@b{Rules for generating a SETUP message:}
@enumerate
@item
The mandatory (first) Bearer Capability information element in the SETUP message will be derived from the call type
and flags.  The Bearer Capability information element will contain the Information transfer capability, rate, base
and multiplier indicated above.
@itemize @bullet
@item
When the call type is CC_CALL_TYPE_128KBS_UNRESTRICTED, the Bearer Capability information element will be coded with
an Information transfer capability of unrestricted (or unrestricted with tones an announcements if the flag
CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS i set) and an Information transfer rate of 2 x 64 kbit/s uni-rate call.  For a
multi-rate call, the call type should be coded as CC_CALL_TYPE_2x64KBS_UNRESTRICTED.
@item
When the call type is CC_CALL_TYPE_384KBS_UNRESTRICTED, the Bearer Capability information element will be coded with
an Information transfer capability of unrestricted (or unrestricted with tones an announcements if the flag
CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS i set) and an Information transfer rate of 384 kbit/s uni-rate call.  For a
multi-rate call, the call type should be coded as CC_CALL_TYPE_6x64KBS_UNRESTRICTED.
@item
When the call type is CC_CALL_TYPE_1536KBS_UNRESTRICTED, the Bearer Capability information element will be coded
with an Information transfer capability of unrestricted (or unrestricted with tones an announcements if the flag
CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS i set) and an Information transfer rate of 1536 kbit/s uni-rate call.  For a
multi-rate call, the call type should be coded as CC_CALL_TYPE_24x64KBS_UNRESTRICTED.
@item
When the call type is CC_CALL_TYPE_1920KBS_UNRESTRICTED, the Bearer Capability information element will be coded
with an Information transfer capability of unrestricted (or unrestricted with tones an announcements if the flag
CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS i set) and an Information transfer rate of 1920 kbit/s uni-rate call.  For a
multi-rate call, the call type should be coded as CC_CALL_TYPE_29x64KBS_UNRESTRICTED.
@itemize @bullet
@item
The mandatory Channel Identification information element in the SETUP message will be derived from the address to
which the stream is bound.
@end itemize
@item
If the stream is bound to a channel group (the one or more interfaces), then a free channel will be selected
automatically by the CCS provider (if possible).
@item
If the stream is bound to a channel, then the channel identifier of the bound channel will be used.
@end itemize
@end enumerate

@b{Rules for state transitions:}
@enumerate
@item
If the optional information element contains a Sending Complete information element, then the CCS provider will not
accept any subsequent @prim{CC_INFORMATION_REQ} primitives from the CCS user, nor will the CCS provider issue any
subsequent @prim{CC_MORE_INFO_IND} primitives to the CCS user.
@end enumerate

@subsubsection CC_SETUP_IND
@prindex CC_SETUP_IND

@subsubheading Parameters
@vtable @parm
@item cc_call_type
Specifies the type of call to be set up.  For Q.931 conforming CCS providers, the call type can be one of the call
types listed under "Call Type and Flags" in this addendum.
@item cc_call_flags
Specifies the options flags associated with the call. For Q.931 conforming CCS providers, the call flags can be any
of the flags listed under "Call Type and Flags" in this addendum.
@item cc_cdpn_length
Specifies the length of the called party number.  For Q.931 conforming CCS providers, the format of the called party
number is the format of the Called Party Number parameter (without the parameter type or length octets) as specified
in Q.931.
@item cc_cdpn_offset
Specifies the offset of the called party number from the beginning of the block.
@item cc_addr_length
Specifies the length of the address which contains the channel identifier selected for the call.
@item cc_addr_offset
Specifies the offset of the address from the beginning of the block.
@end vtable

@subsubheading Flags

Call flags can be any of the call flags supported by the CCS provider listed under @prim{CC_SETUP_REQ} in this addendum.

@subsubheading Rules

@b{Rules for call type:}
@enumerate
@item
A CCS provider need not support all of the call types listed.
@end enumerate

@b{Rules for call flags:}
@enumerate
@item
The CC_ITC_WITH_TONES_AND_ANNOUNCEMENTS flag may only be set when the call type is unrestricted digital information.
When the call type is not unrestricted digital information, this flag should be ignored by the CCS provider.
@end enumerate

@b{Rules for called party number:}

@b{Rules for obtaining parameters from a SETUP message:}
@enumerate
@item
The mandatory (first) Bearer Capability information element in the SETUP message will be translated into the call
type and flags.  The call type and flags correspond to the Bearer Capability information element will contain the
Information transfer capability, rate, base and multiplier indicated under "Call Type" and "Flags".
@item
The mandatory Channel Identification information element in the SETUP message will be provided in the address
parameter.
@end enumerate

@b{Rules for state transitions:}
@enumerate
@item
If the optional information element contains a Sending Complete information element, then the CCS provider will not
accept any subsequent @prim{CC_MORE_INFO_REQ} primitives from the CCS user, nor will the CCS provider issue any subsequent
@prim{CC_INFORMATION_IND} primitives to the CCS user.
@end enumerate

@subsubsection CC_SETUP_RES
@prindex CC_SETUP_RES

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_SETUP_CON
@prindex CC_SETUP_CON

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_CALL_REATTEMPT_IND
@prindex CC_CALL_REATTEMPT_IND

@subsubheading Rules

@subsubsection CC_SETUP_COMPLETE_REQ
@prindex CC_SETUP_COMPLETE_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_SETUP_COMPLETE_IND
@prindex CC_SETUP_COMPLETE_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsection Continuity Check Primitives

@subsubsection CC_CONT_CHECK_REQ
@prindex CC_CONT_CHECK_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_CONT_TEST_REQ
@prindex CC_CONT_TEST_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_CONT_REPORT_REQ
@prindex CC_CONT_REPORT_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsection Call Establishment Primitives

@subsubsection CC_MORE_INFO_REQ
@prindex CC_MORE_INFO_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_MORE_INFO_IND
@prindex CC_MORE_INFO_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_INFORMATION_REQ
@prindex CC_INFORMATION_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_INFORMATION_IND
@prindex CC_INFORMATION_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_INFO_TIMEOUT_IND
@prindex CC_INFO_TIMEOUT_IND

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
If the Q.931 conforming CCS provider is expecting additional digits (it has previously issued a
@prim{CC_MORE_INFO_REQ})
and timer T302 expires, the CCS provider will issue this primitive to the CCS user.
@item
Upon receipt of this primitive, it is the CCS user's responsibility to determine whether the address digits are
sufficient and to issue a @prim{CC_SETUP_RES} or @prim{CC_REJECT_REQ} primitive.
@end enumerate

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS user
receives a @prim{CC_INFO_TIMEOUT_IND}

@subsubsection CC_PROCEEDING_REQ
@prindex CC_PROCEEDING_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_PROCEEDING_IND
@prindex CC_PROCEEDING_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_ALERTING_REQ
@prindex CC_ALERTING_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_ALERTING_IND
@prindex CC_ALERTING_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_PROGRESS_REQ
@prindex CC_PROGRESS_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_PROGRESS_IND
@prindex CC_PROGRESS_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_IBI_REQ
@prindex CC_IBI_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_IBI_IND
@prindex CC_IBI_IND

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsection Call Established Primitives

@subsubsection CC_SUSPEND_REQ
@prindex CC_SUSPEND_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options associated with the suspend.  See "Flags" below.
@end vtable

@subsubheading Flags

Q.931 conforming CCS providers do not support suspend flags.  This field should be coded zero (0) by the CCS user
and ignored by the CCS provider.

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
Only the CCS user on the User side of the Q.931 interface can issue a @prim{CC_SUSPEND_REQ} primitive.  If the CCS provider
is in Network mode and it receives a CCS_SUSPEND_REQ, it should respond with a @prim{CC_ERROR_ACK} with error @perr{CCNOTSUPP}.
@end enumerate

@subsubsection CC_SUSPEND_IND
@prindex CC_SUSPEND_IND
@vtable @parm
@item cc_flags
Indicates the options associated with the suspend.  See "Flags" below.
@end vtable

@subsubheading Flags

Q.931 conforming CCS providers do not support suspend flags.  This field will be coded zero (0) by the CCS provider
and may be ignored by the CCS provider.

@subsubsection CC_SUSPEND_RES
@prindex CC_SUSPEND_RES

@subsubheading Parameters

@subsubheading Rules

@subsubsection CC_SUSPEND_CON
@prindex CC_SUSPEND_CON

@subsubheading Parameters

@subsubheading Rules

@subsubsection CC_SUSPEND_REJECT_REQ
@prindex CC_SUSPEND_REJECT_REQ

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause for the rejection.  For Q.931 conforming CCS providers, the cause values can be any of the
values listed in "Cause Values" in this addendum with the exception of CCS_CAUS_NONE.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_SUSPEND_REJECT_IND
@prindex CC_SUSPEND_REJECT_IND

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause for the rejection.  For Q.931 conforming CCS providers, the cause values can be any of the
values listed in "Cause Values" in this addendum with the exception of CCS_CAUS_NONE.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_RESUME_REQ
@prindex CC_RESUME_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options associated with the resume.  See "Flags" below.
@end vtable

@subsubheading Flags

Q.931 conforming CCS providers do not support resume flags.  This field should be coded zero (0) by the CCS user and
ignored by the CCS provider.

@subsubheading Rules

@subsubsection CC_RESUME_IND
@prindex CC_RESUME_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options associated with the resume.  See "Flags" below.
@end vtable

@subsubheading Flags

Q.931 conforming CCS providers do not support resume flags.  This field should be coded zero (0) by the CCS user and
ignored by the CCS provider.

@subsubheading Rules

@subsubsection CC_RESUME_RES
@prindex CC_RESUME_RES

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_RESUME_CON
@prindex CC_RESUME_CON

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_RESUME_REJECT_REQ
@prindex CC_RESUME_REJECT_REQ

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause for the rejection.  For Q.931 conforming CCS providers, the cause values can be any of the
values listed in "Cause Values" in this addendum with the exception of CCS_CAUS_NONE.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_RESUME_REJECT_IND
@prindex CC_RESUME_REJECT_IND
@vtable @parm
@item cc_cause
Specifies the cause for the rejection.  For Q.931 conforming CCS providers, the cause values can be any of the
values listed in "Cause Values" in this addendum with the exception of CCS_CAUS_NONE.
@end vtable

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsection Call Termination Primitives

@subsubsection Cause Values

Cause values are used in the following primitives:

 @prim{CC_REJECT_REQ},
 @prim{CC_REJECT_IND},
 @prim{CC_DISCONNECT_REQ},
 @prim{CC_DISCONNECT_IND},
 @prim{CC_RELEASE_REQ}, and
 @prim{CC_RELEASE_IND}.

@subsubheading Parameters
@vtable @parm
@item cc_cause
Indicates the case for the rejection, disconnection, or release of a call.  For Q.931 conforming CCS providers, the
cause values can be any of the cause values listed in Q.850 listed under "Cause Value" below.
@end vtable

@subsubheading Cause Value

Cause values are essentially opaque and cause values will be transferred directly to the corresponding Q.931
message.  The following cause values are defined for Q.931 conforming CCS providers:
@vtable @pval
@item CC_CAUS_UNALLOCATED_NUMBER
The called party number does not correspond to number allocated to a subscriber or terminal.
@item CC_CAUS_NO_ROUTE_TO_TRANSIT_NETWORK
(no description)
@item CC_CAUS_NO_ROUTE_TO_DESTINATION
(no description)
@item CC_CAUS_SEND_SPECIAL_INFO_TONE
(no description)
@item CC_CAUS_MISDIALLED_TRUNK_PREFIX
(no description)
@item CC_CAUS_PREEMPTION
(no description)
@item CC_CAUS_PREEMPTION_CCT_RESERVED
(no description)
@item CC_CAUS_NORMAL_CALL_CLEARING
(no description)
@item CC_CAUS_USER_BUSY
(no description)
@item CC_CAUS_NO_USER_RESPONDING
(no description)
@item CC_CAUS_NO_ANSWER
(no description)
@item CC_CAUS_SUBSCRIBER_ABSENT
(no description)
@item CC_CAUS_CALL_REJECTED
(no description)
@item CC_CAUS_NUMBER_CHANGED
(no description)
@item CC_CAUS_REDIRECT
(no description)
@item CC_CAUS_OUT_OF_ORDER
(no description)
@item CC_CAUS_ADDRESS_INCOMPLETE
(no description)
@item CC_CAUS_FACILITY_REJECTED
(no description)
@item CC_CAUS_NORMAL_UNSPECIFIED
(no description)
@item CC_CAUS_NO_CCT_AVAILABLE
(no description)
@item CC_CAUS_NETWORK_OUT_OF_ORDER
(no description)
@item CC_CAUS_TEMPORARY_FAILURE
(no description)
@item CC_CAUS_SWITCHING_EQUIP_CONGESTION
(no description)
@item CC_CAUS_ACCESS_INFO_DISCARDED
(no description)
@item CC_CAUS_REQUESTED_CCT_UNAVAILABLE
(no description)
@item CC_CAUS_PRECEDENCE_CALL_BLOCKED
(no description)
@item CC_CAUS_RESOURCE_UNAVAILABLE
(no description)
@item CC_CAUS_NOT_SUBSCRIBED
(no description)
@item CC_CAUS_OGC_BARRED_WITHIN_CUG
(no description)
@item CC_CAUS_ICC_BARRED WITHIN_CUG
(no description)
@item CC_CAUS_BC_NOT_AUTHORIZED
(no description)
@item CC_CAUS_BC_NOT_AVAILABLE
(no description)
@item CC_CAUS_INCONSISTENCY
(no description)
@item CC_CAUS_SERVICE_OPTION_NOT_AVAILABLE
(no description)
@item CC_CAUS_BC_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_FACILITY_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_RESTRICTED_BC_ONLY
(no description)
@item CC_CAUS_SERIVCE_OPTION_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_USER_NOT_MEMBER_OF_CUG
(no description)
@item CC_CAUS_INCOMPATIBLE_DESTINATION
(no description)
@item CC_CAUS_NON_EXISTENT_CUG
(no description)
@item CC_CAUS_INVALID_TRANSIT_NTWK_SELECTION
(no description)
@item CC_CAUS_INVALID_MESSAGE
(no description)
@item CC_CAUS_MESSAGE_TYPE_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_PARAMETER_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_RECOVERY_ON_TIMER_EXPIRY
(no description)
@item CC_CAUS_PARAMETER_PASSED_ON
(no description)
@item CC_CAUS_MESSAGE_DISCARDED
(no description)
@item CC_CAUS_PROTOCOL_ERROR
(no description)
@item CC_CAUS_INTERWORKING
(no description)
@item CC_CAUS_UNALLOCATED_DEST_NUMBER
(no description)
@item CC_CAUS_UNKNOWN_BUSINESS_GROUP
(no description)
@item CC_CAUS_EXCHANGE_ROUTING_ERROR
(no description)
@item CC_CAUS_MISROUTED_CALL_TO_PORTED_NUMBER  26
(no description)
@item CC_CAUS_LNP_QOR_NUMBER_NOT_FOUND
(no description)
@item CC_CAUS_PREEMPTION
(no description)
@item CC_CAUS_PRECEDENCE_CALL_BLOCKED
(no description)
@item CC_CAUS_CALL_TYPE_INCOMPATIBLE
(no description)
@item CC_CAUS_GROUP_RESTRICTIONS
(no description)
@end vtable

@subsubheading Rules

In addition to these cause values, the CCS provider might support additional variant-specific cause values.

@subsubsection CC_REJECT_REQ
@prindex CC_REJECT_REQ

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause value for the rejection.  For Q.931 conforming CCS providers, the cause value will be one of the
cause values listed under "Cause Values" in this Addendum.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_REJECT_IND
@prindex CC_REJECT_IND

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause value for the rejection.  For Q.931 conforming CCS providers, the cause value will be one of the
cause values listed under "Cause Values" in this Addendum.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_CALL_FAILURE_IND
@prindex CC_CALL_FAILURE_IND

@subsubheading Parameters
@vtable @parm
@item cc_reason
Specifies the reason for the failure indication.  For Q.931 conforming CCS providers, the reason will be one of the
reasons listed under "Call Failure Reasons" below.
@item cc_cause
Specifies the cause value for the error indication.  For Q.931 conforming CCS providers, the cause value will be one
of the cause values listed under "Cause Values" in this addendum.
@end vtable

@subsubheading Call Failure Reasons
@vtable @pval
@item ISUP_CALL_FAILURE_ERROR
Indicates that the data link failed and recovered during overlap sending or overlap receiving.
@item ISUP_CALL_FAILURE_STATUS
Indicates that the CCS provider received a STATUS message from the peer with a unrecoverable mismatch in state.
@item ISUP_CALL_FAILURE_RESTART
Indicates that the CCS provider received or issued a RESTART message for the channel.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_DISCONNECT_REQ
@prindex CC_DISCONNECT_REQ

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause value for the disconnect.  For Q.931 conforming CCS providers, the cause value will be one of
the cause values listed under "Cause Values" in this addendum.
@end vtable

@subsubheading Rules

@subsubsection CC_DISCONNECT_IND
@prindex CC_DISCONNECT_IND

@subsubheading Parameters
@vtable @parm
@item cc_cause
Indicates the case values for the disconnect.  For Q.931 conforming CCS providers, the cause value wil be one of the
cause values listed under "Cause Value" in this addendum.
@end vtable

@subsubheading Rules

@subsubsection CC_RELEASE_REQ
@prindex CC_RELEASE_REQ

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause value for the release.  For Q.931 conforming CCS providers, the cause value will be one of the
cause values listed under "Cause Values" in this addendum.
@end vtable

@subsubheading Rules

@b{Rules for cause:}
@enumerate
@item
If the request is not the first step in the clearing phase (i.e, the call is not in state CC_WREQ_REL), then the
cause value must be specified.  Otherwise, the cause value should be coded CC_CAUS_NONE by the CCS user and ignored
by the CCS provider.
@end enumerate

@subsubsection CC_RELEASE_IND
@prindex CC_RELEASE_IND

@subsubheading Parameters
@vtable @parm
@item cc_cause
Specifies the cause value for the release.  For Q.931 conforming CCS providers, the cause value will be one of the
cause values listed under "Cause Values" in this addendum.
@end vtable

@subsubheading Rules

@b{Rules for cause:}
@enumerate
@item
If the request is not the first step in the clearing phase (i.e, the call is not in state CC_WIND_REL), then the
cause value will be indicated by the CCS provider.  Otherwise, the cause value will be coded CC_CAUS_NONE by the CCS
provider and should be ignored by the CCS user.
@end enumerate

@subsubsection CC_RELEASE_RES
@prindex CC_RELEASE_RES

@subsubheading Parameters

@subsubheading Rules

@subsubsection CC_RELEASE_CON
@prindex CC_RELEASE_CON

@subsubheading Parameters

@subsubheading Rules

@subsection Management Primitives

@subsubsection CC_RESTART_REQ
@prindex CC_RESTART_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
@item cc_addr_length
Specifies the length of the address which contains the interface identifier(s) and optional channel identification
for the interface(s) or channels to restart.
@item cc_addr_offset
Specifies the offset of the address from the beginning of the block.
@end vtable

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_RESTART_CON
@prindex CC_RESTART_CON

@subsubheading Parameters
@vtable @parm
@item cc_flags
@item cc_addr_length
Specifies the length of the address which contains the interface identifier(s) and optional channel identification
for the interface(s) or channels to restart.
@item cc_addr_offset
Specifies the offset of the address from the beginning of the block.
@end vtable

@subsubheading Flags

@subsubheading Rules

@section Q.931 Header File Listing

@noindent
@smallformat
@verbatiminclude isdni.h
@end smallformat

@page
@node Addendum for Q.764 Conformance
@unnumbered Addendum for Q.764 Conformance

This addendum describes the formats and rules that are specific to ISUP Q.764.  The addendum must be used along with
the generic CCI as defined in the main document when implementing a CCS provider that will be configured with the
Q.764 call processing layer.

@section Primitives and Rules for Q.764 Conformance

The following are the rules that apply to the CCI primitives for Q.764 compatibility.

@subsection Common Primitive Parameters

@subsubsection Call Control Addresses

@subsubheading Format

The format of call control addresses is as follows:

@subsubheading Parameters
@vtable @parm
@item cc_addr_length
Specifies or indicates the length of the call control address.  If a call control address is not included in the
primitive, this parameter must be coded zero (0).
@item cc_addr_offset
Specifies or indicates the offset of the address from the begining of the primitive.  If a call control address is
not included with the primitive, this parameter must be coded zero (0).
@end vtable

@subsubheading Address Format

The format of the call control addresses for Q.764 conforming CCS providers is as follows:
@smallexample
@verbatim
typedef struct isup_addr {
        ulong scope;            /* the scope of the identifier */
        ulong id;               /* the identifier within the scope */
        ulong cic;              /* circuit identification code within the scope */
} isup_addr_t;
@end verbatim
@tpindex struct isup_addr
@tpindex isup_addr_t

#define ISUP_SCOPE_CT           1       /* circuit scope */
#define ISUP_SCOPE_CG           2       /* circuit group scope */
#define ISUP_SCOPE_TG           3       /* trunk group scope */
#define ISUP_SCOPE_SR           4       /* signalling relation scope */
#define ISUP_SCOPE_SP           5       /* signalling point scope */
#define ISUP_SCOPE_DF           6       /* default scope */
#define ISUP_SCOPE_CIC          7       /* for unidentified cic addresses */
@end smallexample

@subsubheading Address Fields
@vtable @pval
@item scope
Specifies or indicates the scope of the call control address.  See "Scope" below.
@item id
Specifies or indicates the identifier within the scope.
@item cic
Specifies or indicates the Circuit Identification Code significant within the scope.
@end vtable

@subsubheading Scope

The scope of the address is one of the following:
@vtable @pval
@item ISUP_SCOPE_CT
Specifies or indicates that the scope of the call control address is a ISUP circuit.  The identifier within the
scope is an identifier which uniquely identifies a circuit to the CCS provider.  Circuit scope addresses may also be
used to specify or indicate circuit groups, trunk groups, signalling relations and signalling points.  When used in
an indication or confirmation primitive, the CCS provider includes the Circuit Identification Code associated with
the circuit in the address.

For multi-rate calls where multiple circuits are involved, the circuit scoped address specifies the lowest numerical
Circuit Identification Code in the group of circuits.
@item ISUP_SCOPE_CG
Specifies or indicates that the scope of the call control address is a ISUP circuit group.  The identifier within
the scope is an identifier which uniquely identifies a circuit group to the CCS provider.  Circuit group scope
addresses may also be used to specify or indicate signalling relations and signalling points.  When used in an
indication or confirmation primitive, the CCS provider includes the Circuit Identification Code associated with the
circuit group (lowest numerical value CIC in the circuit group range).
@item ISUP_SCOPE_TG
Specifies or indicates that the scope of the call control address is a ISUP trunk group.  The identifier within the
scope is an identifier which uniquely identifies a trunk group to the CCS provider.  Trunk group scope addresses may
also be used to specify or indicate circuits, signalling relations and signalling points.  The Circuit
Identification Code must be used to specify a circuit within the trunk group.
@item ISUP_SCOPE_SR
Specifies or indicates that the scope of the call control address is a ISUP signalling relation.  The identifier
within the scope is an identifier which uniquely identifies a signalling relation to the CCS provider.  Signalling
relation scope addresses may also be used to specify or indicate circuits and signalling points.  The Circuit
Identification Code must be used to sepcify a circuit (equipped or unequipped) within the signalling relation.
@item ISUP_SCOPE_SP
Specifies or indicates that the scope of the call control address is a ISUP signalling point.  The identifier within
the scope is an identifier which uniquely identifies a local signalling point to the CCS provider.  Signalling point
scope addresses may only indicate local signalling points.  The Circuit Identification Code is unused and should be
ignored by the CCS user and will be coded zero (0) by the CCS provider.
@item ISUP_SCOPE_DF
Specifies or indicates that the scope of the call control address is the default scope.  The identifier within the
scope and Circuit Identification Code are unused and should be ignored by the CCS user and will be coded zero (0) by
the CCS provider.
@end vtable

@subsubheading Rules

@b{Rules for scope:}
@enumerate
@item
In primitives in which the address parameter occurs, the scope field setting indicates the scope of the address
parameter.
@item
Only one call control address can be specified with a signle scope.
@item
Not all scopes are necessarily supported by all primitives.  See the particular primitive in this addendum.
@end enumerate

@b{Rules for addresses:}
@enumerate
@item
The address contained in the primitive contains the following:
@itemize @bullet
@item
A scope.
@item
An identifier within the scope or zero (0).
@item
A circuit identification code within the scope or zero (0).
@end itemize
@item
If the scope of the address is @pval{ISUP_SCOPE_DF}, then both the identifier and circuit identification code fields should
be coded zero (0) and will be ignored by the CCS user or provider.
@item
If the scope of the address is @pval{ISUP_SCOPE_SP}, then the circuit identification code field should be coded zero (0) and
will be ignored by the CCS user or provider.
@item
In all other scopes, the circuit identification code is optional and is coded zero (0) if unused.
@end enumerate

@subsubsection Optional Parameters

@subsubheading Format

The format of the optional parameters for Q.764 conforming CCS providers is as follows:

@subsubheading Parameters
@vtable @parm
@item cc_opt_length
Specifies or indicates the length of the optional parameters associated with the primitive.  For Q.764 conforming
CCS providers, the format of the optional parameters is the format of the Optional Parameters list (without the
pointer or End of Optional Parameters octets) as specified in Q.763.
@item cc_opt_offset
Specifies the offset of the optional parameters from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for optional parameters:}
@enumerate
@item
The optional parameters provided by the CCS user may be checked for syntax by the CCS provider.  If the CCS provider
discovers a syntax error in the format of the optional parameters, the CCS provider should respond with a
@prim{CC_ERROR_ACK} primitive with error @perr{CCBADOPT}.
@item
For some primitives, specific optional parameters might be interpreted by the CCS provider and alter the function of
some primitives.  See the specific primitive descriptions later in this addendum.
@item
Except for optional parameters interpreted by the CCS provider as specified later in this addendum, the optional
parameters are treated as opaque and the optional parameter list only is checked for syntax.  Opaque parameters will
be passed to the ISUP message without examination by the CCS provider.
@item
To perform specific functions, additional optional parameters may be added to ISUP messages by the CCS provider.
@item
To perform specific functions, optional parameters may be modified by the CCS provider before being added to ISUP
messages.
@end enumerate

@subsection Local Management Primitives

@subsubsection CC_INFO_ACK
@prindex CC_INFO_ACK

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_BIND_REQ
@prindex CC_BIND_REQ

@subsubheading Parameters
@vtable @parm
@item cc_addr_length
Indicates the length of the address to bind.
@item cc_addr_offset
Indicates the offset of the address to bind from the beginning of the block.
@item cc_setup_ind
Indicates the maximum number of setup (or continuity check) indications that will be outstanding for the listening
stream.
@item cc_bind_flags
Indicates the options assocated with the bind.  The bind flags can be as follows:
@vtable @pval
@item CC_DEFAULT_LISTENER
When set, this flag specifies that this stream is the "default listener stream."  This stream is used to pass setup
indications (or continuity check requests) for all incoming calls that contain protocol identifiers that are not
bound to any other listener, or when a listener stream with cc_setup_ind value of greater than zero is not found.
Also, the default listener will receive all incoming call indications that contain no user data (i.e., test calls)
and all maintenance indications (i.e., @prim{CC_MAINT_IND}).  Only one default listener stream is allowed per occurrence of
CCI.  An attempt to bind a default listener stream when one is already bound should result in an error (of type
@perr{CCADDRBUSY}).
@item CC_TOKEN_REQUEST
When set, this flag specifies to the CCS provider that the CCS user has requested that a "token" be assigned to the
stream (to be used in the call response message), and the token value be returned to the CCS user via the
@prim{CC_BIND_ACK} primitive.  The token assigned by the CCS provider can then be used by the CCS user in a subsequent
@prim{CC_SETUP_RES} primitive to identify the stream on which the call is to be established.
@item CC_MANAGEMENT
When set, this flag specifies to the CCS provider that this stream is to be used for circuit management indications
for the specified addresses.
@item CC_TEST
When set, this flag specifies to the CCS provider that this stream is to be used for continuity and test call
indications for the specified addresses.
@item CC_MAINTENANCE
When set, this flag specifies to the CCS provider that this stream is to be used for maintenance indications for the
specified addresses.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for address specification:}
@enumerate
@item
The address contained in the primitive as indicated by @parm{cc_addr_length} and @parm{cc_addr_offset} parameters.
The address can be of any ISUP scope.
@item
If the @pval{CC_DEFAULT_LISTENER}
flag is set, the parameters @parm{cc_addr_length} and @parm{cc_addr_offset} should be
coded zero, and will be ignored by the CCS provider.
@end enumerate

@b{Rules for setup indications:}
@enumerate
@item
If the number of setup indications is non-zero, the stream is bound as a listening stream.  Listening streams will
receive all calls, test calls, and continuity tests that are incoming on the address bound.
@itemize @bullet
@item
If the address bound is of scope @pval{ISUP_SCOPE_CT}, only incoming calls on the bound circuit will be delivered to the
listening stream.
@item
If the address bound is of scope @pval{ISUP_SCOPE_CG}, only incoming calls on the bound circuit group will be delivered to
the listening stream.
@item
If the address bound is of scope @pval{ISUP_SCOPE_TG}, only incoming calls on the bound trunk group will be delivered to
the listening stream (this is the normal case).
@item
If the address bound is of scope @pval{ISUP_SCOPE_SR}, only incoming calls on the bound signalling relation (from the
associated remote point code) will be delivered to the listening stream.
@item
If the address bound is of scope @pval{ISUP_SCOPE_SP}, only incoming calls on the bound local signalling point will be
delivered to the listening stream.
@item
If the address bound is of scope @pval{ISUP_SCOPE_DF}, all incoming calls will be delivered to the listening stream.
@item
Streams bound at one scope takes precedence over a stream bound at another scope in the order: circuit, circuit
group, trunk group, signalling relation, signalling point and default scope.
@end itemize
@item
Once a stream has successfully bound as a listening stream, it should be prepared to receive incoming calls, test
calls and continuity tests.
@end enumerate

@b{Rules for bind flags:}
@enumerate
@item
For Q.764 conformance, the @pval{CC_DEFAULT_LISTENER}
will receive all incoming calls, test calls, continuity tests,
circuit management indications and maintenance indications that have no other listening stream.  There can only be
one stream bound with the @pval{CC_DEFAULT_LISTENER}
flag set.
@item
Only one of @pval{CC_DEFAULT_LISTENER},
@pval{CC_MANAGEMENT}, @pval{CC_TEST} and @pval{CC_MAINTENANCE} may be set.
@item
Streams bound with the @pval{CC_MANAGEMENT} flag set will receive only circuit management indications and will not receive
any calls.
@item
Streams bound with the @pval{CC_TEST} flag set will receive only continuity test and test call indications and will not
receive normal calls, circuit management or maintenance indications.
@item
Streams bound with the @pval{CC_MAINTENANCE} flag set will receive only maintenance indications and will not receive any
circuit management indications or calls.
@end enumerate

@subsubsection CC_BIND_ACK
@prindex CC_BIND_ACK

@subsubheading Parameters
@vtable @parm
@item cc_addr_length
Indicates the length of the address to bind.
@item cc_addr_offset
Indicates the offset of the address to bind from the beginning of the block.
@item cc_setup_ind
Indicates the maximum number of setup (or continuity check) indications that will be outstanding for the listening
stream.
@end vtable

@subsubheading Flags

See @prim{CC_BIND_REQ} in this Addendum.

@subsubheading Rules

See @prim{CC_BIND_REQ} in this Addendum.

@subsubsection CC_OPTMGMT_REQ
@prindex CC_OPTMGMT_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsection Call Setup Primitives

@subsubsection CC_SETUP_REQ
@prindex CC_SETUP_REQ

@subsubheading Parameters
@vtable @parm
@item cc_call_type
Specifies the type of call to be set up.
Q.764 conforming CCS providers must support the following call types:
@vtable @pval
@item CC_CALL_TYPE_SPEECH
The call type is speech.  This call type corresponds to a Q.764 transmission medium requirement of @emph{Speech}.
@item CC_CALL_TYPE_64KBS_UNRESTRICTED
The call type is 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.764 transmission
medium requirement of @emph{64 kbit/s Unrestricted Digital Information}.
@item CC_CALL_TYPE_3_1kHZ_AUDIO
The call type is 3.1 kHz audio.  This call type corresponds to a Q.764 transmission medium requirement of @emph{3.1
kHz Audio}.
@item CC_CALL_TYPE_64KBS_PREFERRED
The call type is 64 kbit/s preferred.  This call type corresponds to a Q.764 transmission medium requirement of
@emph{64 kbit/s Preferred}.
@item CC_CALL_TYPE_2x64KBS_UNRESTRICTED
The call type is 2 x 64 kbit/s unrestricted digital information.  This call type corresponds to a Q.764 transmission
medium requirement of @emph{2 x 64 kbit/s Unrestricted Digital Information}.
@item CC_CALL_TYPE_384KBS_UNRESTRICTED
The call type is 384 kbit/s unrestricted digital information.  This call type corresponds to a Q.764 transmission
medium requirement of @emph{384 kbit/s Unrestricted Digital Information}.
@item CC_CALL_TYPE_1536KBS_UNRESTRICTED
The call type is 1536 kbit/s unrestricted digital information.  This call type corresponds to a Q.764 transmission
medium requirement of @emph{1536 kbit/s Unrestricted Digital Information}.
@item CC_CALL_TYPE_1920KBS_UNRESTRICTED
The call type is 1920 kbit/s unrestricted digital information.  This call type corresponds to a Q.764 transmission
medium requirement of @emph{1920 kbit/s Unrestricted Digital Information}.
@end vtable
@item cc_user_ref
Specifies the CCS user call reference to be associated with the call setup request.  The CCS provider will use this
user call reference in any indications given before the @prim{CC_SETUP_CON} primitive is issued.
@item cc_call_flags
Specifies the options associated with the call.  Q.764 conforming CCS providers must support the following flags:

The following flags correspond to bits in the @emph{Nature of Connection Indicators} parameter of Q.763:
@vtable @pval
@item ISUP_NCI_ONE_SATELLITE_CCT
@itemx ISUP_NCI_TWO_SATELLITE_CCT
When one of these flags is set it indicates that either one or two satellite circuits are present in the connection.
Otherwise, it indicates that no satellite circuits are present in the connection.
@item ISUP_NCI_CONT_CHECK_REQUIRED
@itemx ISUP_NCI_CONT_CHECK_PREVIOUS
When one of these flags is set it indicates that either a continuity check is required on the connection, or that a
continuity check was performed on a previous connection.  Otherwise, it indicates that a continuity check is not
required on the connection.
@item ISUP_NCI_OG_ECHO_CONTROL_DEVICE
When set it indicates that an outgoing half echo control device is included on the connection.  Otherwise, it
indicates that no outgoing half echo control device is included on the connection.
@end vtable

The following flags correspond to bits in the @emph{Forward Call Indicators} parameter of Q.763:
@vtable @pval
@item ISUP_FCI_INTERNATIONAL_CALL
When this flag is set, the call is to be treated as an international call.  Otherwise, the call is to be treated as
a national call.
@item ISUP_FCI_PASS_ALONG_E2E_METHOD_AVAILABLE
@itemx ISUP_FCI_SCCP_E2E_METHOD_AVAILABLE
When one of these flags is set, either the pass along end-to-end method is available or the SCCP end-to-end method
is available.  Otherwise, no end-to-end method is available and only link-by-link method is available.
@item ISUP_FCI_INTERWORKING_ENCOUNTERED
When this flag is set, interworking has been encountered on the call.  Otherwise, no interworking has been
encountered on the call.
@item ISUP_FCI_E2E_INFORMATION_AVAILABLE
When this flag is set, end-to-end information is now available.  Otherwise, no end-to-end information is available.
@item ISUP_FCI_ISDN_USER_PART_ALL_THE_WAY
When this flag is set, ISDN User Part has been used all the way on the call.  Otherwise, ISDN User Part has not been
used all the way.
@item ISUP_FCI_ORIGINATING_ACCESS_ISDN
When this flag is set, the originating access is ISDN.  Otherwise, the originating access is non-ISDN.
@item ISUP_FCI_SCCP_CLNS_METHOD_AVAILABLE
@itemx ISUP_FCI_SCCP_CONS_METHOD_AVAILABLE
@itemx ISUP_FCI_SCCP_ALL_METHODS_AVAILABLE
When one of these flags is set, either the connectionless SCCP method is available, the connection oriented SCCP
method is available, or both methods are available.  Otherwise, no SCCP method is indicated as available.
@end vtable

@item cc_cdpn_length
Specifies the length of the called party number.  For Q.764 conforming CCS providers, the format of the called party
number is the format of the Called Party Number parameter (without the parameter type or length octets) as specified
in Q.763.
@item cc_cdpn_offset
Specifies the offset of the called party number from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
If the ISUP user wishes to setup multiple outgoing calls on the same stream, the ISUP user associates a user call
reference with each of the setup requests so that the indication, confirmation and acknowledgement primitives can be 
associated with the specific call setup request.
@item
User call references are only necessary if multiple outgoing calls are to setup at the same time.
@item
User call references only need by valid until a setup confirmation, call reattempt indication, release indication or
call failure indication has been received in response to the setup request.  A setup confirmation will contain a CCS
provider call reference which can be used to distinguish the call from other calls to the CCS provider.
@end enumerate

@b{Rules for call type:}
@enumerate
@item
All Q.764 conforming CCS provider must support the following call types:

 CC_CALL_TYPE_SPEECH,
 CC_CALL_TYPE_64KBS_UNRESTRICTED,
 CC_CALL_TYPE_3_1kHZ_AUDIO, and
 CC_CALL_TYPE_64KBS_PREFERRED.

@item
Support for other call types is optional and implementation-specific.
@end enumerate

@b{Rules for flags:}
@enumerate
@item
Q.764 conforming CCS providers must support all of the flags listed above.
@item
Only one of the following flags may be set:

 ISUP_NCI_ONE_SATELLITE and
 ISUP_NCI_TWO_SATELLITE.

@item
Only one of the following flags may be set:

 @pval{ISUP_NCI_CONT_CHECK_REQUIRED and}
 @pval{ISUP_NCI_CONT_CHECK_PREVIOUS.}

@item
Only one of the following flags may be set:

 @pval{ISUP_FCI_PASS_ALONG_E2E_METHOD_AVAILABLE} and
 @pval{ISUP_FCI_SCCP_E2E_METHOD_AVAILABLE}.

@item
Only one of the following flags may be set,
and only if @pval{ISUP_FCI_SCCP_E2E_METHOD_AVAILABLE} is also set:

 @pval{ISUP_FCI_SCCP_CLNS_METHOD_AVAILABLE},
 @pval{ISUP_FCI_SCCP_CONS_METHOD_AVAILABLE} and
 @pval{ISUP_FCI_SCCP_ALL_METHODS_AVAILABLE}.

@end enumerate

@subsubsection CC_SETUP_IND
@prindex CC_SETUP_IND

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Indicates the CCS provider-assigned call reference associated with the call.
@item cc_call_type
Indicates the type of call to be set up.  For Q.764 conforming CCS providers, the call type can be one of the call
types listed in this addendum under @prim{CC_SETUP_REQ}.
@item cc_call_flags
Indicates the options associated with the call.
Q.764 conforming CCS providers indicate the flags listed in this addendum under @prim{CC_SETUP_REQ}.
@item cc_addr_length
Indicates the length of the call control address (circuit(s)) upon which the call setup is indicated.
@item cc_addr_offset
Indicates the offset of the call control address from the start of the block.
@item cc_cdpn_length
Indicates the length of the called party number.  For Q.764 conforming CCS providers, the format of the called party
number is the format of the Called Party Number parameter (without the parameter type or length octets) as specified
in Q.763.
@item cc_cdpn_offset
Indicates the offset of the called party number from the beginning of the block.
@item cc_opt_length
Indicates the length of the optional parameters associated with the IAM, excluding the end of optional parameters
tag.
@item cc_opt_offset
Indicates the offset of the options from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
The ISUP provider will indicate a unique call reference to the CCS user which is used to associate response and
request primitives with the call setup indication.
@item
Provider call references will always be indicated.
@item
Provider call references are only valid until a call failure or release indication has been issued by the CCS
provider.
@item
Provider call references are only valid for streams upon which the @prim{CC_SETUP_IND} is issued, or for streams upon which the call
was accepted by the CCS user with a @prim{CC_SETUP_RES} primitive.
@item
Provider call references are unique across the provider.
@end enumerate

@b{Rules for call type:}
@enumerate
@item
The rules for call type in section @prim{CC_SETUP_REQ} in this addendum also apply to the @prim{CC_SETUP_IND}.  All Q.764
conforming CCS providers must support the following call types:

 CC_CALL_TYPE_SPEECH,
 CC_CALL_TYPE_64KBS_UNRESTRICTED,
 CC_CALL_TYPE_3_1kHZ_AUDIO, and
 CC_CALL_TYPE_64KBS_PREFERRED.

@item
Support for additional call types is optional and implementation-specific.
@end enumerate

@b{Rules for setup flags:}
@enumerate
@item
The rules for setup flags in section @prim{CC_SETUP_REQ} in this addendum also apply to the
@prim{CC_SETUP_IND}.
@end enumerate

@b{Rules for addresses:}
@enumerate
@item
Call control addresses in the @prim{CC_SETUP_IND} are of scope @pval{ISUP_SCOPE_CT} and identify the circuit(s) upon which the
call setup is indicated.
@item
For multi-rate calls, the call control address indicates the base circuit (numerically lowest Circuit Identification
Code) of the multi-rate call.
@end enumerate

@subsubsection CC_SETUP_RES
@prindex CC_SETUP_RES

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Specifies the call reference of the @prim{CC_SETUP_IND} to which the CCS user is responding.
@item cc_token_value
Specifies the token of a stream upon which to accept the call setup.
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
The call reference specified by the CCS User must be a call reference which was previously indicated by the CCS
provider in an outstanding @prim{CC_SETUP_IND}.  Otherwise the CCS provider will respond with a @prim{CC_ERROR_ACK} primitive with
error @perr{CCBADCLR}.
@end enumerate

@b{Rules for token value:}
@enumerate
@item
If the token is the token value of the stream upon which the corresponding @prim{CC_SETUP_IND} was received, or zero (0),
then the call setup will be accepted on the stream upon which the @prim{CC_SETUP_IND} was received.
@item
If the token is non-zero and different from the listening stream, the call setup will be accepted on the specified
stream.
@end enumerate

@subsubsection CC_SETUP_CON
@prindex CC_SETUP_CON

@subsubheading Parameters
@vtable @parm
@item cc_user_ref
Indicates the CCS user call reference that was specified in the @prim{CC_SETUP_REQ}.  This call reference is used by the
CCS user to associated the @prim{CC_SETUP_CON} with an outstanding @prim{CC_SETUP_REQ} primitive.
@item cc_call_ref
Indicates the CCS provider call reference that is to be associated with the call.  This call reference is used by
the CCS provider to identify the call and is to be used by the CCS user in all subsequent primitives referencing the
call.
@item cc_addr_length
Indicates the length of the identifier of the circuit upon which the call setup is confirmed.
@item cc_addr_offset
Indicates the offset of the identifier from the start of the block.
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
The CCS user call reference will be the same as the call reference provided by the user in the
@prim{CC_SETUP_REQ}
primitive.
@item
The CCS provider call reference will follow the rules of the @prim{CC_SETUP_IND} in this Addendum.
@end enumerate

@b{Rules for addresses:}
@enumerate
@item
The call control address indicated in the @prim{CC_SETUP_CON} is a
@pval{ISUP_SCOPE_CT} (circuit scoped) call control address which identifies the circuit(s) upon which the outgoing call
will be connected.
@item
For multi-rate calls, the call control address specifies the base circuit (lowest numerical Circuit Identification
Code) for the multi-rate call.
@end enumerate

@subsubsection CC_CALL_REATTEMPT_IND
@prindex CC_CALL_REATTEMPT_IND

@subsubheading Parameters
@vtable @parm
@item cc_user_ref
Indicates the CCS user call reference for the call.  This reference identifies the corresponding
@prim{CC_SETUP_REQ}
primitives to the CCS user for which the call reattempt need be performed.
@item cc_reason
Indicates the reason for the reattempt.  The reason can be one of the following values:
@vtable @pval
@item ISUP_REATTEMPT_DUAL_SEIZURE
Indicates that the circuit was seized by a controlling exchange during the initial setup of the call (i.e, before
any backward message was received).
@item ISUP_REATTEMPT_RESET
Indicates that the circuit was reset during the initial setup of the call (i.e, before any backward message was
received).
@item ISUP_REATTEMPT_BLOCKING
Indicates that the circuit was blocked during the initial setup of the call (i.e, before any backward message was
received).
@item ISUP_REATTEMPT_T24_TIMEOUT
Indicates that COT failure occurred on the circuit (due to T24 timeout).
@item ISUP_REATTEMPT_UNEXPECTED
Indicates that an unexpected message was received for the call during the initial setup of the call (i.e, before any
backward message was received).
@item ISUP_REATTEMPT_COT_FAILURE
Indicates that COT failed on the circuit (due to transmission of COT message indicating failure).
@item ISUP_REATTEMPT_CIRCUIT_BUSY
Indicates that the specified circuit was busy.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
The CCS user call reference is a call reference associated with an outstanding @prim{CC_SETUP_REQ} primitive to which the
CCS provider is responding.
@end enumerate

@b{Rules for reason:}
@enumerate
@item
The Q.764 conforming CCS provider will provide one of the reasons listed above.
@item
The ISUP_REATTEMPT_DUAL_SEIZURE reason will only be indicated if the CCS user represents a non-controlling exchange
for the associated trunk group.
@item
The ISUP_REATTEMPT_T24_TIMEOUT reason will only be indicated if the outgoing call includes a continuity test and a
positive @prim{CC_CONT_REPORT_REQ} was not issued to the CCS provider by a test stream within T24.
@item
The ISUP_REATTEMPT_COT_FAILURE reason will only be indicated if the outgoing call includes a continuity test and a
negative @prim{CC_CONT_REPORT_REQ} was issued to the CCS provider by a test stream within T24.
@item
The ISUP_REATTEMPT_CIRCUIT_BUSY reason will only be indicated if the stream issuing the @prim{CC_SETUP_REQ} primitive is
bound to a circuit (@pval{ISUP_SCOPE_CT}) and the circuit is busy with another call.
@end enumerate

@subsubsection CC_SETUP_COMPLETE_REQ
@prindex CC_SETUP_COMPLETE_REQ

@subsubheading Rules

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if a CCS provider
conforming to Q.764 receives a @prim{CC_SETUP_COMPLETE_REQ} for a call reference in the CCS_ANSWERED state
(CCS_ICC_ANSWERED), the CCS provider will ignore the primitive.

@subsubsection CC_SETUP_COMPLETE_IND
@prindex CC_SETUP_COMPLETE_IND

@subsubheading Rules

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if a CCS provider
conforming to Q.764 issues a @prim{CC_SETUP_COMPLETE_IND} for a call reference in the CCS_ANSWERED state, the CCS user may
ignore the primitive.

@subsection Continuity Check Phase

@subsubsection CC_CONT_CHECK_REQ
@prindex CC_CONT_CHECK_REQ

@subsubheading Parameters
@vtable @parm
@item cc_addr_length
Specifies the length of the circuit test address (circuit) upon which the continuity check is to be performed.
@item cc_addr_offset
Specifies the offset of the circuit test address from the start of the block.
@end vtable

@subsubheading Rules

@b{Rules for addresses:}
@enumerate
@item
The parameter @parm{cc_addr_length} cannot be zero: i.e, an address must be provided or the CCS provider should
respond with @prim{CC_ERROR_ACK} with an error of @perr{CCNOADDR}.
@item
The address provided must be of scope @pval{ISUP_SCOPE_CT} and must provide the identifier of the circuit upon which the
CCS user is requesting a continuity check.
@item
The specified circuit identifier must be equipped else the CCS provider should response with
@prim{CC_ERROR_ACK} and an
error of @perr{CCBADADDR}.
@end enumerate

@subsubsection CC_CONT_CHECK_IND
@prindex CC_CONT_CHECK_IND

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Indicates the CCS provider call reference.
@item cc_addr_length
Indicates the length of the identifier of the circuit upon which the continuity check is to be performed.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item

@end enumerate
@b{Rules for addresses:}
@enumerate
@item
The parameter @parm{cc_addr_length} cannot be zero: i.e, an address must be provided or the CCS provider should
respond with @prim{CC_ERROR_ACK} with an error of @perr{CCNOADDR}.
@item
The address provided must be of scope @pval{ISUP_SCOPE_CT} and must provide the identifier of the circuit upon which the
CCS user is requesting a continuity check.
@item
The specified circuit test address (circuit identifier) must be equipped else the CCS provider should response with
@prim{CC_ERROR_ACK} and an error of @perr{CCBADADDR}.
@end enumerate

@subsubsection CC_CONT_TEST_REQ
@prindex CC_CONT_TEST_REQ

This primitive is only supported when the Loop Back Acknowledgement is used as a national option under Q.764.  For
compatibility with CCS providers not supporting the national option, if such a CCS provider receives a
@prim{CC_CONT_TEST_REQ} while waiting for a @prim{CC_CONT_REPORT_IND}, the CCS provider should silently discard the primitive.

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Specifies the CCS provider call reference.
@item cc_addr_length
Indicates the length of the call control address (@pval{ISUP_SCOPE_CT} circuit identifier) upon which the continuity check is to
be performed.
@item cc_addr_offset
Indicates the offset of the call control address from the start of the block.
@end vtable

@subsubheading Rules

@b{Rules for addresses:}
@enumerate
@item
The parameter @parm{cc_addr_length} cannot be zero: i.e, an address must be provided or the CCS provider should
respond with @prim{CC_ERROR_ACK} with an error of @perr{CCNOADDR}.
@item
The address provided must be the identifier of the circuit upon which the CCS user is requesting a continuity check.
@item
The specified circuit identifier must be equipped else the CCS provider should response with
@prim{CC_ERROR_ACK} and an
error of @perr{CCBADADDR}.
@end enumerate

@subsubsection CC_CONT_TEST_IND
@prindex CC_CONT_TEST_IND

This primitive is only supported when the Loop Back Acknowledgement is used as a national option under Q.764.  For
compatibility with CCS providers not supporting the national option, such a CCS provider will issue a
@prim{CC_CONT_TEST_IND} in response to a @prim{CC_CONT_CHECK_REQ} following the @prim{CC_OK_ACK}.

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Specifies the CCS provider call reference.
@item cc_addr_length
Specifies the length of the identifier of the circuit upon which the continuity check is to be performed.
@item cc_addr_offset
Specifies the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
The CCS provider assigned call reference is used to associate an outstanding continuity test indication
(CC_CONT_CHECK_IND or call setup indication @prim{CC_SETUP_IND} including a continuity test
(@pval{ISUP_NCI_CONT_CHECK_REQUIRED}).
@end enumerate

@b{Rules for addresses:}
@enumerate
@item
The parameter @parm{cc_addr_length} cannot be zero: i.e, an address must be provided or the CCS provider should
respond with @prim{CC_ERROR_ACK} with an error of @perr{CCNOADDR}.
@item
The address provided must be the identifier of the circuit upon which the CCS user is requesting a continuity check.
@item
The specified circuit identifier must be equipped else the CCS provider should response with
@prim{CC_ERROR_ACK} and an
error of @perr{CCBADADDR}.
@end enumerate

@subsubsection CC_CONT_REPORT_REQ
@prindex CC_CONT_REPORT_REQ

@subsubheading Parameters
@vtable @parm
@item cc_user_ref
Specifies the CCS User assigned call reference.
@item cc_call_ref
Specifies the CCS Provider assigned call reference.
@item cc_result
Specifies the result of the continuity test, whether success or failure.  For Q.764 conforming CCS provider, the
result parameter can be one of the following values:
@vtable @pval
@item ISUP_COT_SUCCESS
Indicates that the continuity check test was successful.
@item ISUP_COT_FAILURE
Indicates that the continuity check test failed.
@end vtable
@item cc_addr_length
Specifies the length of the identifier of the circuit upon which the continuity check is to be performed.
@item cc_addr_offset
Specifies the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@b{Rules for addresses:}
@enumerate
@item
The parameter @parm{cc_addr_length} cannot be zero: i.e, an address must be provided or the CCS provider should
respond with @prim{CC_ERROR_ACK} with an error of @perr{CCNOADDR}.
@item
The address provided must be the identifier of the circuit upon which the CCS user is requesting a continuity check.
@item
The specified circuit identifier must be equipped else the CCS provider should response with
@prim{CC_ERROR_ACK} and an
error of @perr{CCBADADDR}.
@end enumerate

@subsubsection CC_CONT_REPORT_IND
@prindex CC_CONT_REPORT_IND

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Indicates the CCS provider assigned call reference.
@item cc_result
Indicates the result of the continuity test, whether success or failure.  For Q.764 conforming CCS provider, the
result parameter can be one of the following values:
@vtable @pval
@item ISUP_COT_SUCCESS
Indicates that the continuity check test was successful.
@item ISUP_COT_FAILURE
Indicates that the continuity check test failed.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for call reference:}
@enumerate
@item
@end enumerate

@subsection Call Establishment Primitives

@subsubsection CC_MORE_INFO_REQ
@prindex CC_MORE_INFO_REQ

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive is not directly supported by Q.764 conforming CCS providers.  For compatibility with Q.931 conforming
CCS providers, if the Q.764 conforming CCS provider receives a @prim{CC_MORE_INFO_REQ} in state
@psta{CCS_WRES_SIND}, it should
@stindex CCS_WRES_SIND
invoke any interworking procedures and silently discard the primitive.
@end enumerate

@subsubsection CC_MORE_INFO_IND
@prindex CC_MORE_INFO_IND

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive may optionally be issued by a Q.764 conforming CCS provider in the @emph{overlap} signalling mode,
if the appropriate timer has expired and the CCS provider has not received an indication that the provided address
is complete.
@end enumerate

@subsubsection CC_INFORMATION_REQ
@prindex CC_INFORMATION_REQ

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Specifies the CCS provider assigned call reference for the call.
@item cc_subn_length
Specifies the length of the subsequent number.  For Q.764 conforming CCS providers, the format of the called party
address is the format of the Subsequent Number parameter (without the parameter type or length octets) as specified
in Q.763.
@item cc_subn_offset
Specifies the offset of the subsequent number from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive will only be issued before any @prim{CC_PROCEEDING_IND}, @prim{CC_ALERTING_IND}, @prim{CC_PROGRESS_IND}, or @prim{CC_IBI_IND} has
occurred on the stream while in the @psta{CCS_WCON_SREQ} state.  If not, the CCS provider should respond with a
@stindex CCS_WCON_SREQ
@prim{CC_ERROR_ACK} primitive with error @perr{CCOUTSTATE}.
@item
This primitive must not be issued if the preceding @prim{CC_SETUP_REQ} contained a called party address which was complete
(i.e, contains a ST code following the digits).  If it is, the CCS provider should respond with a @prim{CC_ERROR_ACK} with
error @perr{CCBADADDR}.
@item
This primitive must not be issued  if the trunk group or circuit to which the stream is bound is configured for
@emph{en bloc} operation.  If it is, the CCS provider should respond with a @prim{CC_ERROR_ACK} with error @perr{CCNOTSUPP}.
@end enumerate

@subsubsection CC_INFORMATION_IND
@prindex CC_INFORMATION_IND

@subsubheading Parameters
@vtable @parm
@item cc_call_ref
Indicates the CCS provider assigned call reference.
@item cc_subn_length
Indicates the length of the subsequent number.  For Q.764 conforming CCS providers, the format of the subsequent
number is the format of the Subsequent Number parameter (without the parameter type or length octets) as specified
in Q.763.
@item cc_subn_offset
Indicates the offset of the subsequent number from the beginning of the block.
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive will only be issued by the CCS provider before any @prim{CC_PROCEEDING_REQ},
@prim{CC_ALERTING_REQ},
@prim{CC_PROGRESS_REQ}, or @prim{CC_IBI_REQ} has been received in state @psta{CCS_WCON_SREQ}.
@stindex CCS_WCON_SREQ
@item
This primitive will not be issued by the CCS provider if the preceding @prim{CC_SETUP_REQ} contained a complete called
party address (i.e, contains an ST code following the digits), or if the trunk group or circuit is configured for
@emph{en bloc} operation.
@end enumerate

@subsubsection CC_INFO_TIMEOUT_IND
@prindex CC_INFO_TIMEOUT_IND

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
If the Q.764 conforming CCS provider encounters interworking on a call and is not expecting an address complete
message, and timer T11 expires, the CCS provider will issue this primitive to the CCS user.
@item
Upon receipt of this primitive, it is the CCS user's responsibility to determine whether the address digits are
sufficient and to issue a @prim{CC_SETUP_RES} or @prim{CC_REJECT_REQ} primitive.
@end enumerate

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS user
receives a @prim{CC_INFO_TIMEOUT_IND}

@subsubsection CC_PROCEEDING_REQ
@prindex CC_PROCEEDING_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Specifies the options associated with the call.
Indicates the flags associated with the primitive.  For Q.764 conforming CCS providers, call flags can be an of the following:
Q.764 conforming CCS provider must support the following flags:

The following flags correspond to bits in the Backward Call Indicators parameter of Q.763:
@vtable @pval
@item ISUP_BCI_NO_CHARGE
@itemx ISUP_BCI_CHARGE
When one of these flags is set, it indicates that the call is not to be charged, or the call is to be charged.
Otherwise, it indicates that there is no indication with regard to charging.
@item ISUP_BCI_SUBSCRIBER_FREE
@itemx ISUP_BCI_CONNECT_FREE
When one of these flags is set, it indicates that the terminating subscriber is free, or that the connection is
free.  Otherwise, no indication is given.
@item ISUP_BCI_ORDINARY_SUBSCRIBER
@itemx ISUP_BCI_PAYPHONE
When one of these flags is set, it indicates that the call has terminated to an ordinary subscriber, or that the
call has terminated to a pay phone.
@item ISUP_BCI_PASS_ALONG_E2E_METHOD_AVAILABLE
@itemx ISUP_BCI_SCCP_E2E_METHOD_AVAILABLE
When one of these flags is set, either the pass along end-to-end method is available, or the SCCP end-to-end method
is available.  Otherwise, no end-to-end method is available and only link-by-link method is available.
@item ISUP_BCI_INTERWORKING_ENCOUNTERED
When this flag is set, interworking has been encountered on the call.  Otherwise, to interworking has been
encountered on the call.
@item ISUP_BCI_E2E_INFORMATION_AVAILABLE
When this flag is set, end-to-end information is now available.  Otherwise, no end-to-end information is available.
@item ISUP_BCI_ISDN_USER_PART_ALL_THE_WAY
When this flag is set, ISDN User Part has been used all the way on the call, Otherwise, ISDN User Part has not be
used all the way.
@item ISUP_BCI_HOLDING_REQUESTED
When this flag is set, holding is requested.  Otherwise, holding is not requested.
@item ISUP_BCI_TERMINATING_ACCESS_ISDN
When this flag is set, the terminating access is ISDN.  Otherwise, the terminating access is non-ISDN.
@item ISUP_BCI_IC_ECHO_CONTROL_DEVICE
When set, this flag indicates that an incoming half echo control device is included on the connection.  Otherwise,
it indicates that no incoming half echo control device is included in the connection.
@item ISUP_BCI_SCCP_CLNS_METHOD_AVAILABLE
@itemx ISUP_BCI_SCCP_CONS_METHOD_AVAILABLE
@itemx ISUP_BCI_SCCP_ALL_METHODS_AVAILABLE
When one of these flags is set, either the connectionless SCCP method is available, the connection oriented SCCP
method is available, or both methods are available.  Otherwise, no SCCP method is indicated as available.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive can only be issued by the CCS user before any @prim{CC_ALERTING_REQ}, @prim{CC_PROGRESS_REQ} or @prim{CC_IBI_REQ} has been
issued while in state @psta{CCS_WRES_SIND}.
@stindex CCS_WRES_SIND
@end enumerate

@subsubsection CC_PROCEEDING_IND
@prindex CC_PROCEEDING_IND

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive will only be issued by the CCS provider before any @prim{CC_ALERTING_IND}, @prim{CC_PROGRESS_IND} or @prim{CC_IBI_IND} has
been issued while in state @psta{CCS_WCON_SREQ}.
@stindex CCS_WCON_SREQ
@end enumerate

@subsubsection CC_ALERTING_REQ
@prindex CC_ALERTING_REQ

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive can only be issued by the CCS user before any @prim{CC_PROGRESS_REQ} or @prim{CC_IBI_REQ} has been issued while in
state @psta{CCS_WRES_SIND}.
@stindex CCS_WRES_SIND
@end enumerate

@subsubsection CC_ALERTING_IND
@prindex CC_ALERTING_IND

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive will only be issued by the CCS provider before any @prim{CC_PROGRESS_IND} or @prim{CC_IBI_IND} has been issued
while in state @psta{CCS_WCON_SREQ}.
@stindex CCS_WCON_SREQ
@end enumerate

@subsubsection CC_PROGRESS_REQ
@prindex CC_PROGRESS_REQ

@subsubheading Parameters
@vtable @parm
@item cc_event
Indicates the progress event.  For Q.764 conforming CCS providers, this can be one of the following:
@vtable @pval
@item ISUP_EVNT_ALERTING
Indicates that the called party is being alerted.  This event is indicated only if a CC_CALL_PROCEEDING_IND
primitive has already been received.
@item ISUP_EVNT_PROGRESS
Indicates that the call is progressing with the specified optional parameters.
@item ISUP_EVNT_IBI
This event is indicated only by the @prim{CC_IBI_IND} primitive and will not appear here.
@item ISUP_EVNT_CALL_FORWARDED_ON_BUSY
This event indicates that the call has been forwarded on busy and the optional parameters (if any) contain the
attributes of the forwarding (e.g., redirecting number, etc.).
@item ISUP_EVNT_CALL_FORWARDED_ON_NO_ANSWER
This event indicates that the call has been forwarded on no answer and the optional parameters (if any) contain the
attributes of the forwarding (e.g., redirecting number, etc.).
@item ISUP_EVNT_CALL_FORWARDED_UNCONDITIONAL
This event indicates that the call has been forwarded unconditionally and the optional parameters (if any) contain
the attributes of the forwarding (e.g., redirecting number, etc.).
@end vtable
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_EVNT_PRESENTATION_RESTRICTED
When set, this flag indicates that the event indication is not to be presented to the caller.  Otherwise, the event
may be presented to the caller.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive can only be issued by the CCS user before any @prim{CC_IBI_REQ} has been issued while in state
@psta{CCS_WRES_SIND}.
@stindex CCS_WRES_SIND
@end enumerate

@b{Rules for progress event:}
@enumerate
@item
Q.764 conforming CCS providers must support the complete list of progress events listed above.
@item
When this primitive is issued with the event ISUP_EVNT_ALERTING, it must follow the rules for the primitive
@prim{CC_ALERTING_REQ}.
@item
When this primitive is issued with the event ISUP_EVNT_IBI, it must follow the rules for the primitive @prim{CC_IBI_REQ}.
@end enumerate

@b{Rules for progress flags:}
@enumerate
@item
The flag ISUP_EVNT_PRESENTATION_RESTRICTED cannot be set when the event is ISUP_EVNT_ALERTING, ISUP_EVNT_PROGRESS or
ISUP_EVNT_IBI.
@end enumerate

@subsubsection CC_PROGRESS_IND
@prindex CC_PROGRESS_IND

@subsubheading Parameters
@vtable @parm
@item cc_event
Indicates the progress event.  The event can be any of the events listed in this addendum under
@prim{CC_PROGRESS_REQ}.
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_EVNT_PRESENTATION_RESTRICTED
When set, this flag indicates that the event indication is not to be presented to the caller.  Otherwise, the event
may be presented to the caller.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
This primitive will only be issued by the CCS provider before any @prim{CC_IBI_IND} has been issued while in state
@psta{CCS_WCON_SREQ}.
@stindex CCS_WCON_SREQ
@end enumerate

@b{Rules for progress event:}
@enumerate
@item
Q.764 conforming CCS providers must support the complete list of progress events listed above.
@item
This primitive will not be issued by the CCS provider with event ISUP_EVNT_ALERTING or event ISUP_EVNT_IBI: instead,
a @prim{CC_ALERTING_IND} or @prim{CC_IBI_IND} event will be issued.
@end enumerate

@b{Rules for progress flags:}
@enumerate
@item
The flag ISUP_EVNT_PRESENTATION_RESTRICTED cannot be set when the vent is ISUP_EVNT_PROGRESS.
@end enumerate

@subsubsection CC_IBI_REQ
@prindex CC_IBI_REQ

@subsubheading Rules

@subsubsection CC_IBI_IND
@prindex CC_IBI_IND

@subsubheading Rules

@subsection Call Established Primitives

@subsubsection CC_SUSPEND_REQ
@prindex CC_SUSPEND_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Specifies options associated with the suspend.
@vtable @pval
@item CC_SUSRES_NETWORK_INITIATED
When this flag is set, it indicates that the suspend was network originated.  When this flag is not set, it
indicates that the suspend was ISDN subscriber initiated.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
For Q.764 conforming CCS providers, suspend can be requested by independently either via local provider or the
remote provider.  A call can be:
@itemize @bullet
@item
Not Suspended
@item
Locally Suspended
@item
Remotely Suspended
@item
Locally and Remotely Suspended
@end itemize
@item
Requests to locally suspend a call which is already locally suspended should be ignored by the CCS provider.
@end enumerate

@subsubsection CC_SUSPEND_IND
@prindex CC_SUSPEND_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Specifies options associated with the suspend.
@vtable @pval
@item CC_SUSRES_NETWORK_INITIATED
When this flag is set, it indicates that the suspend was network originated.  When this flag is not set, it
indicates that the suspend was ISDN subscriber initiated.
@end vtable
@end vtable

@subsubheading Rules

@b{Rules for issuing primitive:}
@enumerate
@item
For Q.764 conforming CCS providers, suspend can be requested by independently either via local provider or the
remote provider.  A call can be:
@itemize @bullet
@item
Not Suspended
@item
Locally Suspended
@item
Remotely Suspended
@item
Locally and Remotely Suspended
@end itemize
@item
Indications of remote suspension of a call which is already remotely suspended will not be issued by the CCS
provider.
@end enumerate

@subsubsection CC_SUSPEND_RES
@prindex CC_SUSPEND_RES

@subsubheading Rules

@b{Rules for issuing primitive:}

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS
provider receives a @prim{CC_SUSPEND_RES} in the CCS_WRES_SUSIND or @psta{CCS_SUSPENDED} states, the CCS provider should ignore
@stindex CCS_SUSPENDED
the @prim{CC_SUSPEND_RES} primitive and move directly to the @psta{CCS_SUSPENDED} state if it has not already done so.
@stindex CCS_SUSPENDED

@subsubsection CC_SUSPEND_REJECT_REQ
@prindex CC_SUSPEND_REJECT_REQ

@subsubheading Rules

@b{Rules for issuing primitive:}

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS
provider receives a @prim{CC_SUSPEND_REJECT_REQ} in the CCS_WRES_SUSIND or @psta{CCS_SUSPENDED} states, the CCS provider should
@stindex CCS_SUSPENDED
reply with a @prim{CC_ERROR_ACK} primitive with error @prim{CCNOTSUPP}.

@subsubsection CC_RESUME_REQ
@prindex CC_RESUME_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Specifies options associated with the resume.
@vtable @pval
@item CC_SUSRES_NETWORK_INITIATED
When this flag is set, it indicates that the resume was network originated.  When this flag is not set, it indicates
that the resume was ISDN subscriber initiated.
@end vtable
@end vtable

@subsubheading Rules

@subsubsection CC_RESUME_IND
@prindex CC_RESUME_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Specifies options associated with the resume.
@vtable @pval
@item CC_SUSRES_NETWORK_INITIATED
When this flag is set, it indicates that the resume was network originated.  When this flag is not set, it indicates
that the resume was ISDN subscriber initiated.
@end vtable
@end vtable

@subsubheading Rules

@subsubsection CC_RESUME_RES
@prindex CC_RESUME_RES

@subsubheading Rules

@b{Rules for issuing primitive:}

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS
provider receives a @prim{CC_RESUME_RES} in the CCS_WRES_SUSIND or CCS_ANSWERED states, the CCS provider should ignore the
@prim{CC_RESUME_RES} primitive and move directly to the CCS_RESUMEED state if it has not already done so.

@subsubsection CC_RESUME_REJECT_REQ
@prindex CC_RESUME_REJECT_REQ

@subsubheading Rules

@b{Rules for issuing primitive:}

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS
provider receives a @prim{CC_RESUME_REJECT_REQ} in the CCS_WRES_SUSIND or CCS_ANSWERED states, the CCS provider should
reply with a @prim{CC_ERROR_ACK} primitive with error @prim{CCNOTSUPP}.

@subsection Call Termination Primitives

@subsubsection CC_REJECT_REQ
@prindex CC_REJECT_REQ

@subsubheading Rules

@b{Rules for issuing primitive:}

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS
provider receives a @prim{CC_REJECT_REQ} in the @psta{CCS_WRES_SIND} (CCS_ICC_WAIT_COT or CCS_ICC_WAIT_ACM) states, the provider
@stindex CCS_WRES_SIND
should perform an automatic release procedure and move to the CCS_WAIT_RLC state.

@subsubsection CC_CALL_FAILURE_IND
@prindex CC_CALL_FAILURE_IND

@subsubheading Parameters
@vtable @parm
@item cc_cause
Indicates the cause of the failure.  The cc_cause can have one of the following values:
@vtable @pval
@item ISUP_CALL_FAILURE_COT_FAILURE
Indicates that the continuity check on the circuit failed.  This applies to incoming calls only.
@item ISUP_CALL_FAILURE_RESET
@itemx ISUP_CALL_FAILURE_RECV_RLC
Indicates that the circuit was not completely released by the distant end.  This applies to incoming calls only.
@item ISUP_CALL_FAILURE_BLOCKING
Indicates that the circuit was blocked during call setup.  This applies to incoming calls only.
@item ISUP_CALL_FAILURE_T2_TIMEOUT
@itemx ISUP_CALL_FAILURE_T3_TIMEOUT
@itemx ISUP_CALL_FAILURE_T6_TIMEOUT
Indicates that the call was suspended beyond the allowable period.  This applies to all established calls.
@item ISUP_CALL_FAILURE_T7_TIMEOUT
Indicates that there was no response to the call setup request.  This applies to outgoing calls only.
@item ISUP_CALL_FAILURE_T8_TIMEOUT
Indicates that the call failed waiting for a continuity check report from the distant end.  This applies to incoming
calls only.
@item ISUP_CALL_FAILURE_T9_TIMEOUT
Indicates that the call failed while waiting for the distant end to answer.  This applies to outgoing calls only.
@item ISUP_CALL_FAILURE_T35_TIMEOUT
Indicates that additional information (digits) were not received from the caller within a sufficient period.  This
applies to incoming calls only.
@item ISUP_CALL_FAILURE_T38_TIMEOUT
Indicates that the call was suspended beyond the allowable period.  This applies to all established calls.
@item ISUP_CALL_FAILURE_CIRCUIT_BUSY
@end vtable
@end vtable

@subsubheading Rules

@subsubsection CC_DISCONNECT_REQ
@prindex CC_DISCONNECT_REQ

@subsubheading Rules

For compatibility between CCS providers conforming to Q.931 and CCS providers conforming to Q.764, if the CCS
provider receives a @prim{CC_DISCONNECT_REQ}, the provider should respond with @prim{CC_ERROR_ACK} with the error @prim{CCNOTSUPP}.

@subsubsection CC_RELEASE_REQ
@prindex CC_RELEASE_REQ

@subsubheading Parameters
@vtable @parm
@item cc_cause
Indicates the cause of the release.  Cause can be one of the following values:
@vtable @pval
@item CC_CAUS_UNALLOCATED_NUMBER
(no description)
@item CC_CAUS_NO_ROUTE_TO_TRANSIT_NETWORK
(no description)
@item CC_CAUS_NO_ROUTE_TO_DESTINATION
(no description)
@item CC_CAUS_SEND_SPECIAL_INFO_TONE
(no description)
@item CC_CAUS_MISDIALLED_TRUNK_PREFIX
(no description)
@item CC_CAUS_PREEMPTION
(no description)
@item CC_CAUS_PREEMPTION_CCT_RESERVED
(no description)
@item CC_CAUS_NORMAL_CALL_CLEARING
(no description)
@item CC_CAUS_USER_BUSY
(no description)
@item CC_CAUS_NO_USER_RESPONDING
(no description)
@item CC_CAUS_NO_ANSWER
(no description)
@item CC_CAUS_SUBSCRIBER_ABSENT
(no description)
@item CC_CAUS_CALL_REJECTED
(no description)
@item CC_CAUS_NUMBER_CHANGED
(no description)
@item CC_CAUS_REDIRECT
(no description)
@item CC_CAUS_OUT_OF_ORDER
(no description)
@item CC_CAUS_ADDRESS_INCOMPLETE
(no description)
@item CC_CAUS_FACILITY_REJECTED
(no description)
@item CC_CAUS_NORMAL_UNSPECIFIED
(no description)
@item CC_CAUS_NO_CCT_AVAILABLE
(no description)
@item CC_CAUS_NETWORK_OUT_OF_ORDER
(no description)
@item CC_CAUS_TEMPORARY_FAILURE
(no description)
@item CC_CAUS_SWITCHING_EQUIP_CONGESTION
(no description)
@item CC_CAUS_ACCESS_INFO_DISCARDED
(no description)
@item CC_CAUS_REQUESTED_CCT_UNAVAILABLE
(no description)
@item CC_CAUS_PRECEDENCE_CALL_BLOCKED
(no description)
@item CC_CAUS_RESOURCE_UNAVAILABLE
(no description)
@item CC_CAUS_NOT_SUBSCRIBED
(no description)
@item CC_CAUS_OGC_BARRED_WITHIN_CUG
(no description)
@item CC_CAUS_ICC_BARRED WITHIN_CUG
(no description)
@item CC_CAUS_BC_NOT_AUTHORIZED
(no description)
@item CC_CAUS_BC_NOT_AVAILABLE
(no description)
@item CC_CAUS_INCONSISTENCY
(no description)
@item CC_CAUS_SERVICE_OPTION_NOT_AVAILABLE
(no description)
@item CC_CAUS_BC_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_FACILITY_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_RESTRICTED_BC_ONLY
(no description)
@item CC_CAUS_SERIVCE_OPTION_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_USER_NOT_MEMBER_OF_CUG
(no description)
@item CC_CAUS_INCOMPATIBLE_DESTINATION
(no description)
@item CC_CAUS_NON_EXISTENT_CUG
(no description)
@item CC_CAUS_INVALID_TRANSIT_NTWK_SELECTION
(no description)
@item CC_CAUS_INVALID_MESSAGE
(no description)
@item CC_CAUS_MESSAGE_TYPE_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_PARAMETER_NOT_IMPLEMENTED
(no description)
@item CC_CAUS_RECOVERY_ON_TIMER_EXPIRY
(no description)
@item CC_CAUS_PARAMETER_PASSED_ON
(no description)
@item CC_CAUS_MESSAGE_DISCARDED
(no description)
@item CC_CAUS_PROTOCOL_ERROR
(no description)
@item CC_CAUS_INTERWORKING
(no description)
@item CC_CAUS_UNALLOCATED_DEST_NUMBER
(no description)
@item CC_CAUS_UNKNOWN_BUSINESS_GROUP
(no description)
@item CC_CAUS_EXCHANGE_ROUTING_ERROR
(no description)
@item CC_CAUS_MISROUTED_CALL_TO_PORTED_NUMBER  26
(no description)
@item CC_CAUS_LNP_QOR_NUMBER_NOT_FOUND
(no description)
@item CC_CAUS_PREEMPTION
(no description)
@item CC_CAUS_PRECEDENCE_CALL_BLOCKED
(no description)
@item CC_CAUS_CALL_TYPE_INCOMPATIBLE
(no description)
@item CC_CAUS_GROUP_RESTRICTIONS
(no description)
@end vtable
@end vtable

@subsubheading Rules

@subsubsection CC_RELEASE_IND
@prindex CC_RELEASE_IND

@subsubheading Parameters
@vtable @parm
@item cc_cause
Indicates the cause of the release.  Cause can be one of the cause value listed in this addendum under
@prim{CC_RELEASE_REQ}.
@end vtable

@subsubheading Rules

@subsection Management Primitives

@subsubsection CC_RESTART_REQ
@prindex CC_RESTART_REQ

@subsubheading Rules

For compatibility between CCS providers conforming to Q.931 and CCS provider conforming to Q.764, if the CCS
provider conforming to Q.764 receives a @prim{CC_RESTART_REQ}, the provider should respond with @prim{CC_ERROR_ACK} with the error
@prim{CCNOTSUPP}.

@subsubsection CC_RESET_REQ
@prindex CC_RESET_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_RESET_IND
@prindex CC_RESET_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_RESET_RES
@prindex CC_RESET_RES

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_RESET_CON
@prindex CC_RESET_CON

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_BLOCKING_REQ
@prindex CC_BLOCKING_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error @perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_BLOCKING_IND
@prindex CC_BLOCKING_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error @perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_BLOCKING_RES
@prindex CC_BLOCKING_RES

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error
@perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_BLOCKING_CON
@prindex CC_BLOCKING_CON

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error
@perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_UNBLOCKING_REQ
@prindex CC_UNBLOCKING_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error
@perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_UNBLOCKING_IND
@prindex CC_UNBLOCKING_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error
@perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_UNBLOCKING_RES
@prindex CC_UNBLOCKING_RES

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error
@perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_UNBLOCKING_CON
@prindex CC_UNBLOCKING_CON

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@item ISUP_MAINTENANCE_ORIENTED
@itemx ISUP_HARDWARE_FAILURE_ORIENTED
When one of these flags is set it indicates that either maintenance oriented or hardware failure oriented blocking
is to be performed.  If both or neither of these flags are set, the primitive will fail with error
@perr{CCBADFLAG}.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_QUERY_REQ
@prindex CC_QUERY_REQ

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_QUERY_IND
@prindex CC_QUERY_IND

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_QUERY_RES
@prindex CC_QUERY_RES

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@subsubsection CC_QUERY_CON
@prindex CC_QUERY_CON

@subsubheading Parameters
@vtable @parm
@item cc_flags
Indicates the options flags.
@vtable @pval
@item ISUP_GROUP
When set, this flag indicates that the operation is to be performed on a group of call control addresses and that
any circuit identifier in the specified call control address is to be interpreted by the CCS provider as a circuit
group identifier.
@end vtable
@item cc_addr_length
Indicates the length of the address which consists of a circuit identifier.
@item cc_addr_offset
Indicates the offset of the address from the start of the block.
@end vtable

@subsubheading Rules

@section Q.764 Header File Listing

@noindent
@smallformat
@verbatiminclude isupi.h
@end smallformat

@page
@node Addendum for ETSI EN 300 356-1 V3.2.2 Conformance
@unnumbered Addendum for ETSI EN 300 356-1 V3.2.2 Conformance

This addendum describes the formats and rules that are specific to ETSI EN 300 356-1 V3.2.2.  The addendum must be used
along with the generic CCI as defined in the main document, and the Q.764 conformance defined in @ref{Addendum for Q.764
Conformance}.  when implementing a CCS provider that will be configured with the EN 300 356-1 call processing layer.

@section Primitives and Rules for ETSI EN 300 356-1 V3.2.2 Conformance

The following are the additional rules that apply to the CCI primitives for ETSI EN 300 356-1 V3.2.2 compatibility.

@subsection Local Management Primitives

@subsection Call Setup Primitives

@subsubsection CC_SETUP_REQ
@prindex CC_SETUP_REQ

@subsubheading Parameters

@subsubheading Flags

@subsubheading Rules

@subsubsection CC_SETUP_IND
@prindex CC_SETUP_IND

@subsubheading Parameters
@vtable @parm
@item cc_call_type
Specifies the call type to be set up.  In addition to Q.764 values, for EN 300 356-1 V3.2.2 conforming CCS
providers, the call type can also be one of the values listed under "Call Type" below.
@end vtable

@subsubheading Call Type

The following call types are defined for EN 300 356-1 V3.2.2 conforming CCS providers in addition to the Q.931
values shown in @ref{Addendum for Q.931 Conformance}.
@vtable @pval
@item CC_CALL_TYPE_3x64KBS_UNRESTRICTED
The call type is 3 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 3 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_4x64KBS_UNRESTRICTED
The call type is 4 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 4 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_5x64KBS_UNRESTRICTED
The call type is 5 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 5 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_6x64KBS_UNRESTRICTED
The call type is 6 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of 384 kbit/s unrestricted digital information.  This call type can be
synonymous with CC_CALL_TYPE_384KBS_UNRESTRICTED.
@item CC_CALL_TYPE_7x64KBS_UNRESTRICTED
The call type is 7 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 7 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_8x64KBS_UNRESTRICTED
The call type is 8 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 8 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_9x64KBS_UNRESTRICTED
The call type is 9 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 9 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_10x64KBS_UNRESTRICTED
The call type is 10 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 10 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_11x64KBS_UNRESTRICTED
The call type is 11 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 11 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_12x64KBS_UNRESTRICTED
The call type is 12 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 12 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_13x64KBS_UNRESTRICTED
The call type is 13 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 13 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_14x64KBS_UNRESTRICTED
The call type is 14 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 14 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_15x64KBS_UNRESTRICTED
The call type is 15 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 15 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_16x64KBS_UNRESTRICTED
The call type is 16 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 16 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_17x64KBS_UNRESTRICTED
The call type is 17 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 17 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_18x64KBS_UNRESTRICTED
The call type is 18 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 28 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_19x64KBS_UNRESTRICTED
The call type is 19 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 19 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_20x64KBS_UNRESTRICTED
The call type is 20 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 20 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_21x64KBS_UNRESTRICTED
This call type corresponds to a EN 300 356-1 V3.2.2 transmission medium requirement of "reserved for 21 x 64 kbit/s
unrestricted digital information".  The call type is 21 x 64 kbit/s unrestricted digital information.
@item CC_CALL_TYPE_22x64KBS_UNRESTRICTED
The call type is 22 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 22 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_23x64KBS_UNRESTRICTED
The call type is 23 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 23 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_24x64KBS_UNRESTRICTED
The call type is 24 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "1536 kbit/s unrestricted digital information".  This call type can be
synonymous with CC_CALL_TYPE_1536KBS_UNRESTRICTED.
@item CC_CALL_TYPE_25x64KBS_UNRESTRICTED
The call type is 25 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 25 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_26x64KBS_UNRESTRICTED
The call type is 26 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 26 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_27x64KBS_UNRESTRICTED
The call type is 27 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 27 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_28x64KBS_UNRESTRICTED
The call type is 28 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "reserved for 28 x 64 kbit/s unrestricted digital information".
@item CC_CALL_TYPE_29x64KBS_UNRESTRICTED
The call type is 29 x 64 kbit/s unrestricted digital information.  This call type corresponds to a EN 300 356-1
V3.2.2 transmission medium requirement of "1920 kbit/s unrestricted digital information".  This call type can be
synonymous with CC_CALL_TYPE_1920KBS_UNRESTRICTED.
@end vtable

@subsubheading Rules

@b{Rules for call type:}
@enumerate
@item
Only multi-rate connection types for 384 kbit/s (6 x 64 kbit/s), 1536 kbit/s (24 x 64 kbit/s) and 1920 kbit/s (29 x
64 kbit/s) are supported.  For EN 300 356-1 V3.2.2 compliant CCS providers.
@end enumerate

@section ETSI EN 300 356-1 V3.2.2 Header File Listing

@page
@node Mapping of CCI Primitives to Q.931
@appendix Mapping of CCI Primitives to Q.931

The mapping of CCI primitives to Q.931 primitives is shown in @tabref{2}.  For the most part, this mapping
is a one to one mapping of service primitives, with the exception of @emph{Setup Response} and @emph{Setup
Confirm}.

@tabfigsized{cci_tab2,2,Mapping of CCI primitives to Q.931 Primitives,4.0in}

In Q.931 the @emph{Setup Response} and @emph{Setup Confirm} primitives and issued only once the voice channel is
connected.  In OpenSS7 CCI, the @prim{CC_SETUP_RES} and @prim{CC_SETUP_CON} primitives are used to accept the addressing and
assign a stream and correspond to the first backward message (i.e, @emph{Processing}, @emph{Alerting} or
@emph{Progress} @emph{Request} or @emph{Indication}; and @emph{Setup} @emph{Indication} or @emph{Confirm}).

@page
@node Mapping of CCI Primitives to Q.764
@appendix Mapping of CCI Primitives to Q.764

The mapping of CCI primitives to Q.764 primitives is shown in @tabref{3}.  For the most part this is a one
to one mapping of service primitives, with the exception of @emph{Setup Response} and @emph{Setup Confirm}.

@tabfigsized{cci_tab3,3,Mapping of CCI primitives to Q.764 Primitives,4.0in}

In Q.764 the @emph{Setup Response} and @emph{Setup Confirm} primitives and issued only once the voice channel is
connected.  In OpenSS7 CCI, the @prim{CC_SETUP_RES} and @prim{CC_SETUP_CON} primitives are used to accept the addressing and
assign a stream and correspond to the first backward message (i.e, @emph{Processing}, @emph{Alerting} or
@emph{Progress} @emph{Request} or @emph{Indication}; and @emph{Setup} @emph{Indication} or @emph{Confirm}).

@page
@node State/Event Tables
@appendix State/Event Tables

@page
@node Primitive Precedence Tables
@appendix Primitive Precedence Tables

@page
@node CCI Header File Listing
@appendix CCI Header File Listing

@noindent
@smallformat
@verbatiminclude cci.h
@end smallformat

@node Glossary
@unnumbered Glossary

@table @emph
@item Signalling Data Link Service Data Unit
A grouping of SDL user data whose boundaries are preserved from one end of the
signalling data link connection to the other.
@item Data transfer
The phase in connection and connectionless modes that supports the transfer of
data between to signalling data link users.
@item SDL provider
The signalling data link layer protocol that provides the services of the
signalling data link interface.
@item SDL user
The user-level application or user-level or kernel-level protocol that accesses
the services of the signalling data link layer.
@item Local management
The phase in connection and connectionless modes in which a SDL user initializes
a stream and attaches a PPA address to the stream.  Primitives in this phase
generate local operations only.
@item PPA
The point at which a system attaches itself to a physical communications medium.
@item PPA identifier
An identifier of a particular physical medium over which communication
transpires.
@end table

@node Acronyms
@unnumbered Acronyms

@multitable {SDL SDU}{International Telecommunication Union - Telecom Sector}
@item ITU-T @tab International Telecommunications Union - Telecom Sector
@item PPA @tab Physical Point of Attachment
@item SDLI @tab Signalling Data Link Interface
@item SDL SDU @tab Signalling Data Link Service Data Unit
@item SDL @tab Signalling Data Link
@end multitable

@node References
@unnumbered References
@enumerate
@item ITU-T Recommendation X.210, (Geneva, 1993), ``Information Technology --- Open Systems Interconnection --- Basic reference model: Conventions for the definition of OSI services,'' ISO/IEC 10731:1994.
@item ITU-T Recommendation X.217, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Service definition for the Association Control Service Element,'' ISO/IEC 8649:1996.
@item ITU-T Recommendation X.227, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connection-oriented protocol for the Association Control Service Element: Protocol Specification,'' ISO/IEC 8650-1.
@item ITU-T Recommendation X.237, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connectionless protocol for the Association Control Service Element: Protocol Specification,'' ISO/IEC 10035-1 : 1995.
@item ITU-T Recommendation X.216, (Geneva, 1994), ``Information Technology --- Open Systems Interconnection --- Presentation service definition,'' ISO/IEC 8822:1994.
@item ITU-T Recommendation X.226, (Geneva, 1994), ``Information Technology --- Open Systems Interconnection --- Connection-oriented presentation protocol: Protocol specification,'' ISO/IEC 8823-1:1994.
@item ITU-T Recommendation X.236, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connectionless presentation protocol: Protocol specification,'' ISO/IEC 9576-1:1995.
@item ITU-T Recommendation X.215, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Session service definition,'' ISO/IEC 8326:1996.
@item ITU-T Recommendation X.225, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connection-oriented session protocol: Protocol specification,'' ISO/IEC 8327-1:1996.
@item ITU-T Recommendation X.235, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Connectionless session protocol: Protocol specification,'' ISO/IEC 9548-1:1995.
@item ITU-T Recommendation X.214, (Geneva, 1995), ``Information Technology --- Open Systems Interconnection --- Transport service definition,'' ISO/IEC 8072:1996.
@item ITU-T Recommendation X.224
@item ITU-T Recommendation Q.700
@item ITU-T Recommendation Q.701
@item ITU-T Recommendation Q.702
@item ITU-T Recommendation Q.703
@item ITU-T Recommendation Q.704
@item Geoffrey Gerrien, ``CDI - Application Program Interface Guide,'' Gcom, Inc., March 1999.
@item ITU-T Recommendation Q.771, (Geneva, 1993), ``Signalling System No. 7 --- Functional description of transaction capabilities,'' (White Book).
@end enumerate

@node Licenses
@unnumbered Licenses

All code presented in this manual is licensed under the @ref{GNU Affero General Public License}.
The text of this manual is licensed under the @ref{GNU Free Documentation License}, with no
invariant sections, no front-cover texts and no back-cover texts.  Please note, however, that it is
just plain wrong to modify statements of, or attribute statements to, the Author or @cite{OpenSS7
Corporation}.

@menu
* GNU Affero General Public License::
* GNU Free Documentation License::
@end menu

@include texi/agpl3.texi
@page
@include texi/fdl13.texi

@ifnotplaintext
@c skip indexes for plain text (regex search works better)
@c @iftex
@c @node Indices
@c @unnumbered Indices
@c @end iftex

@c @ifnottex
@c @c concatenate indices for html and info
@node Index
@unnumbered Index
@printindex cp
@c @end ifnottex

@c @iftex
@c @menu
@c * Concept Index::
@c * Protocol State Index::
@c * Primitive Index::
@c * Primitive Structure and Type Index::
@c * Primitive Structure Field Index::
@c * Primitive Values Index::
@c * Primitive Error Values Index::
@c * Input-Output Control Index::
@c * MIB Object Index::
@c * Manual Page Index::
@c @end menu
@c 
@c @node Concept Index
@c @section Concept Index
@c @printindex cp
@c 
@c @page
@c @node Protocol State Index
@c @section Protocol State Index
@c @printindex st
@c 
@c @page
@c @node Primitive Index
@c @section Primitive Index
@c @printindex pr
@c 
@c @page
@c @node Primitive Structure and Type Index
@c @section Primitive Structure and Type Index
@c @printindex tp
@c 
@c @page
@c @node Primitive Structure Field Index
@c @section Primitive Structure Field Index
@c @printindex vr
@c 
@c @page
@c @node Primitive Values Index
@c @section Primitive Values Index
@c @printindex pv
@c 
@c @page
@c @node Primitive Error Values Index
@c @section Primitive Error Values Index
@c @printindex pe
@c 
@c @page
@c @node Input-Output Control Index
@c @section Input-Output Control Index
@c @printindex ct
@c 
@c @page
@c @node MIB Object Index
@c @section MIB Object Index
@c @printindex mo
@c 
@c @page
@c @node Manual Page Index
@c @section Manual Page Index
@c @printindex mp
@c @end iftex
@end ifnotplaintext

@iftex
@c insert list of figures and tables for printed manuals
@page
@heading List of Figures
@listoffloats Figure
@page
@heading List of Tables
@listoffloats Table
@end iftex

@bye
