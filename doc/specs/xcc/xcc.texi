% -*- texinfo -*- vim: ft=texinfo tw=100 nocin nosi noai
% =========================================================================
%
% @(#) $Id: xcc.texi,v 1.1.2.2 2011-02-07 02:21:48 brian Exp $
%
% =========================================================================
%
% Copyright (c) 2008-2011  Monavacon Limited <http://www.monavacon.com/>
% Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
% Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.3 or
% any later version published by the Free Software Foundation; with no
% Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
% copy of the license is included in the section entitled "GNU Free
% Documentation License".
%
% Permission to use, copy and distribute this documentation without
% modification, for any purpose and without fee or royalty is hereby
% granted, provided that both the above copyright notice and this
% permission notice appears in all copies and that the name of OpenSS7
% Corporation not be used in advertising or publicity pertaining to
% distribution of this documentation or its contents without specific,
% written prior permission.  OpenSS7 Corporation makes no representation
% about the suitability of this documentation for any purpose.  It is
% provided "as is" without express or implied warranty.
% 
% Permission is granted to process this file through Tex and print the
% results, provided the printed document carries copying permission
% notice identical to this one except for the removal of this paragraph
% (this paragraph not being relevant to the printed manual).
% 
% OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
% DOCUMENTATION INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE
% CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE
% IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY
% PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN NO EVENT SHALL
% OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR
% CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
% USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
% THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS
% THEREOF.
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2011-02-07 02:21:48 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename xcc.info
@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE XOM Call Control (XCC)
@set MANUAL_TYPE Specification
@settitle @value{MANUAL_TITLE}

@dircategory OpenSS7
@direntry
* XCC: (xcc).				XOM Call Control
@end direntry

@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE XOM Call Control (XCC)
@set MANUAL_TYPE Specification

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}.

Copyright @copyright{} 2008-2011  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2001  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*

All Rights Reserved.

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled @ref{GNU Free Documentation License}.

Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@ignore
Permission is granted to process this file through Tex and print the results, provided the printed
document carries copying permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
OPENSS7 CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT
THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE, OR THAT THE IMPLEMENTATION OF SUCH
CONTENTS WILL NOT INFRINGE ON ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.  IN
NO EVENT SHALL OPENSS7 CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH ANY USE OF
THIS DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.
@end ifinfo

@include ../../../scripts/texi/args.texi
@set MANUAL_TITLE XOM Call Control (XCC)
@set MANUAL_TYPE Specification

@set PART Call Control
@set LONG Call Control
@set SHORT CC
@set INTERFACE XCC

@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@subtitle Updated @value{PACKAGE_PDATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@sp 2
@subtitle Copyright @copyright{} 2008-2011  Monavacon Limited
@subtitle All Rights Reserved.
@sp 4
@quotation
@chapheading Abstract:
This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.  It provides abstraction of the
@value{LONG} (@value{SHORT}) interface to these components as well as providing a basis for
@value{LONG} control for other @value{LONG} protocols.
@end quotation
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll

@chapheading Published by:

@sp 1

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Copyright @copyright{} 2008-2011  @uref{http://www.monavacon.com/, Monavacon Limited} @*
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*

@noindent
All Rights Reserved.

@sp 1

@noindent
Unauthorized distribution or duplication is prohibited.

@sp 1

@noindent
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
the license is included in the section entitled @ref{GNU Free Documentation License}.

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@chapheading Notice:

@noindent
@strong{OpenSS7 Corporation disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights.  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.}

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defcodeindex pr
@c Define an index of primitive values
@defcodeindex pv
@c Define an index of primitive error values
@defcodeindex pe
@c Define an index of protocol states
@defcodeindex st
@c Define an index of input-output controls
@defcodeindex ct
@c Define an index of manual pages.
@defcodeindex mp
@c Define an index of MIB objects.
@defcodeindex mo

@c frags out automake
@c @ifnottex
@c @c concatenate indices for text, html and info
@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex pe cp
@syncodeindex st cp
@syncodeindex mp cp
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex ct cp
@syncodeindex mo cp
@c @end ifnottex

@include texi/macros.texi
@include texi/versions.texi
@include texi/prims.texi

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@heading About This Manual
This is Edition @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL}, last updated @value{PACKAGE_DATE}, of
@cite{The @value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version
@value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE}@value{PACKAGE_PATCHLEVEL} of the
@value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Preface::
* Introduction::
* C Language Binding::
* Description::
* Interface Functions::
* Interface Class Definitions::
* Errors::
* C Headers::
* Examples::
* Glossary::
* Licenses::
* Index::
@end menu

@iftex
@c insert list of figures and tables for printed manuals
@page
@heading List of Figures
@listoffloats Figure
@page
@heading List of Tables
@listoffloats Table
@end iftex

@node Preface
@unnumbered Preface

@section Notice

Software in this document and related software is released under the AGPL (@pxref{GNU Affero General
Public License}).  Please note, however, that there are different licensing terms for some of the
manual package and some of the documentation.  Consult permission notices contained in the
documentation of those components for more information.

This document is released under the FDL (@pxref{GNU Free Documentation License}) with no invariant
sections, no front-cover texts and no back-cover texts.

@section Abstract

This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.

@noindent
This document specifies a @value{MANUAL_TITLE} Specification in support of the OpenSS7 @value{LONG}
(@value{SHORT}) protocol stacks.  It provides abstraction of the @value{PART} interface to these
components as well as providing a basis for @value{PART} control for other @value{PART} protocols.

@subsection Purpose
@cpindex STREAMS

The purpose of this document is to provide technical documentation of the @value{MANUAL_TITLE}.
This document is intended to be included with the OpenSS7 @acronym{STREAMS} software package released
by @cite{OpenSS7 Corporation}.  It is intended to assist software developers, maintainers and users
of the @value{MANUAL_TITLE} with understanding the software architecture and technical interfaces
that are made available in the software package.

@subsection Intent

It is the intent of this document that it act as the primary source of information concerning the
@value{MANUAL_TITLE}.  This document is intended to provide information for writers of OpenSS7
@value{MANUAL_TITLE} applications as well as writers of OpenSS7 @value{MANUAL_TITLE} Users.

@subsection Audience

The audience for this document is software developers, maintainers and users and integrators of the
@value{MANUAL_TITLE}.  The target audience is developers and users of the OpenSS7 SS7 stack.

@section Revision History

Take care that you are working with a current version of this documentation: you will not be
notified of updates.  To ensure that you are working with a current version, check the
@uref{http://www.openss7.org/,OpenSS7 Project} website for a current version.

A current version of this specification is normally distributed with the @cite{@value{PACKAGE_TITLE}}
package, @file{@value{PACKAGE}-@value{VERSION}}.@footnote{@url{http://www.openss7.org/repos/tarballs/@value{PACKAGE}-@value{VERSION}.tar.bz2}}

@subsection Version Control

@noindent
Although the author has attempted to ensure that the information in this document is complete and
correct, neither the Author nor OpenSS7 Corporation will take any responsibility in it.
@cite{OpenSS7 Corporation} is making this documentation available as a reference point for the
industry.  While @cite{OpenSS7 Corporation} believes that these interfaces are well defined in this
release of the document, minor changes may be made prior to products conforming to the interfaces
being made available.  @cite{OpenSS7 Corporation} reserves the right to revise this software and
documentation for any reason, including but not limited to, conformity with standards promulgated by
various agencies, utilization of advances in the state of the technical arts, or the reflection of
changes in the design of any techniques, or procedures embodied, described, or referred to herein.
@cite{OpenSS7 Corporation} is under no obligation to provide any feature listed herein.

@smallexample
@verbatim
$Log: xcc.texi,v $
Revision 1.1.2.2  2011-02-07 02:21:48  brian
- updated manuals

Revision 1.1.2.1  2009-06-21 10:57:56  brian
- added files to new distro

@end verbatim
@end smallexample

@section ISO 9000 Compliance

Only the @TeX{}, texinfo, or roff source for this maual is controlled.  An opaque (printed,
postscript or portable document format) version of this manual is a @strong{UNCONTROLLED VERSION}.

@subsection Disclaimer

@noindent
@strong{@cite{OpenSS7 Corporation} disclaims all warranties with regard to this documentation
including all implied warranties of merchantability, fitness for a particular purpose,
non-infrincement, or title; that the contents of the manual are suitable for any purpose, or that
the implementation of such contents will not infringe on any third party patents, copyrights,
trademarks or other rights.  In no event shall @cite{OpenSS7 Corporation} be liable for any direct,
indirect, special or consequential damages or any damages whatsoever resulting from loss of use,
data or profits, whether in an action or contract, negligence or other tortious action, arising out
of or in connection with any use of this documentation or the performance or implementation of the
contents thereof.}

@subsection U.S. Government Restricted Rights

If you are licensing this Software on behalf of the U.S. Government ("Government"), the following
provisions apply to you.  If the Software is supplied by the Department of Defense ("DoD"), it is
classified as "Commercial Computer Software" under paragraph 252.227-7014 of the DoD Supplement to
the Federal Aquisition Regulations ("DFARS") (or any successor regulations) and the Government is
acquiring only the license rights granded herein (the license rights customarily provided to
non-Government users).  If the Software is supplied to any unit or agency of the Government other
than DoD, it is classified as "Restricted Computer Software" and the Government's rights in the
Software are defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR") (or any
successor regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplerment
to the FAR (or any successor regulations).

@section Acknowledgements

@url{http://www.openss7.org/,The OpenSS7 Project} was funded in part by:

@itemize @bullet
@item @url{http://www.monavacon.com/,Monavacon Limited}
@item @url{http://www.openss7.com/,OpenSS7 Corporation}
@end itemize

Thanks to the subscribers to and sponsors of @url{http://www.openss7.org/, The OpenSS7 Project}.
Without their support, open software like this would not be possible.

As with most open source projects, this project would not have been possible without the valiant
efforts and productive software of the @url{http://www.fsf.org/,Free Software Foundation}, the
@url{http://www.kernel.org/,Linux Kernel Community}, and the open source software movement at large.

@node Introduction
@chapter Introduction
@cpindex STREAMS

@menu
* Overview::
* Format of the Specification::
* Introductory Concepts::
* Relationship to ISUP, ISDN, H.323 and SIP-T::
* Relationship to Data Abstraction Services::
* Mandatory and Optional Features::
* Packages::
* Terminology::
* Abbreviations::
@end menu

@node Overview
@section Overview

The XOM Call Control Programming Interface (abbreviated XCC) defines an
Application Program Inteface (API) to call control services.  It is referred to as @dfn{the
interface} throughout this specification.

The interface is designed to offer services that are consistent with, but not limited to, the ITU-T
Recommendation Q.761, Q.931, H.225.0 and IETF SIP-T standards.  These standards were published in 1997 and have
been stable for many years.

The interface is also designated to offer services that are consistent with the 3GPP TS 28.001
standards for GSM mobile networks.

All of the above standards are referred to in this document as @dfn{the Standards}.

Access to other call control services through the API is not prohibited, but has not been
explicitly considered.

The interface is designed to be used and implemented in conjunction with the use and implementation
of the general-purpose XOM API (reference @b{XOM}).

A brief introduction to Call Control Services is given in @ref{Introductory Concepts}.
Following this is an overview of OSI-Abstract-DATA Manipulation OM, which provides the Data
Abstraction service as defined in the XOM specification (reference @b{XOM}).  Then the optional features of
this specification are described, and the chapter closes with a list of abbreviations.  In all cases
the reader should refer to the Standards (reference @b{ISUP}, reference @b{ISDN}, reference @b{H.323}, or to the XOM Specification
(reference @b{XOM}) for further authoritative details.

The structure of the remaining chapters and appendices are described in the @ref{Preface}.

@node Format of the Specification
@section Format of the Specification

This specification describes a programming language-independent interface to the Call Control
Services together with a specific C language binding of that interface.  Several conventions are
used to identify particular items.  The general conventions are described in the @ref{Preface},
while the C language binding conventions are described in @ref{C Language Binding}.

@node Introductory Concepts
@section Introductory Concepts

@menu
* Relationship to Call Control Protocols::
* XCC and the Call Control Provider::
@end menu

@node Relationship to Call Control Protocols
@subsection Relationship to Call Control Protocols

The interaction between call control programs acting in a call control entity role are
realized through the exchange of call control service information.  The general
communications service for the call control applications is the @dfn{Call Control Protocol}.  Call
control protocols define the following operations:

@multitable @columnfractions .5 .5
@item @b{Service} @tab @b{Type}
@end multitable

This communication may be accomplished using the ITU-T or ANSI @dfn{Message Transfer Part} protocol.

@node XCC and the Call Control Provider
@subsection XCC and the Call Control Provider

The XCC interface provides access to the CC service provider, which offers all of the facilities
defined in the Standards.  It also provides facilities such as automatic association management and
automatic session handling.  The interface is designed not to restrict the services offered to those
of specific service packages of ISUP.

The interface defined in this specification is ``symmetrical'' in the sense that it can be used to
implement call control programs acting in any of the CC producer or consumer roles (e.g. MSC,
BSC).  The interface supports:

@itemize
@item a call control program acting as a consumer of call control services.  This is
done by submitting service operation requests and receiving service operation responses.
@item a call control program acting as a producer of call control services.  This is
done by receiving service operation requests and sending back service operation responses.
@end itemize

The interface provides the ability to send @dfn{requests} on the consumer side and to receive
@dfn{indications} on the producer side within a call control interaction.  Furthermore, if the
service is confirmed, the producer will be able to send back @dfn{responses} that will be received
as @dfn{confirmations} by the consumer.

@node Relationship to ISUP, ISDN, H.323 and SIP-T
@section Relationship to ISUP, ISDN, H.323 and SIP-T

The API is essentially based on the abstract services of the ITU-T ISUP and ISDN, but is
independent of the underlying communications stack.  The API allows the manipulation of ITU-T and
ANSI call control service information.  Thus this API does not preclude and does not force the
use of either the ITU-T ISUP protocol or the ANSI ISUP protocol.

The XCC API offers several abstract call control service views: the on of ISUP, the one of ISDN,
the one of H.323, the one of GSM BSSAP, and that of SIP-T.

The contents of ITU-T ISUP messages are described in ITU-T Recommendation Q.761.  These messages
implicitly define the ITU-T ISUP services.  The mapping between ITU-T ISUP services and various
service primitives and parameters of the XCC API are described below.

The services offered by the XCC API are a superset of those defined by ITU-T and ANSI.
The general communication protocol for ANSI ISUP is the MTP as specified in ANSI T1.113.4/200.  The
general communication protocol for ITU-T ISUP is the MTP as specified in ITU-T Recommendation series
Q.761 through Q.764.

The abstract call control views of XCC (ITU-T and ANSI, ISUP, ISDN, H.323, BSSAP or SIP-T) are
independent of the underlying protocol.  However, the ITU-T view on top of ANSI MTP requires that an
appropriate mapping of ITU-T ISUP services over ANSI MTP is widely available.

@node Relationship to Data Abstraction Services
@section Relationship to Data Abstraction Services

XCC is dependent on standard data abstraction services to ensure portability of call control software
written to the XCC specification.  XCC functions pass most arguments by reference.  The data
referenced by these arguments is modelled and manipulated in an object-oriented fashion.  Call
application data abstraction services are provided by the XOM API (reference @b{XOM}).

The definitions below introduce the various concepts that are used by Call Control data
abstraction services.

@table @dfn
@item Syntax
A @dfn{syntax} is the classification and representation of values in OSI-Abstract-Data Manipulation.
Examples of syntaxes are @i{Boolean}, @i{Integer}, @i{Real}, @i{String(Octet)},
@i{String(Object-Identifier)} and @i{Object}.

@item Value
A @dfn{value} is a single datum, or piece of information.  A value may be as simple as a Boolean
value (for example, @i{True}), or as complicated as an entire OM object (for example, a
@i{Message}).

@item OM Attribute
An @dfn{OM attribute type} is an arbitrary category into which a specification places some values.
An @dfn{OM attribute} is an OM Attribute Type, together with an ordered sequence of one or more
values.  The OM Attribute Type can be thought of as the name of the OM attribute.

@item OM Object
An @dfn{OM object} is a collection of OM attributes.

@item OM Class
An @dfn{OM class} is a category of OM objects set out in a specification.  It determines the OM
attributes that may be present in the OM object, and details the constraints on those OM attributes.

@item Package
A @dfn{Package} is a set of OM classes that are grouped together by the specification, because tey
are functionally related (for example, ISUP service package).

@item Package Closure
A @dfn{Package-Closure} is the set of classes that need to be supported to be able to create all
possible instances of all classes defined in the package.  Thus an OM Class may be defined to have
an OM Attribute whose value is an OM Obejct of an OM Class that is defined in some other package,
but within the same @dfn{Package-Closure}.

@item Workspace
A @dfn{workspace} is allocated storage that contains one or more @dfn{Package-Closures}, together
with an implementation of the Call Control data abstraction services, that supports all the OM
classes of OM objects in the @dfn{Package-Closures}.

@item Descriptor
A @dfn{descriptor} is a defined data structure that is used to represent an OM Attribute Type and a
single value.  The structure has three components: a type, a syntax and a value.

@item Public Object
@dfn{Public Objects} are represented by data structures that are manipulated directly using
programming language constructs.  Use of Public Objects therefore simplifies programming by this
direct access and by enabling objects to be statically defined, when appropriate.  Programs can
efficiently access public objects.

@item Private Objects
@dfn{Private Objects} are held in data structures that are private to the service and can only be
accessed from programs indirectly using interface functions.  They are of particular use for
structures that are infrequently manipulated by programs, being passed by reference to the service,
which can then manipulate them efficiently.  An example of such objects in XCC is the @i{session}
object.
@end table

@node Mandatory and Optional Features
@section Mandatory and Optional Features

The interface defines an Application Program Interface (API) that application programs can use to
access the functionality of the underlying Call Control Services.  The interface does not
define or imply any profile of that service.

Note that nothing in this specification requires that the implementation of the interface or the
Call Control Services itself acutally makes use of TCAP or other parts of the model, just so
long as it provides the defined service.  Also, the @emph{scope} of the Call Control Services
to which an application has access is not determined; it is not restricted to ITU-T ISUP operations.

Some OM attributes are optional: these are marked @emph{(Optional Functionality)} in the OM class
definitions.  They are:

@itemize @bullet
@item @b{File-Descriptor} in a @b{Session} object.
@end itemize

Some items of behaviour of the interface and a number of aspects of the Call Control Services
provider are implemetnation-defined.  These are:

@itemize
@item the maximum number of oustanding asynchronous operations
@item whether an asyncrhonous function call returns before the operation is submitted to the Call
Control Services provider
@item the text and language of error messages
@item the OM classes permitted as values of the
@c @b{Name},
@b{Address} and @b{Title} argument to
interface functions.
@end itemize

The default values of some OM attributes on OM object @b{Session} are locally administered.

This API assumes the provision of automatic association management and automatic session handling by
the CC provider.

The interface enables negotiation of the use of the various defined features of the CC provider and
those of the interface.

@node Packages
@section Packages

The specification defines three Call Control packages (Common CC package, ITU-T CC package and
ANSI CC package), @ref{Interface Class Definitions}.  These packages define the OM classes required
by the interface functions to perform ITU-T CC or ANSI CC services.  The Common CC package, which
also includes the errors defined (@pxref{Errors}), is mandatory.  The ITU-T CC package and the ANSI
CC package are optional, but at least one of them must be supported by the implementation.  The
ITU-T service view and the ANSI service view assume the support of the corresponding ITU-T CC or ANSI
CC package by the implementation.

The use of the optional packages is negotiated using the @command{Negotiate()} function.

@node Terminology
@section Terminology

The terms @dfn{implementation-defined}, @dfn{may}, @dfn{should}, @dfn{undefined}, @dfn{unspecified},
and @dfn{will} are used in this document with the meanings ascribed to them in reference @b{XPG4},
see also @ref{Glossary}.

@node Abbreviations
@section Abbreviations

@multitable @columnfractions .1 .9
@item API @tab Application Program Interface
@item ANS.1 @tab Abstract Syntax Notation One
@item ANSI @tab American National Standards Institute
@c @item AVA @tab Attribute Value Assertion
@item BER @tab Basic Encoding Rules
@item GSM @tab Global Services Mobile
@item ISO @tab International Organisation for Standardisation
@item ITU-T @tab Internation Telecommunications Union - Telecom Sector
@item MAP @tab Mobile Application Part
@item OM @tab OSI-Abstract-Data Manipulation
@item OSI @tab Open Systems Interconnect
@item ROSE @tab Remote Operations Service Element
@item TCAP @tab Transaction Capabilities Application Part
@item XMAP @tab XOM Mobile Application Part API
@item XOM @tab X/Open: OSI-Abstract-Data Manipulation API
@end multitable

@node C Language Binding
@chapter C Language Binding

@menu
* C Naming Conventions::
* Use and Implementtion of Interfaces::
* Function Return Values::
* Compilation and Linking::
@end menu

This chapter sets out certain characteristics of the C language binding to the interface.  The
binding specifies C identifiers for all the elements of the interface, so that application programs
written in C can access the Mobile Application Services.  These elements include function names,
@var{typedef} names and constants.  All of the C identifiers are mechanically derived from the
language independent names as explained below.  There is a complete list of all the identifiers in
@ref{C Headers}.  For ease of use, some of these identifiers are defined in the specification
alongside the language-independent name.

A @i{Function()} is indicated as shown.

A @pval{CONSTANT} is in Roman font.

The names of @perr{[ERRORS]} and other return codes are surrounded by square brackets.

The definitions of the C identifiers appear in four headers:

@ftable @b
@item <xom.h>
This header file contains definitions for the associated OM interface.
@item <xcc.h>
This header file contains common definitions for the access to the Mobile Application Part service
(see @ref{Interface Functions}, and @ref{Common CC Package}).  A listing of this header file is
provided in @ref{xcc.h}.
@item <xcc_gsm.h>
This header file contains specific definitions that reflect the Abstract Services of the ITU-T Mobile
Services along with the ASN.1 productions of the related protocol (ITU-T CC), @xref{ITU-T CC Package}.
A listing of this header file is provided in @ref{xcc_gsm.h}.
@item <xcc_ansi.h>
This header file contains specific definitions that reflect the Abstract Services of the ANSI Mobile
Services allong with the ASN.1 productions of the related protocol (ANSI CC), @xref{ANSI CC
Package}.  A listing of this header file is provided in @ref{xcc_ansi.h}.
@item <xcc_gsm_sm.h>
This header file contains specific definitions that reflect the Short Message ITU-T services along
with ASN.1 productions of the related services (ITU-T CC Short Message services), @xref{ITU-T Short
Message Service Package}.  A listing of this header file is provided in @ref{xcc_gsm_sm.h}.
@end ftable

@node C Naming Conventions
@section C Naming Conventions

The interfaces uses part of the C public namespace for its facilities.  All identifiers start with
the letters cc, CC or OCC, and more detail of the conventions used are given in the following
table.  Note that the interface reserves @emph{all} identifiers starting with the letters @var{ccP}
for private (i.e. internal) use by implementations of the interface.  It also reserves @emph{all}
identifiers starting with the letters @var{ccX} or @var{CCX} for vendor-specific extensions of the
interface.  Application programmers should not use any identifier starting with these letters.

The OSI-Abstract-Data Manipulation API uses similar, thorugh not identical, naming conventions, that
are described in XOM (reference @b{XOM}).  All its identifiers are prefixes by the letters @var{OM} or
@var{om}.

@multitable @columnfractions .5 .2
@item reserved for implementors @tab @var{ccP}
@item reserved for interface extensions @tab @var{ccX}
@item reserved for interface extensions @tab @var{CCX}
@item reserved for implementors @tab @var{OCC}
@item @tab
@item functions @tab @var{cc_}
@item error problem values @tab @var{CC_E_}
@item enumeration tags (except errors) @tab @var{CC_T_}
@item OM classs names @tab @var{CC_C_}
@item OM value length limits @tab @var{CC_VL_}
@item OM value number limits @tab @var{CC_VN_}
@item other constants @tab @var{CC_}
@end multitable

A complete list of all identifiers used (except those beginning @var{ccP}, @var{ccX}, @var{CCX}
or @var{OCC}) is given in @ref{C Headers}.  No implementation of the interface will use any other
public identifiers.  A @dfn{public identifier} is any name except those reserved in section 4.1.2.1
of the ISO C Standard, and the @dfn{public namespace} is the set of all possible public identifiers.

The C identifiers are derived from the langauage-independent names used throughput this
specification by a purely mechanical process which depends on the kind of name:

@itemize @bullet
@item Interface function names are made entirely lower-case and prefixed by @var{cc_}.  Thus
@b{Service-Req()} becomes @command{cc_service_req()}.

@item C function parameters are derived from the argument and result names by making them entirely
lower-case.  In addition, the names of results have @var{_return} added as a suffix.  Thus the
argument @b{Session} becomes @var{session}, while the result of @b{Result} becomes
@var{result_return}.

@item OM class names are made entirely upper-case and prefixed by @var{CC_C_}.  Thus
@b{Service-Argument} becomes @var{CC_C_SERVICE_ARGUMENT}.  Note that the symbolic OM class names
are strictly those used in the abstract syntax ASN.1 of the TCAP and CC with the exception that
names containing multiple words are separated by hyphens.

@item Enumeration tags are derived from the name of the corresponding OM type and syntax by
prefixing @var{CC_}.  The case of letters is left unchanged.  Thus @b{Enum(User-reason)}
befomes @var{CC_User_reason}.

@item Enumeration constants, except erros, are made entirely upper-case and prefixed by @var{CC_T_}.
Thus @b{resource-limitation} becomes @var{CC_T_RESOURCE_LIMITATION}.

@item The name of an OM attribute is local to its OM class, that measn the same name of an OM
attribute may appear in different OM classes, for example, OM attribute @b{application-Context} is
defined in both OM classes @b{Open-Arg} and @b{application-Context-List}.  Independent-language
atribute @b{application-Context} appears as @var{CC_APPLICATION_CONTEXT} in C-language.  Note that
the symbolic OM attribute names are strictly those used in the abstract syntax ASN.1 of the TCAP and
CC with the exception that names containing multiple words are separated with hyphens.

@item Errors are treated as a special case.  Constants that are the possible values of the OM
attribute @b{Error-Status} of a subclass of the OM class @b{Error} are made entirely upper-case and
prefixed by @var{CC_E_}.  Thus @b{invalid-session} becomes @var{CC_E_INVALID_SESSION}.

@item The constants in the @b{Value Length} and @b{Value Number} columns of the OM class definition
tables are also assigned identifiers.  (They have no names in the language-independent
specification.)  Where the upper limit in on eof these columns is not ``1'' (one), it is given a
name consisting of the OM attribute name, prefixed by @var{CC_VL_} for value length, or
@var{CC_VN_} for value numbers.


@item The sequence of octets for each object identifier is also assigned an identifier, for internal
use by certain OM macros.  These identifiers are all upper case and are prefixed by @var{OMP_O_}.
See reference @b{XOM} for further details on the use of object identifiers.

Note that hyphens are translated everywhere to underscores.

@end itemize

@node Use and Implementtion of Interfaces
@section Use and Implementtion of Interfaces

Each of the following statements applies unless explicitly state otherwise in the detailed
descriptions that follow:

If an argument to a function has an invalid value (such as a value outside the domain of the
function, or a pointer outside the address space of the program, or a null pointer), the behvaiour
is @dfn{undefined}.

Any function declared in a header may be implemented as a macro defined in the header, so a library
function should not be declared explicitly if its header is included.  Any macro definition of a
function can be suppressed locally be encoding the name of the function in parentheses, because the
name is not then followed by the left parthesis that indicate expansion of a macro function name.
For the same syntactic reason, it is permitted to take the address of a library function even if it
is also defined as a macro.  The use of @command{#undef} to remove any macro defintion will also
ensure that an actual function is referred to.  Any invocation of a library function that is
implemented as a macro will expand to code that evaluates each of its arguments exactly once, fully
protected by parentheses where necessary, so it is generally safe to use arbitrary expressions as
arguments.  Likewise, those function-like macros described in the following sections may be invoked
in an expression anywhere a function with a compatible return type could be called.

@node Function Return Values
@section Function Return Values

The return value of a C function is always bound to the result of the language-independent
description.  Functions return a value of @type{CC_status}, which is an error indication.  If and
only if the function succeeds, its value will be @b{success}, expressed in C by the constant
@var{CC_SUCCESS}.  If a function returns a status other than this, then it has not updated the
return parameters.  The value of the status, in this case, is an error as described in @ref{Errors}.
In most cases the integer returned in @b{Status} is sufficient for error processing.  However, in a
few cases additional information is available if desired.

Since C does not provide multiple return values, functions must return all other results by writing
into storage passed by the application program.  Any argument that is a pointer to such storage has
a name ending with @var{_return}.  For example, the C parameter declaration @samp{OM_sint
*invoke_id_return} in the @i{Service-Req()} function indicates that the function will return an
signed integer @b{Invoke-Id} as a result, so the actual argument to the function must be the address
of a suitable variable.  This notation allows the reader to distinguish between an input parameter
that happes to be a pointer, and an output parameter where the @key{*} is used to simulate the
semantics of passing by reference.

@node Compilation and Linking
@section Compilation and Linking

All applications programs that use this interface include the @file{<xom.h>} and @file{<xcc.h>}
headers in that order, and at least one of the @file{<xcc_gsm.h>} and @file{<xcc_ansi.h>} headers.

@node Description
@chapter Description

@menu
* Services: Services Description.
* Session: Session Description.
* Context: Context Description.
* Function Arguments::
* Function Results::
* Synchronous and Asynchronous Operation::
* Other Features::
* Function Sequencing::
@end menu

The interface comprises a number of functions together with many OM classes and OM objects that are
used as the arguments and results of the functions.  Both the functions and the OM objects are based
closely on the @dfn{Abstract Service} that is specified in the Standards (references ITU-T ISUP and
ANSI ISUP).

The interface models mobile application interactions as service requests made through a number of
interface @dfn{functions}, which take a number of input @dfn{arguments}.  Each valid request causes
an @dfn{operation} within the producer which eventually returns a @dfn{status} and any @dfn{result}
of the operation.

All interactions between a Consumer and a Producer belong to a @dfn{session}, which is represented
by an OM object passed as the first argument to most interface functions.

The other arguments to the function include a @dfn{context} and various service-specific arguments.
The @dfn{context} includes a number of parameters that are common to many functions and that seldom
change from operation to operation.

Each of the components of this model is described below, along with other features of the interface
such as asynchronous function calls and security.

@node Services Description
@section Services

@menu
* Negotiation Sequence::
* Names, Addresses and Titles: Names.
@end menu

As mentioned above, the Standards define Abstract Services that Consumers and Producers use.
Each of these Absract Services maps to a single function call with the same name.  The services are
@b{Service-req} and @b{Service-rsp}.

@c FIXME more here...

These are three functions called @i{Receive()}, @i{Wait()}, and @i{Abandon()} which have no
counterpart in the Abstract Service.  @i{Receive()} is used to receive indications and results of
asynchronous operations, and is explained in @ref{Interface Functions}.  @i{Wait()} is used to
suspend execution until indications are available for specified sessions.  @i{Abandon()} is used to
abandon locally the result of a pending asyncrhonous operation.  Two additional functions
@i{Bind()}@footnote{@xref{Bind}.} and @i{Unbind()} are used to open and close a user-session.

There are also other interface specific functions called @i{Get-Assoc-Info()}, @i{Get-Last-Error()},
@i{Validate-object()}, @i{Error-Message()}, @i{Initialize()}, @i{Shutdown()} and @i{Negotiate()}.

The detailed specifications are given in @ref{Interface Functions}.
@ignore
The interface functions are summarized in Table 3.1.  Those interface functions that can execute
asynchronously are indicated by an @samp{a} in the first column.  The function @i{Cancel-req()} can
only be used asynchronously.  An @samp{s} in the second column indicates that the function addresses
the corresponding TCAP, ITU-T ISUP or ANSI ISUP service while an @samp{i} references a specific
interface service.
@end ignore

@node Negotiation Sequence
@subsection Negotiation Sequence

The interface has an initialize and shutdown sequence that permits the negotiation of optional
features.  This involves the functions @i{Initialize()}, @i{Negotiate()}, and @i{Shutdown()}.

Every application program must first call @i{Initialize()}, that returns a workspace.  This
workspace supports only the standard Common ISUP package, @xref{Interface Class Definitions}.

The workspace can be extended to support either the ITU-T ISUP or ANSI ISUP package or both (see
@ref{Interface Class Definitions}, and any combination of the optional Mobile Application Services
packages), or any vendor extensions.  Vendor extensions may include additional packages, and may
also include additional or modified functionality.  All such packages or other extensions are
identified by means of OSI Object Identifiers, and the Object Identifiers are supplied to the
@i{Negotiate()} function to incorporate the extensions into the workspace.  Features defined by this
specification are described and assigned Object Identifiers in @ref{Interface Functions}.  A feature
represents any package or any additional or modified functionality that is subject to negotiattion.
The @i{Negotiate()} function allows some particular features to be made available.

After a worksapce with the required features has been negotiated in this way, the application can
use the workspace as required.  It can create and manipulate OM objects using the OM functions, and
can start one or more management sessions using @i{Bind()}.@footnote{@xref{Bind}.}  All the sessions on a given workspace
share the same features.

Eventually, when it has completed its tasks, terminated all is mobile application sessions using
@i{Unbind()}, and released all its OM objects using @i{OM-Delete()}, the application should ensure
that resources associated with the interface are freed by calling @i{Shutdown()}.

A miscellaneous error arises if an attempt is made to use an unavailable feature.  If an instance of
a class that is not in an available package is supplied as a function argument, the @b{bad-class}
error arises.

@node Names
@subsection Names, Addresses and Titles

To address a wide variety of mobile application transport protocols the interface is capable of
accepting various forms of object names, system addresses and program or system titles.

@itemize @bullet
@item @b{Name} is an ``abstract class'' that contains various subclass types used to define specific
subscribers or systems responsible for producing mobile application services.

@item @b{Address} is an ``abstract class'' that contains various subclass types used to define the
specific location to contact a particular consumer or producer of mobile services.  For example, the
SCCP-Address subclass is typically used to define the location of a producer or consumer.

@item @b{Title} is an ``abstract class'' that contains various subclass types used to define a
specific subscriber or system name reponsible for producing mobile application services.
@end itemize

All three abstract classes participate in an implementation-specific name resolution scheme.  It is
assumed that given a @b{Name}, an implementation can determine the @b{Title} responsible for that
@b{Name}.  It is also assumed that given a @b{Title}, an implementation can determine the
@b{Address} of that @b{Title}.@footnote{Note that the way in which these relationships are resolved
is implementation-dependent, but use of SCCP Global Title translations should play a significant
role.}

The producer of an invoked operation may be explicitly designated at the interface boundary using
the following precedence rules:

@enumerate
@item A default Title or Address may be supplied as parameters to a bound ``session''.  If both
are provided, the implementation will verify that the Title resolves to the Address.
@item If automatic association management is used, a provider Title or Address may be supplied
as parameters within the ``context'' or a specific operation request.  If both are provided, the
implementation will verify that the Title resolves to the Address.  The ``context'' Title or or
Address takes precedence over the ``session'' Title or Address for unassociated session objects.
@item A consumer address may be supplied as a parameter within the ``argument'' of a specific
operation request.  The ``argument'' Address takes precedence over either the ``session'' Title or
Address or the ``context'' Title or Address.
@item If the producer of an invoked operation is not explicitly designated at the interface
boundary, the implementation will resolve the Name to the appropriate Title or Address.
@end enumerate

@node Session Description
@section Session

@menu
* AAM Enabled Session::
* AAM Disabled Session::
* Associated Session::
* ADH Enabled Session::
* ADH Disabled Session::
* Dialog Session::
@end menu

A session identifies to which mobile application entity a particular operation will be sent.  It
contains some @b{Bind-Arguments}, such as the name of the consumer.  The session is passed as the
first argument to most interface functions.

A session is described by an OM object of OM class @b{Session}.  It is created, and appropriate
parameter values may be set, using the OSI-Abstract-Data Manipulation functions.  A mobile
application session is then started with @i{Bind()}@footnote{@xref{Bind}.} and later is terminated with @i{Unbind()}.  A
session with default parameters can be started by passing the constant @b{Default-Session}
(@samp{(OM_object)CC_DEFAULT_SESSION}) as the @b{Session} argument to @i{Bind()}.

@i{Bind()} must be called before the @b{Session} can be used as an argument to any other function in
the interface.  After @i{Unbind()} has been called, @i{Bind()} must be called again if another
session is to be started.

The interface supports multiple concurrent sessions, so that an application implemented as a single
process, such as a server in a client-server model, can interact with the Mobile Application
Services using several identities; and so that a process can interact directly and concurrently with
different mobile application services.

Detailed specifications of the OM class @b{Session} are given in @ref{Interface Class Definitions}.

A session can be used either acting as a consumer of mobile application services, or acting as a
producer of mobile application services, or both.

A session acn be restricted for use only with a designated program called the responder.  When the
responder is omitted and automatic association management is used, the session can be used to
exchange mobile application service information with all processes.

The responder (title and address) parameters of an opened session, if present, specifies the
producer of the requested operation.  The precedence rules on address and title of the responder are
described in @ref{Names}.

Other OM attributes (vendors' implementation extensions) may be included to specify characteristics
of the underlying protocol used.

There are three type of session objects:

@node AAM Enabled Session
@subsection AAM Enabled Session

The @b{Session} collects together all the information that described a particular management
interaction.  The parameters that are to control such a session are set up in an instance of this OM
class, which is then passed as an argument to @i{Bind()}.@footnote{@xref{Bind}.}  This sets the OM attributes that describe
the actual characteristics of the session, and starts the session.  Such a started session can be
passed as the first argument to interface functions.

No attribute of a bound or connected session may be changed.  The result of modifying a started
session is unspecified.

Finally, @i{Unbind()} is used to terminate the sesion, after which the parameters can be modified an
a new session started using the same instance, if required.  Multiple concurrent sessions can be
run, by using multiple instances of this OM class.

A session allows a requesting program (the requestor) to exchange mobile application information
with another program designated (the responder) or by default to all programs.

An @dfn{AAM enabled} session thus allows a mobile application entity to access either a portion of
the mobile application services (that is, that are accessible via the designated responder) or all
mobile application services.  In the later case, the producer mobile application entity resolution
is performed by the Mobile Application Service provider, according to the mobile application
services invoked.

This type of session object can not be used to receive or send ACSE related primitives or
operations explicitly.  The use ACSE explicitly, see @ref{AAM Disabled Session}.

@node AAM Disabled Session
@subsection AAM Disabled Session

A session object can have Automatic Association Management disabled when it belongs to a workspace that has
Automatic Association Management disabled via @i{Negotiate()}, which allows the user to explicitly send and
receive ACSE operations to build and tear down associations.  It gives explicit control over
associations to the user.  The Mobile Application Service provider does no ACSE operations on behalf
of the user.

When the user creates and binds a session object in a workspace with AAM disabled, only the
following attributes within the session object can be specified:

@itemize
@item @i{requestor-Address}
@item @i{requestor-Title}
@c @item @i{role}
@end itemize

The session object is then passed as an argument to @i{Bind()},@footnote{@xref{Bind}.} which binds
the session.  This bound session can only be used to send ACSE related operations an to receive ACSE
related primitives.  The following can be sent/received using this type of bound session:

@itemize
@item @i{Receive()} (@command{cc_receive()}/@samp{CC_ASSOC_IND})
@item @i{Receive()} (@command{cc_receive()}/@samp{CC_ASSOC_CNF})
@item @i{Assoc-req()} (@command{cc_assoc_req()})
@item @i{Assoc-rsp()} (@command{cc_assoc_rsp()})
@end itemize

The other attributes that relate to ACSE are specified within an @b{Assoc-Argument} or
@b{Assoc-Result} object that is passed to, or returned from, @i{Assoc-req()}, @i{Assoc-rsp()}, or
@i{Receive()}.

@node Associated Session
@subsection Associated Session

Once a user has created a bound session that has AAM disabled, an association can be created.  An
association is represented by an @dfn{associated} or @dfn{partially associated} session object.  An
@dfn{associated} session is returned as the result of building a new association.  The associated
session is used, like a bound session, by sending and receiving mobile application dialog handling
or service operations.  The major difference is that an associated session object can only be used
to send and receive operations to, or from, a single remote mobile application entity.  After a
session is associated, the user can abort the association, which implicitly unbinds the associated,
or partialyl associated, session.

The precedence rules for common parameters within the @b{Session} and the @b{Context} objects are
different for associated session objects.  Once a session is in the associated state; the
@var{responder-Address} and @var{responder-Title} cannot be overridden by the context object.

To terminate this type of session, the user should either abort the session, which implicitly
unbinds the session.  If the user unbinds the associated session prior to aborting the association,
the service provider will abort the association.

@node ADH Enabled Session
@subsection ADH Enabled Session

The ADH enabled session allows a mobile application entity to invoke and respond to mobile
application services requests and indications without regard for dialog handling.  The Mobile
Application Service provider provides all dialog handling.

This type of session cannot be used to send dialog handling primitives or operations explicitly.
To use dialog handling explicitly, see @ref{ADH Disabled Session}.

@node ADH Disabled Session
@subsection ADH Disabled Session

A session object can have Automatic Dialog Handling disabled when it belongs to a workspace that has
Automatic Dialog Handling disabled using the @i{Negotiate()} function.  This allows the user to
explicitly send and receive dialog handling operations to establish and tear down dialogs.  It gives
explicit control over dialogs to the user.  The Mobile Application Service provider does no dialog
handling operations on behalf of the user.

Once the session object is bound (AAM enabled) or associated (AAM disabled) and has ADH disabled,
the session must explicitly issue dialog handling operations for each mobile application service
request or response.  This bound or associated session can only be used to send dialog handling
primitives.  The following can be sent/received using this type of bound or associated session:

@itemize
@item @i{Receive()} (@command{cc_receive()}/@samp{CC_OPEN_IND})
@item @i{Receive()} (@command{cc_receive()}/@samp{CC_ACCEPT_CNF})
@item @i{Receive()} (@command{cc_receive()}/@samp{CC_REFUSE_CNF})
@item @i{Open()} (@command{cc_open()})
@item @i{Accept()} (@command{cc_accept()})
@item @i{Refuse()} (@command{cc_refuse()})
@end itemize

The other attributes that relate to dialog handling are specified within the @b{Open-Argument},
@b{Accept-Result} or @b{Refuse-Result} objects that are passed to, or returned from, @i{Open()},
@i{Accept()}, @i{Refuse()}, or @i{Receive()}.

@node Dialog Session
@subsection Dialog Session

Once a user has created a bound or associated session that has ADH disabled, a dialog can be
created.  A dialog is represented by a @dfn{fully formed}, or @dfn{partially formed} @dfn{dialog},
session object.  A @dfn{dialog} session is returned as the result of building a new dialog.  The
dialog session is used, like a bound or associated session, by sending and receiving mobile
application service operations.  The major difference is that a dialog session object can only be
used to send and receive operations within a single dialog with a single remote mobile application
entity.  After a session forms a dialog, the user can close or abort the dialog, which returns the
session to the bound or associated state.

The precedence rules for common parameters within the @b{Session} and the @b{Context} objects are
different for dialog session objects.  Once a session has formed a dialog, the dialog related
arguments, @var{application-Context-Name}, cannot be overridden by the context object.

To terminate this type of session, the user should either abort or close the dialog, which
implicitly unbind the session.  If the user unbinds the dialog session prior to either closing or
aborting the dialog, the service provider will first attempt to close the dialog, and if that is
rejected, will abort the dialog.

@node Context Description
@section Context

The context defines the characteristics of the mobile application interaction that are specific to a
particular mobile application operation, but are often used unchanged for many operations.  Since
the parameters are presumed to be relatively static for a given user during a particular mobile
application interaction, these arguments are collected into an OM object of OM class @b{Context},
which is supplied as the second argument of each mobile application operation.  This serves to
reduce the number of arguments passed to each function.

The context includes various administrative details, such as the @i{mode} defined in the Abstract
Service, which affect the processing of each mobile application operation.  These include a number
of @i{Service Controls} and @i{Local Controls} that allow control over some aspects of the
operation.
The @i{Service Controls} include
@b{mode}, @b{responder-Address}, and @b{responder-Title}.
The @i{Local Controls} include
@b{asynchronous}, @b{reply-Limit} and @b{time-Limit}.
Each of these is mapped onto an OM attribute in the @b{Context}, and they are detailed in
@ref{Interface Class Definitions}.

The effect is as if they were passed as a group of additional arguments on every function call.  The
value of each component of the context is determined when the interface function is called, and
remains fixed throughout the operation.

The precedence rules on address and title of the responder are described in @ref{Names}.

Some of the OM attributes in the @b{Context} have default values, some of which are locally
adminstered.  The constant @b{Default-Context} (@samp{CC_DEFAULT_CONTEXT}) can be pased as the
value of the @b{Context} argument to the interface functions, and has the same effect as a context
OM object created with default values.  The context must be a private object, unless it is
@b{Default-Context}.

Detailed specifications of the OM class @b{Context} are given in @ref{Interface Class Definitions}.

@node Function Arguments
@section Function Arguments

@menu
* Encoding and Decoding::
* Argument and Response::
@end menu

The Abstract Service defines specific arguments for each operation.  These are mapped onto
coresponding arguments to each interface function (which are aso called input parameters).  Although
each service has different arguments, some specific arguments recur in several operations; these are
briefly introduced here.  As far as the ITU-T CC package is concerned, OM classes are defined with a
one-to-one mapping to the ASN.1 Abstract Syntax of ITU-T CC.  Full details of these and all the other
arguments are given in the function definitions in @ref{Interface Functions}, and the OM class
definitions in @ref{Interface Class Definitions}.

All arguments that are OM objects can generally be supplied to the interface functions as public
objects (i.e, descriptor lists) or as private objects.  Private objects must be created in the
workspace that was returned by @i{Initialize()}.  In some cases, constants can be supplied instead
of OM objects.

Note that wherever a function is stated as accepting an instance of a particular OM class as the
value of an argument, it will also accept an instance of any subclass of that OM class.  For
example, the @b{Service-Req} function has a parameter @b{argument}, which accepts values of OM class
@b{Service-Argument}.  Any of the subclasses of @b{Service-Argument} may be supplied as the value of
@b{argument}.

Rules for interpretation of @samp{ANY} syntax appearing in function arguments are defined in
@ref{Encoding and Decoding}.

@node Encoding and Decoding
@subsection Encoding and Decoding

XCC specifies two alternatives for encoding and decoding of Mobile Application Packages
OM-Attribute values of type @samp{ANY}, or any OM-Attribute values in a Mobiled Application Services
package.

@enumerate
@item The encoding and decoding functionality can be provided internally with the XCC API, without
requiring the application to invoke any encoding or decoding functions.  This option allows the
application to be free from any knowledge of encoding rules.  In this case, the OM class and
attribute type and corresponding representation are defined in a mobile application or services
package.  The XCC API uses the package definition to attempt encoding or decoding; if automatic
decoding fails, an OM String(Encoding) is used.
@item The application can perform encoding and decoding itself.  This option gives the application
responsibility and control over the encoding and decoding of OM attributes.  In this case, all OM
attribute values appear as an OM String(Encoding).
@end enumerate

The encoding and decoding alternative to be used is negotiated through the @i{Negotiate()} function;
@xref{Negotiate}.

The XCC API does not specify the use of OM-Encode or OM-Decode for the OM classes defined in this
specification, or in mobile application or services packages used with this specification.

To ensure interoperability, the sender and receiver must follow the same encoding rules when
converting between OM syntax and encoded syntax.  If an algorithm is used to generate OM packages,
then the algorithm must ensure that the generated OM syntax is consistent with the input abstract
syntax (that is, the same encoded values must result from applying the encoding rules to either
representation).  The encoding rules used with the ITU-T CC and ANSI CC packages defined by this
specification are ANS.1 BER.  This does not imply that other encoding rules cannot be used with
other packages defined in the future.

For the API to encode and decode the OM attribute values according to the ASN.1 standard scheme,
ASN.1 taggin information must be stored for each OM object and each OM attribute.  Thus, the package
definitions in the workspace need to incorporate the ASN.1 tagging information for each OM object
and each OM attribute definition for all Mobile Application Services packages.

As a minimum, the following requirements apply:

@itemize @bullet
@item All rules specified in ISO/IEC 8825 -- Specification of Basic Encoding Rules for Abstract
Syntax Notation One (ASN.1) shall be adhered to.  Any exceptions or restrictions must be stated.
@item ASN.1 tagging information must be retained for each OM object and each OM attribute in the
Mobile Application Services packages.
@item The specified encoding and decoding scheme (and any implementation thereof) should be
extensible to accomodate the new encoding rules established subsequent to ISO/IEC 8825.
@end itemize

@node Argument and Response
@subsection Argument and Response

Most operations and notifications take an argument to specify the argument of the operation and a
response when issuing the response of the operation.  These arguments and responses are specified to
accept values of OM classes that are consistent with the abstract service view (ITU-T CC or ANSI CC)
of the current operation.

The argument for a @i{Service-req()} function is represented by an instance of the OM Class
@b{ITUT-Service-Req-Argument} for a ITU-T CC operation or an instance of the OM Class
@b{ANSI-Service-Req-Argument} for an ANSI CC operation.

The reponse for a @i{Service-rsp()} function is represented by an instance of the OM Class
@b{GSM-Service-Result}, @b{GSM-Linked-Reply-Argument} @b{Service-Error} or
@b{GSM-Service-Reject} to represent the possible responses of the ITU-T service request operation, or
an instance of the @b{ANSI-Service-Result}, @b{ANSI-Linked-Reply-Argument} @b{Service-Error} or
@b{ANSI-Service-Reject} to represent the possible responses of the ANSI service request operation.

@node Function Results
@section Function Results

@menu
* Invoke-ID: Invoke-ID Discussion.
* Result: Result Discussion.
* Status: Status Discussion.
@end menu

All functions return a @b{Status} (which is the C function result).  Most return an @b{Invoke-ID}
which identfies the particular invocation.  The confirmed operations each return a @b{Result}.  (The
@b{Invoke-ID} and @b{Result} are returned using pointers that are supplied as arguments of the C
function).  These three kinds of function results are introduced below.

All OM objects returned by interface functions (results and errors) will be private objects in the
workspace assocaited with the session private object.

@node Invoke-ID Discussion
@subsection Invoke-ID

All interface functions that invoke a mobile application service operation return an @b{Invoke-ID};
an integer that identifies the particular invocation of an operation.  The @b{Invoke-ID} is only
relevant for asynchronous confirmed operations and may be used later to receive the @b{Status} and
@b{Result}, or to abandon them.  The @b{Invoke-ID} is also used to respond to a previously requested
confirmed operation.  Asynchronous operations are fully described in @ref{Synchronous and
Asynchronous Operation}.  The interface functions that can be used to start them are the
@i{Service-req()} function.

The numerical value of the invoke-Id returned from a call that successfully invoke an asynchronous
confirmed operation is guaranteed to be unique amoungst all outstanding operations in given session.
The value is such as could be returned from TCAP, the Transaction Capabilities Application Part
defined in ITU-T Recommendation Q.771 through Q.775.  Invoke IDs used by XCC are not necessarily
those that are actually sent via a protocol such as TCAP.  Invoke IDs may be mapped or altered by
the Mobile Application Service provider.

The value returned for a synchronous operation or an asynchronous non-confirmed operation is
unspecified, as is that for a call that fails to invoke an operation.

@node Result Discussion
@subsection Result

Functions invoking confirmed mobile application service operations return a result only if they
succeed.  All errors from these functions are reported in the @b{Status} described below, as are
errors from all other functions.

The value returned by a function call that invokes an asynchronous operation is unspecified, as is
that for a call that fails to invoke an operation.  The result of an asynchronous operation is
returned by a later call to @i{Receive()}.

The result of a function invoking a confirmed operation can be composed of a single reply, or of
multiple linked replies.  In the later case, the term @dfn{partial result} is used to designate one
of these linked replies.  Only a confirmed @b{Service-req} may produce multiple results.  Multiple
replies to a single mobile application service operation may only occur if the invoker specifies
multiple-reply in the functional unit attribute of the Session object.

In asynchronous mode, the partial results can be retrieved one at a time by subsequent calls to
@i{Receive()}, which each time returns an instance of OM class @b{Linked-Reply-Argument}.  In
synchronous mode, the function returns an instance of OM class @b{Multiple-Reply}, which contains a
list of sub-objects of OM class @b{Linked-Reply-Argument}.

The result (or partial result) of an operation is returned in a private object whose OM class is
appropriate to the particular operation.  The format of mobile application service operation results
is driven both by the Abstract Service and by the need to provide asynchronous execution of
functions.  To simplify processing of asynchronous results, the result (or partial result) of a
single operation is returned in a single OM obejct (corresponding to the abstract result defined in
the Standards).  The components of the result (or partial result) of an operation are represented by
OM attribute in the operation's result object.  All information contianed in the Abstract Service
result is made available to the application program.  The result (partial result) is inspected using
the functions provided in the OSI-Abstract-Data Manipulation API.

Only confirmed mobile application service operations produce results, and each type of operation has
a specific OM class of OM object for its result.  These OM classes are defined in @ref{Interface
Class Definitions}.

The actual OM class of the result can always be a subclass of that named, to allow flexibility for
extensions.  Thus, the function @i{OM-Instance()} should always be used when testing the OM class.

@node Status Discussion
@subsection Status

Every interface function returnes a @b{Status} value, which is either the constant @b{success}
(@samp{(CC_status)0} or @samp{CC_SUCCESS}) or an error.  Function call errors are represented as
integer constants and grouped in categories of System, Library and Communications as described in
@ref{Errors}.

Additional error information is available for System and Communications errors via the
@i{Get-Last-Error()} function call.  Additional error information is available for the
@b{bad-argument} Library error via the @i{Validate-object()} function call.

A synchronous call with multiple linked replies is considered successful unless the reploy limit or
time limit is exceeded.  The function returns a @b{Status} value equal to success, and the argument
@i{Result} is an OM object of OM class @b{Multiple-Reply}, which contains all the linked replies.

It should be noted that OM object @b{Linked-Reply-Argument} may contain an OM attribute that
reflects an error.

If the reply limit or time limit is exceeded, the synchronous call fails and returns a status of the
appropriate Library error.  However, the @i{Result} is still considered valid and may contain an
OM-Object @b{Multiple-Reply}, which contains all the received linked replies.  A result of
@var{CC_ABSENT_OBJECT} means no replies were received.

In most cases other results of functions are initialized to Null (@var{CC_ABSENT_OBJECT}) if the
status does not have the value @b{success}.  However, the @i{Result} is still considered valid and
may contain an OM-Object of parital replies.  A result of @var{CC_ABSENT_OBJECT} means no replies
were received.

@node Synchronous and Asynchronous Operation
@section Synchronous and Asynchronous Operation

The asynchronous or synchronous mode of a requested operation is specified at the interface, and
determined for each operation by the value of the OM attribute @i{Asynchronous} in the @b{Context}
passed to the interface function.  The default value of this OM attribute is @b{false}, causing all
operations to by synchronous.  Support for both synchronous and asynchronous operation is mandatory.
There is a limit to the number of pending asynchronous operations; this limit is given by the
constant @b{max-outstanding-operations}, and has a minimum value of 10.

In synchronous mode, all functions wait until the operation is complete before returning.  Thus the
thread of control is blocked within the interface after calling a function, and the application can
make use of the result immediately after the function returns.

In asynchronous mode, some functions return before the operation is complete.  The application is
then able to continue with other processing while the operation is being executed by the Mobile
Application Service provider, and can then access the result by calling @i{Receive()}.  An
application may initiate several concurrent asynchronous operations on the ame session before
receiving any of the results, subject to the limit described below.  The results are not guaranteed
to be returned in any particular order.  The functions that can execute asynchronously are the
@i{Service-req()} function.  This correponds to the mobile application services of the Standards
that operate in a confirmed mode.  Moreover, only confirmed operations return service results.

An asynchronous function call of a confirmed service returns an @b{Invoke-ID} of the operation to
the application.  The same @b{Invoke-ID} will be returned by @i{Receive()} on the corresponding
result.

An @b{Invoke-ID} is also returned by @i{Receive()} on an indication of an invoked mobile application
service operation.  The same @b{Invoke-ID} will be used to respond to this operation.

Implementations of the interface are free to return from asynchronous function calls as soon as
possible or may wait until the operation has been submitted to the unerlying Mobile Application
Service provider.  The actual policy used is implemetnation-defined.

Implementations will define a limit to the number of asyncrhonous operations that may be outstanding
at any one time on any one session.  An asynchronous operation is outstanding from the time that the
function is called until the last reply of the result is returned by @i{Receive()}, or the operation
is abandoned by @i{Abandon()}, or the session is closed by @i{Unbind()}.  The limit is given by the
constant @b{max-outstanding-operations} (@samp{CC_MAX_OUTSTANDING_OPERATIONS}) and is at least 10
for conformant XCC implemetnations.  While this number of operations is outstanding, attempts to
invoke further asynchronous operations will report a @b{Library-Error} (too many operations).

Asynchronous operation calls can be aborted by executing an @i{Abandon()} or @i{Unbind()} call.  In
this case, the operation is no longer outstanding and the result  will never be returned by further
@i{Receive()} function calls.

If an error is detected before an asynchronous request is submitted to the Mobile Application
Service provider, the function will return immediately and there will be no outstanding operation
generated.  Other errors are notified later by @i{Receive()}, when the result of the outstanding
asynchronous confirmed operation is returned.  All errors occurring during a synchronous request are
reported when the function returns.  Full details of error handling are given in @ref{Errors}.

Where vendors provide suitable system primitives (such as System V @manref{poll(2s)}, or BSD
@manref{select(2)}), applications can obtain a file descriptor from the @b{Session} by inspecting
the value fo the OM attribute @i{File-Descriptor}.  Applications may use the file descriptor to
suspend the process until data is received on the particular file descriptor.

Applications should ensure that there are no outstanding asynchronous operations on a session when
@i{Unbind()} is called on that session.  Once @i{Unbind()} has been called there is no way to
determine whether any outstanding operations succeed or even whether they were ever sent to the
Mobile Application Service provider.  Also no errors or results of any kind will be reported to the
application.  It is strongly recommended that @i{Receive()} is called repeatedly until
@b{Completion-Flag} takes the value @b{nothing}.

@node Other Features
@section Other Features

@menu
* Automatic Association Management::
* Automatic Dialog Handling::
* Automatic Performer Resolution::
* Responder Versatility::
* Automatic Name to Address Resolution::
* Automatic Dispatching to Appropriate Stack::
@end menu

These features are not part of the interface itself, but are mandatory when specified by the Mobile
Application Service provider.

The Mobile Applications are not restricted to those defined by ITU-T CC.

All the features listed below are for the most part necessary for ease of use in a mobile
application environment.  These features are classified as given registered identifiers (Object
Identifier).  They can be negotiated using the @i{Negotiate()} function in the same manner as
packages.  Other types of information that are critical in servicing an environment that incudes
implemetnation from multiple vendors on various machines can also be classified and handled with
the @i{Negotiate()} function.  Features defined by this specification are described and assigned
Object Identifiers in @ref{Interface Functions}.

@node Automatic Association Management
@subsection Automatic Association Management

When the Mobile Application Services provider makes use of association oriented communication services,
such as TCAP, the Mobile Application Service provider implementations are assumed to provide
automatic handling of the association between mobile application entities, establishing
and releasing associations at its discretion.  Such management is intended to bring
benefits such as reduced communication charges.  To allow this flexibility to the implementation,
the interface does not specify when communication takes place.  Automatic Association Management
(AAM) may be enabled or disabled on a per-workspace basis using the @i{Negotiate()} function. 

@node Automatic Dialog Handling
@subsection Automatic Dialog Handling

When the Mobile Application Services provider makes use of dialog oriented communication services,
such as that provided by TCAP, the Mobile Application Service provider implementations are assumed
to provide automatic handling of dialogs between mobile application entities, establishing and
releasing dialogs at its discretion.  Such management is intended to bring benefits such as reduced
communication overheads.  To allow this flexibility to the implementation, the interface does not
specify when communication takes place.  Automatic Dialog Handling (ADH) may be enabled or disabled
on a per-workspace basis using the @i{Negotiate()} function.@footnote{Note that Automatic Dialog
Handling is an independent concept from Automatic Association Management.}

@node Automatic Performer Resolution
@subsection Automatic Performer Resolution

The performer of an invoked operation my be explicitly designated by the responder name and
responder address parameters of the bound session used.

However, in the case where the responder is specified as a wildcard, the Mobile Application Service
provider may be assumed to provide automatic mobile application service and application context to
consumer resolution: to find out the consumer that is in charge of the selected mobile application
service specified in the mobile application service operation.

@node Responder Versatility
@subsection Responder Versatility

Responder versatility is the ability to change the consumer within a same bound-session at each
function call.  It is useful when the automatic consumer resolution is either not suported by the
Mobile Application Service provider or note requested.  This applies if the underlying Mobile
Application Service provider is connection-less.

@node Automatic Name to Address Resolution
@subsection Automatic Name to Address Resolution

Mobile Application Service provider implementation may provide automatic resolution between program
name and address to find the network address of a mobile application entity from its name using
directory or translation services.

@node Automatic Dispatching to Appropriate Stack
@subsection Automatic Dispatching to Appropriate Stack

The Mobile Application Services provideer implementation may provide a loop back facility if the
destination of the operation or notification is local.  It also may provide routing of the
mobile application services operation to the proper underlying communications stack according to the
implied mobile application service and the destination (for example over a ITU-T SCCP stack or an
ANSI SCCP stack).

@node Function Sequencing
@section Function Sequencing

A minimum set of sequencing rules applies when using the interface to exchange mobile application
service information between mobile application programs acting as a mobile application entity.
These rules need to be respected by mobile application programs to ensure that interface
functions are called in the proper sequence and that the state of the interface is not violated,
otherwise @b{Library-error} status will be returned.@footnote{Note the following is considered as
tutorial information.  The definitive information is contained in the Standards (see referenced
documents).}

The general rules to follow are:

@enumerate
@item Initialize a workspace (@samp{cc_initialize()})
@item Negotiate features of the interface (@samp{cc_negotiate()})
@item Open one or several sessions (@samp{cc_bind()})
@item Perform mobile application service interactions (operations) using the offered interface
functions.  An interaction is identified by its @b{Invoke-Id}.
@item Close the opened sessions (@samp{cc_unbind()})
@item Discard the workspace (@samp{cc_shutdown()})
@end enumerate

Seven states are defined in the interface to cover both interface service operations and mobile
application service interactions:


@table @var
@item UNINIT
Workspace uninitialized.
@item INIT
Workspace initialized.
@item UNBND
Session closed.
@item BND
Session opened.
@item IDLE
Outstanding operatoin requested in a mobile application service interaction.
@item OUTOP
Operation indication received in a mobile application service interaction.
@item OPIND
@end table


@node Interface Functions
@chapter Interface Functions

@node Interface Class Definitions
@chapter Interface Class Definitions

@node Errors
@chapter Errors

@node C Headers
@appendix C Headers

@menu
* xcc.h::
* xcc_isup.h::
* xcc_isdn.h::
* xcc_h323.h::
* xcc_sipt.h::
@end menu

@node xcc.h
@section @file{xcc.h}

@smallformat
@c @verbatiminclude xcc.h
@end smallformat

@page
@node xcc_isup.h
@section @file{xcc_isup.h}

@smallformat
@c @verbatiminclude xcc_isup.h
@end smallformat

@page
@node xcc_isdn.h
@section @file{xcc_isdn.h}

@page
@node xcc_h323.h
@section @file{xcc_h323.h}

@page
@node xcc_sipt.h
@section @file{xcc_sipt.h}

@node Examples
@appendix Examples

@smallformat
@c @verbatiminclude example.c
@end smallformat

@node Glossary
@unnumbered Glossary

@node Licenses
@unnumbered Licenses

All code presented in this manual is licensed under the @ref{GNU Affero General Public License}.
The text of this manual is licensed under the @ref{GNU Free Documentation License}, with no
invariant sections, no front-cover texts and no back-cover texts.  Please note, however, that it is
just plain wrong to modify statements of, or attribute statements to, the Author or @cite{OpenSS7
Corporation}.

@menu
* GNU Affero General Public License::
* GNU Free Documentation License::
@end menu

@include texi/agpl3.texi
@page
@include texi/fdl13.texi

@ifnotplaintext
@c skip indexes for plain text (regex search works better)
@node Index
@unnumbered Index
@printindex cp
@end ifnotplaintext

@page
@shortcontents
@page
@contents
@bye
