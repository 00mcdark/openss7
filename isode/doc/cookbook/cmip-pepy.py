-- automatically generated by posy 3.2 #15 (gonzo), do not edit!

CMIP DEFINITIONS ::=

%{
#include <stdio.h>
#include "CMIP-types.h"
%}

PREFIXES encode decode print

BEGIN

ENCODER encode

EventReportArgument
    %{
	struct type_CMIP_EventReportArgument *arg =
			(struct type_CMIP_EventReportArgument *) parm;
    %}
    ::=
        SEQUENCE {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]],

            eventType[5]
                EventTypeID
                [[p (PEPYPARM) arg -> eventType]],

            eventTime[6]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) arg -> eventTime]]
                OPTIONAL <<arg -> eventTime>>,

            eventInfo[7]
                EventInfo
                [[p (PEPYPARM) arg -> eventInfo]]
                OPTIONAL <<arg -> eventInfo>>
        }

EventReportResult ::=
        NULL

LinkedReplyArgument
    %{
	struct type_CMIP_LinkedReplyArgument *arg =
			(struct type_CMIP_LinkedReplyArgument *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            getResult[0]
                IMPLICIT GetResult
                [[p (PEPYPARM) arg -> un.getResult]],

            getError[1]
                IMPLICIT GetListError
                [[p (PEPYPARM) arg -> un.getError]],

            setResult[2]
                IMPLICIT SetResult
                [[p (PEPYPARM) arg -> un.setResult]],

            setError[3]
                IMPLICIT SetListError
                [[p (PEPYPARM) arg -> un.setError]],

            actionResult[4]
                IMPLICIT ActionResult
                [[p (PEPYPARM) arg -> un.actionResult]]
        }

GetArgument
    %{
	struct type_CMIP_GetArgument *arg =
			(struct type_CMIP_GetArgument *) parm;
	struct element_CMIP_0 *element_CMIP_0;
    %}
    ::=
        SEQUENCE %{ element_CMIP_0 = arg -> element_CMIP_0; %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]],

            accessControl[5]
                AccessControl
                [[p (PEPYPARM) arg -> accessControl]]
                OPTIONAL <<arg -> accessControl>>,

            synchronization[6]
                IMPLICIT CMISSync
                [[p (PEPYPARM) arg -> synchronization]]
                DEFAULT bestEffort <<arg -> synchronization>>,

            filter
                CMISFilter
                [[p (PEPYPARM) arg -> filter]]
                OPTIONAL <<arg -> filter>>,

            mgmtInfoIdList[11]
                IMPLICIT SEQUENCE OF
                    <<element_CMIP_0 = arg -> element_CMIP_0;
                            element_CMIP_0;
                            element_CMIP_0 = element_CMIP_0 -> next>>
                    MgmtInfoId
                    [[p (PEPYPARM) element_CMIP_0 -> MgmtInfoId]]
        }

GetResult
    %{
	struct type_CMIP_GetResult *arg =
			(struct type_CMIP_GetResult *) parm;
	struct element_CMIP_1 *element_CMIP_1;
    %}
    ::=
        SEQUENCE %{ element_CMIP_1 = arg -> element_CMIP_1; %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]]
                OPTIONAL <<arg -> managedObjectClass>>,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]]
                OPTIONAL <<arg -> managedObjectInstance>>,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) arg -> currentTime]]
                OPTIONAL <<arg -> currentTime>>,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    <<element_CMIP_1 = arg -> element_CMIP_1;
                            element_CMIP_1;
                            element_CMIP_1 = element_CMIP_1 -> next>>
                    MgmtInfo
                    [[p (PEPYPARM) element_CMIP_1 -> MgmtInfo]]
        }

SetArgument
    %{
	struct type_CMIP_SetArgument *arg =
			(struct type_CMIP_SetArgument *) parm;
	struct element_CMIP_2 *element_CMIP_2;
    %}
    ::=
        SEQUENCE %{ element_CMIP_2 = arg -> element_CMIP_2; %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]],

            accessControl[5]
                AccessControl
                [[p (PEPYPARM) arg -> accessControl]]
                OPTIONAL <<arg -> accessControl>>,

            synchronization[6]
                IMPLICIT CMISSync
                [[p (PEPYPARM) arg -> synchronization]]
                DEFAULT bestEffort <<arg -> synchronization>>,

            filter
                CMISFilter
                [[p (PEPYPARM) arg -> filter]]
                OPTIONAL <<arg -> filter>>,

            mgmtInfoList[11]
                IMPLICIT SEQUENCE OF
                    <<element_CMIP_2 = arg -> element_CMIP_2;
                            element_CMIP_2;
                            element_CMIP_2 = element_CMIP_2 -> next>>
                    MgmtInfo
                    [[p (PEPYPARM) element_CMIP_2 -> MgmtInfo]]
        }

SetResult
    %{
	struct type_CMIP_SetResult *arg =
			(struct type_CMIP_SetResult *) parm;
	struct element_CMIP_3 *element_CMIP_3;
    %}
    ::=
        SEQUENCE %{ element_CMIP_3 = arg -> element_CMIP_3; %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]]
                OPTIONAL <<arg -> managedObjectClass>>,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]]
                OPTIONAL <<arg -> managedObjectInstance>>,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) arg -> currentTime]]
                OPTIONAL <<arg -> currentTime>>,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    <<element_CMIP_3 = arg -> element_CMIP_3;
                            element_CMIP_3;
                            element_CMIP_3 = element_CMIP_3 -> next>>
                    MgmtInfo
                    [[p (PEPYPARM) element_CMIP_3 -> MgmtInfo]]
        }

ActionArgument
    %{
	struct type_CMIP_ActionArgument *arg =
			(struct type_CMIP_ActionArgument *) parm;
    %}
    ::=
        SEQUENCE {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]],

            accessControl[5]
                AccessControl
                [[p (PEPYPARM) arg -> accessControl]]
                OPTIONAL <<arg -> accessControl>>,

            filter
                CMISFilter
                [[p (PEPYPARM) arg -> filter]]
                OPTIONAL <<arg -> filter>>,

            actionType[11]
                ActionTypeId
                [[p (PEPYPARM) arg -> actionType]],

            actionInfo[12]
                ActionInfo
                [[p (PEPYPARM) arg -> actionInfo]]
                OPTIONAL <<arg -> actionInfo>>
        }

ActionResult
    %{
	struct type_CMIP_ActionResult *arg =
			(struct type_CMIP_ActionResult *) parm;
    %}
    ::=
        SEQUENCE {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]]
                OPTIONAL <<arg -> managedObjectClass>>,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]]
                OPTIONAL <<arg -> managedObjectInstance>>,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) arg -> currentTime]]
                OPTIONAL <<arg -> currentTime>>,

            actionResult[6]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> actionResult]]
        }

NoSuchObject
    %{
	struct type_CMIP_NoSuchObject *arg =
			(struct type_CMIP_NoSuchObject *) parm;
    %}
    ::=
        OBJECT IDENTIFIER
        [[O arg]]

SyncNotSupported
    %{
	struct type_CMIP_SyncNotSupported *arg =
			(struct type_CMIP_SyncNotSupported *) parm;
    %}
    ::=
        CMISSync
        [[p (PEPYPARM) arg]]

InvalidFilter
    %{
	struct type_CMIP_InvalidFilter *arg =
			(struct type_CMIP_InvalidFilter *) parm;
    %}
    ::=
        CMISFilter
        [[p (PEPYPARM) arg]]

NoSuchMgmtInfoId
    %{
	struct type_CMIP_NoSuchMgmtInfoId *arg =
			(struct type_CMIP_NoSuchMgmtInfoId *) parm;
    %}
    ::=
        MgmtInfoId
        [[p (PEPYPARM) arg]]

InvalidMgmtInfoValue
    %{
	struct type_CMIP_InvalidMgmtInfoValue *arg =
			(struct type_CMIP_InvalidMgmtInfoValue *) parm;
    %}
    ::=
        MgmtInfo
        [[p (PEPYPARM) arg]]

GetListError
    %{
	struct type_CMIP_GetListError *arg =
			(struct type_CMIP_GetListError *) parm;
	struct element_CMIP_4 *element_CMIP_4;
    %}
    ::=
        SEQUENCE %{ element_CMIP_4 = arg -> element_CMIP_4; %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]]
                OPTIONAL <<arg -> managedObjectClass>>,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]]
                OPTIONAL <<arg -> managedObjectInstance>>,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) arg -> currentTime]]
                OPTIONAL <<arg -> currentTime>>,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    <<element_CMIP_4 = arg -> element_CMIP_4;
                            element_CMIP_4;
                            element_CMIP_4 = element_CMIP_4 -> next>>
                    MISGetInfoStatus
                    [[p (PEPYPARM) element_CMIP_4 -> MISGetInfoStatus]]
        }

MISGetInfoStatus
    %{
	struct type_CMIP_MISGetInfoStatus *arg =
			(struct type_CMIP_MISGetInfoStatus *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            mgmtInfoIdError[0]
                IMPLICIT MgmtInfoIdError
                [[p (PEPYPARM) arg -> un.mgmtInfoIdError]],

            mgmtInfo[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> un.mgmtInfo]]
        }

MgmtInfoIdError
    %{
	struct type_CMIP_MgmtInfoIdError *arg =
			(struct type_CMIP_MgmtInfoIdError *) parm;
    %}
    ::=
        SEQUENCE {
            errorStatus[0]
                IMPLICIT ErrorStatus
                [[p (PEPYPARM) arg -> errorStatus]],

            mgmtInfoId[1]
                MgmtInfoId
                [[p (PEPYPARM) arg -> mgmtInfoId]]
        }

SetListError
    %{
	struct type_CMIP_SetListError *arg =
			(struct type_CMIP_SetListError *) parm;
	struct element_CMIP_5 *element_CMIP_5;
    %}
    ::=
        SEQUENCE %{ element_CMIP_5 = arg -> element_CMIP_5; %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) arg -> managedObjectClass]]
                OPTIONAL <<arg -> managedObjectClass>>,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) arg -> managedObjectInstance]]
                OPTIONAL <<arg -> managedObjectInstance>>,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) arg -> currentTime]]
                OPTIONAL <<arg -> currentTime>>,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    <<element_CMIP_5 = arg -> element_CMIP_5;
                            element_CMIP_5;
                            element_CMIP_5 = element_CMIP_5 -> next>>
                    MISSetInfoStatus
                    [[p (PEPYPARM) element_CMIP_5 -> MISSetInfoStatus]]
        }

MISSetInfoStatus
    %{
	struct type_CMIP_MISSetInfoStatus *arg =
			(struct type_CMIP_MISSetInfoStatus *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            mgmtInfoError[0]
                IMPLICIT MgmtInfoError
                [[p (PEPYPARM) arg -> un.mgmtInfoError]],

            mgmtInfo[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> un.mgmtInfo]]
        }

MgmtInfoError
    %{
	struct type_CMIP_MgmtInfoError *arg =
			(struct type_CMIP_MgmtInfoError *) parm;
    %}
    ::=
        SEQUENCE {
            errorStatus[0]
                IMPLICIT ErrorStatus
                [[p (PEPYPARM) arg -> errorStatus]],

            mgmtInfo[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> mgmtInfo]]
        }

ErrorStatus
    %{
	struct type_CMIP_ErrorStatus *arg =
			(struct type_CMIP_ErrorStatus *) parm;
    %}
    ::=
        INTEGER
        [[i arg -> arg]]
        {
            accessDenied(2),
            noSuchMgmtInfoId(5),
            invalidMgmtInfoValue(7)
        }

NoSuchAction
    %{
	struct type_CMIP_NoSuchAction *arg =
			(struct type_CMIP_NoSuchAction *) parm;
    %}
    ::=
        ActionTypeId
        [[p (PEPYPARM) arg]]

ProcessingFailure
    %{
	struct type_CMIP_ProcessingFailure *arg =
			(struct type_CMIP_ProcessingFailure *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            actual[0]
                SpecificErrorInfo
                [[p (PEPYPARM) arg -> un.actual]],

            none[1]
                IMPLICIT NULL
        }

NoSuchEventType
    %{
	struct type_CMIP_NoSuchEventType *arg =
			(struct type_CMIP_NoSuchEventType *) parm;
    %}
    ::=
        EventTypeID
        [[p (PEPYPARM) arg]]

ObjectClass
    %{
	struct type_CMIP_ObjectClass *arg =
			(struct type_CMIP_ObjectClass *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            globalForm[0]
                IMPLICIT OBJECT IDENTIFIER
                [[O arg -> un.globalForm]],

            nonSpecificForm[1]
                IMPLICIT OCTET STRING
                [[o (arg -> un.nonSpecificForm) ? arg -> un.nonSpecificForm -> qb_base : NULLCP
                    $ (arg -> un.nonSpecificForm) ? arg -> un.nonSpecificForm -> qb_len : 0]]
        }

ObjectInstance
    %{
	struct type_CMIP_ObjectInstance *arg =
			(struct type_CMIP_ObjectInstance *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            distinguishedName[2]
                IMPLICIT DistinguishedName
                [[p (PEPYPARM) arg -> un.distinguishedName]],

            nonSpecificForm[3]
                IMPLICIT OCTET STRING
                [[o (arg -> un.nonSpecificForm) ? arg -> un.nonSpecificForm -> qb_base : NULLCP
                    $ (arg -> un.nonSpecificForm) ? arg -> un.nonSpecificForm -> qb_len : 0]],

            enumeratedForm[4]
                IMPLICIT INTEGER
                [[i arg -> un.enumeratedForm]]
        }

CMISSync
    %{
	struct type_CMIP_CMISSync *arg =
			(struct type_CMIP_CMISSync *) parm;
    %}
    ::=
        INTEGER
        [[i arg -> arg]]
        {
            bestEffort(0),
            ordered(1),
            stopOnError(2),
            atomic(3)
        }

CMISFilter
    %{
	struct type_CMIP_CMISFilter *arg =
			(struct type_CMIP_CMISFilter *) parm;
	struct member_CMIP_0 *member_CMIP_0;
	struct member_CMIP_1 *member_CMIP_1;
    %}
    ::=
        CHOICE
            %{
                member_CMIP_0 = arg -> un.member_CMIP_0;
                member_CMIP_1 = arg -> un.member_CMIP_1;
            %}
            <<arg -> offset>>
        {
            item[7]
                FilterItem
                [[p (PEPYPARM) arg -> un.item]],

            and[8]
                IMPLICIT SET OF
                    <<member_CMIP_0 = arg -> un.member_CMIP_0;
                            member_CMIP_0;
                            member_CMIP_0 = member_CMIP_0 -> next>>
                    CMISFilter
                    [[p (PEPYPARM) member_CMIP_0 -> CMISFilter]],

            or[9]
                IMPLICIT SET OF
                    <<member_CMIP_1 = arg -> un.member_CMIP_1;
                            member_CMIP_1;
                            member_CMIP_1 = member_CMIP_1 -> next>>
                    CMISFilter
                    [[p (PEPYPARM) member_CMIP_1 -> CMISFilter]],

            not[10]
                CMISFilter
                [[p (PEPYPARM) arg -> un.not]]
        }

FilterItem
    %{
	struct type_CMIP_FilterItem *arg =
			(struct type_CMIP_FilterItem *) parm;
    %}
    ::=
        CHOICE <<arg -> offset>> {
            equality[0]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> un.equality]],

            greaterOrEqual[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> un.greaterOrEqual]],

            lessOrEqual[2]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) arg -> un.lessOrEqual]],

            present[3]
                MgmtInfoID
                [[p (PEPYPARM) arg -> un.present]]
        }

AccessControl
    %{
	struct type_CMIP_AccessControl *arg =
			(struct type_CMIP_AccessControl *) parm;
    %}
    ::=
        ANY
        [[a arg]]

EventTypeId
    %{
	struct type_CMIP_EventTypeId *arg =
			(struct type_CMIP_EventTypeId *) parm;
    %}
    ::=
        ANY
        [[a arg]]

EventInfo
    %{
	struct type_CMIP_EventInfo *arg =
			(struct type_CMIP_EventInfo *) parm;
    %}
    ::=
        ANY
        [[a arg]]

MgmtInfo
    %{
	struct type_CMIP_MgmtInfo *arg =
			(struct type_CMIP_MgmtInfo *) parm;
    %}
    ::=
        SEQUENCE {
                MgmtInfoId
                [[p (PEPYPARM) arg -> element_CMIP_6]],

                MgmtInfoValue
                [[p (PEPYPARM) arg -> element_CMIP_7]]
        }

MgmtInfoId
    %{
	struct type_CMIP_MgmtInfoId *arg =
			(struct type_CMIP_MgmtInfoId *) parm;
    %}
    ::=
        ANY
        [[a arg]]

MgmtInfoValue
    %{
	struct type_CMIP_MgmtInfoValue *arg =
			(struct type_CMIP_MgmtInfoValue *) parm;
    %}
    ::=
        ANY
        [[a arg]]

ActionTypeId
    %{
	struct type_CMIP_ActionTypeId *arg =
			(struct type_CMIP_ActionTypeId *) parm;
    %}
    ::=
        ANY
        [[a arg]]

ActionInfo
    %{
	struct type_CMIP_ActionInfo *arg =
			(struct type_CMIP_ActionInfo *) parm;
    %}
    ::=
        ANY
        [[a arg]]

SpecificErrorInfo
    %{
	struct type_CMIP_SpecificErrorInfo *arg =
			(struct type_CMIP_SpecificErrorInfo *) parm;
    %}
    ::=
        ANY
        [[a arg]]

DECODER decode

EventReportArgument
    %{
	struct type_CMIP_EventReportArgument **arg =
			(struct type_CMIP_EventReportArgument **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_EventReportArgument *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_EventReportArgument *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        SEQUENCE {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]],

            eventType[5]
                EventTypeID
                [[p (PEPYPARM) &((*arg) -> eventType)]],

            eventTime[6]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) &((*arg) -> eventTime)]]
                OPTIONAL,

            eventInfo[7]
                EventInfo
                [[p (PEPYPARM) &((*arg) -> eventInfo)]]
                OPTIONAL
        }

EventReportResult
    %{
	struct type_CMIP_EventReportResult **arg =
			(struct type_CMIP_EventReportResult **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_EventReportResult *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_EventReportResult *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        NULL

LinkedReplyArgument
    %{
	struct type_CMIP_LinkedReplyArgument **arg =
			(struct type_CMIP_LinkedReplyArgument **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_LinkedReplyArgument *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_LinkedReplyArgument *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            getResult[0]
                IMPLICIT GetResult
                [[p (PEPYPARM) &((*arg) -> un.getResult)]]
                %{ (*(arg)) -> offset = type_CMIP_LinkedReplyArgument_getResult; %},

            getError[1]
                IMPLICIT GetListError
                [[p (PEPYPARM) &((*arg) -> un.getError)]]
                %{ (*(arg)) -> offset = type_CMIP_LinkedReplyArgument_getError; %},

            setResult[2]
                IMPLICIT SetResult
                [[p (PEPYPARM) &((*arg) -> un.setResult)]]
                %{ (*(arg)) -> offset = type_CMIP_LinkedReplyArgument_setResult; %},

            setError[3]
                IMPLICIT SetListError
                [[p (PEPYPARM) &((*arg) -> un.setError)]]
                %{ (*(arg)) -> offset = type_CMIP_LinkedReplyArgument_setError; %},

            actionResult[4]
                IMPLICIT ActionResult
                [[p (PEPYPARM) &((*arg) -> un.actionResult)]]
                %{ (*(arg)) -> offset = type_CMIP_LinkedReplyArgument_actionResult; %}
        }

GetArgument
    %{
	struct type_CMIP_GetArgument **arg =
			(struct type_CMIP_GetArgument **) parm;
	struct element_CMIP_0 **element_CMIP_0;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_GetArgument *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_GetArgument *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        element_CMIP_0 = &((*arg) -> element_CMIP_0);
    %}
        SEQUENCE %{ element_CMIP_0 = &((*arg) -> element_CMIP_0); %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]],

            accessControl[5]
                AccessControl
                [[p (PEPYPARM) &((*arg) -> accessControl)]]
                OPTIONAL,

            synchronization[6]
                IMPLICIT CMISSync
                [[p (PEPYPARM) &((*arg) -> synchronization)]]
                DEFAULT bestEffort,

            filter
                CMISFilter
                [[p (PEPYPARM) &((*arg) -> filter)]]
                OPTIONAL,

            mgmtInfoIdList[11]
                IMPLICIT SEQUENCE OF
                    %{
                        if ((*(element_CMIP_0) = (struct element_CMIP_0 *)
                                calloc (1, sizeof **(element_CMIP_0))) == ((struct element_CMIP_0 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    MgmtInfoId
                    [[p (PEPYPARM) &((*element_CMIP_0) -> MgmtInfoId)]]
                    %{ element_CMIP_0 = &((*element_CMIP_0) -> next); %}
        }

GetResult
    %{
	struct type_CMIP_GetResult **arg =
			(struct type_CMIP_GetResult **) parm;
	struct element_CMIP_1 **element_CMIP_1;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_GetResult *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_GetResult *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        element_CMIP_1 = &((*arg) -> element_CMIP_1);
    %}
        SEQUENCE %{ element_CMIP_1 = &((*arg) -> element_CMIP_1); %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]]
                OPTIONAL,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]]
                OPTIONAL,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) &((*arg) -> currentTime)]]
                OPTIONAL,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    %{
                        if ((*(element_CMIP_1) = (struct element_CMIP_1 *)
                                calloc (1, sizeof **(element_CMIP_1))) == ((struct element_CMIP_1 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    MgmtInfo
                    [[p (PEPYPARM) &((*element_CMIP_1) -> MgmtInfo)]]
                    %{ element_CMIP_1 = &((*element_CMIP_1) -> next); %}
        }

SetArgument
    %{
	struct type_CMIP_SetArgument **arg =
			(struct type_CMIP_SetArgument **) parm;
	struct element_CMIP_2 **element_CMIP_2;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_SetArgument *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_SetArgument *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        element_CMIP_2 = &((*arg) -> element_CMIP_2);
    %}
        SEQUENCE %{ element_CMIP_2 = &((*arg) -> element_CMIP_2); %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]],

            accessControl[5]
                AccessControl
                [[p (PEPYPARM) &((*arg) -> accessControl)]]
                OPTIONAL,

            synchronization[6]
                IMPLICIT CMISSync
                [[p (PEPYPARM) &((*arg) -> synchronization)]]
                DEFAULT bestEffort,

            filter
                CMISFilter
                [[p (PEPYPARM) &((*arg) -> filter)]]
                OPTIONAL,

            mgmtInfoList[11]
                IMPLICIT SEQUENCE OF
                    %{
                        if ((*(element_CMIP_2) = (struct element_CMIP_2 *)
                                calloc (1, sizeof **(element_CMIP_2))) == ((struct element_CMIP_2 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    MgmtInfo
                    [[p (PEPYPARM) &((*element_CMIP_2) -> MgmtInfo)]]
                    %{ element_CMIP_2 = &((*element_CMIP_2) -> next); %}
        }

SetResult
    %{
	struct type_CMIP_SetResult **arg =
			(struct type_CMIP_SetResult **) parm;
	struct element_CMIP_3 **element_CMIP_3;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_SetResult *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_SetResult *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        element_CMIP_3 = &((*arg) -> element_CMIP_3);
    %}
        SEQUENCE %{ element_CMIP_3 = &((*arg) -> element_CMIP_3); %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]]
                OPTIONAL,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]]
                OPTIONAL,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) &((*arg) -> currentTime)]]
                OPTIONAL,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    %{
                        if ((*(element_CMIP_3) = (struct element_CMIP_3 *)
                                calloc (1, sizeof **(element_CMIP_3))) == ((struct element_CMIP_3 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    MgmtInfo
                    [[p (PEPYPARM) &((*element_CMIP_3) -> MgmtInfo)]]
                    %{ element_CMIP_3 = &((*element_CMIP_3) -> next); %}
        }

ActionArgument
    %{
	struct type_CMIP_ActionArgument **arg =
			(struct type_CMIP_ActionArgument **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_ActionArgument *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_ActionArgument *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        SEQUENCE {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]],

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]],

            accessControl[5]
                AccessControl
                [[p (PEPYPARM) &((*arg) -> accessControl)]]
                OPTIONAL,

            filter
                CMISFilter
                [[p (PEPYPARM) &((*arg) -> filter)]]
                OPTIONAL,

            actionType[11]
                ActionTypeId
                [[p (PEPYPARM) &((*arg) -> actionType)]],

            actionInfo[12]
                ActionInfo
                [[p (PEPYPARM) &((*arg) -> actionInfo)]]
                OPTIONAL
        }

ActionResult
    %{
	struct type_CMIP_ActionResult **arg =
			(struct type_CMIP_ActionResult **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_ActionResult *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_ActionResult *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        SEQUENCE {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]]
                OPTIONAL,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]]
                OPTIONAL,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) &((*arg) -> currentTime)]]
                OPTIONAL,

            actionResult[6]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> actionResult)]]
        }

NoSuchObject
    %{
	struct type_CMIP_NoSuchObject **arg =
			(struct type_CMIP_NoSuchObject **) parm;
    %}
    ::=
        OBJECT IDENTIFIER
        [[O (*arg)]]

SyncNotSupported
    %{
	struct type_CMIP_SyncNotSupported **arg =
			(struct type_CMIP_SyncNotSupported **) parm;
    %}
    ::=
        CMISSync
        [[p (PEPYPARM) &((*arg))]]

InvalidFilter
    %{
	struct type_CMIP_InvalidFilter **arg =
			(struct type_CMIP_InvalidFilter **) parm;
    %}
    ::=
        CMISFilter
        [[p (PEPYPARM) &((*arg))]]

NoSuchMgmtInfoId
    %{
	struct type_CMIP_NoSuchMgmtInfoId **arg =
			(struct type_CMIP_NoSuchMgmtInfoId **) parm;
    %}
    ::=
        MgmtInfoId
        [[p (PEPYPARM) &((*arg))]]

InvalidMgmtInfoValue
    %{
	struct type_CMIP_InvalidMgmtInfoValue **arg =
			(struct type_CMIP_InvalidMgmtInfoValue **) parm;
    %}
    ::=
        MgmtInfo
        [[p (PEPYPARM) &((*arg))]]

GetListError
    %{
	struct type_CMIP_GetListError **arg =
			(struct type_CMIP_GetListError **) parm;
	struct element_CMIP_4 **element_CMIP_4;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_GetListError *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_GetListError *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        element_CMIP_4 = &((*arg) -> element_CMIP_4);
    %}
        SEQUENCE %{ element_CMIP_4 = &((*arg) -> element_CMIP_4); %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]]
                OPTIONAL,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]]
                OPTIONAL,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) &((*arg) -> currentTime)]]
                OPTIONAL,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    %{
                        if ((*(element_CMIP_4) = (struct element_CMIP_4 *)
                                calloc (1, sizeof **(element_CMIP_4))) == ((struct element_CMIP_4 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    MISGetInfoStatus
                    [[p (PEPYPARM) &((*element_CMIP_4) -> MISGetInfoStatus)]]
                    %{ element_CMIP_4 = &((*element_CMIP_4) -> next); %}
        }

MISGetInfoStatus
    %{
	struct type_CMIP_MISGetInfoStatus **arg =
			(struct type_CMIP_MISGetInfoStatus **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_MISGetInfoStatus *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_MISGetInfoStatus *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            mgmtInfoIdError[0]
                IMPLICIT MgmtInfoIdError
                [[p (PEPYPARM) &((*arg) -> un.mgmtInfoIdError)]]
                %{ (*(arg)) -> offset = type_CMIP_MISGetInfoStatus_mgmtInfoIdError; %},

            mgmtInfo[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> un.mgmtInfo)]]
                %{ (*(arg)) -> offset = type_CMIP_MISGetInfoStatus_mgmtInfo; %}
        }

MgmtInfoIdError
    %{
	struct type_CMIP_MgmtInfoIdError **arg =
			(struct type_CMIP_MgmtInfoIdError **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_MgmtInfoIdError *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_MgmtInfoIdError *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        SEQUENCE {
            errorStatus[0]
                IMPLICIT ErrorStatus
                [[p (PEPYPARM) &((*arg) -> errorStatus)]],

            mgmtInfoId[1]
                MgmtInfoId
                [[p (PEPYPARM) &((*arg) -> mgmtInfoId)]]
        }

SetListError
    %{
	struct type_CMIP_SetListError **arg =
			(struct type_CMIP_SetListError **) parm;
	struct element_CMIP_5 **element_CMIP_5;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_SetListError *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_SetListError *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        element_CMIP_5 = &((*arg) -> element_CMIP_5);
    %}
        SEQUENCE %{ element_CMIP_5 = &((*arg) -> element_CMIP_5); %} {
            managedObjectClass
                ObjectClass
                [[p (PEPYPARM) &((*arg) -> managedObjectClass)]]
                OPTIONAL,

            managedObjectInstance
                ObjectInstance
                [[p (PEPYPARM) &((*arg) -> managedObjectInstance)]]
                OPTIONAL,

            currentTime[5]
                IMPLICIT GeneralizedTime
                [[p (PEPYPARM) &((*arg) -> currentTime)]]
                OPTIONAL,

            mgmtInfoList[6]
                IMPLICIT SEQUENCE OF
                    %{
                        if ((*(element_CMIP_5) = (struct element_CMIP_5 *)
                                calloc (1, sizeof **(element_CMIP_5))) == ((struct element_CMIP_5 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    MISSetInfoStatus
                    [[p (PEPYPARM) &((*element_CMIP_5) -> MISSetInfoStatus)]]
                    %{ element_CMIP_5 = &((*element_CMIP_5) -> next); %}
        }

MISSetInfoStatus
    %{
	struct type_CMIP_MISSetInfoStatus **arg =
			(struct type_CMIP_MISSetInfoStatus **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_MISSetInfoStatus *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_MISSetInfoStatus *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            mgmtInfoError[0]
                IMPLICIT MgmtInfoError
                [[p (PEPYPARM) &((*arg) -> un.mgmtInfoError)]]
                %{ (*(arg)) -> offset = type_CMIP_MISSetInfoStatus_mgmtInfoError; %},

            mgmtInfo[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> un.mgmtInfo)]]
                %{ (*(arg)) -> offset = type_CMIP_MISSetInfoStatus_mgmtInfo; %}
        }

MgmtInfoError
    %{
	struct type_CMIP_MgmtInfoError **arg =
			(struct type_CMIP_MgmtInfoError **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_MgmtInfoError *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_MgmtInfoError *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        SEQUENCE {
            errorStatus[0]
                IMPLICIT ErrorStatus
                [[p (PEPYPARM) &((*arg) -> errorStatus)]],

            mgmtInfo[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> mgmtInfo)]]
        }

ErrorStatus
    %{
	struct type_CMIP_ErrorStatus **arg =
			(struct type_CMIP_ErrorStatus **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_ErrorStatus *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_ErrorStatus *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        INTEGER
        [[i (*arg) -> arg]]
        {
            accessDenied(2),
            noSuchMgmtInfoId(5),
            invalidMgmtInfoValue(7)
        }

NoSuchAction
    %{
	struct type_CMIP_NoSuchAction **arg =
			(struct type_CMIP_NoSuchAction **) parm;
    %}
    ::=
        ActionTypeId
        [[p (PEPYPARM) &((*arg))]]

ProcessingFailure
    %{
	struct type_CMIP_ProcessingFailure **arg =
			(struct type_CMIP_ProcessingFailure **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_ProcessingFailure *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_ProcessingFailure *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            actual[0]
                SpecificErrorInfo
                [[p (PEPYPARM) &((*arg) -> un.actual)]]
                %{ (*(arg)) -> offset = type_CMIP_ProcessingFailure_actual; %},

            none[1]
                IMPLICIT NULL
                %{ (*(arg)) -> offset = type_CMIP_ProcessingFailure_none; %}
        }

NoSuchEventType
    %{
	struct type_CMIP_NoSuchEventType **arg =
			(struct type_CMIP_NoSuchEventType **) parm;
    %}
    ::=
        EventTypeID
        [[p (PEPYPARM) &((*arg))]]

ObjectClass
    %{
	struct type_CMIP_ObjectClass **arg =
			(struct type_CMIP_ObjectClass **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_ObjectClass *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_ObjectClass *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            globalForm[0]
                IMPLICIT OBJECT IDENTIFIER
                [[O (*arg) -> un.globalForm]]
                %{ (*(arg)) -> offset = type_CMIP_ObjectClass_globalForm; %},

            nonSpecificForm[1]
                IMPLICIT OCTET STRING
                %{
                    if (((*arg) -> un.nonSpecificForm = str2qb ($$, $$_len)) == ((struct qbuf *) 0)) {
                        advise (NULLCP, "out of memory");
                        return NOTOK;
                    }

                    (*(arg)) -> offset = type_CMIP_ObjectClass_nonSpecificForm;
                %}
        }

ObjectInstance
    %{
	struct type_CMIP_ObjectInstance **arg =
			(struct type_CMIP_ObjectInstance **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_ObjectInstance *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_ObjectInstance *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            distinguishedName[2]
                IMPLICIT DistinguishedName
                [[p (PEPYPARM) &((*arg) -> un.distinguishedName)]]
                %{ (*(arg)) -> offset = type_CMIP_ObjectInstance_distinguishedName; %},

            nonSpecificForm[3]
                IMPLICIT OCTET STRING
                %{
                    if (((*arg) -> un.nonSpecificForm = str2qb ($$, $$_len)) == ((struct qbuf *) 0)) {
                        advise (NULLCP, "out of memory");
                        return NOTOK;
                    }

                    (*(arg)) -> offset = type_CMIP_ObjectInstance_nonSpecificForm;
                %},

            enumeratedForm[4]
                IMPLICIT INTEGER
                [[i (*arg) -> un.enumeratedForm]]
                %{ (*(arg)) -> offset = type_CMIP_ObjectInstance_enumeratedForm; %}
        }

CMISSync
    %{
	struct type_CMIP_CMISSync **arg =
			(struct type_CMIP_CMISSync **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_CMISSync *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_CMISSync *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        INTEGER
        [[i (*arg) -> arg]]
        {
            bestEffort(0),
            ordered(1),
            stopOnError(2),
            atomic(3)
        }

CMISFilter
    %{
	struct type_CMIP_CMISFilter **arg =
			(struct type_CMIP_CMISFilter **) parm;
	struct member_CMIP_0 **member_CMIP_0;
	struct member_CMIP_1 **member_CMIP_1;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_CMISFilter *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_CMISFilter *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
        member_CMIP_0 = &((*arg) -> un.member_CMIP_0);
        member_CMIP_1 = &((*arg) -> un.member_CMIP_1);
    %}
        CHOICE
        {
            item[7]
                FilterItem
                [[p (PEPYPARM) &((*arg) -> un.item)]]
                %{ (*(arg)) -> offset = type_CMIP_CMISFilter_item; %},

            and[8]
                IMPLICIT SET OF
                    %{
                        if ((*(member_CMIP_0) = (struct member_CMIP_0 *)
                                calloc (1, sizeof **(member_CMIP_0))) == ((struct member_CMIP_0 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    CMISFilter
                    [[p (PEPYPARM) &((*member_CMIP_0) -> CMISFilter)]]
                    %{ member_CMIP_0 = &((*member_CMIP_0) -> next); (*(arg)) -> offset = type_CMIP_CMISFilter_and; %},

            or[9]
                IMPLICIT SET OF
                    %{
                        if ((*(member_CMIP_1) = (struct member_CMIP_1 *)
                                calloc (1, sizeof **(member_CMIP_1))) == ((struct member_CMIP_1 *) 0)) {
                            advise (NULLCP, "out of memory");
                            return NOTOK;
                        }
                    %}
                    CMISFilter
                    [[p (PEPYPARM) &((*member_CMIP_1) -> CMISFilter)]]
                    %{ member_CMIP_1 = &((*member_CMIP_1) -> next); (*(arg)) -> offset = type_CMIP_CMISFilter_or; %},

            not[10]
                CMISFilter
                [[p (PEPYPARM) &((*arg) -> un.not)]]
                %{ (*(arg)) -> offset = type_CMIP_CMISFilter_not; %}
        }

FilterItem
    %{
	struct type_CMIP_FilterItem **arg =
			(struct type_CMIP_FilterItem **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_FilterItem *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_FilterItem *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        CHOICE
        {
            equality[0]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> un.equality)]]
                %{ (*(arg)) -> offset = type_CMIP_FilterItem_equality; %},

            greaterOrEqual[1]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> un.greaterOrEqual)]]
                %{ (*(arg)) -> offset = type_CMIP_FilterItem_greaterOrEqual; %},

            lessOrEqual[2]
                IMPLICIT MgmtInfo
                [[p (PEPYPARM) &((*arg) -> un.lessOrEqual)]]
                %{ (*(arg)) -> offset = type_CMIP_FilterItem_lessOrEqual; %},

            present[3]
                MgmtInfoID
                [[p (PEPYPARM) &((*arg) -> un.present)]]
                %{ (*(arg)) -> offset = type_CMIP_FilterItem_present; %}
        }

AccessControl
    %{
	struct type_CMIP_AccessControl **arg =
			(struct type_CMIP_AccessControl **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

EventTypeId
    %{
	struct type_CMIP_EventTypeId **arg =
			(struct type_CMIP_EventTypeId **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

EventInfo
    %{
	struct type_CMIP_EventInfo **arg =
			(struct type_CMIP_EventInfo **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

MgmtInfo
    %{
	struct type_CMIP_MgmtInfo **arg =
			(struct type_CMIP_MgmtInfo **) parm;
    %}
    ::=
    %{
        if ((*(arg) = (struct type_CMIP_MgmtInfo *)
                calloc (1, sizeof **(arg))) == ((struct type_CMIP_MgmtInfo *) 0)) {
            advise (NULLCP, "out of memory");
            return NOTOK;
        }
    %}
        SEQUENCE {
                MgmtInfoId
                [[p (PEPYPARM) &((*arg) -> element_CMIP_6)]],

                MgmtInfoValue
                [[p (PEPYPARM) &((*arg) -> element_CMIP_7)]]
        }

MgmtInfoId
    %{
	struct type_CMIP_MgmtInfoId **arg =
			(struct type_CMIP_MgmtInfoId **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

MgmtInfoValue
    %{
	struct type_CMIP_MgmtInfoValue **arg =
			(struct type_CMIP_MgmtInfoValue **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

ActionTypeId
    %{
	struct type_CMIP_ActionTypeId **arg =
			(struct type_CMIP_ActionTypeId **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

ActionInfo
    %{
	struct type_CMIP_ActionInfo **arg =
			(struct type_CMIP_ActionInfo **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

SpecificErrorInfo
    %{
	struct type_CMIP_SpecificErrorInfo **arg =
			(struct type_CMIP_SpecificErrorInfo **) parm;
    %}
    ::=
        ANY
        [[a (*arg)]]

END

%{

free_CMIP_EventReportArgument (arg)
struct type_CMIP_EventReportArgument *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> eventType)
        free_CMIP_EventTypeID (arg -> eventType),
            arg -> eventType = NULL;
    if (arg -> eventTime)
        free_UNIV_GeneralizedTime (arg -> eventTime),
            arg -> eventTime = NULL;
    if (arg -> eventInfo)
        free_CMIP_EventInfo (arg -> eventInfo),
            arg -> eventInfo = NULL;

    if (arg)
	free ((char *) arg);
}

free_CMIP_EventReportResult (arg)
struct type_CMIP_EventReportResult *arg;
{
    if (arg == NULL)
	return;


    if (arg)
	free ((char *) arg);
}

free_CMIP_LinkedReplyArgument (arg)
struct type_CMIP_LinkedReplyArgument *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_LinkedReplyArgument_getResult:
            if (arg -> un.getResult)
                free_CMIP_GetResult (arg -> un.getResult),
                    arg -> un.getResult = NULL;
            break;

        case type_CMIP_LinkedReplyArgument_getError:
            if (arg -> un.getError)
                free_CMIP_GetListError (arg -> un.getError),
                    arg -> un.getError = NULL;
            break;

        case type_CMIP_LinkedReplyArgument_setResult:
            if (arg -> un.setResult)
                free_CMIP_SetResult (arg -> un.setResult),
                    arg -> un.setResult = NULL;
            break;

        case type_CMIP_LinkedReplyArgument_setError:
            if (arg -> un.setError)
                free_CMIP_SetListError (arg -> un.setError),
                    arg -> un.setError = NULL;
            break;

        case type_CMIP_LinkedReplyArgument_actionResult:
            if (arg -> un.actionResult)
                free_CMIP_ActionResult (arg -> un.actionResult),
                    arg -> un.actionResult = NULL;
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_GetArgument (arg)
struct type_CMIP_GetArgument *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> accessControl)
        free_CMIP_AccessControl (arg -> accessControl),
            arg -> accessControl = NULL;
    if (arg -> synchronization)
        free_CMIP_CMISSync (arg -> synchronization),
            arg -> synchronization = NULL;
    if (arg -> filter)
        free_CMIP_CMISFilter (arg -> filter),
            arg -> filter = NULL;
    {
        struct element_CMIP_0 *element_CMIP_0;

        for (element_CMIP_0 = arg -> element_CMIP_0;
                element_CMIP_0;
                element_CMIP_0 = element_CMIP_0 -> next) {
            if (element_CMIP_0 -> MgmtInfoId)
                free_CMIP_MgmtInfoId (element_CMIP_0 -> MgmtInfoId),
                    element_CMIP_0 -> MgmtInfoId = NULL;

            if (element_CMIP_0)
                free ((char *) element_CMIP_0);
        }

        arg -> element_CMIP_0 = NULL;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_GetResult (arg)
struct type_CMIP_GetResult *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> currentTime)
        free_UNIV_GeneralizedTime (arg -> currentTime),
            arg -> currentTime = NULL;
    {
        struct element_CMIP_1 *element_CMIP_1;

        for (element_CMIP_1 = arg -> element_CMIP_1;
                element_CMIP_1;
                element_CMIP_1 = element_CMIP_1 -> next) {
            if (element_CMIP_1 -> MgmtInfo)
                free_CMIP_MgmtInfo (element_CMIP_1 -> MgmtInfo),
                    element_CMIP_1 -> MgmtInfo = NULL;

            if (element_CMIP_1)
                free ((char *) element_CMIP_1);
        }

        arg -> element_CMIP_1 = NULL;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_SetArgument (arg)
struct type_CMIP_SetArgument *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> accessControl)
        free_CMIP_AccessControl (arg -> accessControl),
            arg -> accessControl = NULL;
    if (arg -> synchronization)
        free_CMIP_CMISSync (arg -> synchronization),
            arg -> synchronization = NULL;
    if (arg -> filter)
        free_CMIP_CMISFilter (arg -> filter),
            arg -> filter = NULL;
    {
        struct element_CMIP_2 *element_CMIP_2;

        for (element_CMIP_2 = arg -> element_CMIP_2;
                element_CMIP_2;
                element_CMIP_2 = element_CMIP_2 -> next) {
            if (element_CMIP_2 -> MgmtInfo)
                free_CMIP_MgmtInfo (element_CMIP_2 -> MgmtInfo),
                    element_CMIP_2 -> MgmtInfo = NULL;

            if (element_CMIP_2)
                free ((char *) element_CMIP_2);
        }

        arg -> element_CMIP_2 = NULL;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_SetResult (arg)
struct type_CMIP_SetResult *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> currentTime)
        free_UNIV_GeneralizedTime (arg -> currentTime),
            arg -> currentTime = NULL;
    {
        struct element_CMIP_3 *element_CMIP_3;

        for (element_CMIP_3 = arg -> element_CMIP_3;
                element_CMIP_3;
                element_CMIP_3 = element_CMIP_3 -> next) {
            if (element_CMIP_3 -> MgmtInfo)
                free_CMIP_MgmtInfo (element_CMIP_3 -> MgmtInfo),
                    element_CMIP_3 -> MgmtInfo = NULL;

            if (element_CMIP_3)
                free ((char *) element_CMIP_3);
        }

        arg -> element_CMIP_3 = NULL;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_ActionArgument (arg)
struct type_CMIP_ActionArgument *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> accessControl)
        free_CMIP_AccessControl (arg -> accessControl),
            arg -> accessControl = NULL;
    if (arg -> filter)
        free_CMIP_CMISFilter (arg -> filter),
            arg -> filter = NULL;
    if (arg -> actionType)
        free_CMIP_ActionTypeId (arg -> actionType),
            arg -> actionType = NULL;
    if (arg -> actionInfo)
        free_CMIP_ActionInfo (arg -> actionInfo),
            arg -> actionInfo = NULL;

    if (arg)
	free ((char *) arg);
}

free_CMIP_ActionResult (arg)
struct type_CMIP_ActionResult *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> currentTime)
        free_UNIV_GeneralizedTime (arg -> currentTime),
            arg -> currentTime = NULL;
    if (arg -> actionResult)
        free_CMIP_MgmtInfo (arg -> actionResult),
            arg -> actionResult = NULL;

    if (arg)
	free ((char *) arg);
}

free_CMIP_GetListError (arg)
struct type_CMIP_GetListError *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> currentTime)
        free_UNIV_GeneralizedTime (arg -> currentTime),
            arg -> currentTime = NULL;
    {
        struct element_CMIP_4 *element_CMIP_4;

        for (element_CMIP_4 = arg -> element_CMIP_4;
                element_CMIP_4;
                element_CMIP_4 = element_CMIP_4 -> next) {
            if (element_CMIP_4 -> MISGetInfoStatus)
                free_CMIP_MISGetInfoStatus (element_CMIP_4 -> MISGetInfoStatus),
                    element_CMIP_4 -> MISGetInfoStatus = NULL;

            if (element_CMIP_4)
                free ((char *) element_CMIP_4);
        }

        arg -> element_CMIP_4 = NULL;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_MISGetInfoStatus (arg)
struct type_CMIP_MISGetInfoStatus *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_MISGetInfoStatus_mgmtInfoIdError:
            if (arg -> un.mgmtInfoIdError)
                free_CMIP_MgmtInfoIdError (arg -> un.mgmtInfoIdError),
                    arg -> un.mgmtInfoIdError = NULL;
            break;

        case type_CMIP_MISGetInfoStatus_mgmtInfo:
            if (arg -> un.mgmtInfo)
                free_CMIP_MgmtInfo (arg -> un.mgmtInfo),
                    arg -> un.mgmtInfo = NULL;
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_MgmtInfoIdError (arg)
struct type_CMIP_MgmtInfoIdError *arg;
{
    if (arg == NULL)
	return;

    if (arg -> errorStatus)
        free_CMIP_ErrorStatus (arg -> errorStatus),
            arg -> errorStatus = NULL;
    if (arg -> mgmtInfoId)
        free_CMIP_MgmtInfoId (arg -> mgmtInfoId),
            arg -> mgmtInfoId = NULL;

    if (arg)
	free ((char *) arg);
}

free_CMIP_SetListError (arg)
struct type_CMIP_SetListError *arg;
{
    if (arg == NULL)
	return;

    if (arg -> managedObjectClass)
        free_CMIP_ObjectClass (arg -> managedObjectClass),
            arg -> managedObjectClass = NULL;
    if (arg -> managedObjectInstance)
        free_CMIP_ObjectInstance (arg -> managedObjectInstance),
            arg -> managedObjectInstance = NULL;
    if (arg -> currentTime)
        free_UNIV_GeneralizedTime (arg -> currentTime),
            arg -> currentTime = NULL;
    {
        struct element_CMIP_5 *element_CMIP_5;

        for (element_CMIP_5 = arg -> element_CMIP_5;
                element_CMIP_5;
                element_CMIP_5 = element_CMIP_5 -> next) {
            if (element_CMIP_5 -> MISSetInfoStatus)
                free_CMIP_MISSetInfoStatus (element_CMIP_5 -> MISSetInfoStatus),
                    element_CMIP_5 -> MISSetInfoStatus = NULL;

            if (element_CMIP_5)
                free ((char *) element_CMIP_5);
        }

        arg -> element_CMIP_5 = NULL;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_MISSetInfoStatus (arg)
struct type_CMIP_MISSetInfoStatus *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_MISSetInfoStatus_mgmtInfoError:
            if (arg -> un.mgmtInfoError)
                free_CMIP_MgmtInfoError (arg -> un.mgmtInfoError),
                    arg -> un.mgmtInfoError = NULL;
            break;

        case type_CMIP_MISSetInfoStatus_mgmtInfo:
            if (arg -> un.mgmtInfo)
                free_CMIP_MgmtInfo (arg -> un.mgmtInfo),
                    arg -> un.mgmtInfo = NULL;
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_MgmtInfoError (arg)
struct type_CMIP_MgmtInfoError *arg;
{
    if (arg == NULL)
	return;

    if (arg -> errorStatus)
        free_CMIP_ErrorStatus (arg -> errorStatus),
            arg -> errorStatus = NULL;
    if (arg -> mgmtInfo)
        free_CMIP_MgmtInfo (arg -> mgmtInfo),
            arg -> mgmtInfo = NULL;

    if (arg)
	free ((char *) arg);
}

free_CMIP_ErrorStatus (arg)
struct type_CMIP_ErrorStatus *arg;
{
    if (arg == NULL)
	return;


    if (arg)
	free ((char *) arg);
}

free_CMIP_ProcessingFailure (arg)
struct type_CMIP_ProcessingFailure *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_ProcessingFailure_actual:
            if (arg -> un.actual)
                free_CMIP_SpecificErrorInfo (arg -> un.actual),
                    arg -> un.actual = NULL;
            break;

        case type_CMIP_ProcessingFailure_none:
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_ObjectClass (arg)
struct type_CMIP_ObjectClass *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_ObjectClass_globalForm:
            if (arg -> un.globalForm)
                oid_free (arg -> un.globalForm),
                    arg -> un.globalForm = NULLOID;
            break;

        case type_CMIP_ObjectClass_nonSpecificForm:
            if (arg -> un.nonSpecificForm)
                qb_free (arg -> un.nonSpecificForm),
                    arg -> un.nonSpecificForm = NULL;
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_ObjectInstance (arg)
struct type_CMIP_ObjectInstance *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_ObjectInstance_distinguishedName:
            if (arg -> un.distinguishedName)
                free_CMIP_DistinguishedName (arg -> un.distinguishedName),
                    arg -> un.distinguishedName = NULL;
            break;

        case type_CMIP_ObjectInstance_nonSpecificForm:
            if (arg -> un.nonSpecificForm)
                qb_free (arg -> un.nonSpecificForm),
                    arg -> un.nonSpecificForm = NULL;
            break;

        case type_CMIP_ObjectInstance_enumeratedForm:
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_CMISSync (arg)
struct type_CMIP_CMISSync *arg;
{
    if (arg == NULL)
	return;


    if (arg)
	free ((char *) arg);
}

free_CMIP_CMISFilter (arg)
struct type_CMIP_CMISFilter *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_CMISFilter_item:
            if (arg -> un.item)
                free_CMIP_FilterItem (arg -> un.item),
                    arg -> un.item = NULL;
            break;

        case type_CMIP_CMISFilter_and:
            {
                struct member_CMIP_0 *member_CMIP_0;

                for (member_CMIP_0 = arg -> un.member_CMIP_0;
                        member_CMIP_0;
                        member_CMIP_0 = member_CMIP_0 -> next) {
                    if (member_CMIP_0 -> CMISFilter)
                        free_CMIP_CMISFilter (member_CMIP_0 -> CMISFilter),
                            member_CMIP_0 -> CMISFilter = NULL;

                    if (member_CMIP_0)
                        free ((char *) member_CMIP_0);
                }

                arg -> un.member_CMIP_0 = NULL;
            }
            break;

        case type_CMIP_CMISFilter_or:
            {
                struct member_CMIP_1 *member_CMIP_1;

                for (member_CMIP_1 = arg -> un.member_CMIP_1;
                        member_CMIP_1;
                        member_CMIP_1 = member_CMIP_1 -> next) {
                    if (member_CMIP_1 -> CMISFilter)
                        free_CMIP_CMISFilter (member_CMIP_1 -> CMISFilter),
                            member_CMIP_1 -> CMISFilter = NULL;

                    if (member_CMIP_1)
                        free ((char *) member_CMIP_1);
                }

                arg -> un.member_CMIP_1 = NULL;
            }
            break;

        case type_CMIP_CMISFilter_not:
            if (arg -> un.not)
                free_CMIP_CMISFilter (arg -> un.not),
                    arg -> un.not = NULL;
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_FilterItem (arg)
struct type_CMIP_FilterItem *arg;
{
    if (arg == NULL)
	return;

    switch (arg -> offset) {
        case type_CMIP_FilterItem_equality:
            if (arg -> un.equality)
                free_CMIP_MgmtInfo (arg -> un.equality),
                    arg -> un.equality = NULL;
            break;

        case type_CMIP_FilterItem_greaterOrEqual:
            if (arg -> un.greaterOrEqual)
                free_CMIP_MgmtInfo (arg -> un.greaterOrEqual),
                    arg -> un.greaterOrEqual = NULL;
            break;

        case type_CMIP_FilterItem_lessOrEqual:
            if (arg -> un.lessOrEqual)
                free_CMIP_MgmtInfo (arg -> un.lessOrEqual),
                    arg -> un.lessOrEqual = NULL;
            break;

        case type_CMIP_FilterItem_present:
            if (arg -> un.present)
                free_CMIP_MgmtInfoID (arg -> un.present),
                    arg -> un.present = NULL;
            break;
    }

    if (arg)
	free ((char *) arg);
}

free_CMIP_MgmtInfo (arg)
struct type_CMIP_MgmtInfo *arg;
{
    if (arg == NULL)
	return;

    if (arg -> element_CMIP_6)
        free_CMIP_MgmtInfoId (arg -> element_CMIP_6),
            arg -> element_CMIP_6 = NULL;
    if (arg -> element_CMIP_7)
        free_CMIP_MgmtInfoValue (arg -> element_CMIP_7),
            arg -> element_CMIP_7 = NULL;

    if (arg)
	free ((char *) arg);
}

%}
