\File{ryresp\-invoke.c},{21:34},{Aug 31 1988}
\L{\LB{...}}
\L{\LB{}}
\L{\LB{\K{static} \K{int}  op\_name (sd, ryo, rox, in, roi)}}
\L{\LB{\K{int}}\Tab{8}{sd;}}
\L{\LB{\K{struct} RyOperation *ryo;}}
\L{\LB{\K{struct} RoSAPinvoke *rox;}}
\L{\LB{caddr\_t}\Tab{8}{in;}}
\L{\LB{\K{struct} RoSAPindication *roi;}}
\L{\LB{\{}}
\L{\LB{    \K{int}}\Tab{8}{    result,}}
\L{\LB{}\Tab{8}{    won;}}
\L{\LB{    \K{register} \K{struct} type\_MODULE\_argument *arg =}}
\L{\LB{}\Tab{16}{(\K{struct} type\_MODULE\_argument *) in;}}
\L{\LB{}}
\L{\LB{\C{}\/* this check should *not* be made if linking of operations is expected *\/\CE{}}}
\L{\LB{    \K{if} (rox \-\> rox\_nolinked == 0) \{}}
\L{\LB{}\Tab{8}{advise (LLOG\_EXCEPTIONS, NULLCP,}}
\L{\LB{}\Tab{16}{\S{}\"RO\-INVOKE.INDICATION\/\%d: \%s, unknown linkage \%d\"\SE{},}}
\L{\LB{}\Tab{16}{sd, ryo \-\> ryo\_name, rox \-\> rox\_linkid);}}
\L{\LB{}\Tab{8}{\K{return} ureject (sd, ROS\_IP\_LINKED, rox, roi);}}
\L{\LB{    \}}}
\L{\LB{    \K{if} (debug)}}
\L{\LB{}\Tab{8}{advise (LLOG\_DEBUG, NULLCP, \S{}\"RO\-INVOKE.INDICATION\/\%d: \%s\"\SE{},}}
\L{\LB{}\Tab{16}{sd, ryo \-\> ryo\_name);}}
\L{\LB{}}
\L{\LB{\C{}\/* do something with ``arg\'\' here and decide if won... *\/\CE{}}}
\L{\LB{}}
\L{\LB{    \K{if} (won) \{}}
\L{\LB{}\Tab{8}{\K{register} \K{struct} type\_MODULE\_result *res;}}
\L{\LB{}}
\L{\LB{\C{}\/* allocate and initialize the result ``res\'\' here... *\/\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{8}{\K{if} (RyDsResult (sd, rox \-\> rox\_id, (caddr\_t) res, ROS\_NOPRIO, roi)}}
\L{\LB{}\Tab{16}{== NOTOK)}}
\L{\LB{}\Tab{8}{    ros\_adios (\&roi \-\> roi\_preject, \S{}\"RESULT\"\SE{});}}
\L{\LB{}\Tab{8}{result = OK;}}
\L{\LB{}}
\L{\LB{}\Tab{8}{free\_MODULE\_result (res);}}
\L{\LB{    \}}}
\L{\LB{    \K{else} \{}}
\L{\LB{}\Tab{8}{\K{struct} type\_MODULE\_parameter *parm;}}
\L{\LB{}}
\L{\LB{\C{}\/* allocate and initialize ``parm\'\' here... *\/\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{8}{result = error (sd, error\_MODULE\_error1, (caddr\_t) parm, rox, roi);}}
\L{\LB{}}
\L{\LB{}\Tab{8}{free\_MODULE\_parameter (parm);}}
\L{\LB{    \}}}
\L{\LB{}}
\L{\LB{\C{}\/* ``arg\'\' will be automatically free\'d when op\_name returns *\/\CE{}}}
\L{\LB{}}
\L{\LB{    \K{return} result;}}
\L{\LB{\}}}
\L{\LB{}}
\L{\LB{...}}
\L{\LB{}}
\L{\LB{\K{static} \K{int}  error (sd, err, param, rox, roi)}}
\L{\LB{\K{int}}\Tab{8}{sd,}}
\L{\LB{}\Tab{8}{err;}}
\L{\LB{caddr\_t}\Tab{8}{param;}}
\L{\LB{\K{struct} RoSAPinvoke *rox;}}
\L{\LB{\K{struct} RoSAPindication *roi;}}
\L{\LB{\{}}
\L{\LB{    \K{if} (RyDsError (sd, rox \-\> rox\_id, err, param, ROS\_NOPRIO, roi) == NOTOK)}}
\L{\LB{}\Tab{8}{ros\_adios (\&roi \-\> roi\_preject, \S{}\"ERROR\"\SE{});}}
\L{\LB{}}
\L{\LB{    \K{return} OK;}}
\L{\LB{\}}}
\L{\LB{}}
\L{\LB{}}
\L{\LB{\K{static} \K{int}  ureject (sd, reason, rox, roi)}}
\L{\LB{\K{int}}\Tab{8}{sd,}}
\L{\LB{}\Tab{8}{reason;}}
\L{\LB{\K{struct} RoSAPinvoke *rox;}}
\L{\LB{\K{struct} RoSAPindication *roi;}}
\L{\LB{\{}}
\L{\LB{    \K{if} (RyDsUReject (sd, rox \-\> rox\_id, reason, ROS\_NOPRIO, roi) == NOTOK)}}
\L{\LB{}\Tab{8}{ros\_adios (\&roi \-\> roi\_preject, \S{}\"U\-REJECT\"\SE{});}}
\L{\LB{}}
\L{\LB{    \K{return} OK;}}
\L{\LB{\}}}
\L{\LB{}}
\L{\LB{...}}
