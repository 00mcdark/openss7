@c -*- texinfo -*- vim: ft=texinfo tw=100 nocin nosi
@c =========================================================================
@c
@c @(#) $Id: todo.texi,v 0.9.2.1 2006/08/26 14:37:59 brian Exp $
@c
@c =========================================================================
@c
@c Copyright (c) 2001-2006  OpenSS7 Corporation <http://www.openss7.com/>
@c
@c All Rights Reserved.
@c
@c Permission is granted to make and distribute verbatim copies of this
@c manual provided the copyright notice and this permission notice are
@c preserved on all copies.
@c
@c Permission is granted to copy and distribute modified versions of this
@c manual under the conditions for verbatim copying, provided that the
@c entire resulting derived work is distributed under the terms of a
@c permission notice identical to this one.
@c 
@c Since the Linux kernel and libraries are constantly changing, this
@c manual page may be incorrect or out-of-date.  The author(s) assume no
@c responsibility for errors or omissions, or for damages resulting from
@c the use of the information contained herein.  The author(s) may not
@c have taken the same level of care in the production of this manual,
@c which is licensed free of charge, as they might when working
@c professionally.
@c 
@c Formatted or processed versions of this manual, if unaccompanied by
@c the source, must acknowledge the copyright and authors of this work.
@c
@c -------------------------------------------------------------------------
@c
@c U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
@c on behalf of the U.S. Government ("Government"), the following
@c provisions apply to you.  If the Software is supplied by the Department
@c of Defense ("DoD"), it is classified as "Commercial Computer Software"
@c under paragraph 252.227-7014 of the DoD Supplement to the Federal
@c Acquisition Regulations ("DFARS") (or any successor regulations) and the
@c Government is acquiring only the license rights granted herein (the
@c license rights customarily provided to non-Government users).  If the
@c Software is supplied to any unit or agency of the Government other than
@c DoD, it is classified as "Restricted Computer Software" and the
@c Government's rights in the Software are defined in paragraph 52.227-19
@c of the Federal Acquisition Regulations ("FAR") (or any successor
@c regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
@c NASA Supplement to the FAR (or any successor regulations).
@c
@c =========================================================================
@c 
@c Commercial licensing and support of this software is available from
@c OpenSS7 Corporation at a fee.  See http://www.openss7.com/
@c 
@c =========================================================================
@c
@c Last Modified $Date: 2006/08/26 14:37:59 $ by $Author: brian $
@c
@c =========================================================================

Things to do:

@itemize @minus
@item
Add a tail padding amount to the stream head as a option to facilitate conversion of mblks to
sk_bufs.

@table @emph
@item DONE:
Implemented as SO_WRPAD.
@end table

@item
Socket buffer handling:

@enumerate 1
@item
Rather than write offset and padding, why not provide a flag (e.g.  SO_SKBUFF) to indicate to the
stream head to allocate an sk_buff with the message block and share buffers between mblk and
sk_buff, then, the sk_buff can be used without allocation in the bottom half.  esballoc() and
alloc_skbuff() can be used to set up the message block.  dup() could be made aware of the hidden
sk_buff and increment the shared sk_buff count as well.  Also, msgpullup() and pullupmsg() could be
made aware of message blocks containing sk_buffs and have them do the appropriate thing.

@item
The other thing that is needed is some way to tell the other end of a loopback connection that the
sk_buff it has received already has an mblk attached to it as above.  Then the message block could
be simply passed upstream and one would not need to be esballoc'ed for it.

@item
Another thing is to provide the ability to partial checksum and copy data from user into these
sk_buffs, but setting an SO_CSUM flag along with the SO_SKBUFF flag to indicate the type of checksum
to perform.
@end enumerate

The combination of the above three items should provide some serious performance gains for Linux
networking based stream heads.

@table @emph
@item TODO:
Implement these three items.
@end table

@item
Had another look at specfs, devfs and udev.  It looks like we can create minor device nodes within
/dev (not just /dev/streams) using devfs or udev.  Again, this doesn't do everything that specfs
does.  specfs will demand load when an attempt is made to open a non-existent character device.
Nevertheless, we can describe a "streams" class for udev and when a module registers a minor device
node, we can have udev create that device node and provide permissions by adding our files to the
/etc/udev/rules.d and /etc/udev/permissions.d directories.

Therefore, on a udev system, we should make strconf-sh create the necessary rules.d and
permissions.d file entries.  register_strnod will be modified to create a udev instance within the
stream class matching the rules.d and permissions.d entry when creating a minor device node within
the specfs.

On a devfs system, register_strdev and register_strnod should perform devfs calls instead of calling
register_chrdev.  That way minor device nodes will automagically appear at least once the module is
loaded.

@table @emph
@item TODO:
rationalize specfs to devfs and udev
@end table

@item
Have the STREAMS subsystem register a panic notifier on 2.6 kernels to be able to recover from
panics caused by misbehaving STREAMS modules or drivers.

@table @emph
@item TODO:
Register panic notifier.
@end table

@item
Per cpu data:- I am still using the older approach of using cacheline aligned arrays for per-cpu
data.  This, of course, does not fully utilize NUMA architectures.  For NUMA architectures we need
to use the per-cpu utilities provided by the 2.6 kernel.  I haven't touched converting this yet.

Also, there are several NUMA supporting STREAMS utility functions (allocb_node, etc.) that need to
be supported yet.

@table @emph
@item TODO:
Convert cacheline aligned arrays to NUMA per-cpu data on 2.6 kernels.  Complete NUMA supporting
STREAMS facilities.
@end table

@item
Timers and Buffer callbacks:- Still haven't tested these.

@table @emph
@item TODO:
Test.
@end table

@item
More performance testing and profiling on SMP.  On the same kernel running non-SMP we get pipe
performance of about 80-90% of a Linux native pipe.  Just running an SMP kernel drops this to 60%
comparative.  Running both CPUs in an SMP kernel does not improve matters.  Need to profile this up
80-90% on SMP too.  Also, so many changes were made for 64bit and 32bit compatibility that the old
profiling information is out of date and needs to be updated.

@table @emph
@item DONE:
Profile and performance tests on SMP.
@end table

@item
I am interested to convert the perftest program to use a FIFO instead of a pipe.  This is because a
FIFO is more closely related to a Linux Native pipe (i.e it has a read side and a write side, is
really only one file pointer, and only supports unidirectional flow).  Comparative tests as opposed
to STREAMS-based pipes should be interesting.

@table @emph
@item DONE:
Tested.  Results were unimpressive.  STREAMS FIFOs perform about 1% better than STREAMS-based pipes.
@end table

@item
32bit compatibility:- Not done yet, but a plan in place.  Override stupid CDROM ioctl conversions on
kernels before 2.6.11, use compat_ioctl after that.  For the older read/write interface it will be
necessary to have two "magic" lengths: one the same as the old one for 32-bit and a new 64-bit
"magic" length.  This is so that the internal function can convert.  Perhaps it can really be the
same number in the lower 32-bits.  Note that on later kernels there is a CONFIG_COMPAT define that
we might want to check in the configure script.

@table @emph
@item DONE:
Tested on x86_64 with i686.
@item DONE:
Documentation of new registration functions.
@end table

@item
SMP:- Finally got at least a Hyper-Threaded Intel 630 for testing.  There are some issues discovered
when running the test suites.  Initial debugging is done (everything runs and doesn't crash) it is
just that some multiple writers and readers are getting stuck in wait queues.  What we need to do is
to split the wait queues into open, close, read, write and ioctl from the big wait queue that it is,
and largely get rid of the RSLEEP, WSLEEP, IOCWAIT type bits (we could still set them for
compatibilty with SVR4 but not examine them).

@table @emph
@item DONE:
Tested on X86_64 SMP.
@end table

@item
64bit clean:- Pretty good now.  I have clean compiles and test suite runs on 2.6.9-22.EL x86_64
kernels.

@table @emph
@item DONE:
Tested on x86_64.
@end table

@item
LiS Binary Compatibiility:-  Pretty much messed up right now.  I have the regparm(0) stuff on the
callout and callback functions, and the STREAMS Compatibility Modules does regparm(0) on all the
lis_ functions.  Primary STREAMS data structures align on the first portion of the data structure.
Sizes vary, so don't do q+1.  Flags are a little different.  There are however several problematic
data structures: cred_t and the ioctypes: iocblk, copyreq, copyresp, and the linkblk.  When you
enable binary compatibility mode, it uses the LiS versions of these.

@table @emph
@item DONE:
Needs testing.
@end table

@item
LfS Binary Compatibility:-  A little better.  Callouts and callbacks always regparm(0).  STREAMS
utility functions are always regparm(3).  Data structures are stable for the most part.  cred_t,
however, is variable depending on the kernel.  Compile with the LiS binary compatibility and the
cred_t will be fixed size.

@table @emph
@item DONE:
Needs testing.
@end table

@item
Finish the documentation.

@table @emph
@item MOSTLY DONE:
updated documentation alot.
@end table

@item
Finish the full STREAMS logger and proper implementation of the strlog() utility.

@table @emph
@item DONE:
Added to strutil package.  Needs testing.
@end table

@item
Need to rework the specfs.  There are now several situations to consider:

The following four situations require the specfs.

@enumerate a
@item 2.4 kernel without devfs
@item 2.6 kernel without devfs
@item 2.4 kernel with devfs but without devfsd
@item 2.6 kernel with devfs but without devfsd
@end enumerate

The following two situations could use devfs instead of specfs.

@enumerate e
@item 2.4 kernel with devfs and with devfsd
@item 2.6 kernel with devfs and with devfsd
@end enumerate

The following one situation could use udev instead of devfs or specfs.

@enumerate g
@item 2.6 kernel with udev
@end enumerate

To get this to work requires that there be an independent layer between the filesystem providing
device access for STREAMS and the STREAMS subsystem.  A set of registration functions need to be
provided and a common set of callouts from the filesystem made to the STREAMS executive.

The registration functions need to be called when a STREAMS driver loads and the filesystem needs to
do the right thing.  This also needs to include the registration of major and minor devices,
including clone devices.

The callout functions from the filesystem need to invoke the STREAMS device file operations in a
predictable manner, and the STREAMS subsystem requires the ability to chain open calls, or even open
STREAMS devices from within the kernel (e.g. for pipes and connld and such).

It is difficult to get the filesystem (specfs, devfs, udev) to hold data structures in a manner that
is also usable by the STREAMS subsystem, so the filesystem adaptation layer needs to maintain data
structures in the same manner for all filesystems.

Well,...  After a little investigation, it is all messed up.  udev doesn't do what we need when
demand loading pseudo devices, and devfs is probably not used anymore (I found most production
kernels disabled for devfs) so it looks like spefs is the way to go.  I might use udev for "real"
device drivers, but that's just for SS7.  So it looks like we are stuck with mounting the specfs.  I
notice that ptys still use their own filesystem too...

So, what we need now is to rework data structures and the specfs to be a little more stable.

@table @emph
@item DONE:
Tested.
@end table

@item
Kernel objects are another thing.  For 2.6 kernels, we need to hold our data structures in the
kobject manner so that the /sys filesystem is usable.  This requires another adaptation layer
because 2.4 kernels do this in a completely different way.  Much of our /proc filesystem stuff needs
to move into /sys for 2.6 kernels by stay the same for 2.4 kernels.

The /sys filesystem does not really do much for STREAMS.  The /dev/streams specfs filesystem does
more for us.

@table @emph
@item SKIPPED.
@end table
@end itemize
