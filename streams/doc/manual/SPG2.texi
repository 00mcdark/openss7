% -*- texinfo -*- vim: ft=texinfo noautoindent nocindent nosmartindent
% =========================================================================
%
% @(#) $Id: SPG2.texi,v 0.9.2.4 2005/11/17 01:59:26 brian Exp $
%
% =========================================================================
%
% Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
% Copyright (C) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2005/11/17 01:59:26 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename SPG2.info
@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide
@settitle @value{MANUAL_TITLE}

@dircategory STREAMS
@direntry
* SPG2: (SPG2).			STREAMS Programmer's Guide (Take 2)
@end direntry

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}.

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this guide
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed guide).

@end ignore
Permission is granted to copy and distribute modified versions of this guide
under the conditions for verbatim copying, provided the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this guide into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@ignore
@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@end ignore
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2005  OpenSS7 Corporation <@uref{http://www.openss7.com/}> @*
Copyright @copyright{} 1997-2000  Brian F. G. Bidulock <@email{bidulock@@openss7.org}> @*
All Rights Reserved. @*

@noindent
Published by OpenSS7 Corporation @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
This is texinfo edition @value{PACKAGE_RELEASE} of the @value{MANUAL_TITLE}
documentation, and is consistent with @value{PACKAGE_NAME} @value{PACKAGE_VERSION}.
This guide was developed under the @uref{http://www.openss7.org/, OpenSS7
Project} and was funded in part by
@uref{http://www.openss7.com/, OpenSS7 Corporation}.

@noindent
Permission is granted to make and distribute verbatim copies of this guide
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission is granted to copy and distribute modified versions of this guide
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

@noindent
Permission is granted to copy and distribute translations of this guide into
another language, under the same conditions as for modified versions.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Ed. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Ed.  @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Manpage index
@defcodeindex mp

@c Concatenate indices
@syncodeindex fn cp
@syncodeindex vr cp
@synindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp
@synindex mp cp

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@unnumbered About This Guide
This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of @cite{The
@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
release @value{PACKAGE_RELEASE} of the @value{PACKAGE_TITLE} package.
@end ifnottex

@iftex

@macro tabfig {image, number, caption}
@cartouche
@float Table,Table \number\
@image{\image\}
@caption{@emph{\caption\}}
@end float
@end cartouche
@end macro

@macro tabfigsized {image, number, caption, size}
@cartouche
@float Table,Table \number\
@image{\image\,\size\}
@caption{@emph{\caption\}}
@end float
@end cartouche
@end macro

@macro figure {image, number, caption}
@cartouche
@float Figure,Figure \number\
@image{\image\}
@caption{@emph{\caption\}}
@end float
@end cartouche
@end macro

@macro figuresized {image, number, caption, size}
@cartouche
@float Figure,Figure \number\
@image{\image\,\size\}
@caption{@emph{\caption\}}
@end float
@end cartouche
@end macro

@macro manref {name}
@mpindex \name\
@command{\name\}
@end macro

@macro mantype {name}
@tindex \name\
@code{\name\}
@end macro

@macro ioctlref {name}
@findex \name\
@code{\name\}
@end macro

@end iftex

@ifnottex

@macro tabfig {image, number, caption}
@image{\image\} @anchor{Table \number\} @center @emph{Table \number\.@:  \caption\}
@end macro

@macro tabfigsized {image, number, caption, size}
@image{\image\,\size\} @anchor{Table \number\} @center @emph{Table \number\.@:  \caption\}
@end macro

@macro figure {image, number, caption}
@image{\image\} @anchor{Figure \number\} @center @emph{Figure \number\.@:  \caption\}
@set fignum \number\
@end macro

@macro figuresized {image, number, caption, size}
@image{\image\,\size\} @anchor{Figure \number\} @center @emph{Figure \number\.@:  \caption\}
@set fignum \number\
@end macro

@macro manref {name}
@mpindex \name\
@command{\name\} (@inforef{\name\, , *manpages*})
@end macro

@macro mantype {name}
@tindex \name\
@code{\name\} (@inforef{\name\, , *manpages*})
@end macro

@macro ioctlref {name}
@code{\name\} (@inforef{\name\(2), , *manpages*}; @inforef{streamio(7), , *manpages*})
@end macro

@end ifnottex

@macro tabref {number}
@ref{Table \number\}
@end macro

@macro figref {number}
@ref{Figure \number\}
@end macro

@macro manpage {name}
@mpindex \name\
@command{\name\}
@end macro

@macro type {name}
@tindex \name\
@code{\name\}
@end macro

@macro member {name}
@vindex \name\
@var{\name\}
@end macro

@macro constant {name}
@vindex \name\
@code{\name\}
@end macro

@macro signal {name}
@vindex \name\
@{@b{@code{\name\}}@}
@end macro

@macro errno {name}
@vindex \name\
(@b{@code{\name\}})
@end macro

@macro stropt {name}
@vindex \name\
@code{\name\}
@end macro

@macro streamio {name}
@findex \name\
@code{\name\}
@end macro

@macro termio {name}
@findex \name\
@code{\name\}
@end macro

@macro sockio {name}
@findex \name\
@code{\name\}
@end macro

@macro msg {name}
@vindex \name\
@code{\name\}
@end macro

@macro header {name}
@pindex \name\
@file{\name\}
@end macro

@menu
* Acknowledgements::
* Preface::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* Messages::
* Polling::
* Modules and Drivers::
* Modules::
* Drivers::
* Multiplexing::
* Pipes and FIFOs::
* Terminal Subsystem::
* Synchronization::
* Reference::
* Conformance::
* Portability::
* Data Structures::
* Message Types::
* Utilities::
* Debugging::
* Configuration::
* Administration::
* Examples::
* Copying::
* Glossary::
* Index::

 --- The Detailed Node Listing ---

Acknowledgements

* Sponsors::			Sponsors
* Contributors::		Contributors

Preface
Introduction

* Background::			STREAMS Background
* What is STREAMS?::		STREAMS Description
* Basic Streams Operations::	STREAMS Basic Operations
* Components::			STREAMS Components
* Multiplexing of Streams::	STREAMS Multiplexing
* Benefits of STREAMS::		STREAMS Benefits

Overview

* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems

Mechanism

* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction

Processing

* Procedures::			STREAMS Put and Service Procedures
* Asynchronous Example::	STREAMS Asynchronous Stream Example

Messages

* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers

Polling

* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal

Modules and Drivers

* Environment::			STREAMS Module and Driver Environment
* Input-Output Control::	STREAMS Input and Output Control
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines

Modules

* Module::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines

Drivers

* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* spec File System::		Avoiding Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering

* Driver::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines

Multiplexing

* Multiplexors::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexor Connect and Disconnect Lower Stream
* Multiplexor Construction Example::
				STREAMS Multiplexor Construction Example
* Multiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexor Persistent Links
* Multiplexing Driver Design Guidelines::
				STREAMS Multiplexing Driver Design Guidelines

Pipes and FIFOs

* Pipes and FIFOs::		STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs

Terminal Subsystem

* Terminal Subsystem::		STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem

Synchronization

* MT Configuration::		MP STREAMS MT Configuration
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks

* STREAMS Framework Integrity::
* MP Message Ordering::
* MP-UNSAFE Modules::
* MP Put and Service Procedures::
* MP Timeout and Buffer Callbacks::
* MP Open and Close Procedures::
* MP Module Unloading::
* MP Locking::
* MP Asynchronous Callbacks::
* Stream Integrity::

Reference

* Files::			STREAMS Files
* Modules::			STREAMS Modules
* Drivers::			STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions

Conformance

* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX Compatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
* LiS Compatibility::		LiS 2.18.1 Compatibility

Portability

* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* LiS Portability::		Porting from LiS 2.18.1

Data Structures

* Stream Structures::
* Queue Structures::
* Message Structures::
* Input Output Control Structures::
* Link Structures::
* Options Structures::

Message Types

* Message Type::
* Ordinary Messages::
* High Priority Messages::

Utilities

Debugging

Configuration

Administration

* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System

Examples

* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example

Copying

* GNU General Public License::		GPL
* GNU Free Documentation License::	FDL

Glossary

Index

@end menu

@c --------------------------------------------------------------------------
@c --------------------------------------------------------------------------

@node Acknowledgements
@unnumbered Acknowledgements
@cindex credits

@include texi/funding.texi

@node Preface
@unnumbered Preface

@section Document Information
@cindex document information

@subsection Notice
@cindex document notice
@cindex licensing

This package is released and distributed under the @cite{GNU General Public License} (@pxref{GNU
General Public License}).  Please note, however, that there are different licensing terms for the
manual pages and some of the documentation (derived from OpenGroup@footnote{Formerly X/Open and UNIX
International.} publications and other sources).  Consult the permission notices contained in the
documentation for more information.

This document, is released under the @cite{GNU Free Documentation License} (@pxref{GNU Free
Documentation License}) with all sections invariant.

@subsection Abstract
@cindex document abstract

This document provides a @cite{@value{MANUAL_TYPE}} for @cite{@value{PACKAGE_TITLE}}.

@subsection Objective
@cindex document objective

The objective of this document is to provide a guide for the @dfn{STREAMS} programmer when
developing @dfn{STREAMS} modules, drivers and application programs for @cite{@value{PACKAGE_TITLE}}.

This guide provides information to developers on the use of the @dfn{STREAMS} mechanism at user and
kernel levels.

@dfn{STREAMS} was incorporated in UNIX System V Release 3 to augment the character input/output
(I/O) mechanism and to support development of communication services.

@dfn{STREAMS} provides developers with integral functions, a set of utility routines, and facilities
that expedite software design and implementation.

@subsection Intent
@cindex document intent

The intent of this document is to act as an introductory guide to the @dfn{STREAMS} programmer.  It
is intended to be read alone and is not intended to replace or supplement the
@cite{@value{PACKAGE_TITLE}} manual pages.  For a reference for writing code, the manual pages
(see @manref{STREAMS(9)}) provide a better reference to the programmer.
Although this describes the features of the @cite{@value{PACKAGE_TITLE}} package,
@uref{http://www.openss7.com/,OpenSS7 Corporation} is under no obligation to provide any software,
system or feature listed herein.

@subsection Audience
@cindex document audience

This document is intended for a highly technical audience.  The reader should already be familiar
with @cite{Linux} kernel programming, the @cite{Linux} file system, character devices, driver input
and output, interrupts, software interrupt handling, scheduling, process contexts, multiprocessor
locks, etc.

The guide is intended for network and systems programmers, who use the @dfn{STREAMS} mechanism at
user and kernel levels for @cite{Linux} and @cite{UNIX} system communication services.

Readers of the guide are expected to possess prior knowledge of the @cite{Linux} and @cite{UNIX}
system, programming, networking, and data communication.

@subsection Revisions
@cindex document revisions

Take care that you are working with a current version of this document: you will not be notified of
updates.  To ensure that you are working with a current version, contact the
@uref{mailto:bidulock@@openss7.org,Author}, or check @uref{http://www.openss7.org/,The OpenSS7
Project} website for a current version.

A current version of this document is normally distributed with the @cite{@value{PACKAGE_TITLE}}
package.

@subsubsection Version Control

@smallexample

$Log: SPG2.texi,v $
Revision 0.9.2.4  2005/11/17 01:59:26  brian
- more workup of take 2

Revision 0.9.2.3  2005/11/16 10:30:39  brian
- still working up take 2

Revision 0.9.2.2  2005/11/16 03:20:03  brian
- working up take 2

Revision 0.9.2.1  2005/11/15 12:05:09  brian
- second run at SPG

Revision 0.9.2.45  2005/11/14 23:27:06  brian
- more workup

Revision 0.9.2.44  2005/11/14 11:19:49  brian
- working up manual

Revision 0.9.2.43  2005/11/14 04:43:55  brian
- updating manual

Revision 0.9.2.42  2005/11/13 23:04:01  brian
- starting cleanup of SPG

Revision 0.9.2.41  2005/10/07 09:34:00  brian
- more testing and corrections

Revision 0.9.2.40  2005/09/26 10:56:41  brian
- doc updates

Revision 0.9.2.39  2005/09/20 12:53:07  brian
- more doc updates, corrected QFULL handling

Revision 0.9.2.38  2005/09/18 07:38:35  brian
- more doc updates

Revision 0.9.2.37  2005/09/17 11:52:08  brian
- documentation updates

Revision 0.9.2.36  2005/09/17 08:20:57  brian
- more doc updates

Revision 0.9.2.35  2005/09/17 00:46:12  brian
- document updates

Revision 0.9.2.34  2005/09/16 03:06:02  brian
- added glossary

Revision 0.9.2.33  2005/09/15 13:02:52  brian
- added new graphics and updates

@end smallexample

@subsubsection ISO 9000 Compliance

Only the @TeX{}, texinfo, or roff source for this document is controlled.  An opaque (printed,
postscript or portable document format) version of this document is an @strong{UNCONTROLLED
VERSION}.

@subsection Disclaimer
@cindex document disclaimer

@noindent
@cite{OpenSS7 Corporation} disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights.  In
no event shall @cite{OpenSS7 Corporation} be liable for any direct, indirect, special or
consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising out of or in connection with
any use of this document or the performance or implementation of the contents thereof.

@noindent
@cite{OpenSS7 Corporation} reserves the right to revise this software and documentation for any
reason, including but not limited to, conformity with standards promulgated by various agencies,
utilization of advances in the state of the technical arts, or the reflection of changes in the
design of any techniques, or procedures embodied, described, or referred to herein.  @cite{OpenSS7
Corporation} is under no obligation to provide any feature listed herein.

@subsubsection U.S. Government Restricted Rights

If you are licensing this Software on behalf of the U.S. Government ("Government"), the following
provisions apply to you.  If the Software is supplied by the Department of Defense ("DoD"), it is
classified as "Commercial Computer Software" under paragraph 252.227-7014 of the DoD Supplement to
the Federal Acquisition Regulations ("DFARS") (or any successor regulations) and the Government is
acquiring only the license rights granted herein (the license rights customarily provided to
non-Government users).  If the Software is supplied to any unit or agency of the Government other
than DoD, it is classified as "Restricted Computer Software" and the Government's rights in the
Software are defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR") (or any
successor regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to
the FAR (or any successor regulations).

@section Organization
@cindex organization

This guide has several chapters, each discussing a unique topic.  @ref{Introduction},
@ref{Overview}, @ref{Mechanism} and @ref{Processing} contain introductory information and can be
ignored by those already familiar with @dfn{STREAMS} concepts and facilities.

This document is organized as follows:

@ifnottex
@menu
  Acknowledgements::
  Preface::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* Messages::
* Polling::
* Modules and Drivers::
* Modules::
* Drivers::
* Multiplexing::
* Pipes and FIFOs::
* Terminal Subsystem::
* Synchronization::
* Reference::
* Conformance::
* Portability::
* Data Structures::
* Message Types::
* Utilities::
* Debugging::
* Configuration::
* Administration::
* Examples::
* Copying::
* Glossary::
* Index::
@end menu
@end ifnottex
@iftex
@table @emph
@item @ref{Preface}
Describes the organization and purpose of the guide.  It also defines an intended audience and an
expected background of the users of the guide.
@item @ref{Introduction}
An introduction to @dfn{STREAMS} and the @cite{@value{PACKAGE_TITLE}} package.
@dfn{STREAMS} Fundamentals.  Presents an overview and the benefits of @dfn{STREAMS}.
@item @ref{Overview}
A brief overview of @dfn{STREAMS}.
@item @ref{Mechanism}
A description of the @dfn{STREAMS} framework.  Describes the basic operations for constructing,
using, and dismantling Streams.  These operations are performed using @manpage{open(2)},
@manpage{close(2)}, @manpage{read(2)}, @manpage{write(2)}, and @manpage{ioctl(2)}.
@item @ref{Processing}
Processing and procedures within the @dfn{STREAMS} framework.  Gives an overview of the
@dfn{STREAMS} put and service routines.
@item @ref{Messages}
@dfn{STREAMS} Messages, organization, types, priority, queueing, and general handling.  Discusses
@dfn{STREAMS} messages, their structure, linkage, queueing, and interfacing with other @dfn{STREAMS}
components.
@item @ref{Polling}
Polling of @dfn{STREAMS} file descriptors and other asynchronous application techniques.  Describes
how @dfn{STREAMS} allows user processes to monitor, control, and poll Streams to allow an effective
utilization of system resources.
@item @ref{Modules and Drivers}
An overview of @dfn{STREAMS} modules, drivers and multiplexing drivers.  Describes the @dfn{STREAMS}
module and driver environment, input-output controls, routines, declarations, flush handling, driver-kernel
interface, and also provides general design guidelines for modules and drivers.
@item @ref{Modules}
Details of @dfn{STREAMS} modules, including examples.  Provides information on module construction
and function.
@item @ref{Drivers}
Details of @dfn{STREAMS} drivers, including examples.  Discusses @dfn{STREAMS} drivers, elements of
driver flow control, flush handling, cloning, and processing.
@item @ref{Multiplexing}
Details of @dfn{STREAMS} multiplexing drivers, including examples.  Describes the @dfn{STREAMS}
multiplexing facility.
@item @ref{Pipes and FIFOs}
Details of @dfn{STREAMS}-based Pipes and FIFOs.  Provides information on creating, writing, reading,
and closing of @dfn{STREAMS}-based pipes and FIFOs and unique connections.
@item @ref{Terminal Subsystem}
Details of @dfn{STREAMS}-based Terminals and Pseudo-terminals.  Discusses @dfn{STREAMS}-based
terminal and and pseudo-terminal subsystems.
@item @ref{Synchronization}
Discusses @dfn{STREAMS} in a symmetrical multi-processor environment.
@item @ref{Reference}
Reference section.
@item @ref{Conformance}
Conformance of the @cite{@value{PACKAGE_TITLE}} package to other @cite{UNIX} implementations of
@dfn{STREAMS}.
@item @ref{Portability}
Portability of @dfn{STREAMS} modules and drivers written for other @cite{UNIX} implementations of
@dfn{STREAMS} and how they can most easily be ported into @cite{@value{PACKAGE_TITLE}}; but, for
more details on this topic, see the @cite{@value{PACKAGE_TITLE} - @dfn{STREAMS} Portability Guide}.
@item @ref{Data Structures}
Primary @dfn{STREAMS} Data Sturctures, descriptions of their members, flags, constants and use.
Summarizes data structures commonly used by @dfn{STREAMS} modules and drivers.
@item @ref{Message Types}
@dfn{STREAMS} Message Type reference, with descriptions of each message type.  Describes
@dfn{STREAMS} messages and their use.
@item @ref{Utilities}
@dfn{STREAMS} kernel-level utility functions for the module or driver writer.  Describes
@dfn{STREAMS} utility routines and their usage.
@item @ref{Debugging}
@dfn{STREAMS} debugging facilities and their use.
Provides debugging aids for developers.
@item @ref{Configuration}
@dfn{STREAMS} configuration, the @dfn{STREAMS Administrative Driver} and the autopush facility.
Describes how modules and drivers are configured into the @dfn{Linux} and @dfn{UNIX} system, tunable
parameters, and the autopush facility.
@item @ref{Administration}
Administration of the @dfn{STREAMS} subsystem.
@item @ref{Examples}
Collected examples.
@c @item @ref{Device Numbers}
@c Specifics on device numbering and the @dfn{Shadow Special Filesystem}.
@c @item @ref{Multi-Threading}
@c Syncrhonization for Symmetrical Multiprocessor (SMP) architectures.
@end table
@end iftex


@subsubsection Conventions Used

This guide uses @cite{texinfo} typographical conventions.

Throughout this guide, the word @dfn{STREAMS} will refer to the mechanism and the word @dfn{Stream}
will refer to the path between a user application and a driver.  In connection with
@dfn{STREAMS}-based pipes @dfn{Stream} refers to the data transfer path in the kernel between the
kernel and one or more user processes.

Examples are given to highlight the most important and common capabilities of @dfn{STREAMS}.  They
are not exhaustive and, for simplicity, often reference fictional drivers and modules.  Some
examples are also present in the @cite{@value{PACKAGE_TITLE}} package, both for testing and example
purposes.

System calls, @dfn{STREAMS} utility routines, header files, and data structures are given using
@command{texinfo} @file{filename} typesetting, when they are mentioned in the text.

Variable names, pointers, and parameters are given using @command{texinfo} @var{variable}
typesetting conventions.  Routine, field, and structure names unique to the examples are also given
using @command{texinfo} @var{variable} typesetting conventions when they are mentioned in the text.

Declarations and short examples are in @command{texinfo} @samp{sample} typesetting.

@command{texinfo} displays are used to show program source code.
@ignore
Screens are used to simulate what a user will see on a video display screen or to show program
source code.
@end ignore

Data structure formats are also shown in @command{texinfo} displays.

@ignore
[Boxcaut.gif]

The caution sign is used to show possible harm or damage to a system, an application, a process, a
piece of hardware, etc.

[Boxnote.gif]

The note sign is used to emphasize points of interest, to present parenthetical information, and to
cite references to other documents and commands.
@end ignore

@subsection Other Documentation

Although the @cite{@value{MANUAL_TYPE}} for @cite{@value{PACKAGE_TITLE}} provides a guide to aid in
developing @dfn{STREAMS} applications, readers are encouraged to consult the
@cite{@value{PACKAGE_TITLE}} manual pages.  For a reference for writing code, the manual pages (see
@manref{STREAMS(9)}) provide a better reference to the programmer.
For detailed information on
system calls used by @dfn{STREAMS} (section 2), and
@dfn{STREAMS} utilities from section 8.
@dfn{STREAMS} specific input output control (ioctl) calls are provided in @manref{streamio(7)}.
@dfn{STREAMS} modules and drivers are described on section 7.
@dfn{STREAMS} is also described to some extent in the @cite{System V Interface Definition, Third Edition}.

@subsection UNIX Edition

This system conforms to @cite{UNIX System V Release 4.2} for @cite{Linux}.


@subsection Related Manuals

@cite{@value{PACKAGE_TITLE} Installation and Reference Manual}

@subsection Copyright

@copyright{} 1997-2005  OpenSS7 Corporation.  All Rights Reserved.

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@c ============================================================================
@node Introduction
@chapter Introduction
@menu
* Background::			STREAMS Background
* What is STREAMS?::		STREAMS Description
* Basic Streams Operations::	STREAMS Basic Operations
* Components::			STREAMS Components
* Multiplexing of Streams::	STREAMS Multiplexing
* Benefits of STREAMS::		STREAMS Benefits
@end menu

@c ----------------------------------------------------------------------------
@node Background
@section Background

@dfn{STREAMS} is a facility first presented in a paper by Dennis M. Ritchie in
1984,@footnote{@cite{A Stream Input-Output System, AT&T Bell Laboratories Technical Journal 63, No.
8 Part 2 (October, 1984), pp.  1897-1910.}} originally implemented on 4.1BSD and later part of
@cite{Bell Laboratories Eighth Edition UNIX}, incorporated into
@cite{UNIX System V Release 3.0}
@cindex UNIX System V Release 3.0
and enhanced in
@cite{UNIX System V Release 4}
@cindex UNIX System V Release 4
and
@cite{UNIX System V Release 4.2}.
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used in @cite{SVR4} for terminal input/output, pseudo-terminals, pipes, named
pipes (FIFOs), interprocess communication and networking.  Since its release in @cite{System V
Release 4}, @dfn{STREAMS} has been implemented across a wide range of @cite{UNIX}, @cite{UNIX}-like,
and @cite{UNIX}-based systems, making its implementation and use an @i{ipso facto} standard.

@dfn{STREAMS} is a facility that allows for a reconfigurable full duplex communications path,
@dfn{Stream}, between a user process and a driver in the kernel.  Kernel protocol modules can be
pushed onto and popped from the @dfn{Stream} between the user process and driver.  The @dfn{Stream}
can be reconfigured in this way by a user process.  The user process, neighbouring protocol modules
and the driver communicate with each other using a message passing scheme closely related to
@dfn{MOM (Message Oriented Middleware)}.  This permits a loose coupling between protocol modules,
drivers and user processes, allowing a third-party and loadable kernel module approach to be taken
toward the provisioning of protocol modules on platforms supporting @dfn{STREAMS}.

On @cite{UNIX System V Relase 4.2},
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used for terminal input-output, pipes, FIFOs (named pipes), and network
communications.  Modern @cite{UNIX}, @cite{UNIX}-like and @cite{UNIX}-based systems providing
@dfn{STREAMS} normally support some degree of network communications using @dfn{STREAMS}; however,
many do not support @dfn{STREAMS}-based pipe and FIFOs@footnote{For example, AIX.} or terminal
input-output.@footnote{For example, HP-UX}.

@cite{Linux} has not traditionally implemented a @dfn{STREAMS} subsystem.  It is not clear why,
however, perceived ideological differences between @dfn{STREAMS} and @dfn{Sockets} and also the
@dfn{XTI/TLI} and @dfn{Sockets} interfaces to @dfn{Internet Protocol} services are usually at the
centre of the debate.  For additional details on the debate,
@pxref{Top, , About This Manual, STREAMS_FAQ, @value{PACKAGE_TITLE} Frequently Asked Questions}.

@cite{Linux} pipes and FIFOs are @cite{SVR3}-style, and the @cite{Linux} terminal subsystem is
@cite{BSD}-like.  @cite{UNIX 98 Pseudo-Terminals}, @file{ptys}, have a specialized implementation
that does not follow the @dfn{STREAMS} framework and, therefore, do not support the pushing or
popping of @dfn{STREAMS} modules.  Internal networking implementation under @cite{Linux} follows the
@cite{BSD} approach with a native (system call) @dfn{Sockets} interface only.

@cite{RedHat} at one time provided an @cite{Intel Binary Compatibility Suite (iBCS)} module for
@cite{Linux} that supported the @dfn{XTI/TLI} interface and @file{socksys} system calls and
input-output controls, but not the @dfn{STREAMS} framework (and therefore cannot push or pop
modules).

A @dfn{STREAMS} package for @cite{Linux} was written and eventually distributed and maintained by
@uref{http://www.gcom.com/,GCOM Inc.}   This is the @cite{Linux STREAMS (LiS)} package.  This
package had some failings and was repeatedly rejected for mainline adoption, which prompted the
development of @cite{@value{PACKAGE_TITLE}}.  @cite{Linux STREAM (LiS)} is no longer supported (it
does not have a maintainer).

@cite{@value{PACKAGE_TITLE}} is the current open source implementation of @cite{STREAMS} for
@cite{Linux} and provides all of the capabilities of @cite{UNIX System V Release 4.2 MP}, plus
support for mainstream @cite{UNIX} implementations based on @cite{UNIX System V Release 4.2 MP}
through compatibility modules.

Although it is intended primarily as documentation for the @cite{@value{PACKAGE_TITLE}}
implementation of @cite{STREAMS}, much of the @cite{@value{MANUAL_TITLE} - @value{MANUAL_TYPE}} is
generally applicable to all @cite{STREAMS} implementations.

@c ----------------------------------------------------------------------------
@node What is STREAMS?
@section What is STREAMS?

@dfn{STREAMS} is a flexible, message oriented framework for the development of @cite{GNU/Linux}
communications facilities and protocols.  It provide a set of system calls, kernel resources, and
kernel utilities within a framework that is applicable to a wide range of communications facilities
including terminal subsystems, interprocess communication, and networking.  It provides standard
interfaces for communication input and output within the kernel, common facilities for device
drivers, and a standard interface@footnote{@cite{XPG 4.2/XNS 4.2}, @cite{XPG 5/XNS 5},
@cite{POSIX/SUSv2 XSI Extensions} and @cite{POSIX/SUSv3 XSR Extensions}.} between the kernel and the
rest of the @cite{GNU/Linux} system.

The standard interface and mechanism enable modular, portable development and easy integration of
high performance network services and their components.  Because it is a message passing
architecture, @dfn{STREAMS} does not impose a specific network architecture (as does the @dfn{BSD
Sockets} kernel architecture.  The @dfn{STREAMS} user interface is uses the familiar @cite{UNIX}
character special file input and output mechanisms @manpage{open(2)}, @manpage{read(2)},
@manpage{write(2)}, @manpage{ioctl(2)}, @manpage{close(2)}; and provides additional system calls,
@manpage{poll(2)}, @manpage{getmsg(2)}, @manpage{getpmsg(2)}, @manpage{putmsg(2)},
@manpage{putpmsg(2)}, to assist in message passing between user-level applications and
kernel-resident modules.  Also, @dfn{STREAMS} defines a standard set of input-output controls
(@manpage{ioctl(2)}) for manipulation and configuration of @dfn{STREAMS} by a user-space
application.

As a message passing architecture, the @dfn{STREAMS} interface between the user process and kernel
resident modules can be treated either as fully synchronous exchanges or can be treated
asynchronously for maximum performance.

@subsection Characteristics

@dfn{STREAMS} has the the following characteristics that are not exhibited (or are exhibited in
different ways) by other kernel level subsystems:

@itemize @bullet

@item @dfn{STREAMS} is based on the character device special file which is one of the most flexible
special files available in the @cite{GNU/Linux} system.

@item @dfn{STREAMS} is a message passing architecture, similar to @cite{Message Oriented Middleware
(MOM)} that achieves a high degree of functional decoupling between modules.  This allows the
service interface between modules to correspond to the natural interfaces found or described between
protocol layers in protocol stack without requiring the implementation to conform to any given
model.

As a contrasting example, the @dfn{BSD Sockets} implementation, internal to the kernel, provides
strict socket-protocol, protocol-protocol and protocol-device function call interfaces.

@item By using @command{put} and @command{service} procedures for each module, and scheduling
@command{service} procedures, @dfn{STREAMS} combines background scheduling of coroutine service
procedures with message queueing and flow control to provide a mechanism robust for both event driven
subsystem and soft real-time subsystem.

In contrast, @dfn{BSD Sockets}, internal to the kernel, requires the sending component across the
socket-protocol, protocol-protocol, or protocol-device to handle flow control.  @dfn{STREAMS}
integrates flow control within the @dfn{STREAMS} framework.

@item @dfn{STREAMS} permits user runtime configuration of kernel data structure and modules to
provide for a wide range of novel configurations and capabilities in a live @cite{GNU/Linux} system.
The @dfn{BSD Sockets} protocol framework does not provide this capability.

@item @dfn{STREAMS} is as applicable to termination input-output and interprocess communication as
it is to networking protocols.

@dfn{BSD Sockets} is only applicable to a restricted range of networking protocols.

@item @dfn{STREAMS} provides mechanisms (the pushing and popping of modules, and the linking and
unlinking of @dfn{Streams} under multiplexing drivers) for complex configuration of protocol stacks;
the precise topology being typically under the control of user space daemon processes.

No other kernel protocol stack framework provides this flexible capability.  Under @dfn{BSD Sockets}
it is necessary to define specialized socket types to perform these configuration functions and not
in any standard way.

@end itemize

@subsection Components

@dfn{STREAMS} provides a full-duplex communications path for data and control information between a
kernel-resident driver and a user space process (see @figref{101}).

Within the kernel, a @dfn{Stream} is comprised of the following basic components:

@itemize @bullet
@item A @dfn{Stream head} that is inside the @cite{Linux} kernel, but which sits closest to the user
space process.  The @dfn{Stream head} is responsible for communicating with user space processes and
that presents the standard @dfn{STREAMS} I/O interface to user space processes and applications.
@item A @dfn{Stream end} or @dfn{Driver} that is inside the @cite{Linux} kernel, but which sits
farthest from the user space process.  A @dfn{Stream end} or @dfn{Driver} that interfaces to
hardware or other mechanisms within the @cite{Linux} kernel.
@item  A @dfn{Module} that sits between the @dfn{Stream head} and @dfn{Stream end}.  The
@dfn{Module} provides modular and flexible processing of control and data information passed up and
down the @dfn{Stream}.
@end itemize

@figuresized{SPG_fig01,101,Simple Stream,3in}

@subsubsection Stream head

A @dfn{Stream head} is the component of a @dfn{Stream} that is closest to the user space process.
The @dfn{Stream head} is responsible for directly communicating with the user space process in user
context and for converting system calls to actions performed on the @dfn{Stream head} or the
conversion of control and data information passed between the user space process and the
@dfn{Stream} in response to system calls.  All @dfn{Streams} are associate with a @dfn{Stream head}.
In the case of @dfn{STREAMS}-based pipes, the @dfn{Stream} may be associated with two
(interconnected) @dfn{Stream heads}.  Because the @dfn{Stream head} follows the same structure as a
@dfn{Module}, it can be viewed as a specialized module.

With @dfn{STREAMS}, pipes and FIFOs are also @dfn{STREAMS}-based.@footnote{Unlike the native
@cite{Linux} pipes and FIFOs that use the older @cite{UNIX System V Release 3} or @dfn{BSD}
approaches to these facilities.}  @dfn{STREAMS}-based pipes and FIFOs do not have a @dfn{Driver}
component.

@dfn{STREAMS}-based pipes place another @dfn{Stream head} in the position of the @dfn{Driver}.  That
is, a @dfn{STREAMS}-based pipe is a full-duplex communications path between two otherwise
independent @dfn{Stream heads}.  @dfn{Modules} may be placed between the @dfn{Stream heads} in the
same fashion as they can exist between a @dfn{Stream head} and a @dfn{Driver} in a normal
@dfn{Stream}.
A @dfn{STREAMS}-based pipe is illustrated in @figref{102}.

@figuresized{SPG_fig02,102,@dfn{STREAMS}-based Pipe,3in}

@dfn{STREAMS}-based FIFOs consist of a single @dfn{Stream head} that has its downstream path
connected to its upstream path where the @dfn{Driver} would be located.  @dfn{Modules} can be pushed
under this single @dfn{Stream Head}.
A @dfn{STREAMS}-based FIFO is illustrated in @figref{109}.

@figuresized{SPG_fig07,109,@dfn{STREAMS}-based @dfn{FIFO} (named pipe),3in}

For more information on @dfn{STREAMS}-based pipes and FIFOs, @pxref{Pipes and FIFOs}.

@subsubsection Module

A @dfn{STREAMS} @dfn{Module} is an optional processing element that is placed between the
@dfn{Stream head} and the @dfn{Stream end}.  The @dfn{Module} can perform processing functions on
the data and control information flowing in either direction on the @dfn{Stream}.  It can
communicate with neighbouring modules, the @dfn{Stream head} or a @dfn{Driver} using @dfn{STREAMS}
messages.  Each @dfn{Module} is self-contained in the sense that it does not directly invoke
functions provided by, nor access datastructures of, neighbouring modules, but rather communicates
data, status and control information using messages.  This functional isolation provides a loose
coupling that permits flexible recombination and reuse of @dfn{Modules}.  A @dfn{Module} follows the
same framework as the @dfn{Stream head} and @dfn{Driver}, has all of the same entry points and can
use all of the same @dfn{STREAMS} and kernel utilities to perform its function.

@dfn{Modules} can be inserted between a @dfn{Stream head} and @dfn{Stream end} (or another
@dfn{Stream head} in the case of a @dfn{STREAMS}-based pipe or FIFO).  The insertion and deletion of
@dfn{Modules} from a @dfn{Stream} is referred to as @dfn{pushing} and @dfn{popping} a @dfn{Module}
due to the fact that that modules are inserted or removed from just beneath the @dfn{Stream head} in
a push-down stack fashion.  Pushing and popping of modules can be performed using standard
@manpage{ioctl(2)} calls and can be performed by user space applications without any need for kernel
programming, assembly, or relinking.

For more information on @dfn{STREAMS Modules}, @pxref{Module Component}.

@subsubsection Driver

All @dfn{Streams}, with the sole exception of @dfn{STREAMS}-based pipe and FIFOs, contain a
@dfn{Driver} a the @dfn{Stream end}.  A @dfn{STREAMS} @dfn{Driver} can either be a @dfn{device
driver} that directly or indirectly controls hardware, or can be a @dfn{pseudo-device driver} that
interface with other software subsystems within the kernel.  @dfn{STREAMS} drivers normally perform
little processing within the @dfn{STREAMS} framework and typically only provide conversion between
@dfn{STREAMS} messages and hardware or software events (e.g. interrupts) and conversion between
@dfn{STREAMS} framework data structures and device related data structures.

For more information on @dfn{STREAMS Drivers}, @pxref{Driver Component}.

@subsubsection Queues

Each component in a @dfn{Stream} (@dfn{Stream head}, @dfn{Module}, @dfn{Driver}) has an associated
pair of queues.  One @dfn{queue} in each pair is responsible for managing the message flow in the
@dfn{downstream} direction from @dfn{Stream head} to @dfn{Stream end}; the other for the
@dfn{upstream} direction.  The @dfn{downstream} @dfn{queue} is called the @dfn{write-side}
@dfn{queue} in the @dfn{queue} pair; the @dfn{upstream} @dfn{queue}, the @dfn{read-side}
@dfn{queue}.

Each @dfn{queue} in the pair provides pointers necessary for organizing the temporary storage and
management of @dfn{STREAMS} messages on the @dfn{queue}, as well as function pointers to procedures
to be invoked when messages are placed on the @dfn{queue} or need to be taken off of the
@dfn{queue}, and pointers to auxillary and module-private data structures.  The @dfn{read-side}
@dfn{queue} also contains function pointers to procedures used to @command{open} and @command{close}
the @dfn{Stream head}, @dfn{Module} or @dfn{Driver} instance associated with the @dfn{queue} pair.
@dfn{Queue} pairs are dynamically allocated when an instance of the @dfn{driver}, @dfn{module} or
@dfn{Stream head} is created and deallocated when the instance is destroyed.

For more information on @dfn{STREAMS Queues}, @pxref{Queue Component}.

@subsubsection Messages

@dfn{STREAMS} is a message passing architecture.  @dfn{STREAMS} messages can contain control
information or data, or both.  Messages that contain control information are intended to illicit a
response from a neighbouring module, @dfn{Stream head} or @dfn{Stream end}.  The control information
typically uses the message type to invoke a general function and the fields in the control part of
the messge as arguments to a call to the function.  The data portion of a message represents
information that is (from the perspective of the @dfn{STREAMS} framework) unstructured.  Only
cooperating modules, the @dfn{Stream head} or @dfn{Stream end} need know or agree upon the format of
control or data messages.

A @dfn{STREAMS} message consists of one or more blocks.  Each block is a 3-tuple of a message block,
a data block and a data buffer.  Each data block has a message type, and the data buffer contains
the control information or data associated with each block in the message.  @dfn{STREAMS} messages
typically consist of one control-type block (@constant{M_PROTO}) and zero or more data-type blocks
(@constant{M_DATA}), or just a data-type block.

A set of specialized and standard message types define messages that can be sent by a @dfn{module}
or @dfn{driver} to control the @dfn{Stream head}.  A set of specialized and standard message types
define messages that can be sent by the @dfn{Stream head} to control a @dfn{module} or @dfn{driver},
normaly in response to a standard input-output control for the @dfn{Stream}.

@dfn{STREAMS} messages are passed between a module, @dfn{Stream head} or @dfn{Driver} using a
@command{put} procedure associated with the queue in the queue pair for the direction in which
the message is being passed.  Messages passed towards the @dfn{Stream head} are passed in the
@dfn{upstream} direction, and those towards the @dfn{Stream end}, in the @dfn{downstream} direction.
The @dfn{read-side} queue in the queue pair associated with the module instance to which a message
is passed is responsible for processing or queueing @dfn{upstream} messages; the @dfn{write-side}
queue, for processing @dfn{downstream} messages.

@dfn{STREAMS} messages are generated by the @dfn{Stream head} and passed @dfn{downstream} in
response to @manpage{write(2)}, @manpage{putmsg(2)}, and @manpage{putpmsg(2)} system calls; they are
also consumed by the @dfn{Stream head} and converted to information passed to user space in response
to @manpage{read(2)}, @manpage{getmsg(2)}, and @manpage{getpmsg(2)} system calls.

@dfn{STREAMS} messages are also generated by the @dfn{Driver} and passed @dfn{upstream} to
ultimately be read by the @dfn{Stream head}; they are also consumed when written by the @dfn{Stream
head} and ultimately arrive at the @dfn{Driver}.

For more information on @dfn{STREAMS Messages}, @pxref{Message Component}.

@c ----------------------------------------------------------------------------
@node Basic Streams Operations
@section Basic Streams Operations

This section provides a basic description of the user level interface and system calls that are used
to manipulate a @dfn{Stream}.

A @dfn{Stream} is similar, and indeed is implemented, as a character device special file and is
associated with a character device within the @cite{GNU/Linux} system.  Each @dfn{STREAMS} character
device special file (character device node, see @manref{mknod(2)}) has associated with it a major
and minor device number.  In the usual situation, a @dfn{Stream} is associated with each minor
character device node in a similar fashion to a minor device instance for regular character device
drivers.

@dfn{STREAMS} devices are opened, as are character device drivers, with the @manpage{open(2)} system
call.@footnote{An exception is @dfn{STREAMS}-based pipes, that are opened with the @manpage{pipe(2)}
system call.}  Opening a minor device node accesses a separate @dfn{Stream} instance between the
user level process and the @dfn{STREAMS} device driver.  As with normal character devices, the file
descriptor returned from the @manpage{open(2)} call, can be used to further access the @dfn{Stream}.

Opening a minor device node for the first time results in the creation of a new instance of a
@dfn{Stream} between the @dfn{Stream head} and the @dfn{driver}.  Subsequent opens of the same minor
device node does not result in the creation of a new @dfn{Stream}, but provides another file
descriptor that can be used to access the same @dfn{Stream} instance.  Only the first open of a
minor device node will result in the creation of a new @dfn{Stream} instance.

Once it has opened a @dfn{Stream}, the user level process can send and receive data to and from the
@dfn{Stream} with the usual @manpage{read(2)} and @manpage{write(2)} system calls that are
compatible with the existing character device interpretations of these system calls.  @dfn{STREAMS}
also provides the additional system calls, @manpage{getmsg(2)} and @manpage{getpmsg(2)}, to read
control and data information from the @dfn{Stream}, as well as @manpage{putmsg(2)} and
@manpage{putpmsg(2)} to write control and data information.  These additional system calls provide a
richer interface to the @dfn{Stream} than is provided by the traditional @manpage{read(2)} and
@manpage{write(2)} calls.

A @dfn{Stream} is closed using the @manpage{close(2)} system call (or a call that closes file
descriptors such as @manpage{exit(2)}).  If a number of processes have the @dfn{Stream} open, only
the last @manpage{close(2)} of a @dfn{Stream} will result in the destruction of the @dfn{Stream}
instance.

@subsection Basic Operations Example
An basic example of opening, reading from and writing to a @dfn{Stream} driver is shown in
@ref{Listing 101}.

@cartouche
@iftex
@float Listing,Listing 101
@end iftex
@smallexample
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
main()
@{
        char buf[1024]
        int fd, count;

        if ((fd = open("/dev/streams/comm/1", O_RDWR)) < 0) @{
                perror("open failed");
                exit(1);
        @}

        while ((count = read(fd, buf, 1024)) > 0) @{
                if (write(fd, buf, count) != count) @{
                        perror("write failed");
                        break;
                @}
        @}
        exit(0);
@}
@end smallexample
@iftex
@caption{@emph{Basic Operations}}
@end float
@end iftex
@ifnottex
@anchor{Listing 101} @center @emph{Listing 101.@:  Basic Operations}
@set lstnum 101
@end ifnottex
@end cartouche

The example in @ref{Listing 101} is for a communications device that provide a communications
channel for data transfer between two processes or hosts.   Data written to the device is
communicated over the channel to the remote process or host.  Data read from the device was written
by the remote process or host.

In the example in @ref{Listing 101}, a simple @dfn{Stream} is opened using the @manpage{open(2)}
call.  @file{/dev/streams/comm/1} is the path to the character minor device node in the file system.
When the device is opened, the character device node is recognized as a @dfn{STREAMS} special file,
and the @dfn{STREAMS} subsystem creates a @dfn{Stream} (if one does not already exist for the minor
device node) an associates it with the minor device node.  @figref{103} illustrates the state of the
@dfn{Stream} at the point after the @manpage{open(2)} call returns.

@figuresized{SPG_fig03,103,Stream to Communications Driver,3in}

The @command{while} loop in @ref{Listing 101} simply reads data from the device using the
@manpage{read(2)} system call and then writes the data back to the device using the
@manpage{write(2)} system call.

When a @dfn{Stream} is opened for blocking operation (i.e., neither @constant{O_NONBLOCK} nor
@constant{O_NDLEAY} were set), @manpage{read(2)} will block until some data arrives.  The
@manpage{read(2)} call might, however, return less that the requested @samp{1024} bytes.  When data
is read, the routine simply writes the data back to the device.

@dfn{STREAMS} implements flow control both in the upstream and downstream directions.  Flow control
limits the amount of normal data that can be queued awaiting processing within the @dfn{Stream}.
High and low water marks for flow control are set on a queue pair basis.  Flow control is local and
specific to a given @dfn{Stream}.  High priority control messages are not subject to @dfn{STREAMS}
flow control.

When a @dfn{Stream} is opened for blocking operation (i.e., neither @constant{O_NONBLOCK} nor
@constant{O_NDLEAY} were set), @manpage{write(2)} will block while waiting for flow control to
subside. @manpage{write(2)} will always block awaiting the availability of @dfn{STREAMS} message
blocks to satisfy the call, regardless of the setting of @constant{O_NONBLOCK} or
@constant{O_NDELAY}.

In the example in @ref{Listing 101}, the @manpage{exit(2)} system call is used to exit the program;
however, the @manpage{exit(2)} results in the equivalent of a call to @manpage{close(2)} for all
open file descriptors and the @dfn{Stream} is flushed and destroyed before the program is finally
exited.

@c ----------------------------------------------------------------------------
@node Components
@section Components
@menu
* Queue Component::
* Message Component::
* Module Component::
* Driver Component::
* Stream Head Component::
@end menu

This section briefly describes each @dfn{STREAMS} component and how they interact within a
@dfn{Stream}.  Chapters later in this manual describe the components and their interaction in
greater detail.

@c ----------------------------------------
@node Queue Component
@subsection Queues

This subsection provides a brief overview of message @dfn{queues} and their associated procedures.

A @dfn{queue} provides an interface between an instance of a @dfn{STREAMS} driver, module or
@dfn{Stream head}, and the other modules and drivers that make up a @dfn{Stream} for a direction of
message flow (i.e., @dfn{upstream} or @dfn{downstream}).  When an instance of a @dfn{STREAMS}
driver, module or @dfn{Stream head} is associated with a @dfn{Stream}, a pair of queues are
allocated to represent the driver, module or @dfn{Stream head} within the @dfn{Stream}.  Queue data
structures are always allocated in pairs.  The first queue in the pair is the @dfn{read-side} or
@dfn{upstream} queue in the pair; the second queue, the @dfn{write-side} or @dfn{downstream} queue.

Queues are described in greater detail in @ref{Queues and Priority}.

@subsubsection Queue Procedures

This subsection provides a brief overview of @dfn{queue} procedures.

The @dfn{STREAMS} module, driver or @dfn{Stream head} provides five procedures that are associated
with each queue in a queue pair: the @command{put}, @command{service}, @command{open},
@command{close} and @command{admin} procedures.  Normally the @command{open} and @command{close}
procedures (and possibly the optional @command{admin} procedure) are only associated with the
@dfn{read-side} of the queue pair.

Each queue in the pair has a pointer to a @command{put} procedure.  The @command{put} procedure is
used by @dfn{STREAMS} to present a new message to an upstream or downstream queue.  At the ends of
the @dfn{Stream}, the @dfn{Stream head} write-side, or @dfn{Stream end} read-side, queue
@command{put} procedure is normally invoked using the @manref{put(9)} utility.  A module within the
@dfn{Stream} typically has its @command{put} procedure invoked by an adjacent module, driver or
@dfn{Stream head} that uses the @manref{putnext(9)} utility from its own @command{put} or
@command{service} procedure to pass message to adjacent modules.  The @command{put} procedure of the
queue receiving the message is invoked.  The @command{put} procedure decides whether to process the
message immediately, queue the message on the message queue for later processing by the queue's
@command{service} procedure, or whether to pass the message to a subsequent queue using
@manpage{putnext(9)}.

Each queue in the pair has a pointer to an optional @command{service} procedure.  The purpose of a
@command{service} procedure process messages that were deferred by the @command{put} procedure by
being placed on the message queue with utilities such as @manref{putq(9)}.  A @command{service}
procedure typically loops through taking messages off of the queue and processing them.  The
procedure normally terminates the loop when it can not process the current message (in which case it
places the message back on the queue with @manref{putbq(9)}), or when there is no longer any
messages left on the queue to process.  A @command{service} procedure is optional in the sense that
if the @command{put} procedure never places any messages on the queue, a @command{service} procedure
is unnecessary.

Each queue in the pair also has a pointer to a @command{open} and @command{close} procedure;
however, the @var{qi_qopen} and @var{qi_qclose} pointers are only significant in the @dfn{read-side}
queue of the queue pair.

The queue @command{open} procedure for a driver is called each time that a driver (or @dfn{Stream
head}) is opened, including the first open that creates a @dfn{Stream} and upon each successive open
of the @dfn{Stream}.  The queue @command{open} procedure for a module is called when the module is
first pushed onto (inserted into) a @dfn{Stream}, and for each successive open of a @dfn{Stream}
upon which the module has already been pushed (inserted).

The queue @command{close} procedure for a module is called whenever the module is popped (removed)
from a @dfn{Stream}.  Modules are automatically popped from a @dfn{Stream} on the last close of the
@dfn{Stream}.  The queue @command{close} procedure for a driver is called with the last close of the
@dfn{Stream} or when the last reference to the @dfn{Stream} is relinquished.  If the @dfn{Stream} is
linked under a multiplexing driver (@ioctlref{I_LINK}), or has been named with @manref{fattach(3)},
then the @dfn{Stream} will not be dismantled on the last close and the @command{close} procedure not
called until the @dfn{Stream} is eventually unlinked (@ioctlref{I_UNLINK}) or detached
(@manref{fdetach(3)}).

Procedures are described in greater detail in @ref{Procedures}.

@c ----------------------------------------
@node Message Component
@subsection Messages

This subsection provides a brief overview of @dfn{STREAMS messages}.

In fitting with the concept of function decoupling, all control and data information is passed
between @dfn{STREAMS} modules, drivers and the @dfn{Stream head} using messages.  Utilities are
provided to the @dfn{STREAMS} module writer for passing messages using queue and message pointers.
@dfn{STREAMS} messages consist of a 3-type of a message block structure (@manref{msgb(9)}), a data
block structure (@manref{datab(9)}) and a data buffer.  The message block structure is used to
provide an instance of a reference to a data block and pointers into the data buffer.  The data
block structure is used to provide information about the data buffer, such as message type, separate
from the data contained in the buffer.  Messages are normally passed between @dfn{STREAMS} modules,
drivers and the @dfn{Stream head} using utilities that invoke the target module's @command{put}
procedure, such as @manref{put(9)}, @manref{putnext(9)}, @manref{qreply(9)}.  Messages travel along
a @dfn{Stream} with successive invocations of each driver, module and @dfn{Stream head}'s
@command{put} procedure.

Messages are described in greater detail in @ref{Messages}.

@subsubsection Message Types

This subsection provides a brief overview of @dfn{STREAMS message types}.

Each data block (@manref{datab(9)}) is assigned a message type.  The message type discriminates the
use of the message by drivers, modules and the @dfn{Stream head}.  Most of the message type may be
assigned by a module or driver when it generates a message, and the message type can be modified as
a part of message processing.  The @dfn{Stream head} uses a wider set of message types to perform
its function of converting the functional interface to the user process into the messaging interface
used by @dfn{STREAMS} modules and drivers.

Most of the defined message types (@pxref{Message Types}) are solely for use within the
@dfn{STREAMS} framework.  A more limited set of message types (@msg{M_PROTO}, @msg{M_PCPROTO} and
@msg{M_DATA}) can be used to pass control and data information to and from the user process via the
@dfn{Stream head}.  These message type can be generated and consumed using the @manref{read(2)},
@manref{write(2)}, @manref{getmsg(2)}, @manref{getpmsg(2)}, @manref{putmsg(2)}, @manref{putpmsg(2)}
system calls and some @manref{streamio(7)} @dfn{STREAMS} @manpage{ioctl(2)}.

Message types are described in detail in @ref{Message Types}.

@subsubsection Message Linkage

Messages blocks of differing types can be linked together into composite messages as illustrated in
@figref{104}.

@figuresized{SPG_fig05,104,A Message,4in}

Messages, once allocated, or when removed from a queue, exist standalone (i.e., they are not
attached to any queue).  Messages normally exist standalone when they have been first allocated by
an interrupt service routine, or by the @dfn{Stream head}.  They are placed into the @dfn{Stream} by
the driver or @dfn{Stream head} at the @dfn{Stream end} by calling @manref{put(9)}.  After being
inserted into a @dfn{Stream}, message normally only exist standalone in a given queue's
@command{put} or @command{service} procedures.  A queue's @command{put} or @command{service}
procedure normally do one of the following:
@itemize @bullet
@item pass the message along to an adjacent queue with @manref{putnext(9)} or @manref{qreply(9)};
@item process and consume the message by deallocating it with @manref{freemsg(9)};
@item place the message on the queue from the @command{put} procedure with @manref{putq(9)} or from
the @command{service} procedure using @manref{putbq(9)}.
@end itemize
Once placed on a queue, a message exists only on that queue and all other references to the message
are dropped.

Only one reference to a message block (@manpage{msgb(9)}) exists within the @dfn{STREAMS} framework.
Additional references to the same data block (@manpage{datab(9)}) and data buffer can be established
by duplicating the messages block, @manpage{msgb(9)} (without duplicating either the data
block,(@manpage{datab(9)}, or data buffer).  The @dfn{STREAMS} @manref{dupb(9)} and
@manref{dupmsg(9)} utilities can be used to duplicate message blocks.  Also, the entire 3-tuple of
message block, data block and data buffer can be copied using the @manref{copyb(9)} and
@manref{copymsg(9)} @dfn{STREAMS} utilities.

When a message is first allocated, it is the responsibility of the allocating procedure to either
pass the message to a queue @command{put} procedure, place the message on its own message queue, or
free the message.  When a message is removed from a message queue, the reference then becomes the
responsibility of the procedure that removed it from the queue.  Under special circumstances, it
might be necessary to temporarily store a reference to a standalone message in a module private
data structure, however, this is usually not necessary.

When a message has been placed on a queue, it is linked into the list of messages already on the
queue.  Messages that exist on a message queue await processing by the queue's @command{service}
procedure.  Essentially, queue @command{put} procedures are a way of performing immediate message
processing, and placing a message on a message queue for later processing by the queue's
@command{service} procedure is a way of deferring message processing until a later time: that is,
until @dfn{STREAMS} schedules the @command{service} procedure for execution.

Two messages linked together on a message queue is illustrated in @figref{105}.  In the figure,
@samp{Message 2} is linked to @samp{Message 1}.

@figuresized{SPG_fig06,105,Messages on a Message Queue,4in}

As illustrated in @figref{105}, when a message exists on a message queue, the first message block in
the message (which can possibly contain a chain of message blocks) is linked into a double linked
list used by the message queue to order and track messages.  The queue structure, @manref{queue(9)},
contains the head and tail pointers for the linked list of messages that reside on the queue.  Some
of the fields in the first message block (such as the linked list pointers) are significant only in
the first message block of the message and applies to all the message blocks in the message (such as
message band).

Message linkage is described in detail in @ref{Message Structure}.

@subsubsection Message Queueing Priority

This subsection provides a brief overview of @dfn{message queueing priority}.

@dfn{STREAMS} message queues provide the ability to process messages of differing priority.  There
are three classes of message priority (in order of increasing priority):
@enumerate
@item Normal messages.
@item Priority messages.
@item High-priority messages.
@end enumerate

Normal messages are queued in priority band @samp{0}.  Priority messages are queued in bands greater
than zero (@samp{1} through @samp{255} inclusive).  Messages of a higher ordinal band number are of
greater priority.  For example, a priority message for band @samp{23} is queued ahead of messages
for band @samp{22}.  Normal and priority messages are subject to flow control within a @dfn{Stream},
and a queued according to priority.

High priority messages are assigned a priority band of @samp{0}; however, their message type
distinguishes them as high priority messages and they are queued ahead of all other messages.  (The
priority band for high priority messages is ignored and always set to @samp{0} whenever a high
priority message type is queued.) High priority messages are given special treatment within the
@dfn{Stream} and are not subjected to flow control; however, only one high priority message can be
outstanding for a given transaction or operation within a @dfn{Stream}.  The @dfn{Stream head} will
discard high priority messages that arrive before a previous high priority message has been acted
upon.

Because queue @command{service} procedures process messages in the order in which they appear in the
queue, messages that are queued toward the head of the queue yield a higher scheduling priority than
those toward the tail.  High priority messages are queue first, followed by priority messages of
descending band numbers, finally followed by normal (band @samp{0}) messages.

@dfn{STREAMS} provides independent flow control parameters for ordinary messages.  Normal message flow
control parameters are contained in the queue structure itself (@manref{queue(9)}); priority
parameters, in the auxiliary queue band structure (@manref{qband(9)}).  A set of flow control
parameters exists for each band (from @samp{0} to @samp{255}).

As a high priority message is defined by message type, some message types are available in
high-priority/ordinary pairs (e.g., @msg{M_PCPROTO}/@msg{M_PROTO}) that perform the same function
but which have differing priority.

Queueing priority is described in greater detail in @ref{Queues and Priority}.

@c ----------------------------------------
@node Module Component
@subsection Modules

This subsection provides a brief overview of @dfn{STREAMS modules}.

@dfn{Modules} are components of message processing that exist as a unit within a @dfn{Stream}
beneath the @dfn{Stream head}.  @dfn{Modules} are optional components and zero or more (up to a
predefined limit) instances of a module can exist within a given @dfn{Stream}.  Instances of a
@dfn{module} have a unique queue pair associated with them that permit the instance to be linked
among the other queue pairs in a @dfn{Stream}.

@figref{48} illustrates and instance each of two modules (@samp{A} and @samp{B}) that are linked
within the same @dfn{Stream}.  Each module instance consists of a queue pair (@samp{Ad/Au} and
@samp{Bd/Bu} in the figure).  Messages flow from the driver to the @dfn{Stream head} through the
@dfn{upstream} queues in each queue pair (@samp{Au} and then @samp{Bu} in the figure); and from
@dfn{Stream head} to driver through @dfn{downstream} queues (@samp{Bd} and then @samp{Ad}).

The @dfn{module} provides unique message processing procedures (@command{put} and optionally
@command{service} procedures) for each queue in the queue pair.  One set of @command{put} and
@command{service} procedures handles @dfn{upstream} messages; the other set, @dfn{downstream}
messages.  Each procedure is independent of the others.  @dfn{STREAMS} handles the passing of
messages but any other information that is to be passed between procedures must be performed
explicitly by the procedures themselves.  Each queue provides a module private pointer that can be
used by procedures for maintaining state information or passing other information between
procedures.

@figuresized{SPG_fig48,48,A @dfn{Stream} in More Detail,4in}

Each procedure can pass messages directly to the adjacent queue in either direction of message flow.
This is normally performed with the @dfn{STREAMS} @manref{putnext(9)} utility.  For example, in
@figref{48}, procedures associated with queue @samp{Bd} can pass messages to queue @samp{Ad};
@samp{Bu} to @samp{Au}.

Also, procedures can easily locate the other queue in a queue pair and pass messages along the
opposite direction of flow.  This is normally performed using the @dfn{STREAMS} @manref{qreply(9)}
utility.  For example, in @figref{48}, procedures associated with queue @samp{Ad} can easily locate
queue @samp{Au} and pass messages to @samp{Bu} using @manpage{qreply(9)}.

Each queue in a module is associated with messages, processing procedures, and module private data.
Typically, each queue in the module has a distinct set of message, processing procedures and module
private data.

@table @dfn

@item Messages

Messages can be inserted into, and removed from, the linked list message queue associated with each
queue in the queue pair as they pass through the module.  For example, in @figref{48}, @samp{Message
Ad} exists on the @samp{Ad} queue; @samp{Message Bu}, on the @samp{Bu} queue.

@item Processing Procedures

Each queue in a @dfn{module} queue pair requires that a @command{put} procedure be defined for the
queue.  Upstream or downstream modules, drivers or the @dfn{Stream head} invoke a @command{put}
procedure of the module when they pass messages to the module along the @dfn{Stream}.

Each queue may optionally provide a @command{service} procedure that will be invoked when messages
are placed on the queue for later processing by the @command{service} procedure.  A
@command{service} procedure is never required if the module @command{put} procedure never enqueues a
message to either queue in the queue pair.

Either procedure in either queue in the pair can pass messages upstream or downstream and may alter
information within the module private data associated with either queue in the pair.

@item Data

Module processing procedures can make use of a pointer in each queue structure that is reserved for
use by the module writer to locate module private data structures.  These data structures are
typically attached to each queue from the module's  @command{open} procedure, and detached from then
module's @command{close} procedure.  Module private data is useful for maintaining state information
associated with the instance of the module and for passing information between procedures.

@end table

Modules are described in greater detail in @ref{Modules}.

@c ----------------------------------------
@node Driver Component
@subsection Drivers

This subsection provides a brief overview of @dfn{STREAMS drivers}.

The @dfn{Device} component of the @dfn{Stream} is an inital part of the regular @dfn{Stream}
(positioned just below the @dfn{Stream head}).  Most @dfn{Streams} start out life as a @dfn{Stream
head} connected to a @dfn{driver}.  The driver is positioned within the @dfn{Stream} at the
@dfn{Stream end}.  Note that not all @dfn{Streams} require the presence of a driver: a
@dfn{STREAMS}-based pipe or FIFO @dfn{Stream} do not contain a driver component.

A @dfn{driver} instance represented by a queue pair within the @dfn{Stream}, just as for modules.
Also, each queue in the queue pair has a message queue, processing procedures, and private data
associated with it in the same way as for @dfn{STREAMS} modules.  There are three differences that
distinguish drivers from modules:

@enumerate

@item Drivers are responsible for generating and consuming messages at the @dfn{Stream end}.

Drivers convert @dfn{STREAMS} messages into appropriate software or hardware actions, events and
data transfer.  As a result, drivers that are associated with a hardware device normally contain an
interrupt service procedure that handles the external device specific actions, events and data
transfer.  Messages are typically consumed at the @dfn{Stream end} in the driver's downstream
@command{put} or @command{service} procedure and action take or data transferred to the hardware
device.  Messages are typically generated at the @dfn{Stream end} in the driver's interrupt service
procedure, and inserted upstream using the @manref{put(9)} @dfn{STREAMS} utility.

Software drivers (so-called @dfn{pseudo-device drivers}) are similar to a hardware device driver
with the exception that they typically do not contain an interrupt service routine.  Pseudo-device
drivers are still repsonsible for consuing messages at the @dfn{Stream end} and converting them into
actions and data output (external to @dfn{STREAMS}), as well as generating messages in response to
events and data input (external to @dfn{STREAMS}).

In constrast, @dfn{modules} are intended to operate solely within the @dfn{STREAMS} framework.

@item  Because a driver sits at a @dfn{Stream} end and can support multiplexing, a driver can have
multiple @dfn{Streams} connected to it, either upstream (fan-in) or downstream (fan-out)
(@pxref{Multiplexing of Streams}).

In contrast, an instance of a @dfn{module} is only connected within a single @dfn{Stream} and does
not support multiplexing at the module queue pair.

@item An instance of a driver (queue pair) is created and destroyed using the @manpage{open(2)} and
@manpage{close(2)} system calls.

In constrast, an instance of a @dfn{module} (queue pair) is created and destroyed using the
@streamio{I_PUSH} and @streamio{I_POP} @dfn{STREAMS} @manpage{ioctl(2)} commands.

@end enumerate

Aside from these differences, the @dfn{STREAMS} @dfn{driver} is similar in most respects to the
@dfn{STREAMS} @dfn{module}.  Both drivers and modules can pass signals, error codes, return values,
and other information to processes in adjacent queue pairs using @dfn{STREAMS} messages of various
message types provided for that purpose.

Drivers are described in greater detail in @ref{Drivers}.

@c ----------------------------------------
@node Stream Head Component
@subsection Stream Head

This subsection provide a brief overview of @dfn{Stream heads}.

The @dfn{Stream head} is the first component of a @dfn{Stream} that is allocated when a @dfn{Stream}
is created.  All @dfn{Streams} have an associated @dfn{Stream head}.

In the case of @dfn{STREAMS}-based pipes, two @dfn{Stream heads} are associated with each other.
@dfn{STREAMS}-based FIFOs have one @dfn{Stream head} but no @dfn{Stream end} or @dfn{Driver}.
For all other @dfn{Streams}, as illustrated in @figref{48}, there exists a @dfn{Stream head} and a
@dfn{Stream end} or @dfn{Driver}.

The @dfn{Stream head} has a queue pair associated with them, just as does any other @dfn{STREAMS}
module or driver.  Also, just as any other module, the @dfn{Stream head} provides the processing
procedures and private data for processing of messages passed to queues in the pair.

The differences is that the processing procedures are provided by the @dfn{GNU/Linux} system rather
than being written by the @dfn{module} or @dfn{driver} writer.  These system provided processing
procedures perform the necessary functions to convert generate to and consume messages from the
@dfn{Stream} in response to system calls invoked by a user process.  Also, a set of specialized
behaviours are provided and a set of specialized message types that may be exchanged with modules
and drivers in the @dfn{Stream} to provide the standard interface expected by the user application.

@dfn{Stream heads} are described in greater detail in @ref{Mechanism}, @ref{Polling}, @ref{Pipes and
FIFOs}, and @ref{Terminal Subsystem}.

@c ----------------------------------------------------------------------------
@node Multiplexing of Streams
@section Multiplexing

This subsection provides a brief overview of @dfn{Stream Multiplexing}.

Basic @dfn{Streams} that can be created with the @manpage{open(2)} or @manpage{pipe(2)} system calls
are linear arrangements from @dfn{Stream head} to @dfn{Driver} or @dfn{Stream head} to @dfn{Stream
haed}.  Althoug these linear arrangements satisfy the needs of a large class of @dfn{STREAMS}
applications, there exits a class of application that are more naturally represented by
multiplexing: that is, an arrangements where one or more upper @dfn{Streams} feed into one or more
lower @dfn{Streams}.  Network protocol stacks (a significant application are for @dfn{STREAMS}) are
typically more easily represented by multiplexed arrangements.

A @dfn{fan-in} multiplexing arrangement is one in which multiple upper @dfn{Streams} feed into a
single lower @dfn{Stream} in a @dfn{many-to-one} relationship as illustrated in @figref{49}.

@figuresized{SPG_fig49,49,Many-to-one Multiplexor,1.4in}

A @dfn{fan-out} multiplexing arrangement is one in which a single upper @dfn{Stream} feeds into
multiple lower @dfn{Streams} in a @dfn{one-to-many} relationship as illustrated in @figref{50}.
(This is the more typically arrangement for communications protocol stacks.)

@figuresized{SPG_fig50,50,One-to-many Multiplexor,1.4in}

A @dfn{fan-in/fan-out} multiplexing arrangement is one in which multiple upper @dfn{Streams} feed
into mutliple lower @dfn{Streams} in a @dfn{many-to-many} relationship as illustrated in
@figref{51}.

@figuresized{SPG_fig51,51,Many-to-many Multiplexor,1.4in}

To support these arrangements, @dfn{STREAMS} provide a mechanism that can be used to assemble
multiplexing arrangements in a flexible way.  An, otherwise normal, @dfn{STREAMS} pseudo-device
driver can be specified to be a multiplexing driver.

Conceptually, a multiplexing driver can perform @dfn{upper multiplexing} between multiple
@dfn{Streams} on its @dfn{upper} side connecting the user process and the multiplexing driver, and
@dfn{lower multiplexing} between multiple @dfn{Streams} on its @dfn{lower} side connecting the
multiplexing driver and the device driver.

As with normal @dfn{STREAMS} drivers, @dfn{multiplexing drivers} can have multiple @dfn{Streams}
created on its @dfn{upper} side using the @manpage{open(2)} system call.  Unlike regular
@dfn{STREAMS} drivers, however, @dfn{multiplexing drivers} have the additional capability that other
@dfn{Streams} can be linked to the @dfn{lower} side of the driver.  The linkage is performed by
issuing specialized @manpage{streamio(7)} commands to to the driver that are recognized by
multiplexing drivers (@streamio{I_LINK}, @streamio{I_PLINK}, @streamio{I_UNLINK},
@streamio{I_PUNLINK}).

Any @dfn{Stream} can be linked under a multiplexing driver (provided that it is not already linked
under another multiplexing driver).  This includes an upper @dfn{Stream} of a multiplexing driver.
In this fashion, complex trees of multiplexing drivers and linear @dfn{Stream} segments containing
pushed @dfn{modules} can be assembled.  Using these linkage commands, complex arrangements can be
assembled, manipulated and dismantled by a user or daemon process to suit application needs.

The @dfn{fan-in} arrangement of @figref{49} performs @dfn{upper multiplexing}; the @dfn{fan-out}
arrangement of @figref{50}, @dfn{lower multiplexing}; and the @dfn{fan-in/fan-out} arrangement of
@figref{51}, both @dfn{upper} and @dfn{lower multiplexing}.

@subsection Fan-Out Multiplexers

@figref{47} illustrates an example, closely related to the @dfn{fan-out} arrangement of @figref{50},
where the @cite{Internet Protocol (IP)} within a networking stack is implemented as a multiplexing
driver and independent @dfn{Streams} to three specific device drivers are linked beneath the
@cite{IP} multiplexing driver.

@figuresized{SPG_fig47,47,Internet Multiplexing @dfn{Stream},4in}

The @cite{IP} multiplexing driver is capable of routing messages to the lower @dfn{Streams} on the
basis of address and the subnet membership of each device driver.  Messages received from the lower
@dfn{Streams} can be discriminated an sent to the appropriate user process upper @dfn{Stream} (e.g.
on the basis of, say, protocol Id).  Each lower @dfn{Stream}, @samp{Module 1}, @samp{Module 2},
@samp{Driver 3}, presents the same service interface to the @cite{IP} multiplexing driver,
regardless of the specific hardware or lower level communications protocol supported by the driver.
For example, the lower @dfn{Streams} could all support the @cite{Data Link Provider Interface
(DLPI)}.

As depicted in @figref{47}, the @cite{IP} multiplexing driver could have additional multiplexing
drivers or modules above it.  Also, @samp{Driver 1}, @samp{Driver 2} or @samp{Driver 3} could
themselves be multiplexing drivers (or replaced by multiplexing drivers).  In general, multiplexing
drivers are independent in the sense that it is not necessary that a given multiplexing driver be
aware of other multiplexing drivers upstream of its upper @dfn{Stream}, nor downstream of its lower
@dfn{Streams}.

@subsection Fan-In Multiplexers

@figref{52} illustrates an example, more closely related to the @dfn{fan-in} arrangement of
@figref{49}, where an @cite{X.25 Packet Layer Protocol} multiplexing driver is used to switch
messages between upper @dfn{Streams} supporting @cite{Permanent Virtual Circuits (PVCs)} or
@cite{Switch Virtual Circuits (SVCs)} and (possibly) a single lower @dfn{Stream}.

@figuresized{SPG_fig52,52,Multiplexing @dfn{Stream},3in}

The ability to multiplex upper @dfn{Streams} to a driver is a characteristic supported by all
@dfn{STREAMS} drivers: not just @dfn{multiplexing drivers}.  Each @manpage{open(2)} to a minor
device node results in another uppper @dfn{Stream} that can be associated with the device driver.
What the @dfn{multiplexing driver} permits over the normal @dfn{STREAMS} driver is the ability to
link one or more lower @dfn{Streams} (possibly containing modules and another multiplexing driver)
beneath it.

@subsection Complex Multiplexers

When constructing multiplexers for applications, even more complicated arrangements are possible.
Multiplexing over multiple @dfn{Streams} on both the upper and lower side of a @dfn{multiplexing
driver} is possible.  Also, a driver the provides lower multiplexing can be linked beneath a driver
that provide upper multiplexing as depicted by the dashed box in @figref{52}.  Each multiplexing
driver can perform @dfn{upper} multiplexing, @dfn{lower} multiplexing, or both, providing a
flexibility for the designer.

@dfn{STREAMS} provides multiplexing as a general purpose facility that is flexible in that
multiplexing drivers can be stacked and linked in a wide array of complex configurations.
@dfn{STREAMS} imposes few restrictions on processing within the multiplexing driver making the
mechanism applicable to a many classes of applications.

Multiplexing is described in greater detail in @ref{Multiplexing}.

@c ----------------------------------------------------------------------------
@node Benefits of STREAMS
@section Benefits of STREAMS
@menu
* Standardized Service Interfaces::
* Manipulating Modules::
@end menu

@dfn{STREAMS} provides a flexible, scalable, portable, and resuable kernel and user level facility
for the development of @cite{GNU/Linux} system communications services.  @dfn{STREAMS} allows the
creation of kernel resident modules that offer standard message passing facilities and the ability
for user level processes to manipulate and configure those modules into complex topologies.
@dfn{STREAMS} offers a standard way for user level processes to select and interconnect
@dfn{STREAMS} modules and drivers in a wide array of combinations without the need to alter
@cite{Linux} kernel code, recompile or relink the kernel.

@dfn{STREAMS} also assists in simplifying the user interface to device drivers and protocol stacks
by providing powerful system calls for the passing of control information from user to driver.
With @dfn{STREAMS} it is possible to directly implement asynchronous primitive-based service
interfaces to protocol modules.

@c ----------------------------------------
@node Standardized Service Interfaces
@subsection Standardized Service Interfaces

Many modern communications protocols define a service primitive interface between a service user and
a service provider.  Examples include the @cite{ISO Open Systems Interconnect (OSI)} and protocols
based on @dfn{OSI} such as @cite{Signalling System Number 7 (SS7)}.  Protocols based on @cite{OSI}
can be directly implemented using @dfn{STREAMS}.

In contrast to other approaches, such as @dfn{BSD Sockets}, @dfn{STREAMS} does not impose a
structured function call interface on the interaction between a user level process or kernel
resident protocol module.  Instead, @dfn{STREAMS} permits the service interface between a service
user and service provider (whether the service user is a user level process or kernel resident
@dfn{STREAMS} module) to be defined in terms of @dfn{STREAMS} messages that represent standardized
service primitives across the interface.

A service interface is defined@footnote{See ITU-T Recommendation X.200 and ITU-T Recommendation
X.210 for more information about service primitive interfaces.} at the boundary between neighbouring
modules.  The upper module at the boundary is termed the @dfn{service user} and the lower module at
the boundary is termed the @dfn{service provider}.  Implemented under @dfn{STREAMS}, a service
interface is a specified set of messages and the rules that allow passage of these messages across
the boundary.  A @dfn{STREAMS} module or driver that implements a service interface will exchange
messages within the defined set across the boundary and will respond to received messages in
accordance with the actions defined for the specific message and the sequence of messages preceding
receipt of the message (i.e., in accordance with the state of the module).

Instances of protocol stacks are formed using @dfn{STREAMS} facilities for pushing modules and
linking multiplexers.  For proper and consistent operation, protocol stacks are assembled so that
each neighboring module, driver and multiplexer implement the same service interface.  For example,
a module that implements the @cite{SS7 MTP} protocol layer, as shown in @figref{53}, presents a
protocol service interface at it input and output sides.  Other modules, drivers and multiplexers
should only be connected at the input and output sides of the @cite{SS7 MTP} protocol module if they
provide the same interface in the symetric role (i.e., user or provider).

It is the ability of @dfn{STREAMS} to implement service primitive interfaces between protocol
modules that makes it most appropriate for implementation of protocols based on the @cite{OSI}
service primitie interface such as @cite{X.25}, @cite{Integrated Services Digital Network (ISDN)},
@cite{Signalling System No. 7 (SS7)}.

@c ----------------------------------------
@node Manipulating Modules
@subsection Manipulating Modules
@menu
* Protocol Portability::
* Protocol Substitution::
* Protocol Migration::
* Module Reusability::
@end menu

@dfn{STREAMS} provides the ability to manipulate the configuration of drivers, modules and
multiplexers from user space, easing configuration of protocol stacks and profiles.  Modules,
drivers and multiplexers implementing common service interfaces can be substituted with ease.  User
level processes may access the protocol stack at various levels using the same set of standard
system calls, while also permitting the service interface to the user process to match that of the
topmost module.

It is this flexibility that makes @dfn{STREAMS} well suited to the implementation of communications
protocols based on the @dfn{OSI} service primitive interface model.  Additional benefits for
communications protocols include:

@itemize @bullet
@item User level programs use a service interface that is independent of underlying protocols,
drivers, device implementation, and physical communications media.

@item Communications architecture and upper layer protocols can be independent of underlying
protocol, drivers, device implementation, and physical communications media.

@item Communications protocol profiles can be created by selecting and connection constituent lower
layer protocols and services.
@end itemize

The benfits of the @dfn{STREAMS} approach are protocol portability, protocol substitution, protocol
migration, and module reusability.  Examples provided in the sections that follow are real-world
examples taken from the open source @cite{Signalling System No. 7 (SS7)} stack implemented by the
@uref{http://www.openss7.org/,OpenSS7 Project}.

@node Protocol Portability
@subsubsection Protocol Portability

@figuresized{SPG_fig53,53,Protocol Module Portability,3in}

@figref{53}, shows how the same @cite{SS7 Signalling Link} protocol module can be used with
different drivers on different machines by implementing compatible service interfaces.  The
@cite{SS7 Signalling Link} are the @dfn{Data Link Provider Interface (DLPI)} and the
@dfn{Communications Device Interface (CDI)} for @dfn{High-Level Data Link Control (HDLC)}.

By using standard @dfn{STREAMS} mechanisms for the implementation of the @cite{SS7 Signalling Link}
module, only the driver needs to be ported to port an entire protocol stack from one machine to
another.  The same @cite{SS7 Signalling Link} module (and upper layer modules) can be used on both
machines.

Because the @dfn{Driver} presents a standardized service interface using @dfn{STREAMS}, porting a
driver from the machine architecture of @samp{Machine A} to that of @samp{Machine B} consists of
changes internal to the driver and external to the @dfn{STREAMS} environment.  Machine dependent
issues, such as bus architectures and interrupt handling are kept independent of the primary state
machine and service interface.  Porting a driver from one major @cite{UNIX} or @cite{UNIX}-like
operating system and machine architecture supporting @dfn{STREAMS} to another is a straightforward
task.

With @cite{@value{PACKAGE_TITLE}}, @dfn{STREAMS} provides the ability to directly port a large body
of existing @dfn{STREAMS} modules to the @cite{GNU/Linux} operating system.

@node Protocol Substitution
@subsubsection Protocol Substitution

@figuresized{SPG_fig56,300,Protocol Substitution,3in}

@dfn{STREAMS} permits the easy substitution of protocol modules (or devic drivers) within a protocol
stack providing a new protocol profile.  When protocol modules are implemented to a compatible
service interface the can be recombined and substituted, providing a flexible protocol architecture.
In some circumstances, and through proper design, protocol modules can be substituted that implement
the same service interface, even if they were not originally intended to be combined in such a
fashion.

@figref{300} illustrates how @dfn{STREAMS} can substitute upper layer protocol modules to implement
a different protocol stack over the same @dfn{HDLC} driver.  As each module and driver support the
same service interface at each level, it is conceivable that the resulting modules could be
recombined to support, for example, @cite{SS7 MTP} over an @cite{ISDN LAPB} channel.@footnote{SS7
MTP over ISDN LAPB was originally defined under ISDN as an E-Channel.}

Another example would be substituting an @cite{M2PA} signalling link module for a traditional
@cite{SS7 Signalling Link Module} to provide @cite{SS7 over IP}.

@node Protocol Migration
@subsubsection Protocol Migration

@figref{54} illustrates how @dfn{STREAMS} can move functions between kernel software and front end
firmware.  A common downstream service interface allows the transport protocol module to be
independent of the number or type of modules below.  The same transport module will connect without
modification to either an @cite{SS7 Signalling Link} module or @cite{SS7 Signalling Link} driver
that presents the same service interface.

@figuresized{SPG_fig54,54,Protocol Migration,3in}

The @uref{http://www.openss7.org/,OpenSS7} @cite{SS7 Stack} uses this capability also to adapt the
protocol stack to front-end hardware that supports differing degrees of @cite{SS7 Signalling Link}
support  in firmware.  Hardware cards that support as much as a transparent bit stream can have
@cite{SS7 Signalling Data Link}, @cite{SS7 Signalling Data Terminal} and @cite{SS7 Signalling Link}
modules pushed to provide a complete @cite{SS7 Signalling Link} that might, on another hardware
card, be mostly implemented in firmware.

By shifting functions between software and firmware, developers can produce cost effective,
functionally equivalent systems over a wide range of configurations.  They can rapidly incorporate
technological advances.  The same upper layer protocol module can be used on a lower capacity
machine, where economics may preclude the use of front-end hardware, and also on a larger scale
system where a front-end is economically justified.

@node Module Reusability
@subsubsection Module Reusability

@figref{55} shows the same canonical module (for example, one that provides
delete and kill processing on character strings) reused in two different @dfn{Streams}.  This module
would typically be implemented as a filter, with no downstream service interface.  In both cases, a
tty interface is presented to the @dfn{Stream}'s user process since the module is nearest the
@dfn{Stream head}.

@figuresized{SPG_fig55,55,Module Reusability,3in}

@c ============================================================================
@node Overview
@chapter Overview
@menu
* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems
@end menu

@node Definitions
@section Definitions

@node Concepts
@section Concepts

@node Application Interface
@section Application Interface

@node Kernel Level Facilities
@section Kernel Level Facilities

@node Subsystems
@section Subsystems

@c ============================================================================
@node Mechanism
@chapter Mechanism
@menu
* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction
@end menu

This chapter describes how applications programs create and interact with a @dfn{Stream} using
traditional and standardized @dfn{STREAMS} system calls.  General system call and
@dfn{STREAMS}-specific system calls provide the interface required by user level processes when
implementing user level applications programs.

@node Mechanism Overview
@section Mechanism Overview

The system call interface provided by @dfn{STREAMS} is upward compatible with the traditional
character device system calls.

@dfn{STREAMS} devices appears as character device nodes within the file system in the
@dfn{GNU/Linux} system.
The @manref{open(2)} system call recognizes that a character special file is a @dfn{STREAMS} device,
creates a @dfn{Stream} and associates it with a device in the same fashion as a character device.

Once open, a user process can send and receive data to and from the @dfn{STREAMS} special file using
the traditional @manref{write(2)} and @manref{read(2)} system calls in the same manner as is
performed on a traditional character device special file.

Character device input-output controls using the @manref{ioctl(2)} system call can also be performed
on a @dfn{STREAMS} s[ecial file.  @dfn{STREAMS} defines a set of standard input-output control
commands (see @manref{ioctl(2p)} and @manref{streamio(7)}) specific to @dfn{STREAMS} special files.
Input-output controls that a defined for a specific device are also supported as they are for
character device drivers.

With support for these general character device input and output system calls, it is possible to
implement a @dfn{STREAMS} device driver in such a way that an application is unaware that it has
opened and is controling a @dfn{STREAMS} device driver: tne application could treat the device in
the identical manner to a character device.  This make it possible to convert an existing character
device driver to @dfn{STREAMS} and make possible the portability, migration, substitution and
reusability benefits of the @dfn{STREAMS} framework.

@dfn{STREAMS} provides @dfn{STREAMS}-specific system calls and @manpage{ioctl(2)} commands, in
addition to support for the traditional character device I/O system calls and @manpage{ioctl(2)}
commands.

The @manref{poll(2)} system call@footnote{Although the @manpage{poll(2)} system call has been
implemented in @cite{GNU/Linux}, it was historically provided only by @dfn{STREAMS}.  This is
evident from the fact that @manpage{poll(2)} system can supports events like @constant{POLLRDBAND}
that have no meaning outside of the @dfn{STREAMS} framework.} provides the ability for the
application to poll multiple @dfn{Streams} for a wide range of events.

The @manref{putmsg(2)} and @manref{putpmsg(2)} system calls provide the ability for applications
programs to transfer both control and data information to the @dfn{Stream}.  The @manpage{write(2)}
system call only supports the transfer of data to the @dfn{Stream}, whereas, @manpage{putmsg(2)} and
@manpage{putpmsg(2)} permit the transfer of prioritized control information in addition to data.

The @manref{getmsg(2)} and @manref{getpmsg(2)} system calls provide the ability for applications
programs to receive both control and data information from the @dfn{Stream}.  The @manpage{read(2)}
system call can only support the transfer of data (and in some cases the inline control
information), whereas, @manpage{getmsg(2)} and @manpage{getpmsg(2)} permit the transfer of
prioritized control information in addition to data.

Implementation of standardized service primitive interfaces is enabled through the use of the
@manpage{putmsg(2)}, @manpage{putpmsg(2)}, @manpage{getmsg(2)} and @manpage{getpmsg(2)} system
calls.

@dfn{STREAMS} also provides kernel level utilities and facilities for the development of kernel
resident @dfn{STREAMS} modules and drivers.  Within the @dfn{STREAMS} framework, the @dfn{Stream
head} is responsible for conversion between @dfn{STREAMS} messages passed up and down a @dfn{Stream}
and the system call interface presented to user level applications programs.  The @dfn{Stream head}
is common to all @dfn{STREAMS} special files and the conversion between the system call interface
and message passed on the @dfn{Stream} does not have to be reimplemented by the module and device
driver writer as is the case for traditional character device I/O.

@subsection STREAMS System Calls

The @dfn{STREAMS}-related system calls are:

@multitable @columnfractions .20 .80
@item @manpage{open(2)}
@tab Open a @dfn{STREAMS} special file and create a @dfn{Stream}.
@item @manpage{close(2)}
@tab Close a @dfn{STREAMS} special file and possibly cause the destruction of a @dfn{Stream} (i.e.,
on the last close of the @dfn{Stream}.
@item @manpage{read(2)}
@tab Read data from a @dfn{Stream}.
@item @manpage{write(2)}
@tab Write data to a @dfn{Stream}.
@item @manpage{ioctl(2)}
@tab Control a @dfn{Stream}.
@item @manpage{getmsg(2)}, @manpage{getpmsg(2)}
@tab Receive a (prioritized) message at the @dfn{Stream head}.
@item @manpage{putmsg(2)}, @manpage{putpmsg(2)}
@tab Send a (prioritized) message from the @dfn{Stream head}.
@item @manpage{poll(2)}
@tab Notify the application program when selected events occur on one or more @dfn{Streams}.
@item @manpage{pipe(2)}
@tab Create a channel that provides a @dfn{STREAMS}-based bidirectional communication path between
multiple processes.
@end multitable

@node Stream Construction
@section Stream Construction

@dfn{STREAMS} constructs a @dfn{Stream} as a double linked list of kernel data structures.  Elements
of the linked list are queue pairs that represent the instantiation of a @dfn{Stream head}, modules
and drivers.  Linear segments of linke queue pairs can be connected to multiplexing drivers to form
complex tree topologies.  The branches of the tree are closest to the user level process and the
roots of the tree are closest to the device driver.

The uppermost queue pair of a @dfn{Stream} represents the @dfn{Stream head}.  The lowermost queue
pair of a @dfn{Stream} represents the @dfn{Stream end} or @dfn{driver}.  

@c ============================================================================
@node Processing
@chapter Processing
@menu
* Procedures::			STREAMS Put and Service Procedures
* Asynchronous Example::	STREAMS Asynchronous Stream Example
@end menu

@node Procedures
@section Procedures

@node Asynchronous Example
@section Asynchronous Example

@c ============================================================================
@node Messages
@chapter Messages
@menu
* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers
@end menu


@node Messages Overview
@section Messages Overview

@node Message Structure
@section Message Structure

@node Queues and Priority
@section Queues and Priority

@node Service Interfaces
@section Service Interfaces

@node Message Allocation
@section Message Allocation

@node Extended Buffers
@section Extended Buffers

@c ============================================================================
@node Polling
@chapter Polling
@menu
* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal
@end menu


@node Input and Output Polling
@section Input and Output Polling

@node Controlling Terminal
@section Controlling Terminal

@c ============================================================================
@node Modules and Drivers
@chapter Modules and Drivers
@menu
* Environment::			STREAMS Module and Driver Environment
* Input-Output Control::	STREAMS Input and Output Control
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines
@end menu


@node Environment
@section Environment

@node Input-Output Control
@section Input-Output Control

@node Flush Handling
@section Flush Handling

@node Driver-Kernel Interface
@section Driver-Kernel Interface

@node Design Guidelines
@section Design Guidelines

@c ============================================================================
@node Modules
@chapter Modules
@menu
* Module::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines
@end menu


@node Module
@section Module

@node Module Flow Control
@section Module Flow Control

@node Module Design Guidelines
@section Module Design Guidelines

@c ============================================================================
@node Drivers
@chapter Drivers
@menu
* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* spec File System::		Avoiding Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering
* Driver::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines
@end menu


@node External Device Numbers
@section External Device Numbers

@node Internal Device Numbers
@section Internal Device Numbers

@node spec File System
@section spec File System

@node Clone Device
@section Clone Device

@node Named STREAMS Device
@section Named STREAMS Device

@node Driver
@section Driver

@node Cloning
@section Cloning

@node Loop-Around Driver
@section Loop-Around Driver

@node Driver Design Guidelines
@section Driver Design Guidelines

@c ============================================================================
@node Multiplexing
@chapter Multiplexing
@menu
* Multiplexors::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexor Connect and Disconnect Lower Stream
* Multiplexor Construction Example::
				STREAMS Multiplexor Construction Example
* Multiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexor Persistent Links
* Multiplexing Driver Design Guidelines::
				STREAMS Multiplexing Driver Design Guidelines
@end menu


@node Multiplexors
@section Multiplexors

@node Connecting and Disconnecting Lower Stream
@section Connecting and Disconnecting Lower Stream

@node Multiplexor Construction Example
@section Multiplexor Construction Example

@node Multiplexing Driver
@section Multiplexing Driver

@node Persistent Links
@section Persistent Links

@node Multiplexing Driver Design Guidelines
@section Multiplexing Driver Design Guidelines

@c ============================================================================
@node Pipes and FIFOs
@chapter Pipes and FIFOs
@menu
* STREAMS Pipes and FIFOs::	STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs
@end menu


@node STREAMS Pipes and FIFOs
@section Pipes and FIFOs

@node Flushing Pipes and FIFOs
@section Flushing Pipes and FIFOs

@node Named Streams
@section Named Streams

@node Unique Connections
@section Unique Connections

@c ============================================================================
@node Terminal Subsystem
@chapter Terminal Subsystem
@menu
* STREAMS Terminal Subsystem::	STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem
@end menu


@node STREAMS Terminal Subsystem
@section Terminal Subsystem

@node Pseudo-Terminal Subsystem
@section Pseudo-Terminal Subsystem

@c ============================================================================
@node Synchronization
@chapter Synchronization
@menu
* MT Configuration::		MP STREAMS MT Configuration
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks
* STREAMS Framework Integrity::
* MP Message Ordering::
* MP-UNSAFE Modules::
* MP Put and Service Procedures::
* MP Timeout and Buffer Callbacks::
* MP Open and Close Procedures::
* MP Module Unloading::
* MP Locking::
* MP Asynchronous Callbacks::
* Stream Integrity::
@end menu


@node MT Configuration
@section MT Configuration

@node Asynchronous Entry Points
@section Asynchronous Entry Points

@node Asynchronous Callbacks
@section Asynchronous Callbacks

@node Synchronous Entry Points
@section Synchronous Entry Points

@node Synchronous Callbacks
@section Synchronous Callbacks

@node STREAMS Framework Integrity
@section STREAMS Framework Integrity

@node MP Message Ordering
@section MP Message Ordering

@node MP-UNSAFE Modules
@section MP-UNSAFE Modules

@node MP Put and Service Procedures
@section MP Put and Service Procedures

@node MP Timeout and Buffer Callbacks
@section MP Timeout and Buffer Callbacks

@node MP Open and Close Procedures
@section MP Open and Close Procedures

@node MP Module Unloading
@section MP Module Unloading

@node MP Locking
@section MP Locking

@node MP Asynchronous Callbacks
@section MP Asynchronous Callbacks

@node Stream Integrity
@section Stream Integrity

@c ============================================================================
@node Reference
@chapter Reference
@menu
* Files::			STREAMS Files
* System Modules::		STREAMS Modules
* System Drivers::		STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions
@end menu


@node Files
@section Files

@node System Modules
@section System Modules

@node System Drivers
@section System Drivers

@node System Calls
@section System Calls

@node Input-Output Controls
@section Input-Output Controls

@node Module Entry Points
@section Module Entry Points

@node Structures
@section Structures

@node Registration
@section Registration

@node Message Handling
@section Message Handling

@node Queue Handling
@section Queue Handling

@node Miscellaneous Functions
@section Miscellaneous Functions

@node Extensions
@section Extensions

@node Compatibility
@section Compatibility

@c ============================================================================
@node Conformance
@chapter Conformance
@menu
* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX Compatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
* LiS Compatibility::		LiS 2.18.1 Compatibility
@end menu


@node SVR 4.2 Compatibility
@section SVR 4.2 Compatibility

@node AIX Compatibility
@section AIX Compatibility

@node HP-UX Compatibility
@section HP-UX Compatibility

@node OSF/1 Compatibility
@section OSF/1 Compatibility

@node UnixWare Compatibility
@section UnixWare Compatibility

@node Solaris Compatibility
@section Solaris Compatibility

@node SUX Compatibility
@section SUX Compatibility

@node UXP Compatibility
@section UXP Compatibility

@node LiS Compatibility
@section LiS Compatibility

@c ============================================================================
@node Portability
@chapter Portability
@menu
* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* LiS Portability::		Porting from LiS 2.18.1
@end menu


@node Core Function Support
@section Core Function Support

@node SVR 4.2 Portability
@section SVR 4.2 Portability

@node AIX Portability
@section AIX Portability

@node HP-UX Portability
@section HP-UX Portability

@node OSF/1 Portability
@section OSF/1 Portability

@node UnixWare Portability
@section UnixWare Portability

@node Solaris Portability
@section Solaris Portability

@node SUX Portability
@section SUX Portability

@node UXP Portability
@section UXP Portability

@node LiS Portability
@section LiS Portability

@c ============================================================================
@node Data Structures
@appendix Data Structures
@menu
* Stream Structures::
* Queue Structures::
* Message Structures::
* Input Output Control Structures::
* Link Structures::
* Options Structures::
@end menu


@node Stream Structures
@section Stream Structures

@node Queue Structures
@section Queue Structures

@node Message Structures
@section Message Structures

@node Input Output Control Structures
@section Input Output Control Structures

@node Link Structures
@section Link Structures

@node Options Structures
@section Options Structures

@c ============================================================================
@node Message Types
@appendix Message Types
@menu
* Message Type::
* Ordinary Messages::
* High Priority Messages::
@end menu


@node Message Type
@section Message Type

@node Ordinary Messages
@section Ordinary Messages

@node High Priority Messages
@section High Priority Messages

@c ============================================================================
@node Utilities
@appendix Utilities
@menu
@end menu

@c ============================================================================
@node Debugging
@appendix Debugging
@menu
@end menu

@c ============================================================================
@node Configuration
@appendix Configuration
@menu
@end menu

@c ============================================================================
@node Administration
@appendix Administration
@menu
* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System
@end menu


@node Administrative Utilities
@section Administrative Utilities

@node System Controls
@section System Controls

@node /proc File System
@section /proc File System

@c ============================================================================
@node Examples
@appendix Examples
@menu
* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example
@end menu


@node Module Example
@section Module Example

@node Driver Example
@section Driver Example

@c ============================================================================
@node Copying
@appendix Copying
@menu
* GNU General Public License::		GPL
* GNU Free Documentation License::	FDL
@end menu

@include texi/gpl.texi

@include texi/fdl.texi

@c ============================================================================
@node Glossary
@unnumbered Glossary

@multitable @columnfractions .30 .70

@item @dfn{anchor} @tab
@cindex anchor
A @dfn{STREAMS} locking mechanism that prevents the removal of @dfn{STREAMS} modules with the
@streamio{I_POP} @command{ioctl}.  Anchors are placed on @dfn{STREAMS} modules by adding the
@samp{[anchor]} flag to @manref{autopush(8)} configuration files or directly with the
@streamio{I_ANCHOR} @command{ioctl}.

@item @dfn{autopush} @tab
@cindex autopush
A @dfn{STREAMS} mechanism that enables a pre-specified list of modules to be pushed automatically
onto a @dfn{Stream} when a @dfn{STREAMS} device is opened.  This mechanism is used only for
administrative purposes.

@item @dfn{back-enable} @tab
@cindex back-enable
To enable (by @dfn{STREAMS}) a preceding blocked queue's @command{service} procedure when
@dfn{STREAMS} determines that a succeeding queue has reached its low-water mark.

@item @dfn{blocked} @tab
@cindex blocked
A queue's @command{service} procedure that cannot be enabled due to flow control.

@item @dfn{clone device} @tab
@cindex clone device
A @dfn{STREAMS} device that returns an unused major/minor device number when initially opened,
rather than requiring the minor device to be specified by name in the @command{open} call.

@item @dfn{close procedure} @tab
@cindex close procedure
A routine that is called when a module is popped from a @dfn{Stream} or when a driver is closed.
A pointer to this procedure is specified in the @member{qi_qopen} member of the @mantype{queue(9)}
structure associated with the read side of the module's queue pair.

@item @dfn{control Stream} @tab
@cindex control Stream
A @dfn{Stream} above a multiplexing driver used to establish lower multiplexer connections.
Multiplexed @dfn{Stream} configurations are maintained through the controlling @dfn{Stream} to a
multiplexing driver.

@item @dfn{Device Driver Interface} @tab
@cindex Device Driver Interface
An interface that facilitates driver portability across different @cite{UNIX} system versions.

@item @dfn{device driver} @tab
@cindex device driver
A @dfn{Stream} component whose principle functions are handling an associated physical device and
transforming data and information between the external interface and the @dfn{Stream}.

@item @dfn{Driver Kernel Interface} @tab
@cindex Driver Kernel Interface
An interface between the @cite{UNIX} system kernel and different types of drivers.  It consists of a
set of driver defined functions that are called by the kernel.  These functions are entry points
into a driver.

@item @dfn{downstream} @tab
@cindex downstream
A direction of data flow going from the @dfn{Stream head} toward a driver.  Also called the
@dfn{write-side} and @dfn{output-side}.

@item @dfn{driver} @tab
@cindex driver
A module that forms the @dfn{Stream end}.  It can be a device driver or a pseudo-device driver.  It
is a required component in @dfn{STREAMS} (except in @dfn{STREAMS}-based pipes and FIFOs), and is
physically identical to a module.  It typically handles data transfer between the kernel and a
device and does little or no processing of data.

@item @dfn{enable} @tab
@cindex enable
A term used to describe scheduling of a queue's @command{service} procedure.

@item @dfn{FIFO} @tab
@cindex FIFO
@dfn{First In, First Out}.  A term used in @dfn{STREAMS} for named pipes.  This term is also used in
queue scheduling.

@item @dfn{flow control} @tab
@cindex flow control
A @dfn{STREAMS} mechanism that regulates the rate of message transfer within a @dfn{Strema} and from
user space into a @dfn{Stream}.

@item @dfn{hardware emulation module} @tab
@cindex hardware emulation module
A module required when the terminal line discipline is on a @dfn{Stream} but there is no terminal
driver at the @dfn{Stream end}.  This module recognizes all @manref{termio(7)} @command{ioctl}s
necessary to support terminal semantics specified by @mantype{termio(9)} and @mantype{termios(9)}.

@item @dfn{input side} @tab
@cindex input side
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{read-side} and @dfn{upstream}.

@item @dfn{line discipline} @tab
@cindex line discipline
A @dfn{STREAMS} module that performs @manref{termio(7)} canonical and non-canonical processing.  It
shares some @manref{termio(7)} processing with a driver in a @dfn{STREAMS} terminal subsystem.

@item @dfn{lower Stream} @tab
@cindex lower Stream
A @dfn{Stream} connected beneath a multiplexing pseudo-device driver, by means of an
@streamio{I_LINK} or @streamio{I_PLINK} @command{ioctl}.  The far end of a lower @dfn{Stream}
terminates at a device driver or another multiplexer driver.

@item @dfn{master driver} @tab
@cindex master driver
A @dfn{STREAMS}-based device supported by the pseudo-terminal subsystem.  It is the controlling part
of the pseudo-terminal subsystem (also called @samp{ptm}).

@item @dfn{message} @tab
@cindex message
One or more linked message blocks.  A message is referenced by its first message block and its type
is defined by the message type of that block.

@item @dfn{message block} @tab
@cindex message block
A triplet consisting of a data buffer and associated control structures, a @mantype{msgb(9)}
structure, a @mantype{datab(9)} structure.  It carries data or information, as identified by its
message type, in a @dfn{Stream}.

@item @dfn{message queue} @tab
@cindex message queue
A linked list of zero or more messages connected together.

@item @dfn{message type} @tab
@cindex message type
A enumerated set of values identifying the contents of a message.

@item @dfn{module} @tab
@cindex module
A defined set of kernel-level routines and data structure used to process data, status, and control
information on a @dfn{Stream}.  It is an optional element, but there can be many modules in one
@dfn{Stream}.  It consists of a pair of queues (read queue and write queue), and it communicates to
other components in a @dfn{Stream} by passing messages.

@item @dfn{multiplexer} @tab
@cindex multiplexer
A @dfn{STREAMS} mechanism that allows message to be routed among multiple @dfn{Streams} in the
kernel.  A multiplexing configuration includes at least one multiplexing pseudo-device driver
connected to one or more upper @dfn{Streams} and one or more lower @dfn{Streams}.

@item @dfn{named Stream} @tab
@cindex named Stream
A @dfn{Stream}, typically a pipe, with a name associated with it by way of a call to
@manref{fattach(3)} (that is, a @manref{mount(2)} operation).  This is different from a named pipe
(FIFO) in two ways: a named pipe (FIFO) is unidirectional while a named @dfn{Stream} is
bidirectional; a name @dfn{Stream} need not refer to a pipe, but can be another type of
@dfn{Stream}.

@item @dfn{open routine} @tab
@cindex open routine
A procedure in each @dfn{STREAMS} driver and module called by @dfn{STREAMS} on each @command{open}
system call made on the @dfn{Stream}.  A module's @command{open} procedure is also called when the
module is pushed.

@item @dfn{packet mode} @tab
@cindex packet mode
A feature supported by the @dfn{STREAMS}-based pseudo-terminal subsystem.  It is used to inform a
process on the master side when state changes occur on the slave side of a pseudo-TTY.  It is
enabled by pushing a module called @samp{pckt} on the master side.

@item @dfn{persistent link} @tab
@cindex persistent link
A connection below a multiplexer that can exist without having an open controlling @dfn{Stream}
associated with it.

@item @dfn{pipe} @tab
@cindex pipe
See @dfn{STREAMS}-based pipe.

@item @dfn{pop} @tab
@cindex pop
A term used when a module that is immediately below the @dfn{Stream} head is removed.

@item @dfn{pseudo-device driver} @tab
@cindex pseudo-device driver
A software driver, not directly associated with a physical device, that performs functions internal
to a @dfn{Stream} such as a multiplexer or @manref{log(4)} driver.

@item @dfn{pseudo-terminal subsystem} @tab
@cindex pseudo-terminal subsystem
A user interface identical to a terminal subsystem except that there is a process in place of a
hardware device.  It consists of at least a master device, slave device, line discipline module, and
hardware emulation module.

@item @dfn{push} @tab
@cindex push
A term used when a muodule is inserted in a @dfn{Stream} immediately below the @dfn{Stream head}.

@item @dfn{pushable module} @tab
@cindex pushable module
A module put between the @dfn{Stream head} and driver.  It performs intermediate transformations on
messages flowing between the @dfn{Stream head} and driver.  A driver is a non-pushable module.

@item @dfn{put procedure} @tab
@cindex put procedure
A routine in a module or driver associated with a queue that receives messages from the preceding
queue.  It is the single entry point into a queue from a preceding queue.  It may perform processing
on the message and will then generally either queue the message for subsequent processing by this
queue's @command{service} procedure, or will pass the message to the @command{put} procedure of the
following queue (using @manref{putnext(9)}).

@item @dfn{queue} @tab
@cindex queue
A data structure that contains status information, a pointer to routines processing message, and
pointers for administering a @dfn{Stream}.  It typically contains pointer to @command{put} and
@command{service} procedures, a message queue, and private data.

@item @dfn{read-side} @tab
@cindex read-side
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{upstream} and @dfn{input-side}.

@item @dfn{read queue} @tab
@cindex read queue
A message queue in a module or driver containing messages moving @dfn{upstream}.  Associated with
the @manref{read(2)} system call and input from a driver.

@item @dfn{remote mode} @tab
@cindex remote mode
A feature available with the pseudo-terminal subsystem.  It is used for applications that perform
the canonical and echoing functions normally done by line discipline module and TTY driver.  It
enables applications on the master side to turn off the canonical processing.

@item @dfn{STREAMS Administrative Driver} @tab
@cindex STREAMS Administrative Driver
A @dfn{STREAMS} Administrative Driver that provides an interface to the @manref{autopush(8)}
mechanism.

@item @dfn{schedule} @tab
@cindex schedule
To place a queue on the internal list of queues that will subsequently have their service procedure
called by the @dfn{STREAMS} scheduler.  @dfn{STREAMS} scheduling is independent of @cite{Linux}
process scheduling.

@item @dfn{service interface} @tab
@cindex service interface
A set of primitives that define a service at the boundary between a service user and a service
provider and the rules (typically represented by a state machine) for allowable sequences of the
primitives across the boundary.  At a @dfn{Stream}/user boundary, the primitives are typically
contained in the control part of a message; within a @dfn{Stream}, in @msg{M_PROTO} or
@msg{M_PCPROTO} message blocks.

@item @dfn{service procedure} @tab
@cindex service procedure
A module or driver routine associated with a queue that receives messages queue for it by the
@command{put} procedure is called by the @dfn{STREAMS} scheduler.  It may perform processing on the
message and generally passes the message to the @command{put} procedure of the following queue.

@item @dfn{service provider} @tab
@cindex service provider
An entity in a service interface that responds to request primitives from the service user with
response and event primitives.

@item @dfn{service user} @tab
@cindex service user
An entity in a service interface that generates request primitives for the service provider and
consumes response and event primitives.

@item @dfn{slave driver} @tab
@cindex slave driver
A @dfn{STREAMS}-based device supported by the pseudo-terminal subsystem.  It is also called
@samp{pts} and works with a line discipline module and hardware emulation module to provide an
interface to a user process.

@item @dfn{standard pipe} @tab
@cindex standard pipe
A mechanism for the unidirectional flow of data between two processes where data written by one
process becomes data read by the other process.

@item @dfn{Stream} @tab
@cindex Stream
A kernel level aggregate created by connecting @dfn{STREAMS} components, resulting from an
application of the @dfn{STREAMS} mechanism.  The primary components are the @dfn{Stream head}, the
driver (or @dfn{Stream end}), and zero or more pushable modules between the @dfn{Stream head} and
driver.

@item @dfn{STREAMS-based pipe} @tab
@cindex STREAMS-based pipe
A mechanism used for bidirectional data transfer implemented using @dfn{STREAMS}, and sharing the
properties of @dfn{STREAMS}-based devices.

@item @dfn{Stream end} @tab
@cindex Stream end
A @dfn{Stream} component furthest from the user process that contains a driver.

@item @dfn{Stream head} @tab
@cindex Stream head
A @dfn{Stream} component closest to the user process.  It provides the interface between the
@dfn{Stream} and the user process.

@item @dfn{STREAMS} @tab
@cindex STREAMS
A kernel mechanism that provides the framework for network services and data communication.  It
defines interface standards for character intput/output within the kernel, and between the kernel
and user level.  The @dfn{STREAMS} mechanism includes integral functions, utility routines, kernel
facilities, and a set of structures.

@item @dfn{TTY driver} @tab
@cindex TTY driver
A @dfn{STREAMS}-based device used in a terminal subsystem.

@item @dfn{upper stream} @tab
@cindex upper stream
A @dfn{Stream} that terminates above a multiplexing driver.  The beginning of an upper @dfn{Stream}
originates at the @dfn{Stream head} or another multiplexing driver.

@item @dfn{upstream} @tab
@cindex upstream
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{read-side} and @dfn{input side}.

@item @dfn{water mark} @tab
@cindex water mark
A limit value used in flow control.  Each queue has a high-water mark and a low-water mark.  The
high-water mark value indicates the upper limit related to the number of bytes contained on the
queue.  When the queued character reaches its high water mark, @dfn{STREAMS} causes another queue
that attempts to send a message to this queue to become blocked.  When the characters in this queue
are reduced to the low-water mark value, the other queue is unblocked by @dfn{STREAMS}.

@item @dfn{write queue} @tab
@cindex write queue
A message qeuue in a module or driver containing messages moving downstream.  Associated with the
@manref{write(2)} system call and output from a user process.

@item @dfn{write-side} @tab
@cindex write-side
A direction of data flow going from the @dfn{Stream head} toward a driver.  Also called downstream
and output side.

@end multitable

@c ============================================================================
@iftex
@node List of Figures
@unnumbered List of Figures

@listoffloats Figure
@end iftex

@c ============================================================================
@iftex
@node List of Listings
@unnumbered List of Listings

@listoffloats Listing
@end iftex

@c ============================================================================
@node Index
@unnumbered Index

@c @page
@c @node Indices
@c @unnumbered Indices
@c @menu
@c * Concept Index::		Index of Concepts
@c * Type Index::			Index of Data Types
@c * Function Index::		Index of Functions and Macros
@c * Variable Index::		Index of Variables and Constants
@c * File Index::			Index of Files and Programs
@c @end menu
@c 
@c @page
@c @node Concept Index
@c @unnumberedsec Concept Index
@printindex cp

@c @page
@c @node Type Index
@c @unnumberedsec Type Index
@c @printindex tp
@c 
@c @page
@c @node Function Index
@c @unnumberedsec Function and Macro Index
@c @printindex fn
@c 
@c @page
@c @node Variable Index
@c @unnumberedsec Variable and Constant Macro Index
@c @printindex vr
@c 
@c @page
@c @node File Index
@c @unnumberedsec Program and File Index
@c @printindex pg

@page
@shortcontents
@page
@contents
@bye

