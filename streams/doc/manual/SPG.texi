% -*- texinfo -*- vim: ft=texinfo noautoindent nocindent nosmartindent
% =========================================================================
%
% @(#) $Id: SPG.texi,v 0.9.2.29 2005/09/12 13:09:42 brian Exp $
%
% =========================================================================
%
% Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
% Copyright (C) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2005/09/12 13:09:42 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename SPG.info
@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide
@settitle @value{MANUAL_TITLE}

@dircategory STREAMS
@direntry
* SPG: (SPG).                   STREAMS Programmer's Guide
@end direntry

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}.

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@ignore
@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@end ignore
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2005  OpenSS7 Corporation <@uref{http://www.openss7.com/}> @*
Copyright @copyright{} 1997-2000  Brian F. G. Bidulock <@email{bidulock@@openss7.org}> @*
All Rights Reserved. @*

@noindent
Published by OpenSS7 Corporation @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
This is texinfo edition @value{PACKAGE_RELEASE} of the @value{MANUAL_TITLE}
documentation, and is consistent with @value{PACKAGE_NAME} @value{PACKAGE_VERSION}.
This manual was developed under the @uref{http://www.openss7.org/, OpenSS7
Project} and was funded in part by
@uref{http://www.openss7.com/, OpenSS7 Corporation}.

@noindent
Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

@noindent
Permission is granted to copy and distribute translations of this manual into
another language, under the same conditions as for modified versions.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Ed. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Ed.  @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Concatenate indices
@syncodeindex pg cp
@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex tp cp
@synindex ky cp

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@unnumbered About This Manual
This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of @cite{The
@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
release @value{PACKAGE_RELEASE} of the @value{PACKAGE_TITLE} package.
@end ifnottex

@iftex

@macro tabfig {image, number, caption}
@float Table,Table \number\
@image{\image\}
@caption{@emph{\caption\}}
@end float
@end macro

@macro tabref {number}
@emph{@ref{Table \number\}}
@end macro

@macro figure {image, number, caption}
@cartouche
@float Figure,Figure \number\
@image{\image\}
@caption{@emph{\caption\}}
@end float
@end cartouche
@end macro

@macro figuresized {image, number, caption, size}
@cartouche
@float Figure,Figure \number\
@image{\image\,\size\}
@caption{@emph{\caption\}}
@end float
@end cartouche
@end macro

@macro figref {number}
@emph{@ref{Figure \number\}}
@end macro

@macro manpage {name}
@command{\name\}
@end macro

@end iftex

@ifnottex

@macro tabfig {image, number, caption}
@image{\image\} @anchor{Table \number\} @center @emph{Table \number\.@:  \caption\}
@end macro

@macro tabref {number}
@emph{@ref{Table \number\}}
@end macro

@macro figure {image, number, caption}
@image{\image\} @anchor{Figure \number\} @center @emph{Figure \number\.@:  \caption\}
@set fignum \number\
@end macro

@macro figuresized {image, number, caption, size}
@image{\image\,\size\} @anchor{Figure \number\} @center @emph{Figure \number\.@:  \caption\}
@set fignum \number\
@end macro

@macro figref {number}
@emph{@ref{Figure \number\}}
@end macro

@macro manpage {name}
@inforef{\name\, , *manpages*}
@end macro

@end ifnottex

@menu
* Acknowledgements::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* Messages::
* Polling::
* Modules and Drivers::
* STREAMS Modules::
* STREAMS Drivers::
* STREAMS Mulxiplexing::
* STREAMS-based Pipes and FIFOs::
* STREAMS-based Terminal Subsystem::
* Reference::
* Examples::
* Device Numbers::
* Multi-Threading::
* Administration::
* Conformance::
* Portability::
* Copying::
* Index::

 --- The Detailed Node Listing ---

Acknowledgements

* Sponsors::			Sponsors of Linux Fast-STREAMS
* Contributors::		Contributors to Linux Fast-STREAMS

Introduction

* What is STREAMS?::		STREAMS Description
* Does Linux have STREAMS?::	STREAMS and Linux
* Why STREAMS?::		STREAMS Justification
* Why Fast?::			STREAMS Implementation
* Why Linux?::			STREAMS for Linux
* Why Compatibility?::		STREAMS Compatibility

Overview

* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems

Mechanism

* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction

Processing

* Procedures::			STREAMS Put and Service Procedures
* Asyncrhonous Example::	STREAMS Asyncrhonous Stream Example

Messages

* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers

Polling

* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal

Modules and Drivers

* Environment::			STREAMS Module and Driver Environment
* Input-Output Controls::	STREAMS Input and Output Controls
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines

STREAMS Modules

* Modules::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines

STREAMS Drivers

* Drivers::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines

STREAMS Mulxiplexing

* Multiplexing::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexor Connect and Disconnect Lower Stream
* Multiplexor Construction Example::
				STREAMS Multiplexor Construction Example
* Mulxiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexor Persistent Links
* Multiplexor Design Guidelines::
				STREAMS Multiplexor Design Guidlines

STREAMS-based Pipes and FIFOs

* Pipes and FIFOs::		STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs

STREAMS-based Terminal Subsystem

* Terminal Subsystem::		STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem

Reference

* Files::			STREAMS Files
* Modules::			STREAMS Modules
* Drivers::			STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions

Examples

* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example

Device Numbers

* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* spec File System::		Avoiding Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering

Multi-Threading

* Configuration::		MP STREAMS Configuration
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks

Administration

* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System

Conformance

* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX Compatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
* LiS Compatibility::		LiS 2.18.1 Compatibility

Portability

* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* LiS Portability::		Porting from LiS 2.18.1

Copying

* GNU General Public License::		GPL
* GNU Free Documentation License::	FDL

@end menu

@c Indices
@c 
@c * Concept Index::		Concept Index
@c * Type Index::			Type Index
@c * Function Index::		Function Index
@c * Variable Index::		Variable Index
@c * File Index::			File Index


@c --------------------------------------------------------------------------

@node Acknowledgements
@unnumbered Acknowledgements
@cindex credits

@include texi/funding.texi

@ignore 

@menu
* Sponsors::			Sponsors of Linux Fast-STREAMS
* Contributors::		Contributors to Linux Fast-STREAMS
@end menu

@node Sponsors
@unnumberedsec Sponsors of @value{PACKAGE_TITLE}
@cindex sponsors

Funding for completion of @value{PACKAGE_TITLE} was provided by:

OpenSS7 Corporation

Additional funding for The OpenSS7 Project was provided by:

@node Contributors
@unnumberedsec Contributors to @value{PACKAGE_TITLE}
@cindex contributors

The primary contributor to @value{PACKAGE_TITLE} is Brian F. G. Bidulock.

@end ignore

@node Introduction
@chapter Introduction
@cindex introduction

The @url{http://www.openss7.org/, OpensSS7 Project},
@cindex OpenSS7 Project
@file{@value{PACKAGE}-@value{VERSION}} package
@pgindex @value{PACKAGE}-@value{VERSION}
provides an @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
compatible @cite{STREAMS} implementation for @b{Linux}
@cindex Linux
2.4 and 2.6 series kernels.

@menu
* What is STREAMS?::		STRAEMS Overview
* Does Linux have STREAMS?::	STREAMS and Linux
* Why STREAMS?::		STREAMS Justification
* Why Fast?::			STREAMS Implementation
* Why Linux?::			STREAMS for Linux
* Why Compatibility?::		STREAMS Compatibility
@end menu

@node What is STREAMS?
@section What is @cite{STREAMS}?
@cindex what is @cite{STREAMS}?
@cindex @cite{STREAMS}, what is it?

@cite{STREAMS} is a facility first presented by Dennis M. Ritchie in 1984,@footnote{@cite{A Stream
Input-Output System, AT&T Bell Laboratories Technical Journal 63, No. 8 Part 2 (October, 1984), pp.
1897-1910.}} originally implemented on 4.1BSD and later part of @cite{Bell Laboratories Eighth
Edition UNIX}, incorporated into
@cite{UNIX System V Release 3.0}
@cindex UNIX System V Release 3.0
and enhanced in
@cite{UNIX System V Release 4}
@cindex UNIX System V Release 4
and
@cite{UNIX System V Release 4.2}.
@cindex UNIX System V Release 4.2
@cite{STREAMS} was used in @cite{SVR4} for terminal input/output, pseudo-terminals, pipes, named
pipes (FIFOs), interprocess communication and networking.  Since its release in @cite{System V
Release 4}, @dfn{STREAMS} has been implemented across a wide range of @cite{UNIX}, @cite{UNIX}-like,
and @cite{UNIX}-based systems, making its implementation and use an @i{ipso facto} standard.

@cite{STREAMS} is a facility that allows for a reconfigurable full duplex communications path
(stream) between a user process and a driver in the kernel.  Kernel protocol modules can be pushed
onto and popped from the stream between the user process and driver.  The stream can be reconfigured
in this way by a user process.  The user process, neighbouring protocol modules and the driver
communicate with each other using a message passing scheme closely related to MOM (Message Oriented
Middleware).  This permits a loose coupling between protocol modules, drivers and user processes,
allowing a third-party and loadable kernel module approach to be taken toward the provisioning of
protocol modules on platforms supporting @cite{STREAMS}.

On @cite{UNIX System V Relase 4.2}
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used for terminal input-output, pipes, FIFOs (named pipes), and network
communications.  Modern @cite{UNIX}, @cite{UNIX}-like and @cite{UNIX}-based systems providing
@dfn{STREAMS} normally support some degree of network communications using @dfn{STREAMS}; however,
many do not support @dfn{STREAMS}-based pipe and FIFOs@footnote{For example, AIX.} or terminal
input-output.@footnote{For example, HP-UX}.

@node Does Linux have STREAMS?
@section Does Linux have STREAMS?
@cindex Does Linux have STREAMS?

No, not as part of the kernel.  That is rather peculiar, particularly since Linux normally follows
SVR4 first and 4BSD second.  (Otherwise, it would just be another BSD.)

A number of attempts were made to move the @cite{Linux STREAM (LiS)} project into the @b{Linux}
kernel, however, each attempt crashed and burned in a shower of flames from BSD advocates on LKML.
Arguments against appear to be based more on @dfn{Religious Denomination} rather than valid
technical argument.  This is discussed more in the next section (@pxref{Why STREAMS?}).

@subsection Linux STREAMS (LiS)
@cindex Linux STREAMS (LiS)

@subsection Linux Fast-STREAMS (LfS)
@cindex Linux Fast-STREAMS (LfS)

@subsection STREAMS for FreeBSD
@cindex FreeBSD

@subsection OpenSTREAMS?

@node Why STREAMS?
@section Why STREAMS?
@cindex Why STREAMS?

@menu
* STREAMS versus Sockets::	STREAMS and Sockets
* Benefits of STREAMS::		STREAMS Benefits
* Criticism of STREAMS::	STREAMS Criticism
* Realities of STREAMS::	STREAMS Realities
@end menu

@node STREAMS versus Sockets
@subsection STREAMS versus Sockets
@cindex STREAMS versus Sockets

The basic question that is always asked is: "Why use @cite{STREAMS} when you can just use
@b{Linux}'s NET4 BSD Sockets instead?"

The answer to this question is that @cite{STREAMS} provides capabilities for specialized protocols
and streamed input/output requirements (such as media) that are not ameniable to the sockets
interface or queue mechanisms.

Two examples are SS7 (Signalling System Number 7) which is a specialized Telecommunications protocol
used be switching equipment in the Public Switched Telephone Network; and transferring and
manipulating voice channels associated with telephone call or other telecommunications services.
These are the reasons why the @url{http://www.openss7.org/, OpenSS7 Project}
@cindex OpenSS7 Project
originally embarked on using @cite{STREAMS}.  You will find that a large number of @cite{SS7} stack
vendors also deliver @cite{UNIX} and even @cite{RTOS} products on @cite{STREAMS}.

Although the BSD Sockets framework was established to permit arbitrary protocols to be implemented
within the framework, it is seldom that BSD Sockets is actually used in this fashion.

@quotation
The @cite{4.2BSD} version of @cite{UNIX} introduced @dfn{sockets}
@cindex sockets
[Leffler, McKusick, Karels,
Quaterman 1988].  The operating system provided an infrastructure in which network protocols could
be implemented.  It provided memory management facilities, a set of system calls for accessing
network software, an object-oriented framework for the network protocols themselves, and a
formalized device driver interface.  The @dfn{sockets}
@cindex sockets
mechanism was primarily used to implement the
TCP/IP
@cindex TCP/IP
protocols for the
ARPA
@cindex ARPANET
Internet.
The device driver interface made it possible for the operating system to support a wide range of
network controllers.  @dfn{sockets}
@cindex sockets
are widely used for the implementation of TCP/IP
@cindex TCP/IP
on @cite{UNIX} systems and have been ported to many implementations of @cite{UNIX System V}.
Although it is possible to implement other protocols within the @dfn{sockets} mechanism, it was not
often done.

An alternative infrastructure for providing network protocols is @dfn{STREAMS}, originally designed
by Dennis Ritchie [Ritchie 1984a] and first released in @cite{UNIX System V Release 3.0}.
@dfn{STREAMS} provides an environment in which communications protocols can be developed.  It
consists of a set of system calls, kernel functions and data structures.  With this environment it
is easier to write modular and reusable code.  The code is also simpler because many of the support
functions the programmer needs are provided by the @dfn{STREAMS} infrastructure.
@end quotation

Have you ever seen the RTP (Real-Time Transport Protocol, RFC 1889) implemented under a Socket?  Why
not?  Is not the sockets interface so flexible as to permit such protocols to be implemented?

There are several reasons that BSD Sockets have not been used for other protocol development:

@itemize

@item  Although BSD Sockets provides a framework for protocol development, it does not provide
many utility functions for working with arbitrary protocols.  Most of the utilities are DARPA
ARPANET specific.@footnote{This should not be suprising as the 4BSD releases were developed for
DARPA.}

@item Protocol to protocol module interfaces are poorly standardized for the BSD Sockets system,
whereas, protocol to protocol module service interfaces are well defined under OSI for
@cite{STREAMS}.  (@b{Linux} discards the protocol to protocol interface anyway.)

@item The BSD Sockets interface can easily be applied over @cite{STREAMS} transport protocol
modules; however, the reverse is not true: the @cite{STREAMS} interface cannot easily be provided
over the BSD Sockets protocol modules.@footnote{A case in point is the iBCS.
@cindex iBCS
@cindex Intel Binary Compatibility Suite
You will see in the iBCS
@cindex iBCS
@cindex Intel Binary Compatibility Suite
that, although a basic XTI over Sockets implementation can be provided, none of the @cite{STREAMS}
facilities can be supported.  In constrast the @cite{STREAMS} INET driver that performs XTI over
Sockets with in the @cite{STREAMS} framework is easily implemented as a single device driver and
provides both @cite{iBCS}
@cindex iBCS
@cindex Intel Binary Compatibility Suite
and @cite{STREAMS} capabilities.}

@item Support in the BSD Sockets model for dynamically loaded protocol (kernel) modules and
administrative reconfiguration of protocols and interfaces for new protocols are poorly supported.

@item The BSD Sockets model has almost no support for banded or priority message queues within the
model and no systemic approach to flow control.

@item The @b{Linux} implementation of BSD Sockets discards much of the general purpose protocol
framework, presumably in the pursuit of speed.

BSD sockets consists of a socket that interfaces with the user using file system and socket
semantics, a protocol control block that represents the upper-most protocol, a socket to protocol
interface, additional protocol control blocks representing lower protocol components, a protocol to
protocol interface, a device interface abstraction, and a protocol to device interface.

Linux discards the protocol control block, socket to protocol interface, protocol to protocol
interface, and protocol to device interface.

One of the major ramifications of @b{Linux} discarding the protocol to protocol interface is that it
is very difficult to implement layered or tunnelled protocols in the @b{Linux} kernel.
@footnote{That is, even more difficult than on a BSD system.}
Layered protocols that run, say, over UDP, such as econet, must internally use the socket interface
to a UDP datagram socket to layer the econet protocol over UDP.  Under @dfn{STREAMS} it is much
easier to either push econet as a module over the UDP transport provider stream, or to I_LINK
transport provider streams under an econet multiplexing driver.

@end itemize

In commenting on the relative performance of @cite{STREAMS} and Sockets, Mitchel Waite had this to
say:

@quotation
Sockets are like pipes with more power.  They are bidirectional and may cross network or other
machine boundaries.  In addition, sockets allow limited control information as well as data.

Streams are more general still, with extensive control information passing capabilities.

On most @cite{UNIX} systems, messages (if available) have the lowest overhead and highest
bandwidth, with pipes following close behind.  Because they support complex networking facilities,
sockets are probably less efficient than streams, but because they rarely appear on the same machine
as streams, the question is somewhat academic.  They certainly have much lower bandwidth than pipes
or messages.@footnote{@cite{UNIX Papers, for UNIX Developers and Power Users, (Waite, 1987) pp. 358-359}}
@end quotation

With @dfn{@value{PACKAGE_TITLE}} it will be very possible to compare the performance of @dfn{STREAMS}
in comparison to @dfn{Sockets}.  It will also be possible to compare the performance of traditional
@b{Linux} pipes and FIFOs with @dfn{STREAMS}-based pipes and FIFOs.

@node Benefits of STREAMS
@subsection Benefits of @cite{STREAMS}
@cindex benefits of @cite{STREAMS}
@cindex @cite{STREAMS}, benefits

@cite{STREAMS} provides a flexible, portable and reusable set of tools for development of @b{Linux}
system communications services.  @cite{STREAMS} allows an easy creation of modules that offer
standard data communications services and the ability to manipulate those modules on a @dfn{Stream}.  From
user level, modules can be dynamically selected and interconnected; kernel programming, assembly,
and link editing are not required to create the interconnection.

@cite{STREAMS} also greatly simplifies the user interface for languages that have complex input and
output requirements.

@subsubsection Standardized Service Interfaces
@cindex Standardized Service Interfaces

@cite{STREAMS} simplifies the creation of modules that present a service interface to any
neighbouring application program, module, or device driver.  A service interface is defined at the
boundary between two neighbours.  In @cite{STREAMS}, a @i{service interface} is a set of messages
and the rules that allow passage of these messages across the boundary.  A module that implements a
service interface will receive a message from a neighbour and respond with an appropriate action
(for example, send back a requires to retransmit) based on the specific message received and the
preceding sequence of messages.

In general, any two modules can be connected anywhere in a @dfn{Stream}.  However, rational sequences are
generally constructed by connecting modules with compatible protocol service interfaces.  For
example, a module that implements an X.25 protocol layer, as shown in
@c @figref{13},
Figure 13,
presents a protocol service interface at its input and output sides.  In this case, other modules
should only be connected to the input and output side if they have the compatible X.25 service
interface.

@subsubsection Manipulating Modules
@cindex Manipulating Modules

@cite{STREAMS} provides the ability to manipulate modules from user level, to interchange modules
with common service interfaces, and to change the service interface to a @cite{STREAMS} user
process.  These capabilities yield further benefits when implementing networking services and
protocols, including:

@itemize
@item User level programs can be independent of underlying protocols and physical communications
media.
@item Network architectures and higher level protocols can be independent of underlying protocols,
drivers, and physical communications media.
@item Higher level services can be created by selecting and connecting lower level services and
protocols.
@end itemize

@subsubsection Protocol Portability

@c @figref{13}
Figure 13,
shows how the same X.25 protocol module can be used with different drivers on different machines by
implementing compatible service interfaces.  The X.25 protocol module interfaces are Connection
Oriented Network Service (CONS) and Link Access Protocol - Balanced (LAPB).

@subsubsection Protocol Substitution

Alternate protocol modules (and device drivers) can be exchanged on the same machine if they are
implemented to an equivalent service interface.

@subsubsection Protocol Migration

@c @figref{14}
Figure 14
illustrates how @cite{STREAMS} can move functions between kernel software and front end firmware.  A
common downstream service interface allows the transport protocol module to be independent of the
number or type of modules below.  The same transport module will connect without modification to
either an X.25 module or X.25 driver that has the same service interface.

By shifting functions between software and firmware, you can produce cost-effective, functionally
equivalent systems over a wide range of configurations.  They can rapidly incorporate technological
advances.  The same transport protocol module can be used on a lower capacity machine, where
economics may preclude the use of front-end hardware, and also on a larger scale system where a
front-end is economically justified.

@subsubsection Module Reusability

@c @figref{15}
Figure 15
shows the same canonical module (for example, one that provide delete and kill processing on
character strings) reused in two different Streams.  This module would typically be implemented as a
filter, with no downstream service interface.  In both cases, a tty interface is presented to the
@dfn{Stream}'s user process since the module is nearest the @dfn{Stream head}.

@node Criticism of STREAMS
@subsection Criticism of STREAMS
@cindex Criticism of STREAMS

Following are some excerpts from Dennis M. Ritchie's original (1984) Bell Technical Journal paper on
the stream I/O system.  These excerpts are the limitations of the system as were perceived by Dennis
M. Ritchie at the time.  Strangely enough, although every limitation listed by Dennis was fixed even
as early as @cite{UNIX System V Release 3.0} and even in the @cite{UNIX Eighth Edition}, some BSD
advocates will use these limitations as a reason for not using @dfn{STREAMS} in BSD.  Also, note
that BSD'ers will also say that @dfn{STREAMS} was a @cite{UNIX Eighth Edition} (Bell Laboratories
Research version of UNIX) thing; however, Dennis' paper clearly states that the base system for the
initial @cite{Stream Input-Output System} was @cite{4.1BSD}.  Also note that @cite{4.1BSD} already
had @dfn{sockets} and that some of Ritchie's work was taken from @dfn{sockets}.  It took until
@cite{4.2BSD} for @cite{BBN} to add the @dfn{DARPANET} protocol stack to sockets.

Perhaps it is not so surprising why BSD'ers hark back to Ritchie's original problem list for
@dfn{STREAMS}: because it was at that point that BSD decided to not follow the @cite{STREAMS} work
too closely, except as regards IPC, and UNIX domain mechanisms.  It is likely that BSD would have
used @dfn{STREAMS}, however, it was included in @cite{UNIX System V Release 3.0} and this was the
first release that @cite{AT&T} was allowed to aggressively market under the terms of the
@dfn{Modified Judgement}.

@quotation
Although the new organization performs well, it has several peculiarities and limitations.  Some of
them seem inherent, some are fixable, and some are the subject of current work.

I/O control calls turn into messages that require answers before a result can be returned to the
user.  Sometimes the message ultimately goes to another user-level process that may reply tardily or
never.  The stream is write-locked until the reply returns, in order to eliminate the need to
determine which process gets which reply.  A timeout breaks the lock, so there is an unjustified
error return if a reply is late, and a long lockup period if one is lost.  The problem can be
ameliorated by working harder on it, but it typifies the difficulties that turn up when direct calls
are replaced by message-passing schemes.
@end quotation

This problem was never really fixed I suppose because most @dfn{STREAMS} specifications say that
only one @command{ioctl} can be outstanding for a given stream.  Nevertheless, an @command{ioctl}
identifier was added to the @var{M_IOCTL}
@vindex M_IOCTL
message that uniquely identifies the @command{ioctl}; but, a timer is still used.  With
the @var{I_STR}
@vindex I_STR
@command{ioctl}, however, the caller has control over the duration of the timeout.
Strange, but this unfixed problem is the one that seldom gets raised as a reason for no using
@dfn{STREAMS}.

@quotation
Several oddities appear because time spent in server routines cannot be assigned to any particular
user or process.  It is impossible, for example, for devices to support privileged @command{ioctl}
calls, because the device has no idea who generated the message.  Accounting and scheduling becomes
less accurate; a short census of several systems showed that between 4 and 8 per cent of non-idle
CPU time was being spent in server routines.  Finally, the annonimity for server processing most
certainly makes it more difficult to measure the performance of the new I/O system.
@end quotation

This problem with privileged @command{ioctl} calls was easily fixed by adding the credentials of the
caller to the @var{M_IOCTL}
@vindex M_IOCTL
message.
This limitation is also not mentioned by @dfn{STREAMS} critics.

@quotation
In its current form the stream I/O system is purely data-driven.  That is, data is presented by a
user's @command{write} call, and passes through to the device; conversely, data appears unbidden from
a device an passes to the top level, where it is picked up by @command{read} calls.  Wherever
possible flow control throttles down fast generators of data, but nowhere except at the consumer end
of a stream is there knowledge for precisely how much data is desired.  Consider a command to execute
possibly interactive program on another machine connected to a stream.  The simplest such common
sets up the connection and invokes the remote program, and then copies characters from its own
standard input to the stream, and from the stream to its standard output.  The scheme is adequate in
practise, but breaks when the user types more than the remote program expects.  For example, if the
remote program reads no input at all, any typed-ahead characters are sent to the remote system and
lost.  This demonstrates a problem, but I know of no solution inside the stream I/O mechanism
itself; other ideas will have to be applied.
@end quotation

Back-enabling of queues and the use of the @var{M_READ}
@vindex M_READ
message makes it possible for the consumer end of the stream to signal its desire for data
downstream.
Also, in the example that Ritchie gives here, the network protocol (TCP) is of no help either.
This limitation is also not mentioned by @dfn{STREAMS} critics.

@quotation
Streams are linear connections; by themselves, they support no notion of multiplexing, fan-in or
fan-out.  Except at the ends of a stream, each invocation of a module has a unique "next" and
"previous" module.  Two locally-important applications of streams testify to the importance of
multiplexing: Blit terminal connections, where the multiplexing is done well, though at some
performance costs, but a user program, and remote execution of commands over a network, where it is
desired, but not now easy, to separate the standard output from error output.  It seems likely that
a general multiplexing mechanism could help in both cases, but again, I do not yet know how to
design it.
@end quotation

This was, of course, solved, even in @cite{UNIX System V Release 3.0} with the
@var{I_LINK},
@vindex I_LINK
@var{I_PLINK},
@vindex I_PLINK
@var{I_UNLINK}
@vindex I_UNLINK
and
@var{I_PUNLINK}
@vindex I_PUNLINK
@dfn{STREAMS} @command{ioctl} commands and the concept of a multiplexing pseudo-device driver.
This fixed limitation you will see mentioned below.

The following excerpt shows how BSD'ers like to misinterpret the situation:

@quotation
Original work on the flexible configuration of IPC processing modules was done at Bell Laboratories
in UNIX Eigth Edition [Presotto & Richie, 1985].  This @i{stream I/O system} was based on UNIX
character I/O system.  It allowed a user process to open a raw terminal port and then to insert
appropriate kernel-processing modules, such as one to do normal terminal line editing.  Modules to
process network protocols also could be inserted.  Stacking a terminal-processing module on top of a
network-processing module allowed flexible and efficient implementation of @i{network virtual
terminals} within the kernel.  A problem with streams modules, however, is that they are inherently
linear in nature, and thus they do not adequately handle the fan-in and fan-out associated with
multiplexing in datagram-based networks; such multiplexing is done in device drivers, below the
modules proper.  The Eighth Edition stream I/O system was adopted in System V, Release 3 as the
STREAMS system.
@footnote{@cite{The Design and Implementation of the 4.4BSD Operating System, McKusick, et. al.,
(Addison-Wesley, 1996) pp. 15-16}}
@end quotation

Well, the @cite{UNIX Eighth Edition} @dfn{Stream Input-Output System} may have been included in
@cite{UNIX System V Release 3.0} as stated, however, Ritchie's @dfn{Stream Input-Output System} was
implemented on @cite{4.1BSD} for the October 1984 paper.

@quotation
The design of the networking facilities for 4.2BSD took a different approach, based on the
@dfn{socket} interface and a flexible multilayer network architecture.  This design allows a single
system to support multiple sets of networking protocols with stream datagram, and other types of
access.  Protocol modules may deal with multiplexing of data from different connection onto a single
transport medium, as well as with demultiplexing of data for different protocols and connection
received from each network device.  The 4.4BSD release made small extensions to the socket interface
to allow the implementation of the ISO networking protocols.
@footnote{@cite{The Design and Implementation of the 4.4BSD Operating System, McKusick, et. al.,
(Addison-Wesley, 1996) pp. 15-16}}
@end quotation

@node Realities of STREAMS
@subsection Realities of STREAMS
@cindex Realities of STREAMS

The realities of @dfn{STREAMS} are as follows:

@itemize

@item @dfn{STREAMS} is implemented on every major ``Big Iron'' @cite{UNIX}.

Even Sun Microsystems chose to abandon BSD Sockets as an internal kernel networking implementation
and moved to the @cite{UNIX System V Release 4} @dfn{STREAMS} subsystem instead.@footnote{BSD'er
will tell you that Sun Microsystems just made a bad decision.} @dfn{STREAMS} is implemented (to list
a few) in 
@cite{AIX 5L Version 5.1 PSE},
@cindex AIX
@cite{HP-UX 11.0i v2 STREAMS/UX},
@cindex HP-UX
@cite{OSF/1 1.2/Digital UNIX},
@cindex OSF/1
@cindex Digital UNIX
@cite{UnixWare 7.1.3 (OpenUnix 8)},
@cindex UnixWare
@cindex OpenUnix
@cite{Solaris 9/SunOS 5.9},
@cindex Solaris
@cindex SunOS
@cite{Super-UX},
@cindex Super-UX
@cite{UXP/V}
@cindex UXP/V
and
@cite{MacOS OT}.
@cindex MacOS

@item @dfn{STREAMS} is implemented on many Real-Time Operating Systems (RTOS) based on @cite{UNIX}.

Examples include @cite{WindRiver}, @cite{PSOS}, @cite{VxWorks}, etc.

@item @dfn{STREAMS} implementations are widely standardized on the @cite{UNIX System V Release 4.2}
specifications.

@item @dfn{STREAMS} provides standardized (POSIX, OpenGroup, SVID) Transport Library Interface to
communications networking suites.

@item @dfn{STREAMS} has many portable implementations.

@end itemize

@node Why Fast?
@section Why Fast?
@cindex Why Fast?

@dfn{@value{PACKAGE_TITLE}} includes the word @cite{fast} in the name because of the original roots of
the @dfn{@value{PACKAGE_TITLE}} development effort.  @dfn{@value{PACKAGE_TITLE}} was originally developed by
the @url{http://www.openss7.org/, OpenSS7 Project} as a production replacement for the
@cite{Linux STREAMS (LiS)}
@cindex Linux STREAMS (LiS)
package previously available from @url{http://www.gcom.com/, GCOM}.
@cindex GCOM
One of the reasons for contemplating a replacement for
@cite{Linux STREAMS (LiS)}
@cindex Linux STREAMS (LiS)
was the dismal performance provided by
@cite{Linux STREAMS (LiS)}.
@cindex Linux STREAMS (LiS)
Other reasons included:
@itemize

@item Mainline Adoption instead of Portability

@cite{LiS} attempts to maintain portability across a number of operating systems.  The goals of
portability and mainline adoption are usually at cross-purposes.  @dfn{@value{PACKAGE_TITLE}} proposes
mainline adoption in contrast to portability.  Many @dfn{STREAMS} implementations are available for
other operating systems.

@item Production Grade

@cite{LiS} attempts to always provide debugging facilities@footnote{In fact, these debugging
facilities always point at the driver or module writer when a bug is encountered in LiS itself!} and
does not trust the driver or module writer.  This leads to poor performance and in many cases the
propagation of bugs to the field by failing to panic the kernel.  @dfn{@value{PACKAGE_TITLE}} aims at a
production grade environment that implicitly trusts the driver or module while providing optional
debugging facilities (both compile-time options as well as run-time options).

@item SVR 4.2 MP Compatibility
@cindex SVR 4.2 MP

@cite{LiS} only provides @cite{SVR 4} uniprocessor capabilities.  @dfn{@value{PACKAGE_TITLE}} provides
@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
capabilities.

@item Portability

@cite{LiS} forces ported drivers and modules from other implementations to use the @cite{LiS} DDI
and configuration mechanisms.  @dfn{@value{PACKAGE_TITLE}} provides compatibility functions for all
major implementations of @dfn{STREAMS} as well as providing a rich DDI based on @cite{SVR 4.2 MP},
@cindex SVR 4.2 MP
@cite{Solaris}, and other implementations.

@item Bug Circumvention

@item Major Redesign

@item Scalable

@item Soft Real Time Performance

@cite{LiS} avoids use of high-performance @b{Linux}-specific facilities because of its aims at
portability.  @dfn{@value{PACKAGE_TITLE}} being aimed at only @b{Linux} uses the highest-performance
techniques available in the @b{Linux} kernel for implementation.  This includes kernel memory
caches and other techniques.

@item Maintainability

@end itemize

@node Why Linux?
@section Why Linux?
@cindex Why Linux?

Well, @b{Linux} is the only @cite{SVR 4}
@cindex SVR 4
based system that does not provide @cite{STREAMS}, although @cite{STREAMS} is an essential part of
@cite{SVR 4}.
@cindex SVR 4
Without @cite{STREAMS}, @b{Linux} is just another @cite{BSD},
@cindex BSD
and perhaps a bad one.

@node Why Compatibility?
@section Why Compatibility?
@cindex Why Compatibility?

@dfn{@value{PACKAGE_TITLE}} is designed and implemented to be compatible with as many
@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based implementations of @cite{STREAMS} as possible.  This is done for several reasons:

@enumerate

@item @i{Porting legacy drivers to @b{Linux}:}

Many legacy @cite{STREAMS} drivers have been written and developed for @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
or @cite{UNIX} systems based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
Remaining compatible with as many implementation as possible permits these legacy drivers to be
easily ported from their native @cite{UNIX} variant to the @dfn{@value{PACKAGE_TITLE}}
@cindex @value{PACKAGE_TITLE} (LfS)
environment, thus quickly porting these legacy drivers to @b{Linux}.

@item @i{Leverage of knowledge base:}

Many developers are familiar one or another of the mainstream @cite{UNIX} implementations of
@cite{SVR 4.2 MP STREAMS}.
@cindex SVR 4.2 MP, @cite{STREAMS}
By remaining as compatible as possible with all these implementations of @cite{STREAMS} permits
knowledge and expertise in the @cite{UNIX} variant of @cite{STREAMS} to be transferred and applied
to @dfn{@value{PACKAGE_TITLE}}
@cindex @value{PACKAGE_TITLE} (LfS)
on @b{Linux}.

@item @i{Reverse portability:}

Because it is as compatible as possible with other @cite{STREAMS} implementations, @cite{STREAMS}
drivers and modules developed on @dfn{@value{PACKAGE_TITLE}} can easily be ported to other
implementations if a set of compatibility and portability guidelines are followed.  This allows
@cite{STREAMS} drivers and modules developed on the @b{Linux} operating system to be used on branded
@cite{UNIX} systems with minimal porting and modification.

@item @i{Standardization:}

By being as compatible as possible with as many @cite{STREAMS} implementations as possible,
@dfn{@value{PACKAGE_TITLE}}
@cindex @value{PACKAGE_TITLE} (LfS)
implements an @i{ipso facto} standard.  Unfortunately, the
@cite{OpenGroup}
@cindex OpenGroup
and
@cite{POSIX}
@cindex POSIX
have been very lacking in the standardization of internal kernel interfaces such as @cite{STREAMS}.
Maximum compatibility moves close to providing a standard for such interfaces.

@end enumerate

@subsection Intel Binary Compatibility Suite (iBCS)
@cindex Intel Binary Compatibility Suite (iBCS)

The @cite{Intel Binary Compatibility Suite} provides binary compatibility on the @cite{Intel}
architecture for systems conforming to @cite{SVR 4.2}.  @cite{RedHat} has released an @cite{iBCS}
module for their distributions of @b{Linux} and the @b{Linux Kernel} for some time.

@subsubsection OpenGroup Specifications
@cindex OpenGroup Specifications

OpenGroup and POSIX specifications have never directly addressed @dfn{STREAMS} implementation within
the operating system.  I suppose that this is primarily because 4BSD based system have seldom
included @dfn{STREAMS}.  Perhaps it was due to some religious upheaval from BSD advocates that did
not want to see @dfn{STREAMS} become part of a standard.

Nevertheless, the @dfn{STREAMS} subsystem has been an optional part of the
@url{http://www.opengroup.org/, OpenGroup} specifications for some time.  It is my opinion that the
@url{http://www.opengroup.org/, OpenGroup} has missed a rich opportunity for standardization of
kernel level interfaces.

@unnumberedsubsubsec UNIX 03 Compliance
@cindex UNIX 03 compliance
@cindex compliance, UNIX 03

@dfn{UNIX 03} compliance to @cite{Open Group Extensions} requires that XTI/TLI networking support be
provided.  (See @cite{XNS 5.2}).  As the @dfn{iBCS} has proven, this does not require full
@dfn{STREANS} support, however, it is an easier thing to accomplish with @dfn{STREAMS} support.
Even though the @cite{XNS 5.2} specification does not describe @dfn{STREAMS}, the @cite{SUSv3} does.
The @url{http://www.opengroup.org/, OpenGroup} has never defined the internals of the @dfn{STREAMS}
facility in their @dfn{CAE} specifications; however, they are described and the user-space
facilities and system calls are completely defined and described.

@unnumberedsubsubsec UNIX 98 Compliance
@cindex UNIX 98 compliance
@cindex compliance, UNIX 98

@dfn{UNIX 98} compliance to @cite{X/Open Extensions} requires that XTI/TLI networking support be
provided.  (See @cite{XNS 5}).  As the @dfn{iBCS} has proven, this does not require full
@dfn{STREANS} support, however, it is an easier thing to accomplish with @dfn{STREAMS} support.
Even though the @cite{XNS 5} specification does not describe @dfn{STREAMS}, the @cite{XSI 5} and
@cite{SUSv2} does.  The @url{http://www.opengroup.org/, OpenGroup} has never defined the internals
of the @dfn{STREAMS} facility in their @dfn{CAE} specifications; however, they are described and the
user-space facilities and system calls are completely defined and described.

@unnumberedsubsubsec UNIX 95 Compliance
@cindex UNIX 95 compliance
@cindex compliance, UNIX 95

@dfn{UNIX 95} compliance to @cite{X/Open Extensions} requires that XTI/TLI networking support be
provided.  (See @cite{XNS 4.2}).  As the @dfn{iBCS} has proven, this does not require full
@dfn{STREANS} support, however, it is an easier thing to accomplish with @dfn{STREAMS} support.
Even though the @cite{XNS 4.2} specification does not describe @dfn{STREAMS}, the @cite{XSI 4.2} and
@cite{SUS} does.  The @url{http://www.opengroup.org/, OpenGroup} has never defined the internals of
the @dfn{STREAMS} facility in their @dfn{CAE} specifications; however, they are described and the
user-space facilities and system calls are completely defined and described.

@subsection Device Driver Interface (DDI)
@cindex DDI

@node Overview
@chapter Overview of @value{PACKAGE_TITLE}
@cindex overview
@menu
* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems
@end menu

This manual documents how to develop and port STREAMS drivers and modules for
@value{PACKAGE_TITLE}.

@node Definitions
@section @cite{STREAMS} Definitions
@cindex @cite{STREAMS}, definitions
@cindex definitions, @cite{STREAMS}

@table @dfn

@item Stream
A @dfn{Stream} is a full-duplex communications path between a User Process and a Kernel Level Device
or Pseudo-Device Driver.  A @dfn{Stream} is a group of @dfn{STTREAMS} message queue pairs in a chain
from a kernel driver at the @dfn{Stream End} to a @dfn{Stream Head} at the user.

@item Stream Head
A @dfn{Stream Head} is the component in a @dfn{Stream} that is closest to the User Process.  The
@dfn{Stream Head} sits in Kernel Space and provide interface to the User Process.

@item Stream End
A @dfn{Stream End} is the component in a @dfn{Stream} that is farthest from the User Process.  The
@dfn{Stream End} sits in Kernel Space and is normally a Device or Pseudo-Device Driver.

@item Module
A @dfn{Module} is a protocol module that resides between the @dfn{Stream Head} and @dfn{Stream End}
on a @dfn{Stream}.  Protocol @dfn{Modules} are optional and can be pushed or popped from a
@dfn{Stream} using @command{ioctl} commands to the @dfn{Stream Head}.  A @dfn{Module} can refer to a
linkable kernel component (kernel module), a @dfn{STREAMS} driver, module or mux (@dfn{STREAMS}
module), or a pushable @dfn{STREAMS} module.

@item Driver
A @dfn{Driver} is a device or pseudo-device driver that sits at the @dfn{Stream End}.  @dfn{Drivers}
are associated with device numbers and are opened by the User Process.  A @dfn{Driver} is a
@dfn{STREAMS} module which sets at a @dfn{Stream End}, farthest from the user on a @dfn{Stream}.

@item Messages
A @dfn{Message} is a chain of data buffers used for passing data by reference between neighbouring
@dfn{STREAMS} @dfn{Modules}, the @dfn{Stream Head} and the @dfn{Driver}.  A @dfn{Message} is a
message containing data that is made up of a sequence of message blocks, data blocks and data.

@item Queues
Each @dfn{Stream Head}, @dfn{Stream End} and intervening @dfn{Module} consists of a pair of
@dfn{Queues}: one downstream @dfn{Queue} for messages first written by the User Process, and one
upstream @dfn{Queue} for messages ultimately read by the User Process.  A @dfn{Queue} is an ordered
list of messages awaiting processing.  @dfn{STREAMS} modules form a full duplex connection by
pairing queues as read and write queues.

@item Stream I/O

@item Multiplexing
@dfn{Multiplexing} is a situation where multiple @dfn{Streams} can fan-in or fan-out from a
@dfn{Module} or @dfn{Multiplexing Driver}.  A @dfn{Multiplexing} driver or @dfn{mux} is a
@dfn{STREAMS} module which has lower as well as upper queue pairs.

@item Polling

@item Flow Control
A @dfn{Stream} is flow-controlled when it is congested and temporarily cannot pass messages in the
band in which the stream is flow-controlled.

@end table

@node Concepts
@section Concepts
@cindex concepts

There are three types of @cite{STREAMS} entities: the stream head, modules and drivers.  Stream
heads are the kernel-space interface to the user process.  Modules are pushable streams protocol
modules that are optionally placed between the user process (stream head) and the driver (stream
end).  Drivers are device drivers or pseudo device drivers that can be opened using a character
device special file.

@figuresized{SPG_fig08,8,@dfn{STREAMS} Modules,4in}

@figref{8} illustrates the basic @dfn{STREAMS} modules:

@table @dfn

@item Stream Head
The @dfn{Stream Head} is allocated by the @dfn{STREAMS} subsystem when a @dfn{STREAMS} character
special device is opened.

A stream head is created whenever the first @command{open(2)}
@findex open(2)
is performed on a @dfn{STREAMS} device.  A stream head has a queue pair just like any other driver,
module or multiplexer, but it interfaces directly with user-space library calls.  A stream head is
opened whenever a driver is opened (whether for the first time or not), and each time that a module
is pushed onto the stream.  A stream head is closed when the last close is performed on the stream.

@item Driver
@dfn{Drivers} are opened by character major and minor device number.

Instances of a @dfn{STREAMS} driver are created by calling @command{open(2)}
@findex open(2)
on a character special device which has a device major number which has been registered against the
driver.  Opening the special character device results in the driver's open procedure being called.
The driver's open procedure is also called each time that the device is opened and each time that a
module is pushed onto a stream.  Closing the special character device for the last time results in
the driver's close procedure being called.

@item Module
@dfn{Modules} may be pushed under a @dfn{Stream Head} once a @dfn{Driver} or @dfn{Multiplexer} has
been opened.

@dfn{STREAMS} modules are not created by calling @command{open(2)}:
@findex open(2)
they are pushed onto an open stream with the @var{I_PUSH} @command{ioctl(2)}.
@vindex I_PUSH
@findex ioctl(2)
@cindex streamio(7)
Modules are pushed by name.  Modules can be popped from a stream using the @var{I_POP}
@command{ioctl(2)}.
@vindex I_POP
@findex ioctl(2)
@cindex streamio(7)
Several modules can be pushed on a stream.  A module's open procedure is called when it is pushed
and whenever the stream is reopened, and its close procedure is called whenever it is popped, or
when the stream is closed for the last time and is being dismantled.

@item Multiplexer
@dfn{Multiplexers} are opened on the upper interface like @dfn{Drivers}, but can also have other
streams @dfn{linked} underneath them.

@dfn{STREAMS} @dfn{Multiplexers} have both an upper queue pair and a lower queue pair.  Upper queue
pairs are opened when a character special device is opened as with a driver.  Lower queue pairs are
linked when another stream is linked under the @dfn{Multiplexer} by executing the @var{I_LINK} or
@var{I_PLINK}
@vindex I_LINK
@vindex I_PLINK
@command{ioctl(2)} command
@findex ioctl(2)
@cindex streamio(7)
on a control stream associated with the @dfn{Multiplexer}.

@var{I_LINK}'ed
@vindex I_LINK
streams can by unlinked with the @var{I_UNLINK}
@vindex I_UNLINK
@command{ioctl(2)}
@findex ioctl(2)
@cindex streamio(7)
command.
@var{I_PLINK}'ed
@vindex I_PLINK
streams can by unlinked with the @var{I_PUNLINK}
@vindex I_PUNLINK
@command{ioctl(2)}
@findex ioctl(2)
@cindex streamio(7)
command.
When the control stream is closed, all @var{I_LINK}'ed
@vindex I_LINK
streams are automatically unlinked.  @var{I_PLINK}'ed
@vindex I_PLINK
streams remain linked until the last upper stream of the @dfn{Multiplexer} is closed, at which time
the @dfn{Multiplexer} is dismantled and the @var{I_PLINK}'ed
@vindex I_PLINK
streams are @var{I_PUNLINK}'ed
@vindex I_PUNLINK
and closed.

@end table

A simple stream is illustrated in @figref{1}.

@figuresized{SPG_fig01,1,Simple Stream,4in}

In the simple stream, the @dfn{downstream} flow is the flow from the User Process to the Driver that
passes through any optional intervening Modules; the @dfn{upstream} flow is the flow from the Driver
to the User Process, again through any intervening Modules.

It is possible to have a stream that does not contain a module or driver.  There are two types of
streams that do not contain a module or driver: a pipe and a FIFO (named pipe).

A @dfn{STREAMS}-based pipe is illustrated in @figref{2}.

@figuresized{SPG_fig02,2,@cite{STREAMS}-based Pipe,4in}

A @dfn{STREAMS}-based FIFO is illustrated in @figref{7}.

@figuresized{SPG_fig07,7,@cite{STREAMS}-based FIFO (named pipe),4in}

Each @cite{STREAMS} driver or module has a number of constituent pieces.  Each @cite{STREAMS} driver
or module contains a stream table, stream administration, module information, module statistics and
queue initialization information.

Each instance of a @cite{STREAMS} driver or module has associated with it a stream head and a stream
end (the driver).  Each instance of a @cite{STREAMS} driver or module contains a queue pair with a
write (downstream) and read (upstream) queue.  Each queue possibly has queue band information
associated with the queue.

Each @cite{STREAMS} queue and queue band can contain @cite{STREAMS} messages.  @cite{STREAMS}
messages are composed of message blocks, data blocks and data buffers in a chain-buffer arrangement.

@figuresized{SPG_fig09,9,Message Overview,4in}

@figref{9} illustrates a @dfn{STREAMS} message.  Messages are strings of message blocks.  Each
message block refers to a data block.  Each data block has a data area associated with it.  The
data block has a message type (@samp{db_type}) associated with it.  Message types can be one of the
following:

@subheading Normal Messages

@multitable @columnfractions .20 .05 .05 .70
@item @var{M_DATA} @tab D @tab U @tab data to or from the user
@vindex M_DATA
@item @var{M_PROTO} @tab D @tab U @tab protocol primitive
@vindex M_PROTO
@item @var{M_BREAK} @tab D @tab - @tab request a driver to send a break in the medium
@vindex M_BREAK
@item @var{M_CTL} @tab D @tab U @tab used for inter-module and driver communication
@vindex M_CTL
@item @var{M_DELAY} @tab D @tab - @tab requests a real-time delay in output processing
@vindex M_DELAY
@item @var{M_IOCTL} @tab D @tab - @tab passes a streams ioctl call
@vindex M_IOCTL
@item @var{M_PASSFP} @tab D @tab U @tab user be stream heads to pass file pointers to each other (e.g. pipes)
@vindex M_PASSFP
@item @var{M_RSE} @tab D @tab U @tab reserved
@vindex M_RSE
@item @var{M_SETOPTS} @tab - @tab U @tab set options on the stream head
@vindex M_SETOPTS
@item @var{M_SIG} @tab - @tab U @tab sends a signal to the user
@vindex M_SIG
@end multitable

@subheading Priority Messages

@multitable @columnfractions .20 .05 .05 .70
@item @var{M_COPYIN} @tab - @tab U @tab copy data from user for transparent ioctl
@vindex M_COPYIN
@item @var{M_COPYOUT} @tab - @tab U @tab copy data to user for transparent ioctl
@vindex M_COPYOUT
@item @var{M_ERROR} @tab - @tab U @tab sends a fatal error to the stream head
@vindex M_ERROR
@item @var{M_FLUSH} @tab D @tab U @tab requests that driver and modules discard messages
@vindex M_FLUSH
@item @var{M_HANGUP} @tab - @tab U @tab indicates to the stream head that no more data can be read or written
@vindex M_HANGUP
@item @var{M_IOCACK} @tab - @tab U @tab acknowledges an ioctl request
@vindex M_IOCACK
@item @var{M_IOCNAK} @tab - @tab U @tab negatively acknowledges an ioctl request
@vindex M_IOCNAK
@item @var{M_IOCDATA} @tab D @tab - @tab provides data requested by a @var{M_COPYIN}
@vindex M_IOCDATA
@vindex M_COPYIN
@item @var{M_PCPROTO} @tab D @tab U @tab priority protocol primitive
@vindex M_PCPROTO
@item @var{M_PCRSE} @tab D @tab U @tab reserved
@vindex M_PCRSE
@item @var{M_PCSIG} @tab - @tab U @tab sends a priority signal to the user
@vindex M_PCSIG
@item @var{M_READ} @tab D @tab - @tab sent by the stream head when the user issues an unsatisfied @command{read(2)}
@findex read(2)
call
@vindex M_READ
@item @var{M_STOP} @tab D @tab - @tab requests that a device stop its output
@vindex M_STOP
@item @var{M_START} @tab D @tab - @tab request that a device start its output
@vindex M_START
@item @var{M_STARTI} @tab D @tab - @tab requests that a device start its input
@vindex M_STARTI
@item @var{M_STOPI} @tab D @tab - @tab requests that a device stop its input
@vindex M_STOPI
@end multitable

Message functions consist of the following:

@multitable @columnfractions .20 .80
@item @command{adjmsg(9)} @tab trims bytes from the front or back of a message
@findex adjmsg(9)
@item @command{allocb(9)} @tab allocates a combined message and data block
@findex allocb(9)
@item @command{bufcall(9)} @tab calls a specified function when buffers become available
@findex bufcall(9)
@item @command{copyb(9)} @tab copies a message block including the data
@findex copyb(9)
@item @command{copymsg(9)} @tab copies all the message blocks and data making up a message
@findex copymsg(9)
@item @command{datamsg(9)} @tab tests if the message is a data message (@var{M_DATA}, @var{M_PROTO}, ...)
@findex datamsg(9)
@item @command{dupb(9)} @tab duplicates a message block but references the same data
@findex dupb(9)
@item @command{dupmsg(9)} @tab duplicates all message blocks making up a message but references the
@findex dupmsg(9)
same data in each message block
@item @command{esballoc(9)} @tab allocates a message block and data block but references a
@findex esballoc(9)
user-provided data and free function
@item @command{freeb(9)} @tab frees a message block
@findex freeb(9)
@item @command{freemsg(9)} @tab frees an entire message
@findex freemsg(9)
@item @command{linkb(9)} @tab links a message block onto the end of a message
@findex linkb(9)
@item @command{msgdsize(9)} @tab counts the bytes in @var{M_DATA} blocks in a message
@findex msgdsize(9)
@item @command{pullupmsg(9)} @tab places data from an entire message into a single message block
@findex pullupmsg(9)
@item @command{unbufcall(9)} @tab cancels an earlier buffer callback request
@findex unbufcall(9)
@item @command{unlinkb(9)} @tab remove the first message block in a message
@findex unlinkb(9)
@end multitable

Messages can be priority or normal messages.  Priority messages are delivered ahead of normal
messages.  Normal messages can be in one of 256 bands (0-255).  Band @samp{n} messages are delivered
ahead of band @samp{m} messages where @samp{n>m}.  Queues are scheduled whenever messages are placed
on the tail of the queue.  Queues are scheduled whenever priority messages exist in a queue,
regardless of whether they were placed on the tail or the head of the queue.  Care must be taken not
to return a priority message to the head of the queue in a service procedure or the service
procedure will simply be rescheduled.

Buffers can be allocated as @var{BPRI_HI},
@vindex BPRI_HI
@var{BPRI_MED},
@vindex BPRI_MED
@var{BPRI_LO}
@vindex BPRI_LO
and @var{BRPI_WAITOK}.
@vindex BPRI_WAITOK
In many @dfn{STREAMS} implementations, these priorities have no meaning.

A buffer that is smaller than a given size (@var{FASTBUF})
@vindex FASTBUF
will be allocated more quickly.  This is because the buffer is allocated coincident with the message
block and data block.

When the system runs out of buffer, it will return failure to @command{allocb(9)}
@findex allocb(9)
and @command{esballoc(9)}.
@findex esballoc(9)
@command{bufcall(9)}
@findex bufcall(9)
or @command{esbbcall(9)}
@findex esbbcall(9)
can be used to have the @dfn{STREAMS} subsystem call a client function when a buffer of the given
size is available.  Care must be taken with the use of @command{bufcall(9)}
@findex bufcall(9)
that deadlock situations do not arise.

@figuresized{SPG_fig03,3,Stream to Communications Driver,4in}

Each module in a stream consists of a pair of queues: one for read (upstream) and one for write
(downstream).  Each queue is one of a pair of queues, see @figref{4}.  Where @samp{q} is one of the
queues in the pair, the paired queue is identified by @samp{OTHERQ(q)}.  Where @samp{q} is the write
queue in the pair, the read queue is identified by @samp{RD(q)}.  The read queue is for messages
ultimately read by the user.  Where @samp{q} is the read queue in the pair, the write queue is
identified by @samp{WR(q)}.  The write queue is for messages first written by the user.

@figuresized{SPG_fig04,4,Queue Pair Allocation,0.5in}

Queue functions consist of the following:

@multitable @columnfractions .20 .80
@item @command{backq(9)} @tab obtains a pointer to the previous queue in a stream
@findex backq(9)
@item @command{bcanput(9)} @tab tests for flow-control in a particular priority band
@findex bcanput(9)
@item @command{canput(9)} @tab test flow-control
@findex canput(9)
@item @command{enableok(9)} @tab marks a queue as being ready to be enabled
@findex enableok(9)
@item @command{flushband(9)} @tab removes all queued messages in a specified priority band
@findex flushband(9)
@item @command{flushq(9)} @tab removes all messages from a queue
@findex flushq(9)
@item @command{getadmin(9)} @tab finds the pointer to the @code{qi_qadmin()} function for a module
@findex getadmin(9)
@item @command{getmid(9)} @tab looks up the module identifier
@findex getmid(9)
@item @command{getq(9)} @tab gets a message from a queue
@findex getq(9)
@item @command{insq(9)} @tab inserts a message at a given point in a queue
@findex insq(9)
@item @command{noenable(9)} @tab stops a queue from being scheduled
@findex noenable(9)
@item @command{OTHERQ(9)} @tab finds the sibling of a given queue
@findex OTHERQ(9)
@item @command{putbq(9)} @tab puts back a message on a queue
@findex putbq(9)
@item @command{putctl(9)} @tab puts a control (e.g., @var{M_CTL}) message on a queue
@findex putctl(9)
@vindex M_CTL
@item @command{putctl1(9)} @tab puts a 1-byte control message on a queue
@findex putctl1(9)
@item @command{putnext(9)} @tab passes a message to the next queue in a stream
@findex putnext(9)
@item @command{putq(9)} @tab puts a message on a queue
@findex putq(9)
@item @command{qenable(9)} @tab schedule a queue
@findex qenable(9)
@item @command{qreply(9)} @tab passes a reply along a stream in the opposite direction
@findex qreply(9)
@item @command{qsize(9)} @tab returns the number of message on a queue
@findex qsize(9)
@item @command{RD(9)} @tab finds the read queue
@findex RD(9)
@item @command{rmvq(9)} @tab removes a message from the middle of a queue
@findex rmvq(9)
@item @command{strqget(9)} @tab queries the information from a queue
@findex strqget(9)
@item @command{WR(9)} @tab finds the write queue
@findex WR(9)
@end multitable

The queue open procedure is called whenever a driver special character device is opened.  It is also
called when a module is pushed onto a stream.

The queue close procedure is called when a driver special character device is closed for the last
time.  It is also called when a module is popped from a stream.

The queue put procedure is called whenever a previous queue in the stream passes a message to the
queue, or a message is otherwise placed on the queue with the @command{put(9)}
@findex put(9)
function.

The queue service procedure is called when there are messages on the queue to be serviced and the
@dfn{STREAMS} subsystem has scheduled the queue for service.

Put and service procedures must handle
@var{M_DATA},
@vindex M_DATA
@var{M_PROTO},
@vindex M_PROTO
@var{M_PCPROTO},
@vindex M_PCPROTO
@var{M_FLUSH}
@vindex M_FLUSH
and
@var{M_IOCTL}
@vindex M_IOCTL
messages.  Other messages are more or less optional.

Module put and service procedures should pass any unrecognized message types along.  Module put and
service procedures should pass any unrecognized @var{M_IOCTL}
@vindex M_IOCTL
@command{ioctl(2)} commands along.
Modules must perform canonical flushing in response to
@var{M_FLUSH}
@vindex M_FLUSH
messages.  This includes passing @var{M_FLUSH}
@vindex M_FLUSH
messages along downstream or upstream.

Driver put and service procedures should discard any unrecognized message types.  Driver put and
service procedures should negatively acknowledge (@var{M_IOCNAK})
@vindex M_IOCNAK
any unrecognized @var{M_IOCTL}
@vindex M_IOCTL
commands.
Drivers must perform canonical flushing in response to
@var{M_FLUSH}
@vindex M_FLUSH
messages.  This includes sending @var{M_FLUSH}
@vindex M_FLUSH
message that arrive on their way downstream to the upstream queues (@command{qreply(9)}).
@findex qreply(9)

Queue scheduling pertains to when a queue's service procedure is schedule to run by the kernel.
When a queue's service procedure is scheduled to run, the queue is considered enabled.  When a
queue's service routine is prohibited from running, it is considered disabled.  Only queues that
have service procedures can become enabled.  Queues with only @command{put(9)}
@findex put(9)
procedures are never enabled.

Queues are enabled whenever a priority messages is placed on the queue.  Queues are enable whenever
@command{qenable(9)}
@findex qenable(9)
is called explicitly.
Queues are also enabled as a result of back-enabling.  A queue is back-enabled when it previously
tested the next queue for flow control and found the queue flow controlled (the queue had passed its
high water mark); the queue which was previously test is now no longer flow controlled (it has
fallen below its low water mark); the queue which previously tested can now put to the queue which
was flow controlled.

Queues are disabled whenever the queue service procedure has run.  Queues are disabled whenever
@command{noenable(9)}
@findex noenable(9)
has been called explicitly.  Queues are disabled whenever they are empty.

Flow control pertains to when a queue will accept messages put to it from above and below.  When the
number of bytes in a  queue passes the high water mark associated with the queue, the queue is
considered flow controlled.  Flow controlled queues will fail a @command{canput(9)}
@findex canput(9)
call.  When the number of bytes in a flow controlled queue falls below the low water mark, the queue
is considered available to process messages again.  Only queues that have a service procedure can
become flow controlled.  Only queues that have service procedures need check for flow control
downstream.

It is the responsibility of a module performing a @command{putq(9)},
@findex putq(9)
a @command{putnext(9)}
@findex putnext(9)
or a @command{qreply(9)}
@findex qreply(9)
to a queue to check for flow control with @command{canput(9)},
@findex canput(9)
@command{canputnext(9)},
@findex canputnext(9),
@command{bcanput(9)}
@findex bcanput(9)
or
@command{bcanputnext(9)}
@findex bcanputnext(9)
before placing the message on a queue.
Modules that receive messages when they are flow controlled might discard them.
Flow control kicks in when the number of byte queued passes the queue's high water mark.

Back-enabling occurs when a queue that was previously flow controlled, drops below its low water
mark, and was tested while it was flow controlled.  Flow control can be difficult to accomplish
correctly in drivers and across multiplexers.



@dfn{STREAMS} drivers, modules and multiplexing drivers are described with a series of statically
allocated structures beginning with the driver switch table or module switch table entries.

@menu
* Stream Administration::
* Driver Switch Table::
* Module Switch Table::
* Stream Table::
* Queue Initialization::
* Module Information::
* Module Statistics::
* Stream Head::
* Queue::
* Queue Band::
* Message Block::
* Data Block::
* Data Buffer::
* User Credentials::
@end menu

@node Stream Administration
@subsection Stream Administration
@cindex Stream Administration

Some @cite{STREAMS} implementation also provide some sort of @cite{STREAMS} administration structure
that contains more specific information about a @cite{STREAMS} driver or module, such as the name of
the driver or module, synchronization, administrative flags, version, etc.  These administrative
structures are normally passed to the registration procedure to register a driver or module.
Implementations that function this way are @cite{AIX},
@cindex AIX
@cite{OSF/1},
@cindex OSF/1
@cite{HP-UX}
@cindex HP-UX
and
@cite{UnixWare}.
@cindex UnixWare

@cite{AIX}
@cindex AIX
uses the @code{strconf_t}
@tindex strconf_t
structure and calls the @command{str_install_AIX(9)}
@findex str_install_AIX(9)
registration function.
@cite{OSF/1}
@cindex OSF/1
uses the @code{streamadm(9)}
@tindex streamadm(9)
structure and calls the @command{strmod_add(9)}
@findex strmod_add(9)
and @command{strmod_del(9)}
@findex strmod_del(9)
registration functions.
@cite{HP-UX}
@cindex HP-UX
uses the @code{stream_inst(9)}
@tindex stream_inst
structure and calls the @command{str_install_HPUX(9)}
@findex str_install_HPUX(9)
and @command{str_uninstall(9)}
@findex str_uninstall(9)
registration functions.

The @file{sys/strconf.h} header file contains definitions for both the @dfn{STREAMS} administrative
structures as well as declarations and function prototypes for the registration functions.

Other @dfn{STREAMS} implementations use the character device switch table or module switch table
entries themselves.  The partially completed entry might still be passed to the registration
function like a @dfn{STREAMS} administrative structure.
Implementations that function this way are @cite{Solaris}
@cindex Solaris
and
@dfn{@value{PACKAGE_TITLE}}.
@cindex @value{PACKAGE_TITLE}

@cite{Solaris}
@cindex Solaris
uses a plethora of statically allocated structures to describe @dfn{STREAMS} drivers and modules.
Several of these structures correspond to the character device (well, character and block device)
switch table entry as well as the module switch table entry.
@cite{@value{PACKAGE_TITLE}}
@cindex @value{PACKAGE_TITLE}
uses the actual character device switch table and module switch table structures and calls the
@command{register_strdrv(9)}
@findex register_strdrv(9)
and
@command{register_strmod(9)}
@findex register_strmod(9)
registration functions.

Some implementations use a registration function alone and do not pass a structure.
Implementations that function this way are @cite{LiS}.
@cindex LiS

@cite{LiS}
@cindex LiS
simply calls the
@command{lis_register_strdrv(9)}
@findex lis_register_strdrv(9)
and
@command{lis_register_strmod(9)}
@findex lis_register_strmod(9)
registration functions.

@node Driver Switch Table
@subsection Driver Switch Table
@cindex Driver Switch Table

Each @cite{STREAMS} device or pseudo-device driver or multiplexing driver registers itself with the
@cite{STREAMS} subsystem.  Nevertheless, to allow user processes to open the @cite{STREAMS} device
requires that the device by entered into the system device switch tables.  @cite{SVR 3} had a device
switch table and many other @cite{UNIX} implementations do as well.  @b{Linux} does not use a device
switch table.  Rather it uses character device lists hashed on device number, or a file system
mechanism such as the device file system (@samp{devfs}) or @samp{udev}.  @dfn{@value{PACKAGE_TITLE}}
registers devices with the necessary @b{Linux} mechanism and then implements an internal device
switch table as a list hashed on device number.

Normally, @dfn{STREAMS} implementations have some mechanism for registering a driver with the
character device switch table or other structures used for opening @dfn{STREAMS} devices.  Some
configuration procedure take structures (e.g. @cite{Solaris}), some do not (e.g. @cite{LiS}).  Each
configuration technique is unique to that implementation.  @dfn{@value{PACKAGE_TITLE}} supports its
own registration technique as well as several of the other more common implementation methods.
@dfn{@value{PACKAGE_TITLE}} has its own registration procedure that consists of first completing a
static @code{cdevsw(9)}
@tindex cdevsw(9)
structure for entry into the @code{cdevsw_list(9)},
@tindex cdevsw_list(9)
which is @dfn{@value{PACKAGE_TITLE}}'s equivalent of a character device switch table.

The character device switch table entry structure (@code{cdevsw(9)})
@tindex cdevsw(9)
structure takes the following information:

@multitable @columnfractions .15 .85
@item @code{d_list} @tab list of all cdevsw structures
@item @code{d_hash} @tab list of module hashes in slot
@item @code{d_name} @tab driver name
@item @code{d_str} @tab pointer to streamtab for driver
@item @code{d_flag} @tab driver flags
@item @code{d_modid} @tab driver module identifier
@item @code{d_count} @tab open count
@item @code{d_sqlvl} @tab synchronization level
@item @code{d_syncq} @tab synchronization queue
@item @code{d_kmod} @tab kernel module
@item @code{d_major} @tab base major device number
@item @code{d_inode} @tab specfs inode
@item @code{d_mode} @tab inode mode
@item @code{d_fop} @tab file operations
@item @code{d_majors} @tab major device nodes for this device
@item @code{d_minors} @tab minor device nodes for this device
@item @code{d_apush} @tab autopush list
@item @code{d_plinks} @tab permanent links for this driver
@item @code{d_stlist} @tab stream head list for this driver
@end multitable

Only the driver name, @code{streamtab}
@tindex streamtab(9)
pointer, flags and synchronization level need be completed by the module writer: the remaining
fields in the @code{cdevsw}
@tindex cdevsw(9)
structure will be populated by the registration procedure.
The procedure used by @dfn{@value{PACKAGE_TITLE}} for registering @dfn{STREAMS} drivers is the
@command{register_strdrv(9)}
@findex register_strdrv(9)
kernel function.

@node Module Switch Table
@subsection Module Switch Table
@cindex Module Switch Table

Each @cite{STREAMS} module registers itself with the @cite{STREAMS} subsystem and is assigned a
unique module identification number.  Even @cite{STREAMS} device or pseudo-device driver's are
assigned a unique module identification number.  In most @cite{STREAMS} implementations, modules are
entered by module identification number into a module switch table.  @dfn{@value{PACKAGE_TITLE}}
implements an internal module switch table as a list hashed on module identifier.

Normally, @dfn{STREAMS} implementations have some mechanism for registering a module with the module
switch table or other structures used for opening @dfn{STREAMS} modules.  Some configuration
procedures take structures (e.g. @cite{Solaris}), some do not (e.g. @cite{LiS}).  Each configuration
technique is unique to that implementation.  @dfn{@value{PACKAGE_TITLE}} supports its own
configuration technique as well as several of the other more common implementation methods.
@dfn{@value{PACKAGE_TITLE}} has its own registration procedure that consists of first completing a
static @code{fmodsw(9)}
@tindex fmodsw(9)
structure for entry into the @code{fmodsw_list(9)},
@tindex fmodsw_list(9)
which is @dfn{@value{PACKAGE_TITLE}}'s equivalent of a module switch table.

The module switch table entry structure (@code{fmodsw(9)})
@tindex fmodsw(9)
structure takes the following information:

@multitable @columnfractions .15 .85
@item @code{f_list} @tab list of all fmodsw structures
@item @code{f_hash} @tab list of module hashes in slot
@item @code{f_name} @tab module name
@item @code{f_str} @tab pointer to streamtab for module
@item @code{f_flag} @tab module flags
@item @code{f_modid} @tab module identifier
@item @code{f_count} @tab open count
@item @code{f_sqlvl} @tab synchronization level
@item @code{f_syncq} @tab synchronization queue
@item @code{f_kmod} @tab kernel module
@end multitable

Only the module name, @code{streamtab}
@tindex streamtab(9)
pointer, flags and synchronization level need be completed by the module writer: the remaining
fields in the @code{fmodsw}
@tindex fmodsw(9)
structure will be populated by the registration procedure.
The procedure used by @dfn{@value{PACKAGE_TITLE}} for registering @dfn{STREAMS} modules is the
@command{register_strmod(9)}
@findex register_strmod(9)
kernel function.
It is no coincidence that the @code{fmodsw} structure is identical to the first portion of the
@code{cdevsw} structure.

@node Stream Table
@subsection Stream Table
@cindex Stream Table

Each @cite{STREAMS} driver or module has an external entry point into a streams table.  The stream
table structure is the jumping off point for all driver or module specific data structures that
describe the @cite{STREAMS} driver or module.  Each @cite{STREAMS} driver or module that is unique
within the @cite{STREAMS} subsystem has a unique stream table, regardless of which device major
numbers, module identifiers, or other external registrations have been performed on behalf of the
driver of module.

The stream table structure (@code{streamtab})
@tindex streamtab
contains the following information:

@multitable @columnfractions .15 .85
@item @code{st_rdinit} @tab read queue init structure pointer
@item @code{st_wrinit} @tab write queue init structure pointer
@item @code{st_muxrinit} @tab multiplexer lower read queue init structure pointer
@item @code{st_muxwinit} @tab multiplexer lower write queue init structure pointer
@end multitable

Only the @code{st_rdinit} and @code{st_wrinit} members need be completed for a normal module or
driver.  For a multiplexing driver that accepts the @var{I_LINK}
@vindex I_LINK
or @var{I_PLINK}
@vindex I_PLINK
commands, the lower queue initialization information, @code{st_muxrinit} and @code{st_muxwinit} must
be completed as well.

@node Queue Initialization
@subsection Queue Initialization
@cindex Queue Initialization

Each stream table (driver or module) has associated with it queue initialization information for the
upstream and downstream queues.  If the driver is a multiplexing driver, it may also have associated
with the stream table upstream and downstream queue initialization information for the lower queue
pair.

The queue initialization structure provides function pointers to the put, service, open, close and
administrative procedures for the queue to which the initialization structure belongs.  Queue
initialization structures are bound to a specific upper or lower, upstream or downstream queue using
the stream table.  Up to four queue initialization structures can exist for a driver or module, or,
it is possible that all four queues could share a single queue initialization
structures.@footnote{Only the open and close procedures indicated in the queue initialization
structure associated with an upper upstream (read) queue will be used to open and close an instance
of the driver or module.  Open and close function pointers in the other queue initialization
structures will be ignored.}

The queue initialization structure (@code{qinit(9)})
@tindex qinit(9)
contains the following information:

@multitable @columnfractions .15 .85
@item @code{qi_putp} @tab put procedure
@item @code{qi_srvp} @tab service procedure
@item @code{qi_qopen} @tab each open (read queue only)
@item @code{qi_qclose} @tab last close (read queue only)
@item @code{qi_qadmin} @tab administrative procedure (not used)
@item @code{qi_minfo} @tab module information
@item @code{qi_mstat} @tab module statistics
@end multitable

@node Module Information
@subsection Module Information
@cindex Module Information

Each queue initialization structure points to a module information structure that provides some
queueing parameters for the stream.  Nevertheless, only one module information structure is necessary
for the stream.  The module information structure contains the module identifier, the module name,
the minimum and maximum packet sizes accepted on the queue from the stream head, and the high and
low water marks for flow control.  If any of this later information needs to differ on a queue basis
(upper or lower multiplex queues considered as well), then the module information structure must be
separate for each queue.

The module information structure (@code{module_info(9)})
@tindex module_info(9)
contains the following information:

@multitable @columnfractions .15 .85
@item @code{mi_idnum} @tab module identification number
@item @code{mi_idname} @tab module name
@item @code{mi_minpsz} @tab minimum packet size accepted
@item @code{mi_maxpsz} @tab maximum packet size accepted
@item @code{mi_hiwat} @tab high water mark
@item @code{mi_lowat} @tab low water mark
@end multitable

@node Module Statistics
@subsection Module Statistics
@cindex Module Statistics

Each queue initialization structure points to an optional module statistics structure that collects
statistics for the stream.

The module statistics structure (@code{module_stat(9)})
@tindex module_stat(9)
contains the following information:

@multitable @columnfractions .15 .85
@item @code{ms_pcnt} @tab calls to @code{qi_putp}
@item @code{ms_scnt} @tab calls to @code{qi_srvp}
@item @code{ms_ocnt} @tab calls to @code{qi_qopen}
@item @code{ms_ccnt} @tab calls to @code{qi_qclose}
@item @code{ms_acnt} @tab calls to @code{qi_qadmin}
@item @code{ms_xptr} @tab module private statistics pointer
@item @code{ms_xsize} @tab size of module private statistics area
@item @code{ms_flags} @tab boolean statistics, for future use
@end multitable

@node Stream Head
@subsection Stream Head
@cindex Stream Head

A stream head is a dynamic structure that is created whenever a @cite{STREAMS} driver (stream end)
is instantiated. 

The stream head accepts the following input-output controls:

@multitable @columnfractions .20 .80
@item I_PUSH @tab push a module
@vindex I_PUSH
@item I_POP @tab pop a module
@vindex I_POP
@item I_SETSIG @tab receive a @var{SIGPOLL} signal when an event occurs
@vindex I_SETSIG
@item I_FDINSERT @tab pass informationa about a stream
@vindex I_FDINSERT
@item I_STR @tab generate an @command{ioctl(2)} to a streams module
@vindex I_STR
@item I_SENDFD @tab send a file descriptor down a stream
@vindex I_SENDFD
@item I_LINK @tab link a stream under a multiplexer
@vindex I_LINK
@item I_PLINK @tab permanently link a stream under a multiplexer
@vindex I_PLINK
@item I_LOOK @tab get name of module below stream head
@vindex I_LOOK
@item I_FLUSH @tab flush a stream
@vindex I_FLUSH
@item I_FLUSHBAND @tab flush a stream in a given band
@vindex I_FLUSHBAND
@item I_GETSIG @tab return events that generate @var{SIGPOLL}
@vindex I_GETSIG
@item I_FIND @tab find a particular module in a stream
@vindex I_FIND
@item I_PEEK @tab read first message on a stream
@vindex I_PEEK
@item I_SRDOPT @tab set read options
@vindex I_SRDOPT
@item I_GRDOPT @tab get read options
@vindex I_GRDOPT
@item I_SWROPT @tab set write options
@vindex I_SWROPT
@item I_GWROPT @tab get write options
@vindex I_GWROPT
@item I_RECVFD @tab retrieve a passed file descriptor 
@vindex I_RECVFD
@item I_LIST @tab list all modules in a stream
@vindex I_LIST
@item I_ATMARK @tab see if stream head message has been marked
@vindex I_ATMARK
@item I_CKBAND @tab check if message of a particular band is writable
@vindex I_CKBAND
@item I_GETBAND @tab get priority band of first message at stream head
@vindex I_GETBAND
@item I_CANPUT @tab cehck if given band is writable
@vindex I_CANPUT
@item I_SETCLTIME @tab set the time that @dfn{STREAMS} will wait while closing
@vindex I_SETCLTIME
@item I_GETCLTIME @tab get the time that @dfn{STREAMS} will wait while closing
@vindex I_GETCLTIME
@item I_UNLINK @tab unlink a stream from beneath a multiplexer
@vindex I_UNLINK
@item I_PUNLINK @tab unlink a permanent stream from beneath a multiplexer
@vindex I_PUNLINK
@end multitable

@multitable @columnfractions .20 .80
@item @var{SO_ALL} @tab set all old options
@vindex SO_ALL
@item @var{SO_READOPT} @tab set read option
@vindex SO_READOPT
@item @var{SO_WROFF} @tab set write offset
@vindex SO_WROFF
@item @var{SO_MINPSZ} @tab set minimum packet size
@vindex SO_MINPSZ
@item @var{SO_MAXPSZ} @tab set maximum packet size
@vindex SO_MAXPSZ
@item @var{SO_HIWAT} @tab set high water mark
@vindex SO_HIWAT
@item @var{SO_LOWAT} @tab set low water mark
@vindex SO_LOWAT
@item @var{SO_MREADON} @tab set read notification on
@vindex SO_MREADON
@item @var{SO_MREADOFF} @tab set read notification off
@vindex SO_MREADOFF
@item @var{SO_NDELON} @tab old TTY semantics for NDELAY reads and writes
@vindex SO_NDELON
@item @var{SO_NDELOFF} @tab STREAMS semantics for NDELAY reads and writes
@vindex SO_NDELOFF
@item @var{SO_ISTTY} @tab the stream is acting as a terminal
@vindex SO_ISTTY
@item @var{SO_ISNTTY} @tab the stream is not acting as a terminal
@vindex SO_ISNTTY
@item @var{SO_TOSTOP} @tab stop on background writes to this stream
@vindex SO_TOSTOP
@item @var{SO_TONSTOP} @tab do not stop on background writes to this stream
@vindex SO_TONSTOP
@item @var{SO_BAND} @tab water marks affect band
@vindex SO_BAND
@item @var{SO_DELIM} @tab messages are delimited
@vindex SO_DELIM
@item @var{SO_NODELIM} @tab turn off delimiters
@vindex SO_NODELIM
@item @var{SO_STRHOLD} @tab @cite{UnixWare} and @cite{Solaris} only: enable strwrite message coalescing
@vindex SO_STRHOLD
@item @var{SO_ERROPT} @tab @cite{Solaris} only
@vindex SO_ERROPT
@item @var{SO_LOOP} @tab @cite{UnixWare} only
@vindex SO_LOOP
@item @var{SO_COPYOPT} @tab @cite{Solaris} only: user io copy options
@vindex SO_COPYOPT
@item @var{SO_MAXBLK} @tab @cite{Solaris} only: maximum block size
@vindex SO_MAXBLK
@end multitable

@multitable @columnfractions .20 .80
@item @var{IOCWAIT} @tab ioctl in progress
@vindex IOCWAIT
@item @var{RSLEEP} @tab process sleeping on read
@vindex RSLEEP
@item @var{WSLEEP} @tab process sleeping on write
@vindex WSLEEP
@item @var{STRPRI} @tab priority message waiting
@vindex STRPRI
@item @var{STRHUP} @tab stream is hung up
@vindex STRHUP
@item @var{STWOPEN} @tab strem head open in progress
@vindex STWOPEN
@item @var{STPLEX} @tab stream linked under mux
@vindex STPLEX
@item @var{STRISTTY} @tab stream is a terminal
@vindex STRISTTY
@item @var{STRDERR} @tab M_ERROR for read received
@vindex STRDERR
@item @var{STWRERR} @tab M_ERROR for write received
@vindex STWRERR
@item @var{STRCLOSE} @tab wait for strclose to complete
@vindex STRCLOSE
@item @var{SNDMREAD} @tab send M_READ msg when read issued
@vindex SNDMREAD
@item @var{STRHOLD} @tab coallese written messages
@vindex STRHOLD
@item @var{STRMSIG} @tab M_SIG at head of queue
@vindex STRMSIG
@item @var{STRDELIM} @tab generate delimited messages
@vindex STRDELIM
@item @var{STRTOSTOP} @tab stop timeout
@vindex STRTOSTOP
@item @var{STRISFIFO} @tab stream is a fifo
@vindex STRISFIFO
@item @var{STRISPIPE} @tab stream is a STREAMS pipe
@vindex STRISPIPE
@item @var{STRISSOCK} @tab stream is a STREAMS socket
@vindex STRISSOCK
@item @var{STFROZEN} @tab stream is frozen
@vindex STFROZEN
@end multitable

@node Queue
@subsection Queue
@cindex Queue

A pair of queues are allocated, initialized, assigned and linked into a stream each time that a
@cite{STREAMS} driver or module is instantiated.  A pointer to the upstream (read) queue in the
queue pair is the common method for passing a handle to a driver or module instance.

@node Queue Band
@subsection Queue Band
@cindex Queue Band

Queue bands are allocated and initialized in association with queues on demand.  Many @cite{STREAMS}
drivers or modules never have queue bands allocated because they do not pass priority banded
messages, only normal messages.

@node Message Block
@subsection Message Block
@cindex Message Block

A message block is a structure that references a data block and data buffer.  Each message block is
a view into a data buffer and has a start (read pointer) and finish (write pointer) within the
buffer.  Message block can be chained together to form larger segmented messages.

@node Data Block
@subsection Data Block
@cindex Data Block

Data blocks are a description of a data buffer external to the buffer itself.  Each data block
describes the limits of the data buffer, its base, and size.  Each data block also hold a number of
flags and contains a data block type describing the type of data contained in the data buffer.  Data
blocks also contain any necessary information concerning the functions and arguments necessary to
free the data buffer.  Also, data blocks maintain reference counts of the number of message blocks
that reference the data buffer.

@subsubsection Data Block Types
@cindex Data Block Types

@node Data Buffer
@subsection Data Buffer
@cindex Data Buffer

Data buffers can be allocated within the @cite{STREAMS} buffer pools using the @command{allocb(9)}
@findex allocb(9)
function or can be allocated externally and associated with a data and message block using the
@command{esballoc(9)}
@findex esballoc(9)
function.

@node User Credentials
@subsection User Credentials
@cindex User Credentials

@node Application Interface
@section Application Interface
@cindex @cite{STREAMS}, application interface
@cindex application interface, @cite{STREAMS}

@subsection System Calls

@multitable @columnfractions .20 .80
@item @command{close(2)} @tab --
@findex close(2)
@item @command{fattach(2)} @tab --
@findex fattach(2)
@item @command{fcntl(2)} @tab --
@findex fcntl(2)
@item @command{fdetach(2)} @tab --
@findex fdetach(2)
@item @command{getmsg(2)} @tab --
@findex getmsg(2)
@item @command{getpmsg(2)} @tab --
@findex getpmsg(2)
@item @command{ioctl(2)} @tab --
@findex ioctl(2)
@item @command{isastream(2)} @tab --
@findex isastream(2)
@item @command{open(2)} @tab --
@findex open(2)
@item @command{pipe(2)} @tab --
@findex pipe(2)
@item @command{poll(2)} @tab --
@findex poll(2)
@item @command{putmsg(2)} @tab --
@findex putmsg(2)
@item @command{putpmsg(2)} @tab --
@findex putpmsg(2)
@item @command{read(2)} @tab --
@findex read(2)
@item @command{readv(2)} @tab --
@findex readv(2)
@item @command{select(2)} @tab --
@findex select(2)
@item @command{write(2)} @tab --
@findex write(2)
@item @command{writev(2)} @tab --
@findex writev(2)
@end multitable

@node Kernel Level Facilities
@section Kernel Level Facilities
@cindex kernel level facilities
@cindex @cite{STREAMS}, kernel level facilities
@cindex kernel level facilities, @cite{STREAMS}

@subsection Stream Head

@subsection Modules

@subsection Drivers

@subsection Messages

@figuresized{SPG_fig05,5,A Message,5in}

@figuresized{SPG_fig06,6,Messages on a Message Queue,5in}

@subsubsection Message Types

@subsubheading Normal Messages

@multitable @columnfractions .20 .05 .05 .70
@item M_DATA
@vindex M_DATA
@tab D @tab U @tab Normal data.
@item M_PROTO
@vindex M_PROTO
@tab D @tab U @tab Normal protocol information.
@item M_BREAK
@vindex M_BREAK
@tab D @tab -- @tab Break request.
@item M_PASSFP
@vindex M_PASSFP
@tab D @tab U @tab Passed file pointer.
@item M_EVENT
@vindex M_EVENT
@tab -- @tab U @tab Normal event.  (@cite{Solaris} only)
@item M_SIG
@vindex M_SIG
@tab -- @tab U @tab Signal.
@item M_DELAY
@vindex M_DELAY
@tab D @tab -- @tab Delay request.
@item M_CTL
@vindex M_CTL
@tab D @tab U @tab Normal inter-module control message.
@item M_IOCTL
@vindex M_IOCTL
@tab D @tab -- @tab Input-Output control.
@item M_SETOPTS
@vindex M_SETOPTS
@tab -- @tab U @tab Normal set queue options.
@item M_RSE
@vindex M_RSE
@tab D @tab U @tab Normal reserved.
@item M_TRAIL
@vindex M_TRAIL
@tab -- @tab -- @tab (@cite{UnixWare} only)
@item M_BACKWASH
@vindex M_BACKWASH
@tab D @tab -- @tab (@cite{AIX} only)
@end multitable

@subsubheading Priority Messages

@multitable @columnfractions .20 .05 .05 .70
@item M_IOCACK
@vindex M_IOCACK
@tab -- @tab U @tab Input-Output control acknowledgement (result).
@item M_IOCNAK
@vindex M_IOCNAK
@tab -- @tab U @tab Input-Output control negative acknowledgement (error).
@item M_PCPROTO
@vindex M_PCPROTO
@tab D @tab U @tab Priority protocol information.
@item M_PCSIG
@vindex M_PCSIG
@tab -- @tab U @tab Priority signal.
@item M_READ
@vindex M_READ
@tab D @tab -- @tab Read request.
@item M_FLUSH
@vindex M_FLUSH
@tab D @tab U @tab Flush queue request.
@item M_STOP
@vindex M_STOP
@tab D @tab -- @tab Stop output request.
@item M_START
@vindex M_START
@tab D @tab -- @tab Start output request.
@item M_HANGUP
@vindex M_HANGUP
@tab -- @tab U @tab Hangup.
@item M_ERROR
@vindex M_ERROR
@tab -- @tab U @tab Fatal error.
@item M_COPYIN
@vindex M_COPYIN
@tab -- @tab U @tab Input-Output control copyin request.
@item M_COPYOUT
@vindex M_COPYOUT
@tab -- @tab U @tab Input-Output control copyout request.
@item M_IOCDATA
@vindex M_IOCDATA
@tab D @tab -- @tab Input-Output control copied in data.
@item M_PCRSE
@vindex M_PCRSE
@tab D @tab U @tab Priority reserved.
@item M_STOPI
@vindex M_STOPI
@tab D @tab -- @tab Stop input request.
@item M_STARTI
@vindex M_STARTI
@tab D @tab -- @tab Start input request.
@item M_PCCTL
@vindex M_PCCTL
@tab D @tab U @tab Priority inter-module control message.  (@cite{UnixWare} only)
@item M_PCSETOPTS
@vindex M_PCSETOPTS
@tab -- @tab U @tab Priority set queue options.  (@cite{UnixWare} only)
@item M_PCEVENT
@vindex M_PCEVENT
@tab -- @tab U @tab Priority event.  (@cite{Solaris} only)
@item M_UNHANGUP
@vindex M_UNHANGUP
@tab -- @tab U @tab Hangup corrected.  (@cite{Solaris} and @cite{OSF/1} only)
@item M_NOTIFY
@vindex M_NOTIFY
@tab -- @tab U @tab (@cite{OSF/1} and @cite{HP-UX} only)
@item M_HPDATA
@vindex M_HPDATA
@tab D @tab U @tab (@cite{HP-UX} and @cite{MacOT} only)
@item M_LETSPLAY
@vindex M_LETSPLAY
@tab -- @tab U @tab (@cite{AIX} only)
@item M_DONTPLAY
@vindex M_DONTPLAY
@tab D @tab -- @tab (@cite{AIX} only)
@item M_BACKDONE
@vindex M_BACKDONE
@tab D @tab -- @tab (@cite{AIX} only)
@end multitable

@subsection Message Queueing Priority

@subsection Queues

@subsection Multiplexing

@subsection Multithreading

@node Subsystems
@section Subsystems
@cindex subsystems, STREAMS
@cindex STREAMS, subsystems

@menu
* Logging::			STREAMS Logging
* Administrative Driver::	STREAMS Administrative Driver
* Terminal I/O::		STREAMS Terminal I/O
* Pipes::			STREAMS Pipes
* FIFOs::			STREAMS FIFOs
* Networking::			STREAMS Networking
@end menu

@node Logging
@subsection Logging
@cindex logging, STREAMS
@cindex STREAMS, logging

The kernel logger and system logger on a @b{Linux} system is the native logging implementation.
These are BSD-style loggers.  @dfn{@value{PACKAGE_TITLE}} provides a @dfn{STREAMS}-based logger as
well.  The advantage of a @dfn{STREAMS}-based logger is for trace and error logging @dfn{STREAMS}
drivers and modules using the @command{strlog} facility.  This facility includes a device driver
(the @dfn{STREAMS} log device, @command{log(4)}),
@pgindex log(4)
a kernel function (@command{strlog(9)}),
@findex strlog(9)
and two user space daemon processes (@command{strace(8)}
@pgindex strace(8)
and @command{strerr(8)}).
@pgindex strerr(8)
The @dfn{STREAMS} logger has the unique capability that it can filter trace messages and only incur
the cost of tracing and logging those messages that are filtered out (at the kernel level).  This
allows a large degree of trace logging to be available, yet, only a small proportion of the
available trace messages generated to logs.

The @dfn{STREAMS} logger @command{log(4)},
@pgindex log(4)
@command{strlog(9)}
@findex strlog(9)
command, and @command{strace(8)}
@pgindex strace(8)
and @command{strerr(8)}
@pgindex strerr(8)
loggers are all available in the base @code{@value{PACKAGE}-@value{VERSION}} package.@footnote{I
have been considering removing these facilities into a common @code{strutil-0.7a.1} package that
could work with @cite{LiS} as well, perhaps.}

@node Administrative Driver
@subsection Administrative Driver
@cindex administrative driver, STREAMS
@cindex STREAMS, administrative driver

@dfn{@value{PACKAGE_TITLE}} provides a @dfn{STREAMS} administration facility.  This facility
consists of a driver (the @dfn{STREAMS Administrative Driver}, @command{sad(4)}),
@pgindex sad(4)
several autopush kernel functions (@command{autopush_add(9)},
@findex autopush_add(9)
@command{autopush_del(9)},
@findex autopush_del(9)
@command{autopush_find(9)},
@findex autopush_find(9)
@command{autopush_vml(9)}),
@findex autopush_vml(9)
and the @command{autopush(8)},
@pgindex autopush(8)
@command{insf(8)},
@pgindex insf(8)
@command{strload(8)},
@pgindex strload(8)
@command{strsetup(8)},
@pgindex strsetup(8)
@command{strinfo(8)},
@pgindex strinfo(8)
@command{scls(8)}
@pgindex scls(8)
and other administrative commands.

@node Terminal I/O
@subsection Terminal I/O
@cindex terminal i/o, STREAMS
@cindex STREAMS, terminal i/o

By default, terminal I/O in a @b{Linux} system does not use @cite{STREAMS}.  It, in fact, uses a
@cite{STREAMS} @samp{pty} emulation.  However, this is only an emulation and does not provide all
@cite{STREAMS} facilities.  It is not possible, for example, on a @b{Linux} @samp{pty} to push or
pop modules from a terminal.  The @b{Linux} @samp{pty} only provides emulation for read/write and
ioctl calls.

A separate auxiliary package for @dfn{@value{PACKAGE_TITLE}} that provides true @cite{STREAMS}-based
@cite{UNIX'98} compliant pseudo terminals is available.  This is the @code{strpty-0.7a.1} package
also available from @url{http://www.openss7.org/, The OpenSS7 Project}.@footnote{Actually, this
package is not yet avilable.  I will work on it someday when it is necessary.}

There are three user commands available in the @dfn{@value{PACKAGE_TITLE}} package that are useful
for terminal input-output: these are the
@command{strchg(1)}
@pgindex strchg(1)
@command{strconf(1)}
@pgindex strconf(1)
and
@command{strreset(1)}
@pgindex strreset(1)
user commands.

@node Pipes
@subsection Pipes
@cindex pipes, STREAMS
@cindex STREAMS, pipes

@dfn{@value{PACKAGE_TITLE}} supports @cite{STREMS}-based pipes as an optional feature.
@cite{STREAMS}-based pipes operate as described in the @cite{UNIX SVR4.2 Operating System API
Reference} and the @cite{UNIX System V Release 4 Programmer's Guide: STREAMS}.

By default, pipes created on @b{Linux} by the @manpage{pipe(2)} system call are not
@cite{STREAMS}-based.  To get @cite{STREAMS}-based pipes, configure @dfn{Linux Fast-STREAMS} with
configuration parameter @code{--enable-streams-fifos}.

@dfn{@value{PACKAGE_TITLE}} also provides a character device based pipe facility using the
@manpage{spx(4)} driver.
@footnote{I am considering taking pipes and FIFOs out of the base
@code{@value{PACKAGE}-@value{VERSION}} package an placing them in their own @code{strpipe-0.7a.1}
package.}

@node FIFOs
@subsection FIFOs
@cindex FIFOs, STREAMS
@cindex STREAMS, FIFOs

@dfn{@value{PACKAGE_TITLE}} supports @cite{STREAMS}-based FIFOs (named pipes) as an optional feature.
@cite{STREAMS}-based FIFOs operate as described in the @cite{UNIX SVR4.2 Operating System API
Reference} and the @cite{UNIX System V Release 4 Programmer's Guide: STREAMS}.

By default, FIFOs created on @b{Linux} with the
@manpage{mknod(8)}
@pgindex mknod(8)
utility are not @cite{STREAMS}-based.  To get @cite{STREAMS}-based FIFOs, configure @dfn{Linux
Fast-STREAMS} with configuration parameter @code{--enable-streams-fifos}.
@footnote{I am considering taking pipes and FIFOs out of the base
@code{@value{PACKAGE}-@value{VERSION}} package an placing them in their own @code{strpipe-0.7a.1}
package.}

@node Networking
@subsection Networking
@cindex networking, STREAMS
@cindex STREAMS, networking

By default, networking in a @b{Linux} system does not use @cite{STREAMS}.  It uses the native Linux
@dfn{BSD Sockets} approach.  Some @b{GNU/Linux} distributions do provide an @cite{iBCS (Intel Binary
Compatibility Suite)}
@cindex iBCS
@cindex Intel Binary Compatibility Suite
that provides XTI/TLI networking, however, this is only a @dfn{STREAMS} emulation and cannot push or
pop protocol modules from a stream.  Also, @b{Linux} @cite{iBCS} only provides emulation for
read/write and ioctl calls.

A separate auxiliary package for @dfn{@value{PACKAGE_TITLE}} that provides a true
@cite{STREAMS}-based @cite{UNIX'98} compliant XTI/TLI library is available.  This is the
@code{strxnet-0.9.2.5} package
also available from @url{http://www.openss7.org/, The OpenSS7 Project}.

To be able to open INET streams also requires the @code{strinet-0.9.2.1} package
also available from @url{http://www.openss7.org/, The OpenSS7 Project}.  This package provides
@dfn{STREAMS}-based networking by providing a specialized @dfn{STREAMS} driver that internally opens
a @b{Linux} native @dfn{BSD Socket} and translates @dfn{STREAMS} messages to and from the internal
@dfn{Socket}.

@node Mechanism
@chapter STREAMS Mechanism
@cindex mechanism
@menu
* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction
@end menu

@node Mechanism Overview
@section STREAMS Mechanism Overview
@cindex mechanism overview

This chapter shows how to construct, use, and dismantle a @dfn{Stream} using @dfn{STREAMS}-related
systems calls.  General and @dfn{STREAMS}-specific system calls provide the user level facilities
required to implement application programs.  This system call interface is upwardly compatible with
the traditional character I/O facilities.  The @manpage{open(2)} system call will recognize a
@dfn{STREAMS} file and create a @dfn{Stream} to the specified driver.  A user process can receive
and send data on @dfn{STREAMS} files using @manpage{read(2)} and @manpage{write(2)} in the same
manner as with traditional character files.  The @manpage{ioctl(2)} system call enables users to
perform functions specific to a particular device.  @dfn{STREAMS} ioctl commands [see
@manpage{streamio(7)}] support a variety of functions for accessing and controlling @dfn{Streams}.
The last @manpage{close(2)} in a @dfn{Stream} will dismantle a @dfn{Stream}.

In addition to the traditional @command{ioctl} commands and system calls, there are other system
calls used by @dfn{STREAMS}.  The @manpage{poll(2)} system call enables a user to poll multiple
@dfn{Streams} for various events.  The @manpage{putmsg(2)} and @manpage{getmsg(2)} system calls
enable users to send and receive @dfn{STREAMS} messages, and are suitable for interacting with
@dfn{STREAMS} modules and drivers through a service interface.

@dfn{STREAMS} provides kernel facilities and utilities to support development of modules and
drivers.  The @dfn{Stream} head handles most system calls so that the related processing does not
have to be incorporated in a module or driver.

@subsection STREAMS System Calls

The @dfn{STREAMS}-related system calls are:

@table @manpage
@item open(2)
Open a @dfn{Stream}
@item close(2)
Close a @dfn{Stream}
@item read(2)
Read data from a @dfn{Stream}
@item write(2)
Write data to a @dfn{Stream}
@item ioctl(2)
Control a @dfn{Stream}
@item getmsg(2)
Receive a message at the @dfn{Stream head}
@item putmsg(2)
Send a message downstream
@item poll(2)
Notify the application program when selected events occur on a @dfn{Stream}
@item pipe(2)
Create a channel that provides a communication path between multiple processes.
@end table

@node Stream Construction
@section STREAMS Stream Construction
@cindex stream construction

@dfn{STREAMS} constructs a @dfn{Stream} as a linked list of kernel resident data structures.  The
list is created as a set of linked queue pairs.  The first queue pair is the head of the
@dfn{Stream} and the second queue pair is the end of the @dfn{Stream}.  The end of the @dfn{Stream}
represents a device driver, pseudo device driver, or the other end of a @dfn{STREAMS}-based pipe.
Kernel routines interface with the @dfn{Stream head} to perform operations on the @dfn{Stream}.
@figref{13} depicts the upstream (read) and downstream (write) portions of the @dfn{Stream}.  Queue
@samp{H2} is the upstream half of the @dfn{Stream head} and queue @samp{H1} is the downstream half
of the @dfn{Stream head}.  Queue @samp{E2} is the upstream half of the @dfn{Stream end} and queue
@samp{E1} is the downstream half of the @dfn{Stream end}.

@figuresized{SPG_fig13,13,Upstream and Downstream @dfn{Stream} Construction,2.5in}

At the same relative location in each queue is the address of the entry point, a procedure to
process any message received by that queue.  The procedure for queues @samp{H1} and @samp{H2}
process messages sent to the @dfn{Stream head}.  The procedure for queues @samp{E1} and @samp{E2},
process messages received by the other end of the @dfn{Stream}, the @dfn{Stream end} (tail).
Messages move from one end to the other, from one queue to the next linked queue, as the procedure
specified by that queue is executed.

@figref{14} the data structures forming each queue: @code{queue}, @code{qinit}, @code{qband},
@code{module_info}, and @code{module_stat}.  The @code{qband} structures have information for each
priority band in the queue.  The queue data structure contains various modifiable values for that
queue.  The @code{qinit} structure contains a pointer to the processing procedures, the
@code{module_info} structure contains initial limit values, and the @code{module_stat} structure is
used for statistics gathering.  Each queue in the queue pair contains a different set of these data
structures.  There is a @code{queue}, @code{qinit}, @code{module_info}, and @code{module_stat} data
structure for the upstream portion of the queue pair and a set of data structures for the downstream
portion of the pair.  In some situations, a queue pair may share some or all of the data structures.
For example, there may be a separate @code{qinit} structure for each queue in the pair and one
@code{module_stat} structure that represents both queues in the pair.  These data structures are
described in @ref{STREAMS Data Structures}.

@figuresized{SPG_fig14,14,@dfn{Stream} Queue Relationship,5.5in}

@figref{14} shows two neighboring queue pairs with links (solid vertical arrows) in both directions.
When a module is pushed onto a @dfn{Stream}, @dfn{STREAMS} creates a queue pair and links each queue
in the pair to its neighboring queue in the upstream and downstream direction.  The linkage allows
each queue to locate its next neighbor.  This relation is implemented between adjacent queue pairs
by the @var{q_next} pointer.  Within a queue pair, each queue locates its mate (see dashed arrows in
@figref{14}) by use of @dfn{STREAMS} macros, since there is no pointer between the two queues.  The
existence of the @dfn{Stream head} and @dfn{Stream end} is known to the queue procedures only as
destinations towards which messages are sent.

@page
@subsection Opening a STREAMS Device File

One way to construct a @dfn{Stream} is to open [see open(2)] a STREAMS-based driver file (see
[7]Figure:2.3 [8]Opened STREAMS-based Driver).  All entry points into the driver are defined by the
streamtab structure for that driver.  The streamtab structure has a format as follows:

@smallexample
struct streamtab @{
    struct qinit *st_rdinit;
    struct qinit *st_wrinit;
    struct qinit *st_muxrinit;
    struct qinit *st_muxwinit;
@};
@end smallexample

The @code{streamtab} structure defines a module or driver.  @var{st_rdinit} points to the read
@code{qinit} structure for the driver and @var{st_wdinit} points to the driver's write @code{qinit}
structure.  @var{st_muxrinit} and @var{st_muxwinit} point to the lower read and write @code{qinit}
structures if the driver is a multiplexor driver.

If the @command{open} call is the initial file open, a @dfn{Stream} is created.  (There is one
@dfn{Stream} per major/minor device pair.)  First, an entry is allocated in the user's file table
and a @dfn{vnode} is created to represent the opened file.  The file table entry is initialized to
point to the allocated @dfn{vnode} (see @var{f_vnode} in @figref{15}) and the @dfn{vnode} is
initialized to specify a file of type character special.

Second, a @dfn{Stream header} is created from an @code{stdata} data structure and a @dfn{Stream
head} is created from a pair of @code{queue} structures.  The content of @code{stdata} and
@code{queue} are initialized with predetermined values, including the @dfn{Stream head} processing
procedures.

The @dfn{snode} contains the file system dependent information.  It is associated with the
@dfn{vnode} representing the device.  The @var{s_commonvp} field of the @dfn{snode} points to the
common device @dfn{vnode}.  The @dfn{vnode} field, @var{v_data}, contains a pointer to the
@dfn{snode}.  Instead of maintaining a pointer to the @dfn{vnode}, the @dfn{snode} contains the
@dfn{vnode} as an element.  The @var{sd_vnode} field of @code{stdata} is initialized to point to the
allocated @dfn{vnode}.  The @var{v_stream} field of the @dfn{vnode} data structure is initialized to
point to the @dfn{Stream header}, thus there is a forward and backward pointer between the
@dfn{Stream header} and the @dfn{vnode}.  There is one @dfn{Stream header} per @dfn{Stream}.  The
header is used by @dfn{STREAMS} while performing operations on the @dfn{Stream}.  In the downstream
portion of the @dfn{Stream}, the @dfn{Stream header} points to the downstream half of the
@dfn{Stream head} queue pair.  Similarly, the upstream portion of the @dfn{Stream} terminates at the
@dfn{Stream header}, since the upstream half of the @dfn{Stream head} queue pair points to the
header.  As shown in @figref{15}, from the @dfn{Stream header} onward, a @dfn{Stream} is constructed
of linked queue pairs.

@figuresized{SPG_fig15,15,Opened @dfn{STREAMS}-based Driver,4in}

Next, a @code{queue} structure pair is allocated for the driver.  The queue limits are initialized
to those values specified in the corresponding @code{module_info} structure.  The queue processing
routines are initialized to those specified by the corresponding @code{qinit} structure.

Then, the @var{q_next} values are set so that the @dfn{Stream head} write queue points to the driver
write queue and the driver read queue points to the @dfn{Stream head} read queue.  The @var{q_next}
values at the ends of the @dfn{Stream} are set to @var{NULL}.  Finally, the driver open procedure
(located via its read @code{qinit} structure) is called.

If this @command{open} is not the initial open of this @dfn{Stream}, the only actions performed are
to call the driver @command{open} and the @command{open} procedures of all pushable modules on the
@dfn{Stream}.  When a @dfn{Stream} is already open, further opens of the same device will result in
the @command{open} routines of all modules and the driver on the @dfn{Stream} being called.  Note
that this is in reverse order from the way a @dfn{Stream} is initially set up.  That is, a driver is
opened and a module is pushed on a @dfn{Stream}.  When a push occurs the module @command{open}
routine is called.  If another open of the same device is made, the @command{open} routine of the
module will be called followed by the @command{open} routine of the driver.  This is opposite from
the initial order of opens when the @dfn{Stream} is created.

@page
@subsection Creating a STREAMS-based Pipe

In addition to opening a @dfn{STREAMS}-based driver, a @dfn{Stream} can be created by creating a
pipe [see @manpage{pipe(2)}].  Since pipes are not character devices, @dfn{STREAMS} creates and
initializes a @code{streamtab} structure for each end of the pipe.  As with modules and drivers, the
@code{streamtab} structure defines the pipe.  The @var{st_rdinit}, however, points to the read
@code{qinit} structure for the @dfn{Stream head} and not for a driver.  Similarly, the
@var{st_wdinit} points to the @dfn{Stream head's} write @code{qinit} structure and not to a driver.
The @var{st_muxrinit} and @var{st_muxwinit} are initialized to null since a pipe cannot be a
multiplexor driver.

When the pipe system call is executed, two @dfn{Streams} are created.  @dfn{STREAMS} follows the
procedures similar to those of opening a driver; however, duplicate data structures are created.
That is, two entries are allocated in the user's file table and two @dfn{vnodes} are created to
represent each end of the pipe, as shown in @figref{16}.  The file table entries are initialized to
point to the allocated @dfn{vnodes} and each @dfn{vnode} is initialized to specify a file of type
@dfn{FIFO}.

Next, two @dfn{Stream headers} are created from @code{stdata} data structures and two @dfn{Stream
heads} are created from two pairs of @code{queue} structures.  The content of @code{stdata} and
@code{queue} are initialized with the same values for all pipes.

Each @dfn{Stream header} represents one end of the pipe and it points to the downstream half of each
@dfn{Stream head} queue pair.  Unlike @dfn{STREAMS}-based devices, however, the downstream portion
of the @dfn{Stream} terminates at the upstream portion of the other @dfn{Stream}.

@figuresized{SPG_fig16,16,Creating @dfn{STREAMS}-based Pipe,5.5in}

The @var{q_next} values are set so that the @dfn{Stream head} write queue points to the @dfn{Stream
head} read queue on the other side.  The @var{q_next} values for the @dfn{Stream head's} read queue
points to null since it terminates the @dfn{Stream}.

@subsection Adding and Removing Modules

As part of constructing a @dfn{Stream}, a module can be added (pushed) with an @command{ioctl}
@var{I_PUSH} [see @manpage{streamio(7)}] system call.  The push inserts a module beneath the
@dfn{Stream head}.  Because of the similarity of @dfn{STREAMS} components, the push operation is
similar to the driver open.  First, the address of the @code{qinit} structure for the module is
obtained.

Next, @dfn{STREAMS} allocates a pair of @code{queue} structures and initializes their contents as in
the driver open.

Then, @var{q_next} values are set and modified so that the module is interposed between the
@dfn{Stream} head and its neighbor immediately downstream.  Finally, the module @command{open}
procedure (located via @code{qinit}) is called.

Each push of a module is independent, even in the same @dfn{Stream}.  If the same module is pushed
more than once on a @dfn{Stream}, there will be multiple occurrences of that module in the
@dfn{Stream}.  The total number of pushable modules that may be contained on any one @dfn{Stream} is
limited by the kernel parameter @var{NSTRPUSH} (@pxref{Configuration}).

An @command{ioctl} @var{I_POP} [see @manpage{streamio(7)}] system call removes (pops) the module
immediately below the @dfn{Stream} head.  The pop calls the module @command{close} procedure.  On
return from the module @command{close}, any messages left on the module's message queues are freed
(deallocated).  Then, @dfn{STREAMS} connects the @dfn{Stream head} to the component previously below
the popped module and deallocates the module's @code{queue} pair.  @var{I_PUSH} and @var{I_POP}
enable a user process to dynamically alter the configuration of a @dfn{Stream} by pushing and
popping modules as required.  For example, a module may be removed and a new one inserted below the
@dfn{Stream} head.  Then the original module can be pushed back after the new module has been
pushed.

@subsection Closing the Stream

The last close to a @dfn{STREAMS} file dismantles the @dfn{Stream}.  Dismantling consists of popping
any modules on the @dfn{Stream} and closing the driver.  Before a module is popped, the close may
delay to allow any messages on the write message queue of the module to be drained by module
processing.  Similarly, before the driver is closed, the close may delay to allow any messages on
the write message queue of the driver to be drained by driver processing.  If @var{O_NDELAY} (or
@var{O_NONBLOCK}) [see @manpage{open(2)}] is clear, close will wait up to @samp{15} seconds for each
module to drain and up to @samp{15} seconds for the driver to drain.  If @var{O_NDELAY} (or
@var{O_NONBLOCK}) is set, the pop is performed immediately and the driver is closed without delay.
Messages can remain queued, for example, if flow control is inhibiting execution of the write queue
service procedure.  When all modules are popped and any wait for the driver to drain is completed,
the driver @command{close} routine is called.  On return from the driver @command{close}, any
messages left on the driver's queues are freed, and the @code{queue} and @code{stdata} structures
are deallocated.

@dfn{STREAMS} frees only the messages contained on a message queue.  Any message or data structures
used internally by the driver or module must be freed by the driver or module @command{close}
procedure.

Finally, the user's @dfn{file table} entry and the @dfn{vnode} are deallocated and the @dfn{file} is
closed.

@subsection Stream Construction Example

The following example extends the previous communications device echoing example (@pxref{Basic
Streams Operations}) by inserting a module in the Stream.  The (hypothetical) module in this example
can convert (change case, delete, duplicate) selected alphabetic characters.

@subsubsection Inserting Modules


An advantage of @dfn{STREAMS} over the traditional character I/O mechanism stems from the ability to
insert various modules into a @dfn{Stream} to process and manipulate data that pass between a user
process and the driver.  In the example, the character conversion module is passed a command and a
corresponding string of characters by the user.  All data passing through the module are inspected
for instances of characters in this string; the operation identified by the command is performed on
all matching characters.  The necessary declarations for this program are shown below:

@smallexample
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/uio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stropts.h>

#define   BUFLEN      1024

/*
 *  These defines would typically be
 *  found in a header file for the module
 */
#define   XCASE       1         /* change alphabetic case of char */
#define   DELETE      2         /* delete char */
#define   DUPLICATE   3         /* duplicate char */

main()
@{
    char buf[BUFLE];
    int fd, count;
    struct strioct1 strioctl;
@end smallexample

The first step is to establish a @dfn{Stream} to the communications driver and insert the character
conversion module.  The following sequence of system calls accomplishes this:

@smallexample
    if ((fd = open("/dev/comm/01", O_RDWR)) < 0) @{
        perror("open failed");
        exit(1);
    @}

    if (ioctl(fd, I_PUSH, "chconv") < 0) @{
        perror("ioctl  I_PUSH failed");
        exit(2);
    @}
@end smallexample

The @var{I_PUSH} @command{ioctl} call directs the @dfn{Stream} head to insert the character
conversion module between the driver and the @dfn{Stream head}, creating the @dfn{Stream} shown in
@figref{17}.  As with drivers, this module resides in the kernel and must have been configured into
the system before it was booted.

@figuresized{SPG_fig17,17,Case Converter Module,4in}

An important difference between @dfn{STREAMS} drivers and modules is illustrated here.  Drivers are
accessed through a node or nodes in the file system and may be opened just like any other device.
Modules, on the other hand, do not occupy a file system node.  Instead, they are identified through
a separate naming convention, and are inserted into a @dfn{Stream} using @var{I_PUSH}.  The name of
a module is defined by the module developer.

Modules are pushed onto a @dfn{Stream} and removed from a @dfn{Stream} in @dfn{Last-In-First-Out
(LIFO)} order.  Therefore, if a second module was pushed onto this @dfn{Stream}, it would be
inserted between the @dfn{Stream} head and the character conversion module.

@subsubsection Module and Driver Control

The next step in this example is to pass the commands and corresponding strings to the character
conversion module.  This can be accomplished by issuing ioctl calls to the character conversion
module as follows:

@smallexample
/* change all uppercase vowels to lowercase */
strioctl.ic_cmd = XCASE;
strioctl.ic_timout = 0;         /* default timeout (15 sec) */
strioctl.ic_dp = "AEIOU";
strioctl.ic_len = strlen(strioctl.ic_dp);

if (ioctl(fd, I_STR, &strioctl) < 0) @{
    perror("ioctl I_STR failed");
    exit(3);
@}

/* delete all instances of trhe chars 'x' and  'X' */
strioctl.ic_cmd = DELETE;
strioctl.ic_dp = "xX";
strioctl.ic_len = strlen(strioctl.ic_dp);

if (ioctl(fd, I_STR, &strioctl) < 0) @{
    perror("ioctl I_STR failed");
    exit(4);
@}
@end smallexample

@command{ioctl} requests are issued to @dfn{STREAMS} drivers and modules indirectly, using the
@var{I_STR} @command{ioctl} call [see @manpage{streamio(7)}].  The argument to @var{I_STR} must be a
pointer to a @code{strioctl} structure, which specifies the request to be made to a module or
driver.  This structure is defined in @file{<sys/stropts.h>} and has the following format:

@smallexample
struct strioctl @{
    int ic_cmd;                         /* ioctl request */
    int ic_timout;                      /* ACK/NAK timeout */
    int ic_len;                         /* length of data argument */
    char *ic_dp;                        /* ptr to data argument */
@};
@end smallexample

where @var{ic_cmd} identifies the command intended for a module or driver, @var{ic_timout} specifies
the number of seconds an @var{I_STR} request should wait for an acknowledgement before timing out,
@var{ic_len} is the number of bytes of data to accompany the request, and @var{ic_dp} points to that
data.

In the example, two separate commands are sent to the character conversion module.  The first sets
@var{ic_cmd} to the command @var{XCASE} and sends as data the string @samp{AEIOU}; it will convert
all uppercase vowels in data passing through the module to lowercase.  The second sets ic_cmd to the
command @var{DELETE} and sends as data the string @samp{xX}; it will delete all occurrences of the
characters @samp{x} and @samp{X} from data passing through the module.  For each command, the value
of @var{ic_timout} is set to zero, which specifies the system default timeout value of @samp{15}
seconds.  The @var{ic_dp} field points to the beginning of the data for each command; @var{ic_len}
is set to the length of the data.

@var{I_STR} is intercepted by the @dfn{Stream head}, which packages it into a message, using
information contained in the @code{strioctl} structure, and sends the message downstream.  Any
module that does not understand the command in @var{ic_cmd} will pass the message further
downstream.  The request will be processed by the module or driver closest to the @dfn{Stream head}
that understands the command specified by @var{ic_cmd}.  The @command{ioctl} call will block up to
@var{ic_timout} seconds, waiting for the target module or driver to respond with either a positive
or negative acknowledgement message.  If an acknowledgement is not received in @var{ic_timout}
seconds, the @command{ioctl} call will fail.

Only one @var{I_STR} request can be active on a @dfn{Stream} at one time.  Further requests will
block until the active @var{I_STR} request is acknowledged and the system call completes.

The @code{strioctl} structure is also used to retrieve the results, if any, of an @var{I_STR}
request.  If data are returned by the target module or driver, @var{ic_dp} must point to a buffer
large enough to hold that data, and @var{ic_len} will be set on return to indicate the amount of
data returned.

The remainder of this example is identical to the example in @ref{Overview of STREAMS}:

@smallexample
    while ((count = read(fd, buf, BUFLEN)) > 0) @{
        if (write(fd, buf, count) != count) @{
            perror("write failed");
            break;
        @}
    @}
    exit(0);
@}
@end smallexample

Notice that the character conversion processing was realized with no change to the communications
driver.

The exit system call will dismantle the @dfn{Stream} before terminating the process.  The character
conversion module will be removed from the @dfn{Stream} automatically when it is closed.
Alternatively, modules may be removed from a @dfn{Stream} using the @var{I_POP} @command{ioctl} call
described in @manpage{streamio(7)}.  This call removes the topmost module on the @dfn{Stream}, and
enables a user process to alter the configuration of a @dfn{Stream} dynamically, by popping modules
as needed.

A few of the important @command{ioctl} requests supported by @dfn{STREAMS} have been discussed.
Several other requests are available to support operations such as determining if a given module
exists on the @dfn{Stream}, or flushing the data on a @dfn{Stream}.  These requests are described
fully in @manpage{streamio(7)}.

@node Processing
@chapter STREAMS Processing Routines
@cindex processing routines
@menu
* Procedures::			STREAMS Put and Service Procedures
* Asyncrhonous Example::	STREAMS Asyncrhonous Stream Example
@end menu

@node Procedures
@section STREAMS Put and Service Procedures
@cindex put and service procedures

The @command{put} and @command{service} procedures in the queue are routines that process messages
as they transit the queue.  The processing is generally performed according to the message type and
can result in a modified message, new message(s), or no message.  A resultant message, if any, is
generally sent in the same direction in which it was received by the queue, but may be sent in
either direction.  Typically, each @command{put} procedure places messages on its queue as they
arrive, for later processing by the @command{service} procedure.

A queue will always contain a @command{put} procedure and may also contain an associated
@command{service} procedure.  Having both a @command{put} and @command{service} procedure in a queue
enables @dfn{STREAMS} to provide the rapid response and the queuing required in multi-user systems.

The @command{service} and @command{put} routines pointed at by a queue, and the queues themselves,
are not associated with any process.  These routines may not sleep if they cannot continue
processing, but must instead return.  Any information about the current status of the queue must be
saved by the routine before returning.

@subsection Put Procedure

A @command{put} procedure is the queue routine that receives messages from the preceding queues in
the @dfn{Stream}.  Messages are passed between queues by a procedure in one queue calling the
@command{put} procedure contained in the following queue.  A call to the @command{put} procedure in
the appropriate direction is generally the only way to pass messages between @dfn{STREAMS}
components.  There is usually a separate @command{put} procedure for the read and write queues
because of the full-duplex operation of most @dfn{Streams}.  However, there can be a single
@command{put} procedure shared between both the read and write queues.

The @command{put} procedure allows rapid response to certain data and events, such as echoing of
input characters.  It has higher priority than any scheduled @command{service} procedure and is
associated with immediate, as opposed to deferred, processing of a message.  The @command{put}
procedure executes before the scheduled @command{service} procedure of any queue is executed.

Each @dfn{STREAMS} component accesses the adjacent @command{put} procedure as a subroutine.  For
example, consider that @samp{modA}, @samp{modB}, and @samp{modC} are three consecutive components in
a @dfn{Stream}, with @samp{modC} connected to the @dfn{Stream head}.  If @samp{modA} receives a
message to be sent upstream, @samp{modA} processes that message and calls @samp{modB}'s read
@command{put} procedure, which processes it and calls @samp{modC}'s read @command{put} procedure,
which processes it and calls the @dfn{Stream head's} read @command{put} procedure.  Thus, the
message will be passed along the @dfn{Stream} in one continuous processing sequence.  This sequence
has the benefit of completing the entire processing in a short time with low overhead (subroutine
calls).  On the other hand, if this sequence is lengthy and the processing is implemented on a
multi-user system, then this manner of processing may be good for this @dfn{Stream} but may be
detrimental for others.  @dfn{Streams} may have to wait too long to get their turn, since each
@command{put} procedure is called from the preceding one, and the kernel stack (or interrupt stack)
grows with each function call.  The possibility of running off the stack exists, thus panicking the
system or producing undeterminate results.

@subsection Service Procedure

In addition to the @command{put} procedure, a @command{service} procedure may be contained in each
queue to allow deferred processing of messages.  If a queue has both a @command{put} and
@command{service} procedure, message processing will generally be divided between the procedures.
The @command{put} procedure is always called first, from a preceding queue.  After completing its
part of the message processing, it arranges for the @command{service} procedure to be called by
passing the message to the @manpage{putq(9)} routine.  @command{putq(9)} does two things: it places
the message on the message queue of the queue (see Figure Messages on a Message Queue) and links the
queue to the end of the @dfn{STREAMS} scheduling queue.  When @command{putq(9)} returns to the
@command{put} procedure, the procedure can return or continue to process the message.  Some time
later, the @command{service} procedure will be automatically called by the @dfn{STREAMS} scheduler.

The @dfn{STREAMS} scheduler is separate and distinct from the @cite{UNIX} system process scheduler.
It is concerned only with queues linked on the @dfn{STREAMS} scheduling queue.  The scheduler calls
each @command{service} procedure of the scheduled queues one at a time in a @dfn{First-In-First-Out
(FIFO)} manner.

The scheduling of queue @command{service} routines is machine dependent.  However, they are
guaranteed to run before returning to user level.

@dfn{STREAMS} utilities deliver the messages to the processing @command{service} routine in the
@dfn{FIFO} manner within each priority class (high priority, priority band, ordinary), because the
@command{service} procedure is unaware of the message priority and simply receives the next message.
The @command{service} routine receives control in the order it was scheduled.  When the
@command{service} routine receives control, it may encounter multiple messages on its message queue.
This buildup can occur if there is a long interval between the time a message is queued by a
@command{put} procedure and the time that the @dfn{STREAMS} scheduler calls the associated
@command{service} routine.  In this interval, there can be multiple calls to the @command{put}
procedure causing multiple messages to build up.  The @command{service} procedure always processes
all messages on its message queue unless prevented by flow control.

Terminal output and input erase and kill processing, for example, would typically be performed in a
@command{service} procedure because this type of processing does not have to be as timely as
echoing.  Use of a @command{service} procedure also allows processing time to be more evenly spread
among multiple @dfn{Streams}.  As with the @command{put} procedure there can be a separate
@command{service} procedure for each queue in a @dfn{STREAMS} component or a single procedure used
by both the read and write queues.

Rules that should be observed in @command{put} and @command{service} procedures are listed in
@ref{Modules and Drivers}.

@node Asyncrhonous Example
@section An Asyncrhonous Stream Example
@cindex asynchronous stream example

In the following example, our computer runs the @cite{UNIX} system and supports different kinds of
asynchronous terminals, each logging in on its own port.  The port hardware is limited in function;
for example, it detects and reports line and modem status, but does not check parity.

Communications software support for these terminals is provided via a @dfn{STREAMS} based
asynchronous protocol.  The protocol includes a variety of options that are set when a terminal
operator dials in to log on.  The options are determined by a @dfn{STREAMS} user process,
@command{getstrm}, which analyzes data sent to it through a series of dialogs (prompts and
responses) between the process and terminal operator.

The process sets the terminal options for the duration of the connection by pushing modules onto the
@dfn{Stream} or by sending control messages to cause changes in modules (or in the device driver)
already on the @dfn{Stream}.  The options supported include:

@itemize @bullet
@item @dfn{ASCII} or @dfn{EBCDIC} character codes
@item For @dfn{ASCII} code, the parity (odd, even or none)
@item Echo or not echo input characters
@item Canonical input and output processing or transparent (raw) character handling
@end itemize

These options are set with the following modules:

@vtable @var
@item CHARPROC
Provides input character processing functions, including dynamically settable (via control messages
passed to the module) character echo and parity checking.  The module's default settings are to echo
characters and not check character parity.
@item CANONPROC
Performs canonical processing on @dfn{ASCII} characters upstream and downstream (note that this
performs some processing in a different manner from the standard @cite{UNIX} system character I/O
@dfn{tty} subsystem).
@item ASCEBC
Translates @dfn{EBCDIC} code to @dfn{ASCII} upstream and @dfn{ASCII} to @dfn{EBCDIC} downstream.
@end vtable

At system initialization a user process, @command{getstrm}, is created for each @dfn{tty} port.
@command{getstrm} opens a @dfn{Stream} to its port and pushes the @var{CHARPROC} module onto the
@dfn{Stream} by use of an @command{ioctl} @var{I_PUSH} command.  Then, the process issues a getmsg
system call to the @dfn{Stream} and sleeps until a message reaches the @dfn{Stream} head.  The
@dfn{Stream} is now in its idle state.

The initial idle @dfn{Stream}, shown in @figref{18}, contains only one pushable module,
@var{CHARPROC}.  The device driver is a limited function raw @dfn{tty} driver connected to a
limited-function communication port.  The driver and port transparently transmit and receive one
unbuffered character at a time.

@figuresized{SPG_fig18,18,Idle @dfn{Stream} Configuration for Example,4in}

Upon receipt of initial input from a @dfn{tty} port, @command{getstrm} establishes a connection with
the terminal, analyzes the option requests, verifies them, and issues @dfn{STREAMS} system calls to
set the options.  After setting up the options, @command{getstrm} creates a user application
process.  Later, when the user terminates that application, @command{getstrm} restores the
@dfn{Stream} to its idle state by use of similar system calls.

@figref{19} continues the example and associates kernel operations with user-level system calls.  As
a result of initializing operations and pushing a module, the @dfn{Stream} for port one has the
following configuration:

@figuresized{SPG_fig19,19,Operational @dfn{Stream} for Example,4in}

As mentioned before, the upstream queue is also referred to as the read queue reflecting the message
flow direction.  Correspondingly, downstream is referred to as the write queue.

@subsection Read-Side Processing

In our example, read-side processing consists of driver processing, @var{CHARPROC} processing, and
@var{CANONPROC} processing.

@subsubsection Driver Processing

The user process has been blocked on the @manpage{getmsg(2)} system call while waiting for a message
to reach the @dfn{Stream head}, and the device driver independently waits for input of a character
from the port hardware or for a message from upstream.  Upon receipt of an input character interrupt
from the port, the driver places the associated character in an @var{M_DATA} message, allocated
previously.  Then, the driver sends the message to the @var{CHARPROC} module by calling
@var{CHARPROC}'s upstream put procedure.  On return from @var{CHARPROC}, the driver calls the
@manpage{allocb(9)} utility routine to get another message for the next character.

@subsubsection CHARPROC

@var{CHARPROC} has both @command{put} and @command{service} procedures on its read-side.  In the
example, the other queues in the modules also have both procedures:

@figuresized{SPG_fig20,20,Module Put and Service Procedures,3in}

When the driver calls @var{CHARPROC}'s read queue @command{put} procedure, the procedure checks
private data flags in the queue.  In this case, the flags indicate that echoing is to be performed
(recall that echoing is optional and that we are working with port hardware which can not
automatically echo).  @var{CHARPROC} causes the echo to be transmitted back to the terminal by first
making a copy of the message with a @dfn{STREAMS} utility routine.  Then, @var{CHARPROC} uses
another utility routine to obtain the address of its own write queue.  Finally, the @var{CHARPROC}
read @command{put} procedure calls its write @command{put} procedure and passes it the message copy.
The write procedure sends the message to the driver to effect the echo and then returns to the read
procedure.

This part of read-side processing is implemented with @command{put} procedures so that the entire
processing sequence occurs as an extension of the driver input character interrupt.  The
@var{CHARPROC} read and write @command{put} procedures appear as subroutines (nested in the case of
the write procedure) to the driver.  This manner of processing is intended to produce the character
echo in a minimal time frame.

After returning from echo processing, the @var{CHARPROC} read @command{put} procedure checks another
of its private data flags and determines that parity checking should be performed on the input
character.  Parity should most reasonably be checked as part of echo processing.  However, for this
example, parity is checked only when the characters are sent upstream.  This relaxes the timing in
which the checking must occur, that is, it can be deferred along with the canonical processing.
@var{CHARPROC} uses @manpage{putq(9)} to schedule the (original) message for parity check processing
by its read @command{service} procedure.  When the @var{CHARPROC} read @command{service} procedure
is complete, it forwards the message to the read @command{put} procedure of @var{CANONPROC}.  Note
that if parity checking was not required, the @var{CHARPROC} @command{put} procedure would call the
@var{CANONPROC} @command{put} procedure directly.

@subsubsection CANONPROC

@var{CANONPROC} performs canonical processing.  As implemented, all read queue processing is
performed in its @command{service} procedure so that @var{CANONPROC}'s @command{put} procedure
simply calls @manpage{putq(9)} to schedule the message for its read @command{service} procedure and
then exits.  The @command{service} procedure extracts the character from the message buffer and
places it in the "line buffer" contained in another @var{M_DATA} message it is constructing.  Then,
the message which contained the single character is returned to the buffer pool.  If the character
received was not an @dfn{end-of-line}, @var{CANONPROC} exits.  Otherwise, a complete line has been
assembled and @var{CANONPROC} sends the message upstream to the @dfn{Stream head} which unblocks the
user process from the @manpage{getmsg(2)} call and passes it the contents of the message.

@subsection Write-Side Processing

The write-side of this Stream carries two kinds of messages from the user process: @command{ioctl}
messages for @var{CHARPROC}, and @var{M_DATA} messages to be output to the terminal.

@command{ioctl} messages are sent downstream as a result of an @command{ioctl}(2) system call.  When
@var{CHARPROC} receives an @command{ioctl} message type, it processes the message contents to modify
internal flags and then uses a utility routine to send an acknowledgement message upstream to the
@dfn{Stream head}.  The @dfn{Stream head} acts on the acknowledgement message by unblocking the user
from the @command{ioctl}.

For terminal output, it is presumed that @var{M_DATA} messages, sent by @manpage{write(2)} system
calls, contain multiple characters.  In general, @dfn{STREAMS} returns to the user process
immediately after processing the @command{write} call so that the process may send additional
messages.  Flow control will eventually block the sending process.  The messages can queue on the
write-side of the driver because of character transmission timing.  When a message is received by
the driver's write @command{put} procedure, the procedure will use @manpage{putq(9)} to place the
message on its write-side service message queue if the driver is currently transmitting a previous
message buffer.  However, there is generally no write queue @command{service} procedure in a device
driver.  Driver output interrupt processing takes the place of scheduling and performs the
@command{service} procedure functions, removing messages from the queue.

@subsection Analysis

For reasons of efficiency, a module implementation would generally avoid placing one character per
message and using separate routines to echo and parity check each character, as was done in this
example.  Nevertheless, even this design yields potential benefits.  Consider a case where
alternate, more intelligent, port hardware was substituted.  If the hardware processed multiple
input characters and performed the echo and parity checking functions of @var{CHARPROC}, then the
new driver could be implemented to present the same interface as @var{CHARPROC}.  Other modules such
as @var{CANONPROC} could continue to be used without modification.

@node Messages
@chapter STREAMS Messages
@cindex messages
@menu
* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers
@end menu

@node Messages Overview
@section STREAMS Messages Overview
@cindex messages overview

Messages are the means of communication within a @dfn{Stream}.  All input and output under
@dfn{STREAMS} is based on messages.  The objects passed between @dfn{Streams} components are
pointers to messages.  All messages in @dfn{STREAMS} use two data structures to refer to the data in
the message.  These data structures describe the type of the message and contain pointers to the
data of the message, as well as other information.  Messages are sent through a @dfn{Stream} by
successive calls to the @command{put} routine of each queue in the @dfn{Stream}.  Messages may be
generated by a driver, a module, or by the @dfn{Stream head}.

@subsection Message Types

There are several different @dfn{STREAMS} messages (@pxref{Message Types}) and they are defined in
@file{<sys/stream.h>}.  The messages differ in their intended purpose and their queueing priority.
The contents of certain message types can be transferred between a process and a @dfn{Stream} by use
of system calls.

Below, the message types are briefly described and classified according to their queueing priority.

Ordinary Messages (also called normal messages):

@multitable @columnfractions .20 .05 .05 .70
@item @var{M_DATA} @tab D @tab U @tab User data message for I/O system calls
@vindex M_DATA
@item @var{M_PROTO} @tab D @tab U @tab Protocol control information
@vindex M_PROTO
@item @var{M_BREAK} @tab D @tab - @tab Request to a @dfn{Stream} driver to send a "break"
@vindex M_BREAK
@item @var{M_CTL} @tab D @tab U @tab Control/status request used for inter-module communication
@vindex M_CTL
@item @var{M_DELAY} @tab D @tab - @tab Request a real-time delay on output
@vindex M_DELAY
@item @var{M_IOCTL} @tab D @tab - @tab Control/status request generated by a @dfn{Stream head}
@vindex M_IOCTL
@item @var{M_PASSFP} @tab D @tab U @tab File pointer passing message
@vindex M_PASSFP
@item @var{M_RSE} @tab D @tab U @tab Reserved for internal use
@vindex M_RSE
@item @var{M_SETOPTS} @tab - @tab U @tab Set options at the @dfn{Stream head}, sent upstream
@vindex M_SETOPTS
@item @var{M_SIG} @tab - @tab U @tab Signal sent from a module/driver to a user
@vindex M_SIG
@end multitable

High Priority Messages:

@multitable @columnfractions .20 .05 .05 .70
@item @var{M_COPYIN} @tab - @tab U @tab Copy in data for transparent @command{ioctl}s, sent upstream
@vindex M_COPYIN
@item @var{M_COPYOUT} @tab - @tab U @tab Copy out data for transparent @command{ioctl}s, sent upstream
@vindex M_COPYOUT
@item @var{M_ERROR} @tab - @tab U @tab Report downstream error condition, sent upstream
@vindex M_ERROR
@item @var{M_FLUSH} @tab D @tab U @tab Flush module queue
@vindex M_FLUSH
@item @var{M_HANGUP} @tab - @tab U @tab Set a @dfn{Stream head} hangup condition, sent upstream
@vindex M_HANGUP
@item @var{M_IOCACK} @tab - @tab U @tab Positive @manpage{ioctl(2)} acknowledgement
@vindex M_IOCACK
@item @var{M_IOCDATA} @tab D @tab - @tab Data for transparent @command{ioctl}s, sent downstream
@vindex M_IOCDATA
@item @var{M_IOCNAK} @tab - @tab U @tab Negative @manpage{ioctl(2)} acknowledgement
@vindex M_IOCNAK
@item @var{M_PCPROTO} @tab D @tab U @tab Protocol control information
@vindex M_PCPROTO
@item @var{M_PCRSE} @tab D @tab U @tab Reserved for internal use
@vindex M_PCRSE
@item @var{M_PCSIG} @tab - @tab U @tab Signal sent from a module/driver to a user
@vindex M_PCSIG
@item @var{M_READ} @tab D @tab - @tab Read notification, sent downstream
@vindex M_READ
@item @var{M_STOP} @tab D @tab - @tab Suspend output
@vindex M_STOP
@item @var{M_START} @tab D @tab - @tab Restart stopped device output
@vindex M_START
@item @var{M_STOPI} @tab D @tab - @tab Suspend input
@vindex M_STOPI
@item @var{M_STARTI} @tab D @tab - @tab Restart stopped device input
@vindex M_STARTI
@end multitable

Transparent @command{ioctl}s support applications developed prior to the introduction of @dfn{STREAMS}.

@subsection Expedited Data

The @cite{Open Systems Interconnection (OSI) Reference Model} developed by the @cite{International
Standards Organization (ISO)} and @cite{International Telegraph and Telephone Consultative Committee
(CCITT)} provides an international standard seven-layer architecture for the development of
communication protocols.  @cite{AT&T} adheres to this standard and also supports the
@dfn{Transmission Control Protocol and Internet Protocol (TCP/IP)}.

@dfn{OSI} and @dfn{TCP/IP} support the transport of expedited data (see note below) for transmission
of high priority, emergency data.  This is useful for flow control, congestion control, routing, and
various applications where immediate delivery of data is necessary.

Expedited data are mainly for exceptional cases and transmission of control signals.  These are
emergency data that are processed immediately, ahead of normal data.  These messages are placed
ahead of normal data on the queue, but after @dfn{STREAMS} high priority messages and after any
expedited data already on the queue.

Expedited data flow control is unaffected by the flow control constraints of normal data transfer.
Expedited data have their own flow control because they can easily run the system out of buffers if
their flow is unrestricted.

Drivers and modules define separate high and low water marks for priority band data flow.  (Water
marks are defined for each queue and they indicate the upper and lower limit of bytes that can be
contained on the queue; see @var{M_SETOPTS} in @pxref{Message Types}).  The default water marks for
priority band data and normal data are the same.  The @dfn{Stream} head also ensures that incoming
priority band data are not blocked by normal data already on the queue.  This is accomplished by
associating a priority with the messages.  This priority implies a certain ordering of the messages
in the queue.  (Message queues and priorities are discussed later in this chapter.)

Within the @dfn{STREAMS} mechanism and in this guide expedited data are also referred to as priority
band data.

@node Message Structure
@section STREAMS Message Structure
@cindex message structure

All messages are composed of one or more message blocks.  A message block is a linked triplet of two
structures and a variable length data buffer.  The structures are a message block (@code{msgb}) and
a data block (@code{datab}).  The data buffer is a location in memory where the data of a message
are stored.

@smallexample
struct msgb @{
    struct msgb *b_next;                /* next message on queue */
    struct msgb *b_prev;                /* previous message on queue */
    struct msgb *b_cont;                /* next message block of message */
    unsigned char *b_rptr;              /* first unread data byte in buffer */
    unsigned char *b_wptr;              /* first unwritten data byte in buffer */
    struct datab *b_datap;              /* data block */
    unsigned char b_band;               /* message priority */
    unsigned char b_padl;
    unsigned short b_flag;              /* see below - message flags */
    long b_pad2;
@};

typedef struct msgb mblk_t;

/* message flags.  these are interpreted by the stream head.  */
#define msgmark    0x01         /* last byte of message is "marked" */
#define msgnoloop  0x02         /* don't loop message around to write side of
                                   stream */
#define msgdelim   0x04         /* message is delimited */
#define msgnoget   0x08         /* getq does not return message */
#define msgatten   0x20         /* attention to on read side */

struct free_rtn @{
    void (*free_func) (caddr_t);
    caddr_t free_arg;
@};

struct datab @{
    union @{
        struct datab *freep;
        struct free_rtn *frtnp;
    @} db_f;                             /* used internally */
    unsigned char *db_base;             /* first byte of buffer */
    unsigned char *db_lim;              /* last byte+1 of buffer */
    unsigned char db_ref;               /* message count pointing to this block */
    unsigned char db_type;              /* message type */
    unsigned char db_iswhat;            /* status of message/dat buffer triplet */
    unsigned int db_size;               /* used internally */
    caddr_t db_msgaddr;                 /* triplet message header pointing to datab */
    long db_filler;                     /* reserved for future use */
@};

#define db_freep db_f.freep
#define db_frtnp db_f.frtnp

typedef struct datab dblk_t;
typedef struct free_rtn frtn_t;
@end smallexample

The field @var{b_band} determines where the message is placed when it is enqueued using the
@dfn{STREAMS} utility routines.  This field has no meaning for high priority messages and is set to
zero for these messages.  When a message is allocated via @manpage{allocb(9)}, the @var{b_band}
field will be initially set to zero.  Modules and drivers may set this field if so desired.

@subsection Message Linkage

The message block is used to link messages on a message queue, link message blocks to form a
message, and manage the reading and writing of the associated data buffer.  The @var{b_rptr} and @var{b_wptr}
fields in the @code{msgb} structure are used to locate the data currently contained in the buffer.  As
shown in @figref{21}, the message block (@code{mblk_t}) points to the data block of the triplet.
The data block contains the message type, buffer limits, and control variables.  @dfn{STREAMS}
allocates message buffer blocks of varying sizes.  @var{db_base} and @var{db_lim} are the fixed
beginning and end (+1) of the buffer.

A message consists of one or more linked message blocks.  Multiple message blocks in a message can
occur, for example, because of buffer size limitations, or as the result of processing that expands
the message.  When a message is composed of multiple message blocks, the type associated with the
first message block determines the message type, regardless of the types of the attached message
blocks.

@figuresized{SPG_fig21,21,Message Form and Linkage,5.5in}

A message may occur singly, as when it is processed by a @command{put} procedure, or it may be
linked on the message queue in a @code{queue}, generally waiting to be processed by the service
procedure.  Message @samp{2}, as shown in @figref{21}, links to message @samp{1}.

Note that a data block in message @samp{1} is shared between message @samp{1} and another message.
Multiple message blocks can point to the same data block to conserve storage and to avoid copying
overhead.  For example, the same data block, with associated buffer, may be referenced in two
messages, from separate modules that implement separate protocol levels.  @figref{21}, illustrates
the concept, but data blocks would not typically be shared by messages on the same queue).  The
buffer can be retransmitted, if required because of errors or timeouts, from either protocol level
without replicating the data.  Data block sharing is accomplished by means of a utility routine [see
@manpage{dupmsg(9)} or @ref{STREAMS Utilities}].  @dfn{STREAMS} maintains a count of the message
blocks sharing a data block in the @var{db_ref} field.

@dfn{STREAMS} provides utility routines and macros, specified in @ref{STREAMS Utilities}, to assist
in managing messages and message queues, and to assist in other areas of module and driver
development.  A utility routine should always be used when operating on a message queue or accessing
the message storage pool.  If messages are manipulated on the queue without using the @dfn{STREAMS}
utilities, the message ordering may become confused and lead to inconsistent results.

@subsection Sending and Receiving Messages

Most message types can be generated by modules and drivers.  A few are reserved for the @dfn{Stream
head}.  The most commonly used messages are @var{M_DATA}, @var{M_PROTO}, and @var{M_PCPROTO}.  These
messages can also be passed between a process and the topmost module in a @dfn{Stream}, with the
same message boundary alignment maintained on both sides of the kernel.  This allows a user process
to function, to some degree, as a module above the @dfn{Stream} and maintain a service interface.
@var{M_PROTO} and @var{M_PCPROTO} messages are intended to carry service interface information among
modules, drivers, and user processes.  Some message types can only be used within a @dfn{Stream} and
cannot be sent or received from user level.

Modules and drivers do not interact directly with any system calls except @manpage{open(2)} and
@manpage{close(2)}.  The @dfn{Stream} head handles all message translation and passing between user
processes and @dfn{STREAMS} components.  Message transfer between processes and the @dfn{Stream
head} can occur in different forms.  For example, @var{M_DATA} and @var{M_PROTO} messages can be
transferred in their direct form by the @manpage{getmsg(2)} and @manpage{putmsg(2)} system calls.
Alternatively, @manpage{write(2)} causes one or more @var{M_DATA} messages to be created from the
data buffer supplied in the call.  @var{M_DATA} messages received at the @dfn{Stream head} will be
consumed by @manpage{read(2)} and copied into the user buffer.  As another example, @var{M_SIG}
causes the @dfn{Stream head} to send a signal to a process.

Any module or driver can send any message in either direction on a @dfn{Stream}.  However, based on
their intended use in @dfn{STREAMS} and their treatment by the @dfn{Stream} head, certain messages
can be categorized as upstream, downstream, or bidirectional.  @var{M_DATA}, @var{M_PROTO}, or
@var{M_PCPROTO} messages, for example, can be sent in both directions.  Other message types are
intended to be sent upstream to be processed only by the @dfn{Stream head}.  Messages intended to be
sent downstream are silently discarded if received by the @dfn{Stream head}.

@dfn{STREAMS} enables modules to create messages and pass them to neighboring modules.  However, the
@manpage{read(2)} and @manpage{write(2)} system calls are not sufficient to enable a user process to
generate and receive all such messages.  First, read and write are byte-stream oriented with no
concept of message boundaries.  To support service interfaces, the message boundary of each service
primitive must be preserved so that the beginning and end of each primitive can be located.  Also,
read and write offer only one buffer to the user for transmitting and receiving @dfn{STREAMS}
messages.  If control information and data were placed in a single buffer, the user would have to
parse the contents of the buffer to separate the data from the control information.

The @command{putmsg} system call enables a user to create messages and send them downstream.  The
user supplies the contents of the control and data parts of the message in two separate buffers.
The @command{getmsg} system call retrieves @var{M_DATA} or @var{M_PROTO} messages from a
@dfn{Stream} and places the contents into two user buffers.

The format of @command{putmsg} is as follows:

@smallexample
int putmsg(int fd, struct strbuf *ctlptr, struct strbuf *dataptr, int flags);
@end smallexample

@var{fd} identifies the @dfn{Stream} to which the message will be passed, @var{ctlptr} and
@var{dataptr} identify the control and data parts of the message, and @var{flags} may be used to
specify that a high priority message (@var{M_PCPROTO}) should be sent.  When a control part is
present, setting @var{flags} to @samp{0} generates an @var{M_PROTO} message.  If flags is set to
@var{RS_HIPRI}, an @var{M_PCPROTO} message is generated.

The @dfn{Stream} head guarantees that the control part of a message generated by @manpage{putmsg(2)}
is at least @samp{64} bytes in length.  This promotes reusability of the buffer.  When the buffer is
a reasonable size, modules and drivers may reuse the buffer for other headers.

The @code{strbuf} structure is used to describe the control and data parts of a message, and has the
following format:

@example
struct strbuf @{
    int maxlen;     /* maximum buffer length */
    int len;        /* length of data */
    char *buf;      /* pointer to buffer */
@}
@end example

@var{buf} points to a buffer containing the data and @var{len} specifies the number of bytes of data
in the buffer.  @var{maxlen} specifies the maximum number of bytes the given buffer can hold, and is
only meaningful when retrieving information into the buffer using @command{getmsg}.

The @command{getmsg} system call retrieves @var{M_DATA}, @var{M_PROTO}, or @var{M_PCPROTO} messages
available at the @dfn{Stream} head, and has the following format:

@smallexample
int getmsg(int fd, struct strbuf *ctlptr, struct strbuf *dataptr, int *flagsp);
@end smallexample

The arguments to @command{getmsg} are the same as those of @command{putmsg} except that the
@var{flagsp} parameter is a pointer to an @code{int}.

@command{putpmsg()} and @command{getpmsg()} [see @manpage{putpmsg(2)} and @manpage{getpmsg(2)}]
support multiple bands of data flow.  They are analogous to the system calls @command{putmsg} and
@command{getmsg}.  The extra parameter is the priority band of the message.

@command{putpmsg()} has the following interface:

@smallexample
int putpmsg(int fd, struct strbuf *ctlptr, struct strbuf *dataptr, int band, int flags);
@end smallexample

The parameter @var{band} is the priority band of the message to put downstream.  The valid values
for @var{flags} are @var{MSG_HIPRI} and @var{MSG_BAND}.  @var{MSG_BAND} and @var{MSG_HIPRI} are
mutually exclusive.  @var{MSG_HIPRI} generates a high priority message (@var{M_PCPROTO}) and
@var{band} is ignored.  @var{MSG_BAND} causes an @var{M_PROTO} or @var{M_DATA} message to be
generated and sent down the priority band specified by @var{band}.  The valid range for band is from
@samp{0} to @samp{255} inclusive.

The call

@example
putpmsg(fd, ctlptr, dataptr, 0, MSG_BAND)
@end example

is equivalent to the the system call

@example
putmsg(fd, ctlptr, dataptr, 0)
@end example

and the call

@example
putpmsg(fd, ctlptr, dataptr, 0, MSG_HIPRI)
@end example

is equivalent to the system call

@example
putmsg(fd, ctlptr, dataptr, RS_HIPRI)
@end example

If @var{MSG_HIPRI} is set and band is non-zero, @command{putpmsg()} fails with @var{EINVAL}.

@command{getpmsg()} has the following format:

@smallexample
int getpmsg(int fd, struct strbuf *ctlptr, struct strbuf *dataptr, int *bandp, int *flagsp);
@end smallexample

@var{bandp} is the priority band of the message.  This system call retrieves a message from the
@dfn{Stream}.  If @samp{*flagsp} is set to @var{MSG_HIPRI}, @command{getpmsg()} attempts to retrieve
a high priority message.  If @var{MSG_BAND} is set, @command{getpmsg()} tries to retrieve a message
from priority band @samp{*bandp} or higher.  If @var{MSG_ANY} is set, the first message on the
@dfn{Stream head} read queue is retrieved.  These three flags (@var{MSG_HIPRI}, @var{MSG_BAND}, and
@var{MSG_ANY}) are mutually exclusive.  On return, if a high priority message was retrieved,
@samp{*flagsp} is set to @var{MSG_HIPRI} and @samp{*bandp} is set to @samp{0}.  Otherwise,
@samp{*flagsp} is set to @var{MSG_BAND} and @samp{*bandp} is set to the band of the message
retrieved.

The call

@example
int band = 0;
int flags = MSG_ANY;
getpmsg(fd, ctlptr, dataptr, &band, &flags);
@end example

is equivalent to

@example
int flags = 0;
getmsg(fd, ctlptr, dataptr, &flags);
@end example

If @var{MSG_HIPRI} is set and @samp{*bandp} is non-zero, @command{getpmsg()} fails with @var{EINVAL}.

@subsection Control of Stream Head Processing

The @var{M_SETOPTS} message allows a driver or module to exercise control over certain @dfn{Stream
head} processing.  An @var{M_SETOPTS} can be sent upstream at any time.  The @dfn{Stream head}
responds to the message by altering the processing associated with certain system calls.  The
options to be modified are specified by the contents of the stroptions structure (@pxref{STREAMS
Data Structures}) contained in the message.

Six @dfn{Stream head} characteristics can be modified.  Four characteristics correspond to fields
contained in @code{queue} (min/max packet sizes and high/low water marks).  The other two are
discussed here.

@subsubsection Read Options

The value for read options (@var{so_readopt}) corresponds to two sets of three modes a user can set
via the @var{I_SRDOPT} @command{ioctl} [see @manpage{streamio(7)}] call.  The first set deals with
data and message boundaries:

@table @asis
@item @dfn{byte-stream} (@var{RNORM})
The @manpage{read(2)} call completes when the byte count is satisfied, the @dfn{Stream head} read
queue becomes empty, or a zero length message is encountered.  In the last case, the zero length
message is put back on the queue.  A subsequent read will return @samp{0} bytes.
@item @dfn{message non-discard} (@var{RMSGN})
The @manpage{read(2)} call completes when the byte count is satisfied or at a message boundary,
whichever comes first.  Any data remaining in the message are put back on the @dfn{Stream head} read
queue.
@item @dfn{message discard} (@var{RMSGD})
The @manpage{read(2)} call completes when the byte count is satisfied or at a message boundary.  Any
data remaining in the message are discarded.
@end table

@dfn{Byte-stream mode} approximately models pipe data transfer.  @dfn{Message non-discard mode}
approximately models a @dfn{TTY} in canonical mode.

The second set deals with the treatment of protocol messages by the @manpage{read(2)} system call:

@table @asis
@item @dfn{normal protocol} (@var{RPROTNORM})
The @manpage{read(2)} call fails with @var{EBADMSG} if an @var{M_PROTO} or @var{M_PCPROTO} message
is at the front of the @dfn{Stream head} read queue.  This is the default operation protocol.
@item @dfn{protocol discard} (@var{RPROTDIS})
The @manpage{read(2)} call will discard any @var{M_PROTO} or @var{M_PCPROTO} blocks in a message,
delivering the @var{M_DATA} blocks to the user.
@item @dfn{protocol data} (@var{RPROTDAT})
The @manpage{read(2)} call converts the @var{M_PROTO} and @var{M_PCPROTO} message blocks to
@var{M_DATA} blocks, treating the entire message as data.
@end table

@subsubsection Write Options

The value for write offset (@var{so_wroff}) is a hook to allow more efficient data handling.  It
works as follows: In every data message generated by a @manpage{write(2)} system call and in the
first @var{M_DATA} block of the data portion of every message generated by a @manpage{putmsg(2)}
call, the @var{Stream head} will leave @samp{so_wroff} bytes of space at the beginning of the
message block.  Expressed as a C language construct:

@example
bp->b_rptr = bp->b_datap->db_base + write offset.
@end example

The write offset value must be smaller than the maximum @dfn{STREAMS} message size, @var{STRMSGSZ}
(@pxref{Tunable Parameters}).  In certain cases (e.g., if a buffer large enough to hold the
@samp{offset+data} is not currently available), the write offset might not be included in the block.
To handle all possibilities, modules and drivers should not assume that the offset exists in a
message, but should always check the message.

The intended use of write offset is to leave room for a module or a driver to place a protocol
header before user data in the message rather than by allocating and prepending a separate message.

@node Queues and Priority
@section STREAMS Message Queues and Priority
@cindex message queues and priority

Message queues grow when the @dfn{STREAMS} scheduler is delayed from calling a service procedure
because of system activity, or when the procedure is blocked by flow control.  When called by the
scheduler the service procedure processes enqueued messages in a @dfn{First-In-First-Out (FIFO)}
manner.  However, expedited data support and certain conditions require that associated messages
(e.g., an @var{M_ERROR}) reach their @dfn{Stream} destination as rapidly as possible.  This is
accomplished by associating priorities to the messages.  These priorities imply a certain ordering
of messages on the queue as shown in @figref{22}.  Each message has a priority band associated with
it.  Ordinary messages have a priority of zero.  High priority messages are high priority by nature
of their message type.  Their priority band is ignored.  By convention, they are not affected by
flow control.  The @manpage{putq(9)} utility routine places high priority messages at the head of
the message queue followed by priority band messages (expedited data) and ordinary messages.

@figuresized{SPG_fig22,22,Message Ordering on a Queue,5in}

When a message is queued, it is placed after the messages of the same priority already on the queue
(i.e., @dfn{FIFO} within their order of queueing).  This affects the flow control parameters
associated with the band of the same priority.  Message priorities range from @samp{0} (normal) to
@samp{255} (highest).  This provides up to @samp{256} bands of message flow within a @dfn{Stream}.
Expedited data can be implemented with one extra band of flow (priority band 1) of data.  This is
shown in @figref{23}.

@figuresized{SPG_fig23,23,Message Ordering with One Priority Band,2.5in}

High priority messages are not subject to flow control.  When they are queued by @manpage{putq(9)},
the associated queue is always scheduled (in the same manner as any queue; following all other
queues currently scheduled).  When the service procedure is called by the scheduler, the procedure
uses @manpage{getq(9)} to retrieve the first message on queue, which will be a high priority
message, if present.  Service procedures must be implemented to act on high priority messages
immediately.  The above mechanisms priority message queueing, absence of flow control, and immediate
processing by a procedure result in rapid transport of high priority messages between the
originating and destination components in the @dfn{Stream}.

Several routines are provided to aid users in controlling each priority band of data flow.  These
routines are @manpage{flushband(9)}, @manpage{bcanput(9)}, @manpage{strqget(9)}, and
@manpage{strqset(9)}.  The @command{flushband()} routine is discussed in @ref{Flush Handling}, the
@command{bcanput()} routine is discussed under @ref{Flow Control}, later in this chapter, and the
other two routines are described next.  @ref{STREAMS Utilities}, also has a description of these
routines.

The @command{strqget()} routine allows modules and drivers to obtain information about a queue or
particular band of the queue.  This provides a way to insulate the @dfn{STREAMS} data structures
from the modules and drivers.  The format of the routine is:

@example
int
strqget(q, what, pri, valp)
        register queue_t *q;
        qfields_t what;
        register unsigned char pri;
        long *valp;
@end example

The information is returned in the @code{long} referenced by @var{valp}.  The fields that can be
obtained are defined by the following:

@example
typedef enum qfields @{
    QHIWAT = 0,         /* q_hiwat or qb_hiwat */
    QLOWAT = 1,         /* q_lowat or qb_lowat */
    QMAXPSZ = 2,        /* q_maxpsz */
    QMINPSZ = 3,        /* q_minpsz */
    QCOUNT = 4,         /* q_count or qb_count */
    QFIRST = 5,         /* q_first or qb_first */
    QLAST = 6,          /* q_last or qb_last */
    QFLAG = 7,          /* q_flag or qb_flag */
    QBAD = 8
@} qfields_t;
@end example

This routine returns @samp{0} on success and an error number on failure.

The routine @command{strqset()} allows modules and drivers to change information about a queue or
particular band of the queue.  This also insulates the @dfn{STREAMS} data structures from the
modules and drivers.  Its format is:

@example
int
strqset(q, what, pri, val)
        register queue_t *q;
        qfields_t what;
        register unsigned char pri;
        long val;
@end example

The updated information is provided by @var{val}.  @command{strqset()} returns @samp{0} on success
and an error number on failure.  If the field is intended to be read-only, then the error
[@b{EPERM}] is returned and the field is left unchanged.  The following fields are currently
read-only: @var{QCOUNT}, @var{QFIRST}, @var{QLAST}, and @var{QFLAG}.

The @command{ioctl}s @var{I_FLUSHBAND}, @var{I_CKBAND}, @var{I_GETBAND}, @var{I_CANPUT}, and
@var{I_ATMARK} support multiple bands of data flow.  The @command{ioctl} @var{I_FLUSHBAND} allows a
user to flush a particular band of messages.  It is discussed in more detail in @ref{Flush
Handling}.

The @command{ioctl} @var{I_CKBAND} allows a user to check if a message of a given priority exists on
the @dfn{Stream head} read queue.  Its interface is:

@example
ioctl(fd, I_CKBAND, pri);
@end example

This returns @samp{1} if a message of priority @var{pri} exists on the @dfn{Stream head} read queue
and @samp{0} if no message of priority @var{pri} exists.  If an error occurs, @samp{-1} is returned.
Note that @var{pri} should be of type @code{int}.

The @command{ioctl} @var{I_GETBAND} allows a user to check the priority of the first message on the
@dfn{Stream head} read queue.  The interface is:

@example
ioctl(fd, I_GETBAND, prip);
@end example

This results in the integer referenced by @var{prip} being set to the priority band of the message
on the front of the @dfn{Stream head} read queue.

The @command{ioctl} @var{I_CANPUT} allows a user to check if a certain band is writable.  Its
interface is:

@example
ioctl(fd, I_CANPUT, pri);
@end example

The return value is @samp{0} if the priority band @var{pri} is flow controlled, @samp{1} if the band
is writable, and @samp{-1} on error.

The field @var{b_flag} of the @code{msgb} structure can have a flag @var{MSGMARK} that allows a
module or driver to mark a message.  This is used to support @dfn{TCP}'s (@dfn{Transport Control
Protocol}) ability to indicate to the user the last byte of out-of-band data.  Once marked, a
message sent to the @dfn{Stream head} causes the @dfn{Stream head} to remember the message.  A user
may check to see if the message on the front of its @dfn{Stream head} read queue is marked or not
with the @var{I_ATMARK} @command{ioctl}.  If a user is reading data from the @dfn{Stream head} and
there are multiple messages on the read queue, and one of those messages is marked, the
@manpage{read(2)} terminates when it reaches the marked message and returns the data only up to that
marked message.  The rest of the data may be obtained with successive reads.

The @command{ioctl} @var{I_ATMARK} has the following format:

@example
ioctl(fd, I_ATMARK, flag);
@end example

where flag may be either @var{ANYMARK} or @var{LASTMARK}.  @var{ANYMARK} indicates that the user
merely wants to check if the message is marked.  @var{LASTMARK} indicates that the user wants to see
if the message is the only one marked on the queue.  If the test succeeds, @samp{1} is returned.  On
failure, @samp{0} is returned.  If an error occurs, @samp{-1} is returned.

@subsection The @code{queue} Structure

Service procedures, message queues, message priority, and basic flow control are all intertwined in
@dfn{STREAMS}.  A queue will generally not use its message queue if there is no @command{service}
procedure in the queue.  The function of a @command{service} procedure is to process messages on its
queue.  Message priority and flow control are associated with message queues.

The operation of a queue revolves around the @code{queue} structure:

@smallexample
struct queue @{
    struct qinit *q_qinfo;      /* procedures and limits for queue */
    struct msgb *q_first;       /* head of message queue for this queue */
    struct msgb *q_last;        /* tail of message queue for this queue */
    struct queue *q_next;       /* next queue in Stream */
    struct queue *q_link;       /* to next queue for scheduling */
    _VOID *q_ptr;               /* to private data structure */
    ulong q_count;              /* number of bytes in queue */
    ulong q_flag;               /* queue state */
    long q_minpsz;              /* min packet size accepted by this module */
    long q_maxpsz;              /* max packet size accepted by this module */
    ulong q_hiwat;              /* queue high water mark for flow control */
    ulong q_lowat;              /* queue low water mark for flow control */
    struct qband *q_bandp;      /* separate flow information */
    unsigned char q_nband;      /* number of priority bands */
    unsigned char q_blocked;    /* number of bands flow controlled */
    unsigned char q_pad1[2];    /* reserved for future use */
    long q_pad2[2];             /* reserved for future use */
@};

typedef struct queue queue_t;
@end smallexample

Queues are always allocated in pairs (read and write); one queue pair per a module, a driver, or a
@dfn{Stream head}.  A queue contains a linked list of messages.  When a queue pair is allocated, the
following fields are initialized by @dfn{STREAMS}:

@itemize @bullet
@item @var{q_qinfo} from @code{streamtab}
@item @var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, @var{q_lowat} from @code{module_info}
@end itemize

Copying values from @code{module_info} allows them to be changed in the queue without modifying the
@code{streamtab} and @code{module_info} values.

@var{q_count} is used in flow control calculations and is the number of bytes in messages on the queue.

@subsubsection Using @code{queue} Information

Modules and drivers should use @dfn{STREAMS} utility routines (@pxref{STREAMS Utilities}) to alter
@var{q_first}, @var{q_last}, @var{q_count}, and @var{q_flag}.

Modules and drivers can change @var{q_ptr}, @var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, and
@var{q_lowat}.

Modules and drivers can read but should not change @var{q_qinfo}, @var{q_next}, @var{q_bandp}, and
@var{q_nband}.

Modules and drivers should not touch @var{q_link}, @var{q_pad1}, and @var{q_pad2}.

@subsubsection Queue Flags

Programmers using the @dfn{STREAMS} mechanism should be aware of the following queue flags:

@multitable @columnfractions .10 .90
@item @code{QENAB}
@tab queue is enabled to run the @command{service} procedure (it is on the run queue)
@item @code{QWANTR}
@tab someone wants to read from the queue
@item @code{QWANTW}
@tab someone wants to write to the queue
@item @code{QFULL}
@tab queue is full
@item @code{QREADR}
@tab set for read queues
@item @code{QUSE}
@tab queue has been allocated
@item @code{QNOENB}
@tab do not enable the queue when data are placed on it
@item @code{QBACK}
@tab queue has been back-enabled
@item @code{QOLD}
@tab queue supports module/driver interface to open/close developed prior to @cite{UNIX System V Release 4.0}
@item @code{QHLIST}
@tab the @dfn{Stream head} write queue is scanned
@end multitable

@subsubsection The @code{qband} Structure

The queue flow information for each band is contained in a @code{qband} structure.  It is defined as
follows:

@smallexample
struct qband @{
    struct qband *qb_next;      /* next band's info */
    ulong qb_count;             /* number of bytes in band */
    struct msgb *qb_first;      /* beginning of band's data */
    struct msgb *qb_last;       /* end of band's data */
    ulong qb_hiwat;             /* high water mark for band */
    ulong qb_lowat;             /* low water mark for band */
    ulong qb_flag;              /* flag, QB_FULL, denotes that a band
                                   of data flow is flow controlled */
    long qb_pad1;               /* reserved for future use */
@};

typedef struct qband qband_t;

/*
 * qband flags
 */
#define QB_FULL       0x01      /* band is considered full */
#define QB_WANTW      0x02      /* someone wants to write to band */
#define QB_BACK       0x04      /* queue has been back-enabled */
@end smallexample

This structure contains pointers to the linked list of messages on the queue.  These pointers,
@var{qb_first} and @var{qb_last}, denote the beginning and end of messages for the particular band.
The @var{qb_count} field is analogous to the queue's @var{q_count} field.  However, @var{qb_count}
only applies to the messages on the queue in the band of data flow represented by the corresponding
@code{qband} structure.  In contrast, @var{q_count} only contains information regarding normal and
high priority messages.

Each band has a separate high and low water mark, @var{qb_hiwat} and @var{qb_lowat}.  These are
initially set to the queue's @var{q_hiwat} and @var{q_lowat} respectively.  Modules and drivers may
change these values if desired through the @manpage{strqset(9)} function.  Three flags,
@var{QB_FULL}, @var{QB_WANTW}, and @var{QB_BACK}, are defined for @var{qb_flag}.  @var{QB_FULL}
denotes that the particular band is full.  @var{QB_WANTW} indicates that someone tried to write to
the band that was flow controlled.  @var{QB_BACK} is set when the service procedure runs as a result
of being back-enabled because the queue is no longer flow-controlled.

The @code{qband} structures are not preallocated per queue.  Rather, they are allocated when a
message with a priority greater than zero is placed on the queue via @manpage{putq(9)},
@manpage{putbq(9)}, or @manpage{insq(9)}.  Since band allocation can fail, these routines return
@samp{0} on failure and @samp{1} on success.  Once a @code{qband} structure is allocated, it remains
associated with the queue until the queue is freed.  @manpage{strqset(9)} and @manpage{strqget(9)}
will cause @code{qband} allocation to occur.

@subsubsection Using @code{qband} Information

The @dfn{STREAMS} utility routines should be used when manipulating the fields in the @code{qband}
structures.  The routines @manpage{strqset(9)} and @manpage{strqget(9)} should be used to access
band information.

Drivers and modules are allowed to change the @var{qp_hiwat} and @var{qp_lowat} fields of the
@code{qband} structure.

Drivers and modules may only read the @var{qb_count}, @var{qb_first}, @var{qb_last}, and
@var{qb_flag} fields of the @code{qband} structure.

The @var{pad} fields should not be used in the @code{qband} structure; they are intended for future
use.

The following figure depicts a queue with two priority bands of flow.

@figuresized{SPG_fig24,24,Data Structure Linkage,4in}

@subsection Message Processing

Put procedures are generally required in pushable modules.  Service procedures are optional.  If the
@command{put} routine enqueues messages, there must exist a corresponding @command{service} routine
that handles the enqueued messages.  If the @command{put} routine does not enqueue messages, the
@command{service} routine need not exist.

The general processing flow when both procedures are present is as follows:

@enumerate
@item  A message is received by the @command{put} procedure in a queue, where some processing may be
performed on the message.
@item  The @command{put} procedure places the message on the queue by use of the @manpage{putq(9)}
utility routine for the @command{service} procedure to perform further processing at some later
time.
@item  @manpage{putq(9)} places the message on the queue based on its priority.
@item  Then, @manpage{putq(9)} makes the queue ready for execution by the @dfn{STREAMS} scheduler
following all other queues currently scheduled.
@item  After some indeterminate delay (intended to be short), the @dfn{STREAMS} scheduler calls the
@command{service} procedure.
@item  The @command{service} procedure gets the first message (@var{q_first}) from the message queue
with the @manpage{getq(9)} utility.
@item  The @command{service} procedure processes the message and passes it to the @command{put}
procedure of the next queue with @manpage{putnext(9)}.
@item  The @command{service} procedure gets the next message and processes it.
@end enumerate

This processing continues until the queue is empty or flow control blocks further processing.  The
@command{service} procedure returns to the caller.

A @command{service} procedure must never sleep since it has no user context.  It must always return
to its caller.

If no processing is required in the @command{put} procedure, the procedure does not have to be
explicitly declared.  Rather, @manpage{putq(9)} can be placed in the @code{qinit} structure
declaration for the appropriate queue side to queue the message for the @command{service} procedure,
e.g.,

@example
static struct qinit winit = @{ putq, modwsrv, ....... @};
@end example

More typically, @command{put} procedures will, at a minimum, process high priority messages to avoid
queueing them.

The key attribute of a @command{service} procedure in the @dfn{STREAMS} architecture is delayed
processing.  When a @command{service} procedure is used in a module, the module developer is
implying that there are other, more time sensitive activities to be performed elsewhere in this
@dfn{Stream}, in other @dfn{Streams}, or in the system in general.  The presence of a
@command{service} procedure is mandatory if the flow control mechanism is to be utilized by the
queue.

The delay for @dfn{STREAMS} to call a @command{service} procedure will vary with implementation and
system activity.  However, once the @command{service} procedure is scheduled, it is guaranteed to be
called before user level activity is resumed.

If a module or driver wishes to recognize priority bands, the @command{service} procedure is written
to the following algorithm:

@smallexample
.
.
while ((bp = getq(q)) != NULL) @{
    if (bp->b_datap->db_type >= QPCTL) @{
        putnext(q, bp);
    @} else if (bcanput(q, bp->b_band)) @{
        putnext(q, bp);
    @} else @{
        putbq(q, bp);
        return;
    @}
@}
.
.
@end smallexample

@subsubsection Flow Control

The @dfn{STREAMS} flow control mechanism is voluntary and operates between the two nearest queues in
a @dfn{Stream} containing @command{service} procedures (see @figref{25}).  Messages are generally
held on a queue only if a @command{service} procedure is present in the associated queue.

Messages accumulate on a queue when the queue's @command{service} procedure processing does not keep
pace with the message arrival rate, or when the procedure is blocked from placing its messages on
the following @dfn{Stream} component by the flow control mechanism.  Pushable modules contain
independent upstream and downstream limits.  The @dfn{Stream head} contains a preset upstream limit
(which can be modified by a special message sent from downstream) and a driver may contain a
downstream limit.

Flow control operates as follows:

@enumerate
@item  Each time a @dfn{STREAMS} message handling routine (for example, @manpage{putq(9)}) adds or
removes a message from a message queue, the limits are checked.  @dfn{STREAMS} calculates the total
size of all message blocks (@samp{bp->b_wptr - bp->b_rptr}) on the message queue.
@item  The total is compared to the queue high water and low water values.  If the total exceeds the
high water value, an internal full indicator is set for the queue.  The operation of the
@command{service} procedure in this queue is not affected if the indicator is set, and the
@command{service} procedure continues to be scheduled.
@item  The next part of flow control processing occurs in the nearest preceding queue that contains a
@command{service} procedure.  In @figref{25}, if @samp{D} is full and @samp{C} has no
@command{service} procedure, then @samp{B} is the nearest preceding queue.
@item  The service procedure in @samp{B} uses a @dfn{STREAMS} utility routine to see if a queue
ahead is marked full.  If messages cannot be sent, the scheduler blocks the service procedure in
@samp{B} from further execution.  @samp{B} remains blocked until the low water mark of the full
queue, @samp{D}, is reached.
@item  While @samp{B} is blocked, any messages except high priority messages arriving at @samp{B}
will accumulate on its message queue (recall that high priority messages are not subject to flow
control).  Eventually, @samp{B} may reach a full state and the full condition will propagate back to
the module in the @dfn{Stream}.
@item  When the @command{service} procedure processing on @samp{D} causes the message block total to
fall below the low water mark, the full indicator is turned off.  Then, @dfn{STREAMS} automatically
schedules the nearest preceding blocked queue (@samp{B} in this case), getting things moving again.
This automatic scheduling is known as back-enabling a queue.
@end enumerate

@figuresized{SPG_fig25,25,Flow Control,3in}

Modules and drivers need to observe the message priority.  High priority messages, determined by the
type of the first block in the message, (@samp{mp->b_datap->db_type >= QPCTL}), are not subject to
flow control.  They are processed immediately and forwarded, as appropriate.

For ordinary messages, flow control must be tested before any processing is performed.  The
@manpage{canput(9)} utility determines if the forward path from the queue is blocked by flow
control.

This is the general flow control processing of ordinary messages:

@enumerate
@item  Retrieve the message at the head of the queue with @manpage{getq(9)}.
@item  Determine if the message type is high priority and not to be processed here.
@item  If so, pass the message to the @command{put} procedure of the following queue with @manpage{putnext(9)}.
@item  Use @manpage{canput(9)} to determine if messages can be sent onward.
@item  If messages should not be forwarded, put the message back on the queue with
@manpage{putbq(9)} and return from the procedure.
@item  Otherwise, process the message.
@end enumerate

The canonical representation of this processing within a service procedure is as follows:

@smallexample
while (qetq != NULL)
    if (high priority message||canput)
         process message
         putnext
    else
         putbq
    return
@end smallexample

Expedited data have their own flow control with the same general processing as that of ordinary
messages.  @manpage{bcanput(9)} is used to provide modules and drivers with a way to test flow
control in the given priority band.  It returns @samp{1} if a message of the given priority can be
placed on the queue.  It returns @samp{0} if the priority band is flow controlled.  If the band does
not yet exist on the queue in question, the routine returns @samp{1}.

If the band is flow controlled, the higher bands are not affected.  However, the same is not true
for lower bands.  The lower bands are also stopped from sending messages.  If this didn't take place,
the possibility would exist where lower priority messages would be passed along ahead of the flow
controlled higher priority ones.

The call @samp{bcanput(q, 0);} is equivalent to the call @samp{canput(q);}.

A @command{service} procedure must process all messages on its queue unless flow control prevents
this.

A @command{service} procedure continues processing messages form its queue until @manpage{getq(9)}
returns @var{NULL}.  When an ordinary message is enqueued by @manpage{putq(9)}, @command{putq()}
will cause the @command{service} procedure to be scheduled only if the queue was previously empty,
and a previous @command{getq()} call returns @var{NULL} (that is, the @var{QWANTR} flag is set).  If
there are messages on the queue, @command{putq()} presumes the @command{service} procedure is
blocked by flow control and the procedure will be automatically rescheduled by @dfn{STREAMS} when
the block is removed.  If the @command{service} procedure cannot complete processing as a result of
conditions other than flow control (e.g., no buffers), it must ensure it will return later [e.g., by
use of @manpage{bufcall(9)} utility routine] or it must discard all messages on the queue.  If this
is not done, @dfn{STREAMS} will never schedule the @command{service} procedure to be run unless the
queue's @command{put} procedure enqueues a priority message with @command{putq()}.

High priority messages are discarded only if there is already a high priority message on the
@dfn{Stream head} read queue.  That is, there can be only one high priority message present on the
@dfn{Stream head} read queue at any time.

@manpage{putbq(9)} replaces messages at the beginning of the appropriate section of the message
queue in accordance with their priority.  This might not be the same position at which the message
was retrieved by the preceding @manpage{getq(9)}.  A subsequent @command{getq()} might return a
different message.

@manpage{putq(9)} only looks at the priority band in the first message.  If a high priority message
is passed to @command{putq()} with a non-zero @var{b_band} value, @var{b_band} is reset to 0 before
placing the message on the queue.@footnote{Check that @value{PACKAGE_TITLE} actually performs this
action.} If the message is passed to @command{putq()} with a @var{b_band} value that is greater than
the number of @code{qband} structures associated with the queue, @command{putq()} tries to allocate
a new @code{qband} structure for each band up to and including the band of the
message.@footnote{@value{PACKAGE_TITLE} currently only allocated the band in question and does not
allocate intermediate queue band structures as described.}

The above also applies to @manpage{putbq(9)} and @manpage{insq(9)}.  If an attempt is made to insert
a message out of order in a queue via @command{insq()}, the message is not inserted and the routine
fails.

@manpage{putq(9)} will not schedule a queue if @manpage{noenable(9)} had been previously called for
this queue.  @command{noenable()} instructs @command{putq()} to enqueue the message when called by
this queue, but not to schedule the @command{service} procedure.  @command{noenable()} does not
prevent the queue from being scheduled by a flow control back-enable.  The inverse of
@command{noenable()} is @manpage{enableok(9)}.

Driver upstream flow control is explained next as an example.  Although device drivers typically
discard input when unable to send it to a user process, @dfn{STREAMS} allows driver read-side flow
control, possibly for handling temporary upstream blockages.  This is done through a driver read
@command{service} procedure which is disabled during the driver open with @manpage{noenable(9)}.  If
the driver input interrupt routine determines messages can be sent upstream (from
@manpage{canput(0)}), it sends the message with @manpage{putnext(9)}.  Otherwise, it calls
@manpage{putq(9)} to queue the message.  The message waits on the message queue (possibly with queue
length checked when new messages are enqueued by the interrupt routine) until the upstream queue
becomes unblocked.  When the blockage abates, @dfn{STREAMS} back-enables the driver read
@command{service} procedure.  The @command{service} procedure sends the messages upstream using
@manpage{getq(9)} and @manpage{canput(9)}, as described previously.  This is
similar to @command{looprsrv()} (@pxref{Loop-Around Driver}) where the @command{service} procedure
is present only for flow control.

@manpage{qenable(9)}, another flow control utility, allows a module or driver to cause one of its
queues, or another module's queues, to be scheduled.  @command{qenable()} might also be used when a
module or driver wants to delay message processing for some reason.  An example of this is a buffer
module that gathers messages in its message queue and forwards them as a single, larger message.
This module uses @manpage{noenable(9)} to inhibit its @command{service} procedure and queues
messages with its @command{put} procedure until a certain byte count or "in queue" time has been
reached.  When either of these conditions is met, the module calls @manpage{qenable(9)} to cause its
@command{service} procedure to run.

Another example is a communication line discipline module that implements end-to-end (i.e., to a
remote system) flow control.  Outbound data are held on the write-side message queue until the
read-side receives a transmit window from the remote end of the network.

@dfn{STREAMS} routines are called at different priority levels.  Interrupt routines are called at the
interrupt priority of the interrupting device.  Service routines are called with interrupts enabled
(hence @command{service} routines for @dfn{STREAMS} drivers can be interrupted by their own
interrupt routines).  Put routines are generally called at @var{str} priority.

@node Service Interfaces
@section STREAMS Service Interfaces
@cindex service interfaces

@dfn{STREAMS} provides the means to implement a service interface between any two components in a
@dfn{Stream}, and between a user process and the topmost module in the @dfn{Stream}.  A service
interface is defined at the boundary between a service user and a service provider (see
@figref{27}).  A service interface is a set of primitives and the rules that define a service and
the allowable state transitions that result as these primitives are passed between the user and the
provider.  These rules are typically represented by a state machine.  In @dfn{STREAMS}, the service
user and provider are implemented in a module, driver, or user process.  The primitives are carried
bidirectionally between a service user and provider in @var{M_PROTO} and @var{M_PCPROTO} messages.

@dfn{PROTO} messages (@var{M_PROTO} and @var{M_PCPROTO}) can be multi-block, with the second through
last blocks of type @var{M_DATA}.  The first block in a @dfn{PROTO} message contains the control
part of the primitive in a form agreed upon by the user and provider.  The block is not intended to
carry protocol headers.  (Although its use is not recommended, upstream @dfn{PROTO} messages can
have multiple @dfn{PROTO} blocks at the start of the message.  @manpage{getmsg(2)} will compact the
blocks into a single control part when sending to a user process.)  The @var{M_DATA} block(s)
contains any data part associated with the primitive.  The data part may be processed in a module
that receives it, or it may be sent to the next @dfn{Stream} component, along with any data
generated by the module.  The contents of @dfn{PROTO} messages and their allowable sequences are
determined by the service interface specification.

@dfn{PROTO} messages can be sent bidirectionally (upstream and downstream) on a @dfn{Stream} and
between a @dfn{Stream} and a user process.  @manpage{putmsg(2)} and @manpage{getmsg(2)} system calls
are analogous, respectively, to @manpage{write(2)} and @manpage{read(2)} except that the former
allow both data and control parts to be (separately) passed, and they retain the message boundaries
across the user-@dfn{Stream} interface.  @manpage{putmsg(2)} and @manpage{getmsg(2)} separately copy
the control part (@var{M_PROTO} or @var{M_PCPROTO} block) and data part (@var{M_DATA} blocks)
between the @dfn{Stream} and user process.

An @var{M_PCPROTO} message is normally used to acknowledge primitives composed of other messages.
@var{M_PCPROTO} insures that the acknowledgement reaches the service user before any other message.
If the service user is a user process, the @dfn{Stream head} will only store a single
@var{M_PCPROTO} message, and discard subsequent @var{M_PCPROTO} messages until the first one is read
with @manpage{getmsg(2)}.

A @dfn{STREAMS} message format has been defined to simplify the design of service interfaces.
System calls, @manpage{getmsg(2)} and @manpage{putmsg(2)} are available for sending messages
downstream and receiving messages that are available at the @dfn{Stream head}.

This section describes the system calls @command{getmsg} and @command{putmsg} in the context of a
service interface example.  First, a brief overview of @dfn{STREAMS} service interfaces is
presented.

@subsection Service Interface Benefits

A principal advantage of the @dfn{STREAMS} mechanism is its modularity.  From user level,
kernel-resident modules can be dynamically interconnected to implement any reasonable processing
sequence.  This modularity reflects the layering characteristics of contemporary network
architectures.

One benefit of modularity is the ability to interchange modules of like functions.  For example, two
distinct transport protocols, implemented as @dfn{STREAMS} modules, may provide a common set of
services.  An application or higher layer protocol that requires those services can use either
module.  This ability to substitute modules enables user programs and higher level protocols to be
independent of the underlying protocols and physical communication media.

Each @dfn{STREAMS} module provides a set of processing functions, or services, and an interface to those
services.  The service interface of a module defines the interaction between that module and any
neighboring modules, and is a necessary component for providing module substitution.  By creating a
well defined service interface, applications and @dfn{STREAMS} modules can interact with any module that
supports that interface.  @figref{26} demonstrates this.

@figuresized{SPG_fig26,26,Protocol Substitution,4in}

By defining a service interface through which applications interact with a transport protocol, it is
possible to substitute a different protocol below that service interface in a manner completely
transparent to the application.  In this example, the same application can run over the
@dfn{Transmission Control Protocol (TCP)} and the @dfn{ISO} transport protocol.  Of course, the
service interface must define a set of services common to both protocols.

The three components of any service interface are the service user, the service provider, and the
service interface itself, as seen in the following figure.

@figuresized{SPG_fig27,27,Service Interface,3in}

Typically, a user makes a request of a service provider using some well-defined service primitive.
Responses and event indications are also passed from the provider to the user using service
primitives.

Each service interface primitive is a distinct @dfn{STREAMS} message that has two parts; a control part
and a data part.  The control part contains information that identifies the primitive and includes
all necessary parameters.  The data part contains user data associated with that primitive.

An example of a service interface primitive is a transport protocol connect request.  This primitive
requests the transport protocol service provider to establish a connection with another transport
user.  The parameters associated with this primitive may include a destination protocol address and
specific protocol options to be associated with that connection.  Some transport protocols also
allow a user to send data with the connect request.  A @dfn{STREAMS} message would be used to define this
primitive.  The control part would identify the primitive as a connect request and would include the
protocol address and options.  The data part would contain the associated user data.

@subsection Service Interface Library Example

The service interface library example presented here includes four functions that enable a user to
do the following:

@itemize @bullet
@item establish a @dfn{Stream} to the service provider and bind a protocol address to the @dfn{Stream},
@item send data to a remote user,
@item close the @dfn{Stream} connected to the provider
@end itemize

First, the structure and constant definitions required by the library are shown.  These typically
will reside in a header file associated with the service interface.

@smallexample
/*
 * Primitives initiated by the service user.
 */
#define BIND_REQ 1              /* bind request */
#define UNITDATA_REQ 2          /* unitdata request */

/*
 * Primitives initiated by the service provider.
 */
#define OK_ACK 3                /* bind acknowledgment */
#define ERROR_ACK 4             /* error acknowledgment */
#define UNITDATA_IND 5          /* unitdata indication */

/*
 * The following structure definitions define the format of the
 * control part of the service interface message of the above
 * primitives.
 */
struct bind_req @{               /* bind request */
    long PRIM_type;             /* always BIND_REQ */
    long BIND_addr;             /* addr to bind */
@};
struct unitdata_req @{           /* unitdata request */
    long PRIM_type;             /* always UNITDATA_REQ */
    long BEST_addr;             /* destination addr */
@};
struct ok_ack @{                 /* positive acknowledgment */
    long PRIM_type;             /* always OK_ACK */
@};
struct error_ack @{              /* error acknowledgment */
    long PRIM_type;             /* always ERROR_ACK */
    long UNIX_error;            /* UNIX system error code */
@};
struct unitdata_ind @{           /* unitdata indication */
    long PRIM_type;             /* always UNITDATA_IND */
    long SRC_addr;              /* source addr */
@};

/* union of all primitives */
union primitives @{
    long type;
    struct bind_req bind_req;
    struct unitdata_req unitdata_req;
    struct ok_ack ok_ack;
    struct error_ack error_ack;
    struct unitdata_ind unitdata_ind;
@};

/* header files needed by library */
#include <stropts.h>
#include <stdio.h>
#include <errno.h>
@end smallexample

Five primitives have been defined.  The first two represent requests from the service user to the
service provider.  These are:

@table @var
@item BIND_REQ
This request asks the provider to bind a specified protocol address.  It requires an acknowledgement
from the provider to verify that the contents of the request were syntactically correct.
@item UNITDATA_REQ
This request asks the provider to send data to the specified destination address.  It does not
require an acknowledgement from the provider.
@end table

The three other primitives represent acknowledgements of requests, or indications of incoming
events, and are passed from the service provider to the service user.  These are:

@table @var
@item OK_ACK
This primitive informs the user that a previous bind request was received successfully by the
service provider.
@item ERROR_ACK
This primitive informs the user that a non-fatal error was found in the previous bind request.  It
indicates that no action was taken with the primitive that caused the error.
@item UNITDATA_IND
This primitive indicates that data destined for the user has arrived.
@end table

The defined structures describe the contents of the control part of each service interface message
passed between the service user and service provider.  The first field of each control part defines
the type of primitive being passed.

@subsubsection Accessing the Service Provider

The first routine presented, @code{inter_open}, opens the protocol driver device file specified by
path and binds the protocol address contained in addr so that it may receive data.  On success, the
routine returns the file descriptor associated with the open @dfn{Stream}; on failure, it returns
@samp{-1} and sets @code{errno} to indicate the appropriate @cite{UNIX} system error value.

@smallexample
inter_open(path, oflags, addr)
        char *path;
@{
    int fd;
    struct bind_req bind_req;
    struct strbuf ctlbuf;
    union primitives rcvbuf;
    struct error_ack *error_ack;
    int flags;

    if ((fd = open(path, oflags)) < 0)
        return (-1);

    /* send bind request msg down stream */

    bind_req.PRIM_type = BIND_REQ;
    bind_req.BIND_addr = addr;
    ctlbuf.len = sizeof(struct bind_req);
    ctlbuf.buf = (char *) &bind_req;

    if (putmsg(fd, &ctlbuf, NULL, 0) < 0) @{
        close(fd);
        return (-1);
    @}
@end smallexample

After opening the protocol driver, @code{inter_open} packages a bind request message to send
downstream.  @manpage{putmsg(2)} is called to send the request to the service provider.  The bind
request message contains a control part that holds a @code{bind_req} structure, but it has no data
part.  @code{bind_req} is a structure of type @code{strbuf}, and it is initialized with the
primitive type and address.  Notice that the @var{maxlen} field of @var{ctlbuf} is not set before
calling @command{putmsg(2)}.  That is because @command{putmsg(2)} ignores this field.  The
@var{dataptr} argument to @command{putmsg(2)} is set to @samp{NULL} to indicate that the message
contains no data part.  Also, the @var{flags} argument is @samp{0}, which specifies that the message
is not a high priority message.

After @code{inter_open} sends the bind request, it must wait for an acknowledgement from the service
provider, as follows:

@smallexample
    /* wait for ack of request */

    ctlbuf.maxlen = sizeof(union primitives);
    ctlbuf.len = 0;
    ctlbuf.buf = (char *) &rcvbuf;
    flags = RS_HIPRI;

    if (getmsg(fd, &ctlbuf, NULL, &flags) < 0) @{
        close(fd);
        return (-1);
    @}

    /* did we get enough to determine type */
    if (ctlbuf.len < sizeof(long)) @{
        close(fd);
        errno = EPROTO;
        return (-1);
    @}

    /* switch on type (first long in rcvbuf) */
    switch (rcvbuf.type) @{
    default:
        close(fd);
        errno = EPROTO;
        return (-1);

    case OK_ACK:
        return (fd);

    case ERROR_ACK:
        if (ctlbuf.len < sizeof(struct error_ack)) @{
            close(fd);
            errno = EPROTO;
            return (-1);
        @}
        error_ack = (struct error_ack *) &rcvbuf;
        close(fd);
        errno = error_ack->UNIX_error;
        return (-1);
    @}
@}
@end smallexample

@manpage{getmsg(2)} is called to retrieve the acknowledgement of the bind request.  The
acknowledgement message consists of a control part that contains either an @code{ok_ack} or
@code{error_ack} structure, and no data part.

The acknowledgement primitives are defined as priority messages.  Messages are queued in a first-in-
first-out manner within their priority at the @dfn{Stream head}; high priority messages are placed
at the front of the @dfn{Stream head} queue followed by priority band messages and ordinary
messages.  The @dfn{STREAMS} mechanism allows only one high priority message per @dfn{Stream} at the
@dfn{Stream head} at one time; any further high priority messages are queued until the message at
the @dfn{Stream head} is processed.  (There can be only one high priority message present on the
@dfn{Stream head} read queue at any time.)  High priority messages are particularly suitable for
acknowledging service requests when the acknowledgement should be placed ahead of any other messages
at the @dfn{Stream head}.

Before calling getmsg, this routine must initialize the @code{strbuf} structure for the control
part.  @var{buf} should point to a buffer large enough to hold the expected control part, and
@var{maxlen} must be set to indicate the maximum number of bytes this buffer can hold.

Because neither acknowledgement primitive contains a data part, the @var{dataptr} argument to
@command{getmsg(2)} is set to @samp{NULL}.  The @var{flagsp} argument points to an integer
containing the value @var{RS_HIPRI}.  This flag indicates that @command{getmsg(2)} should wait for a
@dfn{STREAMS} high priority message before returning.  It is set because we want to catch the
acknowledgement primitives that are priority messages.  Otherwise if the flag is zero the first
message is taken.  With @var{RS_HIPRI} set, even if a normal message is available,
@command{getmsg(2)} will block until a high priority message arrives.

On return from @command{getmsg(2)}, the @var{len} field is checked to ensure that the control part
of the retrieved message is an appropriate size.  The example then checks the primitive type and
takes appropriate actions.  An @var{OK_ACK} indicates a successful bind operation, and
@code{inter_open} returns the file descriptor of the open @dfn{Stream}.  An @var{ERROR_ACK}
indicates a bind failure, and @manpage{errno(3)} is set to identify the problem with the request.

@subsubsection Closing the Service Provider

The next routine in the service interface library example is inter_close, which closes the
@dfn{Stream} to the service provider.

@smallexample
inter_close(fd)
@{
    close(fd);
@}
@end smallexample

The routine simply closes the given file descriptor.  This will cause the protocol driver to free
any resources associated with that @dfn{Stream}.  For example, the driver may unbind the protocol
address that had previously been bound to that @dfn{Stream}, thereby freeing that address for use by
some other service user.

@subsubsection Sending Data to the Service Provider

The third routine, @code{inter_snd}, passes data to the service provider for transmission to the
user at the address specified in @var{addr}.  The data to be transmitted are contained in the buffer
pointed to by @var{buf} and contains @var{len} bytes.  On successful completion, this routine
returns the number of bytes of data passed to the service provider; on failure, it returns @samp{-1}
and sets @manpage{errno(3)} to an appropriate @cite{UNIX} system error value.

@smallexample
inter_snd(fd, buf, len, addr)
        char *buf;
        long addr;
@{
    struct strbuf ctlbuf;
    struct unitdata_req unitdata_req;

    unitdata_req.PRIM_type = UNITDATA_REQ;
    unitdata_req.DEST_addr = addr;
    ctlbuf.len = sizeof(struct unitdata_req);
    ctlbuf.buf = (char *) &unitdata_req;
    databuf.len = len;
    databuf.buf = buf;

    if (putmsg(fd, &ctlbuf, &databuf, 0) < 0)
        return (-1);

    return (len);
@}
@end smallexample

In this example, the data request primitive is packaged with both a control part and a data part.
The control part contains a @code{unitdata_req} structure that identifies the primitive type and the
destination address of the data.  The data to be transmitted are placed in the data part of the
request message.

Unlike the bind request, the data request primitive requires no acknowledgement from the service
provider.  In the example, this choice was made to minimize the overhead during data transfer.  If
the @command{putmsg(2)} call succeeds, this routine assumes all is well and returns the number of
bytes passed to the service provider.

@subsubsection Receiving Data

The final routine in this example, @code{inter_rcv}, retrieves the next available data.  @var{buf}
points to a buffer where the data should be stored, @var{len} indicates the size of that buffer, and
@var{addr} points to a long integer where the source address of the data will be placed.  On
successful completion, @code{inter_rcv} returns the number of bytes in the retrieved data; on
failure, it returns @samp{-1} and sets the appropriate @cite{UNIX} system error value.

@smallexample
inter_rvc(fd, buf, len, addr)
        char *buf;
        long *addr;
@{
    struct strbuf ctlbuf;
    struct strbuf databuf;
    struct unitdata_ind unitdata_ind;
    int retval;
    int flagsp;

    ctlbuf.maxlen = sizeof(struct unitdata_ind);
    ctlbuf.len = 0;
    ctlbuf.buf = (char *) &unitdata_ind;
    databuf.maxlen = len;
    databuf.len = 0;
    databuf.buf = buf;
    flagsp = 0;

    if ((retval = getmsg(fd, &ctlbuf, &databuf, &flagsp)) < 0)
        return (-1);
    if (unitdata_ind.PRIM_type != UNITDATA_IND) @{
        errno = EPROTO;
        return (-1);
    @}
    if (retval) @{
        errno = EIO;
        return (-1);
    @}
    *addr = unitdata_ind.SRC_addr;
    return (databuf.len);
@}
@end smallexample

@manpage{getmsg(2)} is called to retrieve the data indication primitive, where that primitive
contains both a control and data part.  The control part consists of a @code{unitdata_ind} structure
that identifies the primitive type and the source address of the data sender.  The data part
contains the data itself.

In @var{ctlbuf}, @var{buf} must point to a buffer where the control information will be stored, and
@var{maxlen} must be set to indicate the maximum size of that buffer.  Similar initialization is
done for @var{databuf}.

The integer pointed at by @var{flagsp} in the @command{getmsg(2)} call is set to zero, indicating
that the next message should be retrieved from the @dfn{Stream head}, regardless of its priority.
Data will arrive in normal priority messages.  If no message currently exists at the @dfn{Stream
head}, getmsg will block until a message arrives.

The user's control and data buffers should be large enough to hold any incoming data.  If both
buffers are large enough, @command{getmsg(2)} will process the data indication and return @samp{0},
indicating that a full message was retrieved successfully.  However, if either buffer is not large
enough, @command{getmsg(2)} will only retrieve the part of the message that fits into each user
buffer.  The remainder of the message is saved for subsequent retrieval (if in message non-discard
mode), and a positive, non-zero value is returned to the user.  A return value of @samp{MORECTL}
indicates that more control information is waiting for retrieval.  A return value of @samp{MOREDATA}
indicates that more data are waiting for retrieval.  A return value of @samp{(MORECTL | MOREDATA)}
indicates that data from both parts of the message remain.  In the example, if the user buffers are
not large enough (that is, @command{getmsg(2)} returns a positive, non-zero value), the function
will set [@b{EIO}] to @manpage{errno(3)} and fail.

The type of the primitive returned by @command{getmsg(2)} is checked to make sure it is a data
indication (@var{UNITDATA_IND} in the example).  The source address is then set and the number of
bytes of data is returned.

The example presented is a simplified service interface.  The state transition rules for such an
interface were not presented for the sake of brevity.  The intent was to show typical uses of the
@manpage{putmsg(2)} and @manpage{getmsg(2)} system calls.  See @manpage{putmsg(2)} and
@manpage{getmsg(2)} for further details.  For simplicity, this example did not also consider
expedited data.

@subsubsection Module Service Interface Example

The following example is part of a module which illustrates the concept of a service interface.  The
module implements a simple service interface and mirrors the service interface library example given
earlier.  The following rules pertain to service interfaces:

@itemize @bullet
@item Modules and drivers that support a service interface must act upon all @dfn{PROTO} messages
and not pass them through.
@item Modules may be inserted between a service user and a service provider to manipulate the data
part as it passes between them.  However, these modules may not alter the contents of the control
part (@dfn{PROTO} block, first message block) nor alter the boundaries of the control or data parts.
That is, the message blocks comprising the data part may be changed, but the message may not be
split into separate messages nor combined with other messages.
@end itemize

In addition, modules and drivers must observe the rule that high priority messages are not subject
to flow control and forward them accordingly.

@subsubheading Declarations

The service interface primitives are defined in the declarations:

@smallexample
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>
#include <sys/errno.h>

/* Primitives initiated by the service user */

#define BIND_req 1              /* bind request */
#define UNITDATA_REQ 2          /* unitdata request */

/* Primitives initiated by the service provider */

#define OK_ACK 3                /* bind acknowledgment */
#define ERROR_ACK 4             /* error acknowledgment */
#define UNITDATA_IND 5          /* unitdata indication */
/*
 * The following structures define the format of the
 * stream message block of the above primitives.
 */
struct bind_req @{               /* bind request */
    long PRIM_type;             /* always BIND_REQ */
    long BIND_addr;             /* addr to bind */
@};
struct unitdata_req @{           /* unitdata request */
    long PRIM_type;             /* always UNITDATA_REQ */
    long DEST_addr;             /* dest addr */
@};
struct ok_ack @{                 /* ok acknowledgment */
    long PRIM_type;             /* always OK_ACK */
@};
struct error_ack @{              /* error acknowledgment */
    long PRIM_type;             /* always ERROR_ACK */
    long UNIX_error;            /* UNIX system error code */
@};
struct unitdata_ind @{           /* unitdata indication */
    long PRIM_type;             /* always UNITDATA_IND */
    long SRC_addr;              /* source addr */
@};
union primitives @{              /* union of all primitives */
    long type;
    struct bind_req bind_req;
    struct unitdata_req unitdata_req;
    struct ok_ack ok_ack;
    struct error_ack error_ack;
    struct unitdata_ind unitdata_ind;
@};
struct dgproto @{                /* structure per minor device */
    short state;                /* current provider state */
    long addr;                  /* net address */
@};

/* provider states */
#define IDLE 0
#define BOUND 1
@end smallexample

In general, the @var{M_PROTO} or @var{M_PCPROTO} block is described by a data structure containing
the service interface information.  In this example, union primitives is that structure.

Two commands are recognized by the module:

@table @var
@item BIND_REQ
Give this @dfn{Stream} a protocol address (i.e., give it a name on the network).  After a
@var{BIND_REQ} is completed, data from other senders will find their way through the network to this
particular @dfn{Stream}.
@item UNITDATA_REQ
Send data to the specified address.
@end table

Three messages are generated:

@table @var
@item OK_ACK
A positive acknowledgement (ack) of @var{BIND_REQ}.
@item ERROR_ACK
A negative acknowledgement (nak) of @var{BIND_REQ}.
@item UNITDATA_IND
Data from the network have been received (this code is not shown).
@end table

The acknowledgement of a @var{BIND_REQ} informs the user that the request was syntactically correct
(or incorrect if @var{ERROR_ACK}).  The receipt of a @var{BIND_REQ} is acknowledged with an
@var{M_PCPROTO} to insure that the acknowledgement reaches the user before any other message.  For
example, a @var{UNITDATA_IND} could come through before the bind has completed, and the user would
get confused.

The driver uses a per-minor device data structure, dgproto, which contains the following:

@table @var
@item state
current state of the service provider @var{IDLE} or @var{BOUND}
@item addr
network address that has been bound to this @dfn{Stream}
@end table

It is assumed (though not shown) that the module open procedure sets the write queue @var{q_ptr} to
point at the appropriate private data structure.

@subsubheading Service Interface Procedure

The write put procedure is:

@smallexample
static int
protowput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    union primitives *proto;
    struct dgproto *dgproto;
    int err;

    dgproto = (struct dgproto *) q->q_ptr;

    switch (mp->b_datap->db_type) @{

    default:
        /* don't understand it */
        mp->b_datap->db_type = M_ERROR;
        mp->b_rptr = mp->b_wptr = mp->b_datap->db_base;
        *mp->b_wptr++ = EPROTO;
        qreply(q, mp);
        break;

    case M_FLUSH:
        /* standard flush handling goes here ...  */
        break;

    case M_PROTO:
        /* Protocol message -> user request */
        proto = (union primitives *) mp->b_rptr;

        switch (proto->type) @{
        default:
            mp->b_datap->db_type = M_ERROR;
            mp->b_rptr = mp->wptr = mp->b_datap->db_base;
            *mp->b_wptr++ = EPROTO;
            qreply(q, mp);
            break;

        case BIND_REQ:
            if (dgproto->state != IDLE) @{
                err = EINVAL;
                goto error_ack;
            @}
            if (mp->b_wptr - mp->b_rptr != sizeof(struct bind req)) @{
                err = EINVAL;
                goto error_ack;
            @}
            if (err = chkaddr(proto->bind_req.BIND_addr))
                goto error_ack;

            dgproto->state = BOUND;
            dgproto->addr = proto->bind_req.BIND_addr;
            mp->b_datap->db_type = M_PCPROTO;
            proto->type = OK_ACK;
            mp->b_wptr = mp->b_rptr + sizeof(struct ok_ack);
            qreply(q, mp);
            break;

          error_ack:
            mp->b_datap->db_type = M_PCPROTO;
            proto->type = ERROR_ACK;
            proto->error_ack.UNIX_error = err;
            mp->b_wptr = mp->b_rptr + sizeof(struct error_ack);
            greply(q, mp);
            break;

        case UNITDATA_REQ:
            if (dgproto->state != BOUND)
                goto bad;
            if (mp->b_wptr - mp->b_rptr != sizeof(struct unitdata_req))
                goto bad;
            if (err = chkaddr(proto->unitdata_req.DEST_addr)) @{
                goto bad;
                putq(q, mp);
                /* start device or mux output ...  */
            @}
            break;

          bad:
            freemsg(mp);
            break;
        @}
    @}
@}
@end smallexample

The write put procedure switches on the message type.  The only types accepted are @var{M_FLUSH} and
@var{M_PROTO}.  For @var{M_FLUSH} messages, the driver will perform the canonical flush handling
(not shown).  For @var{M_PROTO} messages, the driver assumes the message block contains a union
primitive and switches on the type field.  Two types are understood: @var{BIND_REQ} and
@var{UNITDATA_REQ}.

For a @var{BIND_REQ}, the current state is checked; it must be @var{IDLE}.  Next, the message size
is checked.  If it is the correct size, the passed-in address is verified for legality by calling
@command{chkaddr}.  If everything checks, the incoming message is converted into an @var{OK_ACK} and
sent upstream.  If there was any error, the incoming message is converted into an @var{ERROR_ACK}
and sent upstream.

For @var{UNITDATA_REQ}, the state is also checked; it must be @var{BOUND}.  As above, the message
size and destination address are checked.  If there is any error, the message is simply discarded.
If all is well, the message is put on the queue, and the lower half of the driver is started.

If the write @command{put} procedure receives a message type that it does not understand, either a
bad @samp{b_datap->db_type} or bad @samp{proto->type}, the message is converted into an
@var{M_ERROR} message and sent upstream.

The generation of @var{UNITDATA_IND} messages (not shown in the example) would normally occur in the
device interrupt if this is a hardware driver or in the lower read @command{put} procedure if this
is a multiplexor.  The algorithm is simple: The data part of the message is prepended by an
@var{M_PROTO} message block that contains a @code{unitdata_ind} structure and sent upstream.

@node Message Allocation
@section STREAMS Message Allocation and Freeing
@cindex message allocation and freeing

The @manpage{allocb(9)} utility routine is used to allocate a message and the space to hold the data
for the message.  @manpage{allocb(9)} returns a pointer to a message block containing a data buffer
of at least the size requested, providing there is enough memory available.  It returns null on
failure.  Note that @command{allocb()} always returns a message of type @var{M_DATA}.  The type may
then be changed if required.  @var{b_rptr} and @var{b_wptr} are set to @var{db_base} (see
@manpage{msgb(9)} and @manpage{datab(9)}) which is the start of the memory location for the data.

@command{allocb()} may return a buffer larger than the size requested.  If @command{allocb()}
indicates buffers are not available [@command{allocb()} fails], the @command{put}/@command{service}
procedure may not call @manpage{sleep(9)} to wait for a buffer to become available.  Instead, the
@manpage{bufcall(9)} utility can be used to defer processing in the module or the driver until a
buffer becomes available.

If message space allocation is done by the @command{put} procedure and @command{allocb()} fails, the
message is usually discarded.  If the allocation fails in the @command{service} routine, the message
is returned to the queue.  @manpage{bufcall(9)} is called to enable to the @command{service} routine
when a message buffer becomes available, and the @command{service} routine returns.

The @manpage{freeb(9)} utility routine releases (de-allocates) the message block descriptor and the
corresponding data block, if the reference count (see datab structure) is equal to @samp{1}.  If the
reference counter exceeds @samp{1}, the data block is not released.

The @manpage{freemsg(9)} utility routine releases all message blocks in a message.  It uses
@command{freeb()} to free all message blocks and corresponding data blocks.

In the following example, @command{allocb()} is used by the @code{bappend} subroutine that appends a
character to a message block:

@smallexample
/*
 * Append a character to a message block.
 * If (*bpp) is null, it will allocate a new block
 * Returns 0 when the message block is full, 1 otherwise
 */

#define MODBLKSZ 128            /* size of message blocks */

static
bappend(bpp, ch)
        mblk_t **bpp;
        int ch;
@{
    mblk_t *bp;

    if ((bp = *bpp) != NULL) @{
        if (bp->b_wptr >= bp->b_datap->db_lim)
            return 0;
    @} else if ((*bpp = bp = allocb(MODBLKSZ, BPRI_MED)) == NULL)
        return 1;
    *bp->b_wptr++ = ch;
    return 1;
@}
@end smallexample

@code{bappend} receives a pointer to a message block pointer and a character as arguments.  If a
message block is supplied @samp{(*bpp != NULL)}, @code{bappend} checks if there is room for more data in
the block.  If not, it fails.  If there is no message block, a block of at least @var{MODBLKSZ} is
allocated through @command{allocb()}.

If the @command{allocb()} fails, @code{bappend} returns success, silently discarding the character.
This may or may not be acceptable.  For @dfn{TTY}-type devices, it is generally accepted.  If the
original message block is not full or the @command{allocb()} is successful, @code{bappend} stores
the character in the block.

The next example, subroutine @code{modwput} processes all the message blocks in any downstream data
(type @var{M_DATA}) messages.  @command{freemsg()} deallocates messages.

@smallexample
/* Write side put procedure */
static
modwput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    switch (mp->b_datap->db_TYPE) @{
    default:
        putnext(q, mp);         /* Don't do these, pass them along */
        break;

    case M_DATA:@{
        register mblk_t *bp;
        struct mblk_t *nmp = NULL, *nbp = NULL;

        for (bp = mp; bp != NULL; bp = bp->b_cont) @{
            while (bp->b_rptr < bp->b_wptr) @{
                if (*bp->b_rptr == '\n')
                    if (!bappend(&nbp, '\r'))
                        goto newblk;
                if (!bappend(&nbp, *bp->b_rptr))
                    goto newblk;
                bp->b_rpt++;
                continue;

              newblk:
                if (nmp == NULL)
                    nmp = nbp;
                else
                    linkb(nmp, nbp);    /* link message block to tail of nmp */
                nbp = NULL;
            @}
        @}
        if (nmp == NULL)
            nmp = nbp;
        else
            linkb(nmp, nbp);
        freemsg(mp);            /* de-allocate message */
        if (nmp)
            putnext(q, nmp);
    @}
    @}
@}
@end smallexample

Data messages are scanned and filtered.  @code{modwput1} copies the original message into a new
block(s), modifying as it copies.  @var{nbp} points to the current new message block.  @var{nmp}
points to the new message being formed as multiple @var{M_DATA} message blocks.  The outer
@command{for()} loop goes through each message block of the original message.  The inner
@command{while()} loop goes through each byte.  @code{bappend} is used to add characters to the
current or new block.  If @code{bappend} fails, the current new block is full.  If @var{nmp} is
@samp{NULL}, @var{nmp} is pointed at the new block.  If @var{nmp} is not @samp{NULL}, the new block
is linked to the end of @var{nmp} by use of the @manpage{linkb(9)} utility.

At the end of the loops, the final new block is linked to @var{nmp}.  The original message (all
message blocks) is returned to the pool by @manpage{freemsg(9)}.  If a new message exists, it is
sent downstream.

@subsubsection Recovering From No Buffers

The @manpage{bufcall(9)} utility can be used to recover from an @manpage{allocb(9)} failure.  The
call syntax is as follows:

@smallexample
bufcall()(size, pri, func.arg);
    int size, pri, (*func) ();
    long arg;
@end smallexample

@command{bufcall()} calls @samp{(*func)(arg)} when a buffer of size bytes is available.  When
@var{func} is called, it has no user context and must return without sleeping.  Also, because of
interrupt processing, there is no guarantee that when @var{func} is called, a buffer will actually
be available (someone else may steal it).

On success, @command{bufcall()} returns a nonzero identifier that can be used as a parameter to
@manpage{unbufcall(9)} to cancel the request later.  On failure, @samp{0} is returned and the
requested function will never be called.

Care must be taken to avoid deadlock when holding resources while waiting for @command{bufcall()} to
call @samp{(*func)(arg)}.  @command{bufcall()} should be used sparingly.

Two examples are provided.  The first example is a device receive interrupt handler:

@smallexample
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>

dev_rintr(dev)
@{
    /* process incoming message ...  */

    /* allocate new buffer for device */
    dev_re_load(dev);
@}

/*
 * Reload device with a new receive buffer
 */
dev_re_load(dev)
@{
    mblk_t *bp;

    if ((bp = allocb(DEVBLKSZ, BPRI_MED)) == NULL) @{
        cmn_err(CE_WARN, "dev: allocb failure (size %d)\n", DEVBLKSZ);
        /* Allocation failed.  Use bufcall to * schedule a call to ourselves. */
        (void) bufcall(DEVBLKSZ, BPRI_MED, dev_re_load, dev);
        return;
    @}

    /* pass buffer to device ...  */
@}
@end smallexample

@code{dev_rintr} is called when the device has posted a receive interrupt.  The code retrieves the
data from the device (not shown).  @code{dev_rintr} must then give the device another buffer to fill
by a call to @code{dev_re_load}, which calls @manpage{allocb(9)}.  If @command{allocb()} fails,
@code{dev_re_load} uses @manpage{bufcall(9)} to call itself when @dfn{STREAMS} determines a buffer
is available.

Since @command{bufcall()} may fail, there is still a chance that the device may hang.  A better
strategy, in the event @command{bufcall()} fails, would be to discard the current input message and
resubmit that buffer to the device.  Losing input data is generally better than hanging.

The second example is a write @command{service} procedure, @code{mod_wsrv}, which needs to prepend
each output message with a header.  @code{mod_wsrv} illustrates a case for potential deadlock:

@smallexample
static int
mod_wsrv(q)
        queue_t *q;
@{
    int qenable();
    mblk_t *mp, *bp;

    while (mp = getq(q)) @{
        /* check for priority messages and canput ...  */

        /* Allocate a header to prepend to the message.  If the allocb fails,
           use bufcall to reschedule. */
        if ((bp = allocb(HDRSZ, BPRI_MED)) == NULL) @{
            if (!bufcall(HDRSZ, BPRI_MED, qenable, q)) @{
                timeout(qenable, q, HZ * 2);
            @}
            /* Put the message back and exit, we will be re-enabled later */
            putbq(q, mp);
            return;
        @}
        /* process message ...  */
    @}
@}
@end smallexample

However, if @manpage{allocb(9)} fails, @code{mod_wsrv} wants to recover without loss of data and
calls @manpage{bufcall(9)}.  In this case, the routine passed to @command{bufcall()} is
@manpage{qenable(9)}.  When a buffer is available, the @command{service} procedure will be
automatically re-enabled.  Before exiting, the current message is put back on the queue.  This
example deals with @command{bufcall()} failure by resorting to the @manpage{timeout(9)} operating
system utility routine.  @command{timeout()} will schedule the given function to be run with the
given argument in the given number of clock ticks (there are @var{HZ} ticks per second).  In this
example, if @command{bufcall()} fails, the system will run @manpage{qenable(9)} after two seconds
have passed.@footnote{Under @value{PACKAGE_TITLE}, it is not a good strategy to call
@manpage{timeout(9)} when @manpage{bufcall(9)} fails.  This is because if @manpage{bufcall(9)} fails
to allocate resource for the buffer callback, @manpage{timeout(9)} is also likely to fail to
allocate necessary resources.  A as final resort, if @manpage{timeout(9)} fails, the
@command{service} procedure can simply re-enable itself with @manpage{qenable(9)} and try again when
it is rescheduled.}

@node Extended Buffers
@section STREAMS Extended Buffers
@cindex extended buffers

Some hardware using the @dfn{STREAMS} mechanism supports memory-mapped I/O that allows the sharing
of buffers between users, kernel, and the I/O card.

If the hardware supports memory-mapped I/O, data received from the network are placed in the
@dfn{DARAM} (dual access RAM) section of the I/O card.  Since @dfn{DARAM} is a shared memory between
the kernel and the I/O card, data transfer between the kernel and the I/O card is eliminated.  Once
in kernel space, the data buffer can be manipulated as if it were a kernel resident buffer.
Similarly, data being sent downstream are placed in @dfn{DARAM} and then forwarded to the network.

In a typical network arrangement, data are received from the network by the I/O card.  The disk
controller reads the block of data into the card's internal buffer.  It interrupts the host computer
to denote that data have arrived.  The @dfn{STREAMS} driver gives the controller the kernel address
where the data block is to go and the number of bytes to transfer.  After the disk controller has
read the data into its buffer and verified the checksum, it copies the data into main memory to the
address specified by the the @dfn{DMA} (@dfn{direct memory access}) memory address.  Once in the
kernel space, the data are packaged into message blocks and processed on the usual manner.

When data are transmitted from user process to the network, data are copied from the user space to
the kernel space, and packaged as a message block and sent to the downstream driver.  The driver
interrupts the I/O card signaling that data are ready to be transmitted to the network.  The
controller copies the data from the kernel space to the internal buffer on the I/O card, and from
there data are placed on the network.

The @dfn{STREAMS} buffer allocation mechanism enables the allocation of message and data blocks to
point directly to a client-supplied (non-@dfn{STREAMS}) buffer.  Message and data blocks allocated
this way are indistinguishable (for the most part) from the normal data blocks.  The client-supplied
buffers are processed as if they were normal @dfn{STREAMS} data buffers.

Drivers may not only attach non-@dfn{STREAMS} data buffers but also free them.  This is accomplished
as follows:

@itemize @bullet
@item Allocation If the drivers are to use @dfn{DARAM} without wasting @dfn{STREAMS} resources and
without being dependent on upstream modules, a data and message block can be allocated without an
attached data buffer.  The routine to use is called @manpage{esballoc(9)}.  This returns a message
block and data block without an associated @dfn{STREAMS} buffer.  Rather, the buffer used is the one
supplied by the caller.
@item Freeing Each driver using non-@dfn{STREAMS} resources in a @dfn{STREAMS} environment must
fully manage those resources, including freeing them.  However, to make this as transparent as
possible, a driver-dependent routine is executed in the event @manpage{freeb(9)} is called to free a
message and data block with an attached non-@dfn{STREAMS} buffer.  @manpage{freeb(9)} detects if a
buffer is a client supplied, non-@dfn{STREAMS} buffer.  If it is, @manpage{freeb(9)} finds the
@code{free_rtn} structure associated with that buffer.  After calling the driver-dependent routine
(defined in @code{free_rtn}) to free the buffer, the @manpage{freeb(9)} routine frees the message and
data block.
@end itemize

The format of the @code{free_rtn} structure is as follows:

@smallexample
struct free_rtn @{
    void (*free_func) ();       /* driver dependent free routine */
    char *free_arg;             /* argument for free_rtn */
@};
typedef struct free_rtn frtn_t;
@end smallexample

The structure has two fields: a pointer to a function and a location for any argument passed to the
function.  Instead of defining a specific number of arguments, @var{free_arg} is defined as a
@samp{char *}.  This way, drivers can pass pointers to structures in the event more than one
argument is needed.

The @dfn{STREAMS} utility routine, @manpage{esballoc(9)}, provides a common interface for allocating
and initializing data blocks.  It makes the allocation as transparent to the driver as possible and
provides a way to modify the fields of the data block, since modification should only be performed
by @dfn{STREAMS}.  The driver calls this routine when it wants to attach its own data buffer to a
newly allocated message and data block.  If the routine successfully completes the allocation and
assigns the buffer, it returns a pointer to the message block.  The driver is responsible for
supplying the arguments to @manpage{esballoc(9)}, namely, a pointer to its data buffer, the size of
the buffer, the priority of the data block, and a pointer to the @code{free_rtn} structure.  All
arguments should be non-@samp{NULL}.  See @ref{STREAMS Utilities}, for a detailed description of
@manpage{esballoc(9)}.

@node Polling
@chapter Polling and Signalling
@cindex polling and signalling
@menu
* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal
@end menu

@node Input and Output Polling
@section STREAMS Input and Output Polling
@cindex input and output polling

This chapter describes the synchronous polling mechanism and asynchronous event notification within
@dfn{STREAMS}.  Also discussed is how a @dfn{Stream} can be a controlling terminal.

User processes can efficiently monitor and control multiple @dfn{Streams} with two system calls:
@manpage{poll(2)} and the @var{I_SETSIG} @manpage{ioctl(2)} command.  These calls allow a user
process to detect events that occur at the @dfn{Stream head} on one or more @dfn{Streams}, including
receipt of data or messages on the read queue and cessation of flow control.

To monitor @dfn{Streams} with @manpage{poll(2)}, a user process issues that system call and
specifies the @dfn{Streams} to be monitored, the events to look for, and the amount of time to wait
for an event.  The @manpage{poll(2)} system call will block the process until the time expires or
until an event occurs.  If an event occurs, it will return the type of event and the @dfn{Stream} on
which the event occurred.

Instead of waiting for an event to occur, a user process may want to monitor one or more
@dfn{Streams} while processing other data.  It can do so by issuing the @var{I_SETSIG}
@manpage{ioctl(2)} command, specifying one or more @dfn{Streams} and events [as with
@manpage{poll(2)}].  This @command{ioctl} does not block the process and force the user process to
wait for the event but returns immediately and issues a signal when an event occurs.  The process
must request @manpage{signal(2)} to catch the resultant @var{SIGPOLL} signal.

If any selected event occurs on any of the selected @dfn{Streams}, @dfn{STREAMS} will cause the
@var{SIGPOLL} catching function to be executed in all associated requesting processes.  However, the
process(es) will not know which event occurred, nor on what @dfn{Stream} the event occurred.  A
process that issues the @var{I_SETSIG} can get more detailed information by issuing a poll after it
detects the event.

@subsection Syncrhonous Input and Output

The @manpage{poll(2)} system call provides a mechanism to identify those @dfn{Streams} over which a
user can send or receive data.  For each @dfn{Stream} of interest users can specify one or more
events about which they should be notified.  The types of events that can be polled are
@var{POLLIN}, @var{POLLRDNORM}, @var{POLLRDBAND}, @var{POLLPRI}, @var{POLLOUT}, @var{POLLWRNORM},
@var{POLLWRBAND}, @var{POLLMSG}, and @var{POLLNORM}:

@vtable @var
@item POLLIN
A message other than an @var{M_PCPROTO} is at the front of the @dfn{Stream head} read queue.  This
event is maintained for compatibility with the previous releases of the @cite{UNIX System V}.
@item POLLRDNORM
A normal (non-priority) message is at the front of the @dfn{Stream head} read queue.
@item POLLRDBAND
A priority message (@samp{band > 0}) is at the front of the @dfn{Stream head} read queue.
@item POLLPRI
A high priority message (@var{M_PCPROTO}) is at the front of the @dfn{Stream head} read queue.
@item POLLOUT
The normal priority band of the queue is writable (not flow controlled).
@item POLLWRNORM
The same as @var{POLLOUT}.
@item POLLWRBAND
A priority band greater than @samp{0} of a queue downstream exists and is writable.
@item POLLMSG
An @var{M_SIG} or @var{M_PCSIG} message containing the @var{SIGPOLL} signal has reached the front of
the @dfn{Stream head} read queue.
@item POLLNORM
The same as @var{POLLRDNORM}.
@end vtable

Some of the events may not be applicable to all file types.  For example, it is not expected that
the @var{POLLPRI} event will be generated when polling a regular file.  @var{POLLIN},
@var{POLLRDNORM}, @var{POLLRDBAND}, and @var{POLLPRI} are set even if the message is of zero length.

The @command{poll} system call will examine each file descriptor for the requested events and, on return, will
indicate which events have occurred for each file descriptor.  If no event has occurred on any
polled file descriptor, @command{poll} blocks until a requested event or timeout occurs.
@manpage{poll(2)} takes the following arguments:

@itemize @bullet
@item an array of file descriptors and events to be polled
@item the number of file descriptors to be polled
@item the number of milliseconds @command{poll} should wait for an event if no events are pending (@samp{-1}
specifies wait forever)
@end itemize

The following example shows the use of @command{poll}.  Two separate minor devices of the
communications driver are opened, thereby establishing two separate @dfn{Streams} to the driver.
The @var{pollfd} entry is initialized for each device.  Each @dfn{Stream} is polled for incoming
data.  If data arrive on either @dfn{Stream}, data are read and then written back to the other
@dfn{Stream}.

@smallexample
#include <stropts.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>

#define NPOLL 2                 /* number of file descriptors to poll */

main()
@{
    struct pollfd pollfds[NPOLL];
    char buf[1024];
    int count, i;

    if ((pollfds[0].fd = open("/dev/comm/01", O_RDWR | O_NDELAY)) < 0) @{
        perror("open failed for /dev/comm/01");
        exit(1);
    @}
    if ((pollfds[1].fd = open("/dev/comm/02", O_RDWR | O_NDELAY)) < 0) @{
        perror("open failed for /dev/comm/02");
        exit(2);
    @}
@end smallexample

The variable pollfds is declared as an array of the pollfd structure that is defined in @file{<poll.h>}
and has the following format:

@smallexample
struct pollfd @{
        int fd;                 /* file descriptor */
        short events;           /* requested events */
        short revents;          /* returned events */
@}
@end smallexample

For each entry in the array, @var{fd} specifies the file descriptor to be polled and events is a
bitmask that contains the bitwise inclusive OR of events to be polled on that file descriptor.  On
return, the revents bitmask will indicate which of the requested events has occurred.

The example continues to process incoming data as follows:

@smallexample
    pollfds[0].events = POLLIN; /* set events to poll pollfds[1].events =
                                   POLLIN; * for incoming data */
    while (1) @{
        /* poll and use -1 timeout (infinite) */
        if (poll(pollfds, NPOLL, -1) < 0) @{
            perror("poll failed");
            exit(3);
        @}
        for (i = 0; i < NPOLL; i++) @{
            switch (pollfds[i].revents) @{

            default:            /* default error case */
                perror("error event");
                exit(4);

            case 0:             /* no events */
                break;

            case POLLIN:
                /* echo incoming data on "other" Stream */
                while ((count = read(pollfds[i].fd, buf, 1024)) > 0)
                    /* 
                       * the write loses data if flow control * prevents the
                       transmit at this time. */
                    if (write(pollfds[(i + 1) % 2].fd, buf, count) != count)
                        fprintf(stderr, "writer lost data \n");
                break;
            @}
        @}
    @}
@}
@end smallexample

The user specifies the polled events by setting the events field of the @var{pollfd} structure to
@var{POLLIN}.  This requested event directs @command{poll} to notify the user of any incoming data on each
@dfn{Stream}.  The bulk of the example is an infinite loop, where each iteration will poll both
@dfn{Streams} for incoming data.

The second argument to the @command{poll} system call specifies the number of entries in the
@var{pollfds} array (@samp{2} in this example).  The third argument is a timeout value indicating
the number of milliseconds @command{poll} should wait for an event if none has occurred.  On a
system where millisecond accuracy is not available, timeout is rounded up to the nearest value
available on that system.  If the value of timeout is 0, @command{poll} returns immediately.  Here,
the value of timeout is @samp{-1}, specifying that @command{poll} should block until a requested
event occurs or until the call is interrupted.

If the @command{poll} call succeeds, the program looks at each entry in the @var{pollfds} array.  If
@var{revents} is set to @samp{0}, no event has occurred on that file descriptor.  If @var{revents}
is set to @var{POLLIN}, incoming data are available.  In this case, all available data are read from
the polled minor device and written to the other minor device.

If @var{revents} is set to a value other than @samp{0} or @var{POLLIN}, an error event must have
occurred on that @dfn{Stream}, because @var{POLLIN} was the only requested event.  The following are
@command{poll} error events:

@vtable @var
@item POLLERR
A fatal error has occurred in some module or driver on the @dfn{Stream} associated with the
specified file descriptor.  Further system calls will fail.
@item POLLHUP
A hangup condition exists on the @dfn{Stream} associated with the specified file descriptor.  This
event and @var{POLLOUT} are mutually exclusive; a @dfn{Stream} can't be writable if a hangup has
occurred.
@item POLLNVAL
The specified file descriptor is not associated with an open @dfn{Stream}.
@end vtable

These events may not be polled for by the user, but will be reported in @var{revents} whenever they
occur.  As such, they are only valid in the @var{revents} bitmask.

The example attempts to process incoming data as quickly as possible.  However, when writing data to
a @dfn{Stream}, the write call may block if the @dfn{Stream} is exerting flow control.  To prevent
the process from blocking, the minor devices of the communications driver were opened with the
@var{O_NDELAY} (or @var{O_NONBLOCK}, see note) flag set.  The write will not be able to send all the
data if flow control is exerted and @var{O_NDELAY} (@var{O_NONBLOCK}) is set.  This can occur if the
communications driver is unable to keep up with the user's rate of data transmission.  If the
@dfn{Stream} becomes full, the number of bytes the write sends will be less than the requested
count.  For simplicity, the example ignores the data if the @dfn{Stream} becomes full, and a warning
is printed to @dfn{stderr}.

For conformance with the @dfn{IEEE} operating system interface standard, @dfn{POSIX}, it is
recommended that new applications use the @var{O_NONBLOCK} flag, whose behavior is the same as that
of @var{O_NDELAY} unless otherwise noted.

This program continues until an error occurs on a @dfn{Stream}, or until the process is interrupted.

@subsection Asyncrhonous Input and Output

The @command{poll} system call described before enables a user to monitor multiple @dfn{Streams} in
a synchronous fashion.  The @manpage{poll(2)} call normally blocks until an event occurs on any of
the polled file descriptors.  In some applications, however, it is desirable to process incoming
data asynchronously.  For example, an application may wish to do some local processing and be
interrupted when a pending event occurs.  Some time-critical applications cannot afford to block,
but must have immediate indication of success or failure.

The @var{I_SETSIG} @manpage{ioctl(2)} call [see @manpage{streamio(7)}] is used to request that a
@var{SIGPOLL} signal be sent to a user process when a specific event occurs.  Listed below are
events for the @command{ioctl} @var{I_SETSIG}.  These are similar to those described for
@manpage{poll(2)}.

@vtable @var
@item S_INPUT
@var{M_PCPROTO} is at the front of the @dfn{Stream head} read queue.  This event is maintained for
compatibility with the previous releases of the @cite{UNIX System V}.
@item S_RDNORM
A normal (non-priority) message is at the front of the @dfn{Stream head} read queue.
@item S_RDBAND
A priority message (@samp{band > 0}) is at the front of the @dfn{Stream head} read queue.
@item S_HIPRI
A high priority message (@var{M_PCPROTO}) is present at the front of the @dfn{Stream head} read
queue.
@item S_OUTPUT
A write queue for normal data (priority band = 0) is no longer full (not flow controlled).  This
notifies a user that there is room on the queue for sending or writing normal data downstream.
@item S_WRNORM
The same as @var{S_OUTPUT}.
@item S_WRBAND
A priority band greater than @samp{0} of a queue downstream exists and is writable.  This notifies a
user that there is room on the queue for sending or writing priority data downstream.
@item S_MSG
An @var{M_SIG} or @var{M_PCSIG} message containing the @var{SIGPOLL} flag has reached the front of
@dfn{Stream head} read queue.
@item S_ERROR
An @var{M_ERROR} message reaches the @dfn{Stream head}.
@item S_HANGUP
An @var{M_HANGUP} message reaches the @dfn{Stream head}.
@item S_BANDURG
When used in conjunction with @var{S_RDBAND}, @var{SIGURG} is generated instead @var{SIGPOLL} when a
priority message reaches the front of the @dfn{Stream head} read queue.
@end vtable

@var{S_INPUT}, @var{S_RDNORM}, @var{S_RDBAND}, and @var{S_HIPRI} are set even if the message is of
zero length.  A user process may choose to handle only high priority messages by setting the
@var{arg} to @var{S_HIPRI}.

@subsection Signals

@dfn{STREAMS} allows modules and drivers to cause a signal to be sent to user process(es) through an
@var{M_SIG} or @var{M_PCSIG} message.  The first byte of the message specifies the signal for the
@dfn{Stream head} to generate.  If the signal is not @var{SIGPOLL} [see @manpage{signal(2)}], the
signal is sent to the process group associated with the @dfn{Stream}.  If the signal is
@var{SIGPOLL}, the signal is only sent to processes that have registered for the signal by using the
@var{I_SETSIG} @manpage{ioctl(2)}.

An @var{M_SIG} message can be used by modules or drivers that wish to insert an explicit inband
signal into a message @dfn{Stream}.  For example, this message can be sent to the user process
immediately before a particular service interface message to gain the immediate attention of the
user process.  When the @var{M_SIG} message reaches the head of the @dfn{Stream} head read queue, a
signal is generated and the @var{M_SIG} message is removed.  This leaves the service interface
message as the next message to be processed by the user.  Use of the @var{M_SIG} message is
typically defined as part of the service interface of the driver or module.

@subsubsection Extended Signals

To enable a process to obtain the band and event associated with @var{SIGPOLL} more readily,
@dfn{STREAMS} supports extended signals.  For the given events, a special code is defined in
@file{siginfo.h} that describes the reason @var{SIGPOLL} was generated.  The following table
describes the data available in the @code{siginfo_t} structure passed to the signal handler.

@multitable @columnfractions .20 .20 .20 .20 .20
@item event @tab @code{si_signo} @tab @code{si_code} @tab @code{si_band} @tab @code{si_errno}
@item @var{S_INPUT} @tab @var{SIGPOLL} @tab @var{POLL_IN} @tab band readable @tab unused
@item @var{S_OUTPUT} @tab @var{SIGPOLL} @tab @var{POLL_OUT} @tab band writable @tab unused
@item @var{S_MSG} @tab @var{SIGPOLL} @tab @var{POLL_MSG} @tab band signaled @tab unused
@item @var{S_ERROR} @tab @var{SIGPOLL} @tab @var{POLL_ERR} @tab unused @tab @dfn{Stream} error
@item @var{S_HANGUP} @tab @var{SIGPOLL} @tab @var{POLL_HUP} @tab unused @tab unused
@item @var{S_HIPRI} @tab @var{SIGPOLL} @tab @var{POLL_PRI} @tab unused @tab unused
@end multitable

@node Controlling Terminal
@section STREAMS Stream as Controlling Terminal
@cindex stream as controlling terminal

@subsection Job Control

An overview of @dfn{Job Control} is provided here for completeness and because it interacts with the
@dfn{STREAMS}-based terminal subsystem.  More information on @dfn{Job Control} may be obtained from
the following manual pages: @manpage{exit(2)}, @manpage{getpgid(2)}, @manpage{getpgrp(2)},
@manpage{getsid(2)}, @manpage{kill(2)}, @manpage{setpgid(2)}, @manpage{setpgrp(2)},
@manpage{setsid(2)}, @manpage{sigaction(2)}, @manpage{signal(2)}, @manpage{sigsend(2)},
@manpage{termios(2)}, @manpage{waitid(2)}, @manpage{waitpid(3C)}, and @manpage{signal(5)}, and
@manpage{termio(7)}.

@dfn{Job Control} is a feature supported by the @cite{BSD UNIX} operating system.  It is also an
optional part of the @cite{IEEE P1003.1 POSIX} standard.  @dfn{Job Control} breaks a login session
into smaller units called jobs.  Each job consists of one or more related and cooperating processes.
One job, the foreground job, is given complete access to the controlling terminal.  The other jobs,
background jobs, are denied read access to the controlling terminal and given conditional write and
ioctl access to it.  The user may stop an executing job and resume the stopped job either in the
foreground or in the background.

Under @dfn{Job Control}, background jobs do not receive events generated by the terminal and are not
informed with a hangup indication when the controlling process exits.  Background jobs that linger
after the login session has been dissolved are prevented from further access to the controlling
terminal, and do not interfere with the creation of new login sessions.

The following defines terms associated with @dfn{Job Control}:

@itemize @bullet
@item Background Process group A process group that is a member of a sessionthat established a
connection with a controlling terminal and is not the foreground process group.
@item Controlling Process A session leader that established a connection to a controlling terminal.
@item Controlling Terminal A terminal that is associated with a session.  Each session may have at
most one controlling terminal associated with it and a controlling terminal may be associated with
at most one session.  Certain input sequences from the controlling terminal cause signals to be sent
to the process groups in the session associated with the controlling terminal.
@item Foreground Process Group Each session that establishes a connection with a controlling
terminal distinguishes one process group of the session as a foreground process group.  The
foreground process group has certain privileges that are denied to background process groups when
accessing its controlling terminal.
@item Orphaned Process Group A process group in which the parent of every member in the group is
either a member of the group, or is not a member of the process group's session.
@item Process Group Each process in the system is a member of a process group that is identified by
a process group ID.  Any process that is not a process group leader may create a new process group
and become its leader.  Any process that is not a process group leader may join an existing process
group that shares the same session as the process.  A newly created process joins the process group
of its creator.
@item Process Group Leader A process whose process ID is the same as its process group ID.
@item Process Group Lifetime A time period that begins when a process group is created by its
process group leader and ends when the last process that is a member in the group leaves the group.
@item Process ID A positive integer that uniquely identifies each process in the system.  A process
ID may not be reused by the system until the process lifetime, process group lifetime, and session
lifetime ends for any process ID, process group ID, and session ID sharing that value.
@item Process Lifetime A time period that begins when the process is forked and ends after the
process exits, when its termination has been acknowledged by its parent process.
@item Session Each process group is a member of a session that is identified by a session ID.
@item Session ID A positive integer that uniquely identifies each session in the system.  It is the
same as the process ID of its session leader.
@item Session Leader A process whose session ID is the same as its process and process group ID.
@item Session Lifetime A time period that begins when the session is created by its session leader
and ends when the lifetime of the last process group that is a member of the session ends.
@end itemize

The following signals manage @dfn{Job Control}: [see also @manpage{signal(5)}]

@vtable @var
@item SIGCONT
Sent to a stopped process to continue it.
@item SIGSTOP
Sent to a process to stop it.  This signal cannot be caught or ignored.
@item SIGTSTP
Sent to a process to stop it.  It is typically used when a user requests to stop the foreground
process.
@item SIGTTIN
Sent to a background process to stop it when it attempts to read from the controlling terminal.
@item SIGTTOU
Sent to a background process to stop it when one attempts to write to or modify the controlling
terminal.
@end vtable

A session may be allocated a controlling terminal.  For every allocated controlling terminal,
@dfn{Job Control} elevates one process group in the controlling process's session to the status of
foreground process group.  The remaining process groups in the controlling process's session are
background process groups.  A controlling terminal gives a user the ability to control execution of
jobs within the session.  Controlling terminals play a central role in @dfn{Job Control}.  A user
may cause the foreground job to stop by typing a predefined key on the controlling terminal.  A user
may inhibit access to the controlling terminal by background jobs.  Background jobs that attempt to
access a terminal that has been so restricted will be sent a signal that typically will cause the
job to stop.  (@pxref{Accessing the Controlling Terminal}, later in this chapter.)

@dfn{Job Control} requires support from a line discipline module on the controlling terminal's
@dfn{Stream}.  The @var{TCSETA}, @var{TCSETAW}, and @var{TCSETAF} commands of @manpage{termio(7)}
allow a process to set the following line discipline values relevant to @dfn{Job Control}:

@table @asis
@item @var{SUSP} character
A user defined character that, when typed, causes the line discipline module to request that the
@dfn{Stream} head sends a @var{SIGTSTP} signal to the foreground process with an @var{M_PCSIG}
message, which by default stops the members of that group.  If the value of @var{SUSP} is zero, the
@var{SIGTSTP} signal is not sent, and the @var{SUSP} character is disabled.
@item @var{TOSTOP} flag
If @var{TOSTOP} is set, background processes are inhibited from writing to their controlling
terminal.
@end table

A line discipline module must record the @var{SUSP} suspend character and notify the @dfn{Stream
head} when the user has typed it, and record the state of the @var{TOSTOP} bit and notify the
@dfn{Stream head} when the user has changed it.

@subsection Allocation and Deallocation

A @dfn{Stream} is allocated as a controlling terminal for a session if:

@itemize @bullet
@item The @dfn{Stream} is acting as a terminal,
@item The @dfn{Stream} is not already allocated as a controlling terminal, and
@item The @dfn{Stream} is opened by a session leader that does not have a controlling terminal.
@end itemize

Drivers and modules can inform the @dfn{Stream} head to act as a terminal @dfn{Stream} by sending an
@var{M_SETOPTS} message with the @var{SO_ISTTY} flag set upstream.  This state may be changed by
sending an @var{M_SETOPTS} message with the @var{SO_ISNTTY} flag set upstream.

Controlling terminals are allocated with the @manpage{open(2)} system call.  A @dfn{Stream} head
must be informed that it is acting as a terminal by an @var{M_SETOPTS} message sent upstream before
or while the @dfn{Stream} is being opened by a potential controlling process.  If the @dfn{Stream}
head is opened before receiving this message, the @dfn{Stream} is not allocated as a controlling
terminal.

@subsection Hung-up Streams

When a @dfn{Stream} head receives an @var{M_HANGUP} message, it is marked as hung-up.  @dfn{Streams}
that are marked as hung-up are allowed to be reopened by their session leader if they are allocated
as a controlling terminal, and by any process if they are not allocated as a controlling terminal.
This way, the hangup error can be cleared without forcing all file descriptors to be closed first.

If the reopen is successful, the hung-up condition is cleared.

@subsection Hangup Signals

When the @var{SIGHUP} signal is generated via an @var{M_HANGUP} message (instead of an @var{M_SIG}
or @var{M_PCSIG} message), the signal is sent to the controlling process instead of the foreground
process group, since the allocation and deallocation of controlling terminals to a session is the
responsibility of that process group.

@subsection Accessing the Controlling Terminal

If a process attempts to access its controlling terminal after it has been deallocated, access will
be denied.  If the process is not holding or ignoring @var{SIGHUP}, it is sent a @var{SIGHUP} signal.
Otherwise, the access will fail with an [@b{EIO}] error.

Members of background process groups have limited access to their controlling terminals:

@itemize @bullet
@item If the background process is ignoring or holding the @var{SIGTTIN} signal or is a member of an
orphaned process group, an attempt to read from the controlling terminal will fail with an [@b{EIO}]
error.  Otherwise, the process is sent a @var{SIGTTIN} signal, which by default stops the process.
@item If the process is attempting to write to the terminal and if the terminal's @var{TOSTOP} flag
is clear, the process is allowed access.  The @var{TOSTOP} flag is set upon reception of an
@var{M_SETOPTS} message with the @var{SO_TOSTOP} flag set in the @var{so_flags} field.  It is
cleared upon reception of an @var{M_SETOPTS} message with the @var{SO_TONSTOP} flag set.
@item If the terminal's @var{TOSTOP} flag is set and a background process is attempting to write to
the terminal, the write will succeed if the process is ignoring or holding @var{SIGTTOU}.
Otherwise, the process will stop except when it is a member of an orphaned process group, in which
case it is denied access to the terminal and it is returned an [@b{EIO}] error.
@item If a background process is attempting to perform a destructive @command{ioctl} (an
@command{ioctl} that modifies terminal parameters), the @command{ioctl} call will succeed if the
process is ignoring or holding @var{SIGTTOU}.  Otherwise, the process will stop except when the
process is a member of the orphaned process group.  In that case the access to the terminal is
denied and an [@b{EIO}] error is returned.
@end itemize

@node Modules and Drivers
@chapter Overview of STREAMS Modules and Drivers
@cindex modules and drivers
@menu
* Environment::			STREAMS Module and Driver Environment
* Input-Output Controls::	STREAMS Input and Output Controls
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines
@end menu

@node Environment
@section STREAMS Module and Driver Environment
@cindex module and driver environment

Modules and drivers are processing elements in @dfn{STREAMS}.  A @dfn{Stream} device driver is
similar to a conventional @cite{UNIX} system driver.  It is opened like a conventional driver and is
responsible for the system interface to the device.

@dfn{STREAMS} modules and drivers are structurally similar.  The call interfaces to driver routines
are identical to interfaces used for modules.  Drivers and modules must declare @code{streamtab},
@code{qinit}, and @code{module_info} structures.  Within the @dfn{STREAMS} mechanism drivers are
required elements, but modules are optional.  However, in the @dfn{STREAMS}-based pipe mechanism and
the pseudo-terminal subsystem only the @dfn{Stream} head is required.

There are three significant differences between modules and drivers.  A driver must be able to
handle interrupts from a device, so the driver will typically include an interrupt handler routine.
Another difference is that a driver may have multiple @dfn{Streams} connected to it.  The third
difference is the initialization/deinitialization process that happens via open/close with a driver
and via the @command{ioctls} @var{I_PUSH}/@var{I_POP} with a module.  (@var{I_PUSH}/@var{I_POP}
results in calls to @command{open}/@command{close}.)

User context is not generally available to @dfn{STREAMS} module procedures and drivers.  The
exception is during execution of the @command{open} and @command{close} routines.  Driver and module
open and close routines have user context and may access the @code{u_area} structure (defined in
@file{user.h}, (@pxref{Accessible Symbols and Functions}), later in this chapter) although this is
discouraged.  These routines are allowed to sleep, but must always return to the caller.  That is,
if they sleep, it must be at priority numerically <= @var{PZERO}, or with @var{PCATCH} set in the
sleep priority.  Priorities are higher as they decrease in numerical value.  The process will never
return from the sleep call and the system call will be aborted if:

@itemize @bullet
@item A process is sleeping at priority > @dfn{PZERO},
@item @dfn{PCATCH} is not set, and
@item A process is sent signal via @manpage{kill(2)}.
@end itemize

@dfn{STREAMS} driver and module put procedures and service procedures have no user context.  They
cannot access the @code{u_area} structure of a process and must not sleep.

The module and driver @command{open}/@command{close} interface has been modified for @cite{UNIX
System V Release 4.0}.  However, the system defaults to @cite{UNIX System V Release 3.0} interface
unless @var{prefixflag} is defined.  This is discussed later in this chapter (@pxref{Driver-Kernel
Interface}).  Examples and descriptions in this chapter reflect @cite{Release 4.0} interface.

@subsection Module and Driver Declarations

A module and driver will contain, at a minimum, declarations of the following form:

@smallexample
#include <sys/types.h>          /* required in all modules and drivers */
#include <sys/stream.h>         /* required in all modules and drivers */
#include <sys/param.h>

static struct module_info rminfo = @{ 0x08, "mod", 0, INFPSZ, 0, 0 @};
static struct module_info wminfo = @{ 0x08, "mod", 0, INFPSZ, 0, 0 @};
static int modopen(), modput(), modclose();

static struct qinit rinit = @{
        modput, NULL, modopen, modclose, NULL, &rminfo, NULL
@};

static struct qinit winit = @{
        modput, NULL, NULL, NULL, NULL, &wminfo NULL
@};

struct streamtab modinfo = @{ &rinit, &winit, NULL, NULL @};

extern int moddevflag = 0;
@end smallexample

The contents of these declarations are constructed for the null module example in this section.
This module performs no processing.  Its only purpose is to show linkage of a module into the
system.  The descriptions in this section are general to all @dfn{STREAMS} modules and drivers
unless they specifically reference the example.

The declarations shown are: the header set; the read and write queue (@code{rminfo} and
@code{wminfo}) @code{module_info} structures; the module open, read-put, write-put, and close
procedures; the read and write (@code{rinit}, and @code{winit}) @code{qinit} structures; and the
@code{streamtab} structure.

The header files, @file{types.h} and @file{stream.h}, are always required for modules and drivers.
The header file, @file{param.h}, contains definitions for @var{NULL} and other values for
@dfn{STREAMS} modules and drivers as shown later in this chapter (@pxref{Accessible Symbols and
Functions}).

When configuring a @dfn{STREAMS} module or driver (@pxref{Configuration}) the @code{streamtab}
structure must be externally accessible.  The @code{streamtab} structure name must be the prefix
appended with @samp{info}.  Also, the driver flag must be externally accessible.  The flag name must
be the prefix appended with @samp{devflag}.

The @code{streamtab} contains @code{qinit} values for the read and write queues.  The @code{qinit}
structures in turn point to a @code{module_info} and an optional @code{module_stat} structure.  The
two required structures are:

@smallexample
struct qinit @{
        int (*qi_putp) ();              /* put procedure */
        int (*qi_srvp) ();              /* service procedure */
        int (*qi_qopen) ();             /* called on each open or a push */
        int (*qi_qclose) ();            /* called on last close or a pop */
        int (*qi_qadmin) ();            /* reserved for future use */
        struct module_info *qi_minfo;   /* information structure */
        struct module_stat *qi_mstat;   /* statistics structure - optional */
@};

struct module_info @{
        ushort mi_idnum;                /* module ID number */
        char *mi_idname;                /* module name */
        long mi_minpsz;                 /* min packet size, for developer use */
        long mi_maxpsz;                 /* max packet size, for developer use */
        ulong mi_hiwat;                 /* hi-water mark */
        ulong mi_lowat;                 /* lo-water mark */
@};
@end smallexample

The @code{qinit} contains the queue procedures: put, service, open, and close.  All modules and
drivers with the same @code{streamtab} (i.e., the same @code{fmodsw} or @code{cdevsw} entry) point
to the same upstream and downstream @code{qinit} structure(s).  The structure is meant to be
software read-only, as any changes to it affect all instantiations of that module in all
@dfn{Streams}.  Pointers to the open and close procedures must be contained in the read @code{qinit}
structure.  These fields are ignored on the write-side.  Our example has no service procedure on the
read-side or write-side.

The @code{module_info} contains identification and limit values.  All queues associated with a certain
driver/module share the same @code{module_info} structures.  The @code{module_info} structures
define the characteristics of that driver/module's queues.  As with the @code{qinit}, this structure
is intended to be software read-only.

However, the four limit values (@var{q_minpsz}, @var{q_maxpsz}, @var{q_hiwat}, @var{q_lowat}) are
copied to a queue structure where they are modifiable.  In the example, the flow control high and
low water marks are zero since there is no service procedure and messages are not queued in the
module.

Three names are associated with a module: the character string in @code{fmodsw}, obtained from the
name of the @file{master.d} file used to configure the module; the prefix for @code{streamtab}, used
in configuring the module; and the module name field in the @code{module_info} structure.  The
module name must be the same as that of @file{master.d} for autoconfiguration.  Each module ID and
module name should be unique in the system.  The module ID is currently used only in logging and
tracing.  It is @samp{0x08} in the example.

Minimum and maximum packet sizes are intended to limit the total number of characters contained in
@code{M_DATA} messages passed to this queue.  These limits are advisory except for the @dfn{Stream}
head.  For certain system calls that write to a @dfn{Stream}, the @dfn{Stream} head will observe the
packet sizes set in the write queue of the module immediately below it.  Otherwise, the use of
packet size is developer dependent.  In the example, @var{INFPSZ} indicates unlimited size on the
read-side.

The @code{module_stat} is optional.  Currently, there is no @dfn{STREAMS} support for statistical
information gathering.

@subsubsection Null Module Example

The null module procedures are as follows:

@smallexample
static int
modopen(q, devp, flag, sflag, credp)
        queue_t *q;                     /* pointer to the read queue */
        dev_t *devp;                    /* pointer to major/minor device number */
        int flag;                       /* file flags */
        int sflag;                      /* stream open flags */
        cred_t *credp;                  /* pointer to a credentials structure */
@{
        /* return success */
        return 0;
@}
static int
modput(q, mp)                           /* put procedure */
        queue_t *q;                     /* pointer to the queue */
        mblk_t *mp;                     /* message pointer */
@{
        putnext(q, mp);         /* pass message through */
@}

/* NOTE: we only need one put procedure that can be used for both
 * read-side and write-side.
 */
static int
modclose(q, flag, credp)
        queue_t *q;                     /* pointer to the read queue */
        int flag;                       /* file flags */
        cred_t *credp;                  /* pointer to a credentials structure */
@{
        return 0;
@}
@end smallexample

The form and arguments of these procedures are the same in all modules and all drivers.  Modules and
drivers can be used in multiple @dfn{Streams} and their procedures must be reentrant.

@command{modopen} illustrates the open call arguments and return value.  The arguments are the read
queue pointer (@var{q}), the pointer (@var{devp}) to the major/minor device number, the file flags
(@var{flag}, defined in @file{sys/file.h}), the @dfn{Stream} open flag (@var{sflag}), and a pointer
to a credentials structure (@var{credp}).  The Stream open flag can take on the following values:

@vtable @var
@item MODOPEN
normal module open
@item 0
normal driver open
@item CLONEOPEN
clone driver open
@end vtable

The return value from open is @samp{0} for success and an error number for failure.  If a driver is
called with the @var{CLONEOPEN} flag, the device number pointed to by the @var{devp} should be set
by the driver to an unused device number accessible to that driver.  This should be an entire device
number (major and minor device number).  The open procedure for a module is called on the first
@var{I_PUSH} and on all subsequent open calls to the same @dfn{Stream}.  During a push, a nonzero
return value causes the @var{I_PUSH} to fail and the module to be removed from the @dfn{Stream}.  If
an error is returned by a module during an open call, the open fails, but the @dfn{Stream} remains
intact.

The module open fails if not opened by the super-user (also referred to as a privileged user) that
in future releases will be a user with @samp{driver/special} permissions.  Permission checks in
module and driver open routines should be done with the @manpage{drv_priv(9)} routine.  For
@cite{UNIX System V Release 4.0}, there is no need to check if @samp{u.u_uid == 0}.  This and the
@manpage{suser(9)} routine are replaced with:

@smallexample
error = drv_priv(credp);
if (error)                      /* not super-user */
        return errno;
@end smallexample

In the null module example, @command{modopen} simply returns successfully.  @command{modput}
illustrates the common interface to put procedures.  The arguments are the read or write queue
pointer, as appropriate, and the message pointer.  The put procedure in the appropriate side of the
queue is called when a message is passed from upstream or downstream.  The put procedure has no
return value.  In the example, no message processing is performed.  All messages are forwarded using
the @manpage{putnext(9)} macro (@pxref{STREAMS Utilities}).  @command{putnext} calls the put
procedure of the next queue in the proper direction.

The close routine is only called on an @var{I_POP} ioctl or on the last close call of the
@dfn{Stream}.  The arguments are the read queue pointer, the file flags as in @command{modopen}, and
a pointer to a credentials structure.  The return value is @samp{0} on success and @samp{errno} on
failure.

@node Input-Output Controls
@section STREAMS Input and Output Controls
@cindex input and output controls
@menu
* General ioctl Processing::
* I_STR ioctl Processing::
* Transparent ioctl Processing::
* Transparent ioctl Messages::
* Transparent ioctl Examples::
* I_LIST ioctl::
@end menu

@dfn{STREAMS} is an addition to the @cite{UNIX} system traditional character input/output (I/O)
mechanism.  In this section, the phrases @dfn{"character I/O mechanism"} and @dfn{"I/O mechanism"}
refer only to that part of the mechanism that pre-existed @dfn{STREAMS}.

The @dfn{character I/O mechanism} handles all @manpage{ioctl(2)} system calls in a transparent
manner.  That is, the kernel expects all @command{ioctl}s to be handled by the device driver
associated with the character special file on which the call is sent.  All @command{ioctl} calls are
sent to the driver, which is expected to perform all validation and processing other than file
descriptor validity checking.  The operation of any specific @command{ioctl} is dependent on the
device driver.  If the driver requires data to be transferred in from user space, it will use the
kernel copyin() function.  It may also use copyout() to transfer out any data results back to user
space.

With @dfn{STREAMS}, there are a number of differences from the @dfn{character I/O mechanism} that
impact @command{ioctl} processing.

First, there are a set of generic @dfn{STREAMS} @command{ioctl} command values [see
@manpage{ioctl(2)}] recognized and processed by the @dfn{Stream} head.  These are described in
@manpage{streamio(7)}.  The operation of the generic @dfn{STREAMS} @command{ioctl}s are generally
independent of the presence of any specific module or driver on the @dfn{Stream}.

The second difference is the absence of user context in a module and driver when the information
associated with the @command{ioctl} is received.  This prevents use of @manpage{copyin(9)} or
@manpage{copyout(9)} by the module.  This also prevents the module and driver from associating any
kernel data with the currently running process.  (It is likely that by the time the module or driver
receives the @command{ioctl}, the process generating it may no longer be running.)

A third difference is that for the @dfn{character I/O mechanism}, all @command{ioctl}s are handled
by the single driver associated with the file.  In @dfn{STREAMS}, there can be multiple modules on a
@dfn{Stream} and each one can have its own set of @command{ioctl}s.  That is, the @command{ioctl}s
that can be used on a @dfn{Stream} can change as modules are pushed and popped.

@dfn{STREAMS} provides the capability for user processes to perform control functions on specific
modules and drivers in a @dfn{Stream} with @command{ioctl} calls.  Most @manpage{streamio(7)}
@command{ioctl} commands go no further than the @dfn{Stream} head.  They are fully processed there
and no related messages are sent downstream.  However, certain commands and all unrecognized
commands cause the @dfn{Stream} head to create an @var{M_IOCTL} message which includes the
@command{ioctl} arguments and send the message downstream to be received and processed by a specific
module or driver.  The @var{M_IOCTL} message is the initial message type which carries
@command{ioctl} information to modules.  Other message types are used to complete the
@command{ioctl} processing in the @dfn{Stream}.  In general, each module must uniquely recognize and
take action on specific @var{M_IOCTL} messages.

@dfn{STREAMS} @command{ioctl} handling is equivalent to the transparent processing of the
@dfn{character I/O mechanism}.  @dfn{STREAMS} modules and drivers can process @command{ioctl}s
generated by applications that are implemented for a non-@dfn{STREAMS} environment.

@node General ioctl Processing
@subsection General @command{ioctl} Processing

@dfn{STREAMS} blocks a user process which issues an @command{ioctl} and causes the Stream head to generate an
@var{M_IOCTL} message.  The process remains blocked until either:

@itemize @bullet
@item a module or a driver responds with an @var{M_IOCACK} (ack, positive acknowledgement) message
or an @var{M_IOCNAK} (nak, negative acknowledgement) message, or
@item no message is received and the request "times out," or
@item the @command{ioctl} is interrupted by the user process, or
@item an error condition occurs.
@end itemize

For the @command{ioctl} @var{I_STR} the timeout period can be a user specified interval or a
default.  For the other @var{M_IOCTL} @command{ioctl}s, the default value (infinite) is used.

For an @var{I_STR}, the @dfn{STREAMS} module or driver that generates a positive acknowledgement
message can also return data to the process in that message.  An alternate means to return data is
provided with transparent @command{ioctl}.  If the @dfn{Stream} head does not receive a positive or
negative acknowledgement message in the specified time, the @command{ioctl} call fails.

A module that receives an unrecognized @var{M_IOCTL} message should pass it on unchanged.  A driver
that receives an unrecognized @var{M_IOCTL} should produce a negative acknowledgement.

The form of an @var{M_IOCTL} message is a single @var{M_IOCTL} message block followed by (see
@var{M_PROTO} and @var{M_PCPROTO} Message Structure, @pxref{Message Types}) zero or more
@var{M_DATA} blocks.  The @var{M_IOCTL} message block contains an @code{iocblk} structure, defined
in @file{<sys/stream.h>}:

@smallexample
struct iocblk @{
        int ioc_cmd                     /* ioctl command type */
        cred_t *ioc_cr;                 /* full credentials */
        uint ioc_id;                    /* ioctl id */
        uint ioc_count;                 /* count of bytes in data field */
        int ioc_error;                  /* error code */
        int ioc_rval;                   /* return value */
        long ioc_filler[4];             /* reserved for future use */
@};

#define ioc_uid ioc_cr->cr_uid
#define ioc_gid ioc_cr->cr_gid
@end smallexample

For an @var{I_STR} @command{ioctl}, @var{ioc_cmd} contains the command supplied by the user in the
@code{strioctl} structure defined in @manpage{streamio(7)}.

If a module or driver determines an @var{M_IOCTL} message is in error for any reason, it must
produce the negative acknowledgement message.  This is typically done by setting the message type to
@var{M_IOCNAK} and sending the message upstream.  No data or a return value can be sent to a user in
this case.  If @var{ioc_error} is set to 0, the @dfn{Stream} head will cause the @command{ioctl}
call to fail with @var{EINVAL}.  The driver has the option of setting @var{ioc_error} to an
alternate error number if desired.

@var{ioc_error} can be set to a nonzero value in both @var{M_IOCACK} and @var{M_IOCNAK}.  This will
cause that value to be returned as an error number to the process that sent the @command{ioctl}.

If a module wants to look at what @command{ioctl}s of other modules are doing, the module should not
look for a specific @var{M_IOCTL} on the write-side but look for @var{M_IOCACK} or @var{M_IOCNAK} on
the read-side.  For example, the module sees @var{TCSETA} [see @manpage{termio(7)}] going down and
wants to know what is being set.  The module should look at it and save away the answer but not use
it.  The read-side processing knows that the module is waiting for an answer for the
@command{ioctl}.  When the read-side processing sees an "ack" or "nak" next time, it checks if it is
the same @command{ioctl} (here @var{TCSETA}) and if it is, the module may use the answer previously
saved.

The two @dfn{STREAMS} @command{ioctl} mechanisms, @var{I_STR} and transparent, are described next.
[Here, @var{I_STR} means the @manpage{streamio(7)} @var{I_STR} command and implies the related
@dfn{STREAMS} processing unless noted otherwise.] @var{I_STR} has a restricted format and restricted
addressing for transferring @command{ioctl}-related data between user and kernel space.  It requires
only a single pair of messages to complete @command{ioctl} processing.  The transparent mechanism is
more general and has almost no restrictions on @command{ioctl} data format and addressing.  The
transparent mechanism generally requires that multiple pairs of messages be exchanged between the
@dfn{Stream} head and module to complete the processing.

@node I_STR ioctl Processing
@subsection @code{I_STR} @command{ioctl} Processing

The @var{I_STR} @command{ioctl} provides a capability for user applications to perform module and
driver control functions on @dfn{STREAMS} files.  @var{I_STR} allows an application to specify the
@command{ioctl} timeout.  It requires that all user @command{ioctl} data (to be received by the
destination module) be placed in a single block which is pointed to from the @code{strioctl}
structure.  The module can also return data to this block.

If the module is looking at for example the @var{TCSETA}/@var{TCGETA} group of @command{ioctl} calls
as they pass up or down a @dfn{Stream}, it must never assume that because @var{TCSETA} comes down
that it actually has a data buffer attached to it.  The user may have formed @var{TCSETA} as an
@var{I_STR} call and accidentally given a null data buffer pointer.  One must always check
@var{b_cont} to see if it is @var{NULL} before using it as an index to the data block that goes with
@var{M_IOCTL} messages.

The @var{TCGETA} call, if formed as an @var{I_STR} call with a data buffer pointer set to a value by
the user, will always have a data buffer attached to @var{b_cont} from the main message block.  If
one assumes that the data block is not there and allocates a new buffer and assigns @var{b_cont} to
point at it, the original buffer will be lost.  Thus, before assuming that the @command{ioctl}
message does not have a buffer attached, one should check first.

The following example illustrates processing associated with an @var{I_STR} @command{ioctl}.
@command{lpdoioctl} is called to process trapped @var{M_IOCTL} messages:

@smallexample
lpdoioctl(lp, mp)
        struct lp *lp;
        mblk_t *mp;
@{
        struct iocblk *iocp;
        queue_t *q;

        q = 1 p->qptr;

        /* 1st block contains iocblk structure */
        iocp = (struct iocblk *) mp->b_rptr;

        switch (iocp->ioc_cmd) @{
        case SET_OPTIONS:
                /* Count should be exactly one short's worth (for this example) */
                if (iocp->ioc_count != sizeof(short))
                        goto iocnak;
                if (mp->b_cont == NULL)
                        goto lognak;    /* not shown in this example */
                /* Actual data is in 2nd message block */
                lpsetopt(lp, *(short *) mp->b_cont->b_rptr);
                /* ACK the ioctl */
                mp->b_datap->db_type = M_IOCACK;
                iocp->ioc_cont = 0;
                greply(q, mp);
                break;
        default:
              iocnak:
                /* NAK the ioctl */
                mp->b_datap->db_type = M_IOCNAK;
                greply(q, mp);
        @}
@}
@end smallexample

@command{lpdoioctl} illustrates driver @var{M_IOCTL} processing which also applies to modules.
However, at case default, a module would not "nak" an unrecognized command, but would pass the
message on.  In this example, only one command is recognized, @var{SET_OPTIONS}.  @var{ioc_count}
contains the number of user supplied data bytes.  For this example, it must equal the size of a
short.  The user data are sent directly to the printer interface using @command{lpsetopt}.  Next,
the @var{M_IOCTL} message is changed to type @var{M_IOCACK} and the @var{ioc_count} field is set to
zero to indicate that no data are to be returned to the user.  Finally, the message is sent upstream
using @manpage{qreply(9)}.  If @var{ioc_count} was left nonzero, the Stream head would copy that
many bytes from the 2nd Nth message blocks into the user buffer.

@node Transparent ioctl Processing
@subsection Transparent @command{ioctl} Processing

The transparent @dfn{STREAMS} @command{ioctl} mechanism allows application programs to perform
module and driver control functions with @command{ioctl}s other than @var{I_STR}.  It is intended to
transparently support applications developed prior to the introduction of @dfn{STREAMS}.  It
alleviates the need to recode and recompile the user level software to run over @dfn{STREAMS} files.

The mechanism extends the data transfer capability for @dfn{STREAMS} @command{ioctl} calls beyond
that provided in the @var{I_STR} form.  Modules and drivers can transfer data between their kernel
space and user space in any @command{ioctl} which has a value of the command argument not defined in
@manpage{streamio(7)}.  These @command{ioctl}s are known as transparent @command{ioctl}s to
differentiate them from the @var{I_STR} form.  Transparent processing support is necessary when
existing user level applications perform @command{ioctl}s on a non-@dfn{STREAMS} character device
and the device driver is converted to @dfn{STREAMS}.  The @command{ioctl} data can be in any format
mutually understood by the user application and module.

The transparent mechanism also supports @dfn{STREAMS} applications that want to send @command{ioctl}
data to a driver or module in a single call, where the data may not be in a form readily embedded in
a single user block.  For example, the data may be contained in nested structures, different user
space buffers, etc.

This mechanism is needed because user context does not exist in modules and drivers when
@command{ioctl} processing occurs.  This prevents them from using the kernel
@manpage{copyin(9)}/@manpage{copyout(9)} functions.  For example, consider the following
@command{ioctl} call:

@smallexample
ioctl (stream_fildes, user_command, &ioctl_struct);
@end smallexample

where @code{ioctl_struct} is a structure containing the members:

@smallexample
int stringlen;                          /* string length */
char *string;
struct other_struct *other1;
@end smallexample

To read (or write) the elements of @code{ioctl_struct}, a module would have to perform a series of
@manpage{copyin(9)}/@manpage{copyout(9)} calls using pointer information from a prior
@manpage{copyin(9)} to transfer additional data.  A non @dfn{STREAMS} character driver could
directly execute these copy functions because user context exists during all @cite{UNIX} system
calls to the driver.  However, in @dfn{STREAMS}, user context is only available to modules and
drivers in their @command{open} and @command{close} routines.

The transparent mechanism enables modules and drivers to request that the @dfn{Stream} head perform a
@manpage{copyin(9)} or @manpage{copyout(9)} on their behalf to transfer @command{ioctl} data between
their kernel space and various user space locations.  The related data are sent in message pairs
exchanged between the @dfn{Stream} head and the module.  A pair of messages is required so that each
transfer can be acknowledged.  In addition to @var{M_IOCTL}, @var{M_IOCACK}, and @var{M_IOCNAK}
messages, the transparent mechanism also uses @var{M_COPYIN}, @var{M_COPYOUT}, and @var{M_IOCDATA}
messages.

The general processing by which a module or a driver reads data from user space for the transparent
case involves pairs of request/response messages, as follows:

@enumerate
@item The @dfn{Stream} head does not recognize the command argument of an @command{ioctl} call and
creates a transparent @var{M_IOCTL} message (the @code{iocblk} structure has a @var{TRANSPARENT}
indicator, @pxref{Transparent ioctl Messages}) containing the value of the @var{arg}
argument in the call.  It sends the @var{M_IOCTL} message downstream.
@item A module receives the @var{M_IOCTL} message, recognizes the @var{ioc_cmd}, and determines that
it is @var{TRANSPARENT}.
@item If the module requires user data, it creates an @var{M_COPYIN} message to request a
@manpage{copyin(9)} of user data.  The message will contain the address of user data to copy in and
how much data to transfer.  It sends the message upstream.
@item The @dfn{Stream} head receives the @var{M_COPYIN} message and uses the contents to
@manpage{copyin(9)} the data from user space into an @var{M_IOCDATA} response message which it sends
downstream.  The message also contains an indicator of whether the data transfer succeeded (the
@manpage{copyin(9)} might fail, for instance, because of an @var{EFAULT} [see @manpage{errno(3)}]
condition).
@item The module receives the @var{M_IOCDATA} message and processes its contents.  The module may
use the message contents to generate another @var{M_COPYIN}.  Steps 3 through 5 may be repeated
until the module has requested and received all the user data to be transferred.
@item When the module completes its data transfer, it performs the @command{ioctl} processing and
sends an @var{M_IOCACK} message upstream to notify the @dfn{Stream} head that @command{ioctl}
processing has successfully completed.
@end enumerate

Writing data from a module to user space is similar except that the module uses an @var{M_COPYOUT}
message to request the @dfn{Stream} head to write data into user space.  In addition to length and
user address, the message includes the data to be copied out.  In this case, the @var{M_IOCDATA}
response will not contain user data, only an indication of success or failure.

The module may intermix @var{M_COPYIN} and @var{M_COPYOUT} messages in any order.  However, each
message must be sent one at a time; the module must receive the associated @var{M_IOCDATA} response
before any subsequent @var{M_COPYIN}/@var{M_COPYOUT} request or "ack/nak" message is sent upstream.
After the last @var{M_COPYIN}/@var{M_COPYOUT} message, the module must send an @var{M_IOCACK}
message (or @var{M_IOCNAK} in the event of a detected error condition).

For a transparent @var{M_IOCTL}, user data can not be returned with an @var{M_IOCACK} message.  The
data must have been sent with a preceding @var{M_COPYOUT} message.

@node Transparent ioctl Messages
@subsection Transparent @command{ioctl} Messages

The form of the @var{M_IOCTL} message generated by the @dfn{Stream head} for a transparent
@command{ioctl} is a single @var{M_IOCTL} message block followed by one @var{M_DATA} block.  The
form of the @code{iocblk} structure in the @var{M_IOCTL} block is the same as described above
@pxref{General ioctl Processing}).  However, @var{ioc_cmd} is set to the value of the command
argument in the @command{ioctl} system call and @var{ioc_count} is set to @var{TRANSPARENT}, defined
in @file{<sys/stream.h>}.  @var{TRANSPARENT} distinguishes the case where an @var{I_STR}
@command{ioctl} may specify a value of ioc_cmd equivalent to the command argument of a transparent
@command{ioctl}.  The @var{M_DATA} block of the message contains the value of the @var{arg}
parameter in the call.

Modules that process a specific @var{ioc_cmd} which did not validate the @var{ioc_count} field of
the @var{M_IOCTL} message will break if transparent @command{ioctl}s with the same command are
performed from user space.

@var{M_COPYIN}, @var{M_COPYOUT}, and @var{M_IOCDATA} messages and their use are described in more
detail (@pxref{Message Type}).

@node Transparent ioctl Examples
@subsection Transparent @command{ioctl} Examples

Following are three examples of transparent @command{ioctl} processing.  The first illustrates
@var{M_COPYIN}.  The second illustrates @var{M_COPYOUT}.  The third is a more complex example showing
state transitions combining both @var{M_COPYIN} and @var{M_COPYOUT}.

@subsubsection @code{M_COPYIN} Example

In this example, the contents of a user buffer are to be transferred into the kernel as part of an
ioctl call of the form

@smallexample
ioctl(fd, SET_ADDR, &bufadd)
@end smallexample

where @code{bufadd} is a structure declared as

@smallexample
struct address @{
    int ad_len;                         /* buffer length in bytes */
    caddr_t ad_addr;                    /* buffer address */
@};
@end smallexample

This requires two pairs of messages (request/response) following receipt of the @var{M_IOCTL}
message.  The first will @command{copyin} the structure and the second will @command{copyin} the
buffer.  This example illustrates processing that supports only the transparent form of
@command{ioctl}.  @dfn{xxx}@code{wput} is the write-side put procedure for module or driver
@dfn{xxx}:

@smallexample
struct address @{                        /* same members as in user space */
    int ad_len;                         /* length in bytes */
    caddr_t ad_addr;                    /* buffer address */
@};

    /* state values (overloaded in private field) */
#define GETSTRUCT    0          /* address structure */
#define GETADDR      1          /* byte string from ad_addr */

xxxwput(q, mp)
        queue_t *q;                     /* write queue */
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;

    switch (mp->b_datap->db_type) @{
    .
    .
    .
    case M_IOCTL:
        iocbp = (struct iocblk *) mp->b_rptr;
        switch (iocbp->ioc_cmd) @{
        case SET_ADDR:
            if (iocbp->ioc_count != TRANSPARENT) @{      /* fail if I_STR */
                if (mp->b_cont) @{       /* return buffer to pool ASAP */
                    freemsg(mp->b_cont);
                    mp->b_cont = NULL;
                @}
                mp->b_datap->db_type = M_IOCNAK;        /* EINVAL */
                greply(q, mp);
                break;
            @}
            /* Reuse M_IOCTL block for M_COPYIN request */
            cqp = (struct copyreq *) mp->b_rptr;
            /* Get user space structure address from linked M_DATA block */
            cqp->cq_addr = (caddr_t) *(long *) mp->b_cont->b_rptr;
            freemsg(mp->b_cont);        /* MUST free linked blocks */
            mp->b_cont = NULL;
            cqp->cq_private = (mblk_t *) GETSTRUCT;     /* to identify response */
            /* Finish describing M_COPYIN message */
            cqp->cq_size = sizeof(struct address);
            cqp->cq_flag = 0;
            mp->b_datap->db_type = M_COPYIN;
            mp->b_wptr = mp->b_rptr + sizeof(struct copyreq);
            greply(q, mp);
            break;
        default:                /* M_IOCTL not for us */
            /* if module, pass on */
            /* if driver, nak ioctl */
            break;
        @}                       /* switch (iocbp->ioc_cmd) */
        break;
    case M_IOCDATA:
        xxxioc(q, mp);          /* all M_IOCDATA processing done here */
        break;
    .
    .
    .
    @}                           /* switch (mp->b_datap->db_type) */
@}
@end smallexample

@dfn{xxx}@code{wput} verifies that the @var{SET_ADDR} is @var{TRANSPARENT} to avoid confusion with
an @var{I_STR} @command{ioctl} which uses a value of @var{ioc_cmd} equivalent to the command
argument of a transparent @command{ioctl}.  When sending an @var{M_IOCNAK}, freeing the linked
@var{M_DATA} block is not mandatory as the @dfn{Stream head} will free it.  However, this returns
the block to the buffer pool more quickly.

In this and all following examples in this section, the message blocks are reused to avoid the
overhead of deallocating and allocating.

The @dfn{Stream head} will guarantee that the size of the message block containing an @code{iocblk}
structure will be large enough also to hold the @code{copyreq} and @code{copyresp} structures.

@var{cq_private} is set to contain state information for @command{ioctl} processing (tells us what
the subsequent @var{M_IOCDATA} response message contains).  Keeping the state in the message makes
the message self describing and simplifies the @command{ioctl} processing.  @var{M_IOCDATA}
processing is done in @dfn{xxx}@code{ioc}.  Two @var{M_IOCDATA} types are processed, @var{GETSTRUCT}
and @var{GETADDR}:

@smallexample
xxxioc(q, mp)                   /* M_IOCDATA processing */
        queue_t *q;
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct copyresp *csp;
    struct address *ap;

    csp = (struct copyresp *) mp->b_rptr;
    iocbp = (struct iocblk *) mp->b_rptr;
    switch (csp->cp_cmd) @{      /* validate this M_IOCDATA isfor this module */

    case SET_ADDR:
        if (csp->cp_rval) @{     /* GETSTRUCT or GETADDR failed */
            freemsg(mp);
            return;
        @}
        switch ((int) csp->cp_private) @{        /* determine state */

        case GETSTRUCT: /* user structure has arrived */
            mp->b_datap->db_type = M_COPYIN;    /* reuse M_IOCDATA block */
            cqp = (struct copyreq *) mp->b_rptr;
            ap = (struct address *) mp->b_cont->b_rptr; /* user structure */
            cqp->cq_size = ap->ad_len;  /* buffer length */
            cqp->cq_addr = ap->ad_addr; /* user space buffer address */
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            cqp->cq_flag = 0;
            csp->cp_private = (mblk_t *) GETADDR;       /* next state */
            qreply(q, mp);
            break;

        case GETADDR:
            /* user address is here */
            if (xxx_set_addr(mp->b_cont) == FAILURE) @{  /* hypothetical routine */
                mp->b_datap->db_type = M_IOCNAK;
                iocbp->ioc_error = EIO;
            @} else @{
                mp->b_datap->db_type = M_IOCACK;        /* success */
                iocbp->ioc_error = 0;   /* may have been overwritten */
                iocbp->ioc_count = 0;   /* may have been overwritten */
                iocbp->ioc_rval = 0;    /* may have been overwritten */
            @}
            mp->b_wptr = mp->b_rptr + sizeof(struct ioclk);
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            greply(q, mp);
            break;

        default:                /* invalid state: can't happen */
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            mp->b_datap->db_type = M_IOCNAK;
            mp->b_wptr = mp->rptr + sizeof(struct iocblk);
            iocbp->ioc_error = EINVAL;  /* may have been overwritten */
            qreply(q, mp);
            ASSERT(0);          /* panic if debugging mode */
            break;
        @}
        break;                  /* switch (cp_private) */
    default:                    /* M_IOCDATA not for us */
        /* if module, pass message on */
        /* if driver, free message */
        break;
    @}                           /* switch (cp_cmd) */
@}
@end smallexample

@dfn{xxx}@code{_set_addr} is a routine (not shown in the example) that processes the user address
from the @command{ioctl}.  Since the message block has been reused, the fields that the @dfn{Stream
head} will examine (denoted by @cite{"may have been overwritten"}) must be cleared before sending an
@var{M_IOCNAK}.

@subsubsection @code{M_COPYOUT} Example

In this example, the user wants option values for this @dfn{Stream} device to be placed into the
user's options structure (see beginning of example code, below).  This can be accomplished by use of
a transparent

@smallexample
ioctl(fd, GET_OPTIONS, &optadd)
@end smallexample

or, alternately, by use of a @manpage{streamio(7)} call

@smallexample
ioctl(fd, I_, &opts_strioctl)
@end smallexample

In the first case, @code{optadd} is declared @code{struct options}.  In the @var{I_STR} case,
@code{opts_strioctl} is declared @code{struct strioctl} where @code{opts_strioctl.ic_dp} points to
the user @code{options} structure.

This example illustrates support of both the @var{I_STR} and transparent forms of an
@command{ioctl}.  The transparent form requires a single @var{M_COPYOUT} message following receipt
of the @var{M_IOCTL} to @command{copyout} the contents of the structure.  @dfn{xxx}@code{wput} is
the write-side put procedure for module or driver @dfn{xxx}:

@smallexample
struct options @{                        /* same members as in user space */
    int op_one;
    int op_two;
    short op_three;
    long op_four;
@};

xxxwput(q, mp)
        queue_t *q;                     /* write queue */
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct copyresp *csp;
    int transparent = 0;

    switch (mp->b_datap->db_type) @{
    .
    .
    .
    case M_IOCTL:
        iocbp = (struct iocblk *) mp->b_rptr;

        switch (iocbp->ioc_cmd) @{
        case GET_OPTIONS:
            if (iocbp->ioc_count == TRANSPARENT) @{
                transparent = 1;
                cqp = (struce copyreq *) mp->b_rptr;
                cqp->cq_size = sizeof(struct options);
                /* Get structure address from linked M_DATA block */
                cqp->cq_addr = (caddr_t) *(long *) mp->b_cont->b_rptr;
                cqp->cq_flag = 0;
                /* No state necessary - we will only ever get one M_IOCDATA from the
                   Stream head indicating success or failure for the copyout */
            @}
            if (mp->b_cont)
                freemsg(mp->b_cont);    /* overwitten below */
            if ((mp->b_cont = allocb(sizeof(struct options), BPRI_MED)) == NULL) @{
                mp->b_datap->db_type = M_IOCNAK;
                iocbp->ioc_error = EAGAIN;
                qreply(q, mp);
                break;
            @}
            xxx_get_options(mp->b_cont);        /* hypothetical routine */
            if (transparent) @{
                mp->b_datap->db_type = M_COPYOUT;
                mp->b_wptr = mp->b_rptr + sizeof(struct copyreq);
            @} else @{
                mp->b_datap->db_type = M_IOCACK;
                iocbp->ioc_count = sizeof(struct options);
            @}
            qreply(q, mp);
            break;

        default:                /* M_IOCTL not for us */
            /* if module, pass on; if driver, nak ioctl */
            break;
        @}                       /* switch (iocbp->ioc_cmd) */
        break;

    case M_IOCDATA:
        csp = (struct copyresp *) mp->b_rptr;
        if (csp->cmd != GET_OPTIONS) @{  /* M_IOCDATA not for us */
            /* if module, pass on; if driver, free message */
            break;
        @}
        if (csp->cp_rval) @{
            freemsg(mp);        /* failure */
            return;
        @}
        /* Data successfully copied out, ack */
        mp->b_datap->db_type = M_IOCACK;        /* reuse M_IOCDATA for ack */
        mp->b_wptr = mp->b_rptr + sizeof(struct iocblk);
        iocbp->ioc_error = 0;   /* may have been overwritten */
        iocbp->ioc_count = 0;   /* may have been overwritten */
        iocbp->ioc_rval = 0;    /* may have been overwritten */
        qreply(q, mp);
        break;
    .
    .
    .
    @}                           /* switch (mp->b_datap->db_type) */
@}
@end smallexample

@subsubsection Bidirectional Transfer Example

This example illustrates bidirectional data transfer between the kernel and user space during
transparent ioctl processing.  It also shows how more complex state information can be used.

The user wants to send and receive data from user buffers as part of a transparent @command{ioctl}
call of the form

@smallexample
ioctl(fd, XXX_IOCTL, &addr_xxxdata)
@end smallexample

The user @code{addr_xxxdata} structure defining the buffers is declared as struct @code{xxxdata},
shown below.  This requires three pairs of messages following receipt of the @var{M_IOCTL} message:
the first to @command{copyin} the structure; the second to @command{copyin} one user buffer; and the
last to @command{copyout} the second user buffer.  @dfn{xxx}@code{wput} is the write-side put
procedure for module or driver @dfn{xxx}:

@smallexample
struct xxxdata @{                        /* same members in user space */
    int x_inlen;                        /* number of bytes copied in */
    caddr_t x_inaddr;                   /* buffer address of data copied in */
    int x_outlen;                       /* number of bytes copied out */
    caddr_t x_outaddr;                  /* buffer address of data copied out */
@};

    /* State information for ioctl processing */
struct state @{
    int st_state;                       /* see below */
    struct xxxdata st_data;             /* see above */
@};

    /* state values */
#define GETSTRUCT        0      /* get xxxdata structure */
#define GETINDATA        1      /* get data from x_inaddr */
#define PUTOUTDATA       1      /* get response from M_COPYOUT */

xxxwput(q, mp)
        queue_t *q;                     /* write queue */
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct state *stp;
    mblk_t *tmp;

    switch (mp->b_datap->db_type) @{
    .
    .
    .
    case M_IOCTL:
        iocbp = (struct iocblk *) mp->b_rptr;
        switch (iocbp->ioc_cmd) @{
        case XXX_IOCTL:
            if (iocbp->ioc_cont != TRANSPARENT) @{       /* fail if I_STR */
                if (mp->b_cont) @{       /* return buffer to pool ASAP */
                    freemsg(mp->b_cont);
                    mp->b_cont = NULL;
                @}
                mp->b_datap->db_type = M_IOCNAK;        /* EINVAL */
                qreply(q, mp);
                break;
            @}
            /* Reuse M_IOCTL block for M_COPYIN request */
            cqp = (struct copyreq *) mp->b_rptr;
            /* Get structure's user address from linked M_DATA block */
            cqp->cq_addr = (caddr_t) *(long *) mp->b_cont->b_rptr;
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            /* Allocate state buffer */
            if ((tmp = allocb(sizeof(struct state), BPRI_MED)) == NULL) @{
                mp->b_datap->db_type = M_IOCNK;
                iocbp->ioc_error = EAGAIN;
                qreply(q, mp);
                break;
            @}
            tmp->b_wptr += sizeof(struct state);
            stp = (struct state *) tmp->b_rptr;
            stp->st_state = GETSTRUCT;
            cqp->cq_private = tmp;
            /* Finish describing M_COPYIN message */
            cqp->cq_size = sizeof(struct xxxdata);
            cqp->cq_flag = 0;
            mp->b_datap->db_type = M_COPYIN;
            mp->b_wptr = mp->b_rptr + sizeof(struct copyreq);
            qreply(q, mp);
            break;

        default:                /* M_ioctl not for us */
            /* if module, pass on */
            /* if driver, nak ioctl */
            break;
        @}
        break;
    case M_IOCDATA:
        xxxioc(q, mp);          /* all M_IOCDATA processing done here */
        break;
    .
    .
    .
    @}                           /* switch (mp->b_datap->db_type) */
@}
@end smallexample

@dfn{xxx}@code{wput} allocates a message block to contain the state structure and reuses the M_IOCTL
to create an @var{M_COPYIN} message to read in the @dfn{xxx}@code{data} structure.

@var{M_IOCDATA} processing is done in @dfn{xxx}@code{ioc}:

@smallexample
xxxioc(q, mp)                   /* M_IOCDATA processing */
        queue_t *q;
        mblk_t *mp;
@{
    struct iocblk *iocbp;
    struct copyreq *cqp;
    struct copyresp *csp;
    struct state *stp;
    mblk_t *xxx_indata();

    csp = (struct copyresp *) mp->b_rptr;
    iocbp = (struct iocblk *) mp->b_rptr;
    switch (csp->cp_cmd) @{

    case XXX_IOCTL:
        if (csp->cp_rval) @{     /* failure */
            if (csp->cp_private)        /* state structure */
                freemsg(csp->cp_private);
            freemsg(mp);
            return;
        @}
        stp = (struct state *) csp->cp_private->b_rptr;
        switch (stp->st_state) @{

        case GETSTRUCT: /* xxxdata structure copied in */
            /* save structure */
            stp->st_data = *(struct xxxdata *) mp->b_cont->b_rptr;
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            /* Reuse M_IOCDATA to copyin data */
            mp->b_datap->db_type = M_COPYIN;
            cqp = (struct copyreq *) mp->b_rptr;
            cqp->cq_size = stp->st_data.x_inlen;
            cqp->cq_addr = stp->st_data.x_inaddr;
            cqp->cq_flag = 0;
            stp->st_state = GETINDATA;  /* next state */
            qreply(q, mp);
            break;

        case GETINDATA: /* data successfully copied in */
            /* Process input, return output */
            if ((mp->b_cont = xxx_indata(mp->b_cont)) == NULL) @{ /* hypothetical */
                mp->b_datap->db_type = M_IOCNAK;        /* fall xxx_indata */
                mp->b_wptr = mp->b_rptr + sizeof(struct iocblk);
                iocbp->ioc_error = EIO;
                qreply(q, mp);
                break;
            @}
            mp->b_datap->db_type = M_COPYOUT;
            cqp = (struct copyreq *) mp->b_rptr;
            cqp->cq_size = min(msgdsize(mp->b_cont), stp->st_data.x_outlen);
            cqp->cq_addr = stp->st_data.x_outaddr;
            cqp->cq_flag = 0;
            stp->st_state = PUTOUTDATA; /* next state */
            qreply(q, mp);
            break;

        case PUTOUTDATA:        /* data successfilly copied out, ack ioctl */
            freemsg(csp->cp_private);   /* state structure */
            mp->b_datap->db_type = M_IOCACK;
            mp->b_wtpr = mp->b_rptr + sizeof(struct iocblk);
            iocbp->ioc_error = 0;       /* may have been overwritten */
            iocbp->ioc_count = 0;       /* may have been overwritten */
            iocbp->ioc_rval = 0;        /* may have been overwritten */
            qreply(q, mp);
            break;

        default:                /* invalid state: can't happen */
            freemsg(mp->b_cont);
            mp->b_cont = NULL;
            mp->b_datap->db_type = M_IOCNAK;
            mp->b_wptr = mp->b_rptr + sizeof(struct iocblk);
            iocbp->ioc_error = EINVAL;
            qreply(q, mp);
            ASSERT(0);          /* panic if debugging mode */
            break;
        @}                       /* switch (stp->st_state) */
        break;
    default:                    /* M_IOCDATA not for us */
        /* if module, pass message on */
        /* if driver, free message */
        break;
    @}                           /* switch (csp->cp_cmd) */
@}
@end smallexample

At case @var{GETSTRUCT}, the @dfn{xxx}@code{data} structure is copied into the module's state
structure (pointed at by @var{cp_private} in the message) and the @var{M_IOCDATA} message is reused
to create a second @var{M_COPYIN} message to read in the user data.  At case @var{GETINDATA}, the
input user data are processed by the @dfn{xxx}@code{_indata} routine (not supplied in the example)
which frees the linked @var{M_DATA} block and returns the output data message block.  The
@var{M_IOCDATA} message is reused to create an @var{M_COPYOUT} message to write the user data.  At
case @var{PUTOUTDATA}, the message block containing the state structure is freed and an
acknowledgement is sent upstream.

Care must be taken at the "can't happen" default case since the message block containing the state
structure (@var{cp_private}) is not returned to the pool because it might not be valid.  This might
result in a lost block.  The @command{ASSERT} will help find errors in the module if a "can't
happen" condition occurs.

@node I_LIST ioctl
@subsection @code{I_LIST} @command{ioctl}

The @command{ioctl} @var{I_LIST} supports the
@command{strconf} and @command{strchg} commands [see @manpage{strconf(1)} and @manpage{strchg(1)}]
that are used to query or change the configuration of a @dfn{Stream}.  Only the super-user or an
owner of a @dfn{STREAMS} device may alter the configuration of that @dfn{Stream}.

The @manpage{strchg(1)} command does the following:

@itemize @bullet
@item Push one or more modules on the @dfn{Stream}.
@item Pop the topmost module off the @dfn{Stream}.
@item Pop all the modules off the @dfn{Stream}.
@item Pop all modules up to but not including a specified module.
@end itemize

The @manpage{strconf(1)} command does the following:

@itemize @bullet
@item Indicate if the specified module is present on the @dfn{Stream}.
@item Print the topmost module of the @dfn{Stream}.
@item Print a list of all modules and topmost driver on the @dfn{Stream}.
@end itemize

If the @dfn{Stream} contains a multiplexing driver, the @manpage{strchg(1)} and @manpage{strconf(1)}
commands will not recognize any modules below that driver.

The @command{ioctl} @var{I_LIST} performs two functions.  When the third argument of the
@command{ioctl} call is set to @var{NULL}, the return value of the call indicates the number of
modules, including the driver, present on the @dfn{Stream}.  For example, if there are two modules
above the driver, 3 is returned.  On failure, errno may be set to a value specified in
@manpage{streamio(7)}.  The second function of the @var{I_LIST} @command{ioctl} is to copy the
module names found on the @dfn{Stream} to the user supplied buffer.  The address of the buffer in
user space and the size of the buffer are passed to the @command{ioctl} through a structure
@code{str_list} that is defined as:

@smallexample
struct str_mlist @{
    char l_name[FMNAMESZ + 1];          /* space for holding a module name */
@};
struct str_list @{
    int sl_nmods;                       /* # of modules for which space is
                                           allocated */
    struct str_mlist *sl_modlist;       /* address of buffer for names */
@};
@end smallexample

where @var{sl_nmods} is the number of modules in the @var{sl_modlist} array that the user has
allocated.  Each element in the array must be at least @samp{FMNAMESZ+1} bytes long.  @var{FMNAMESZ}
is defined by @file{<sys/conf.h>}.

The user can find out how much space to allocate by first invoking the @command{ioctl} @var{I_LIST}
with arg set to @var{NULL}.  The @var{I_LIST} call with @var{arg} pointing to the @code{str_list}
structure returns the number of entries that have been filled into the @var{sl_modlist} array (the
number includes the number of modules including the driver).  If there is not enough space in the
@var{sl_modlist} array (see note) or @var{sl_nmods} is less than 1, the @var{I_LIST} call will fail
and errno is set to @var{EINVAL}.  If @var{arg} or the @var{sl_modlist} array points outside the
allocated address space, @var{EFAULT} is returned.

It is possible, but unlikely, that another module was pushed on the @dfn{Stream} after the user
invoked the @var{I_LIST} @command{ioctl} with the @var{NULL} argument and before the @var{I_LIST}
@command{ioctl} with the structure argument was invoked.

@node Flush Handling
@section STREAMS Flush Handling
@cindex flush handling

All modules and drivers are expected to handle @var{M_FLUSH} messages.  An @var{M_FLUSH} message can
originate at the @dfn{Stream head} or from a module or a driver.  The first byte of the
@var{M_FLUSH} message is an option flag that can have following values:

@vtable @var
@item FLUSHR
Flush read queue.
@item FLUSHW
Flush write queue.
@item FLUSHRW
Flush both, read and write, queues.
@item FLUSHBAND
Flush a specified priority band only.
@end vtable

The following example shows line discipline module flush handling:

@smallexample
ld_put(q, mp)
        queue_t *q;                     /* pointer to read/write queue */
        mblk_t *mp;                     /* pointer to message being passed */
@{
    switch (mp->b_datap->db_type) @{
    default:
        putq(q, mp);            /* queue everything */
        return;                 /* except flush */

    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW)       /* flush write queue */
            flushq((q->q_flag & QREADR) ? WR(q) : q, FLUSHDATA);

        if (*mp->b_rptr & FLUSHR)       /* flush read queue */
            flushq((q->q_flag & QREADR) ? q : RD(q), FLUSHDATA);
        putnext(q, mp);         /* pass it on */
        return;
    @}
@}
@end smallexample

The @dfn{Stream head} turns around the @var{M_FLUSH} message if @var{FLUSHW} is set (@var{FLUSHR}
will be cleared).  A driver turns around @var{M_FLUSH} if @var{FLUSHR} is set (should mask off
@var{FLUSHW}).

The next example shows the line discipline module flushing due to break:

@smallexample
ld_put(q, mp)
        queue_t *q;                     /* pointer to read/write queue */
        mblk_t *mp;                     /* pointer to message being passed */
@{
    switch (mp->b_datap->db_type) @{
    default:
        putq(q, mp);            /* queue everything except flush */
        return;

    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW)       /* flush write queue */
            flushq((q->q_flag & QREADR) ? WR(q) : q, FLUSHDATA);

        if (*mp->b_rptr & FLUSHR)       /* flush read queue */
            flushq((q->q_flag & QREADR) ? q : RD(q), FLUSHDATA);
        putnext(q, mp);         /* pass it on */
        return;
    case M_BREAK:
        if (q->q_flag & QREADR) @{       /* read side only */
            /* it doesn't make sense for write side */
            putctll(q->q_next, M_PCSIG, SIGINT);
            putctll(q->q_next, M_FLUSH, FLUSHW);
            putctll(WR(q)->q_next, M_FLUSH, FLUSHR);
        @}
        return;
    @}
@}
@end smallexample

The next two figures further demonstrate flushing the entire @dfn{Stream} due to a line break.
@figref{10} shows the flushing of the write-side of a @dfn{Stream}, and @figref{11} shows the
flushing of the read-side of a @dfn{Stream}.  In the figures dotted boxes indicate flushed queues.

@figuresized{SPG_fig10,10,Flushing the Write-Side of a @dfn{Stream},4in}

The following takes place:

@enumerate
@item A break is detected by a driver.
@item The driver generates an @var{M_BREAK} message and sends it upstream.
@item The module translates the @var{M_BREAK} into an @var{M_FLUSH} message with @var{FLUSHW} set and sends it upstream.
@item The @dfn{Stream} head does not flush the write queue (no messages are ever queued there).
@item The @dfn{Stream} head turns the message around (sends it down the write-side).
@item The module flushes its write queue.
@item The message is passed downstream.
@item The driver flushes its write queue and frees the message.
@end enumerate

This figure shows flushing read-side of a @dfn{Stream}.

@figuresized{SPG_fig11,11,Flushing the Read-Side of a @dfn{Stream},4in}

The events taking place are:

@enumerate
@item After generating the first @var{M_FLUSH} message, the module generates an @var{M_FLUSH} with @var{FLUSHR} set and sends it downstream.
@item The driver flushes its read queue.
@item The driver turns the message around (sends it up the read-side).
@item The module flushes its read queue.
@item The message is passed upstream.
@item The @dfn{Stream} head flushes the read queue and frees the message.
@end enumerate

The @manpage{flushband(9)} routine (@pxref{STREAMS Utilities}) provides the module and driver with
the capability to flush messages associated with a given priority band.  A user can flush a
particular band of messages by issuing:

@smallexample
ioctl(fd, I_FLUSHBAND, bandp)
@end smallexample

where @var{bandp} is a pointer to a structure @code{bandinfo} that has a format:

@smallexample
struct bandinfo @{
    unsigned char bi_pri;
    int bi_flag;
@};
@end smallexample

The @var{bi_flag} field may be one of @var{FLUSHR}, @var{FLUSHW}, or @var{FLUSHRW}.

The following example shows flushing according to the priority band:

@smallexample
@{
    queue_t *rdq;                       /* read queue */
    queue_t *wrq;                       /* write queue */

    switch (bp->b_datap->db_type) @{
    case M_FLUSH:
        if (*bp->b_rptr & FLUSHBAND) @{
            if (*bp->b_rptr & FLUSHW)
                flushband(wrq, FLUSHDATA, *(bp->b_rptr + 1));
            if (*bp->b_rptr & FLUSHR)
                flushband(rdq, FLUSHDATA, *(bp->b_rptr + 1));
        @} else @{
            if (*bp->b_rptr & FLUSHW)
                flushq(wrq, FLUSHDATA);
            if (*bp->b_rptr & FLUSHR)
                flushq(rdq, FLUSHDATA);
        @}
        /* 
         * modules pass the message on;
         * drivers shut off FLUSHW and loop the message
         * up the read-side if FLUSHR is set; otherwise,
         * drivers free the message.
         */
        break;
    @}
@}
@end smallexample

Note that modules and drivers are not required to treat messages as flowing in separate bands.
Modules and drivers can view the queue having only two bands of flow, normal and high priority.
However, the latter alternative will flush the entire queue whenever an @var{M_FLUSH} message is
received.

One use of the field @var{b_flag} of the @code{msgb} structure is provided to give the @dfn{Stream}
head a way to stop @var{M_FLUSH} messages from being reflected forever when the @dfn{Stream} is
being used as a pipe.  When the @dfn{Stream} head receives an @var{M_FLUSH} message, it sets the
@var{MSGNOLOOP} flag in the @var{b_flag} field before reflecting the message down the write-side of
the @dfn{Stream}.  If the @dfn{Stream head} receives an @var{M_FLUSH} message with this flag set,
the message is freed rather than reflected.

@node Driver-Kernel Interface
@section STREAMS Driver-Kernel Interface
@cindex driver-kernel interface

The @dfn{Driver-Kernel Interface (DKI)} is an interface between the @cite{UNIX} system kernel and
drivers.  These drivers are block interface drivers, character interface drivers, and drivers and
modules supporting a @dfn{STREAMS} interface.  Each driver type supports an interface from the
kernel to the driver.  This kernel to-driver interface consists of a set of driver-defined functions
that are called by the kernel.  These functions are the entry points into the driver.

One benefit of defining the @dfn{DKI} is increased portability of driver source code between various
@dfn{UNIX System V} implementations.  Another benefit is a gain in modularity that results in
extending the potential for changes in the kernel without breaking driver code.

The interaction between a driver and the kernel can be described as occurring along two paths.  (See
@figref{12}).

One path includes those functions in the driver that are called by the kernel.  These are entry
points into the driver.  The other path consists of the functions in the kernel that are called by
the driver.  These are kernel utility functions used by the driver.  Along both paths, information
is exchanged between the kernel and drivers in the form of data structures.  The @dfn{DKI}
identifies these structures and specifies a set of contents for each.  The @dfn{DKI} also defines
the common set of entry points expected to be supported in each driver type and their calling and
return syntaxes.  For each driver type, the @dfn{DKI} lists a set of kernel utility functions that
can be called by that driver and also specifies their calling and return syntaxes.

@figuresized{SPG_fig12,12,Interfaces Affecting Drivers,4in}

The set of @dfn{STREAMS} utilities available to drivers are listed (@pxref{STREAMS Utilities}).  No
system-defined macros that manipulate global kernel data or introduce structure size dependencies
are permitted in these utilities.  Therefore, some utilities that have been implemented as macros in
the prior @cite{UNIX} system releases are implemented as functions in @cite{UNIX System V Release
4.0}.  This does not preclude the existence of both macro and function versions of these utilities.
It is envisioned that driver source code will include a header file (@pxref{Header Files}, later in
this chapter) that picks up function declarations while the core operating system source includes a
header file that defines the macros.  With the @dfn{DKI} interface the following @dfn{STREAMS}
utilities are implemented as @samp{C} programming language functions: @manpage{datamsg(9)},
@manpage{OTHERQ(9)}, @manpage{putnext(9)}, @manpage{RD(9)}, @manpage{splstr(9)}, and
@manpage{WR(9)}.

Replacing macros such as @manpage{RD(9)} with function equivalents in the driver source code allows
driver objects to be insulated from changes in the data structures and their size, further
increasing the useful lifetime of driver source code and objects.

The @dfn{DKI} interface defines an interface suitable for drivers and there is no need for drivers
to access global kernel data structures directly.  The kernel functions @manpage{drv_getparm(9)} and
@manpage{drv_setparm(9)} are provided for reading and writing information in these structures.  This
restriction has an important consequence.  Since drivers are not permitted to access global kernel
data structures directly, changes in the contents/offsets of information within these structures
will not break objects.

@subsection Device Driver Interface and Driver-Kernel Interface

The @dfn{Device Driver Interface (DDI)} is an @cite{AT&T} interface that facilitates driver
portability across different @cite{UNIX} system versions on the @cite{AT&T 3B2} hardware.  The
@dfn{Driver-Kernel Interface (DKI)} is an interface that also facilitates driver source code
portability across implementations of @cite{UNIX System V Release 4.0} on all machines.  @dfn{DKI}
driver code, however, will have to be recompiled on the machine on which it is to run.

The most important distinction between the @dfn{DDI} and the @dfn{DKI} lies in scope.  The @dfn{DDI}
addresses complete interfaces (see note below) for block, character, and @dfn{STREAMS} interface
drivers and modules.  The @dfn{DKI} defines only driver interfaces with the kernel with the addition
of the kernel interface for file system type (@dfn{FST}) modules.  The @dfn{DKI} interface does not
specify the system initialization driver interface [i.e., @command{init()} and @command{start()}
driver routines] nor hardware related interfaces such as @command{getvec} for the @cite{AT&T 3B2}.

The "complete interface" refers to hardware- and boot/configuration-related driver interface in
addition to the interface with the kernel.

@subsection @dfn{STREAMS} Interface

The entry points from the kernel into @dfn{STREAMS} drivers and modules are through the @code{qinit}
structures (@pxref{STREAMS Data Structures}) pointed to by the @code{streamtab} structure,
@code{prefixinfo}.  @dfn{STREAMS} drivers may need to define additional entry points to support the
interface with boot/autoconfiguration software and the hardware (for example, an interrupt handler).

If the @dfn{STREAMS} module has prefix @dfn{mod} then the declaration is of the form:

@smallexample
static int modwput(), modwput(), modwsrv(), modclose();

static int modwput(), modwput(), modwsrv();

static struct qinit rdinit =
    @{ modrput, modrsrv, modopen, modclose, NULL, struct module_info, NULL @};

static struct qinit wdinit =
    @{ modwput, modwsrv, NULL, NULL, NULL, struct module_info, NULL @};

struct streamtab modinfo =
    @{ &rdinit, &wrinit, NULL, NULL @};

extern int moddevflag = 0;
@end smallexample

where @code{modrput} is the module's read queue put procedure, @code{modrsrv} is the module's read
queue service procedure, @code{modopen} is the open routine for the module, @code{modclose} is the
close routine for the module, @code{modwput} is the put procedure for the module's write queue, and
@code{modwsrv} is the service procedure for the module's write queue.

Each @code{qinit} structure can point to four entry points.  (An additional function pointer has been
reserved for future use and must not be used by drivers or modules.) These four function pointer
fields in the @code{qinit} structure are: @var{qi_putp}, @var{qi_srvp}, @var{qi_qopen}, and
@var{qi_close}.

The utility functions that can be called by @dfn{STREAMS} drivers and modules are listed
(@pxref{STREAMS Utilities}).  They must follow the call and return syntaxes specified in the
appendix.

@node Design Guidelines
@section STREAMS Design Guidelines
@cindex design guidelines
@menu
* Module and Driver Rules::
* Data Structures::
* Header Files::
* Accessible Symbols and Functions::
@end menu

This section summarizes guidelines common to the design of @dfn{STREAMS} modules and drivers.
Additional rules pertaining to modules and drivers can be found in @ref{Modules}, for modules and
@ref{Drivers}, for drivers.

@node Module and Driver Rules
@subsection Module and Driver Rules
@menu
* Rules for Open and Close Routines::
* Rules for Input Output Controls::
* Rules for Put and Service Procedures::
@end menu

@enumerate
@item Modules and drivers cannot access information in the @code{u_area} of a process.  Modules and
drivers are not associated with any process, and therefore have no concept of process or user
context, except during @command{open} and @command{close} routines (@pxref{Rules for Open and Close
Routines}).
@item Every module and driver must process an @var{M_FLUSH} message according to the value of the
argument passed in the message.
@item A module or a driver should not change the contents of a data block whose reference count is
greater than 1 [see @manpage{dupmsg(9)}] because other modules/drivers that have references to the
block may not want the data changed.  To avoid problems, data should be copied to a new block and
then changed in the new one.
@item Modules and drivers should manipulate queues and manage buffers only with the routines
provided for that purpose, (@pxref{STREAMS Utilities}).
@item Modules and drivers should not require the data in an @var{M_DATA} message to follow a
particular format, such as a specific alignment.
@item Care must be taken when modules are mixed and matched, because one module may place different
semantics on the priority bands than another module.  The specific use of each band by a module
should be included in the service interface specification.  When designing modules and drivers that
make use of priority bands one should keep in mind that priority bands merely provide a way to
impose an ordering of messages on a queue.  The priority band is not used to determine the service
primitive.  Instead, the service interface should rely on the data contained in the message to
determine the service primitive.
@end enumerate

@node Rules for Open and Close Routines
@subsubsection Rules for Open and Close Routines

@enumerate
@item  @command{open} and @command{close} routines may sleep, but the sleep must return to the
routine in the event of a signal.  That is, if they sleep, they must be at @samp{priority <= PZERO},
or with @samp{PCATCH} set in the sleep priority.
@item  The @command{open} routine should return zero on success or an error number on failure.  If
the @command{open} routine is called with the @var{CLONEOPEN} flag, the device number should be set
by the driver to an unused device number accessible to that driver.  This should be an entire device
number (major/minor).
@item  @command{open} and @command{close} routines have user context and can access the
@code{u_area}.  Only the following fields can be accessed in the @code{u_area} (@file{user.h}):
@var{u_procp}, @var{u_ttyp}, @var{u_uid}, @var{u_gid}, @var{u_ruid}, and @var{u_rgid}.  The fields
@var{u_uid}, @var{u_gid}, @var{u_ruid}, and @var{u_rgid} are for backward compatibility with
previously designed device drivers.  The actual user credentials are passed directly to the driver
and need not be accessed in the @code{u_area}.  These fields may not support valid @dfn{uids} or
@dfn{gids} when the system is configured with large user ids.  See note.
@item  Only the following fields can be accessed in the process table (@file{proc.h}): @var{p_pid},
@var{p_pgrp}.  See note.
@item  If a module or a driver wants to allocate a controlling terminal, it should send an
@var{M_SETOPTS} message to the @dfn{Stream} head with the @var{SO_ISTTY} flag set.  Otherwise
signaling will not work on the @dfn{Stream}.
@end enumerate

The @dfn{DKI} interface provides the @manpage{drv_getparm(9)} and @manpage{drv_setparm(9)} functions
to read/write these data and the driver/module need not access them directly.

@node Rules for Input Output Controls
@subsubsection Rules for Input Output Controls

@itemize @bullet
@item Do not change the @var{ioc_id}, @var{ioc_uid}, @var{ioc_gid}, or @var{ioc_cmd} fields in an
@var{M_IOCTL} message.
@item The above rule also applies to fields in an @var{M_IOCDATA}, @var{M_COPYIN}, and
@var{M_COPYOUT} message.  (Field names are different; @pxref{STREAMS Data Structures})
@item Always validate @var{ioc_count} to see whether the @command{ioctl} is the @dfn{transparent} or
@var{I_STR} form.
@end itemize

@node Rules for Put and Service Procedures
@subsubsection Rules for Put and Service Procedures

To ensure proper data flow between modules and drivers, the following rules should be observed in
@command{put} and @command{service} procedures:

@itemize @bullet
@item Put and @command{service} procedure must not sleep.
@item Return codes can be sent with @dfn{STREAMS} messages @var{M_IOCACK}, @var{M_IOCNAK}, and
@var{M_ERROR}.
@item Protect data structures common to @command{put} and @command{service} procedures by using
@manpage{splstr(9)}.
@item Put and @command{service} procedures cannot access the information in the @code{u_area} of a process.
@item Processing @var{M_DATA} messages by both @command{put} and @command{service} procedures could
lead to messages going out of sequence.  The @command{put} procedure should check if any messages
were queued before processing the current message.
@end itemize

On the read-side, it is usually a good idea to have the @command{put} procedure check if the
@command{service} procedure is running because of the possibility of a race condition.  That is, if
there are unprotected sections in the @command{service} procedure, the @command{put} procedure can
be called and run to completion while the @command{service} procedure is running (the @command{put}
procedure can interrupt the @command{service} procedure on the read-side).  For example, the
@command{service} procedure is running and it removes the last message from the queue, but before it
puts the message upstream the @command{put} procedure is called (e.g., from an interrupt routine) at
an unprotected section in the @command{service} procedure.  The @command{put} procedure sees that
the queue is empty and processes the message.  The @command{put} procedure then returns and the
@command{service} procedure resumes; but at this point data are out of order because the
@command{put} procedure sent upstream the message that was received after the data the
@command{service} procedure was processing.

@subsubheading Put Procedures

@enumerate
@item  Each queue must define a @command{put} procedure in its @code{qinit} structure for passing
messages between modules.
@item  A @command{put} procedure must use the @manpage{putq(9)} (@pxref{STREAMS Utilities}) utility
to enqueue a message on its own queue.  This is necessary to ensure that the various fields of the
queue structure are maintained consistently.
@item  When passing messages to a neighboring module, a module may not call @manpage{putq(9)}
directly, but must call its neighbor module's @command{put} procedure [see @manpage{putnext(9)}].
However, the @var{q_qinfo} structure that points to a module's @command{put} procedure may point to
@manpage{putq(9)} [i.e., @manpage{putq(9)} is used as the @command{put} procedure for that module].
When a module calls a neighbor module's @command{put} procedure that is defined in this manner, it
will be calling @manpage{putq(9)} indirectly.  If any module uses @manpage{putq(9)} as its
@command{put} procedure in this manner, the module must define a @command{service} procedure.
Otherwise, no messages will ever be processed by the next module.  Also, because @manpage{putq(9)}
does not process @var{M_FLUSH} messages, any module that uses @manpage{putq(9)} as its @command{put}
procedure must define a @command{service} procedure to process @var{M_FLUSH} messages.
@item  The @command{put} procedure of a queue with no @command{service} procedure must call the
@command{put} procedure of the next queue using @manpage{putnext(9)}, if a message is to be passed
to that queue.
@item  Processing many function calls with the @command{put} procedure could lead to interrupt stack
overflow.  In that case, switch to @command{service} procedure processing whenever appropriate to
switch to a different stack.
@end enumerate

@subsubheading Service Procedures

@enumerate
@item  If flow control is desired, a @command{service} procedure is required.  The
@manpage{canput(9)} or @manpage{bcanput(9)} routines should be used by @command{service} procedures
before doing @manpage{putnext(9)} to honor flow control.
@item  The @command{service} procedure must use @manpage{getq(9)} to remove a message from its
message queue, so that the flow control mechanism is maintained.
@item  The @command{service} procedure should process all messages on its queue.  The only exception
is if the @dfn{Stream head} is blocked [i.e., @manpage{canput(9)} fails] or some other failure like
buffer allocation failure.  Adherence to this rule is the only guarantee that @dfn{STREAMS} will
enable (schedule for execution) the @command{service} procedure when necessary, and that the flow
control mechanism will not fail.  If a @command{service} procedure exits for other reasons, it must
take explicit steps to assure it will be re-enabled.
@item  The @command{service} procedure should not @command{put} a high priority message back on the
queue, because of the possibility of getting into an infinite loop.
@item  The @command{service} procedure must follow the steps below for each message that it processes.
@dfn{STREAMS} flow control relies on strict adherence to these steps.
@end enumerate

@table @asis
@item Step 1:
Remove the next message from the queue using @manpage{getq(9)}.  It is possible that the
@command{service} procedure could be called when no messages exist on the queue, so the
@command{service} procedure should never assume that there is a message on its queue.  If there is
no message, return.
@item Step 2:
If all of the following conditions are met: @manpage{canput(9)} or @manpage{bcanput(9)} fails and
the message type is not a high priority type and the message is to be @command{put} on the next
queue, continue at Step 3.  Otherwise, continue at Step 4.
@item Step 3:
The message must be replaced on the head of the queue from which it was removed using
@manpage{putbq(9)} (@pxref{STREAMS Utilities}).  Following this, the @command{service} procedure is
exited.  The @command{service} procedure should not be re-enabled at this point.  It will be
automatically back-enabled by flow control.
@item Step 4:
If all of the conditions of Step 2 are not met, the message should not be returned to the queue.  It
should be processed as necessary.  Then, return to Step 1.
@end table

@node Data Structures
@subsection Data Structures

Only the contents of q_ptr, q_minpsz, q_maxpsz, q_hiwat, and q_lowat in the queue structure may be
altered.  q_minpsz, q_maxpsz, q_hiwat, and q_lowat are set when the module or driver is opened, but
they may be modified subsequently.

Drivers and modules are allowed to change the qb_hiwat and qb_lowat fields of the qband structure.
They may only read the qb_count, qb_first, qb_last, and qb_flag fields.

The routines strqget() and strqset() can be used to get and set the fields associated with the
queue.  They insulate modules and drivers from changes in the queue structure and also enforce the
previous rules.

@subsubsection Dynamic Allocation of STREAMS Data Structures

Prior to @cite{UNIX System V Release 4.0}, @dfn{STREAMS} data structures were statically configured
to support a fixed number of @dfn{Streams}, read and write queues, message and data blocks, link
block data structures, and @dfn{Stream} event cells.  The only way to change this configuration was
to reconfigure and reboot the system.  Resources were also wasted because data structures were
allocated but not necessarily needed.

With @cite{Release 4.0} the @dfn{STREAMS} mechanism has been enhanced to dynamically allocate the
following @dfn{STREAMS} data structures: @code{stdata}, @code{queue}, @code{linkblk},
@code{strevent}, @code{datab}, and @code{msgb}.  @dfn{STREAMS} allocates memory to cover these
structures as needed.

Dynamic data structure allocation has the advantage of the kernel being initially smaller than a
system with static configuration.  The performance of the system may also improve because of better
memory utilization and added flexibility.  However, @manpage{allocb(9)}, @manpage{bufcall(9)}, and
@manpage{freeb(9)}, the routines that manage these data structures, may be slower at times because
of extra overhead needed for dynamic allocation.

@node Header Files
@subsection Header Files

The following header files are generally required in modules and drivers:

@ftable @file
@item types.h
contains type definitions used in the @dfn{STREAMS} header files
@item stream.h
contains required structure and constant definitions
@item stropts.h
primarily for users, but contains definitions of the arguments to the @var{M_FLUSH} message type
also required by modules
@item ddi.h
contains definitions and declarations needed by drivers to use functions for the @cite{UNIX System
V} @dfn{Device Driver Interface} or @dfn{Driver-Kernel Interface}.  This header file should be the
last header file included in the driver source code (after all statements).
@end ftable

One or more of the header files described next may also be included.  No standard @cite{UNIX} system
header files should be included except as described in the following section.  The intent is to
prevent attempts to access data that cannot or should not be accessed.

@ftable @file
@item errno.h
defines various system error conditions, and is needed if errors are to be returned upstream to the
user
@item sysmacros.h
contains miscellaneous system macro definitions
@item param.h
defines various system parameters, particularly the value of the @var{PCATCH} sleep flag
@item signal.h
defines the system signal values, and should be used if signals are to be processed or sent upstream
@item file.h
defines the file open flags, and is needed if @var{O_NDELAY} (or @var{O_NONBLOCK}) is interpreted
@end ftable

@node Accessible Symbols and Functions
@subsection Accessible Symbols and Functions


The following lists the only symbols and functions that modules or drivers may refer to (in addition
to those defined by @dfn{STREAMS}; see Appendices A and C), if hardware and system release
independence is to be maintained.  Use of symbols not listed here is unsupported.

@ftable @file
@item user.h
(from open/close procedures only)

@vtable @var
@item u_procp
process structure pointer
@item u_ttyp
tty group ID pointer
@end vtable

@item proc.h
(from open/close procedures only)

@vtable @var
@item p_pid
process ID
@item p_pgrp
process group ID
@end vtable

@item (none)
functions accessible from open/close procedures only

@vtable @command
@item sleep(chan, pri)
sleep until wakeup
@item delay(ticks)
delay for a specified time
@end vtable

@item (none)
universally accessible functions

@vtable @command
@item bcopy(from, to, nbytes)
copy data quickly
@item bzero(buffer, nbytes)
zero data quickly
@item max(a, b)
return max of args
@item min(a, b)
return min of args
@item rmalloc(mp, size)
allocate memory space
@item rmfree(mp, size, i)
de-allocate memory space
@item rminit(mp, mapsize)
initialize map structure
@item vtop(vaddr, NULL)
translate from virtual to physical address
@item cmn_err(level,...)
print message and optional panic
@item spln()
set priority level
@item splstr()
set processor level for Streams
@item timeout(func, arg, ticks)
schedule event
@item untimeout(id)
cancel event
@item wakeup(chan)
wake up sleeper
@end vtable

@item sysmacros.h
The first four functions are used to get the major/minor part of the expanded device number.

@vtable @command
@item getemajor(x)
return external major part
@item getmajor(x)
return internal major part
@item geteminor(x)
return external minor part
@item getminor(x)
return internal minor part
@item makedev(x, y)
create a old device number
@item makedevice(x, y)
create a new device number
@item cmpdev(x)
convert to old device format
@item expdev(x)
convert to new device format
@end vtable

@item systm.h
system file

@vtable @var
@item lbolt
clock ticks since boot in HZ
@item time
seconds since epoch
@end vtable

@item param.h
parameter file

@vtable @var
@item PZERO
zero sleep priority
@item PCATCH
catch signal sleep flag
@item HZ
clock ticks per second
@item NULL
0
@end vtable

@item types.h
Everything in @file{types.h} can be used.
@end ftable

@node STREAMS Modules
@chapter STREAMS Modules
@cindex STREAMS modules
@menu
* Modules::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines
@end menu

@node Modules
@section Modules

A @dfn{STREAMS} module is a pair of queues and a defined set of kernel-level routines and data
structures used to process data, status, and control information.  A @dfn{Stream} may have zero or
more modules.  User processes push (insert) modules on a @dfn{Stream} using the @var{I_PUSH}
@command{ioctl} and pop (remove) them using the @var{I_POP} @command{ioctl}.  Pushing and popping of
modules happens in a @dfn{LIFO (Last-In-First-Out)} fashion.  Modules manipulate messages as they
flow through the @dfn{Stream}.

@subsection Module Routines

@dfn{STREAMS} module routines (@command{open}, @command{close}, @command{put}, @command{service})
have already been described in the previous chapters.  This section shows some examples and further
describes attributes common to module @command{put} and @command{service} routines.

A module's @command{put} routine is called by the preceding module, driver, or @dfn{Stream head} and
before the corresponding @command{service} routine.  The @command{put} routine should do any
processing that needs to be done immediately (for example, processing of high priority messages).
Any processing that can be deferred should be left for the corresponding @command{service} routine.

The @command{service} routine is used to implement flow control, handle de-packetization of
messages, perform deferred processing, and handle resource allocation.  Once the @command{service}
routine is enabled, it always runs before any user level code.  The @command{put} and
@command{service} routines must not call @manpage{sleep(9)} and cannot access the @code{u_area}
area, because they are executed asynchronously with respect to any process.

The following example shows a @dfn{STREAMS} module read-side @command{put} routine:

@smallexample
modrput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    struct mod_prv *modptr;

    modptr = (struct mod_prv *) q->q_ptr;       /* for state information */
    if (mp->b_datap->db_type >= QPCTL) @{        /* process priority message */
        putnext(q, mp);         /* and pass it on */
        return;
    @}
    switch (mp->b_datap->db_type) @{
        case M_DATA;            /* may process message data */
        putq(q, mp);            /* queue message for service routine */
        return;
        case M_PROTO;           /* handle protocol control message */
    .
    .
    .
    default:
        putnext(q, mp);
        return;
    @}
@}
@end smallexample

The following briefly describes the code:

@itemize @bullet

@item A pointer to a queue defining an instance of the module and a pointer to amessage are passed
to the @command{put} routine.

@item The @command{put} routine switches on the type of the message.  For each message type, the
@command{put} routine either enqueues the message for further processing by the module
@command{service} routine, or passes the message to the next module in the @dfn{Stream}.

@item High priority messages are processed immediately by the @command{put} routine and passed to
the next module.

@item Ordinary (or normal) messages are either enqueued or passed along the @dfn{Stream}.

@end itemize

This example shows a module write-side @command{put} routine:

@smallexample
modwput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    struct mod_prv *modptr;

    modptr = (struct mod_prv *) q->q_ptr;       /* for state information */
    if (mp->b_datap->db_type >= QPCTL) @{        /* process priority message */
        putnext(q, mp);         /* and pass it on */
        return;
    @}
    switch (mp->b_datap->db_type) @{
    case M_DATA:                /* may process message data */
        putq(q, mp);            /* queue message for service routine */
        /* or pass message along */
        /* putnext(q, mp); */
        return;
    case M_PROTO:
    .
    .
    .
    case M_IOCTL:               /* if command in message is recognized */
        /* process message and send back reply */
        /* else pass message downstream */
    default:
        putnext(q, mp);
        return;
    @}
@}
@end smallexample

The write-side @command{put} routine, unlike the read-side, may be passed M_IOCTL messages.  It is up to the
module to recognize and process the @command{ioctl} command, or pass the message downstream if it does not
recognize the command.

The following example shows a general scenario employed by the module's @command{service} routine:

@smallexample
modrsrv(q)
        queue_t *q;
@{
    mblk_t *mp;

    while ((mp = getq(q)) != (mblk_t *) NULL) @{
        if (!(mp->b_datap->db_type >= QPCTL) && !canput(q->q_next)) @{
            /* flow control check */
            putbq(q, mp);       /* return message */
            return;
        @}
        /* process the message */
        switch (mp->b_datap->db_type) @{
            .
            .
            .
            putnext(q, mp);     /* pass the result */
        @}
    @}                           /* while */
@}
@end smallexample

The steps are:

@itemize @bullet

@item Retrieve the first message from the queue using getq().  If the message is high priority,
process

@item it immediately, and pass it along the @dfn{Stream}.

@item Otherwise, the @command{service} routine should use the canput() utility to determine if the next module
or driver that enqueues messages is within acceptable flow control limits.  The canput() routine
goes down (or up on the read-side) the @dfn{Stream} until it reaches a module, a driver, or the @dfn{Stream
head} with a @command{service} routine.  When it reaches one, it looks at the total message space currently
allocated at that queue for enqueued messages.  If the amount of space currently used at that queue
exceeds the high water mark, the canput() routine returns false (zero).  If the next queue with a
@command{service} routine is within acceptable flow control limits, canput() returns true (nonzero).

@item If canput() returns false, the @command{service} routine should return the message to its own queue
using the putbq() routine.  The @command{service} routine can do no further processing at this time, and it
should return.

@item If canput() returns true, the @command{service} routine should complete any processing of the message.
This may involve retrieving more messages from the queue, (de)-allocating header and trailer
information, and performing control function for the module.

@item When the @command{service} routine is finished processing the message, it may call the putnext() routine
to pass the resulting message to the next queue.

@item Above steps are repeated until there are no messages left on the queue (that is, getq()
returns NULL) or canput() returns false.

@end itemize

@subsection Filter Module Example

The module shown next, crmod, is an asymmetric filter.  On the write-side, newline is converted to
carriage return followed by newline.  On the read-side, no conversion is done.  The declarations of
this module are essentially the same as those of the null module presented in the previous chapter:

@smallexample
/* Simple filter - converts newline -> carriage return, newline */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stream.h>
#include <sys/stropts.h>

static struct module_info minfo = @{ 0x09, "crmod", 0, INFPSZ, 512, 128 @};

static int modopen(), modrput(), modwput(), modwsrv(), modclose();

static struct qinit rinit = @{
    modrput, NULL, modopen, modclose, NULL, &minfo, NULL
@};

static struct qinit winit = @{
    modwput, modwsrv, NULL, NULL, NULL, NULL, &minfo, NULL
@};

struct streamtab crmdinfo = @{ &rinit, &winit, NULL, NULL @};

extern int moddevflag = 0;
@end smallexample

A master.d file to configure crmod is shown in Configuration.  sys/stropts.h includes definitions of
flush message options common to user level, modules and drivers.  modopen and modclose are unchanged
from the null module example shown in Overview of Modules and Drivers.  modrput is like modput from
the null module.

Note that, in contrast to the null module example, a single module_info structure is shared by the
read-side and write-side.  The module_info includes the flow control high and low water marks (512
and 128) for the write queue.  (Though the same module_info is used on the read queue side, the
read-side has no @command{service} procedure so flow control is not used.) The qinit contains the
@command{service}
procedure pointer.

The write-side @command{put} procedure, the beginning of the @command{service} procedure, and an example of flushing a
queue are shown next:

@smallexample
static int
modwput(q, mp)
        queue_t *q;
        register mblk_t *mp;
@{
    if (mp->b_datap->db_type >= QPCTL && mp->b_datap - &gt; db_type != M_FLUSH)
        putnext(q, mp);
    else
        putq(q, mp);            /* Put it on the queue */
@}

static int
modwsrv(q)
        queue_t *q;
@{
    mblk_t *mp;

    while ((mp = getq(q)) != NULL) @{
        switch (mp->b_datap->db_type) @{
        default:
            if (canput(q->q_next)) @{
                putnext(q, mp);
                break;
            @} else @{
                putbq(q, mp);
                return;
            @}

        case M_FLUSH:
            if (*mp->b_rptr & FLUSHW)
                flushq(q, FLUSHDATA);
            putnext(q, mp);
            break;
@end smallexample

modwput, the write @command{put} procedure, switches on the message type.  High priority messages
that are not type M_FLUSH are putnext to avoid scheduling.  The others are queued for the
@command{service} procedure.  An M_FLUSH message is a request to remove messages on one or both
queues.  It can be processed in the @command{put} or @command{service} procedure.

modwsrv is the write @command{service} procedure.  It takes a single argument, a pointer to the
write queue.  modwsrv processes only one high priority message, M_FLUSH.  No other high priority
messages should reach modwsrv.

For an M_FLUSH message, modwsrv checks the first data byte.  If FLUSHW (defined in sys/stropts.h) is
set, the write queue is flushed by use of the flushq() utility (see @dfn{STREAMS} Utilities).
flushq() takes two arguments, the queue pointer and a flag.  The flag indicates what should be
flushed, data messages (FLUSHDATA) or everything (FLUSHALL).  In the example, data includes M_DATA,
M_DELAY, M_PROTO, and M_PCPROTO messages.  The choice of what types of messages to flush is module
specific.

Ordinary messages will be returned to the queue if

canput(q->q_next)

returns false, indicating the downstream path is blocked.  The example continues with the remaining
part of modwsrv processing M_DATA messages:

@smallexample
        case M_DATA:@{
            mblk_t *nbp = NULL;
            mblk_t *next;

            if (!canput(q->q_next)) @{
                putbq(q, mp);
                return;
            @}
            /* Filter data, appending to queue */
            for (; mp != NULL; mp = next) @{
                while (mp->b_rptr < mp->b_wptr) @{
                    if (*mp->b_rptr == '\n') @{
                        if (!bappend(&nbp, '\r'))
                            goto push;
                        if (!bappend(&nbp, *mp->b_rptr))
                            goto push;
                        mb->b_rptr++;
                        continue;
                    @}
                  push:
                    if (nbp)
                        putnext(q, nbp);
                    nbp = NULL;
                    if (!canput(q->q_next)) @{
                        if (mp->b_rptr >= mp->b_wptr) @{
                            next = mp->b_cont;
                            freeb(mp);
                            mp = next;
                        @}
                        if (mp)
                            putbq(q, mp);
                        return;
                    @}
                @}               /* while */
                next = mp->b_cont;
                freeb(mp);
            @}                   /* for */
            if (nbp)
                putnext(q, nbp);
        @}                       /* case M_DATA */
        @}                       /* switsh */
    @}                           /* while */
@}
@end smallexample

The differences in M_DATA processing between this and the example in Messages (see [7]4.5 "
[8]Message Allocation and Freeing ") relate to the manner in which the new messages are forwarded
and flow controlled.  For the purpose of demonstrating alternative means of processing messages,
this version creates individual new messages rather than a single message containing multiple
message blocks.  When a new message block is full, it is immediately forwarded with the putnext()
routine rather than being linked into a single, large message (as was done in the Messages example).
This alternative may not be desirable because message boundaries will be altered and because of the
additional overhead of handling and scheduling multiple messages.

When the filter processing is performed (following push), flow control is checked [with canput()]
after, rather than before, each new message is forwarded.  This is done because there is no
provision to hold the new message until the queue becomes unblocked.  If the downstream path is
blocked, the remaining part of the original message is returned to the queue.  Otherwise, processing
continues.

@node Module Flow Control
@section Module Flow Control

To utilize the @dfn{STREAMS} flow control mechanism, modules must use @command{service} procedures,
invoke canput() before calling putnext(), and use appropriate values for the high and low water
marks.

Module flow control limits the amount of data that can be placed on a queue.  It prevents depletion
of buffers in the buffer pool.  Flow control is advisory in nature and it can be bypassed.  It is
managed by high and low water marks and regulated by QWANTW and QFULL flags.  Module flow control is
implemented by using the canput(), getq(), putq(), putbq(), insq(), and rmvq() routines.

The following scenario takes place normally in flow control when a module and driver are in sync:

@itemize @bullet
@item  A driver sends data to a module using the putnext() routine, and the module's @command{put}
procedure queues data using putq().  The putq() routine then increments the module's q_count by the
number of bytes in the message and enables the @command{service} procedure.  When @dfn{STREAMS}
scheduling runs the @command{service} procedure, the @command{service} procedure then retrieves the
data by calling the getq() utility, and getq() decrements q_count by an appropriate value.
@end itemize

If the module cannot process data at the rate at which the driver is sending the data, the following
happens:

@itemize
@item The module's q_count goes above its high water mark, and the QFULL flag isset by putq().  The
driver's canput() fails, and canput() sets QWANTW flag in the module's queue.  The driver may send a
command to the device to stop input, queue the data in its own queue, or drop the data.  In the
meanwhile, the module's q_count falls below its low water mark [by getq()] and getq() finds the
nearest back queue with a @command{service} procedure and enables it.  The scheduler then runs the
@command{service} procedure.
@end itemize

The next two examples show a line discipline module's flow control.  The first example is a
read-side line discipline module:

@smallexample
/* read- side line discipline module flow control */

id_read_srv(q)
        queue_t *q;             /* pointer to read queue */
@{
    mblk_t *mp;                 /* original message */
    mblk_t *bp;                 /* canonicalized message */

    while ((mp = getq(q)) != NULL) @{
        switch (mp->b_datap->db_type) @{ /* type of message */
        case M_DATA:            /* data message */
            if (canput(q->q_next)) @{
                bp = read_canon(mp);
                putnext(q, bp);
            @} else @{
                putbq(q, mp);   /* put message back in queue */
                return;
            @}
            break;
        default:
            if (mp->b_datap->db_type >= QPCTL)
                putnext(q, mp); /* high priority message */
            else @{              /* ordinary message */
                if (canput(q->q_next))
                    putnext(q, mp);
                else @{
                    putbq(q, mp);
                    return;
                @}
            @}
            break;
        @}
    @}
@}
@end smallexample

The following shows a write-side line discipline module:

@smallexample
/* write-side line discipline module flow control */

id_write_srv(q)
        queue_t *q;             /* pointer to write queue */
@{
    mblk_t *mp;                 /* original message */
    mblk_t *bp;                 /* canonicalized message */

    while ((mp = getq(q)) != NULL) @{
        switch (mp->b_datap->db_type) @{ /* type of message */
        case M_DATA:            /* data message */
            if (canput(q->q_next)) @{
                bp = write_canon(mp);
                putnext(q, bp);
            @} else @{
                putbq(q, mp);
                return;
            @}
            break;

        case M_IOCTL:
            ld ioctl(q, mp);
            break;

        default:
            if (mp->b_datap->db_type >= QPCTL)
                putnext(q, mp); /* high priority message */
            else @{              /* ordinary message */
                if (canput(q->q_next))
                    putnext(q, mp);
                else @{
                    putbq(q, mp);
                    return;
                @}
            @}
            break;
        @}
    @}
@}
@end smallexample

@node Module Design Guidelines
@section Module Design Guidelines

Module developers should follow these guidelines:

@itemize @bullet

@item Messages types that are not understood by the modules should be passed to the nextmodule.

@item The module that acts on an M_IOCTL message should send an M_IOCACK or M_IOCNAK message in
response to the @command{ioctl}.  If the module does not understand the @command{ioctl}, it should pass the M_IOCTL
message to the next module.

@item Modules should be designed in such way that they don't pertain to any particular driver but
can be used by all drivers.

@item In general, modules should not require the data in an M_DATA message to follow a particular
format, such as a specific alignment.  This makes it easier to arbitrarily push modules on top of
each other in a sensible fashion.  Not following this rule may limit module reusability.

@item Filter modules pushed between a service user and a service provider may not alter the contents
of the M_PROTO or M_PCPROTO block in messages.  The contents of the data blocks may be manipulated,
but the message boundaries must be preserved.

@end itemize

Also see [6]6.5 " [7]Design Guidelines " in [8]Chapter 6 [9]Overview of Modules and Drivers .

@node STREAMS Drivers
@chapter STREAMS Drivers
@cindex STREAMS drivers
@menu
* Drivers::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines
@end menu

@node Drivers
@section Drivers

This chapter describes the operation of a @dfn{STREAMS} driver and also discusses some of the
processing typically required in drivers.

Unlike a module, a device driver must have an interrupt routine so that it is accessible from a
hardware interrupt as well as from the @dfn{Stream}.  A driver can have multiple @dfn{Streams}
connected to it.  Multiple connections occur when more than one minor device of the same driver is
in use and in the case of multiplexors (multiplexing is discussed in Multiplexing).  However, these
particular differences are not recognized by the @dfn{STREAMS} mechanism.  They are handled by
developer-provided code included in the driver procedures.

@subsection Overview of Drivers

This section provides a brief overview of the UNIX|Pr system drivers.  This is not an all-inclusive
description, but an introduction and general information on drivers.  |Pr system drivers.  This is
not an all-inclusive description, but an introduction and general information on drivers.

A driver is software that provides an interface between the operating system and a device.  The
driver controls the device in response to kernel commands, and user-level programs access the device
through system calls.  The system calls interface with the file system and process control system,
which in turn access the drivers.  The driver provides and manages a path for the data to and from
the hardware device, and services interrupts issued by the device controller.

@subsubsection Driver Classification

In general, drivers are grouped according to the type of the device they control, the access method
(the way data are transferred), and the interface between the driver and the device.

The type can be hardware or software.  A hardware driver controls a physical device such as a disk.
A software driver, also called a pseudo device, controls software, which in turn may interface with
a hardware device.  The software driver may also support pseudo devices that have no associated
physical device.

Drivers can be character-type or block-type, but many support both access methods.  In
character-type transfer, data are read a character at a time or as a variable length stream of
bytes, the size of which is determined by the device.  In block-type access, data transfer is
performed on fixed-length blocks of data.  Devices that support both block- and character-type
access must have a separate special device file for each access method.  Character access devices
can also use "raw" (also called unbuffered) data transfer that takes place directly between user
address space and the device.  Unbuffered data transfer is used mainly for administrative functions
where the speed of the specific operation is more important than overall system performance.

The driver interface refers to the system structures and kernel interfaces used by the driver.  For
example, @dfn{STREAMS} is an interface.

@subsubsection Driver Configuration

For a driver to be recognized as part of the system, information on driver type, where object code
resides, interrupts, and so on, must be stored in appropriate files.

The following summarizes information needed to include a driver in the system (this information is
unique to the AT&T 3B2):

@ftable @file

@item /etc/master.d
A master file supplies information to the system initialization software to describe different
attributes of a driver.  There is one master file for each driver in the system.

@item /dev
This directory contains special files that provide applications with a way to access drivers via
file operators.

@end ftable

@subsubsection Writing a Driver

All drivers are identified by a string of called the prefix.  The prefix is defined in the master
file for the driver and is added to the name of the driver routines.  For example, the open routine
for the driver with the "xyz" prefix is xyzopen.

Writing a driver differs from writing other C programs in the following ways:

@itemize @bullet

@item  A driver does not have a main.c routine.Rather, driver entry points are given specific names
and accessed through switch tables.

@item  A driver functions as a part of the kernel.  Consequently, a poorly written driver can
degrade system performance or corrupt the system.

@item  A driver cannot use system calls or the C library, because the driver functions at a lower
level.

@item  A driver cannot use floating point arithmetic.  A driver cannot use archives or shared
libraries,

@item  but frequently used subroutines can be put in separate files in the source code directory for
the driver.

@end itemize

Driver code, like other system software, uses the advanced C language capabilities.  These include:
bit manipulation capabilities, casting of data types, and use of header files for defining and
declaring global data structures.

Driver code includes a set of entry point routines:

@itemize @bullet

@item initialization entry points that are accessed through arrays during system initialization.

@item switch table entry points that are accessed through bdevsw (block- access) and cdevsw
(character-access) switch tables when the appropriate system call is issued.

@end itemize

The following lists rules of driver development:

@itemize @bullet

@item All drivers must have an associated file in the master.d directory.

@item All drivers should have system header files that define data structures used in the driver.

@item Drivers may have an init and/or astart routine to initialize the driver.  Software drivers
will usually have little to initialize, because there is no hardware involved.  An init routine is
used when a driver needs to initialize but does not need any system services.  init routines are run
before system services are initialized.  When a driver needs to do initialization that requires
system services, a start routine is used.  The start routines are run after system services have
been initialized.

@item Drivers will have open and close routines.  Most drivers will have an interrupt handler
routine.  The driver developer is responsible for supplying an interrupt routine for the device's
driver.  The @cite{UNIX} system provides a few interrupt handling routines for hardware interrupts, but the
developer has to supply the specifics about the device.  In general, a prefixint interrupt routine
should be written for any device that does not send separate transmit and receive interrupts.  TTY
devices that request separate transmit and receive interrupts can have two separate interrupt
routines associated with them; prefixxinit to transmit an interrupt, and prefixrint to receive an
interrupt.

@item Most drivers will have static subordinate driver routines to provide the functionality for the
specific device.  The names of these routines should include the driver prefix, although this is not
absolutely required since the routine is declared as static.

@item A bootable object file and special device files are also needed for a driver to be fully
functional.

@end itemize

@subsubsection Major and Minor Device Numbers

The @cite{UNIX System V} operating system identifies and accesses peripheral devices by major and
minor numbers.  When a driver is installed and a special device file is created, a device then
appears to the user application as a file.  A device is accessed by opening, reading, writing, and
closing a special device file that has the proper major and minor device numbers.

The major number identifies a driver for a controller.  The minor number identifies a specific
device.  Major numbers are assigned sequentially by either the system initialization software at
boot time for hardware devices, by a program such as drvinstall, or by administrator direction.  The
major number for a software device is assigned automatically by the drvinstall command.  Minor
numbers are designated by the driver developer.

Major and minor numbers can be external or internal.

External major numbers are those visible to the user.

Internal major numbers serve as an index into the cdevsw and bdevsw switch tables.  These are
assigned by the autoconfiguration process when drivers are loaded and they may change every time a
full configuration boot is done.  The system uses the MAJOR table to translate external major
numbers to the internal major numbers needed to access the switch tables.

One driver may control several devices, but each device will have its own external major number and
all those external major numbers are mapped to one internal major number for the driver.

Minor numbers are determined differently for different types of devices.  Typically, minor numbers
are an encoding of information needed by the controller board.

External minor numbers are controlled by a driver developer, although there are conventions enforced
for some types of devices by some utilities.  For example, a tape drive may interface with a
hardware controller (device) to which several tape drives (subdevices) are attached.  All tape
drives attached to one controller will have the same external major number, but each drive will have
a different external minor number.

The MAJOR and MINOR tables map external major and minor numbers to the internal major number.  The
switch tables will have only as many entries as required to support the drivers installed on the
system.  Switch table entry points are activated by system calls that reference a special device
file that supplies the external major number and instructions on whether to use bdevsw or cdevsw.
By mapping the external major number to the corresponding internal major number in the MAJOR table,
the system knows which driver routine to activate.  The routines getmajor() and getminor() return an
internal major and minor number for the device.  The routines getemajor() and geteminor() return an
external major and minor number for the device.

@subsection STREAMS Drivers

At the interface to hardware devices, character I/O drivers have interrupt entry points; at the
system interface, those same drivers generally have direct entry points (routines) to process open,
close, read, write, poll, and @command{ioctl} system calls.

@dfn{STREAMS} device drivers have interrupt entry points at the hardware device interface and have
direct entry points only for the open and close system calls.  These entry points are accessed via
@dfn{STREAMS}, and the call formats differ from traditional character device drivers.
(@dfn{STREAMS} drivers are character drivers, too.  We call the non-@dfn{STREAMS} character drivers
traditional character drivers or non-@dfn{STREAMS} character drivers.) The @command{put} procedure
is a driver's third entry point, but it is a message (not system) interface.  The @dfn{Stream head}
translates write and @command{ioctl} calls into messages and sends them downstream to be processed
by the driver's write queue @command{put} procedure.  read is seen directly only by the @dfn{Stream
head}, which contains the functions required to process system calls.  A driver does not know about
system interfaces other than open and close, but it can detect the absence of a read indirectly if
flow control propagates from the @dfn{Stream head} to the driver and affects the driver's ability to
send messages upstream.

For input processing, when the driver is ready to send data or other information to a user process,
it does not wake up the process.  It prepares a message and sends it to the read queue of the
appropriate (minor device) @dfn{Stream}.  The driver's open routine generally stores the queue
address corresponding to this @dfn{Stream}.

For output processing, the driver receives messages in place of a write call.  If the message can
not be sent immediately to the hardware, it may be stored on the driver's write message queue.
Subsequent output interrupts can remove messages from this queue.

[7]Figure:8.1 [8]Device Driver @dfn{Streams} shows multiple @dfn{Streams} (corresponding to minor
devices) to a common driver.  There are two distinct @dfn{Streams} opened from the same major
device.  Consequently, they have the same streamtab and the same driver procedures.

The configuration mechanism distinguishes between @dfn{STREAMS} devices and traditional character
devices, because system calls to @dfn{STREAMS} drivers are processed by @dfn{STREAMS} routines, not
by the @cite{UNIX} system driver routines.  In the cdevsw file, the field d_str provides this
distinction.  See Configuration for details.

Multiple instantiations (minor devices) of the same driver are handled during the initial open for
each device.  Typically, the queue address is stored in a driver-private structure array indexed by
the minor device number.  This is for use by the interrupt routine which needs to translate from
device number to a particular @dfn{Stream}.  The q_ptr of the queue will point to the private data
structure entry.  When the messages are received by the queue, the calls to the driver @command{put} and
@command{service} procedures pass the address of the queue, allowing the procedures to determine the
associated device.

A driver is at the end of a @dfn{Stream}.  As a result, drivers must include standard processing for
certain message types that a module might simply be able to pass to the next component.

[Boxnote.gif]

During the open and close routine the kernel locks the device snode.  Thus only one open or close
can be active at a time per major/minor device pair.

[Figure:8.1 Device Driver @dfn{Streams}]

[strm.devdvi.gif]

@subsubsection Printer Driver Example

The next example shows how a simple interrupt-per-character line printer driver could be written.
The driver is unidirectional and has no read-side processing.  It demonstrates some differences
between module and driver programming, including the following:

@table @asis

@item Open handling
A driver is passed a device number or is asked to select one.

@item Flush handling
A driver must loop M_FLUSH messages back upstream.

@item @command{ioctl} handling
A driver must send a negative acknowledgement for @command{ioctl} messages it does not understand.
This is discussed under [8]6.2 " [9]Module and Driver ioctls " in Overview of Modules and Drivers.

@end table

@subsubheading Declarations

The driver declarations are as follows (see also "Module and Driver Declarations" in [10]Chapter 6
[11]Overview of Modules and Drivers ):

@smallexample
/* Simple line printer driver */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/dir.h>            /* required for user.h */
#include <sys/signal.h>         /* required for user.h */
#include <sys/user.h>
#include <sys/errno.h>
#include <sys/cred.h>
#include <sys/ddi.h>

static struct module_info minfo = @{
    0xaabb, "lp", 0, INFPSZ, 150, 50
@};

static int lpopen(), lpclose(), lpwput();

static struct qinit rinit = @{
    NULL, NULL, lpopen, lpclose, NULL, &minfo, NULL
@};

static struct qinit winit = @{
    lpwput, NULL, NULL, NULL, NULL, &minfo, NULL
@};

struct streamtab lpinfo = @{ &rinit, &winit, NULL, NULL @};

#define SET_OPTIONS (('1'<<8)|1)        /* should be in a .  h file */

/* This is a private data structure, one per minor device number.  */

struct lp @{
    short flags;                /* flags -- see below */
    mblk_t *msg;                /* current message being output */
    queue_t *qptr;              /* back pointer to write queue */
@};

/* Flags bits */
#define BUSY 1                  /* device is running and interrupt is pending */

extern struct lp lp_lp[];       /* per device lp structure array */
extern int lp_cnt;              /* number of valid minor devices */
int lpdevflag = 0;
@end smallexample

Configuring a @dfn{STREAMS} driver requires only the streamtab structure to be externally accessible.  All
other @dfn{STREAMS} driver procedures would typically be declared static.

The streamtab structure must be defined as prefixinfo, where prefix is the value of the prefix field
in the master file for this driver.  The values in the module name and ID fields in the module_info
structure should be unique in the system.  Note that, as in character I/O drivers, extern variables
are assigned values in the master file when configuring drivers or modules.

There is no read-side @command{put} or @command{service} procedure.  The flow control limits for use on the write-side
are 50 bytes for the low water mark and 150 bytes for the high water mark.  The private lp structure
is indexed by the minor device number and contains these elements:

@table @var

@item flags
A set of flags.  Only one bit is used: BUSY indicates that output is active and a device interrupt
is pending.

@item msg
A pointer to the current message being output.

@item qptr
A back pointer to the write queue.  This is needed to find the write queue during interrupt
processing.

@end table

@subsubheading Driver Open

The @dfn{STREAMS} mechanism allows only one @dfn{Stream} per minor device.  The driver open routine
is called whenever a @dfn{STREAMS} device is opened.  Opening also allocates a private data
structure.  The driver open, lpopen in this example, has the same interface as the module open:

@smallexample
static int
lpopen(q, devp, flag, sflag, credp)
        queue_t *q;             /* read queue */
        dev_t *devp;
        int flag;
        int sflag;
        cred_t *credp;
@{
    struct lp *lp;
    dev_t device;

    if (sflag)                  /* check if non-driver open */
        return ENXIO;

    device = getminor(*devp);
    if (device >= lp_cnt)
        return ENXIO;

    if (q->q_ptr)               /* Check if open already.  q_ptr is assigned
                                   below */
        return EBUSY;

    lp = &lp_lp[device];
    lp->qptr = WR(q);
    q->q_ptr = (char *) lp;
    WR(q)->q_ptr = (char *) lp;
    return 0;
@}
@end smallexample

The @dfn{Stream} flag, sflag, must have the value 0, indicating a normal driver open.  devp is a
pointer to the major/minor device number for this port.  After checking sflag, the @dfn{STREAMS}
open flag, lpopen extracts the minor device pointed to by devp, using the getminor() function.
credp is a pointer to a credentials structure.

The minor device number selects a printer.  The device number pointed to by devp must be less than
lp_cnt, the number of configured printers.  Otherwise failure occurs.

The next check, if (q->q_ptr)..., determines if this printer is already open.  If it is, EBUSY is
returned to avoid merging printouts from multiple users.  q_ptr is a driver/module private data
pointer.  It can be used by the driver for any purpose and is initialized to zero by @dfn{STREAMS}.
In this example, the driver sets the value of q_ptr, in both the read and write queue structures, to
point to a private data structure for the minor device, lp_lp[device].

There are no physical pointers between queues.  WR is a queue pointer macro.  WR(q) generates the
write pointer from the read pointer.  RD and OTHER are also the queue pointer macros.  RD(q)
generates the read pointer from the write pointer, and OTHER(q) generates the mate pointer from
either.  With the DDI, WR, RD, and OTHER are functions.

@subsubheading Driver Flush Handling

The following write @command{put} procedure, lpwput, illustrates driver M_FLUSH handling.  NOTE that
all drivers are expected to incorporate flush handling.

If FLUSHW is set, the write message queue is flushed, and (in this example) the leading message
(lp->msg) is also flushed.  spl5 is used to protect the critical code, assuming the device
interrupts at level 5.

Normally, if FLUSHR is set, the read queue would be flushed.  However, in this example, no messages
are ever placed on the read queue, so it is not necessary to flush it.  The FLUSHW bit is cleared
and the message is sent upstream using qreply().  If FLUSHR is not set, the message is discarded.

The @dfn{Stream head} always performs the following actions on flush requests received on the
read-side from downstream.  If FLUSHR is set, messages waiting to be sent to user space are flushed.
If FLUSHW is set, the @dfn{Stream head} clears the FLUSHR bit and sends the M_FLUSH message
downstream.  In this manner, a single M_FLUSH message sent from the driver can reach all queues in a
@dfn{Stream}.  A module must send two M_FLUSH messages to have the same affect.

lpwput enqueues M_DATA and M_IOCTL messages and, if the device is not busy, starts output by calling
lpout.  Messages types that are not recognized are discarded.


@smallexample
static int
lpwput(q, mp)
        queue_t *q;             /* write queue */
        register mblk_t *mp;    /* message pointer */
@{
    register struct lp *lp;
    int s;

    lp = (struct lp *) q->q_ptr;
    switch (mp->b_datap->db_type) @{

    default:
        freemsg(mp);
        break;

    case M_FLUSH:               /* Canonical flush handing */
        if (*mp->b_rptr & FLUSHW) @{
            flushq(q, FLUSHDATA);
            s = sp15();         /* also flush lp->msg since it is logically *
                                   at the head of the write queue */
            if (lp->msg) @{
                freemsg(lp->msg);
                lp->msg = NULL;
            @}
            splx(s);
        @}
        if (*mp->b_rptr & FLUSHR) @{
            *mp->b_rptr &= ~FLUSHW;
            qreply(q, mp);
        @} else
            freemsg(mp);
        break;

    case M_IOCTL:

    case M_DATA:
        putq(q, mp);
        s = sp15();
        if (!(lp->flags & BUSY))
            lpout(lp);
        splx(s);
    @}
@}
@end smallexample

@subsubheading Driver Interrupt

The following example shows the interrupt routine in the printer driver.

lpint is the driver interrupt handler routine.

lpout simply takes a character from the queue and sends it to the printer.  For convenience, the
message currently being output is stored in lp->msg.

lpoutchar sends a character to the printer and interrupts when complete.  Printer interface options
need to be set before being able to print.

@smallexample
/* Device interrupt routine */

lpint(device)
        int device;             /* minor device nimber of lp */
@{
    register struct lp *lp;

    lp = &lp_lp[device];
    if (!(lp->flags & BUSY)) @{
        cmn_err(CE_WARN, "^lp: unexpected interrupt\n");
        return;
    @}
    lp->flag &= ~BUSY;
    lpout(lp);
@}

/* Start output to device - used by put procedure and driver */
lpout(lp)
        register struct lp *lp;
@{
    register mblk_t *bp;
    queue_t *q;

    q = lp->qptr;

  loop:
    if ((bp = lp->msg) == NULL) @{       /* no current message */
        if ((bp = getq(q)) == NULL) @{
            lp->flags &= NBUSY;
            return;
        @}
        if (bp->b_datap->db_type == M_IOCTL) @{
            lpdoioctl(lp, bp);
            goto loop;
        @}
        lp->msg = bp;           /* new message */

    @}
    if (bp->b_rptr >= bp->b_wptr) @{     /* validate message */
        bp = lp->msg->b_cont;
        lp->msg->b_cont = NULL;
        freeb(lp->msg);
        lp->msg = bp;
        goto loop;
    @}
    lpoutchar(lp, *bp->b_rptr++);       /* output one charactor */
    lp->flags |= BUSY;
@}
@end smallexample

@subsubheading Driver Close

The driver close routine is called by the @dfn{Stream head}.  Any messages left on the queue will be
automatically removed by @dfn{STREAMS}.  The @dfn{Stream} is dismantled and the data structures are
de-allocated.

@smallexample
static int
lpclose(q, flag, credp)
        queue_t *q;             /* read queue */
        int flag;
        cred_t *credp;
@{
    struct lp *lp;
    int s;

    lp = (struct lp *) q->q_ptr;

    /* Free message, queue is automatically flushed by STREAMS */

    s = sp15();
    if (lp->msg) @{
        freemsg(lp->msg);
        lp->msg = NULL;
    @}
    splx(s);
    lp->flags = 0;
@}
@end smallexample

@subsubsection Driver Flow Control

The same utilities (described in Modules) and mechanisms used for module flow control are used by
drivers.

When the message is queued, putq() increments the value of q_count by the size of the message and
compares the result against the driver's write high water limit (q_hiwat) value.  If the count
exceeds q_hiwat, the putq() utility routine will set the internal FULL indicator for the driver
write queue.  This will cause messages from upstream to be halted [canput() returns FALSE] until the
write queue count reaches q_lowat.  The driver messages waiting to be output are dequeued by the
driver output interrupt routine with getq(), which decrements the count.  If the resulting count is
below q_lowat, the getq() routine will back-enable any upstream queue that had been blocked.

Device drivers typically discard input when unable to send it to a user process.  However,
@dfn{STREAMS} allows flow control to be used on the driver read-side to handle temporary upstream
blocks.

To some extent, a driver or a module can control when its upstream transmission will become blocked.
Control is available through the M_SETOPTS message (see Message Types) to modify the @dfn{Stream
head} read-side flow control limits.

@node Cloning
@section Cloning

In many earlier examples, each user process connected a @dfn{Stream} to a driver by opening a
particular minor device of that driver.  Often, however, a user process wants to connect a new
@dfn{Stream} to a driver regardless of which minor device is used to access the driver.  In the
past, this typically forced the user process to poll the various minor device nodes of the driver
for an available minor device.  To alleviate this task, a facility called clone open is supported
for @dfn{STREAMS} drivers.  If a @dfn{STREAMS} driver is implemented as a cloneable device, a single
node in the file system may be opened to access any unused device that the driver controls.  This
special node guarantees that the user will be allocated a separate @dfn{Stream} to the driver on
every open call.  Each @dfn{Stream} will be associated with an unused major/minor device, so the
total number of @dfn{Streams} that may be connected to a particular cloneable driver is limited by
the number of minor devices configured for that driver.

The clone device may be useful, for example, in a networking environment where a protocol pseudo
device driver requires each user to open a separate @dfn{Stream} over which it will establish
communication.

[Boxnote.gif]

The decision to implement a @dfn{STREAMS} driver as a cloneable device is made by the designers of
the device driver.

Knowledge of clone driver implementation is not required to use it.  A description is presented here
for completeness and to assist developers who must implement their own clone driver.

There are two ways to create a clone device node in the file system.  The first is to have a node
with major number 63 (major of the clone driver) and with a minor number equal to the major number
of the real device one wants to open.  For example, /dev/starlan00 might be major 40, minor 0
(normal open), and /dev/starlan might be major 63, minor 40 (clone open).

The second way to create a clone device node is for the driver to designate a special minor device
as its clone entry point.  Here, /dev/starlan might be major 40, minor 0 (clone open).

The former example will cause sflag to be set to CLONEOPEN in the open routine when /dev/starlan is
opened.  The latter will not.  Instead, in the latter case the driver has decided to designate a
special minor device as its clone interface.  When the clone is opened, the driver knows that it
should look for an unused minor device.  This implies that the reserved minor for the clone entry
point will never be given out.

In either case, the driver returns the new device number as:

*devp = makedevice(getmajor(*devp), newminor)

[Boxnote.gif]

makedevice is unique to the DDI interface.  If the DDI interface is not used, makedev can be used
instead of makedevice.

@node Loop-Around Driver
@section Loop-Around Driver

The loop-around driver is a pseudo driver that loops data from one open @dfn{Stream} to another open
@dfn{Stream}.  The user processes see the associated files almost like a full-duplex pipe.  The
@dfn{Streams} are not physically linked.  The driver is a simple multiplexor that passes messages
from one @dfn{Stream}'s write queue to the other @dfn{Stream}'s read queue.

To create a connection, a process opens two @dfn{Streams}, obtains the minor device number
associated with one of the returned file descriptors, and sends the device number in an I_STR
@manpage{ioctl(2)} to the other @dfn{Stream}.  For each open, the driver open places the passed
queue pointer in a driver interconnection table, indexed by the device number.  When the driver
later receives the I_STR as an M_IOCTL message, it uses the device number to locate the other
@dfn{Stream}'s interconnection table entry, and stores the appropriate queue pointers in both of the
@dfn{Streams}' interconnection table entries.

Subsequently, when messages other than M_IOCTL or M_FLUSH are received by the driver on either
@dfn{Stream}'s write-side, the messages are switched to the read queue following the driver on the
other @dfn{Stream}'s read-side.  The resultant logical connection is shown in [6]Figure:8.2
[7]Loop-Around @dfn{Streams} (in the figure, the abbreviation QP represents a queue pair).  Flow
control between the two @dfn{Streams} must be handled by special code since @dfn{STREAMS} will not
automatically propagate flow control information between two @dfn{Streams} that are not physically
interconnected.

[Figure:8.2 Loop-Around @dfn{Streams}]

[strm.retstm.gif]

The next example shows the loop-around driver code.  A master file to configure the loop driver is
shown in Configuration.  The loop structure contains the interconnection information for a pair of
@dfn{Streams}.  loop_loop is indexed by the minor device number.  When a @dfn{Stream} is opened to
the driver, the address of the corresponding loop_loop element is placed in q_ptr (private data
structure pointer) of the read-side and write-side queues.  Since @dfn{STREAMS} clears q_ptr when
the queue is allocated, a NULL value of q_ptr indicates an initial open.  loop_loop is used to
verify that this @dfn{Stream} is connected to another open @dfn{Stream}.

The declarations for the driver are:

@smallexample
/* Loop-around driver */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/stream.h>
#include <sys/stropts.h>
#include <sys/dir.h>
#include <sys/signal.h>
#include <sys/user.h>
#include <sys/errno.h>
#include <sys/cred.h>
#include <sys/ddi.h>

static struct module_info minfo = @{
    0xee12, "loop", 0, INFPSZ, 512, 128
@};

static int loopopen(), loopclose(), loopwput(), loopwsrv(), looprsrv();

static struct qinit rinit = @{
    NULL, looprsrv, loopopen, loopclose, NULL, &minfo, NULL
@};
static struct qinit winit = @{
    loopwput, loopwsrv, NULL, NULL, NULL, &minfo, NULL
@};

struct streamtab loopinfo = @{ &rinit, &winit, NULL, NULL @};

struct loop @{
    queue_t *qptr;              /* back pointer to write queue */
    queue_t *oqptr;             /* pointer to connected read queue */
@}
#define LOOP_SET (('1'<<8|1)    /* should be in a .  h file */
extern struct loop loop_loop[];
extern int loop_cnt;
int loopdevflag = 0;
@end smallexample

The open procedure includes canonical clone processing which enables a single file system node to
yield a new minor device/vnode each time the driver is opened:

@smallexample
static int
loopopen(q, devp, flag, sflag, credp)
        queue_t *q;
        dev_t *devp;
        int flag;
        int sflag;
        cred_t *credp;
@{
    struct loop *loop;

    dev_t newminor;

    /* 
     * If CLONEOPEN, pick a minor device number to use.
     * Otherwise, check the minor device range.
     */
    if (sflag == CLONEOPEN) @{
        for (newminor = 0; newminor < loop_cnt; newminor++) @{
            if (loop_loop[newminor].qptr == NULL)
                break;
        @}
    @} else
        newminor = getminor(*devp);

    if (newminor >= loop_cnt)
        return ENXIO;
    /* construct new device number and reset devp */

    /* getmajor gets the external major number, if (sflag == CLONEOPEN) */

    if (q->q_ptr)               /* already open */
        return 0;

    *devp = makedev(getemajor(*devp), newminor);
    loop = &loop_loop[newminor];
    WR(q)->q_ptr = (char *) loop;
    q->q_ptr = (char *) loop;
    loop->qptr = WR(q);
    loop->oqptr = NULL;

    return 0;
@}
@end smallexample

In loopopen, sflag can be CLONEOPEN, indicating that the driver should pick an unused minor device
(i.e., the user does not care which minor device is used).  In this case, the driver scans its
private loop_loop data structure to find an unused minor device number.  If sflag has not been set
to CLONEOPEN, the passed-in minor device specified by getminor->(*devp) is used.

Since the messages are switched to the read queue following the other @dfn{Stream}'s read-side, the driver
needs a @command{put} procedure only on its write-side:

@smallexample
static int
loopwput(q, mp)
        queue_t *q;
        mblk_t *mp;
@{
    register struct loop *loop;

    loop = (struct loop *) q->q_ptr;

    switch (mp->b_datap->db_type) @{
    case M_IOCTL:@{
        struct iocblk *iocp;
        int error;

        iocp = (struct iocblk *) mp->b_rptr;
        switch (iocp->ioc_cmd) @{
        case LOOP_SET:@{
            int to              /* other minor device */
                /* 
                 * Sanity check.  ioc_count contains the amount of
                 * user supplied data which must equal the size of an int.
                 */
            if (iocp->ioc_count != sizeof(int)) @{
                error = EINVAL;
                goto iocnak;
            @}
            /* fetch other dev from 2nd message block */
            to = *(int *) mp->b_cont->b_rptr;
            /* 
             * More sanity checks.  The minor must be in range, open already.
             * Also, this device and the other one nust be disconnected.
             */

            if (to >= loop_cnt || to < 0 || !loop_loop[to].qptr) @{
                error = ENXIO;
                goto iocnak;
            @}
            if (loop->oqptr || loop_loop[to].oqptr) @{
                error = EBUSY;
                goto iocnak;
            @}
            /* Cross connect streams via the loop structures */
            loop->oqptr = RD(loop_loop[to].qptr);
            loop_loop[to].oqptr = RD(q);
            /* 
             * Return successful ioctl.  Set ioc_count
             * to zero, since no data are returned.
             */

            mp->b_datap->db_type = M_IOCACK;
            iocp->ioc_count = 0;
            qreply(q, mp);
            break;
        @}

        default:
            error = EINVAL;
          iocnak:
            /* 
             * Bad ioctl.  Setting ioc_error causes the
             * ioctl call to return that particular errno.
             * By default, ioctl will return EINVAL on failure
             */
            mp->b_datap->db_type = M_IOCNAK;
            iocp->ioc_error = error;    /* set returned errno */
            qreply(q, mp);

        @}
        break;
    @}
@end smallexample

loopwput shows another use of an I_STR @command{ioctl} call (see [8]Chapter 6 [9]Overview of Modules and
Drivers , "Module and Driver ioctls").  The driver supports a LOOP_SET value of ioc_cmd in the
iocblk of the M_IOCTL message.  LOOP_SET instructs the driver to connect the current open
@dfn{Stream} to
the @dfn{Stream} indicated in the message.  The second block of the M_IOCTL message holds an integer that
specifies the minor device number of the @dfn{Stream} to connect to.

The driver performs several sanity checks: Does the second block have the proper amount of data? Is
the "to" device in range? Is the "to" device open? Is the current @dfn{Stream} disconnected? Is the "to"
@dfn{Stream} disconnected?

If everything checks out, the read queue pointers for the two @dfn{Streams} are stored in the respective
oqptr fields.  This cross-connects the two @dfn{Streams} indirectly, via loop_loop.

Canonical flush handling is incorporated in the @command{put} procedure:

@smallexample
    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW) @{
            flushq(q, FLUSHALL);        /* write */
            flushq(loop->optr, FLUSHALL);
            /* read on other side equals write on this side */
        @}
        if (*mp->b_rptr & FLUSHR) @{
            flushq(RD(q), FLUSHALL);
            flushq(WR(loop->oqptr), FLUSHALL);
        @}
        switch (*mp->b_rptr) @{

        case FLUSHW:
            *mp->b_rptr = FLUSHR;
            break;

        case FLUSHR:
          *mp->b_rptr = FLUSHW:
            break;
        @}
        putnext(loop->oqptr, mp);
        break;

    default:
        /* If this Stream isn't connected, send M_ERROR upstream.  */
        if (loop->oqptr == NULL) @{
            freemsg(mp);
            putctl1(RD(q)->q_next, M_ERROR, ENXIO);
            break;
        @}
        putq(q, mp);
    @}
@}
@end smallexample

Finally, loopwput enqueues all other messages (e.g., M_DATA or M_PROTO) for processing by its
@command{service} procedure.  A check is made to see if the @dfn{Stream} is connected.  If not, an
M_ERROR is sent upstream to the @dfn{Stream head}.

Certain message types can be sent upstream by drivers and modules to the @dfn{Stream head} where
they are translated into actions detectable by user process(es).  The messages may also modify the
state of the @dfn{Stream head}:

@table @var

@item M_ERROR
Causes the @dfn{Stream head} to lock up.  Message transmission between @dfn{Stream} and user
processes is terminated.  All subsequent system calls except close(2) and poll(2) will fail.  Also
causes an M_FLUSH clearing all message queues to be sent downstream by the @dfn{Stream head}.

@item M_HANGUP
Terminates input from a user process to the @dfn{Stream}.  All subsequent system calls that would
send messages downstream will fail.  Once the @dfn{Stream head} read message queue is empty, EOF is
returned on reads.  Can also result in the SIGHUP signal being sent to the process group.

@item M_SIG/M_PCSIG
Causes a specified signal to be sent to a process.

@end table

putctl1() and putctl() are utilities that allocate a non-data (i.e., not M_DATA, M_DELAY, M_PROTO,
or M_PCPROTO) type message, place one byte in the message (for putctl1) and call the @command{put}
procedure of the specified queue.

Service procedures are required in this example on both the write-side and read-side for flow
control:

@smallexample
static int
loopwsrv(q)
        register queue_t *q;
@{
    mblk_t *mp;
    register struct loop *loop;

    loop = (struct loop *) q->q_ptr;

    while ((mp = getq(q)) != NULL) @{

        /* Check if we can put the message up the other Stream read queue */

        if (mp->b_datap->db_type <= QPCTL && !canput(loop->oqptr->q_next)) @{
            putbq(q, mp);       /* read-side is blocked */
            break;
        @}
        /* send message */

        putnext(loop->oqptr, mp);       /* To queue following other Stream read 
                                           queue */
    @}
@}

static int
looprsrv(q)
        queue_t *q;
@{
    /* Enter only when "back enabled" by flow control */

    struct loop *loop;

    loop = (struct loop *) q->q_ptr;
    if (loop->oqptr == NULL)
        return;

    /* manually enable write service procedure */

    qenable(WR(loop->oqptr));
@}
@end smallexample

The write @command{service} procedure, loopwsrv, takes on the canonical form.  The queue being
written to is not downstream, but upstream (found via oqptr) on the other @dfn{Stream}.

In this case, there is no read-side @command{put} procedure so the read @command{service} procedure,
looprsrv, is not scheduled by an associated @command{put} procedure, as has been done previously.
looprsrv is scheduled only by being back enabled when its upstream becomes unstuck from flow control
blockage.  The purpose of the procedure is to re-enable the writer (loopwsrv) by using oqptr to find
the related queue.  loopwsrv can not be directly back-enabled by @dfn{STREAMS} because there is no
direct queue linkage between the two @dfn{Streams}.  Note that no message ever gets queued to the
read @command{service} procedure.  Messages are kept on the write-side so that flow control can
propagate up to the @dfn{Stream head}.  The qenable() routine schedules the write-side
@command{service} procedure of the other @dfn{Stream}.

loopclose breaks the connection between the @dfn{Streams}:

@smallexample
static int
loopclose(q, flag, credp)
        queue_t *q;
        int flag;
        cred_t *credp;
@{
    register struct loop *loop;

    loop = (struct loop *) q->q_ptr;
    loop->qptr = NULL;

    /* If we are connected to another stream, break the linkage, and send a
       hangup message. The hangup message causes the stream head to fail
       writes, allow the queued data to be read completely, and then return EOF 
       on subsequent reads. */
    if (loop->oqptr) @{
        ((struct loop *) loop->oqptr->q_ptr)->oqptr = NULL;
        putctl(loop->oqptr->q_next, M_HANGUP);
        loop->oqptr = NULL;
    @}
@}
@end smallexample

loopclose sends an M_HANGUP message up the connected @dfn{Stream} to the @dfn{Stream head}.

[Boxnote.gif]

This driver can be implemented much more cleanly by actually linking the q_next pointers of the
queue pairs of the two @dfn{Streams}.

@node Driver Design Guidelines
@section Driver Design Guidelines

Driver developers should follow these guidelines:

@itemize @bullet

@item Messages that are not understood by the drivers should be freed.

@item A driver must process an M_IOCTL message.  Otherwise, the @dfn{Stream head} will block for an
M_IOCNAK or M_IOCACK until the timeout (potentially infinite) expires.

@item If a driver does not understand an @command{ioctl}, an M_IOCNAK message must be sent to upstream.

@item Terminal drivers must always acknowledge the EUC ioctls whether they understand them or not.

@item The @dfn{Stream head} locks up the @dfn{Stream} when it receives an M_ERROR message, so driver developers
should be careful when using the M_ERROR message.

@item If a driver wants to allocate a controlling terminal, it should send an M_SETOPTS message with
the SO_ISTTY flag set upstream.

@item A driver must be a part of the kernel for it to be opened.

@end itemize

Also see [6]6.5 " [7]Design Guidelines " in [8]Chapter 6 [9]Overview of Modules and Drivers .

@node STREAMS Multiplexing
@chapter STREAMS Multiplexing
@cindex STREAMS multiplexing
@menu
* Multiplexing::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexor Connect and Disconnect Lower Stream
* Multiplexor Construction Example::
				STREAMS Multiplexor Construction Example
* Mulxiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexor Persistent Links
* Multiplexor Design Guidelines::
				STREAMS Multiplexor Design Guidlines
@end menu

@node Multiplexing
@section Multiplexing

This chapter describes how @dfn{STREAMS} multiplexing configurations are created and also discusses
multiplexing drivers.  A @dfn{STREAMS} multiplexor is a driver with multiple @dfn{Streams} connected
to it.  The primary function of the multiplexing driver is to switch messages among the connected
@dfn{Streams}.  Multiplexor configurations are created from user level by system calls.

@dfn{STREAMS} related system calls are used to set up the "plumbing," or @dfn{Stream}
interconnections, for multiplexing drivers.  The subset of these calls that allows a user to connect
(and disconnect) @dfn{Streams} below a driver is referred to as the multiplexing facility.  This
type of connection is referred to as a 1-to-M, or lower, multiplexor configuration.  This
configuration must always contain a multiplexing driver, which is recognized by @dfn{STREAMS} as
having special characteristics.

Multiple @dfn{Streams} can be connected above a driver by use of open(2) calls.  This was done for
the loop around driver and for the driver handling multiple minor devices in Drivers.  There is no
difference between the connections to these drivers, only the functions performed by the driver are
different.  In the multiplexing case, the driver routes data between multiple @dfn{Streams}.  In the
device driver case, the driver routes data between user processes and associated physical ports.
Multiplexing with @dfn{Streams} connected above is referred to as an N-to-1, or upper, multiplexor.
@dfn{STREAMS} does not provide any facilities beyond open(2) and close(2) to connect or disconnect
upper @dfn{Streams} for multiplexing purposes.

From the driver's perspective, upper and lower configurations differ only in the way they are
initially connected to the driver.  The implementation requirements are the same: route the data and
handle flow control.  All multiplexor drivers require special developer-provided software to perform
the multiplexing data routing and to handle flow control.  @dfn{STREAMS} does not directly support
flow control among multiplexed @dfn{Streams}.

M-to-N multiplexing configurations are implemented by using both of the above mechanisms in a
driver.

As discussed in Drivers, the multiple @dfn{Streams} that represent minor devices are actually
distinct @dfn{Streams} in which the driver keeps track of each @dfn{Stream} attached to it.  The
@dfn{STREAMS} subsystem does not recognize any relationship between the @dfn{Streams}.  The same is
true for @dfn{STREAMS} multiplexors of any configuration.  The multiplexed @dfn{Streams} are
distinct and the driver must be implemented to do most of the work.

In addition to upper and lower multiplexors, more complex configurations can be created by
connecting @dfn{Streams} containing multiplexors to other multiplexor drivers.  With such a
diversity of needs for multiplexors, it is not possible to provide general purpose multiplexor
drivers.  Rather, @dfn{STREAMS} provides a general purpose multiplexing facility.  The facility
allows users to set up the inter-module/driver plumbing to create multiplexor configurations of
generally unlimited interconnection.

@subsection Building a Multiplexor

This section builds a protocol multiplexor with the multiplexing configuration shown in
[7]Figure:9.1 [8]Protocol Multiplexor .  To free users from the need to know about the underlying
protocol structure, a user-level daemon process will be built to maintain the multiplexing
configuration.  Users can then access the transport protocol directly by opening the transport
protocol (TP) driver device node.

An internetworking protocol driver (IP) routes data from a single upper @dfn{Stream} to one of two
lower @dfn{Streams}.  This driver supports two @dfn{STREAMS} connection beneath it.  These
connections are to two distinct networks; one for the IEEE 802.3 standard via the 802.3 driver, and
other to the IEEE 802.4 standard via the 802.4 driver.  The TP driver multiplexes upper
@dfn{Streams} over a single @dfn{Stream} to the IP driver.

[Figure:9.1 Protocol Multiplexor]

[strm.multprx.gif]

The following example shows how this daemon process sets up the protocol multiplexor.  The necessary
declarations and initialization for the daemon program are as follows:

@smallexample
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stropts.h>

main()
@{
    int fd_802_4, fd_802_3, fd_ip, fd_tp;

    /* daemon-ize this process */

    switch (fork()) @{
    case 0:
        break;
        case -1;
        perror("fork failed");
        exit(2);
    default:
        exit(0);
    @}
    setsid();
@end smallexample

This multi-level multiplexed @dfn{Stream} configuration will be built from the bottom up.
Therefore, the example begins by first constructing the Internel Protocol (IP) multiplexor.  This
multiplexing device driver is treated like any other software driver.  It owns a node in the
@cite{UNIX} file system and is opened just like any other @dfn{STREAMS} device driver.

The first step is to open the multiplexing driver and the 802.4 driver, thus creating separate
@dfn{Streams} above each driver as shown in [9]Figure:9.2 [10]Before Link .  The @dfn{Stream} to the
802.4 driver may now be connected below the multiplexing IP driver using the I_LINK @command{ioctl}
call.

[Figure:9.2 Before Link]

[strm.linkbef.gif]

The sequence of instructions to this point is:

@smallexample
    if ((fd_802.4 = open("/dev/802_4", O_RDWR)) < 0) @{
        perror("open of /dev/802_4 failed");
        exit(1);
    @}

    if ((fd_ip = open("/dev/ip", O_RDWR)) < 0) @{
        perror("open of /dev/ip failed");
        exit(2);
    @}

    /* now link 802.  4 to underside of IP */

    if (ioctl(fd_ip, I_LINK, fd_802_4) < 0) @{
        perror("I_LINK ioctl failed");
        exit(3);
    @}
@end smallexample

I_LINK takes two file descriptors as arguments.  The first file descriptor, fd_ip, must reference
the @dfn{Stream} connected to the multiplexing driver, and the second file descriptor, fd_802_4,
must reference the @dfn{Stream} to be connected below the multiplexor.  [11]Figure:9.3 [12]IP
Multiplexor After First Link shows the state of these @dfn{Streams} following the I_LINK call.  The
complete @dfn{Stream} to the 802.4 driver has been connected below the IP driver.  The @dfn{Stream
head}'s queues of the 802.4 driver will be used by the IP driver to manage the lower half of the
multiplexor.

[Figure:9.3 IP Multiplexor After First Link]

[strm.linkaft.gif]

I_LINK will return an integer value, called muxid, which is used by the multiplexing driver to
identify the @dfn{Stream} just connected below it.  This muxid is ignored in the example, but it is
useful for dismantling a multiplexor or routing data through the multiplexor.  Its significance is
discussed later.

The following sequence of system calls is used to continue building the internetworking protocol
multiplexor (IP):

@smallexample
    if ((fd_802_3 = open("/dev/802_3", O_RDWR)) < 0) @{
        perror("open of /dev/802_3 failed");
        exit(4);
    @}

    if (ioctl(fd_ip, I_LINK, fd_802_3) < 0) @{
        perror("I_LINK ioctl failed");
        exit(5);
    @}
@end smallexample

All links below the IP driver have now been established, giving the configuration in [13]Figure:9.4
[14]IP Multiplexor .

[Figure:9.4 IP Multiplexor]

[strm.ipmult.gif]

The @dfn{Stream} above the multiplexing driver used to establish the lower connections is the
controlling @dfn{Stream} and has special significance when dismantling the multiplexing
configuration.  This will be illustrated later in this chapter.  The @dfn{Stream} referenced by
fd_ip is the controlling @dfn{Stream} for the IP multiplexor.

[Boxnote.gif]

The order in which the @dfn{Streams} in the multiplexing configuration are opened is unimportant.
If it is necessary to have intermediate modules in the @dfn{Stream} between the IP driver and media
drivers, these modules must be added to the @dfn{Streams} associated with the media drivers (using
@var{I_PUSH}) before the media drivers are attached below the multiplexor.

The number of @dfn{Streams} that can be linked to a multiplexor is restricted by the design of the
particular multiplexor.  The manual page describing each driver describes such restrictions.
However, only one I_LINK operation is allowed for each lower @dfn{Stream}; a single @dfn{Stream}
cannot be linked below two multiplexors simultaneously.

Continuing with the example, the IP driver will now be linked below the transport protocol (TP)
multiplexing driver.  As seen earlier in [15]Figure:9.1 [16]Protocol Multiplexor , only one link
will be supported below the transport driver.  This link is formed by the following sequence of
system calls:

@smallexample
    if ((fd_tp = open("/dev/tp", O_RDWR)) < 0) @{
        perror("open of /dev/tp failed");
        exit(6);
    @}

    if (ioctl(fd_tp, I_LINK, fd_ip) < 0) @{
        perror("I_LINK ioctl failed");
        exit(7);
    @}
@end smallexample

The multi-level multiplexing configuration shown in [17]Figure:9.5 [18]TP Multiplexor has now been
created.

[Figure:9.5 TP Multiplexor]

[strm.tpmult.gif]

Because the controlling @dfn{Stream} of the IP multiplexor has been linked below the TP multiplexor, the
controlling @dfn{Stream} for the new multi-level multiplexor configuration is the @dfn{Stream} above the TP
multiplexor.

At this point the file descriptors associated with the lower drivers can be closed without affecting
the operation of the multiplexor.  If these file descriptors are not closed, all subsequent read,
write, @command{ioctl}, poll, getmsg, and putmsg system calls issued to them will fail.  That is because
I_LINK associates the @dfn{Stream head} of each linked @dfn{Stream} with the multiplexor, so the user may not
access that @dfn{Stream} directly for the duration of the link.

The following sequence of system calls completes the daemon example:

@smallexample
    close(fd_802_4);
    close(fd_802_3);
    close(fd_ip);

    /* Hold multiplexor open forever */
    pause();
@}
@end smallexample

To summarize, [19]Figure:9.5 [20]TP Multiplexor shows the multi-level protocol multiplexor.  The
transport driver supports several simultaneous @dfn{Streams}.  These @dfn{Streams} are multiplexed
over the single @dfn{Stream} connected to the IP multiplexor.  The mechanism for establishing
multiple @dfn{Streams} above the transport multiplexor is actually a by-product of the way in which
@dfn{Streams} are created between a user process and a driver.  By opening different minor devices
of a @dfn{STREAMS} driver, separate @dfn{Streams} will be connected to that driver.  Of course, the
driver must be designed with the intelligence to route data from the single lower @dfn{Stream} to
the appropriate upper @dfn{Stream}.

The daemon process maintains the multiplexed @dfn{Stream} configuration through an open @dfn{Stream}
(the controlling @dfn{Stream}) to the transport driver.  Meanwhile, other users can access the
services of the transport protocol by opening new @dfn{Streams} to the transport driver; they are
freed from the need for any unnecessary knowledge of the underlying protocol configurations and
sub-networks that support the transport service.

Multi-level multiplexing configurations should be assembled from the bottom up.  That is because the
passing of ioctls through the multiplexor is determined by the nature of the multiplexing driver and
cannot generally be relied on.

@subsection Dismantling a Multiplexor

@dfn{Streams} connected to a multiplexing driver from above with open, can be dismantled by closing
each @dfn{Stream} with close.  The mechanism for dismantling @dfn{Streams} that have been linked
below a multiplexing driver is less obvious, and is described below.

The I_UNLINK @command{ioctl} call is used to disconnect each multiplexor link below a multiplexing
driver individually.  This command has the form:

ioctl(fd, I_UNLINK, muxid);

where fd is a file descriptor associated with a @dfn{Stream} connected to the multiplexing driver
from above, and muxid is the identifier that was returned by I_LINK when a driver was linked below
the multiplexor.  Each lower driver may be disconnected individually in this way, or a special muxid
value of -1 may be used to disconnect all drivers from the multiplexor simultaneously.

In the multiplexing daemon program presented earlier, the multiplexor is never explicitly
dismantled.  That is because all links associated with a multiplexing driver are automatically
dismantled when the controlling @dfn{Stream} associated with that multiplexor is closed.  Because
the controlling @dfn{Stream} is open to a driver, only the final call of close for that @dfn{Stream}
will close it.  In this case, the daemon is the only process that has opened the controlling
@dfn{Stream}, so the multiplexing configuration will be dismantled when the daemon exits.

For the automatic dismantling mechanism to work in the multi-level, multiplexed Stream
configuration, the controlling @dfn{Stream} for each multiplexor at each level must be linked under
the next higher level multiplexor.  In the example, the controlling @dfn{Stream} for the IP driver
was linked under the TP driver.  This resulted in a single controlling @dfn{Stream} for the full,
multi-level configuration.  Because the multiplexing program relied on closing the controlling
@dfn{Stream} to dismantle the multiplexed @dfn{Stream} configuration instead of using explicit
I_UNLINK calls, the muxid values returned by I_LINK could be ignored.

An important side effect of automatic dismantling on the close is that it is not possible for a
process to build a multiplexing configuration with I_LINK and then exit.  That is because exit(2)
will close all files associated with the process, including the controlling @dfn{Stream}.  To keep
the configuration intact, the process must exist for the life of that multiplexor.  That is the
motivation for implementing the example as a daemon process.

However, if the process uses persistent links via the I_PLINK @command{ioctl} call, the multiplexor
configuration would remain intact after the process exits.  Persistent links are described later in
this chapter.

@subsection Routing Data Through a Multiplexor

As demonstrated, @dfn{STREAMS} provides a mechanism for building multiplexed @dfn{Stream}
configurations.  However, the criteria on which a multiplexor routes data is driver dependent.  For
example, the protocol multiplexor shown before might use address information found in a protocol
header to determine over which sub-network data should be routed.  It is the multiplexing driver's
responsibility to define its routing criteria.

One routing option available to the multiplexor is to use the muxid value to determine to which
@dfn{Stream} data should be routed (remember that each multiplexor link is associated with a muxid).
I_LINK passes the muxid value to the driver and returns this value to the user.  The driver can
therefore specify that the muxid value must accompany data routed through it.  For example, if a
multiplexor routed data from a single upper @dfn{Stream} to one of several lower @dfn{Streams} (as
did the IP driver), the multiplexor could require the user to insert the muxid of the desired lower
@dfn{Stream} into the first four bytes of each message passed to it.  The driver could then match
the muxid in each message with the muxid of each lower @dfn{Stream}, and route the data accordingly.

@node Connecting and Disconnecting Lower Stream
@section Connecting and Disconnecting Lower Stream

Multiple @dfn{Streams} are created above a driver/multiplexor by use of the open system call on
either different minor devices, or on a cloneable device file.  Note that any driver that handles
more than one minor device is considered an upper multiplexor.

To connect @dfn{Streams} below a multiplexor requires additional software within the multiplexor.
The main difference between @dfn{STREAMS} lower multiplexors and @dfn{STREAMS} device drivers are
that multiplexors are pseudo-devices and that multiplexors have two additional qinit structures,
pointed to by fields in the streamtab structure: the lower half read-side qinit and the lower half
write-side qinit.

The multiplexor is conceptually divided into two parts: the lower half (bottom) and the upper half
(top).  The multiplexor queue structures that have been allocated when the multiplexor was opened,
use the usual qinit entries from the multiplexor's streamtab.  This is the same as any open of the
@dfn{STREAMS} device.  When a lower @dfn{Stream} is linked beneath the multiplexor, the qinit
structures at the @dfn{Stream head} are substituted by the bottom half qinit structures of the
multiplexors.  Once the linkage is made, the multiplexor switches messages between upper and lower
@dfn{Streams}.  When messages reach the top of the lower @dfn{Stream}, they are handled by
@command{put} and @command{service} routines specified in the bottom half of the multiplexor.

@subsection Connecting Lower Streams

A lower multiplexor is connected as follows: the initial open to a multiplexing driver creates a
@dfn{Stream}, as in any other driver.  open uses the first two streamtab structure entries to create
the driver queues.  At this point, the only distinguishing characteristic of this @dfn{Stream} are
non-NULL entries in the streamtab st_muxrinit and st_muxwinit fields.

These fields are ignored by open (see the rightmost @dfn{Stream} in [7]Figure:9.6 [8]Internet
Multiplexor Before Connecting ).  Any other @dfn{Stream} subsequently opened to this driver will
have the same streamtab and thereby the same mux fields.

Next, another file is opened to create a (soon to be) lower @dfn{Stream}.  The driver for the lower
Stream is typically a device driver (see the leftmost @dfn{Stream} in [9]Figure:9.6 [10]Internet
Multiplexor Before Connecting ).  This Stream has no distinguishing characteristics.  It can include
any driver compatible with the multiplexor.  Any modules required on the lower @dfn{Stream} must be
pushed onto it now.

Next, this lower @dfn{Stream} is connected below the multiplexing driver with an I_LINK
@command{ioctl} call [see streamio(7)].  The @dfn{Stream head} points to the @dfn{Stream head}
routines as its procedures (known via its queue).  An I_LINK to the upper @dfn{Stream}, referencing
the lower @dfn{Stream}, causes @dfn{STREAMS} to modify the contents of the @dfn{Stream head}'s
queues in the lower @dfn{Stream}.  The pointers to the @dfn{Stream head} routines, and other values,
in the @dfn{Stream head}'s queues are replaced with those contained in the mux fields of the
multiplexing driver's streamtab.  Changing the @dfn{Stream head} routines on the lower @dfn{Stream}
means that all subsequent messages sent upstream by the lower @dfn{Stream}'s driver will,
ultimately, be passed to the @command{put} procedure designated in st_muxrinit, the multiplexing
driver.  The I_LINK also establishes this upper @dfn{Stream} as the control @dfn{Stream} for this
lower @dfn{Stream}.  @dfn{STREAMS} remembers the relationship between these two @dfn{Streams} until
the upper @dfn{Stream} is closed, or the lower @dfn{Stream} is unlinked.

Finally, the @dfn{Stream head} sends an M_IOCTL message with ioc_cmd set to I_LINK to the
multiplexing driver.  The M_DATA part of the M_IOCTL contains a linkblk structure.  The multiplexing
driver stores information from the linkblk structure in private storage and returns an M_IOCACK
message (acknowledgement).  l_index is returned to the process requesting the I_LINK.  This value
can be used later by the process to disconnect this @dfn{Stream}.

An I_LINK is required for each lower @dfn{Stream} connected to the driver.  Additional upper
@dfn{Streams} can be connected to the multiplexing driver by open calls.  Any message type can be
sent from a lower @dfn{Stream} to user processes along any of the upper @dfn{Streams}.  The upper
@dfn{Streams} provide the only interface between the user processes and the multiplexor.

Note that no direct data structure linkage is established for the linked @dfn{Streams}.  The read
queue's q_next will be NULL and the write queue's q_next will point to the first entity on the lower
@dfn{Stream}.  Messages flowing upstream from a lower driver (a device driver or another
multiplexor) will enter the multiplexing driver @command{put} procedure with l_qbot as the queue
value.  The multiplexing driver has to route the messages to the appropriate upper (or lower)
@dfn{Stream}.  Similarly, a message coming downstream from user space on any upper Stream has to be
processed and routed, if required, by the driver.

Also note that the lower @dfn{Stream} (see the headers and file descriptors in [11]Figure:9.7
[12]Internet Multiplexor After Connecting ) is no longer accessible from user space.  This causes
all system calls to the lower @dfn{Stream} to return EINVAL, with the exception of close.  This is
why all modules have to be in place before the lower @dfn{Stream} is linked to the multiplexing
driver.

Finally, note that the absence of direct linkage between the upper and lower @dfn{Streams} means
that @dfn{STREAMS} flow control has to be handled by special code in the multiplexing driver.  The
flow control mechanism cannot see across the driver.

In general, multiplexing drivers should be implemented so that new @dfn{Streams} can be dynamically
connected to (and existing @dfn{Streams} disconnected from) the driver without interfering with its
ongoing operation.  The number of @dfn{Streams} that can be connected to a multiplexor is developer
dependent.

@subsection Disconnection Lower Streams

Dismantling a lower multiplexor is accomplished by disconnecting (unlinking) the lower
@dfn{Streams}.  Unlinking can be initiated in three ways: an I_UNLINK @command{ioctl} referencing a
specific @dfn{Stream}, an I_UNLINK indicating all lower @dfn{Streams}, or the last close of the
control @dfn{Stream}.  As in the link, an unlink sends a linkblk structure to the driver in an
M_IOCTL message.  The I_UNLINK call, which unlinks a single @dfn{Stream}, uses the l_index value
returned in the I_LINK to specify the lower Stream to be unlinked.  The latter two calls must
designate a file corresponding to a control @dfn{Stream} which causes all the lower @dfn{Streams}
that were previously linked by this control @dfn{Stream} to be unlinked.  However, the driver sees a
series of individual unlinks.

If no open references exist for a lower @dfn{Stream}, a subsequent unlink will automatically close
the @dfn{Stream}.  Otherwise, the lower @dfn{Stream} must be closed by close following the unlink.
@dfn{STREAMS} will automatically dismantle all cascaded multiplexors (below other multiplexing
@dfn{Streams}) if their controlling @dfn{Stream} is closed.  An I_UNLINK will leave lower, cascaded
multiplexing @dfn{Streams} intact unless the @dfn{Stream} file descriptor was previously closed.

@node Multiplexor Construction Example
@section Multiplexor Construction Example

This section describes an example of multiplexor construction and usage.  [6]Figure:9.6 [7]Internet
Multiplexor Before Connecting shows the @dfn{Streams} before their connection to create the
multiplexing configuration of [8]Figure:9.7 [9]Internet Multiplexor After Connecting .  Multiple
upper and lower @dfn{Streams} interface to the multiplexor driver.  The user processes of
[10]Figure:9.7 [11]Internet Multiplexor After Connecting .  are not shown in [12]Figure:9.6
[13]Internet Multiplexor Before Connecting .

[Figure:9.6 Internet Multiplexor Before Connecting]

[strm.befint.gif]

The Ethernet, LAPB and IEEE 802.2 device drivers terminate links to other nodes.  The multiplexor
driver is an Internet Protocol (IP) multiplexor that switches data among the various nodes or sends
data upstream to a user(s) in the system.  The Net modules would typically provide a convergence
function which matches the multiplexor driver and device driver interface.

[14]Figure:9.6 [15]Internet Multiplexor Before Connecting depicts only a portion of the full, larger
@dfn{Stream}.  In the dotted rectangle above the IP multiplexor, there generally would be an upper
transport control protocol (TCP) multiplexor, additional modules and, possibly, additional
multiplexors in the @dfn{Stream}.  Multiplexors could also be cascaded below the IP driver if the
device drivers were replaced by multiplexor drivers.

[Figure:9.7 Internet Multiplexor After Connecting]

[strm.aftint.gif]

@dfn{Streams} A, B, and C are opened by the process, and modules are pushed as needed.  Two upper
@dfn{Streams} are opened to the IP multiplexor.  The rightmost @dfn{Stream} represents multiple
@dfn{Streams}, each connected to a process using the network.  The @dfn{Stream} second from the
right provides a direct path to the multiplexor for supervisory functions.  It is the control
@dfn{Stream}, leading to a process which sets up and supervises this configuration.  It is always
directly connected to the IP driver.  Although not shown, modules can be pushed on the control
@dfn{Stream}.

After the @dfn{Streams} are opened, the supervisory process typically transfers routing information
to the IP drivers (and any other multiplexors above the IP), and initializes the links.  As each
link becomes operational, its @dfn{Stream} is connected below the IP driver.  If a more complex
multiplexing configuration is required, the IP multiplexor @dfn{Stream} with all its connected links
can be connected below another multiplexor driver.

[16]Figure:9.7 [17]Internet Multiplexor After Connecting shows that the file descriptors for the
lower device driver @dfn{Streams} are left dangling.  The primary purpose in creating these
@dfn{Streams} was to provide parts for the multiplexor.  Those not used for control and not required
for error recovery (by reconnecting them through an I_UNLINK @command{ioctl}) have no further
function.  These lower @dfn{Streams} can be closed to free the file descriptor without any effect on
the multiplexor.

@node Mulxiplexing Driver
@section Mulxiplexing Driver

This section contains an example of a multiplexing driver that implements an N-to-1 configuration.
This configuration might be used for terminal windows, where each transmission to or from the
terminal identifies the window.  This resembles a typical device driver, with two differences: the
device handling functions are performed by a separate driver, connected as a lower @dfn{Stream}, and
the device information (i.e., relevant user process) is contained in the input data rather than in
an interrupt call.

Each upper @dfn{Stream} is created by open(2).  A single lower @dfn{Stream} is opened and then it is
linked by use of the multiplexing facility.  This lower @dfn{Stream} might connect to the tty
driver.  The implementation of this example is a foundation for an M-to-N multiplexor.

As in the loop-around driver (in Drivers), flow control requires the use of standard and special
code, since physical connectivity among the @dfn{Streams} is broken at the driver.  Different
approaches are used for flow control on the lower @dfn{Stream}, for messages coming upstream from
the device driver, and on the upper @dfn{Streams}, for messages coming downstream from the user
processes.

The multiplexor declarations are:

@smallexample
#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysmacros.h>
#include <sys/streams.h>
#include <sys/stropts.h>
#include <sys/errno.h>
#include <sys/cred.h>
#include <sys/ddi.h>

static int mixopen(), muxclose(), muxuwput(), muxlwsrv(), muxlrput(),
muxuwsrv();

static struct module_info info = @{
    0xaabb, "mux", 0, INFPSZ, 512, 128
@};

static struct qinit urinit = @{  /* upper read */
    NULL, NULL, muxopen, muxclose, NULL, &info, NULL
@};

static struct qinit uwinit = @{  /* upper write */
    muxuwput, muxuwsrv, NULL, NULL, NULL, &info, NULL
@};

static struct qinit lrinit = @{  /* lower read */
    muxlrput, NULL, NULL, NULL, NULL, &info, NULL
@};

static struct qinit lwinit = @{  /* lower write */
    NULL, muxlwsrv, NULL, NULL, NULL, &info, NULL
@};

struct streamtab muxinfo = @{ &urinit, &uwinit, &lrinit, &l winit
@};

struct mux @{
    queue_t *qbtr;              /* back pointer to read queue */
@};

extern struct mux mux_mux[];
extern int mux_cnt;

queue_t *muxbot;                /* linked lower queue */
int muxerr;                     /* set if error of hangup on lower stream */
@end smallexample

The four streamtab entries correspond to the upper read, upper write, lower read, and lower write
qinit structures.  The multiplexing qinit structures replace those in each (in this case there is
only one) lower @dfn{Stream head} after the I_LINK has completed successfully.  In a multiplexing
configuration, the processing performed by the multiplexing driver can be partitioned between the
upper and lower queues.  There must be an upper @dfn{Stream} write @command{put} procedure and lower
@dfn{Stream} read @command{put} procedure.  If the queue procedures of the opposite upper/lower
queue are not needed, the queue can be skipped over, and the message put to the following queue.

In the example, the upper read-side procedures are not used.  The lower @dfn{Stream} read queue
@command{put} procedure transfers the message directly to the read queue upstream from the
multiplexor.  There is no lower write @command{put} procedure because the upper write @command{put}
procedure directly feeds the lower write queue downstream from the multiplexor.

The driver uses a private data structure, mux.  mux_mux[dev] points back to the opened upper read
queue.  This is used to route messages coming upstream from the driver to the appropriate upper
queue.  It is also used to find a free major/minor device for a CLONEOPEN driver open case.

The upper queue open contains the canonical driver open code:

@smallexample
static int
muxopen(q, devp, flag, sflag, credp)
        queue_t *q;
        dev_t *devp;
        int flag;
        int sflag;
        cred_t *credp;
@{
    struct mux *mux;
    dev_t device;

    if (sflag == CLONEOPEN) @{
        for (device = 0; device < mux_cnt; device++) @{
            if (mux_mux[device].qptr == 0)
                break;
        @}
    @} else
        device = getminor(*devp);

    if (device >= mux_cnt)
        return ENXIO;

    mux = &mux_mux[device];
    mux->qptr = q;
    q->q_ptr = (char *) mux;
    wr(q)->q_ptr = (char *) mux;
    return 0;
@}
@end smallexample

muxopen checks for a clone or ordinary open call.  It initializes q_ptr to point at the mux_mux[t]
structure.

The core multiplexor processing is the following: downstream data written to an upper @dfn{Stream}
is queued on the corresponding upper write message queue if the lower @dfn{Stream} is flow
controlled.  This allows flow control to propagate towards the @dfn{Stream head} for each upper
@dfn{Stream}.  A lower write @command{service} procedure, rather than a write @command{put}
procedure, is used so that flow control, coming up from the driver below, may be handled.

On the lower read-side, data coming up the lower @dfn{Stream} are passed to the lower read
@command{put} procedure.  The procedure routes the data to an upper @dfn{Stream} based on the first
byte of the message.  This byte holds the minor device number of an upper @dfn{Stream}.  The
@command{put} procedure handles flow control by testing the upper @dfn{Stream} at the first upper
read queue beyond the driver.  That is, the @command{put} procedure treats the @dfn{Stream}
component above the driver as the next queue.

@subsection Upper Write Put Procedure

muxuwput, the upper queue write @command{put} procedure, traps ioctls, in particular I_LINK and
I_UNLINK:

@smallexample
static int
muxuwput(q, mp)
        queue_t *q;
        mblk_t *MP;
@{
    int s;
    struct mux *mux;

    mux = (struct mux *) q->q_ptr;
    switch (mp->b_datap->db_type) @{
    case M_IOCTL:@{
        struct iocblk *iocp;
        struct linkblk *linkp;

        /* 
         * ioctl.  Only channel 0 can do ioctls.  Two
         * calls are recognized: Link, and UNLINK
         */

        if (mux != mux_mux)
            goto iocnak;

        iocp = (struct iocblk *) mp->b_rptr;
        switch (iocp->ioc_cmd) @{
        case I_LINK:

            /* 
             * Link.  The data contains a linkblk structure
             * Remember the bottom queue in muxbot.
             */

            if (muxbot != NULL)
                goto iocnak;
            linkp = (struct linkblk *) mp->b_cont->b_rptr;
            muxbot = linkp->l_qbot;
            muxerr = 0;
            mp->b_datap->db_type = M_IOCACK;
            iocp->ioc_count = 0;
            qreply(q, mp);
            break;

        case I_UNLINK:

            /* 
             * Unlink.  The data contains a linkblk structure.
             * Should not fail an unlink.  Null out muxbot.
             */

            linkp = (struct linkblk *) mp->b_cont->b_rptr;
            muxbot = NULL;
            mp->b_datap->db_type = M_IOCACK;
            iocp->ioc_cont = 0;
            qreply(q, mp);
            break;

        default:
          iocnak:

            /* fail ioctl */

            mp->b_datap->db_type = M_IOCNAK;
            qreply(q, mp);
        @}

        break;

    @}
@end smallexample

First, there is a check to enforce that the @dfn{Stream} associated with minor device 0 will be the
single, controlling @dfn{Stream}.  The ioctls are only accepted on this @dfn{Stream}.  As described
previously, a controlling @dfn{Stream} is the one that issues the I_LINK.  Having a single control
@dfn{Stream} is a recommended practice.  I_LINK and I_UNLINK include a linkblk structure containing:

@table @var
@item l_qtop
The upper write queue from which the @command{ioctl} is coming.  It should always equal q.

@item l_qbot
The new lower write queue.  It is the former @dfn{Stream head} write queue.  It is of most interest
since that is where the multiplexor gets and puts its data.

@item l_index
A unique (system wide) identifier for the link.  It can be used for routing or during selective
unlinks.  Since the example only supports a single link, l_index is not used.

@end table

For I_LINK, l_qbot is saved in muxbot and a positive acknowledgment is generated.  From this point
on, until an I_UNLINK occurs, data from upper queues will be routed through muxbot.  Note that when
an I_LINK, is received, the lower Stream has already been connected.  This allows the driver to send
messages downstream to perform any initialization functions.  Returning an M_IOCNAK message
(negative acknowledgment) in response to an I_LINK will cause the lower @dfn{Stream} to be
disconnected.

The I_UNLINK handling code nulls out muxbot and generates a positive acknowledgment.  A negative
acknowledgment should not be returned to an I_UNLINK.  The @dfn{Stream head} assures that the lower
Stream is connected to a multiplexor before sending an I_UNLINK M_IOCTL.

muxuwput handles M_FLUSH messages as a normal driver would:

@smallexample
    case M_FLUSH:
        if (*mp->b_rptr & FLUSHW)
            flushq(q, FLUSHDATA);
        if (*mp->b_rptr & FLUSHR) @{
            *mp->b_rptr &= ~FLUSHW;
            qreply(q, mp);
        @} else
            freemsg(mp);
        break;
    case M_DATA:
        /* 
         * Data.  If we have no bottom queue --> fail
         * Otherwise, queue the data and invoke the lower
         * service procedure.
         */
        if (muxerr || muxbot == NULL)
            goto bad;
        if (canput(muxbot->q_next)) @{
            mblk_t *bp;

            if ((bp = allocb(l, BPRI_MED)) == NULL) @{
                putq(q, mp);
                bufcall(l, BPRI_MED, qenable, q);
                break;
            @}
            *bp->b_wptr++ = (struct mux *) q->q_ptr - mux_mux;
            bp->b_cont = mp;
            putnext(muxbot, bp);
        @} else
            putq(q, mp);
        break;
    default:
      bad:
        /* 
         * Send an error message upstream.
         */
        mp->b_datap->db_type = M_ERROR;
        mp->b_rptr = mp->b_wptr = mp->b_datap->db_base;
        *mp->b_wptr++ = EINVAL;
        qreply(q, mp);
    @}
@}
@end smallexample

M_DATA messages are not placed on the lower write message queue.  They are queued on the upper write
message queue.  When flow control subsides on the lower @dfn{Stream}, the lower @command{service}
procedure, muxlwsrv, is scheduled to start output.  This is similar to starting output on a device
driver.

@subsection Upper Write Service Procedure

The following example shows the code for the upper multiplexor write @command{service} procedure:

@smallexample
static int
muxuwsrv(q)
        queue_t *q;
@{
    struct mux *muxp;
    mblk_t *mp;

    muxp = (struct mux *) q->q_ptr;

    if (!muxbot && q->q_first) @{
        flushq(q, FLUSHALL);
        return;
    @}
    if (muxerr) @{
        flushq(q, FLUSHALL);
        return;
    @}
    while (mp = getq(q)) @{
        if (canput(muxbot->q_next))
            putnext(muxbot, mp);
        else @{
            putnext(muxbot, mp);
            return;
        @}
    @}
@}
@end smallexample

As long as there is a @dfn{Stream} still linked under the multiplexor and there are no errors, the
@command{service} procedure will take a message off the queue and send it downstream, if flow
control allows.

@subsection Lower Write Service Procedure

muxlwsrv, the lower (linked) queue write @command{service} procedure is scheduled as a result of
flow control subsiding downstream (it is back-enabled).

@smallexample
static int
muxlwsrv(q)
        queue_t *q;
@{
    register int i;

    for (i = 0; i < mux_cnt; i++)
        if (mux_mux[i].qptr && mux_mux[i].qptr->q_first)
            genable(mux_mux[i].qptr);
@}
@end smallexample

muxlwsrv steps through all possible upper queues.  If a queue is active and there are messages on
the queue, then its the upper write @command{service} procedure is enabled via qenable().

@subsection Lower Read Put Procedure

The lower (linked) queue read @command{put} procedure is:

@smallexample
static int
muxlrput(q, mp)
        queue_t *q;
        mklk_t *mp;
@{
    queue_t *uq;
    mklk_t *b_cont;
    int device;

    if (muxerr) @{
        freemsg(mp);
        return;
    @}
    switch (mp->b_datap->db_type) @{
    case M_FLUSH:
        /* 
         * Flush queues.  NOTE: sense of tests is reversed
         * since we are acting like a "stream head"
         */
        if (*mp->b_rptr & FLUSHW) @{
            *mp->b_rptr &= ~FLUSHR;
            qreply(q, mp);
        @} else
            freemsg(mp);
        break;

    case M_ERROR:
    case M_HANGUP:
        muxerr = 1;
        freemsg(mp);
        break;

    case M_DATA:
        /* 
         * Route message.  First byte indicates
         * device to send to.  No floe control.
         *
         * Extract and delete device number.  If the leading block is
         * now empty and more blocks follow, strip the leading block.
         */

        device = *mp->b_rptr++;

        /* Sanity check.  Device must be in range */

        if (device < 0 || device >= mux_cut) @{
            freemsg(mp);
            break;
        @}

        /* 
         * If upper stream is open and not backed up,
         * send the message there, otherwise discard it.
         */

        uq = mux_mux[device].qptr;
        if (uq != NULL && canput(uq->q_next))
            putnext(uq, mp);
        else
            freemsg(mp);
        break;
    default:
        freemsg(mp);
    @}
@}
@end smallexample

muxlrput receives messages from the linked @dfn{Stream}.  In this case, it is acting as a
@dfn{Stream head}.  It handles M_FLUSH messages.  Note the code is reversed from that of a driver,
handling M_FLUSH messages from upstream.  There is no need to flush the read queue because no data
are ever placed on it.

muxlrput also handles M_ERROR and M_HANGUP messages.  If one is received, it locks-up the upper
@dfn{Streams} by setting muxerr.

M_DATA messages are routed by looking at the first data byte of the message.  This byte contains the
minor device of the upper @dfn{Stream}.  Several sanity checks are made: Is the device in range? Is
the upper @dfn{Stream} open? Is the upper @dfn{Stream} not full?

This multiplexor does not support flow control on the read-side.  It is merely a router.  If
everything checks out, the message is put to the proper upper queue.  Otherwise, the message is
discarded.

The upper @dfn{Stream} close routine simply clears the mux entry so this queue will no longer be
found.

@smallexample
/*
 * Upper queue close
 */
static int
muxclose(q, flag, credp)
        queue_t *q;
        int flag;
        cred_t *credp;
@{
    ((struct mux *) q->q_ptr)->qptr = NULL;
    q->q->ptr = NULL;
    wr(q)->q_ptr = NULL;
@}
@end smallexample

@node Persistent Links
@section Persistent Links

With I_LINK and I_UNLINK ioctls the file descriptor associated with the @dfn{Stream} above the
multiplexor used to set up the lower multiplexor connections must remain open for the duration of
the configuration.  Closing the file descriptor associated with the controlling @dfn{Stream} will
dismantle the whole multiplexing configuration.  Some applications may not want to keep a process
running merely to hold the multiplexor configuration together.  Therefore, "free-standing" links
below a multiplexor are needed.  A persistent link is such a link.  It is similar to a @dfn{STREAMS}
multiplexor link, except that a process is not needed to hold the links together.  After the
multiplexor has been set up, the process may close all file descriptors and exit, and the
multiplexor will remain intact.

Two ioctls, I_PLINK and I_PUNLINK, are used to create and remove persistent links that are
associated with the @dfn{Stream} above the multiplexor.  close(2) and I_UNLINK are not able to
disconnect the persistent links.

The format of I_PLINK is:

@example
ioctl(fd0, I_PLINK, fd1)
@end example

The first file descriptor, fd0, must reference the @dfn{Stream} connected to the multiplexing driver
and the second file descriptor, fd1, must reference the @dfn{Stream} to be connected below the
multiplexor.  The persistent link can be created in the following way:

@smallexample
    upper_stream_fd = open("/dev/mux", O_RDWR);
    iower_stream_fd = open("/dev/driver", O_RDWR);
    muxid = ioctl(upper_stream_fd, I_PLINK, lower_stream_fd);
    /* 
     * save muxid in s file
     */
    exit(0);
@end smallexample

[6]Figure:9.8 [7]open() of MUXdriver and Driver1 shows how open(2) establishes a @dfn{Stream}
between the device and the @dfn{Stream head}.

[Figure:9.8 open() of MUXdriver and Driver1]

[strm.dviopen.gif]

The persistent link can still exist even if the file descriptor associated with the upper
@dfn{Stream} to the multiplexing driver is closed.  The I_PLINK @command{ioctl} returns an integer
value, muxid, that can be used for dismantling the multiplexing configuration.  If the process that
created the persistent link still exists, it may pass the muxid value to some other process to
dismantle the link, if the dismantling is desired, or it can leave the muxid value in a file so that
other processes may find it later.  [8]Figure:9.9 [9]Multiplexor After I_PLINK shows a multiplexor
after I_PLINK.

[Figure:9.9 Multiplexor After I_PLINK]

[strm.lplink.gif]

Several users can open the MUXdriver and send data to the Driver1 since the persistent link to the
Driver1 remains intact.  This is shown in the following figure.

[Figure:9.10 Other Users Opening a MUXdriver]

[strm.muxdvi.gif]

The @command{ioctl} I_PUNLINK is used for dismantling the persistent link.  Its format is:

@example
ioctl(fd0, I_PUNLINK, muxid)
@end example

where the fd0 is the file descriptor associated with @dfn{Stream} connected to the multiplexing
driver from above.  The muxid is returned by the @command{ioctl} I_PLINK for the @dfn{Stream} that
was connected below the multiplexor.  The I_PUNLINK removes the persistent link between the
multiplexor referenced by the fd0 and the @dfn{Stream} to the driver designated by the muxid.  Each
of the bottom persistent links can be disconnected individually.  An I_PUNLINK @command{ioctl} with
the muxid value of MUXID_ALL will remove all persistent links below the multiplexing driver
referenced by the fd0.

The following will dismantle the previously given configuration:

@smallexample
    fd = open("/dev/mux", O_RDWR);
    /*
     * retrieve muxid from the file
     */
    ioctl(fd, I_PUNLINK, muxid);
    exit(0);
@end smallexample

The use of the ioctls I_PLINK and I_PUNLINK should not be intermixed with the I_LINK and I_UNLINK.
Any attempt to unlink a regular link via the I_PUNLINK or to unlink a persistent link via the
I_UNLINK @command{ioctl} will cause the errno value of EINVAL to be returned.

Since multi-level multiplexing configurations are allowed in @dfn{STREAMS}, it is possible to have a
situation where persistent links exist below a multiplexor whose @dfn{Stream} is connected to the
above multiplexor by regular links.  Closing the file descriptor associated with the controlling
Stream will remove the regular link but not the persistent links below it.  On the other hand,
regular links are allowed to exist below a multiplexor whose @dfn{Stream} is connected to the above
multiplexor via persistent links.  In this case, the regular links will be removed if the persistent
link above is removed and no other references to the lower @dfn{Streams} exist.

The construction of cycles is not allowed when creating links.  A cycle could be constructed by
creating a persistent link of multiplexor 2 below multiplexor 1 and then closing the controlling
file descriptor associated with the multiplexor 2 and reopening it again and then linking the
multiplexor 1 below the multiplexor 2.  This is not allowed.  The operating system prevents a
multiplexor configuration from containing a cycle to ensure that messages can not be routed
infinitely, thus creating an infinite loop or overflowing the kernel stack.

@node Multiplexing Driver Design Guidelines
@section Multiplexing Driver Design Guidelines

The following lists general multiplexor design guidelines:

@itemize @bullet

@item The upper half of the multiplexor acts like the end of the upper @dfn{Stream}.

@item The lower half of the multiplexor acts like the head of the lower @dfn{Stream}.

@item Service procedures are used for flow control.

@item Message routing is based on multiplexor specific criteria.

@item When one @dfn{Stream} is being fed by many @dfn{Streams}, flow control may have to take place.  Then all
feeding @dfn{Streams} on the other end of the multiplexor will have to be enabled when the flow control is
relieved.

@item When one @dfn{Stream} is feeding many @dfn{Streams}, flow control may also have to take place.  Be careful
not to starve other @dfn{Streams} when one becomes flow controlled.

@end itemize

@node STREAMS-based Pipes and FIFOs
@chapter STREAMS-based Pipes and FIFOs
@cindex STREAMS-based pipes and fifos
@menu
* Pipes and FIFOs::		STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs
@end menu

@node Pipes and FIFOs
@section Pipes and FIFOs

A pipe in the @cite{UNIX} system is a mechanism that provides a communication path between multiple
processes.  Prior to @cite{Release 4.0 UNIX System V} had "standard" pipes and named pipes (also
called FIFOs).  With standard pipes, one end was opened for reading and the other end for writing,
thus data flow was uni-directional.  FIFOs had only one end and typically one process opened the
file for reading and another process opened the file for writing.  Data written into the FIFO by the
writer could then be read by the reader.

To provide greater support and development flexibility for applications using a network, pipes and
FIFOs have become @dfn{STREAMS}-based in @cite{UNIX System V Release 4.0}.  The basic interface
remains the same but the underlying implementation has changed.  Pipes now provide a bi-directional
mechanism for process communication.  When a pipe is created via the pipe(2) system call, two
@dfn{Streams} are opened and connected together, thus providing a full-duplex mechanism.  Data flow
is on First-In-First-Out basis.  Previously pipes were associated with character devices and the
creation of a pipe was limited to the capacity and configuration of the device.  @dfn{STREAMS}-based
pipes and FIFOs are not attached to @dfn{STREAMS}-based character devices.  This eliminates
configuration constraints and limits the number of opened pipes to the number of file descriptors
for that process.

The remainder of this chapter uses the terms pipe and @dfn{STREAMS}-based pipe interchangeably for a
@dfn{STREAMS}-based pipe.

@subsection Creating and Opening Pipes and FIFOs

FIFOs are created via mknod(2) or mkfifo(3C).  FIFOs behave like regular file system nodes but are
distinguished from other file system nodes by the p in the first column when the ls -l command is
executed.  Data written to the FIFO or read from the FIFO flow up and down the @dfn{Stream} in
@dfn{STREAMS} buffers.  Data written by one process can be read by another process.

FIFOs are opened in the same manner as other file system nodes via the open(2) system call.  Any
data written to the FIFO can be read from the same file descriptor in the First-In-First-Out manner.
Modules can also be pushed on the FIFO.  See open(2) for the restrictions that apply when opening a
FIFO.

A @dfn{STREAMS}-based pipe is created via the pipe(2) system call that returns two file descriptors,
fd[0] and fd[1].  Both file descriptors are opened for reading and writing.  Data written to fd[0]
becomes data read from fd[1] and vice versa.

Each end of the pipe has knowledge of the other end through internal data structures.  Subsequent
reads, writes, and closes are aware of if the other end of the pipe is open or closed.  When one end
of the pipe is closed, the internal data structures provide a way to access the @dfn{Stream} for the
other end so that an M_HANGUP message can be sent to its @dfn{Stream head}.

After successful creation of a @dfn{STREAMS}-based pipe, 0 is returned.  If pipe(2) is unable to
create and open a @dfn{STREAMS}-based pipe, it will fail with errno set as follows:

@itemize @bullet
@item ENOMEM could not allocate two vnodes.
@item ENFILE file table is overflowed.
@item EMFILE can't allocate more file descriptors for the process.
@item ENOSR could not allocate resources for both @dfn{Stream heads}.
@item EINTR signal was caught while creating the @dfn{Stream heads}.
@end itemize

@dfn{STREAMS} modules can be added to a @dfn{STREAMS}-based pipe with the @manpage{ioctl(2)}
@var{I_PUSH}.  A module can be pushed onto one or both ends of the pipe (see [7]Figure:10.1
[8]Pushing Modules on a @dfn{STREAMS}-based Pipe ).  However, a pipe maintains the concept of a
midpoint so that if a module is pushed onto one end of the pipe, that module cannot be popped from
the other end.

[Figure:10.1 Pushing Modules on a @dfn{STREAMS}-based Pipe]

[strm.mjlpush.gif]

@subsection Accessing Pipes and FIFOs

@dfn{STREAMS}-based pipes and FIFOs can be accessed through the operating system routines read(2),
write(2), @manpage{ioctl(2)}, close(2), putmsg(2), getmsg(2), and poll(2).  In case of FIFOs open(2)
is also used.

@subsubsection Reading from a Pipe or FIFO

The read(2) [or getmsg(2)] system call is used to read from a pipe or FIFO.  A user reads data from
a @dfn{Stream} (not from a data buffer as was done prior to Release 4.0).  Data can be read from
either end of a pipe.

On success, the read returns the number of bytes read and placed in the buffer.  When the end of the
data is reached, the read returns 0.

When a user process attempts to read from an empty pipe (or FIFO), the following will happen:

@itemize @bullet

@item If one end of the pipe is closed, 0 is returned indicating the end of the file.

@item If no process has the FIFO open for writing, read(2) returns 0 to indicate the end of the
file.

@item If some process has the FIFO open for writing, or both ends of the pipe are open, and O_NDELAY
is set, read(2) returns 0.

@item If some process has the FIFO open for writing, or both ends of the pipe are open, and
O_NONBLOCK is set, read(2) returns -1 and set errno to EAGAIN.

@item If O_NDELAY and O_NONBLOCK are not set, the read call will block until data are written to the
pipe, until one end of the pipe is closed, or the FIFO is no longer open for writing.

@end itemize

@subsubsection Writing to a Pipe or FIFO

When a user process calls the write(2) system call, data are sent down the associated @dfn{Stream}.
If the pipe or FIFO is empty (no modules pushed), data written are placed on the read queue of the
other @dfn{Stream} for @dfn{STREAMS}-based pipes, and on the read queue of the same @dfn{Stream} for
FIFOs.  Since the size of a pipe is the number of unread data bytes, the written data are reflected
in the size of the other end of the pipe.

@subsubheading Zero Length Writes 

If a user process issues write(2) with 0 as the number of bytes to send down a @dfn{STREAMS}-based
pipe or FIFO, 0 is returned, and by default no message is sent down the @dfn{Stream}.  However, if a
user requires that a 0-length message be sent downstream, an @command{ioctl} call may be used to
change this default behavior.  The flag SNDZERO supports this.  If SNDZERO is set in the @dfn{Stream
head}, write(2) requests of 0 bytes will generate a 0-length message and send the message down the
@dfn{Stream}.  If SNDZERO is not set, no message is generated and 0 is returned to the user.

To toggle the SNDZERO bit, the @command{ioctl} I_SWROPT is used.  If arg in the @command{ioctl} call
is set to SNDZERO and the SNDZERO bit is off, the bit is turned on.  If arg is set to 0 and the
SNDZERO bit is on, the bit is turned off.

The @command{ioctl} I_GWROPT is used to return the current write settings.

@subsubheading Atomic Writes 

If multiple processes simultaneously write to the same pipe, data from one process can be
interleaved with data from another process, if modules are pushed on the pipe or the write is
greater than PIPE_BUF.  The order of data written is not necessarily the order of data read.  To
ensure that writes of less than PIPE_BUF bytes will not be interleaved with data written from other
processes, any modules pushed on the pipe should have a maximum packet size of at least PIPE_BUF.

[Boxnote.gif]

PIPE_BUF is an implementation specific constant that specifies the maximum number of bytes that are
atomic in a write to a pipe.  When writing to a pipe, write requests of PIPE_BUF or less bytes will
not be interleaved with data from other processes doing writes on the same pipe.  However, write
requests greater than PIPE_BUF bytes may have data interleaved on arbitrary byte boundaries with
writes by other processes whether or not the O_NONBLOCK or O_NDELAY flag is set.

If the module packet size is at least the size of PIPE_BUF, the @dfn{Stream head} packages the data
in such a way that the first message is at least PIPE_BUF bytes.  The remaining data may be packaged
into smaller or larger blocks depending on buffer availability.  If the first module on the Stream
cannot support a packet of PIPE_BUF, atomic writes on the pipe cannot be guaranteed.

@subsubsection Closing a Pipe or FIFO

The close(2) system call closes a pipe or FIFO and dismantles its associated @dfn{Streams}.  On the
last close of one end of a pipe, an M_HANGUP message is sent upstream to the other end of the pipe.
Subsequent read(2) or getmsg(2) calls on that @dfn{Stream head} will return the number of bytes read
and zero when there are no more data.  Subsequent write(2) or putmsg(2) requests will fail with
ENXIO.  If the pipe has been mounted via fattach() the pipe must be unmounted prior to calling
close, otherwise the @dfn{Stream} will not be dismantled.  If the other end of the pipe is mounted,
the last close of the pipe will force it to be unmounted.

@node Flushing Pipes and FIFOs
@section Flushing Pipes and FIFOs

When the flush request is initiated from a user @command{ioctl} or from a flushq() routine, the
FLUSHR and/or FLUSHW bits of an M_FLUSH message will have to be switched.  The point of switching
the bits is the point where the M_FLUSH message is passed from a write queue to a read queue.  This
point is also known as the mid-point of the pipe.

The mid-point of a pipe is not always easily detectable, especially if there are numerous modules
pushed on either end of the pipe.  In that case, there needs to be a mechanism to intercept all
messages passing through the @dfn{Stream}.  If the message is an M_FLUSH message and it is at the
@dfn{Streams} mid-point, the flush bits need to switched.

This bit switching is handled by the pipemod module.  pipemod should be pushed onto a pipe or FIFO
where flushing of any kind will take place.  The pipemod module can be pushed on either end of the
pipe.  The only requirement is that it is pushed onto an end that previously did not have modules on
it.  That is, pipemod must be the first module pushed onto a pipe so that it is at the mid-point of
the pipe itself.

The pipemod module handles only M_FLUSH messages.  All other messages are passed on to the next
module via the putnext() utility routine.  If an M_FLUSH message is passed to pipemod and the FLUSHR
and FLUSHW bits are set, the message is not processed but is passed to the next module via the
putnext() routine.  If only the FLUSHR bit is set, the FLUSHR bit is turned off and the FLUSHW bit
is set.  The message is then passed to the next module via putnext.  Similarly, if the FLUSHW bit
was the only bit set in the M_FLUSH message, the FLUSHW bit is turned off and the FLUSHR bit is
turned on.  The message is then passed to the next module on the @dfn{Stream}.

The pipemod module can be pushed on any @dfn{Stream} that desires the bit switching.  It must be
pushed onto a pipe or FIFO if any form of flushing must take place.

@node Named Streams
@section Named Streams

Some applications may want to associate a @dfn{Stream} or @dfn{STREAMS}-based pipe with an existing
node in the file system name space.  For example, a server process may create a pipe, name one end
of the pipe, and allow unrelated processes to communicate with it over that named end.

@subsection fattach

A @dfn{STREAMS} file descriptor can be named by attaching that file descriptor to a node in the file
system name space.  The routine fattach() [see also fattach(3C)] is used to name a @dfn{STREAMS}
file descriptor.  @dfn{Stream}, fattach(3C) Its format is:

@example
int fattach (int fildes, char *path)
@end example

where fildes is an open file descriptor that refers to either a @dfn{STREAMS}-based pipe or a
@dfn{STREAMS} device driver (or a pseudo device driver), and path is an existing node in the file
system name space (for example, regular file, directory, character special file, etc).

The path cannot have a @dfn{Stream} already attached to it.  It cannot be a mount point for a file
system nor the root of a file system.  A user must be an owner of the path with write permission or
a user with the appropriate privileges in order to attach the file descriptor.

If the path is in use when the routine fattach() is executed, those processes accessing the path
will not be interrupted and any data associated with the path before the call to the fattach()
routine will continue to be accessible by those processes.

After a @dfn{Stream} is named, all subsequent operations [for example, open(2)] on the path will
operate on the named @dfn{Stream}.  Thus, it is possible that a user process has one file descriptor
pointing to the data originally associated with the path and another file descriptor pointing to a
named @dfn{Stream}.

Once the Stream has been named, the stat(2) system call on path will show information for the
@dfn{Stream}.  If the named @dfn{Stream} is a pipe, the stat(2) information will show that path is a
pipe.  If the @dfn{Stream} is a device driver or a pseudo device driver, path appears as a device.
The initial modes, permissions, and ownership of the named @dfn{Stream} are taken from the
attributes of the path.  The user can issue the system calls chmod(2) and chown(2) to alter the
attributes of the named @dfn{Stream} and not affect the original attributes of the path nor the
original attributes of the @dfn{STREAMS} file.

The size represented in the stat(2) information will reflect the number of unread bytes of data
currently at the @dfn{Stream head}.  This size is not necessarily the number of bytes written to the
@dfn{Stream}.

A @dfn{STREAMS}-based file descriptor can be attached to many different paths at the same time
(i.e., a @dfn{Stream} can have many names attached to it).  The modes, ownership, and permissions of
these paths may vary, but operations on any of these paths will access the same @dfn{Stream}.

Named @dfn{Streams} can have modules pushed on them, be polled, be passed as file descriptors, and
be used for any other @dfn{STREAMS} operation.

@subsection fdetach

A named @dfn{Stream} can be disassociated from a file name with the fdetach() routine [see also
fdetach(3C)] that has the following format:

@example
int fdetach (char *path)
@end example

where path is the name of the previously named @dfn{Stream}.  Only the owner of path or the user
with the appropriate privileges may disassociate the @dfn{Stream} from its name.  The @dfn{Stream}
may be disassociated from its name while processes are accessing it.  If these processes have the
named @dfn{Stream} open at the time of the fdetach() call, the processes will not get an error, and
will continue to access the @dfn{Stream}.  However, after the disassociation, subsequent operations
on path access the underlying file rather than the named @dfn{Stream}.

If only one end of the pipe is named, the last close of the other end will cause the named end to be
automatically detached.  If the named @dfn{Stream} is a device and not a pipe, the last close will
not cause the @dfn{Stream} to be detached.

If there is no named @dfn{Stream} or the user does not have access permissions on path or on the
named @dfn{Stream}, fdetach() returns -1 with errno set to EINVAL.  Otherwise, fdetach() returns 0
for success.

A @dfn{Stream} will remain attached with or without an active server process.  If a server aborted,
the only way a named @dfn{Stream} is cleaned up is if the server executed a clean up routine that
explicitly detached and closed down the @dfn{Stream}.

If the named @dfn{Stream} is that of a pipe with only one end attached, clean up will occur
automatically.  The named end of the pipe is forced to be detached when the other end closes down.
If there are no other references after the pipe is detached, the @dfn{Stream} is deallocated and
cleaned up.  Thus, a forced detach of a pipe end will occur when the server is aborted.

If the both ends of the pipe are named, the pipe remains attached even after all processes have
exited.  In order for the pipe to become detached, a server process would have to explicitly invoke
a program that executed the fdetach() routine.

To eliminate the need for the server process to invoke the program, the fdetach(1M) command can be
used.  This command accepts a path name that is a path to a named @dfn{Stream}.  When the command is
invoked, the @dfn{Stream} is detached from the path.  If the name was the only reference to the
@dfn{Stream}, the @dfn{Stream} is also deallocated.

A user invoking the fdetach(1M) command must be an owner of the named @dfn{Stream} or a user with
the appropriate permissions.

@subsection isastream

The function isastream() [see also isastream(3C)] may be used to determine if a file descriptor is
associated with a @dfn{STREAMS} device.  Its format is:

@example
int isastream (int fildes)
@end example

where fildes refers to an open file.  isastream() returns 1 if fildes represents a @dfn{STREAMS}
file, and 0 if not.  On failure, isastream() returns -1 with errno set to EBADF.

This function is useful for client processes communicating with a server process over a named Stream
to check whether the file has been overlaid by a @dfn{Stream} before sending any data over the file.

@subsection File Descriptor Passing

Named @dfn{Streams} are useful for passing file descriptors between unrelated processes.  A user
process can send a file descriptor to another process by invoking the @manpage{ioctl(2)} I_SENDFD on
one end of a named @dfn{Stream}.  This sends a message containing a file pointer to the @dfn{Stream
head} at the other end of the pipe.  Another process can retrieve that message containing the file
pointer by invoking the @manpage{ioctl(2)} I_RECVFD on the other end of the pipe.

@subsection Named Streams in A Remote Environment

If a user on the server machine creates a pipe and mounts it over a file that is part of an
advertised resource, a user on the client machine (that has remotely named the resource) may access
the remote named @dfn{Stream}.  A user on the client machine is not allowed to pass file descriptors
across the named @dfn{Stream} and will get an error when the @command{ioctl} request is attempted.
If a user on the client machine creates a pipe and attempts to attach it to a file that is a
remotely named resource, the system call will fail.

The following three examples are given as illustrations:

Suppose the server advertised a resource /dev/foo, created a @dfn{STREAMS}-based pipe, and attached
one end of the pipe onto /dev/foo/spipe.  All processes on the server machine will be able to access
the pipe when they open /dev/foo/spipe.  Now suppose that client XYZ mounts the advertised resource
/dev/foo onto its /mnt directory.  All processes on client XYZ will be able to access the
@dfn{STREAMS}-based pipe when they open /mnt/spipe.

If the server advertised another resource /dev/fog and client XYZ mounts that resource onto its
/install directory and then attaches a @dfn{STREAMS}-based pipe onto /install, the mount would fail
with errno set to EBUSY, because /install is already a mount point.  If client XYZ attached a pipe
onto /install/spipe, the mount would also fail with errno set to EREMOTE, because the mount would
require crossing an RFS (Remote File System) mount point.

Suppose the server advertised its /usr/control directory and client XYZ mounts that resource onto
its /tmp directory.  The server now creates a @dfn{STREAMS}-based pipe and attaches one end over its
/usr directory.  When the server opens /usr it will access the pipe.  On the other hand, when the
client opens /tmp it will access what is in the server's /usr/control directory.

@node Unique Connections
@section Unique Connections

With named pipes, client processes may communicate with a server process via a module called connld
that enables a client process to gain a unique, non-multiplexed connection to a server.  The connld
module can be pushed onto the named end of the pipe.  If connld is pushed on the named end of the
pipe and that end is opened by a client, a new pipe will be created.  One file descriptor for the
new pipe is passed back to a client (named @dfn{Stream}) as the file descriptor from the open(2)
system call and the other file descriptor is passed to the server.  The server and the client may
now communicate through a new pipe.

[Figure:10.2 Server Sets Up a Pipe]

[strm.saverset.gif]

[6]Figure:10.2 [7]Server Sets Up a Pipe illustrates a server process that has created a pipe and
pushed the connld module on the other end.  The server then invokes the fattach() routine to name
the other end /usr/toserv.

[Figure:10.3 Processes X and Y Open /usr/toserv]

[strm.xyopen.gif]

When process X (procx) opens /usr/toserv, it gains a unique connection to the server process that
was at one end of the original @dfn{STREAMS}-based pipe.  When process Y (procy) does the same, it
also gains a unique connection to the server.  As shown in [8]Figure:10.3 [9]Processes X and Y Open
/usr/toserv , the server process has access to three separate @dfn{STREAMS}-based pipes via three
file descriptors.

connld is a @dfn{STREAMS}-based module that has an open, close, and @command{put} procedure.  connld
is opened when the module is pushed onto the pipe for the first time and whenever the named end of
the pipe is opened.  The connld module distinguishes between these two opens by use of the q_ptr
field of its read queue.  On the first open, this field is set to 1 and the routine returns without
further processing.  On subsequent opens, the field is checked for 1 or 0.  If the 1 is present, the
connld module creates a pipe and sends the file descriptor to a client and a server.

[Boxnote.gif]

Making use of the q_ptr field eliminates the need to configure the connld module at boot time.  It
also eliminates the need to manage the number of times the module is either pushed and/or popped.

When the named @dfn{Stream} is opened, the open routine of connld is called.  The connld open will
fail if:

@itemize @bullet
@item The pipe ends can not be created.
@item A file pointer and file descriptor can not be allocated.
@item The @dfn{Stream head} can not stream the two pipe ends.
@item strioctl() fails while sending the file descriptor to the server.
@end itemize

The open is not complete until the server process has received the file descriptor using the
@command{ioctl} I_RECVFD.  The setting of the O_NDELAY or O_NONBLOCK flag has no impact on the open.

The connld module does not process messages.  All messages are passed to the next object in the
@dfn{Stream}.  The read and write @command{put} routines call putnext() (see @dfn{STREAMS}
Utilities) to send the message up or down the @dfn{Stream}.

@node STREAMS-based Terminal Subsystem
@chapter STREAMS-based Terminal Subsystem
@cindex STREAMS-based terminal subsystem
@menu
* Terminal Subsystem::		STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem
@end menu

@node Terminal Subsystem
@section Terminal Subsystem

@dfn{STREAMS} provides a uniform interface for implementing character I/O devices and networking
protocols in the kernel.  @cite{UNIX System V Release 4.0} implements the terminal subsystem in
@dfn{STREAMS}.  The @dfn{STREAMS}-based terminal subsystem (see [6]Figure:11.1
[7]@dfn{STREAMS}-based Terminal Subsystem ) provides many benefits:

@itemize @bullet
@item Reusable line discipline modules.  The same module can be used in many @dfn{STREAMS} where the
configuration of these @dfn{STREAMS} may be different.

@item Line discipline substitution.  Although @cite{UNIX System V} provides a standard terminal line
discipline module, another one conforming to the interface may be substituted.  For example, a
remote login feature may use the terminal subsystem line discipline module to provide a terminal
interface to the user.

@item Internationalization.  The modularity and flexibility of the @dfn{STREAMS}-based terminal subsystem
enables an easy implementation of a system that supports multiple byte characters for
internationalization.  This modularity also allows easy addition of new features to the terminal
subsystem.

@item Easy customizing.  Users may customize their terminal subsystem environment by adding and
removing modules of their choice.

@item The pseudo-terminal subsystem.  The pseudo-terminal subsystem can be easily supported (this is
discussed in more detail later in this chapter).

@item Merge with networking.  By pushing a line discipline module on a network line, one can make
the network look like a terminal line.

@end itemize

[Figure:11.1 @dfn{STREAMS}-based Terminal Subsystem]

[strm.termsys.gif]

The initial setup of the @dfn{STREAMS}-based terminal subsystem is handled with the ttymon(1M)
command within the framework of the Service Access Facility or the autopush feature.  The autopush
facility is discussed in Configuration.

The @dfn{STREAMS}-based terminal subsystem supports termio(7), the termios(2) specification of the
POSIX standard, multiple byte characters for internationalization, the interface to asynchronous
hardware flow control [see termiox(7)], and peripheral controllers for asynchronous terminals.
XENIX|Pr and BSD compatibility can also be provided by pushing the ttcompat module.  |Pr and BSD
compatibility can also be provided by pushing the ttcompat module.

@subsection Line Discipline Module

A @dfn{STREAMS} line discipline module called ldterm [see ldterm(7)] is a key part of the
@dfn{STREAMS}-based terminal subsystem.  Throughout this chapter, the terms line discipline and
ldterm are used interchangeably and refer to the @dfn{STREAMS} version of the standard line
discipline and not the traditional character version.  ldterm performs the standard terminal I/O
processing which was traditionally done through the linesw mechanism.

The termio and termios specifications describe four flags which are used to control the terminal:
c_iflag (defines input modes), c_oflag (defines output modes), c_cflag (defines hardware control
modes), and c_lflag (defines terminal functions used by ldterm).  In order to process these flags
elsewhere (for example, in the firmware or in another process), a mechanism is in place to turn on
and off the processing of these flags.  When ldterm is pushed, it sends an M_CTL message downstream
which asks the driver which flags the driver will process.  The driver sends back that message in
response if it needs to change ldterm's default processing.  By default, ldterm assumes that it must
process all flags except c_cflag, unless it receives a message telling otherwise.

@subsubsection Default Settings

When ldterm is pushed on the @dfn{Stream}, the open routine initializes the settings of the termio
flags.  The default settings are:

@table @var
@item c_iflag
@samp{= BRKINT|ICRNL|IXON|ISTRIP|IXANY |ICRNL|IXON|ISTRIP|IXANY}
@item c_oflag
@samp{= OPOST|ONLCR|TAB3 |ONLCR|TAB3}
@item c_cflag
@samp{= 0}
@item c_lflag
@samp{= ISIG|ICANON|ECHO|ECHOK |ICANON|ECHO|ECHOK}
@end table

In canonical mode (ICANON flag in c_lflag is turned on), read from the terminal file descriptor is
in message non-discard (RMSGN) mode [see streamio(7)].  This implies that in canonical mode, read on
the terminal file descriptor always returns at most one line regardless how many characters have
been requested.  In non-canonical mode, read is in byte-stream (RNORM) mode.

@subsubsection Data Structure

The ldterm module uses the following structure to maintain state information:

@smallexample
struct ldterm_mod @{
    mblk_t *t_savbp;            /* saved mblk that holds ld structure */
    struct termios t_modes;     /* effective modes set by the provider */
    struct termios t_amodes;    /* apparent modes for user programs */
    struct termios t_dmodes;    /* modes that driver wishes to process */
    unsigned long t_state;      /* internal state of tty module */
    int t_line;                 /* output line of tty */
    int t_col;                  /* output column of tty */
    int t_rocount;              /* number of characters echoed since last
                                   output */
    int t_rocol;                /* column in which first such character
                                   appeared */
    mblk_t *t_message;          /* pointer to 1st mblk in message being built */
    mblk_t *t_endmsg;           /* pointer to last mblk in that message */
    int t_msglen;               /* number of characters in that message */
    mblk_t *t_echomp;           /* echoed output being assembled */
    int t_rd_request;           /* number of bytes requested by M_READ during
                                   vmin/vtime read */
    int t_tid;                  /* vtime timer id */

    /* 
     * The following are for EUC processing.
     */

    unchar t_codeset;           /* current code set indicator - read-side */
    unchar t_eucleft;           /* bytes left to get in current character */
    unchar t_eucign;            /* bytes left to ignore - output post proc */
    unchar t_eucpad;            /* padding for eucwioc */
    eucioc_t eucwioc;           /* eucioc structure (have to use bcopy) */
    unchar *t_eucp;             /* pointer to parallel array of column widths */
    mblk_t *t_eucp_mp;          /* message block that holds parallel array */
    unchar t_maxeuc;            /* maximum length in memory bytes of an EUC */
    int t_eucwarn;              /* bad EUC counter */
@}
@end smallexample

@subsubsection Open and Close Routines

The open routine of the ldterm module allocates space for holding the tty structure (see tty.h) by
allocating a buffer from the @dfn{STREAMS} buffer pool.  The number of modules that can be pushed
depends on the availability of buffers.  The open also sends an M_SETOPTS message upstream to set
the Stream head high and low water marks to 512 and 128 respectively.

The ldterm module establishes a controlling tty for the line when an M_SETOPTS message (so_flags is
set to SO_ISTTY) is sent upstream.  The @dfn{Stream head} allocates the controlling tty on the open,
if one is not already allocated.

To maintain compatibility with existing applications that use the O_NDELAY flag, the open routine
sets the SO_NDLEON flag on in the so_flags field of the stroptions structure in the M_SETOPTS
message.

The open routine fails if there are no buffers available (cannot allocate the tty structure) or when
an interrupt occurs while sleeping for a buffer to become available.

The close routine frees all the outstanding buffers allocated by this @dfn{Stream}.  It also sends
an M_SETOPTS message to the @dfn{Stream head} to undo the changes made by the open routine.  The
ldterm module also sends M_START and M_STARTI messages downstream to undo the effect of any previous
M_STOP and M_STOPI messages.

@subsubsection Read-Side Processing

The ldterm module's read-side processing has @command{put} and @command{service} procedures.  High
and low water marks for the read queue are 512 and 200 respectively.

ldterm can send the following messages upstream:

ldterm(7) messages

M_DATA, M_BREAK, M_PCSIG, M_SIG, M_FLUSH, M_ERROR, M_IOCACK, M_IOCNAK, M_HANGUP, M_CTL, M_SETOPTS,
M_COPYOUT, and M_COPYIN (see Message Types).

The ldterm module's read-side processes M_BREAK, M_DATA, M_CTL, M_FLUSH, M_HANGUP, and M_IOCACK
messages.  All other messages are sent upstream unchanged.

The @command{put} procedure scans the message for flow control characters (IXON), signal generating
characters, and after (possible) transformation of the message, queues the message for the
@command{service} procedure.  Echoing is handled completely by the @command{service} procedure.

In canonical mode if the ICANON flag is on in c_lflag, canonical processing is performed.  If the
ICANON flag is off, non-canonical processing is performed [see termio(7) for more details].
Handling of VMIN/VTIME in the @dfn{STREAMS} environment is somewhat complicated, because read needs
to activate a timer in the ldterm module in some cases; hence, read notification becomes necessary.
When a user issues an @command{ioctl} to @command{put} ldterm in non-canonical mode, the ldterm
module sends an M_SETOPTS message to the @dfn{Stream head} to register read notification.  Further
reads on the terminal file descriptor will cause the @dfn{Stream head} to issue an M_READ message
downstream and data will be sent upstream in response to the M_READ message.  With read
notification, buffering of raw data is performed by ldterm.  It is possible to canonize the raw
data, when the user has switched from raw to canonical mode.  However, the reverse is not possible.

To summarize, in non-canonical mode, the ldterm module buffers all data until a request for the data
arrives in the form of an M_READ message.  The number of bytes sent upstream will be the argument of
the M_READ message.

The @command{service} procedure of ldterm handles @dfn{STREAMS} related flow control.  Since the
read-side high and low water marks are 512 and 200 respectively, placing more than 512 characters on
the ldterm's read queue will cause the QFULL flag be turned on indicating that the module below
should not send more data upstream.

Input flow control is regulated by the line discipline module by generating M_STARTI and M_STOPI
high priority messages.  When sent downstream, receiving drivers or modules take appropriate action
to regulate the sending of data upstream.  Output flow control is activated when ldterm receives
flow control characters in its data stream.  The ldterm module then sets an internal flag indicating
that output processing is to be restarted/stopped and sends an M_START/M_STOP message downstream.

@subsubsection Write-Side Processing

Write-side processing of the ldterm module is performed by the write-side @command{put} procedures.

The ldterm module supports the following ioctls:

TCSETA, TCSETAW, TCSETAF, TCSETS, TCSETSW, TCSETSF, TCGETA, TCGETS, TCXONC, TCFLSH, TCSBRK,
TIOCSWINSZ, TIOCGWINSZ, and JWINSIZE.

All ioctls not recognized by the ldterm module are passed downstream to the neighboring module or
driver.  BSD functionality is turned off by IEXTEN [see termio(7) for more details].

The following messages can be received on the write-side:

M_DATA, M_DELAY, M_BREAK, M_FLUSH, M_STOP, M_START, M_STOPI, M_STARTI, M_READ, M_IOCDATA, M_CTL, and
M_IOCTL.

On the write-side, the ldterm module processes M_FLUSH, M_DATA, M_IOCTL, and M_READ messages, and
all other message are passed downstream unchanged.

An M_CTL message is generated by ldterm as a query to the driver for an intelligent peripheral and
to decide on the functional split for termio processing.  If all or part of termio processing is
done by the intelligent peripheral, ldterm can turn off this processing to avoid computational
overhead.  This is done by sending an appropriate response to the M_CTL message, as follows: [see
also ldterm(7)].

* If all of the termio processing is done by the peripheral
hardware, the driver sends an M_CTL message back to ldterm with ioc_cmd of the structure iocblk set
to MC_NO_CANON.  If ldterm is to handle all termio processing, the driver sends an M_CTL message
with ioc_cmd set to MC_DO_CANON.  Default is MC_DO_CANON.
* If the peripheral hardware handles only part of the termio
processing, it informs ldterm in the following way: The driver for the peripheral device allocates
an M_DATA message large enough to hold a termios structure.  The driver then turns on those c_iflag,
c_oflag, and c_lflag fields of the termios structure that are processed on the peripheral device by
ORing the flag values.  The M_DATA message is then attached to the b_cont field of the M_CTL message
it received.  The message is sent back to ldterm with ioc_cmd in the data buffer of the M_CTL
message set to MC_PART_CANON.

The line discipline module does not check if write-side flow control is in effect before forwarding
data downstream.  It expects the downstream module or driver to queue the messages on its queue
until flow control is lifted.

@subsubsection EUC Handling in ldterm

The idea of letting post-processing (the o_flags) happen off the host processor is not recommended
unless the board software is prepared to deal with international (EUC) character sets properly.  The
reason for this is that post-processing must take the EUC information into account.  ldterm knows
about the screen width of characters (that is, how many columns are taken by characters from each
given code set on the current physical display) and it takes this width into account when
calculating tab expansions.  When using multi-byte characters or multi-column characters ldterm
automatically handles tab expansion (when TAB3 is set) and does not leave this handling to a lower
module or driver.

As an example, consider the 3B2 PORTS board that has a processor and runs firmware on the board that
can handle output post-processing.  However, the firmware on the PORTS board has no knowledge of EUC
unless one can change the firmware.  Therefore, with some EUC code sets, particularly those where
number of bytes in a character is not equivalent to the width of the character on the screen (for
example, 3 byte codes that take only 2 screen columns), the PORTS board's firmware miscalculates the
number of spaces required to expand the tab.  Hence, if the board is allowed to handle tab
expansion, it may get the expansion wrong in some cases.

By default multi-byte handling by ldterm is turned off.  When ldterm receives an EUC_WSET
@command{ioctl} call, it turns multi-byte processing on, if it is essential to properly handle the
indicated code set.  Thus, if one is using single byte 8-bit codes and has no special multi-column
requirements, the special multi-column processing is not used at all.  This means that multi-byte
processing does not reduce the processing speed or efficiency of ldterm unless it is actually used.

The following describes how the EUC handling in ldterm works:

First, the multi-byte and multi-column character handling is only enabled when the EUC_WSET
@command{ioctl} indicates that one of the following conditions is met:

@itemize @bullet
@item Code set consists of more than one byte (including the SS2 and/or SS3) ofcharacters, or

@item Code set requires more than one column to display on the current device, as indicated in the
EUC_WSET structure.

@end itemize

Assuming that one or more of the above conditions, EUC handling is enabled.  At this point, a
parallel array (see ldterm_mod structure) used for other information, is allocated and a pointer to
it is stored in t_eucp_mp.  The parallel array which it holds is pointed to by t_eucp.  The
t_codeset field holds the flag that indicates which of the code sets is currently being processed on
the read-side.  When a byte with the high bit arrives, it is checked to see if it is SS2 or SS3.  If
so, it belongs to code set 2 or 3.  Otherwise, it is a byte that comes from code set 1.  Once the
extended code set flag has been set, the input processor retrieves the subsequent bytes, as they
arrive, to build one multi-byte character.  The counter field t_eucleft tells the input processor
how many bytes remain to be read for the current character.  The parallel array t_eucp holds for
each logical character in the canonical buffer its display width.  During erase processing,
positions in the parallel array are consulted to figure out how many backspaces need to be sent to
erase each logical character.  (In canonical mode, one backspace of input erases one logical
character, no matter how many bytes or columns that character consumes.) This greatly simplifies
erase processing for EUC.

The t_maxeuc field holds the maximum length, in memory bytes, of the EUC character mapping currently
in use.  The eucwioc field is a sub-structure that holds information about each extended code set.

The t_eucign field aids in output post-processing (tab expansion).  When characters are output,
ldterm keeps a column to indicate what the current cursor column is supposed to be.  When it sends
the first byte of an extended character, it adds the number of columns required for that character
to the output column.  It then subtracts one from the total width in memory bytes of that character
and stores the result in t_eucign.  This field tells ldterm how many subsequent bytes to ignore for
the purposes of column calculation.  (ldterm calculates the appropriate number of columns when it
sees the first byte of the character.)

The field t_eucwarn is a counter for occurrences of bad extended characters.  It is mostly useful
for debugging.

There are two relevant files for handling multi-byte characters: euc.h and eucioctl.h.  The
eucioctl.h contains the structure that is passed with EUC_WSET and EUC_WGET calls.  The normal way
to use this structure is to get CSWIDTH (see note below) from the locale via a mechanism such as
getwidth or setlocale and then copy the values into the structure in eucioctl.h, and send the
structure via an I_STR @command{ioctl} call.  The EUC_WSET call informs the ldterm module about the
number of bytes in extended characters and how many columns the extended characters from each set
consume on the screen.  This allows ldterm to treat multi-byte characters as single entities for the
purpose of erase processing and to correctly calculate tab expansions for multi-byte characters.

[Boxnote.gif]

LC_CTYPE (instead of CSWIDTH) should be used in the environment in UXP/V systems.  See chrtbl(1M)
for more information.

The file euc.h has the structure with fields for EUC width, screen width, and wide character width.
The following functions are used to set and get EUC widths (these functions assume the environment
where the eucwidth_t structure is needed and available):

@smallexample
#include <sys/eucioctl.h>       /* need some other things too, like stropts.h */

struct eucioc eucw;             /* for EUC_WSET/EUC_WGET to line discipline */
eucwidth_t width;               /* return struct from_getwidth() */

/*
 * set_euc Send EUC code widths to line discipline.
 */
set_euc(e)
        struct eucioc *e;
@{
    struct strioctl sb;

    sb.ic_cmd = EUC_WSET;
    sb.ic_timout = 15;
    sb.ic_len = sizeof(struct eucioc);
    sb.ic_dp = (char *) e;

    if (ioctl(0, I_STR, &sb) < 0)
        fail();
@}

/*
 * euclook Get current EUC code widths from line discipline.
 */
euclook(e)
        struct eucioc *e;
@{
    struct strioctl sb;

    sb.ic_cmd = EUC_WGET;
    sb.ic_timout = 15;
    sb.ic_len = sizeof(struct eucioc);
    sb.ic_dp = (char *) e;
    if (ioctl(0, I_STR, &sb) < 0)
        fail();

    printf("CSWIDTH=%d:%d, %d:%d, %d:%d0",
           e->eucw[1], e->scrw[1],
           e->eucw[2], e->scrw[2], e->eucw[3], e->scrw[3]);
@}
@end smallexample

@subsection Support of termiox(7)

The brief discussion of multiple byte character handling by the ldterm module was provided here for
those interested in internationalization applications in UXP/V.  More detailed descriptions may be
obtained from product-related documents, for example, UXP/V Programmer's Guide:
Internationalization.

UXP/V includes the extended general terminal interface [see termiox(7)] that supplements the
termio(7) general terminal interface by adding for asynchronous hardware flow control, isochronous
flow control and clock modes, and local implementations of additional asynchronous features.
termiox(7) is handled by hardware drivers if the board (e.g., EPORTS) supports it.

Hardware flow control supplements the termio(7) IXON, IXOFF, and IXANY character flow control.  The
termiox(7) interface allows for both unidirectional and bidirectional hardware flow control.
Isochronous communication is a variation of asynchronous communication where two communicating
devices provide transmit and/or receive clock to each other.  Incoming clock signals can be taken
from the baud rate generator on the local isochronous port controller.  Outgoing signals are sent on
the receive and transmit baud rate generator on the local isochronous port controller.

Terminal parameters are specified in the termiox structure that is defined in the termiox.h.

@subsection Hardware Emulation Module

If a @dfn{Stream} supports a terminal interface, a driver or module that understands all ioctls to
support terminal semantics (specified by termio and termios) is needed.  If there is no hardware
driver that understands all @command{ioctl} commands downstream from the ldterm module, a hardware
emulation module must be placed downstream from the line discipline module.  The function of the
hardware emulation module is to understand and acknowledge the ioctls that may be sent to the
process at the @dfn{Stream head} and to mediate the passage of control information downstream.  The
combination of the line discipline module and the hardware emulation module behaves as if there were
an actual terminal on that @dfn{Stream}.

The hardware emulation module is necessary whenever there is no tty driver at the end of the
@dfn{Stream}.  For example, it is necessary in a pseudo-tty situation where there is process to
process communication on one system (this is discussed later in this chapter) and in a network
situation where a termio interface is expected (e.g., remote login) but there is no tty driver on
the @dfn{Stream}.

Most of the actions taken by the hardware emulation module are the same regardless of the underlying
architecture.  However, there are some actions that are different depending on whether the
communication is local or remote and whether the underlying transport protocol is used to support
the remote connection.  For example, NTTY is a hardware emulation module supported by AT&T in its
Starla networking environment.  This hardware emulation module behaves in a way understood by the
URP protocol driver that exists below NTTY.  On receipt of a TCSBRK @command{ioctl}, NTTY sends an
M_BREAK message downstream.  When the baud rate is 0, the hardware emulation module sends a TPI
message requesting a disconnect.  These actions are valid for a network situation but may not make
sense in other environments when there is no module/driver below to understand the TPI messages or
handle M_BREAK messages.

Each hardware emulation module has an open, close, read queue @command{put} procedure, and write
queue @command{put} procedure.

The hardware emulation module does the following:


@itemize @bullet
@item Processes, if appropriate, and acknowledges receipt of the following ioctls on its write queue
by sending an M_IOCACK message back upstream: TCSETA, TCSETAW, TCSETAF, TCSETS, TCSETSW, TCSETSF,
TCGETA, TCGETS, and TCSBRK.

@item Acknowledges the Extended @cite{UNIX} Code (EUC) ioctls.

@item If the environment supports windowing, it acknowledges the windowing ioctls TIOCSWINSZ,
TIOCGWINSZ, and JWINSIZE.  If the environment does not support windowing, an M_IOCNAK message is
sent upstream.

@item If any other ioctls are received on its write queue, it sends an M_IOCNAK message upstream.

@item When the hardware emulation module receives an M_IOCTL message of type TCSBRK on its write
queue, it sends an M_IOCACK message upstream and the appropriate message downstream.  For example,
an M_BREAK message could be sent downstream.

@item When the hardware emulation module receives an M_IOCTL message on its write queue to set the
baud rate to 0 (TCSETAW with CBAUD set to B0), it sends an M_IOCACK message upstream and an
appropriate message downstream; for networking situations this will probably be an M_PROTO message
which is a TPI T_DISCON_REQ message requesting the transport provider to disconnect.

@item All other messages (M_DATA, etc.) not mentioned here are passed to the next module or driver
in the @dfn{Stream}.

@end itemize

The hardware emulation module processes messages in a way consistent with the driver that exists
below.

@node Pseudo-Terminal Subsystem
@section Pseudo-Terminal Subsystem

The @dfn{STREAMS}-based pseudo-terminal subsystem provides the user with an interface that is
identical to the @dfn{STREAMS}-based terminal subsystem described earlier in this chapter.  The
pseudo-terminal subsystem (pseudo-tty) supports a pair of @dfn{STREAMS}-based devices called the
master device and slave device.  The slave device provides processes with an interface that is
identical to the terminal interface.  However, where all devices, which provide the terminal
interface, have some kind of hardware device behind them, the slave device has another process
manipulating it through the master half of the pseudo terminal.  Anything written on the master
device is given to the slave as an input and anything written on the slave device is presented as an
input on the master side.

[6]Figure:11.2 [7]Pseudo-tty Subsystem Architecture illustrates the architecture of the
@dfn{STREAMS}-based pseudo-terminal subsystem.  The master driver called ptm is accessed through the
clone driver [see clone(7)] and is the controlling part of the system.  The slave driver called pts
works with the line discipline module and the hardware emulation module to provide a terminal
interface to the user process.  An optional packetizing module called pckt is also provided.  It can
be pushed on the master side to support packet mode (this is discussed later).

The number of pseudo-tty devices that can be installed on a system is dependent on available memory.

@subsection Line Discipline Module

In the pseudo-tty subsystem, the line discipline module is pushed on the slave side to present the
user with the terminal interface.

ldterm may turn off the processing of the c_iflag, c_oflag, and c_lflag fields to allow processing
to take place elsewhere.  The ldterm module may also turn off all canonical processing when it
receives an M_CTL message with the MC_NO_CANON command in order to support remote mode (this is
discussed later).  Although ldterm passes through messages without processing them, the appropriate
flags are set when a "get" @command{ioctl}, such as TCGETA or TCGETS, is issued to indicate that
canonical processing is being performed.

[Figure:11.2 Pseudo-tty Subsystem Architecture]

[strm.ttysys.gif]

@subsection Pseudo-tty Emulation Module PTEM

Since the pseudo-tty subsystem has no hardware driver downstream from the ldterm module to process
the terminal @command{ioctl} calls, another module that understands the @command{ioctl} commands is
placed downstream from the ldterm.  This module, known as ptem, processes all of the terminal
@command{ioctl} commands and mediates the passage of control information downstream.

ldterm and ptem together behave like a real terminal.  Since there is no real terminal or modem in
the pseudo-tty subsystem, some of the @command{ioctl} commands are ignored and cause only an
acknowledgement of the command.  The ptem module keeps track of the terminal parameters set by the
various "set" commands such as TCSETA or TCSETAW but does not usually perform any action.  For
example, if one of the "set" ioctls is called, none of the bits in the c_cflag field of termio has
any effect on the pseudo terminal except if the baud rate is set to 0.  When setting the baud rate
to 0, it has the effect of hanging up the pseudo-terminal.

The pseudo-terminal has no concept of parity so none of the flags in the c_iflag that control the
processing of parity errors have any effect.  The delays specified in the c_oflag field are not also
supported.

The ptem module does the following:

@itemize @bullet
@item Processes, if appropriate, and acknowledges receipt of the following ioctls on its write queue
by sending an M_IOCACK message back upstream: TCSETA, TCSETAW, TCSETAF, TCSETS, TCSETSW, TCSETSF,
TCGETA, TCGETS, and TCSBRK.

@item Keeps track of the window size; information needed for the TIOCSWINSZ, TIOCGWINSZ, and
JWINSIZE @command{ioctl} commands.

@item When it receives any other @command{ioctl} on its write queue, it sends an M_IOCNAK message upstream.

@item It passes downstream the following ioctls after processing them: TCSETA, TCSETAW, TCSETAF,
TCSETS, TCSETSW, TCSETSF, TCSBRK, and TIOCSWINSZ.

@item ptem frees any M_IOCNAK messages it receives on its read queue in case the pckt module (pckt
is described later) is not on the pseudo terminal subsystem and the above ioctls get to the master's
@dfn{Stream head} which would then send an M_IOCNAK message.

@item In its open routine, the ptem module sends an M_SETOPTS message upstream requesting allocation
of a controlling tty.

@item When the ptem module receives an M_IOCTL message of type TCSBRK on its read queue, it sends an
M_IOCACK message downstream and an M_BREAK message upstream.

@item When it receives an @command{ioctl} message on its write queue to set the baud rate to 0 (TCSETAW with
CBAUD set to B0), it sends an M_IOCACK message upstream and a 0-length message downstream.

@item When it receives an M_IOCTL of type TIOCSIGNAL on its read queue, it sends an M_IOCACK
downstream and an M_PCSIG upstream where the signal number is the same as in the M_IOCTL message.

@item When the ptem module receives an M_IOCTL of type TIOCREMOTE on its read queue, it sends an
M_IOCACK message downstream and the appropriate M_CTL message upstream to enable/disable canonical
processing.

@item When it receives an M_DELAY message on its read or write queue, it discards the message and
does not act on it.

@item When it receives an M_IOCTL message with type JWINSIZE on its write queue and if the values in
the jwinsize structure of ptem are not zero, it sends an M_IOCACK message upstream with the jwinsize
structure.  If the values are zero, it sends an M_IOCNAK message upstream.

@item When it receives an M_IOCTL message of type TIOCGWINSZ on its write queue and if the values in
the winsize structure are not zero, it sends an M_IOCACK message upstream with the winsize
structure.  If the values are zero, it sends an M_IOCNAK message upstream.  It also saves the
information passed to it in the winsize structure and sends a @dfn{STREAMS} signal message for signal
SIGWINCH upstream to the slave process if the size changed.

@item When the ptem module receives an M_IOCTL message with type TIOCGWINSZ on its read queue and if
the values in the winsize structure are not zero, it sends an M_IOCACK message downstream with the
winsize structure.  If the values are zero, it sends an M_IOCNAK message downstream.  It also saves
the information passed to it in the winsize structure and sends a @dfn{STREAMS} signal message for signal
SIGWINCH upstream to the slave process if the size changed.

@item All other messages not mentioned above are passed to the next module or driver.

@end itemize

@subsubsection Data Structure

Each instantiation of the ptem module is associated with a local area.  These data are held in a
structure called ptem that has the following format:

@smallexample
struct ptem @{
    long cflags;                /* copy of c_flags */
    mblk_t *dack_ptr;           /* pointer to preallocated message block used
                                   to send disconnect */
    queue_t *q_ptr;             /* pointer to ptem's read queue */
    struct winsize wsz;         /* structure to hold windowing information */
    unsigned short state;       /* state of ptem entry */
@};
@end smallexample

When the ptem module is pushed onto the slave side @dfn{Stream}, a search of the ptem structure is
made for a free entry (state is not set to INUSE).  The c_cflags of the termio structure and the
windowing variables are stored in cflags and wsz respectively.  The dack_ptr is a pointer to a
message block used to send a 0-length message whenever a hang-up occurs on the slave side.

@subsubsection Open and Close Routines

In the open routine of ptem a @dfn{STREAMS} message block is allocated for a 0-length message for
delivering a hang-up message; this allocation of a buffer is done before it is needed to ensure that
a buffer is available.  An M_SETOPTS message is sent upstream to set the read-side @dfn{Stream head}
queues, to assign high and low water marks(512 and 256 respectively), and to establish a controlling
terminal.

The default values B300, CS8, CREAD, and HUPCL are assigned to cflags, and INUSE to the state field.

The open routine fails if:

@itemize @bullet
@item No free entries are found when the ptem structure is searched.
@item sflag is not set to MODOPEN.
@item A 0-length message can not be allocated (no buffer is available).
@item A stroptions structure cannot be allocated.
@end itemize

The close routine is called on the last close of the slave side @dfn{Stream}.  Pointers to read and write
queue are cleared and the buffer for the 0-length message is freed.

@subsection Remote Mode

A feature known as remote mode is available with the pseudo-tty subsystem.  This feature is used for
applications that perform the canonical function normally done by the ldterm module and tty driver.
The remote mode allows applications on the master side to turn off the canonical processing.  An ]
is issued on the master side to enter the remote mode.  When this occurs, an M_CTL message with the
command MC_NO_CANON is sent to the ldterm module indicating that data should be passed when received
on the read-side and no canonical processing is to take place.  The remote mode may be disabled by
ioctl(fd, TIOCREMOTE, 0).

@subsection Packet Mode

The @dfn{STREAMS}-based pseudo-terminal subsystem also supports a feature called packet mode.  This is
used to inform the process on the master side when state changes have occurred in the pseudo-tty.
Packet mode is enabled by pushing the pckt module on the master side.  Data written on the master
side is processed normally.  When data are written on the slave side or when other messages are
encountered by the pckt module, a header is added to the message so it can be subsequently retrieved
by the master side with a getmsg operation.

The pckt module does the following:

@itemize @bullet

@item When a message is passed to this module on its write queue, the module does noprocessing and
passes the message to the next module or driver.

@item The pckt module creates an M_PROTO message when one of the following messages is passed to it:
M_DATA, M_IOCTL, M_PROTO/M_PCPROTO, M_FLUSH, M_START/M_STOP, M_STARTI/M_STOPI, and M_READ.

All other messages are passed through.  The M_PROTO message is passed upstream and retrieved when
the user issues getmsg(2).

@item If the message is an M_FLUSH message, pckt does the following: If the flag is FLUSHW, it is
changed to FLUSHR (because FLUSHR was the original flag before the pts driver changed it),
packetized into an M_PROTO message, and passed upstream.  To prevent the @dfn{Stream head}'s read
queue from being flushed, the original M_FLUSH message must not be passed upstream.

If the flag is FLUSHR, it is changed to FLUSHW, packetized into an M_PROTO message, and passed
upstream.  In order to flush of the write queues properly, an M_FLUSH message with the FLUSHW flag
set is also sent upstream.

If the flag is FLUSHRW, the message with both flags set is packetized and passed upstream.  An
M_FLUSH message with the FLUSHW flag set is also sent upstream.

@end itemize

@subsection Pseudo-tty Drivers ptm and pts

In order to use the pseudo-tty subsystem, a node for the master side driver /dev/ptmx and N number
of slave drivers (N is determined at installation time) must be installed.  The names of the slave
devices are /dev/pts/M where M has the values 0 through N-1.  A user accesses a pseudo-tty device
through the master device (called ptm) that in turn is accessed through the clone driver [see
clone(7)].  The master device is set up as a clone device where its major device number is the major
for the clone device and its minor device number is the major for the ptm driver.

The master pseudo driver is opened via the open(2) system call with /dev/ptmx as the device to be
opened.  The clone open finds the next available minor device for that major device; a master device
is available only if it and its corresponding slave device are not already open.  There are no nodes
in the file system for master devices.

When the master device is opened, the corresponding slave device is automatically locked out.  No
user may open that slave device until it is unlocked.  A user may invoke a function grantpt that
will change the owner of the slave device to that of the user who is running this process, change
the group id to tty, and change the mode of the device to 0620.  Once the permissions have been
changed, the device may be unlocked by the user.  Only the owner or super-user can access the slave
device.  The user must then invoke the unlockpt function to unlock the slave device.slave driver,
open Before opening the slave device, the user must call the ptsname function to obtain the name of
the slave device.  The functions grantpt, unlockpt, and ptsname are called with the file descriptor
of the master device.  The user may then invoke the open system call with the name that was returned
by the ptsname function to open the slave device.

The following example shows how a user may invoke the pseudo-tty subsystem:

@smallexample
    int fdm, fds;
    char *slavename;
    extern char *ptsname();

    fdm = open("/dev/ptmx", O_RDWR);    /* open master */
    grantpt(fdm);               /* change permission of slave */
    unlockpt(fdm);              /* unlock slave */
    slavename = ptsname(fdm);   /* get name of slave */
    fds = open(slavename, O_RDWR);      /* open slave */
    ioctl(fds, I_PUSH, "ptem"); /* push ptem */
    ioctl(fds, I_PUSH, "ldterm");       /* push ldterm */
@end smallexample

Unrelated processes may open the pseudo device.  The initial user may pass the master file
descriptor using a @dfn{STREAMS}-based pipe or a slave name to another process to enable it to open
the slave.  After the slave device is open, the owner is free to change the permissions.

[Boxnote.gif]

Certain programs such as write and wall are set group-id (setgid) to tty and are also able to access
the slave device.

After both the master and slave have been opened, the user has two file descriptors which provide
full duplex communication using two @dfn{Streams}.  The two @dfn{Streams} are automatically
connected.  The user may then push modules onto either side of the @dfn{Stream}.  The user also
needs to push the ptem and ldterm modules onto the slave side of the pseudo-terminal subsystem to
get terminal semantics.

The master and slave drivers pass all @dfn{STREAMS} messages to their adjacent queues.  Only the
M_FLUSH needs some processing.  Because the read queue of one side is connected to the write queue
of the other, the FLUSHR flag is changed to FLUSHW flag and vice versa.

When the master device is closed, an M_HANGUP message is sent to the slave device which will render
the device unusable.  The process on the slave side gets the errno ENXIO when attempting to write on
that @dfn{Stream} but it will be able to read any data remaining on the @dfn{Stream head} read
queue.  When all the data have been read, read returns 0 indicating that the @dfn{Stream} can no
longer be used.

On the last close of the slave device, a 0-length message is sent to the master device.  When the
application on the master side issues a read or getmsg and 0 is returned, the user of the master
device decides whether to issue a close that dismantles the pseudo-terminal subsystem.  If the
master device is not closed, the pseudo-tty subsystem will be available to another user to open the
slave device.

Since 0-length messages are used to indicate that the process on the slave side has closed and
should be interpreted that way by the process on the master side, applications on the slave side
should not write 0-length messages.  If that occurs, the write returns 0, and the 0-length message
is discarded by the ptem module.

The standard @dfn{STREAMS} system calls can access the pseudo-tty devices.  The slave devices
support the O_NDELAY and O_NONBLOCK flags.  Since the master side does not act like the terminal, if
O_NONBLOCK or O_NDELAY is set, read on the master side returns with errno set to EAGAIN if no data
are available, and write returns -1 with errno set to EAGAIN if there is internal flow control.

The master driver supports the ISPTM and UNLKPT ioctls that are used by the functions grantpt,
unlockpt, and ptsname [see grantpt(3C), unlockpt(3C), ptsname(3C)].  The @command{ioctl} ISPTM
determines whether the file descriptor is that of an open master device.  On success, it returns the
major/minor number (type dev_t) of the master device which can be used to determine the name of the
corresponding slave device.  The @command{ioctl} UNLKPT unlocks the master and slave devices.  It
returns 0 on success.  On failure, the errno is set to EINVAL indicating that the master device is
not open.

The format of these commands is:

@example
int ioctl(fd, command, arg)
    int fd, command, arg
@end example

where command is either ISPTM or UNLKPT and arg is 0.  On failure, -1 is returned.

When data are written to the master side, the entire block of data written is treated as a single
line.  The slave side process reading the terminal receives the entire block of data.  Data are not
input edited by the ldterm module regardless of the terminal mode.  The master side application is
responsible for detecting an interrupt character and sending an interrupt signal SIGINT to the
process in the slave side. This can be done as follows:

@example
ioctl(fd, TIOCSIGNAL, SIGINT)
@end example

where SIGINT is defined in the file signal.h.  When a process on the master side issues this
@command{ioctl}, the argument is the number of the signal that should be sent.  The specified signal
is then sent to the process group on the slave side.

To summarize, the master driver and slave driver have the following characteristics:

@itemize @bullet

@item Each master driver has one-to-one relationship with a slave devicebased on major/minor device
numbers.

@item Only one open is allowed on a master device.  Multiple opens are allowed on the slave device
according to standard file mode and ownership permissions.

@item Each slave driver minor device has a node in the file system.

@item An open on a master device automatically locks out an open on the corresponding slave driver.

@item A slave cannot be opened unless the corresponding master is open and has unlocked the slave.

@item To provide a tty interface to the user, the ldterm and ptem modules are pushed on the slave
side.

@item A close on the master sends a hang-up to the slave and renders both @dfn{Streams} unusable after all
data have been consumed by the process on the slave side.

@item The last close on the slave side sends a 0-length message to the master but does not sever the
connection between the master and slave drivers.

@end itemize

@subsubsection grantpt

The grantpt function changes the mode and the ownership of the slave device that is associated with
the given master device.  Given a file descriptor fd, grantpt first checks that the file descriptor
is that of the master device.  If so, it obtains the name of the associated slave device and sets
the user id to that of the user running the process and the group id to tty.  The mode of the slave
device is set to 0620.

If the process is already running as root, the permission of the slave can be changed directly
without invoking this function.  The interface is:

@example
grantpt(int fd);
@end example

The grantpt function returns 0 on success and -1 on failure.  It fails if one or more of the
following occurs: fd is not an open file descriptor, fd is not associated with a master device, the
corresponding slave could not be accessed, or a system call failed because no more processes could
be created.

@subsubsection unlockpt

The unlockpt function clears a lock flag associated with a master/slave device pair.  Its interface
is:

@example
unlockpt(int fd);
@end example

The unlockpt returns 0 on success and -1 on failure.  It fails if one or more of the following
occurs: fd is not an open file descriptor or fd is not associated with a master device.

@subsubsection ptsname

The ptsname function returns the name of the slave device that is associated with the given master
device.  It first checks that the file descriptor is that of the master.  If it is, it then
determines the name of the corresponding slave device /dev/pts/ and returns a pointer to a string
containing the null-terminated path name.  The return value points to static data whose content is
overwritten by each call.  The interface is:

@example
char *ptsname(int fd)
@end example

The ptsname function returns a non-NULL path name upon success and a NULL pointer upon failure.  It
fails if one or more of the following occurs: fd is not an open file descriptor or fd is not
associated with the master device.

@node Reference
@chapter Reference
@cindex reference
@menu
* Files::			STREAMS Files
* Modules::			STREAMS Modules
* Drivers::			STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions
@end menu

@node Files
@section Files
@cindex files

@subsection User Header Files

@unnumberedsubsubsec STREAMS

@table @file

@item stropts.h
@pgindex stropts.h
User include file for the @cite{STREAMS} options file.  This file includes ioctl definitions for the
@dfn{Stream Head}.  This file includes @file{<sys/stropts.h>}.
Files are organized this way for backward compatibility of header file locations.

@item sys/stropts.h
@pgindex sys/stropts.h
System include file for the @cite{STREAMS} options file.  This file includes ioctl definitions for
the @dfn{Stream Head}.  This file is included by @file{<stropts.h>}.
Files are organized this way for backward compatibility of header file locations.

@end table

@unnumberedsubsubsec STREAMS logger

@table @file

@item log.h
@pgindex log.h
User include file for the @dfn{STREAMS} logger.

@item sys/log.h
@pgindex sys/log.h

@item strlog.h
@pgindex strlog.h
User include file for the @dfn{STREAMS} logger.

@item sys/strlog.h
@pgindex sys/strlog.h

@end table

@unnumberedsubsubsec STREAMS Administrative Driver

@table @file

@item sad.h
@pgindex sad.h
User include file for the @cite{STREAMS Administrative Driver}.

@item sys/sc.h
@pgindex sys/sc.h

@item sys/sad.h
@pgindex sys/sad.h

@end table

@subsection System Header Files

@unnumberedsubsubsec STREAMS

@table @file

@item sys/stream.h
@pgindex sys/stream.h

@item sys/strsubr.h
@pgindex sys/strsubr.h

@item sys/strconf.h
@pgindex sys/strconf.h

@item sys/strdebug.h
@pgindex sys/strdebug.h

@end table

@unnumberedsubsubsec DDI/DKI

@table @file

@item sys/debug.h
@pgindex sys/debug.h

@item sys/kmem.h
@pgindex sys/kmem.h

@item sys/cmn_err.h
@pgindex sys/cmn_err.h

@item sys/dki.h
@pgindex sys/dki.h

@item sys/ddi.h
@pgindex sys/ddi.h
DDI/DKI function declarations and defines for @dfn{@value{PACKAGE_TITLE}}.  Extension definitions will
be included when one or more of
@var{_LFS_SOURCE},
@vindex _LFS_SOURCE
@var{_SVR4_SOURCE},
@vindex _SVR4_SOURCE
@var{_AIX_SOURCE},
@vindex _AIX_SOURCE
@var{_HPUX_SOURCE},
@vindex _HPUX_SOURCE
@var{_OSF_SOURCE},
@vindex _OSF_SOURCE
@var{_SUN_SOURCE},
@vindex _SUN_SOURCE
@var{_LIS_SOURCE} or
@vindex _LIS_SOURCE
@var{_UW7_SOURCE} are
@vindex _UW7_SOURCE
defined.

@item sys/svr4ddi.h
@pgindex sys/svr4ddi.h
SVR4 DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_SVR4_SOURCE}
@vindex _SVR4_SOURCE
is defined.

@item sys/aixddi.h
@pgindex sys/aixddi.h
AIX DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_AIX_SOURCE}
@vindex _AIX_SOURCE
is defined.

@item sys/hpuxddi.h
@pgindex sys/hpuxddi.h
HP-UX DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_HPUX_SOURCE}
@vindex _HPUX_SOURCE
is defined.

@item sys/osfddi.h
@pgindex sys/osfddi.h
OSF DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_OSF_SOURCE}
@vindex _OSF_SOURCE
is defined.

@item sys/sunddi.h
@pgindex sys/sunddi.h
Solaris DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_SUN_SOURCE}
@vindex _SUN_SOURCE
is defined.

@item sys/lisddi.h
@pgindex sys/lisddi.h
LiS DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_LIS_SOURCE}
@vindex _LIS_SOURCE
is defined.

@item sys/uw7ddi.h
@pgindex sys/uw7ddi.h
UnixWare DDI compatibility function declarations and defines.  This file should not be included
directly, but will be included from @file{<sys/ddi.h>} when
@var{_UW7_SOURCE}
@vindex _UW7_SOURCE
is defined.

@end table

@unnumberedsubsubsec Miscellaneous

@table @file

@item sys/spec_fs_i.h
@pgindex sys/spec_fs_i.h

@item sys/streams/config.h
@pgindex sys/streams/config.h

@end table

@node Modules
@section Modules
@cindex STREAMS, modules
@cindex modules, STREAMS

@menu
* Stream Head Module ("sth")::
* Connect Line Discipline Module ("connld")::
* Pipe Module ("pipemod")::
* STREAMS Configuration Module ("sc")::
@end menu

@node Stream Head Module ("sth")
@subsection Stream Head Module ("sth")
@pgindex sth(4)
@cindex sth, module
@cindex modules, sth
@cindex Stream Head, module
@cindex modules, Stream Head

@node Connect Line Discipline Module ("connld")
@subsection Connect Line Discipline Module ("connld")
@pgindex connld(4)
@cindex connld, module
@cindex modules, connld

@node Pipe Module ("pipemod")
@subsection Pipe Module ("pipemod")
@pgindex pipemod(4)
@cindex pipemod, module
@cindex modules, pipemod
@cindex Pipe Module, module
@cindex modules, Pipe Module

@node STREAMS Configuration Module ("sc")
@subsection STREAMS Configuration Module ("sc")
@pgindex sc(4)
@cindex sc, module
@cindex modules, sc
@cindex STREAMS Configuration, module
@cindex modules, STREAMS Configuration


@node Drivers
@section Drivers
@cindex STREAMS, drivers
@cindex drivers, STREAMS

@menu
* Clone Driver ("clone")::
* Echo Driver ("echo")::
* FIFO Driver ("fifo")::
* Log Driver ("log")::
* Named STREAMS Device Driver ("nsdev")::
* Null STREAM Driver ("nuls")::
* Pipe Driver ("pipe")::
* STREAMS Administrative Driver ("sad")::
@end menu


@node Clone Driver ("clone")
@subsection Clone Driver ("clone")
@pgindex clone(4)
@cindex clone, driver
@cindex drivers, clone
@cindex Clone, driver
@cindex drivers, Clone

@node Echo Driver ("echo")
@subsection Echo Driver ("echo")
@pgindex echo(4)
@cindex echo, driver
@cindex drivers, echo
@cindex Echo, driver
@cindex drivers, Echo

@node FIFO Driver ("fifo")
@subsection FIFO Driver ("fifo")
@pgindex fifo(4)
@cindex fifo, driver
@cindex drivers, fifo
@cindex FIFO, driver
@cindex drivers, FIFO

@node Log Driver ("log")
@subsection Log Driver ("log")
@pgindex log(4)
@cindex log, driver
@cindex drivers, log
@cindex Log, driver
@cindex drivers, Log

@node Named STREAMS Device Driver ("nsdev")
@subsection Named STREAMS Device Driver ("nsdev")
@pgindex nsdev(4)
@cindex nsdev, driver
@cindex drivers, nsdev
@cindex Named STREAMS Device, driver
@cindex drivers, Named STREAMS Device

@node Null STREAM Driver ("nuls")
@subsection Null STREAM Driver ("nuls")
@pgindex nuls(4)
@cindex nuls, driver
@cindex drivers, nuls
@cindex Null STREAM, driver
@cindex drivers, Null STREAM

@node Pipe Driver ("pipe")
@subsection Pipe Driver ("pipe")
@pgindex pipe(4)
@cindex pipe, driver
@cindex drivers, pipe
@cindex Pipe, driver
@cindex drivers, Pipe

@node STREAMS Administrative Driver ("sad")
@subsection STREAMS Administrative Driver ("sad")
@pgindex sad(4)
@cindex sad, driver
@cindex drivers, sad
@cindex STREAMS Administrative Driver, driver
@cindex drivers, STREAMS Administrative Driver


@node System Calls
@section System Calls
@cindex system calls

@subsection New System Calls

Just as experienced by the @b{Linux STREAMS} project, @dfn{@value{PACKAGE_TITLE}} suffers from the
inability to hook system calls that have been, otherwise, reserved in the @b{Linux} kernel for use
by @cite{STREAMS}.  Therefore, these system calls are implemented as library calls in the
@file{libsttreams} library instead of as system calls in the @file{libc} library.

@multitable @columnfractions .20 .80
@item @command{getmsg(2)}
@findex getmsg(2)
@command{getmsg(2)}
@findex getmsg(2)
@tab is not normally implemented as a system call: it is a library call that calls
@command{getpmsg(2)}.
@findex getpmsg(2)
@item @command{getpmsg(2)}
@findex getpmsg(2)
@tab --
@item @command{putmsg(2)}
@findex putmsg(2)
@command{putmsg(2)}
@findex putmsg(2)
@tab is not normally implemented as a system call: it is a library call that calls
@command{putpmsg(2)}.
@findex putpmsg(2)
@item @command{putpmsg(2)}
@findex putpmsg(2)
@tab --
@item @command{fattach(2)}
@findex fattach(2)
@tab --
@item @command{fdetach(2)}
@findex fdetach(2)
@tab (Note: HP-UX mentions a fdetach system call: I do not know why.)
@item @command{isastream(2)}
@findex isastream(2)
@tab --
@end multitable

@subsection Modifications to Old System Calls

@multitable @columnfractions .20 .80
@item @command{pipe(2)}
@findex pipe(2)
@tab --
@item @command{open(2)}
@findex open(2)
@tab --
@item @command{fcntl(2)}
@findex fcntl(2)
@tab --
@item @command{ioctl(2)}
@findex ioctl(2)
@tab --
@item @command{signal(2)}
@findex signal(2)
@tab --
@item @command{poll(2)}
@findex poll(2)
@tab --
@item @command{select(2)}
@findex select(2)
@tab --
@item @command{read(2)}
@findex read(2)
The @command{read(2)}
@findex read(2)
@tab system call is overloaded with an invalid length to implement the @command{getmsg(2)}
@findex getmsg(2)
and @command{getpmsg(2)}
@findex getpmsg(2)
system calls.
@item @command{readv(2)}
@findex readv(2)
@tab --
@item @command{write(2)}
@findex write(2)
@tab The @command{write(2)}
@findex write(2)
system call is overloaded with an invalid length to implement the @command{putmsg(2)}
@findex putmsg(2)
and @command{putpmsg(2)}
@findex putpmsg(2)
system calls.
@item @command{writev(2)}
@findex writev(2)
@tab --
@item @command{close(2)}
@findex close(2)
@tab --
@end multitable

@node Input-Output Controls
@section Input-Output Controls
@cindex STREAMS, input-output controls
@cindex input-output controls, STREAMS

@multitable @columnfractions .20 .80
@item @var{I_NREAD}
@vindex I_NREAD
@tab --
@item @var{I_PUSH}
@vindex I_PUSH
@tab --
@item @var{I_POP}
@vindex I_POP
@tab --
@item @var{I_LOOK}
@vindex I_LOOK
@tab --
@item @var{I_FLUSH}
@vindex I_FLUSH
@tab --
@item @var{I_SRDOPT}
@vindex I_SRDOPT
@tab --
@item @var{I_GRDOPT}
@vindex I_GRDOPT
@tab --
@item @var{I_STR}
@vindex I_STR
@tab --
@item @var{I_SETSIG}
@vindex I_SETSIG
@tab --
@item @var{I_GETSIG}
@vindex I_GETSIG
@tab --
@item @var{I_FIND}
@vindex I_FIND
@tab --
@item @var{I_LINK}
@vindex I_LINK
@tab --
@item @var{I_UNLINK}
@vindex I_UNLINK
@tab --
@item @var{I_RECVFD}
@vindex I_RECVFD
@tab non-EFT definition
@item @var{I_PEEK}
@vindex I_PEEK
@tab --
@item @var{I_FDINSERT}
@vindex I_FDINSERT
@tab --
@item @var{I_SENDFD}
@vindex I_SENDFD
@tab --
@item @var{I_E_RECVFD}
@vindex I_E_RECVFD
@tab @cite{Unixware}: EFT definition
@item @var{I_SWROPT}
@vindex I_SWROPT
@tab --
@item @var{I_GWROPT}
@vindex I_GWROPT
@tab --
@item @var{I_LIST}
@vindex I_LIST
@tab --
@item @var{I_PLINK}
@vindex I_PLINK
@tab --
@item @var{I_PUNLINK}
@vindex I_PUNLINK
@tab --
@item @var{I_FLUSHBAND}
@vindex I_FLUSHBAND
@tab --
@item @var{I_CKBAND}
@vindex I_CKBAND
@tab --
@item @var{I_GETBAND}
@vindex I_GETBAND
@tab --
@item @var{I_ATMARK}
@vindex I_ATMARK
@tab --
@item @var{I_SETCLTIME}
@vindex I_SETCLTIME
@tab --
@item @var{I_GETCLTIME}
@vindex I_GETCLTIME
@tab --
@item @var{I_CANPUT}
@vindex I_CANPUT
@tab --
@item @var{I_SERROPT}
@vindex I_SERROPT
@tab @cite{Solaris} only
@item @var{I_GERROPT}
@vindex I_GERROPT
@tab @cite{Solaris} only
@item @var{I_ANCHOR}
@vindex I_ANCHOR
@tab @cite{Solaris} only
@item @var{I_S_RECVFD}
@vindex I_S_RECVFD
@tab @cite{UnixWare} only
@item @var{I_STATS}
@vindex I_STATS
@tab @cite{UnixWare} only
@item @var{I_BIGPIPE}
@vindex I_BIGPIPE
@tab @cite{UnixWare} only
@item @var{I_GETTP}
@vindex I_GETTP
@tab @cite{UnixWare} only
@item @var{I_AUTOPUSH}
@vindex I_AUTOPUSH
@tab @cite{Mac OT} only
@item @var{I_HEAP_REPORT}
@vindex I_HEAP_REPORT
@tab @cite{Mac OT} only
@item @var{I_FIFO}
@vindex I_FIFO
@tab @cite{Mac OT} only
@item @var{I_PUTPMSG}
@vindex I_PUTPMSG
@tab @cite{LiS} and @cite{Mac OT}
@item @var{I_GETPMSG}
@vindex I_GETPMSG
@tab @cite{LiS} and @cite{Mac OT}
@item @var{I_FATTACH}
@vindex I_FATTACH
@tab @cite{LiS} only
@item @var{I_FDETACH}
@vindex I_FDETACH
@tab @cite{LiS} only
@item @var{I_PIPE}
@vindex I_PIPE
@tab @cite{LiS} and @cite{Mac OT}
@end multitable

@node Module Entry Points
@section Module entry points
@cindex module entry points

@multitable @columnfractions .20 .80
@item @command{qopen(9)}
@findex qopen(9)
@tab Module queue open procedure.
@item @command{put(9)}
@findex put(9)
@tab Module queue put procedure.
@item @command{srv(9)}
@findex srv(9)
@tab Module queue service procedure.
@item @command{qadmin(9)}
@findex qadmin(9)
@tab Module queue administrative procedure.
@item @command{qclose(9)}
@findex qclose(9)
@tab Module queue close procedure.
@item @command{timeout(9)}
@findex timeout(9)
@tab Timeout callback.
@item @command{qtimeout(9)}
@findex qtimeout(9)
@tab Timeout callback.
@item @command{bufcall(9)}
@findex bufcall(9)
@tab Buffer callback.
@item @command{qbufcall(9)}
@findex qbufcall(9)
@tab Buffer callback.
@item @command{mi_bufcall(9)}
@findex mi_bufcall(9)
@tab Buffer callback.
@item @command{freemsg(9)}
@findex freemsg(9)
@tab Buffer free routine callout.
@end multitable

@node Structures
@section Structures
@cindex structures

@subsection STREAMS Structures

@unnumberedsubsubsec Driver Structures

@multitable @columnfractions .20 .80
@item @code{cdevsw(9)}
@tpindex cdevsw(9)
@tab Character device switch table.
@item @code{devinfo(9)}
@tpindex devinfo(9)
@tab Device information structure.
@end multitable

@unnumberedsubsubsec Module Structures

@multitable @columnfractions .20 .80
@item @code{fmodsw(9)}
@tpindex fmodsw(9)
@tab Module switch table.
@item @code{modinfo(9)}
@tpindex modinfo(9)
@tab Module information structure.
@item @code{module_info(9)}
@tpindex module_info(9)
@tab Module information structure.
@item @code{module_stat(9)}
@tpindex module_stat(9)
@tab Module statistics structure.
@end multitable

@unnumberedsubsubsec Stream Structures

@multitable @columnfractions .20 .80
@item @code{streamtab(9)}
@tpindex streamtab(9)
@tab Stream information table.
@item @code{streamadm(9)}
@tpindex streamadm(9)
@tab Stream administration table.
@item @code{stdata(9)}
@tpindex stdata(9)
@tab Stream head data structure.
@item @code{shinfo(9)}
@tpindex shinfo(9)
@tab Stream head information structure.
@end multitable

@unnumberedsubsubsec Queue Structures

@multitable @columnfractions .20 .80
@item @code{queue(9)}
@tpindex queue(9)
@tab Message queue.
@item @code{qband(9)}
@tpindex qband(9)
@tab Message queue band.
@item @code{bandinfo(9)}
@tpindex bandinfo(9)
@tab Message queue band information structure.
@item @code{qinit(9)}
@tpindex qinit(9)
@tab Message queue initialization.
@item @code{queinfo(9)}
@tpindex queinfo(9)
@tab Message queue information structure.
@end multitable

@unnumberedsubsubsec Message Structures

@multitable @columnfractions .20 .80
@item @code{msgb(9)}
@tpindex msgb(9)
@tab Message block.
@item @code{datab(9)}
@tpindex datab(9)
@tab Data block.
@item @code{mbinfo(9)}
@tpindex mbinfo(9)
@tab Message block information structure.
@item @code{dbinfo(9)}
@tpindex dbinfo(9)
@tab Data block information structure.
@end multitable

@unnumberedsubsubsec Ancilliary Structures

@multitable @columnfractions .20 .80
@item @code{strevent(9)}
@tpindex strevent(9)
@tab STREAMS event structure.
@item @code{seinfo(9)}
@tpindex seinfo(9)
@tab STREAMS event information structure.
@item @code{strapush(9)}
@tpindex strapush(9)
@tab STREAMS autopush structure.
@item @code{apinfo(9)}
@tpindex apinfo(9)
@tab STREAMS autopush information structure.
@end multitable

@unnumberedsubsubsec Additional Structures

@multitable @columnfractions .20 .80
@item @code{cred_t(9)}
@tpindex cred_t(9)
@tab User credentials.
@end multitable

@node Registration
@section Registration
@cindex registration

@subsection @value{PACKAGE_TITLE} Registration

@unnumberedsubsubsec Registration

@multitable @columnfractions .30 .70
@item @command{register_clone(9)}
@findex register_clone(9)
@tab Register a clone minor device number for a @cite{STREAMS} driver.
@item @command{unregister_clone(9)}
@findex unregister_clone(9)
@tab Unregister a clone minor device number for a @cite{STREAMS} driver.
@item @command{register_cmajor(9)}
@findex register_cmajor(9)
@tab Register file operations against a major device number.
@item @command{unregister_cmajor(9)}
@findex unregister_cmajor(9)
@tab Unregister file operations against a major device number.
@item @command{register_strdev(9)}
@findex register_strdev(9)
@tab Register a @cite{STREAMS} device against a device major number.
@item @command{unregister_strdev(9)}
@findex unregister_strdev(9)
@tab Unregister a @cite{STREAMS} device against a device major number.
@item @command{register_strdrv(9)}
@findex register_strdrv(9)
@tab Register a @cite{STREAMS} driver.
@item @command{unregister_strdrv(9)}
@findex unregister_strdrv(9)
@tab Unregister a @cite{STREAMS} driver.
@item @command{register_strmod(9)}
@findex register_strmod(9)
@tab Register a @cite{STREAMS} module.
@item @command{unregister_strmod(9)}
@findex unregister_strmod(9)
@tab Unregister a @cite{STREAMS} module.
@item @command{register_strnod(9)}
@findex register_strnod(9)
@tab Register a @cite{STREAMS} minor device node.
@item @command{unregister_strnod(9)}
@findex unregister_strnod(9)
@tab Unregister a @cite{STREAMS} minor device node.
@end multitable

@unnumberedsubsubsec Autopush

@multitable @columnfractions .25 .75
@item @command{autopush_add(9)}
@findex autopush_add(9)
@tab Add an autopush list entry for a given @cite{STREAMS} device number.
@item @command{autopush_del(9)}
@findex autopush_del(9)
@tab Delete an autopush list entry for a given @cite{STREAMS} device number.
@item @command{autopush_find(9)}
@findex autopush_find(9)
@tab Find an autopush list entry for a given @cite{STREAMS} device number.
@item @command{autopush_vml(9)}
@findex autopush_vml(9)
@tab Verify an autopush @cite{STREAMS} module list.
@end multitable

@unnumberedsubsubsec Administration

@multitable @columnfractions .20 .80
@item @command{getadmin(9)}
@findex getadmin(9)
@tab Get the administration function pointer for a @cite{STREAMS} module.
@item @command{getmid(9)}
@findex getmid(9)
@tab Get the @cite{STREAMS} module identifier by module name.
@end multitable

@node Message Handling
@section Message Handling
@cindex message handling

@subsection STREAMS Message Handling Utilities

@multitable @columnfractions .20 .80
@item @command{allocb(9)}
@findex allocb(9)
@tab Allocate a @cite{STREAMS} message and data block.
@item @command{esballoc(9)}
@findex esballoc(9)
@tab Allocate a @cite{STREAMS} message and data block with a caller supplied data buffer.
@item @command{testb(9)}
@findex testb(9)
@tab Test if a @cite{STREAMS} message can be allocated.
@item @command{bufcall(9)}
@findex bufcall(9)
@tab Install a @cite{STREAMS} buffer callback.
@item @command{unbufcall(9)}
@findex unbufcall(9)
@tab Remove a @cite{STREAMS} buffer callback.
@item @command{copyb(9)}
@findex copyb(9)
@tab Copy a @cite{STREAMS} message block.
@item @command{copymsg(9)}
@findex copymsg(9)
@tab Copy a @cite{STREAMS} message.
@item @command{dupb(9)}
@findex dupb(9)
@tab Duplicate a @cite{STREAMS} message block.
@item @command{dupmsg(9)}
@findex dupmsg(9)
@tab Duplicate a @cite{STREAMS} message.
@item @command{linkb(9)}
@findex linkb(9)
@tab Link a message block into a @cite{STREAMS} message.
@item @command{unlinkb(9)}
@findex unlinkb(9)
@tab Unlink a message block from a @cite{STREAMS} message.
@item @command{rmvb(9)}
@findex rmvb(9)
@tab Remove a message block from a @cite{STREAMS} message.
@item @command{adjmsg(9)}
@findex adjmsg(9)
@tab Trim bytes from the front or back of a @cite{STREAMS} message.
@item @command{msgpullup(9)}
@findex msgpullup(9)
@tab Pull up bytes in a @cite{STREAMS} message.
@item @command{pullupmsg(9)}
@findex pullupmsg(9)
@tab Pull up the bytes in a @cite{STREAMS} message.
@item @command{freeb(9)}
@findex freeb(9)
@tab Frees a @cite{STREAMS} message block.
@item @command{freemsg(9)}
@findex freemsg(9)
@tab Frees a @cite{STREAMS} message.
@item @command{datamsg(9)}
@findex datamsg(9)
@tab Tests a @cite{STREAMS} message type for data.
@item @command{msgdsize(9)}
@findex msgdsize(9)
@tab Calculates the size of the data in a @cite{STREAMS} message.
@item @command{pcmsg(9)}
@findex pcmsg(9)
@tab Test a @cite{STREAMS} data block message type for priority control.
@end multitable

@node Queue Handling
@section Queue Handling
@cindex queue handling

@subsection UP Queue Handling Functions

@multitable @columnfractions .20 .80
@item @command{backq(9)}
@findex backq(9)
@tab Find the upstream or downstream @cite{STREAMS} message queue.
@item @command{RD(9)}
@findex RD(9)
@tab Return the read queue of a @cite{STREAMS} queue pair.
@item @command{WR(9)}
@findex WR(9)
@tab Return the write queue of a @cite{STREAMS} queue pair.
@item @command{OTHERQ(9)}
@findex OTHERQ(9)
@tab Return the other queue of a @cite{STREAMS} queue pair.
@item @command{SAMESTR(9)}
@findex SAMESTR(9)
@tab Test for @cite{STREAMS} pipe or FIFO.
@item @command{qsize(9)}
@findex qsize(9)
@tab Return the number of messages on a @cite{STREAMS} message queue.
@item @command{bcanput(9)}
@findex bcanput(9)
@tab Test banded flow control on a @cite{STREAMS} message queue.
@item @command{canput(9)}
@findex canput(9)
@tab Test flow control on a @cite{STREAMS} message queue.
@item @command{qenable(9)}
@findex qenable(9)
@tab Schedule a @cite{STREAMS} message queue service routine.
@item @command{canenable(9)}
@findex canenable(9)
@tab Test whether a @cite{STREAMS} message queue can be scheduled.
@item @command{enableok(9)}
@findex enableok(9)
@tab Allow a @cite{STREAMS} message queue to be scheduled.
@item @command{noenable(9)}
@findex noenable(9)
@tab Disable a @cite{STREAMS} message queue from being scheduled.
@item @command{flushband(9)}
@findex flushband(9)
@tab Flushes band @cite{STREAMS} messages from a @cite{STREAMS} message queue.
@item @command{flushq(9)}
@findex flushq(9)
@tab Flushes messages from a @cite{STREAMS} message queue.
@item @command{getq(9)}
@findex getq(9)
@tab Gets a message from a @cite{STREAMS} message queue.
@item @command{insq(9)}
@findex insq(9)
@tab Insert a message into a @cite{STREAMS} message queue.
@item @command{rmvq(9)}
@findex rmvq(9)
@tab Remove a message from a @cite{STREAMS} message queue.
@item @command{qreply(9)}
@findex qreply(9)
@tab Reply to a message from a @cite{STREAMS} message queue.
@item @command{putq(9)}
@findex putq(9)
@tab Put a message onto a @cite{STREAMS} message queue.
@item @command{putbq(9)}
@findex putbq(9)
@tab Put a message back on a @cite{STREAMS} message queue.
@item @command{putctl(9)}
@findex putctl(9)
@tab Put a control message on a @cite{STREAMS} message queue.
@item @command{putctl1(9)}
@findex putctl1(9)
@tab Put a 1 byte control message on a @cite{STREAMS} message queue.
@end multitable

@subsection MP Queue Handling Functions

@multitable @columnfractions .20 .80
@item @command{bcanputnext(9)}
@findex bcanputnext(9)
@tab Test for banded flow control beyond a @cite{STREAMS} message queue.
@item @command{canputnext(9)}
@findex canputnext(9)
@tab Test for flow control beyond a @cite{STREAMS} message queue.
@item @command{put(9)}
@findex put(9)
@tab Invoke the put procedure for a @cite{STREAMS} module or driver with a @cite{STREAMS} message.
@item @command{putnext(9)}
@findex putnext(9)
@tab Put a message beyond a @cite{STREAMS} message queue.
@item @command{putnextctl1(9)}
@findex putnextctl1(9)
@tab Put a one byte control message beyond a @cite{STREAMS} message queue.
@item @command{putnextctl(9)}
@findex putnextctl(9)
@tab Put a control message beyond a @cite{STREAMS} message queue.
@item @command{qprocsoff(9)}
@findex qprocsoff(9)
@tab Disable a @cite{STREAMS} message queue for multi-processing.
@item @command{qprocson(9)}
@findex qprocson(9)
@tab Enable a @cite{STREAMS} message queue for multi-processing.
@item @command{freezestr(9)}
@findex freezestr(9)
@tab Freeze the state of a @cite{STREAMS} message queue.
@item @command{unfreezestr(9)}
@findex unfreezestr(9)
@tab Thaw the state of a @cite{STREAMS} message queue.
@item @command{strqget(9)}
@findex strqget(9)
@tab Gets information about a @cite{STREAMS} message queue.
In the non-@i{MP} environment, it was typical to directly access the elements of the @var{queue}
structure.  In the @i{MP} environment, it is no longer safe to directly access elements of the
@var{queue} structure in this fashion.  The @command{strqget(9)}
@findex strqget(9)
function provides the ability to retrieve information about @cite{STREAMS} message queues in the
@i{MP} environment.
@item @command{strqset(9)}
@findex strqset(9)
@tab Sets attributes of a @cite{STREAMS} message queue.
In the non-@i{MP} environment, it was typical to directly access the elements of the @var{queue}
structure.  In the @i{MP} environment, it is no longer safe to directly access elements of the
@var{queue} structure in this fashion.  The @command{strqset(9)}
@findex strqset(9)
function provides the ability to set attributes for @cite{STREAMS} message queues in the
@i{MP} environment.
@end multitable

@node Miscellaneous Functions
@section Miscellaneous Functions
@cindex miscellaneous functions

@subsection Miscellaneous DDI/DKI Functions

@unnumberedsubsubsec Memory Functions

@multitable @columnfractions .25 .75
@item @command{kmem_alloc(9)}
@findex kmem_alloc(9)
@tab Allocate kernel memory.
@item @command{kmem_free(9)}
@findex kmem_free(9)
@tab Deallocate kernel memory.
@item @command{kmem_zalloc(9)}
@findex kmem_zalloc(9)
@tab Allocate and zero kernel memory.
@item @command{kmem_fast_alloc(9)}
@findex kmem_fast_alloc(9)
@tab Allocate kernel memory, fast.
@item @command{kmem_fast_free(9)}
@findex kmem_fast_free(9)
@tab Deallocate kernel memory, fast.
@end multitable

@unnumberedsubsubsec Data Movement and Comparison

@multitable @columnfractions .20 .80
@item @command{bcopy(9)}
@findex bcopy(9)
@tab Copy byte strings.
@item @command{bzero(9)}
@findex bzero(9)
@tab Zero a byte string.
@item @command{copyin(9)}
@findex copyin(9)
@tab Copy user data in from user space to kernel space.
@item @command{copyout(9)}
@findex copyout(9)
@tab Copy user data out to user space from kernel space.
@item @command{max(9)}
@findex max(9)
@tab Determine the maximum of two integers.
@item @command{min(9)}
@findex min(9)
@tab Determine the minimum of two integers.
@end multitable

@unnumberedsubsubsec Device Numbers

@multitable @columnfractions .20 .80
@item @command{getmajor(9)}
@findex getmajor(9)
@tab Get the internal major device number for a device.
@item @command{getminor(9)}
@findex getminor(9)
@tab Get the internal minor device number for a device.
@item @command{makedevice(9)}
@findex makedevice(9)
@tab Create a device from major and minor device numbers.
@end multitable

@unnumberedsubsubsec Timers

@multitable @columnfractions .20 .80
@item @command{delay(9)}
@findex delay(9)
@tab Postpone the calling process for a number of clock ticks.
@item @command{timeout(9)}
@findex timeout(9)
@tab Start a timer.
@item @command{untimeout(9)}
@findex untimeout(9)
@tab Stop a timer.
@end multitable

@unnumberedsubsubsec Time, Process and Privilege

@multitable @columnfractions .20 .80
@item @command{drv_getparm(9)}
@findex drv_getparm(9)
@tab Driver retrieval of kernel parameters.
@item @command{drv_hztomsec(9)}
@findex drv_hztomsec(9)
@tab Convert kernel tick time between microseconds or milliseconds.
@item @command{drv_hztousec(9)}
@findex drv_hztousec(9)
@tab Convert kernel tick time between microseconds or milliseconds.
@item @command{drv_msectohz(9)}
@findex drv_msectohz(9)
@tab Convert kernel tick time between microseconds or milliseconds.
@item @command{drv_priv(9)}
@findex drv_priv(9)
@tab Check if the current process is privileged.
@item @command{drv_usectohz(9)}
@findex drv_usectohz(9)
@tab Convert kernel tick time between microseconds or milliseconds.
@item @command{drv_usecwait(9)}
@findex drv_usecwait(9)
@tab Delay for a number of microseconds.
@end multitable

@unnumberedsubsubsec Error Logging

@multitable @columnfractions .20 .80
@item @command{cmn_err(9)}
@findex cmn_err(9)
@tab Print a kernel command error.
@item @command{strlog(9)}
@findex strlog(9)
@tab Pass a message to the @cite{STREAMS} logger.
@end multitable

@unnumberedsubsubsec File Manipulation

@multitable @columnfractions .20 .80
@item @command{mknod(9)}
@findex mknod(9)
@tab Create a device node.
@item @command{mount(9)}
@findex mount(9)
@tab Mount a file system.
@item @command{umount(9)}
@findex umount(9)
@tab Unmount a file system.
@item @command{unlink(9)}
@findex unlink(9)
@tab Unlink a file.
@end multitable

@node Extensions
@section Extensions
@cindex extensions

There are a number of extensions to @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
@cite{STREAMS} that have been applied by implementations over the years.  Some of these extensions
are common enough across multiple implementations to be considered part of the @i{ipso facto}
standard for @cite{STREAMS}.  @b{Linux Fast-STREAMS} implements these functions are part of the core
set of @cite{STREAMS} functions.

@subsection Common Extensions

@multitable @columnfractions .20 .80
@item @command{linkmsg(9)}
@findex linkmsg(9)
@tab Link a message block to a @cite{STREAMS} message.
@item @command{putctl2(9)}
@findex putctl2(9)
@tab Put a two byte control message on a @cite{STREAMS} message queue.
@item @command{putnextctl2(9)}
@findex putnextctl2(9)
@tab Put a two byte control message on the next @cite{STREAMS} message queue.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld two (or four) @cite{STREAMS} message queues together.
@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two (or four) @cite{STREAMS} message queues.
@end multitable

@subsection @value{PACKAGE_TITLE} Extensions

@unnumberedsubsubsec Internal Queue Functions

@multitable @columnfractions .20 .80
@item @command{allocq(9)}
@findex allocq(9)
@tab Allocate a @cite{STREAMS} queue pair.
@item @command{setq(9)}
@findex setq(9)
@tab Set sizes and procedures associated with a @cite{STREAMS} message queue.
@item @command{qattach(9)}
@findex qattach(9)
@tab Attach a module onto a @cite{STREAMS} file.
@item @command{qopen(9)}
@findex qopen(9)
@tab Call a @cite{STREAMS} module or driver open routine.
@item @command{qclose(9)}
@findex qclose(9)
@tab Closes a @cite{STREAMS} module or driver.
@item @command{qdetach(9)}
@findex qdetach(9)
@tab Detach a module from a @cite{STREAMS} file.
@item @command{freeq(9)}
@findex freeq(9)
@tab Deallocate a @cite{STREAMS} queue pair.
@end multitable

@unnumberedsubsubsec Flow Control

@multitable @columnfractions .20 .80
@item @command{bcanget(9)}
@findex bcanget(9)
@tab Test for message arrival on a band on a stream.
@item @command{canget(9)}
@findex canget(9)
@tab Test for message arrival on a stream.
@end multitable

@subsection Extensions from LiS 2.18.1
@cindex extensions from LiS 2.18.1
@cindex LiS 2.18.1, extensions
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@multitable @columnfractions .30 .70
@item @command{appq(9)}
@findex appq(9)
@tab Append on @cite{STREAMS} message after another.
@item @command{esbbcall(9)}
@findex esbbcall(9)
@tab Install a buffer callback for an extended @cite{STREAMS} message block.
@item @command{isdatablk(9)}
@findex isdatablk(9)
@tab Test a @cite{STREAMS} data block for data type.
@item @command{isdatamsg(9)}
@findex isdatamsg(9)
@tab Test a @cite{STREAMS} data block for data type.
@item @command{kmem_zalloc_node(9)}
@findex kmem_zalloc_node(9)
@tab (undoc).
@item @command{msgsize(9)}
@findex msgsize(9)
@tab Calculate the size of the message blocks in a @cite{STREAMS} message.
@item @command{qcountstrm(9)}
@findex qcountstrm(9)
@tab Add all counts on all @cite{STREAMS} message queues in a stream.
@item @command{xmsgsize(9)}
@findex xmsgsize(9)
@tab Calculate the size of message blocks in a @cite{STREAMS} message.
@end multitable

@node Compatibility
@section Compatibility
@cindex compatibility

@subsection SVR 4.2 MP DDI/DKI Compatibility Functions
@cindex SVR 4.2 MP, compatibility functions
@cindex compatibility functions, SVR 4.2 MP
@cindex SVR 4.2 MP

@subsubheading @cite{SVR 4.2 MP} Core Functions
@cindex core functions, SVR 4.2 MP
@cindex SVR 4.2 MP, core functions
@cindex SVR 4.2 MP

@multitable @columnfractions .20 .80
@item @command{lbolt(9)}
@findex lbolt(9)
Time in ticks since reboot.
@end multitable

@subsubheading @cite{SVR 4.2 MP} Compatibility Module
@cindex compatibility module, SVR 4.2 MP
@cindex SVR 4.2 MP, compatibility module
@cindex SVR 4.2 MP

@multitable @columnfractions .20 .80
@item @command{itimeout(9)}
@findex itimeout(9)
@tab Perform a timeout at an interrupt level.
@item @command{major(9)}
@findex major(9)
@tab Get the internal major number of a device.
@item @command{makedev(9)}
@findex makedev(9)
@tab Make a device number from internal major and minor device numbers.
@item @command{minor(9)}
@findex minor(9)
@tab Get the internal minor number of a device.
@item @command{sleep(9)}
@findex sleep(9)
@tab Put a process to sleep.
@item @command{vtop(9)}
@findex vtop(9)
@tab Convert virtual to physical address.
@item @command{wakeup(9)}
@findex wakeup(9)
@tab Wake a process.
@end multitable

@unnumberedsubsubsec Atomic Integers

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating atomic integers.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating atomic integers.
These functions are general purpose and not @cite{STREAMS}-specific.
For portability of @cite{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @command{ATOMIC_INT_ADD(9)}
@findex ATOMIC_INT_ADD(9)
@tab Add an integer value to an atomic integer.
@item @command{ATOMIC_INT_ALLOC(9)}
@findex ATOMIC_INT_ALLOC(9)
@tab Allocate and initialize an atomic integer.
@item @command{ATOMIC_INT_DEALLOC(9)}
@findex ATOMIC_INT_DEALLOC(9)
@tab Deallocate an atomic integer.
@item @command{ATOMIC_INT_DECR(9)}
@findex ATOMIC_INT_DECR(9)
@tab Decrement and test an atomic integer.
@item @command{ATOMIC_INT_INCR(9)}
@findex ATOMIC_INT_INCR(9)
@tab Increment an atomic integer.
@item @command{ATOMIC_INT_INIT(9)}
@findex ATOMIC_INT_INIT(9)
@tab Initialize an atomic integer.
@item @command{ATOMIC_INT_READ(9)}
@findex ATOMIC_INT_READ(9)
@tab Read an atomic integer.
@item @command{ATOMIC_INT_SUB(9)}
@findex ATOMIC_INT_SUB(9)
@tab Subtract and integer value from an atomic integer.
@item @command{ATOMIC_INT_WRITE(9)}
@findex ATOMIC_INT_WRITE(9)
@tab Write an integer value to an atomic integer.
@end multitable

@unnumberedsubsubsec Basic Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating basic (spin) locks.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating spin locks.
These functions are general purpose and not @cite{STREAMS}-specific.
For portability of @cite{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @command{LOCK(9)}
@findex LOCK(9)
@tab Lock a basic lock.
@item @command{LOCK_ALLOC(9)}
@findex LOCK_ALLOC(9)
@tab Allocate a basic lock.
@item @command{LOCK_DEALLOC(9)}
@findex LOCK_DEALLOC(9)
@tab Deallocate a basic lock.
@item @command{LOCK_OWNED(9)}
@findex LOCK_OWNED(9)
@tab Determine whether a basic lock is head by the caller.
@item @command{TRYLOCK(9)}
@findex TRYLOCK(9)
@tab Try to lock a basic lock.
@item @command{UNLOCK(9)}
@findex UNLOCK(9)
@tab Unlock a basic lock.
@end multitable

@unnumberedsubsubsec STREAMS Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
defines a set of @cite{STREAMS}-specific locks.  The @b{Linux} kernel
@cindex Linux
does not provide these functions.  @dfn{@value{PACKAGE_TITLE}} has some equivalent internal functions.
For portability of @cite{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @command{MPSTR_QLOCK(9)}
@findex MPSTR_QLOCK(9)
@tab Release a queue from exclusive access.
@item @command{MPSTR_QRELE(9)}
@findex MPSTR_QRELE(9)
@tab Acquire a queue for exclusive access.
@item @command{MPSTR_STPLOCK(9)}
@findex MPSTR_STPLOCK(9)
@tab Acquire a stream head for exclusive access.
@item @command{MPSTR_STPRELE(9)}
@findex MPSTR_STPRELE(9)
@tab Release a stream head from exclusive access.
@end multitable

@unnumberedsubsubsec Read/Write Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating read-write locks.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating spin locks.
These functions are general purpose and not @cite{STREAMS}-specific.
For portability of @cite{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @command{RW_ALLOC(9)}
@findex RW_ALLOC(9)
@tab Allocate and initialize a read/write lock.
@item @command{RW_DEALLOC(9)}
@findex RW_DEALLOC(9)
@tab Deallocate a read/write lock.
@item @command{RW_RDLOCK(9)}
@findex RW_RDLOCK(9)
@tab Acquire a read/write lock in read mode.
@item @command{RW_TRYRDLOCK(9)}
@findex RW_TRYRDLOCK(9)
@tab Attempt to acquire a read/write lock in read mode.
@item @command{RW_TRYWRLOCK(9)}
@findex RW_TRYWRLOCK(9)
@tab Attempt to acquire a read/write lock in write mode.
@item @command{RW_UNLOCK(9)}
@findex RW_UNLOCK(9)
@tab Release a read/write lock.
@item @command{RW_WRLOCK(9)}
@findex RW_WRLOCK(9)
@tab Acquire a read/write lock in write mode.
@end multitable

@unnumberedsubsubsec Priority Levels

@multitable @columnfractions .20 .80
@item @command{spl0(9)}
@findex spl0(9)
@tab Set priority level 0.
@item @command{spl1(9)}
@findex spl1(9)
@tab Set priority level 1.
@item @command{spl2(9)}
@findex spl2(9)
@tab Set priority level 2.
@item @command{spl3(9)}
@findex spl3(9)
@tab Set priority level 3.
@item @command{spl4(9)}
@findex spl4(9)
@tab Set priority level 4.
@item @command{spl5(9)}
@findex spl5(9)
@tab Set priority level 5.
@item @command{spl7(9)}
@findex spl6(9)
@tab Set priority level 6.
@item @command{spl7(9)}
@findex spl7(9)
@tab Set priority level 7.
@item @command{spl(9)}
@findex spl(9)
@tab Set priority level.
@item @command{splx(9)}
@findex splx(9)
@tab Set priority level x.
@end multitable

@unnumberedsubsubsec Sleep Locks

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating sleep locks.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating semaphores.
These functions are general purpose and not @cite{STREAMS}-specific.
For portability of @cite{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @command{SLEEP_ALLOC(9)}
@findex SLEEP_ALLOC(9)
@tab Allocate a sleep lock.
@item @command{SLEEP_DEALLOC(9)}
@findex SLEEP_DEALLOC(9)
@tab Deallocate a sleep lock.
@item @command{SLEEP_LOCK(9)}
@findex SLEEP_LOCK(9)
@tab Acquire a sleep lock.
@item @command{SLEEP_LOCKAVAIL(9)}
@findex SLEEP_LOCKAVAIL(9)
@tab Determine whether a sleep lock is available.
@item @command{SLEEP_LOCKOWNED(9)}
@findex SLEEP_LOCKOWNED(9)
@tab Determine whether a sleep lock is held by the caller.
@item @command{SLEEP_LOCK_SIG(9)}
@findex SLEEP_LOCK_SIG(9)
@tab Acquire a sleep lock.
@item @command{SLEEP_TRYLOCK(9)}
@findex SLEEP_TRYLOCK(9)
@tab Attempt to acquire a sleep lock.
@item @command{SLEEP_UNLOCK(9)}
@findex SLEEP_UNLOCK(9)
@tab Release a sleep lock.
@end multitable

@unnumberedsubsubsec Synchronization Variables

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
provides a set of functions for manipulating synchronization variables.  The @b{Linux} kernel
@cindex Linux
also has a set of equivalent functions for manipulating wait queues.
These functions are general purpose and not @cite{STREAMS}-specific.
For portability of @cite{STREAMS} drivers and modules that utilize the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions, these functions have been added to the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
Compatibility Module.

@multitable @columnfractions .30 .70
@item @command{SV_ALLOC(9)}
@findex SV_ALLOC(9)
@tab Allocate a basic condition variable.
@item @command{SV_BROADCAST(9)}
@findex SV_BROADCAST(9)
@tab Broadcast a basic condition variable.
@item @command{SV_DEALLOC(9)}
@findex SV_DEALLOC(9)
@tab Deallocate a basic condition variable.
@item @command{SV_SIGNAL(9)}
@findex SV_SIGNAL(9)
@tab Signal a basic condition variable.
@item @command{SV_WAIT(9)}
@findex SV_WAIT(9)
@tab Wait on a basic condition variable.
@item @command{SV_WAIT_SIG(9)}
@findex SV_WAIT_SIG(9)
@tab Interruptible wait on a basic condition variable.
@end multitable

@unnumberedsubsubsec Resource Allocation

@multitable @columnfractions .30 .70
@item @command{rmalloc(9)}
@findex rmalloc(9)
@tab Allocate a number of units from a resource map.
@item @command{rmallocmap(9)}
@findex rmallocmap(9)
@tab Allocated a resource map.
@item @command{rmallocmap_wait(9)}
@findex rmallocmap_wait(9)
@tab Allocated a resource map.
@item @command{rmalloc_wait(9)}
@findex rmalloc_wait(9)
@tab Allocate a number of units from a resource map.
@item @command{rmfree(9)}
@findex rmfree(9)
@tab Free a number of units from a resource map.
@item @command{rmfreemap(9)}
@findex rmfreemap(9)
@tab Free a resource map.
@item @command{rmget(9)}
@findex rmget(9)
@tab Allocated a number of units from a resource map.
@item @command{rminit(9)}
@findex rminit(9)
@tab Initialize a resource map.
@item @command{rmsetwant(9)}
@findex rmsetwant(9)
@tab Wait for resources on a resource map.
@item @command{rmwanted(9)}
@findex rmwanted(9)
@tab Waiters on a resource map.
@end multitable

@subsection AIX 5L Version 5.1 Compatibility Functions
@cindex AIX 5L Version 5.1, compatibility functions
@cindex compatibility functions, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1
@cindex AIX PSE
@cindex AIX

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the @cite{AIX
5L Version 5.1 Portable STREAMS Environment (PSE)}:

@subsubheading @cite{AIX} Core Functions
@cindex core functions, AIX
@cindex AIX, core functions
@cindex AIX

The functions in this section are provided as part of the core functions provided in the @b{Linux
Fast-STREASM} @cite{STREAMS} subsystem:

@multitable @columnfractions .20 .80
@item @command{putctl2(9)}
@findex putctl2(9)
@tab Put a 2 byte control message on a @cite{STREAMS} message queue.
Many @cite{STREAMS} implementations provide this function.  When the errors that can be delivered to
the Stream Head in a @var{M_ERROR} message were broken from a single read/write error condition to a
separate read and write error condition, the
@command{putctl(9)}
@findex putctl(9)
function lost much of its utility.  Implementation of a
@command{putctl2(9)}
@findex putctl2(9)
function provides a similar capability for read/write error conditions as
@command{putctl(9)}
@findex putctl(9)
provided for combined error conditions previously.
@cite{AIX} implements this function.  @dfn{@value{PACKAGE_TITLE}} provides this function for
compatibility with @cite{AIX} and other @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based @cite{STREAMS} implementations.
@command{putctl2(9)}
@findex putctl2(9)
is not very useful in an @i{MP} environment, where one really wants to place @var{M_ERROR} messages
on the @i{upstream} queue.  The function for that in the @i{MP} environment is
@command{putnextctl2(9)}.
@findex putnextctl2(9)
@cite{AIX} does not implement the
@command{putnextctl2(9)}
@findex putnextctl2(9)
function, which is somewhat surprising, but then @cite{AIX} does not really handle @i{MP} environments
the same way that @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
does: the @cite{AIX Portable STREAMS Environment (PSE)} is essentially single threaded, and
@cite{AIX PSE} does not implement @var{QHLIST} meaning that the synchronization for protecting
dereferencing of @samp{q->q_next} pointers is not present.

@item @command{splstr(9)}
@findex splstr(9)
@tab Set or restore priority levels.
Although @dfn{@value{PACKAGE_TITLE}} does not interpret priority levels in the same fashion as @cite{SVR
4.2 MP}, the
@command{splstr(9)}
@findex splstr(9)
is provided in support of @cite{AIX} and other @cite{STREAMS} implementations.
@cite{AIX} also does not interpret priority levels in the same manner, but provides
@command{splstr(9)}
@findex splstr(9)
and
@command{splx(9)}
@findex splx(9)
functions in support of @cite{STREAMS}.

@item @command{splx(9)}
@findex splx(9)
@tab Set or restore priority levels.
Although @dfn{@value{PACKAGE_TITLE}} does not interpret priority levels in the same fashion as @cite{SVR
4.2 MP}, the
@command{splx(9)}
@findex splx(9)
is provided in support of @cite{AIX} and other @cite{STREAMS} implementations.
@cite{AIX} also does not interpret priority levels in the same manner, but provides
@command{splstr(9)}
@findex splstr(9)
and
@command{splx(9)}
@findex splx(9)
functions in support of @cite{STREAMS}.

@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two pairs of @cite{STREAMS} message queues.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld together two pairs of @cite{STREAMS} message queues.
@end multitable


@subsubheading @cite{AIX} Compatibility Module
@cindex compatibility module, AIX
@cindex AIX, compatibility module
@cindex AIX

The functions in this section are provided as part of the @cite{AIX Compatibility Module} contained
in the @file{streams-aixcompat.o} kernel module.

@multitable @columnfractions .30 .70
@item @command{mi_bufcall(9)}
@findex mi_bufcall(9)
@tab Reliable alternative to @command{buffcall(9)}.
@command{mi_bufcall(9)}
@findex mi_bufcall(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{mi_close_comm(9)}
@findex mi_close_comm(9)
@tab @cite{STREAMS} common minor device close utility.
@command{mi_close_comm(9)}
@findex mi_close_comm(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{mi_next_ptr(9)}
@findex mi_next_ptr(9)
@tab @cite{STREAMS} minor device list traversal.
@command{mi_next_ptr(9)}
@findex mi_next_ptr(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{mi_open_comm(9)}
@findex mi_open_comm(9)
@tab @cite{STREAMS} common minor device open utility.
@command{mi_open_comm(9)}
@findex mi_open_comm(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{mi_prev_ptr(9)}
@findex mi_prev_ptr(9)
@tab @cite{STREAMS} minor device list traversal.
@command{mi_prev_ptr(9)}
@findex mi_prev_ptr(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{str_install(9)}
@findex str_install(9)
@tab Install a @cite{STREAMS} module or driver.
@command{str_install(9)}
@findex str_install(9)
is the @cite{AIX}-specific driver and module registration and deregistration facility.  This
facility is fashioned after the @cite{SVR 4.2 MP} facility.  @dfn{@value{PACKAGE_TITLE}} provides an
@cite{AIX} version of this function in support of @cite{AIX}.
Only the @cite{SVR 4.2 MP} version of this function will be used by portable @cite{STREAMS} modules
and drivers intended to be portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{wantio(9)}
@findex wantio(9)
@tab Perform direct I/O from a @cite{STREAMS} driver.
@command{wantio(9)}
@findex wantio(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{wantmsg(9)}
@findex wantmsg(9)
@tab Provide a filter of wanted messages from a @cite{STREAMS} module.
@command{wantmsg(9)}
@findex wantmsg(9)
is an @cite{AIX}-specific function.  @dfn{@value{PACKAGE_TITLE}} provides this function in support of
@cite{AIX} drivers and modules.
This function will not be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
@end multitable

@subsection HP-UX 11.0i v2 Compatibility Functions
@cindex HP-UX 11.0i v2, compatibility functions
@cindex compatibility functions, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2
@cindex HP-UX

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with
@cite{HP-UX 11.0i v2}:

@subsubheading @cite{HP-UX} Core Functions
@cindex HP-UX, core functions
@cindex core functions, HP-UX
@cindex HP-UX

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{HP-UX 11.0i v2 STREAMS/UX}:
@cindex HP-UX 11.0i v2, STREAMS/UX

@multitable @columnfractions .20 .80
@item @command{putctl2(9)}
@findex putctl2(9)
@tab Put a 2 byte control message on a @cite{STREAMS} message queue.
Many @cite{STREAMS} implementations provide this function.  When the errors that can be delivered to
the Stream Head in a @var{M_ERROR} message were broken from a single read/write error condition to a
separate read and write error condition, the
@command{putctl(9)}
@findex putctl(9)
function lost much of its utility.  Implementation of a
@command{putctl2(9)}
@findex putctl2(9)
function provides a similar capability for read/write error conditions as
@command{putctl(9)}
@findex putctl(9)
provided for combined error conditions previously.
@cite{HP-UX}
@cindex HP-UX
implements this function.  @dfn{@value{PACKAGE_TITLE}} provides this function for
compatibility with @cite{HP-UX}
@cindex HP-UX
and other @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based @cite{STREAMS} implementations.

@item @command{putnextctl2(9)}
@findex putnextctl2(9)
@tab Put a 2 byte control message on the downstream @cite{STREAMS} message queue.
Many @cite{STREAMS} @i{MP} implementations provide this function.  When the errors that can be
delivered to the Stream Head in a @var{M_ERROR}
@vindex M_ERROR
message were broken from a single read/write error condition to a separate read and write error
condition, the
@command{putnextctl(9)}
@findex putnextctl(9)
function lost much of its utility.  Implementation of a
@command{putnextctl2(9)}
@findex putnextctl2(9)
function provides a similar capability for read/write error conditions as
@command{putnextctl(9)}
@findex putnextctl(9)
provided for combined error conditions previously.
@cite{HP-UX}
@cindex HP-UX
implements this function.  @dfn{@value{PACKAGE_TITLE}} provides this function for
compatibility with @cite{HP-UX}
@cindex HP-UX
and other @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
based @cite{STREAMS} implementations.

@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two pairs of @cite{STREAMS} message queues.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld together two pairs of @cite{STREAMS} message queues.
@end multitable

@subsubheading @cite{HP-UX} Compatibility Module
@cindex HP-UX, compatibility module
@cindex compatibility module, HP-UX
@cindex HP-UX

The functions in this section are provided as part of the @cite{HP-UX Compatibility Module} contained
in the @file{streams-hpuxcompat.o} kernel module.

@multitable @columnfractions .20 .80
@item @command{str_install(9)}
@findex str_install(9)
@tab Install a @cite{STREAMS} module or driver.
@command{str_install(9)}
@findex str_install(9)
is the @cite{HP-UX}-specific
@cindex HP-UX
driver and module registration facility.  This facility is fashioned
after the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
facility.  @dfn{@value{PACKAGE_TITLE}} provides an @cite{HP-UX} version of
this function in support of @cite{HP-UX}.  Only the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
version of this function will be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{str_uninstall(9)}
@findex str_uninstall(9)
@tab Uninstall a @cite{STREAMS} module or driver.
@command{str_uninstall(9)}
@findex str_uninstall(9)
is the @cite{HP-UX}-specific
@cindex HP-UX
driver and module deregistration facility.  This facility is fashioned
after the @cite{SVR 4.2 MP} facility.  @dfn{@value{PACKAGE_TITLE}} provides an @cite{HP-UX}
@cindex HP-UX
version of this function in support of @cite{HP-UX}.
@cindex HP-UX
Only the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
version of this function will be used by portable @cite{STREAMS} modules and drivers intended to be
portable across @cite{STREAM} implementations based on @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP

@item @command{streams_get_sleep_lock(9)}
@findex streams_get_sleep_lock(9)
@tab Provide access to the global sleep lock.
@item @command{streams_put(9)}
@findex streams_put(9)
@tab Invoke the put procedure for a @cite{STREAMS} module or driver with a @cite{STREAMS} message.
@end multitable

@subsection OSF/1 1.2/Digital UNIX Compatibility Functions
@cindex OSF/1 1.2/Digital UNIX, compatibility functions
@cindex compatibility functions, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@subsubheading @cite{OSF/1} Core Functions
@cindex core functions, OSF/1
@cindex OSF/1, core functions
@cindex OSF/1

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{OSF/1 1.2/Digital UNIX}:

@multitable @columnfractions .20 .80
@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two pairs of @cite{STREAMS} message queues.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld together two pairs of @cite{STREAMS} message queues.
@end multitable

@subsubheading @cite{OSF/1} Compatibility Module
@cindex compatibility module, OSF/1
@cindex OSF/1, compatibility module
@cindex OSF/1

The functions in this section are provided as part of the @cite{OSF/1 Compatibility Module} contained
in the @file{streams-osfcompat.o} kernel module.

@multitable @columnfractions .30 .70
@item @command{lbolt(9)}
@findex lbolt(9)
@tab Time in ticks since reboot.
@item @command{puthere(9)}
@findex puthere(9)
@tab Invoke the put procedure for a @cite{STREAMS} module or driver with a @cite{STREAMS} message.
@item @command{streams_close_comm(9)}
@findex streams_close_comm(9)
@tab Common minor device close utility.
@item @command{streams_open_comm(9)}
@findex streams_open_comm(9)
@tab Common minor device open utility.
@item @command{streams_open_ocomm(9)}
@findex streams_open_ocomm(9)
@tab Common minor device open utility.
@item @command{strmod_add(9)}
@findex strmod_add(9)
@tab Add a @cite{STREAMS} module.
@item @command{strmod_del(9)}
@findex strmod_del(9)
@tab Delete a @cite{STREAMS} module or driver from the kernel.
@item @command{time(9)}
@findex time(9)
@tab (undoc).
@end multitable

@subsection UnixWare 7.1.3 (OpenUnix 8) Compatibility Functions
@cindex UnixWare 7.1.3 (OpenUnix 8), compatibility functions
@cindex compatibility functions, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@subsubheading @cite{UnixWare} Core Functions
@cindex core functions, UnixWare
@cindex UnixWare, core functions
@cindex UnixWare

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{UnixWare 7.1.3 (OpenUnix 8)}:

@multitable @columnfractions .20 .80
@end multitable

@subsubheading @cite{UnixWare} Compatibility Module
@cindex compatibility module, UnixWare
@cindex UnixWare, compatibility module
@cindex UnixWare

The functions in this section are provided as part of the @cite{UnixWare Compatibility Module} contained
in the @file{streams-uw7compat.o} kernel module.

@multitable @columnfractions .30 .70
@item @command{allocb_physreq(9)}
@findex allocb_physreq(9)
@tab Allocate a @cite{STREAMS} message and data block.
@item @command{emajor(9)}
@findex emajor(9)
@tab Get the external (real) major device number from the device number.
@item @command{eminor(9)}
@findex eminor(9)
@tab Get the external extended minor device number from the device number.
@item @command{etoimajor(9)}
@findex etoimajor(9)
@tab Convert an external major device number to an internal major device number.
@item @command{getemajor(9)}
@findex getemajor(9)
@tab Get the external (real) major device number.
@item @command{geteminor(9)}
@findex geteminor(9)
@tab Get the external minor device number.
@item @command{itoemajor(9)}
@findex itoemajor(9)
@tab Convert an internal major device number to an external major device number.
@item @command{msgphysreq(9)}
@findex msgphysreq(9)
@tab Cause a message block to meet physical requirements.
@item @command{msgpullup_physreq(9)}
@findex msgpullup_physreq(9)
@tab Pull up bytes in a @cite{STREAMS} message.
@item @command{msgscgth(9)}
@findex msgscgth(9)
@tab (undoc).
@item @command{printf(9)}
@findex printf(9)
@tab (undoc).
@item @command{strioccall(9)}
@findex strioccall(9)
@tab (undoc).
@end multitable

@subsection Solaris 9/SunOS 5.9 Compatibility Functions
@cindex Solaris 9/SunOS 5.9, compatibility functions
@cindex compatibility functions, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@subsubheading @cite{Solaris} Core Functions
@cindex core functions, Solaris
@cindex Solaris, core functions
@cindex Solaris

The following functions are provided by @dfn{@value{PACKAGE_TITLE}} for compatibility with the
@cite{Solaris 9/SunOS 5.9}:

@multitable @columnfractions .20 .80
@end multitable

@subsubheading @cite{Solaris} Compatibility Module
@cindex compatibility module, Solaris
@cindex Solaris, compatibility module
@cindex Solaris

The functions in this section are provided as part of the @cite{Solaris Compatibility Module} contained
in the @file{streams-suncompat.o} kernel module.

@multitable @columnfractions .40 .60
@item @command{_fini(9)}
@findex _fini(9)
@tab
@item @command{_info(9)}
@findex _info(9)
@tab
@item @command{_init(9)}
@findex _init(9)
@tab
@item @command{attach(9)}
@findex attach(9)
@tab attach a device to the system or resume a suspended device
@item @command{ddi_create_minor_node(9)}
@findex ddi_create_minor_node(9)
@tab create a minor node for this device
@item @command{ddi_driver_major(9)}
@findex ddi_driver_major(9)
@tab find the major device number associated with a driver
@item @command{ddi_driver_name(9)}
@findex ddi_driver_name(9)
@tab return normalized driver name
@item @command{ddi_get_cred(9)}
@findex ddi_get_cred(9)
@tab get a reference to the credentials of the current user
@item @command{ddi_getiminor(9)}
@findex ddi_getiminor(9)
@tab
@item @command{ddi_get_instance(9)}
@findex ddi_get_instance(9)
@tab get device instance number
@item @command{ddi_get_lbolt(9)}
@findex ddi_get_lbolt(9)
@tab get the current value of the system tick clock
@item @command{ddi_get_pid(9)}
@findex ddi_get_pid(9)
@tab
@item @command{ddi_get_soft_state(9)}
@findex ddi_get_soft_state(9)
@tab
@item @command{ddi_get_time(9)}
@findex ddi_get_time(9)
@tab get the current time in seconds since the epoch
@item @command{ddi_remove_minor_node(9)}
@findex ddi_remove_minor_node(9)
@tab remove a minor node for a device
@item @command{ddi_removing_power(9)}
@findex ddi_removing_power(9)
@tab
@item @command{ddi_soft_state(9)}
@findex ddi_soft_state(9)
@tab
@item @command{ddi_soft_state_fini(9)}
@findex ddi_soft_state_fini(9)
@tab
@item @command{ddi_soft_state_free(9)}
@findex ddi_soft_state_free(9)
@tab
@item @command{ddi_soft_state_init(9)}
@findex ddi_soft_state_init(9)
@tab
@item @command{ddi_soft_state_zalloc(9)}
@findex ddi_soft_state_zalloc(9)
@tab
@item @command{ddi_umem_alloc(9)}
@findex ddi_umem_alloc(9)
@tab allocate page aligned kernel memory
@item @command{ddi_umem_free(9)}
@findex ddi_umem_free(9)
@tab
@item @command{detach(9)}
@findex detach(9)
@tab detach a device from the system or suspend a device
@item @command{getinfo(9)}
@findex getinfo(9)
@tab
@item @command{identify(9)}
@findex identify(9)
@tab determine if a driver is associated with a device
@item @command{install_driver(9)}
@findex install_driver(9)
@tab install a device driver
@item @command{mod_info(9)}
@findex mod_info(9)
@tab provides information on a loadable kernel module to the @cite{STREAMS} executive
@item @command{mod_install(9)}
@findex mod_install(9)
@tab installs a loadable kernel module in the @cite{STREAMS} executive
@item @command{mod_remove(9)}
@findex mod_remove(9)
@tab removes a loadable module from the @cite{STREAMS} executive
@item @command{power(9)}
@findex power(9)
@tab power a device attached to the system
@item @command{probe(9)}
@findex probe(9)
@tab
@item @command{qbufcall(9)}
@findex qbufcall(9)
@tab install a buffer callback
@item @command{qtimeout(9)}
@findex qtimeout(9)
@tab start a timer associated with a queue
@item @command{queclass(9)}
@findex queclass(9)
@tab
@item @command{qunbufcall(9)}
@findex qunbufcall(9)
@tab Cancel a @cite{STREAMS} buffer callback.
@item @command{quntimeout(9)}
@findex quntimeout(9)
@tab
@item @command{qwait(9)}
@findex qwait(9)
@tab wait for a queue message
@item @command{qwait_sig(9)}
@findex qwait_sig(9)
@tab wait for a queue message or signal
@item @command{qwriter(9)}
@findex qwriter(9)
@tab
@end multitable

@subsection LiS 2.18.1 Compatibility Functions
@cindex LiS 2.18.1, compatibility functions
@cindex compatibility functions, LiS 2.18.1
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@multitable @columnfractions .40 .60
@item @command{lis_register_strdev(9)}
@findex lis_register_strdev(9)
@tab
@item @command{lis_register_strmod(9)}
@findex lis_register_strmod(9)
@tab
@item @command{lis_unregister_strdev(9)}
@findex lis_unregister_strdev(9)
@tab
@item @command{lis_unregister_strmod(9)}
@findex lis_unregister_strmod(9)
@tab
@end multitable

@multitable @columnfractions .40 .60
@item @command{lis_adjmsg(9)}
@findex lis_adjmsg(9)
@tab
@item @command{lis_allocb(9)}
@findex lis_allocb(9)
@tab
@item @command{lis_allocb_physreq(9)}
@findex lis_allocb_physreq(9)
@tab
@item @command{lis_allocq(9)}
@findex lis_allocq(9)
@tab
@item @command{lis_appq(9)}
@findex lis_appq(9)
@tab
@item @command{lis_backq(9)}
@findex lis_backq(9)
@tab
@item @command{lis_bcanput(9)}
@findex lis_bcanput(9)
@tab
@item @command{lis_bcanputnext(9)}
@findex lis_bcanputnext(9)
@tab
@item @command{lis_bcopy(9)}
@findex lis_bcopy(9)
@tab
@item @command{lis_bufcall(9)}
@findex lis_bufcall(9)
@tab
@item @command{lis_bzero(9)}
@findex lis_bzero(9)
@tab
@item @command{lis_canenable(9)}
@findex lis_canenable(9)
@tab
@item @command{lis_canput(9)}
@findex lis_canput(9)
@tab
@item @command{lis_canputnext(9)}
@findex lis_canputnext(9)
@tab
@item @command{lis_cmn_err(9)}
@findex lis_cmn_err(9)
@tab
@item @command{lis_copyb(9)}
@findex lis_copyb(9)
@tab
@item @command{lis_copymsg(9)}
@findex lis_copymsg(9)
@tab
@item @command{lis_datamsg(9)}
@findex lis_datamsg(9)
@tab
@item @command{lis_date(9)}
@findex lis_date(9)
@tab
@item @command{lis_dupb(9)}
@findex lis_dupb(9)
@tab
@item @command{lis_dupmsg(9)}
@findex lis_dupmsg(9)
@tab
@item @command{lis_enableok(9)}
@findex lis_enableok(9)
@tab
@item @command{lis_esballoc(9)}
@findex lis_esballoc(9)
@tab
@item @command{lis_esbbcall(9)}
@findex lis_esbbcall(9)
@tab
@item @command{lis_find_strdev(9)}
@findex lis_find_strdev(9)
@tab
@item @command{lis_flushband(9)}
@findex lis_flushband(9)
@tab
@item @command{lis_flushq(9)}
@findex lis_flushq(9)
@tab
@item @command{lis_freeb(9)}
@findex lis_freeb(9)
@tab
@item @command{lis_freemsg(9)}
@findex lis_freemsg(9)
@tab
@item @command{lis_freeq(9)}
@findex lis_freeq(9)
@tab
@item @command{lis_getq(9)}
@findex lis_getq(9)
@tab
@item @command{lis_insq(9)}
@findex lis_insq(9)
@tab
@item @command{lis_isdatablk(9)}
@findex lis_isdatablk(9)
@tab
@item @command{lis_isdatamsg(9)}
@findex lis_isdatamsg(9)
@tab
@item @command{lis_linkb(9)}
@findex lis_linkb(9)
@tab
@item @command{lis_mknod(9)}
@findex lis_mknod(9)
@tab
@item @command{lis_mount(9)}
@findex lis_mount(9)
@tab
@item @command{lis_msgdsize(9)}
@findex lis_msgdsize(9)
@tab
@item @command{lis_msgpullup(9)}
@findex lis_msgpullup(9)
@tab
@item @command{lis_msgsize(9)}
@findex lis_msgsize(9)
@tab
@item @command{lis_noenable(9)}
@findex lis_noenable(9)
@tab
@item @command{lis_OTHER(9)}
@findex lis_OTHER(9)
@tab
@item @command{lis_OTHERQ(9)}
@findex lis_OTHERQ(9)
@tab
@item @command{lis_pullupmsg(9)}
@findex lis_pullupmsg(9)
@tab
@item @command{lis_putbq(9)}
@findex lis_putbq(9)
@tab
@item @command{lis_putctl1(9)}
@findex lis_putctl1(9)
@tab
@item @command{lis_putctl(9)}
@findex lis_putctl(9)
@tab
@item @command{lis_putnext(9)}
@findex lis_putnext(9)
@tab
@item @command{lis_putnextctl1(9)}
@findex lis_putnextctl1(9)
@tab
@item @command{lis_putnextctl(9)}
@findex lis_putnextctl(9)
@tab
@item @command{lis_putq(9)}
@findex lis_putq(9)
@tab
@item @command{lis_qattach(9)}
@findex lis_qattach(9)
@tab
@item @command{lis_qclose(9)}
@findex lis_qclose(9)
@tab
@item @command{lis_qdetach(9)}
@findex lis_qdetach(9)
@tab
@item @command{lis_qenable(9)}
@findex lis_qenable(9)
@tab
@item @command{lis_qopen(9)}
@findex lis_qopen(9)
@tab
@item @command{lis_qprocsoff(9)}
@findex lis_qprocsoff(9)
@tab
@item @command{lis_qprocson(9)}
@findex lis_qprocson(9)
@tab
@item @command{lis_qreply(9)}
@findex lis_qreply(9)
@tab
@item @command{lis_qsize(9)}
@findex lis_qsize(9)
@tab
@item @command{lis_RD(9)}
@findex lis_RD(9)
@tab
@item @command{lis_register_strdev(9)}
@findex lis_register_strdev(9)
@tab
@item @command{lis_register_strmod(9)}
@findex lis_register_strmod(9)
@tab
@item @command{lis_rmvb(9)}
@findex lis_rmvb(9)
@tab
@item @command{lis_rmvq(9)}
@findex lis_rmvq(9)
@tab
@item @command{lis_safe_canenable(9)}
@findex lis_safe_canenable(9)
@tab
@item @command{lis_safe_enableok(9)}
@findex lis_safe_enableok(9)
@tab
@item @command{lis_safe_noenable(9)}
@findex lis_safe_noenable(9)
@tab
@item @command{lis_safe_OTHERQ(9)}
@findex lis_safe_OTHERQ(9)
@tab
@item @command{lis_safe_putnext(9)}
@findex lis_safe_putnext(9)
@tab
@item @command{lis_safe_qreply(9)}
@findex lis_safe_qreply(9)
@tab
@item @command{lis_safe_RD(9)}
@findex lis_safe_RD(9)
@tab
@item @command{lis_safe_SAMESTR(9)}
@findex lis_safe_SAMESTR(9)
@tab
@item @command{lis_safe_WR(9)}
@findex lis_safe_WR(9)
@tab
@item @command{lis_SAMESTR(9)}
@findex lis_SAMESTR(9)
@tab
@item @command{lis_stream_utils(9)}
@findex lis_stream_utils(9)
@tab
@item @command{lis_strqget(9)}
@findex lis_strqget(9)
@tab
@item @command{lis_strqset(9)}
@findex lis_strqset(9)
@tab
@item @command{lis_testb(9)}
@findex lis_testb(9)
@tab
@item @command{lis_timeout(9)}
@findex lis_timeout(9)
@tab
@item @command{lis_umount2(9)}
@findex lis_umount2(9)
@tab
@item @command{lis_umount(9)}
@findex lis_umount(9)
@tab
@item @command{lis_unbufcall(9)}
@findex lis_unbufcall(9)
@tab
@item @command{lis_unlink(9)}
@findex lis_unlink(9)
@tab
@item @command{lis_unlinkb(9)}
@findex lis_unlinkb(9)
@tab
@item @command{lis_unregister_strdev(9)}
@findex lis_unregister_strdev(9)
@tab
@item @command{lis_unregister_strmod(9)}
@findex lis_unregister_strmod(9)
@tab
@item @command{lis_untimeout(9)}
@findex lis_untimeout(9)
@tab
@item @command{lis_version(9)}
@findex lis_version(9)
@tab
@item @command{lis_WR(9)}
@findex lis_WR(9)
@tab
@item @command{lis_xmsgsize(9)}
@findex lis_xmsgsize(9)
@tab
@end multitable

@node Examples
@chapter Examples
@cindex examples
@menu
* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example
@end menu

@node Module Example
@section Module Example
@cindex module example

@node Driver Example
@section Driver Example
@cindex driver example

@node Device Numbers
@chapter Device Numbers
@cindex device numbers
@menu
* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering
* spec File System::		Avoiding Device Numbering
@end menu

@dfn{@value{PACKAGE_TITLE}} supports the concept of internal and external device numbering with base
majors and extended minors.

@dfn{@value{PACKAGE_TITLE}} uses several device numbering schemes intended to be compatible with
@cite{SVR 4.2 MP DDI/DKI}
@cindex DDI/DKI
@cindex SVR 4.2 MP DDI/DKI
and implementations based on @cite{SVR 4.2}
@cindex SVR 4.2
including AIX,
@cindex AIX
HP-UX,
@cindex HP-UX
LiS,
@cindex Linux STREAMS (LiS)
OSF/1,
@cindex OSF/1
Solaris,
@cindex Solaris
Super/UX,
@cindex Super/UX
UnixWare,
@cindex UnixWare
and UXP/V.
@cindex UXP/V

@node External Device Numbers
@section External Device Numbers
@cindex external device numbers
@cindex device numbers, external

@dfn{@value{PACKAGE_TITLE}} provides real external device numbering using the functions
@manpage{getemajor(9)}, @manpage{geteminor(9)} and @manpage{makedevice(9)}.  When used on a
@var{devp} argument passed to the @manpage{qopen(9)} procedures of a STREAMS driver or module,
@manpage{getemajor(9)} and @manpage{geteminor(9)} will return the real external major or minor
device number.  The real external major or minor device number is the major or minor device number
that is seen by user applications.

A number of administrative utilities are provided that assist with the assignment of device names
and number and are useful in boot scripts: (@pxref{Administrative Utilities})

@multitable @columnfractions .15 .85
@item @command{autopush(8)}
@pgindex autopush(8)
@tab -- verify modules and establish autopush lists
@item @command{insf(8)}
@pgindex insf(8)
@tab -- install special device files
@item @command{scls(8)}
@pgindex scls(8)
@tab -- list @dfn{STREAMS} drivers
@item @command{strinfo(8)}
@pgindex strinfo(8)
@tab -- provide information on @dfn{STREAMS} drivers and modules
@item @command{strload(8)}
@pgindex strload(8)
@tab -- load or unload @dfn{STREAMS} drviers and modules
@item @command{strsetup(8)}
@pgindex strsetup(8)
@tab -- create @dfn{STREAMS} devices
@end multitable

Another approach to establishment of dynamically allocated major device numbers is to use the @cite{LiS}
@cindex Linux STREAMS (LiS)
approach of creating minor device nodes using the @command{mknod(9)}
@findex mknod(9)
and @command{unlink(9)}
@findex unlink(9)
facilities provided by the @cite{LiS}
@cindex Linux STREAMS (LiS)
compatibility module.  But this approach does not work well with demand loading of kernel modules
because it relies upon the @b{Linux} character device demand loading approach, or requires informing
@dfn{STREAMS} of all devices and drivers when @dfn{STREAMS} is being compiled.

@dfn{@value{PACKAGE_TITLE}} supports the @b{Linux} character device module demand loading; however, the
@b{Linux} mechanism requires prior knowledge of the character major device number.  Some of the
administrative utilities above can load kernel modules and establish what major device number was
assigned.  See the individual manual pages for more information.

@node Internal Device Numbers
@section Internal Device Numbers
@cindex internal device numbers
@cindex device numbers, internal

Internal extended minor device number is a scheme whereby the @dfn{STREAMS} device driver does not
have to be concerned with architectural limitations on the number of minor device number available
to user applications (0 to 255 in @b{Linux 2.4}).  Instead, the driver treats the major device
number as a base internal device number against which a range of minor devices can be assigned
(currently 0 to 65535).  For external applications, device numbering consists of multiple (real)
external major device numbers that correspond to a single base internal major device number.
Internal extended device numbering is provided by the @command{getmajor(9)},
@findex getmajor(9)
@command{getminor(9)}
@findex getminor(9)
and @command{makedevice(9)}
@findex makedevice(9)
facilities.  Conversions between external (real) major device numbers and internal (base) major
device numbers can be performed with the @command{etoimajor(9)}
@findex etoimajor(9)
and @command{itoemajor(9)}
@findex itoemajor(9)
utilities provided by the @dfn{UnixWare} compatibility modules.

Extended device numbering further complicates the matter of dynamic assignment of major device
numbers and makes it harder for boot and configuration scripts to properly create device nodes.

@node Clone Device
@section Clone Device
@cindex clone device

@subsection Traditional Cloning

The @command{clone(4)}
@pgindex clone(4)
driver supports traditional clone devices.  Traditional clone devices work by
assigning the clone major device number and a unique minor device number to a ``clone'' device.
When this device is opened, the minor device number of the device is used as the new major device
number and zero (0) is used as the minor device number, and the @command{qopen(9)}
@findex qopen(9)
is chained to the @command{qopen(9)}
@findex qopen(9)
procedure of the new @command{streamtab(9)}
@tindex streamtab(9)
structure resulting from looking up this newly created device number.  @var{sflag}
@vindex sflag
is always set to @samp{CLONEOPEN}
@vindex CLONEOPEN
when the traditional clone driver opens a device.

@command{getemajor(9)},
@findex getemajor(9)
@command{geteminor(9)},
@findex geteminor(9)
@command{getmajor(9)}
@findex getmajor(9)
and @command{getminor(9)}
@findex getminor(9)
still function as normal on the resulting @var{devp}
@vindex devp
argument passed to the ultimate driver's @command{qopen(9)}
@findex qopen(9)
procedure.  This is true both for base and extended major device numbers.  The following table
illustrates the situation (assuming that the major device number assigned to the @command{clone(4)}
@pgindex clone(4)
device is 72):

@multitable @columnfractions .25 .25 .25 .25
@item @b{clone}		@tab @b{external}	@tab @b{internal}	@tab @var{sflag}
@item @t{72:32}		@tab @t{32:0}		@tab @t{32:000}		@tab @samp{CLONEOPEN}
@vindex CLONEOPEN
@item @t{72:35}		@tab @t{35:0}		@tab @t{32:256}		@tab @samp{CLONEOPEN}
@vindex CLONEOPEN
@item @t{72:37}		@tab @t{37:0}		@tab @t{32:512}		@tab @samp{CLONEOPEN}
@vindex CLONEOPEN
@end multitable

If a driver wishes to assign an extended major device number in response to a @b{CLONEOPEN},
@vindex CLONEOPEN
it should use @command{makedevice(9)}
@findex makedevice(9)
with the major device number obtained with @command{getmajor(9)}
@findex getmajor(9)
and an extended minor device number assigned by the driver.  In this way, extended minor device
numbers are transparent to the operation of the @command{clone(4)}
@pgindex clone(4)
driver and @samp{CLONEOPEN}.
@vindex CLONEOPEN

@subsection New Cloning

@dfn{@value{PACKAGE_TITLE}} supports the new cloning approach whereby a driver is permitted to alter
the device number returned in the @var{devp}
@vindex devp
argument to @command{qopen(9)}
@findex qopen(9)
even though @var{sflag}
@vindex sflag
is set to @samp{DRVOPEN}
@vindex DRVOPEN
instead of @samp{CLONEOPEN}.
@vindex CLONEOPEN
The driver, at its discretion, can treat any minor device number as a new style clone device,
although normally minor device number zero (0) is usually used as the clone minor.

The driver may either use an external (real) major device number or the internal (base) major device
number.  That is, when calling @command{makedevice(9)}
@findex makedevice(9)
to create the device to return to the @var{devp}
@vindex devp
argument to @command{qopen(9)},
@findex qopen(9)
the driver can use an external (real) major device number (returned by @command{getemajor(9)})
@findex getemajor(9)
combined with an assigned external (real) minor device number (from 0 to 255); or, it can use an
internal (base) major device number (returned by @command{getmajor(9)})
@findex getmajor(9)
combined with an assigned extended minor device number (from 0 to 65535).  The latter approach is
often easier to use.

@node Named STREAMS Device
@section Named STREAMS Device
@cindex named streams device

The @command{nsdev(4)}
@pgindex nsdev(4)
driver provides for a @dfn{Named STREAMS Device}.  This is a device numbering approach unique to
@dfn{@value{PACKAGE_TITLE}}.  The @command{nsdev(4)}
@pgindex nsdev(4)
driver operates in a similar manner to the @command{clone(4)}
@pgindex clone(4)
driver, however, the major number is derived from the prefix name of the device and the minor number
is taken directly from the minor number of the @command{nsdev(4)}
@pgindex nsdev(4)
device.

The following table summarizes the approach (assuming that the major device numbers assigned to the
@command{nsdev(4)}
@pgindex nsdev(4)
device are 74, 75, 76 and 77 and the major device numbers assigned to the @command{inet(4)}
@pgindex inet(4)
driver are 32, 35 and 37):

@multitable @columnfractions .2 .2 .2 .2 .2
@item @b{nsdev}		@tab		@tab @b{external}	@tab @b{internal}	@tab @var{sflag}
@item inet		@tab @t{74:000}	@tab @t{32:000}		@tab @t{32:000}		@tab @samp{DRVOPEN}
@vindex DRVOPEN
@item inet.udp		@tab @t{74:017}	@tab @t{32:017}		@tab @t{32:017}		@tab @samp{DRVOPEN}
@vindex DRVOPEN
@item inet.99		@tab @t{74:099}	@tab @t{32:099}		@tab @t{32:099}		@tab @samp{DRVOPEN}
@vindex DRVOPEN
@item inet.512		@tab @t{76:000}	@tab @t{37:000}		@tab @t{32:512}		@tab @samp{DRVOPEN}
@vindex DRVOPEN
@end multitable

The @command{nsdev(4)}
@pgindex nsdev(4)
device also has the characteristic that if a device name with a major device number of the
@command{nsdev(4)}
@pgindex nsdev(4)
device is opened and there is no device loaded that corresponds to the prefix name of the device
from which to obtain a major device number, the @command{nsdev(4)}
@pgindex nsdev(4)
will attempt to load the `@t{@b{streams-}@i{prefix}}' kernel module using @command{request_module(9)}
@findex request_module(9)
and try again: where, @samp{prefix} is the prefix of the device name up to the first point character
(corresponding to a digit @kbd{.}).  So, in the example above, if the @samp{inet} driver was not
loaded, but an attempt was made to open the @file{/dev/inet.99} device, @dfn{STREAMS} would request
the @file{streams-inet} kernel module be loaded.  This approach simplifies kernel module loading as
well as device numbering and makes it easier for boot scripts to initialize devices.

@node spec File System
@section spec File System
@cindex spec file system

Another approach to creation and assignment of device numbers is the mountable @command{specfs(5)}
@pgindex specfs(5)
file system.  The @command{specfs(5)}
@pgindex specfs(5)
file system can be mounted to provide an in-kernel device directory similar to the @b{Linux}
@file{devfs} file system and the @dfn{Solaris} devices file system.  The @command{spefs(5)}
@pgindex specfs(5)
file system should normally be mounted on the @file{/dev/streams} subdirectory by system
initialization scripts using a command such as: @command{mount -t specfs none /dev/streams}.  See
@command{mount(8)}
@pgindex mount(8)
for more information.  Once mounted over the @file{/dev/streams} subdirectory, subdirectories of
@file{/dev/streams} corresponding to each loaded driver will appear.  So, for example, when the
@command{inet(4)}
@pgindex inet(4)
driver is loaded, the ``inet'' subdirectory will appear at @file{/dev/streams/inet}.  Within each
device subdirectory @file{/dev/streams/@i{devicename}/}, each instance of the device will appear as
a character device named with the instance number of the device and having the eternal (real) major
and external (real) minor device number.

The mounted @command{specfs(5)}
@pgindex specfs(5)
file system also has the characteristic that if a device subdirectory
@file{/dev/streams/@i{devname}/} does not exist, but an attempt is made to read such a directory,
@dfn{@value{PACKAGE_TITLE}} will attempt to load kernel module @file{streams-@i{devname}} into the
kernel with @command{request_module(9)}.
@findex request_module(9)
If the load is successful, the kernel module will register and the subdirectory will be created and
read.

Also, if an attempt is make to open a numbered file within a device subdirectory of
@file{/dev/streams/@i{devname}/@i{nnnn}} where, @samp{nnnn} is an octal, hexadecimal or decimal
ASCII number, @dfn{STREAMS} will open the driver (call @command{qopen(9)}
@findex qopen(9)
for driver @samp{devname}) with the instance number resulting from the conversion of the device name
@samp{nnnn} to an instance number.

These two characteristics permit symbolic links to be placed in the @file{/dev} directory that link
to a device name and instance number in the @file{/dev/stream} directory.  An example is given in
the table below:

@multitable @columnfractions .55 .15 .15 .15
@item @b{link} @tab @b{external} @tab @b{internal} @tab @var{sflag}
@item @file{/dev/tcp}@ ->@ @file{/dev/streams/inet/36} @tab @t{30:36} @tab @t{30:36} @tab @samp{DRVOPEN}
@vindex DRVOPEN
@item @file{/dev/udp}@ ->@ @file{/dev/streams/inet/39} @tab @t{30:39} @tab @t{30:39} @tab @samp{DRVOPEN}
@vindex DRVOPEN
@end multitable

In fact, it does not matter what the character device major or minor device number is on the node in
the @command{specfs(5)}
@pgindex specfs(5)
file system.  This is because the inode in the file system is directly associated with the
@command{streamtab(9)}
@tindex streamtab(9)
structure and instance number without using the normal @b{Linux} character device mechanisms.  When
a device instance exceeds the extended minor device numbering space assigned to a device driver in
the @command{specfs(5)}
@pgindex specfs(5)
file system, device number displayed by @command{stat(2)},
@findex stat(2)
@command{lstat(2)}
@findex lstat(2)
or @command{fstat(2)}
@findex fstat(2)
is chosen by wrapping the instance number into the extended minor device numbering space.

This approach makes it unnecessary to statically assign major device numbers, or to dynamically
assign major device numbers to devices in boot scripts, and is by far the easiest approach.  All that
is required by packages at installation is that they establish the necessary symbolic links on
device name and instance number without concern for major device numbers.

@node Multi-Threading
@chapter Multi-Threading
@cindex multi-threading
@menu
* Configuration::		MP STREAMS Configuration
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks
* Synchronous Callouts::	MP STREAMS Synchronous Callouts
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Asynchronous Callouts::	MP STREAMS Asynchronous Callouts
@end menu

The @b{Linux} 2.6 kernel is multi-threaded to make effective use of symmetric shared-memory
multiprocessor computers.  All parts of the kernel, including @cite{STREAMS} modules and drivers,
must ensure data integrity in a multiprocessing environment.  For the most part, developers must
ensure that concurrently running kernel threads do not attempt to manipulate the same data at the
same time.  The @cite{STREAMS} framework provides multiprocessing @dfn{Syncrhonization Levels},
which allows the developer control over the level of concurrency allowed in a module.  The @cite{SVR
4.2 MP DDI/DKI}
@cindex DDI/DKI
@cindex SVR 4.2 MP DDI/DKI
also provides locking mechanisms for protecting data.

There are two types of entry points, callbacks and callouts in the @dfn{@value{PACKAGE_TITLE}}
subsystem:

@enumerate

@item @emph{Synchronous.}
These entry points, callbacks and callouts are referenced against a @dfn{STREAMS} queue structure.
That is, they were invoked using a @dfn{STREAMS} queue structure as an argument.  These procedures
are as follows:

@multitable @columnfractions .20 .80
@item @command{put(9)}
@findex put(9)
@tab --
@item @command{srv(9)}
@findex srv(9)
@tab --
@item @command{qopen(9)}
@findex qopen(9)
@tab --
@item @command{qclose(9)}
@findex qclose(9)
@tab --
@item @command{qbufcall(9)}
@findex qbufcall(9)
@tab --
@item @command{qtimeout(9)}
@findex qtimeout(9)
@tab --
@item @command{mi_bufcall(9)}
@findex mi_bufcall(9)
@tab --
@item @command{putq(9)}
@findex putq(9)
@tab --
@item @command{putbq(9)}
@findex putbq(9)
@tab --
@item @command{putnext(9)}
@findex putnext(9)
@tab --
@item @command{qreply(9)}
@findex qreply(9)
@tab --
@end multitable

@item @emph{Asynchronous.}
These entry points, callbacks and callouts are @emph{not} referenced against a @dfn{STREAMS} queue
structure.  That is, they were invoked without a specific @dfn{STREAMS} queue structure as an
argument.  These procedures are as follows:

@multitable @columnfractions .20 .80
@item @command{bufcall(9)}
@findex bufcall(9)
@tab --
@item @command{esbbufcall(9)}
@findex esbbufcall(9)
@tab --
@item @command{timeout(9)}
@findex timeout(9)
@tab --
@item @command{esballoc(9)}
@findex esballoc(9)
@tab (free routine)
@end multitable

@end enumerate

@node Configuration
@section Configuration
@cindex configuration
@cindex STREAMS, configuration
@cindex configuration, STREAMS

@cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
specifies a synchronization mechanism that can be used during configuration of a @dfn{STREAMS}
driver or module to specify the level of synchronization required by a module.  The @cite{SVR 4}
synchronization levels are as follows:

@multitable @columnfractions .30 .70
@item @var{SQLVL_DEFAULT}
@vindex SQLVL_DEFAULT
@cindex synchronization, default
@tab @emph{Default level synchronization.}
Specifies that the module uses the default synchronization scheme.  This is the same as specifying
@var{SQLVL_MODULE}.
@vindex SQLVL_MODULE

@item @var{SQLVL_GLOBAL}
@vindex SQLVL_GLOBAL
@cindex synchronization, global
@tab @emph{Global (@dfn{STREAMS} scheduler) level synchronization.}
Specifies that all of @dfn{STREAMS} can be access by only one thread at the same time.  The module
is run with global synchronization.  This means that only one @dfn{STREAMS} executive thread will be
permitted to enter any module.  This makes the entire @dfn{STREAMS} executive single threaded and is
useful primarily for debugging.  This is the same as "Uniprocessor Emulation" on some systems, and
reduces the @dfn{STREAMS} executive to running on a single processor at a time.  This option should
normally be used only for debugging.

@item @var{SQLVL_ELSEWHERE}
@vindex SQLVL_ELSEWHERE
@cindex synchronization, elsewhere
@tab @emph{Module group level synchronization.}
Specifies that the module is run with synchronization within a group of modules.  Only one thread of
execution will be within the group of modules at a time.  The group is separately specified as a
character string name.  This permits a group of modules to run single threaded as though they are
running on a single processor, without interfering with the concurrency of other modules outside the
group.  This can be important for testing and for modules that implicitly share unprotected data
structures.

@item @var{SQLVL_MODULE}
@vindex SQLVL_MODULE
@cindex synchronization, module
@tab @emph{Module level synchronization.}
Specifies that all instances of a module can be accessed by only one thread at the same time.  This
is the default value.
The module is run with synchronization at the module.  Only one thread of execution will be
permitted within the module.  Where the module does not share data structures between modules, this
has a similar effect on running on a uniprocessor system.  This is the default and works best for
non-multiprocessor-safe modules written in accordance with @dfn{STREAMS} guidelines.
This level is roughly equivalent to @cite{Solaris} @var{D_MTPERMOD}
@vindex D_MTPERMOD
perimeters.

@item @var{SQLVL_QUEUEPAIR}
@vindex SQLVL_QUEUEPAIR
@cindex synchronization, queue pair
@tab @emph{Queue pair level synchronization.}
Specifies that each queue pair can be accessed by only one thread at the same time.  Only one thread
will be permitted to enter a given queue's procedures within a given queue pair.  Where the read and
write side of the queue pair share the same private structure (@samp{q->q_ptr}), this provides
multiprocessor protection of the common data structure to all synchronous entry points without an
external lock.
This level is roughly equivalent to @cite{Solaris} @var{D_MTAPAIR}
@vindex D_MTAPAIR
perimeters.

@item @var{SQLVL_QUEUE}
@vindex SQLVL_QUEUE
@cindex synchronization, queue
@tab @emph{Queue level synchronization.}
Specifies that each queue can be accessed by only one thread at the same time.  The module is run
with synchronization at the queue.  Only one thread of execution will be permitted to enter a given
queue's procedures, however, another thread will be permitted to enter procedures of the other queue
in the queue pair.  This is useful when the read and write side of a module are largely independent
and do not require synchronization between sides of the queue pair.
This level is roughly equivalent to @cite{Solaris} @var{D_MTPERQ}
@vindex D_MTPERQ
perimeters.

@item @var{SQLVL_NOP}
@vindex SQLVL_NOP
@cindex synchronization, none
@tab @emph{No synchronization.}
Specifies that each queue can be accessed by more than one thread at a the same time.  The
protection of internal data and of @command{put(9)}
@findex put(9)
and @command{srv(9)}
@findex srv(9)
procedures against @command{timeout(9)}
@findex timeout(9)
or @command{bufcall(9)}
@findex bufcall(9)
is done by the module or driver itself.  This synchronization level should be used essentially for
multiprocessor-efficient modules.
This level is roughly equivalent to @cite{Solaris} @var{D_MP}
@vindex D_MP
flag.
@end multitable

@node Synchronous Entry Points
@section Synchronous Entry Points
@cindex synchronous entry points

@dfn{Synchronous Entry Points} are those entry points into the @dfn{STREAMS} driver or module that
will be synchronized according to the specified synchronization level.

@multitable @columnfractions .20 .80
@item @command{put(9)}
@findex put(9)
@tab @emph{Queue put procedure.}
If the module has any synchronization level other than @var{SQLVL_NOP},
@vindex SQLVL_NOP
the put procedure will be exclusive.  Attempts to enter the put procedure while another thread is
running within the synchronization level will result in the call being postponed until the thread
currently in the synchronization level exits.

@item @command{srv(9)}
@findex srv(9)
@tab If the module has any synchronization level other than @var{SQLVL_NOP},
@vindex SQLVL_NOP
@emph{Queue service procedure.}
the service procedure will be exclusive.  Attempts to enter the service procedure while another
thread is running within the synchronization level will result in the service procedure being
postponed until the thread currently in the synchronization level exits.

@item @command{qopen(9)}
@findex qopen(9)
@tab @emph{Queue open procedure.}
The queue open procedure is synchronous and exclusive before the call to @command{qprocson(9)},
@findex qprocson(9)
or in any event, until return from the procedure.  If the module has synchronization level of
global, elsewhere or per-module; the call to the qopen procedure is exclusive.

@item @command{qclose(9)}
@findex qclose(9)
@tab @emph{Queue close procedure.}
The queue close procedure is synchronous and exclusive after the call to @command{qprocsoff(9)},
@findex qprocsoff(9)
or in any event, after return from the procedure.  If the module has synchronization level of
global, elsewhere or per-module; the call to the qclose procedure is exclusive.

@item @command{qprocson(9)}
@findex qprocson(9)
@tab
@emph{Queue procedures on.}
@item @command{qprocsoff(9)}
@findex qprocsoff(9)
@tab
@emph{Queue procedures off.}
@item @command{freezestr(9)}
@findex freezestr(9)
@tab
@emph{Freeze stream.}
@item @command{unfreezestr(9)}
@findex unfreezestr(9)
@tab
@emph{Thaw stream.}
@item @command{qwriter(9)}
@findex qwriter(9)
@tab
@emph{Queue writer.}
@end multitable

@node Synchronous Callbacks
@section Synchronous Callbacks
@cindex synchronous callbacks

@dfn{Synchronous Callbacks} are those callbacks into the @dfn{STREAMS} driver or module that
will be synchronized according to the specified synchronization level.  Synchronous callbacks are an
extension to the @cite{UNIX System V Release 4.2}
@cindex UNIX System V Release 4.2
specifications of @dfn{STREAMS}.  Synchronous callback extensions include @cite{Solaris} extensions
and @cite{AIX}
@cindex AIX
extensions.

These include:

@multitable @columnfractions .20 .80
@item @command{qbufcall(9)}
@findex qbufcall(9)
@tab -- queue referenced buffer call
@item @command{qtimeout(9)}
@findex qtimeout(9)
@tab -- queue referenced timeout
@item @command{qunbufcall(9)}
@findex qunbufcall(9)
@tab -- queue referenced buffer call cancel
@item @command{quntimeout(9)}
@findex quntimeout(9)
@tab -- queue referenced timeout cancel
@item @command{mi_bufcall(9)}
@findex mi_bufcall(9)
@tab -- queue reference buffer call
@end multitable

@node Synchronous Callouts
@section Synchronous Callouts
@cindex synchronous callouts

@multitable @columnfractions .20 .80
@item @command{putnext(9)}
@findex putnext(9)
@tab --
@item @command{qreply(9)}
@findex qreply(9)
@tab --
@end multitable

@node Asynchronous Entry Points
@section Asynchronous Entry Points
@cindex asynchronous entry points

@node Asynchronous Callbacks
@section Asynchronous Callbacks
@cindex asynchronous callbacks

@dfn{Asynchronous Callbacks} are those callbacks into the @dfn{STREAMS} driver or module that will
@emph{not} be synchronized according to the specified synchronization level.  Asynchronous callbacks
are the basic @cite{UNIX System V Release 4.2} callbacks.

@node Asynchronous Callouts
@section Asynchronous Callouts
@cindex asynchronous callouts

@node Administration
@chapter Administration
@cindex STREAMS, administration
@cindex administration, STREAMS

@menu
* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System
@end menu

@node Administrative Utilities
@section Administrative Utilities
@cindex administrative utilities

@multitable @columnfractions 0.25 0.75
@item @command{autopush(8)}
@pgindex autopush(8)
@tab control the autopush module list for a @cite{STREAMS} device
@item @command{fattach(8)}
@pgindex fattach(8)
@tab name a @cite{STREAMS} file
@item @command{fdetach(8)}
@pgindex fdetach(8)
@tab unlink a named @cite{STREAMS} file
@item @command{insf(8)}
@pgindex insf(8)
@tab install special device files
@item @command{scls(8)}
@pgindex scls(8)
@tab produce a list of module and driver names
@item @command{strace(8)}
@pgindex strace(8)
@tab write @cite{STREAMS} event trace messages to the standard output
@item @command{strclean(8)}
@pgindex strclean(8)
@tab clean up after the @cite{STREAMS} error and trace loggers
@item @command{strconf(8)}
@pgindex strconf(8)
@tab @cite{STREAMS} configuration utility
@item @command{streams_mknod(8)}
@pgindex streams_mknod(8)
@tab create or remove @cite{STREAMS} device nodes
@item @command{strerr(8)}
@pgindex strerr(8)
@tab receive error log messages from the @cite{STREAMS} @command{log(4)} driver
@item @command{strinfo(8)}
@pgindex strinfo(8)
@tab display information about @cite{STREAMS} devices
@item @command{strload(8)}
@pgindex strload(8)
@tab loads the @cite{STREAMS} subsystem
@item @command{strsetup(8)}
@pgindex strsetup(8)
@tab @cite{STREAMS} setup command
@item @command{strvf(8)}
@pgindex strvf(8)
@tab @cite{STREAMS} verification tool
@end multitable

@menu
* autopush(8)::			
* fattach(8)::			
* fdetach(8)::			
* insf(8)::			
* scls(8)::			
* strace(8)::			
* strclean(8)::			
* strconf(8)::			
* streams_mknod(8)::		
* strerr(8)::			
* strinfo(8)::			
* strload(8)::			
* strsetup(8)::			
* strvf(8)::			
@end menu

@page
@node autopush(8)
@subsection autopush(8)
@pgindex autopush(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node fattach(8)
@subsection fattach(8)
@pgindex fattach(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node fdetach(8)
@subsection fdetach(8)
@pgindex fdetach(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node insf(8)
@subsection insf(8)
@pgindex insf(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node scls(8)
@subsection scls(8)
@pgindex scls(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strace(8)
@subsection strace(8)
@pgindex strace(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strclean(8)
@subsection strclean(8)
@pgindex strclean(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strconf(8)
@subsection strconf(8)
@pgindex strconf(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node streams_mknod(8)
@subsection streams_mknod(8)
@pgindex streams_mknod(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strerr(8)
@subsection strerr(8)
@pgindex strerr(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strinfo(8)
@subsection strinfo(8)
@pgindex strinfo(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strload(8)
@subsection strload(8)
@pgindex strload(8)
@subsubheading NAME
@command{strload} -- loads the @cite{STREAMS} subsystem
@subsubheading SYNOPSIS
@smallexample
strload [-u|-q|[-l]] [-f @i{file}] [-d @i{list}] [-m @i{list}]
strload @{-h|--help@}
strload @{-V|--version@}
strload @{-C|--copying@}
@end smallexample
@subsubheading DESCRIPTION
@dfn{@value{PACKAGE_TITLE}} drivers and modules are dynamically loaded and unloaded.  To support
this fuction, each driver and module must have a configuration routine that performs the necessary
initialization and setup operations.

For compatibility with @cite{AIX PSE}, @dfn{@value{PACKAGE_TITLE}} provides the @command{strload}
command to load @cite{STREAMS} drivers and modules.  After loading the driver or module, the
@command{strload} command calls the driver or module entry point using the @var{SYS_CFGDD}
@vindex SYS_CFGDD
or
@var{SYS_CFGMOD}
@vindex SYS_CFGMOD
operations in @command{sysconfig(9)}.
@findex sysconfig(9)

Each @cite{STREAMS} driver of module must eventually call the @command{str_install(9)}
@findex str_install(9)
utility to link into @cite{STREAMS}.

Commonly used drivers or modules can be placed in a configuration file, which controls the normal
setup and tear-down of @dfn{@value{PACKAGE_TITLE}}.  The configuration file allows more flexibility
when loading drivers or modules by providing user-specified nodes and arguments.
@subsubheading OPTIONS
@table @code
@item [-l]
Loads the referenced drivers and modules.  (This is the default if the @samp{-q} and @samp{-u} flags
are not specified.)  If no configuration file, driver or modules are listed in the command options,
only the @cite{STREAMS} exeuctive is loaded;
@item -u, --unload
Unloads the referenced drivers and modules.  If no configuration file, drivers or modules are listed
in the command options, the entire @cite{STREAMS} executive is unloaded;
@item -q, --query
Queries the referenced drivers and moduels.  If no configuration file, drivers or modules are listed
in the command options, only the @cite{STREAMS} executive is queried;
@item -f, --file @i{file}
Specifies the file to use as the configuration file.  If @samp{-f} is not specified, the default
filename is @file{/etc/strload.conf}.
@pgindex /etc/strload.conf
@item -d, --drivers @i{list}
Specifies a list of driver names to load or unload.
@i{list} is a comma separated list of driver names.
@item -m, --modules @i{list}
Specifies a list of module names to load or unload.
@i{list} is a comma separated list of module names.
@end table
Without any options, by default, @command{strload} loads the @cite{STREAMS} executive and takes its
configuration from the file @file{/etc/strload.conf}.
@pgindex /etc/strload.conf
Only one of @samp{-l}, @samp{-q} and @samp{-u} are permitted.
@subsubheading FILE FORMAT
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strsetup(8)
@subsection strsetup(8)
@pgindex strsetup(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node strvf(8)
@subsection strvf(8)
@pgindex strvf(8)
@subsubheading NAME
@subsubheading SYNOPSIS
@subsubheading DESCRIPTION
@subsubheading APPLICATION USAGE
@subsubheading FUTURE DIRECTIONS
@subsubheading SEE ALSO
@subsubheading COMPATIBILITY
@subsubheading CONFORMANCE
@subsubheading HISTORY

@page
@node System Controls
@section System Controls
@cindex system controls

@dfn{@value{PACKAGE_TITLE}} provides and supports a number of system controls that can be accessed
using the /proc/sys/streams/* files, with the @manpage{sysctl(2)}
@findex sysctl(2)
interface, or using @manpage{sysctl(8)}.
@pgindex sysctl(8)

The following STREAMS specific system controls are provided by @dfn{@value{PACKAGE_TITLE}}:

@vtable @var

@item sys.streams.cltime
Defines the default time interval (in milliseconds) that closing stream will linger for messages to
clear its queues before finally closing.  Valid values are zero (0) or greater (MAXINT).  The
default value is the traditional UNIX value of 15,000 milliseconds (15 seconds).  This system
control defines the default for all new streams.  The value for a given stream can be changed with
the @manpage{streamio(7)} IO control @var{I_CLTIME},
@vindex I_CLTIME
after the stream is opened and before the stream is closed.

@item sys.streams.max_apush
Defines the maximum number of modules that can be configured for autopush onto a STREAMS driver.
Valid values are zero (0) or greater (MAXINT).  The default value is the traditional UNIX value of 8
modules.  This system control defines the maximum for all new autopush configurations.  Existing
autopush configurations are unchanged.

@item sys.streams.max_mblk
Defines the maximum number of combined message data blocks that will be held on the per-CPU free
list between runs of @manpage{runqueues(9)}.  Valid values are zero (0) or greater (@var{MAXINT}).
The default value is the traditional @i{UNIX} value of 10 blocks.  This system control defines the
maximum for the next run of @manpage{runqueues(9)} for all CPUs.  Increasing or decreasing this
number may have a positive or negative performance impact.

@item sys.streams.max_stramod
Defines the maximum number of autopush structures that can be defined for the entire system.  Valid
values are zero (0) or greater (@var{MAXINT}).  The default value is eight (8) ???????  This system
control defines the system-wide maximum.

@item sys.streams.max_strdev
Defines the maximum number of streams devices.  This is normally the maximum number of character
devices (@var{MAX_CHRDEV}).
@vindex MAX_CHRDEV
Valid values are zero (0) or greater (@var{MAXINT}).  The default value is @var{MAX_CHRDEV}
@vindex MAX_CHRDEV
(256).
This is a read-only system control.

@item sys.streams.max_strmod
Defines the maximum number of streams modules.  This is normally the maximum number of character
devices (@var{MAX_CHRDEV}).
@vindex MAX_CHRDEV
Valid values are zero (0) or greater (@var{MAXINT}).  The default value is @var{MAX_CHRDEV}
@vindex MAX_CHRDEV
(256).  This is a read-only system control.

@item sys.streams.msg_priority
Defines whether allocation priority will honoured or whether all allocations will be treated the
same.  See @manpage{allocb(9)}.  When true (non-zero), allocation priority will be honoured when
allocating message blocks.  When false (zero), allocation priority will be ignored.  Valid values
are zero (0) or non-zero.  The default value is zero (0).  Changing this value may have a positive
or negative impact on system performance.

@item sys.streams.nband
Defines the number of queue bands available.  Valid values are zero (0) or greater (@var{MAXINT}).
The default value is the traditional UNIX value of 256.  This system control defines the system wide
value.  This system control is read-only.

@item sys.streams.nstrmsgs
Defines the maximum number of combined message data blocks that will be allocated.  Valid values are
zero (0) or greater (@var{MAXINT}).  The default value is 2^12.  Changing this value may have a
positive or negative impact on system performance.  Setting this value to a small number may be
useful for debugging @i{STREAMS} drivers and modules.

@item sys.streams.nstrpush
Defines the maximum number of modules that can be pushed on a stream.  This includes both autopushed
modules and modules pushed using the
@var{I_PUSH}
@vindex I_PUSH
IO control of @manpage{streamio(7)}.  Valid values are zero (0) or greater (@var{MAXINT}).  The
default value is the traditional @cite{UNIX} value of 64.  This is the default values for all new
streams.  Existing streams are unaffected.

@item sys.streams.hiwat
Defines the default high water mark (in message bytes) for the stream head.  Valid values are zero
(0) or greater (@var{MAXINT}).  The default value is 5120.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@var{M_SETOPTS}
@vindex M_SETOPTS
message to the stream head.

@item sys.streams.lowat
Defines the default low water mark (in message bytes) for the stream head.  Valid values are zero
(0) or greater (@var{MAXINT}).  The default value is 1024.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@var{M_SETOPTS}
@vindex M_SETOPTS
message to the stream head.

@item sys.streams.maxpsz
Defines the maximum packet size accepted (in message bytes) for the stream head.  Valid values are
zero (0) or greater (@var{MAXINT}).  The default value is 2^12.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@var{M_SETOPTS}
@vindex M_SETOPTS
message to the stream head.

@item sys.streams.minpsz
Defines the minimum packet size accepted (in message bytes) for the stream head.  Valid values are
zero (0) or greater (@var{MAXINT}).  The default value is 0.  This is the default value for all new
stream heads.  Existing stream heads are unaffected.  The value on existing stream heads can be
changed by a driver or module by sending an
@var{M_SETOPTS}
@vindex M_SETOPTS
message to the stream head.

@item sys.streams.reuse_fmodsw
Defines whether fmodsw table entries will be reused.  When false (zero), fmodsw table entries will
not be reused.  When true (non-zero), fmodsw table entries will be reused.  Valid values are zero
(0) and non-zero.  The default value is false (zero).

@item sys.streams.rtime
Defines the time interval (in milliseconds) that the stream head will wait to forward held messages
when @var{SNDHOLD}
@vindex SNDHOLD
is set for the stream head.  Valid values are zero (0) or greater (@var{MAXINT}).  The default value
is 10 milliseconds (one clock tick).  This is the system wide value for all streams.  Changing this
value may have a positive or negative impact on system performance.

@item sys.streams.strhold
Defines whether the @var{SNDHOLD}
@vindex SNDHOLD
feature is active or not.  When false (0), the @var{SNDHOLD}
@vindex SNDHOLD
feature is deactivated.  When true (non-zero), the @var{SNDHOLD}
@vindex SNDHOLD
feature is activated.  Valid values are zero (0) or non-zero.  The default value is false (0).  This
is the default value for all new streams.  Existing streams are unaffected.  This setting can be
examined and altered on an open stream using the
@var{I_GWROPT}
@vindex I_GWROPT
and
@var{I_SWROPT}
@vindex I_SWROPT
IO controls of @manpage{streamio(7)}.

@item sys.streams.strctlsz
Defines the maximum @i{STREAMS} control part size.  Valid values are zero (0) or greater
(@var{MAXINT}).  The default value is 2^12.  This is the system wide maximum.  Existing allocations
are unaffected by lowering this value.  Changing this value can have an impact on users of
@manpage{putpmsg(2)}.

@item sys.streams.strmsgsz
Defines the maximum @i{STREAMS} message size.  Valid values are zero (0) or greater (@var{MAXINT}).
The default value is 2^18.  This is the system wide maximum.  Existing allocations are unaffected by
lowering this value.  Changing this value can have an impact on users of @manpage{write(2)},
@manpage{writev(2)}, and @manpage{putpmsg(2)}.

@item sys.streams.strthresh
Defines the maximum amount of memory that will be allocated for use by the STREAMS subsystem via
@manpage{kmem_alloc(9)} or @manpage{kmem_zalloc(9)}, or indirectly using @manpage{allocb(9)} or
allocating other @i{STREAMS} data structures.  Valid values are zero (0) or greater (@var{MAXINT}).
This is the system wide maximum.  Existing allocations are unaffected by lowering this value.
Changing this value to a low value may have some use in debugging @i{STREAMS} drivers and modules.

@end vtable

@node /proc File System
@section /proc File System
@cindex /proc file system


@node Conformance
@chapter Conformance
@cindex conformance
@menu
* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX comptatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
* LiS Compatibility::		LiS 2.18.1 Compatibility
@end menu

@node SVR 4.2 Compatibility
@section SVR 4.2 MP DDI/DKI Compatibility
@cindex SVR 4.2 MP, compatibility
@cindex compatibility, SVR 4.2 MP
@cindex SVR 4.2 MP

@node AIX Compatibility
@section AIX 5L Version 5.1 Compatibility
@cindex AIX 5L Version 5.1, compatibility
@cindex compatibility, AIX 5L Version 5.1
@cindex AIX PSE

@node HP-UX Compatibility
@section HP-UX 11.0i v2 Compatibility
@cindex HP-UX 11.0i v2, compatibility
@cindex compatibility, HP-UX 11.0i v2
@cindex HP-UX

@node OSF/1 Compatibility
@section OSF/1 1.2/Digital UNIX Compatibility
@cindex OSF/1 1.2/Digital UNIX, compatibility
@cindex compatibility, OSF/1 1.2/Digital
@cindex OSF/1

@node UnixWare Compatibility
@section UnixWare 7.1.3 Compatibility
@cindex UnixWare 7.1.3 (OpenUnix 8), compatibility
@cindex compatibility, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@node Solaris Compatibility
@section Solaris 9/SunOS 5.9 Compatibility
@cindex Solaris 9/SunOS 5.9, compatibility
@cindex compatibility, Solaris 9/SunOS 5.9
@cindex Solaris

@node SUX Compatibility
@section Super/UX Compatibility
@cindex Super/UX, compatibility
@cindex compatibility, Super/UX
@cindex Super/UX

@node UXP Compatibility
@section UXP/V Compatibility
@cindex UXP/V, compatibility
@cindex compatibility, UXP/V
@cindex UXP/V

@node LiS Compatibility
@section LiS 2.18.1 Compatibility
@cindex LiS 2.18.1, compatibility
@cindex compatibility, LiS 2.18.1
@cindex Linux STREAMS (LiS)

@node Portability
@chapter Portability
@cindex portability

Although each of the manual pages of supported functions and structures provides compatibility and
porting information, this document attempts to gather together pertinent information concerning
porting from various @cite{UNIX} operating system supporting @cite{STREAMS}.

The porting information is organized by the operating system from which porting is being attempted.
Note that, aside from configuration details, any system not listed here that is based on @cite{SVR
4.2 MP}
@cindex SVR 4.2 MP
or on a another of the implementations, should start with that implementation's portability
information.

Porting information is organized into sections as follows:

@menu
* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3 (OpenUnix 8)
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* LiS Portability::		Porting from LiS 2.18.1
* Development::			Developing Portable STREAMS Modules
@end menu

@node Core Function Support
@section Porting with Core Function Support
@cindex porting, core function support

@menu
* Core Message Functions::
* Core UP Queue Functions::
* Core MP Queue Functions::
* Core DDI/DKI Functions::
* Some Common Extension Functions::
* Some Internal Functions::
* Some Oddball Functions::
@end menu

@node Core Message Functions
@subsection Core Message Functions
@cindex core message functions

@multitable @columnfractions .20 .80
@item @command{adjmsg(9)}
@findex adjmsg(9)
@tab trim bytes from the front or back of a @cite{STREAMS} message
@item @command{allocb(9)}
@findex allocb(9)
@tab allocate a @cite{STREAMS} message and data block
@item @command{bufcall(9)}
@findex bufcall(9)
@tab install a buffer callback
@item @command{copyb(9)}
@findex copyb(9)
@tab copy a @cite{STREAMS} message block
@item @command{copymsg(9)}
@findex copymsg(9)
@tab copy a @cite{STREAMS} message
@item @command{datamsg(9)}
@findex datamsg(9)
@tab tests a @cite{STREAMS} message type for data
@item @command{dupb(9)}
@findex dupb(9)
@tab duplicate a @cite{STREAMS} message block
@item @command{dupmsg(9)}
@findex dupmsg(9)
@tab duplicate a @cite{STREAMS} message
@item @command{esballoc(9)}
@findex esballoc(9)
@tab allocate a @cite{STREAMS} message and data block with a caller supplied data buffer
@item @command{freeb(9)}
@findex freeb(9)
@tab frees a @cite{STREAMS} message block
@item @command{freemsg(9)}
@findex freemsg(9)
@tab frees a @cite{STREAMS} message
@item @command{linkb(9)}
@findex linkb(9)
@tab link a message block to a @cite{STREAMS} message
@item @command{msgdsize(9)}
@findex msgdsize(9)
@tab calculate the size of the data in a @cite{STREAMS} message
@item @command{msgpullup(9)}
@findex msgpullup(9)
@tab pull up bytes in a @cite{STREAMS} message
@item @command{pcmsg(9)}
@findex pcmsg(9)
@tab test a data block message type for priority control
@item @command{pullupmsg(9)}
@findex pullupmsg(9)
@tab pull up the bytes in a @cite{STREAMS} message
@item @command{rmvb(9)}
@findex rmvb(9)
@tab remove a message block from a @cite{STREAMS} message
@item @command{testb(9)}
@findex testb(9)
@tab test if a @cite{STREAMS} message can be allocated
@item @command{unbufcall(9)}
@findex unbufcall(9)
@tab remove a @cite{STREAMS} buffer callback
@item @command{unlinkb(9)}
@findex unlinkb(9)
@tab unlink a message block from a @cite{STREAMS} message
@end multitable

@node Core UP Queue Functions
@subsection Core UP Queue Functions
@cindex core queue functions, UP

@multitable @columnfractions .20 .80
@item @command{backq(9)}
@findex backq(9)
@tab find the upstream or downstream queue
@item @command{bcanput(9)}
@findex bcanput(9)
@tab test flow control on a @cite{STREAMS} message queue
@item @command{canenable(9)}
@findex canenable(9)
@tab test whether a @cite{STREAMS} message queue can be scheduled
@item @command{enableok(9)}
@findex enableok(9)
@tab allow a @cite{STREAMS} message queue to be scheduled
@item @command{flushband(9)}
@findex flushband(9)
@tab flushes band @cite{STREAMS} messages from a message queue
@item @command{flushq(9)}
@findex flushq(9)
@tab flushes messages from a @cite{STREAMS} message queue
@item @command{getq(9)}
@findex getq(9)
@tab gets a message from a @cite{STREAMS} message queue
@item @command{insq(9)}
@findex insq(9)
@tab inserts a message into a @cite{STREAMS} message queue
@item @command{noenable(9)}
@findex noenable(9)
@tab disable a @cite{STREAMS} message queue from being scheduled
@item @command{OTHERQ(9)}
@findex OTHERQ(9)
@tab return the other queue of a @cite{STREAMS} queue pair
@item @command{putbq(9)}
@findex putbq(9)
@tab put a message back on a @cite{STREAMS} message queue
@item @command{putctl(9)}
@findex putctl(9)
@tab put a control message on a @cite{STREAMS} message queue
@item @command{putctl1(9)}
@findex putctl1(9)
@tab put a 1 byte control message on a @cite{STREAMS} message queue
@item @command{putq(9)}
@findex putq(9)
@tab put a message on a @cite{STREAMS} message queue
@item @command{qenable(9)}
@findex qenable(9)
@tab schedules a @cite{STREAMS} message queue service routine
@item @command{qreply(9)}
@findex qreply(9)
@tab replies to a message from a @cite{STREAMS} message queue
@item @command{qsize(9)}
@findex qsize(9)
@tab return the number of message on a queue
@item @command{RD(9)}
@findex RD(9)
@tab return the read queue of a @cite{STREAMS} queue pair
@item @command{rmvq(9)}
@findex rmvq(9)
@tab remove a message from a @cite{STREAMS} message queue
@item @command{SAMESTR(9)}
@findex SAMESTR(9)
@tab test for @cite{STREAMS} pipe or FIFO
@item @command{WR(9)}
@findex WR(9)
@tab return the write queue of a @cite{STREAMS} queue pair
@end multitable

@node Core MP Queue Functions
@subsection Core MP Queue Functions
@cindex core queue functions, MP

@multitable @columnfractions .20 .80
@item @command{canputnext(9)}
@findex bcanputnext(9)
@tab test flow control on a message queue
@item @command{canputnext(9)}
@findex canputnext(9)
@tab test flow control on a message queue
@item @command{freezestr(9)}
@findex freezestr(9)
@tab freeze the state of a stream queue
@item @command{put(9)}
@findex put(9)
@tab invoke the put procedure for a @cite{STREAMS} module or driver with a @cite{STREAMS} message
@item @command{putnext(9)}
@findex putnext(9)
@tab put a message on the downstream @cite{STREAMS} message queue
@item @command{putnextctl1(9)}
@findex putnextctl1(9)
@tab put a 1 byte control message on the downstream @cite{STREAMS} message queue
@item @command{putnextctl(9)}
@findex putnextctl(9)
@tab put a control message on the downstream @cite{STREAMS} message queue
@item @command{qprocsoff(9)}
@findex qprocsoff(9)
@tab disables @cite{STREAMS} message queue processing for multi-processing
@item @command{qprocson(9)}
@findex qprocson(9)
@tab enables @cite{STREAMS} message queue processing for multi-processing
@item @command{strqget(9)}
@findex strqget(9)
@tab gets information about a @cite{STREAMS} message queue
@item @command{strqset(9)}
@findex strqset(9)
@tab sets attributes of a @cite{STREAMS} message queue
@item @command{unfreezestr(9)}
@findex unfreezestr(9)
@tab thaw the state of a stream queue
@end multitable

@node Core DDI/DKI Functions
@subsection Core DDI/DKI Functions
@cindex core ddi/dki functions
@cindex DDI/DKI

@multitable @columnfractions .20 .80
@item @command{kmem_alloc(9)}
@findex kmem_alloc(9)
@tab allocate kernel memory
@item @command{kmem_free(9)}
@findex kmem_free(9)
@tab deallocates kernel memory
@item @command{kmem_zalloc(9)}
@findex kmem_zalloc(9)
@tab allocate and zero kernel memory
@item @command{cmn_err(9)}
@findex cmn_err(9)
@tab print a kernel command error
@item @command{bcopy(9)}
@findex bcopy(9)
@tab copy byte strings
@item @command{bzero(9)}
@findex bzero(9)
@tab zero a byte string
@item @command{copyin(9)}
@findex copyin(9)
@tab copy user data in from user space to kernel space
@item @command{copyout(9)}
@findex copyout(9)
@tab copy user data in from kernel space to user space
@item @command{delay(9)}
@findex delay(9)
@tab postpone the calling process for a number of clock ticks
@item @command{drv_getparm(9)}
@findex drv_getparm(9)
@tab driver retrieve kernel parameter
@item @command{drv_hztomsec(9)}
@findex drv_hztomsec(9)
@tab convert kernel tick time between microseconds or milliseconds
@item @command{drv_htztousec(9)}
@findex drv_htztousec(9)
@tab convert kernel tick time between microseconds or milliseconds
@item @command{drv_msectohz(9)}
@findex drv_msectohz(9)
@tab convert kernel tick time between microseconds or milliseconds
@item @command{drv_priv(9)}
@findex drv_priv(9)
@tab check if the current process is privileged
@item @command{drv_usectohz(9)}
@findex drv_usectohz(9)
@tab convert kernel tick time between microseconds or milliseconds
@item @command{drv_usecwait(9)}
@findex drv_usecwait(9)
@tab delay for a number of microseconds
@item @command{min(9)}
@findex min(9)
@tab determine the minimum of two integers
@item @command{max(9)}
@findex max(9)
@tab determine the maximum of two integers
@item @command{getmajor(9)}
@findex getmajor(9)
@tab get the internal major device number for a device
@item @command{getminor(9)}
@findex getminor(9)
@tab get the extended minor device number for a device
@item @command{makedevice(9)}
@findex makedevice(9)
@tab create a device from a major and minor device numbers
@item @command{strlog(9)}
@findex strlog(9)
@tab pass a message to the @cite{STREAMS} logger
@item @command{timeout(9)}
@findex timeout(9)
@tab start a timer
@item @command{untimeout(9)}
@findex untimeout(9)
@tab stop a timer
@end multitable

@multitable @columnfractions .20 .80
@item @command{mknod(9)}
@findex mknod(9)
@tab make block or character special files
@item @command{mount(9)}
@findex mount(9)
@tab mount and unmount file systems
@item @command{umount(9)}
@findex umount(9)
@tab mount and unmount file systems
@item @command{unlink(9)}
@findex unlink(9)
@tab remove a file
@end multitable

@node Some Common Extension Functions
@subsection Some Common Extension Functions
@cindex common extension functions

@multitable @columnfractions .20 .80
@item @command{linkmsg(9)}
@findex linkmsg(9)
@tab link a message block to a @cite{STREAMS} message
@item @command{putctl2(9)}
@findex putctl2(9)
@tab put a two byte control message on a @cite{STREAMS} message queue
@item @command{putnextctl2(9)}
@findex putnextctl2(9)
@tab put a two byte control message on the downstream @cite{STREAMS} message queue
@item @command{weldq(9)}
@findex weldq(9)
@tab weld two (or four) queues together
@item @command{unweldq(9)}
@findex unweldq(9)
@tab unweld two (or four) queues
@end multitable

@node Some Internal Functions
@subsection Some Internal Functions
@cindex internal functions

@multitable @columnfractions .20 .80
@item @command{allocq(9)}
@findex allocq(9)
@tab allocate a @cite{STREAMS} queue pair
@item @command{bcanget(9)}
@findex bcanget(9)
@tab test for message arrival on a band on a stream
@item @command{canget(9)}
@findex canget(9)
@tab test for message arrival on a stream
@item @command{freeq(9)}
@findex freeq(9)
@tab deallocate a @cite{STREAMS} queue pair
@item @command{qattach(9)}
@findex qattach(9)
@tab attach a module onto a @cite{STREAMS} file
@item @command{qclose(9)}
@findex qclose(9)
@tab close a @cite{STREAMS} module or driver
@item @command{qdetach(9)}
@findex qdetach(9)
@tab detach a module from a @cite{STREAMS} file
@item @command{qopen(9)}
@findex qopen(9)
@tab call a @cite{STREAMS} module or driver open routine
@item @command{setq(9)}
@findex setq(9)
@tab set sizes and procedures associated with a @cite{STREAMS} message queue
@end multitable

@node Some Oddball Functions
@subsection Some Oddball Functions
@cindex oddball functions

@multitable @columnfractions .20 .80
@item @command{appq(9)}
@findex appq(9)
@tab append one @cite{STREAMS} message after another
@item @command{esbbcall(9)}
@findex esbbcall(9)
@tab install a buffer callback for an extended @cite{STREAMS} message block
@item @command{isdatablk(9)}
@findex isdatablk(9)
@tab test a @cite{STREAMS} data block for data type
@item @command{isdatamsg(9)}
@findex isdatamsg(9)
@tab test a @cite{STREAMS} data block for data type
@item @command{kmem_zalloc_node(9)}
@findex kmem_zalloc_node(9)
@item @command{msgsize(9)}
@findex msgsize(9)
@tab calculate the size of the message blocks in a @cite{STREAMS} message
@item @command{qcountstrm(9)}
@findex qcountstrm(9)
@tab add all counts on all @cite{STREAMS} message queues in a stream
@item @command{xmsgsize(9)}
@findex xmsgsize(9)
@tab calculate the size of message blocks in a @cite{STREAMS} message
@end multitable

@node SVR 4.2 Portability
@section Porting from SVR 4.2 MP
@cindex porting, SVR 4.2 MP
@cindex SVR 4.2 MP, portability
@cindex SVR 4.2 MP

This section captures portability information for SVR 4.2 MP based systems.  If the operating system
from which you are porting more closely fits one of the other portability sections, please see that
section.

@menu
* Differences from SVR 4.2 MP::
* Commonalities with SVR 4.2 MP::
* Compatibility functions for SVR 4.2 MP::
* Configuration ala SVR 4.2 MP::
@end menu

@node Differences from SVR 4.2 MP
@subsection Differences from SVR 4.2 MP
@cindex differences, SVR 4.2 MP
@cindex SVR 4.2 MP, differences
@cindex SVR 4.2 MP

@dfn{@value{PACKAGE_TITLE}} has very few differences from @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
Not all @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
functions are implemented in the base @dfn{@value{PACKAGE_TITLE}} kernel modules.  Some functions are
included in the @cite{SVR 4.2 MP} compatibility module, @file{streams-svr4compat.o}.

@node Commonalities with SVR 4.2 MP
@subsection Commonalities with SVR 4.2 MP
@cindex commonalities, SVR 4.2 MP
@cindex SVR 4.2 MP, commonalities
@cindex SVR 4.2 MP

@node Compatibility functions for SVR 4.2 MP
@subsection Compatibility functions for SVR 4.2 MP
@cindex compatibility functions, SVR 4.2 MP
@cindex SVR 4.2 MP, compatibility functions
@cindex SVR 4.2 MP

@multitable @columnfractions .20 .80
@item @command{itimeout(9)}
@findex itimeout(9)
@tab Perform a timeout at an interrupt level.
@item @command{lbolt(9)}
@findex lbolt(9)
@tab Time in ticks since reboot.
@item @command{sleep(9)}
@findex sleep(9)
@tab Put a process to sleep.
@item @command{wakeup(9)}
@findex wakeup(9)
@tab Wake a process.
@item @command{vtop(9)}
@findex vtop(9)
@tab Convert virtual to physical address.
@end multitable

@subsubsection Priority Levels

@b{Linux} has a different concept of priority levels than @cite{SVR 4.2 MP}.
@cindex SVR 4.2 MP
@b{Linux} has basically 4 priority levels as follows:

@enumerate

@item Preemptive

At this priority level, software and hardware interrupts are enabled and the kernel is executing
with preemption enabled.  This means that the currently executing kernel thread could preempt and
sleep in favour of another thread of kernel execution.

This priority level only exists on preemptive (mostly 2.6) kernels.

@item Non-Preemptive

At this priority level, software and hardware interrupts are enabled and the kernel is executing
with preemption disabled.  This means that the currently executing kernel thread will only be
interrupted by software or hardware interrupts.

This priority level exists in all kernels.

@item Software Interrupts Disabled

At this priority level, software interrupts are disabled and the kernel is executing with preemption
disabled.  This means that the currently executing kernel thread will only be interrupted by
hardware interrupts.

This is the case when the executing thread is processing a software interrupt, or when the currently
executing thread has disabled software interrupts.

This priority level exists in all kernels.

@item Interrupt Service Routines Disabled

At this priority level, hardware interrupts are disabled and the kernel is executing with preemption
disabled.  This means that the currently executing kernel thread will not be interrupted.

This is the case when the executing thread is processing a hardware interrupt, or when the currently
executing thread has disabled hardware interrupts.

This priority level exists in all kernels.

@end enumerate

@multitable @columnfractions .20 .80
@item @command{spl0(9)}
@findex spl0(9)
@tab Set priority level 0.
@item @command{spl1(9)}
@findex spl1(9)
@tab Set priority level 1.
@item @command{spl2(9)}
@findex spl2(9)
@tab Set priority level 2.
@item @command{spl3(9)}
@findex spl3(9)
@tab Set priority level 3.
@item @command{spl4(9)}
@findex spl4(9)
@tab Set priority level 4.
@item @command{spl5(9)}
@findex spl5(9)
@tab Set priority level 5.
@item @command{spl7(9)}
@findex spl6(9)
@tab Set priority level 6.
@item @command{spl7(9)}
@findex spl7(9)
@tab Set priority level 7.
@item @command{spl(9)}
@findex spl(9)
@tab Set priority level.
@item @command{splx(9)}
@findex splx(9)
@tab Set priority level x.
@end multitable

@subsubsection Atomic Integers

@multitable @columnfractions .30 .70
@item @command{ATOMIC_INT_ADD(9)}
@findex ATOMIC_INT_ADD(9)
@tab Add an integer value to an atomic integer.
@item @command{ATOMIC_INT_ALLOC(9)}
@findex ATOMIC_INT_ALLOC(9)
@tab Allocate and initialize an atomic integer.
@item @command{ATOMIC_INT_DEALLOC(9)}
@findex ATOMIC_INT_DEALLOC(9)
@tab Deallocate an atomic integer.
@item @command{ATOMIC_INT_DECR(9)}
@findex ATOMIC_INT_DECR(9)
@tab Decrement and test an atomic integer.
@item @command{ATOMIC_INT_INCR(9)}
@findex ATOMIC_INT_INCR(9)
@tab Increment an atomic integer.
@item @command{ATOMIC_INT_INIT(9)}
@findex ATOMIC_INT_INIT(9)
@tab Initialize an atomic integer.
@item @command{ATOMIC_INT_READ(9)}
@findex ATOMIC_INT_READ(9)
@tab Read an atomic integer.
@item @command{ATOMIC_INT_SUB(9)}
@findex ATOMIC_INT_SUB(9)
@tab Subtract and integer value from an atomic integer.
@item @command{ATOMIC_INT_WRITE(9)}
@findex ATOMIC_INT_WRITE(9)
@tab Write an integer value to an atomic integer.
@end multitable

@subsubsection Basic Locks

@multitable @columnfractions .30 .70
@item @command{LOCK(9)}
@findex LOCK(9)
@tab Lock a basic lock.
@item @command{LOCK_ALLOC(9)}
@findex LOCK_ALLOC(9)
@tab Allocate a basic lock.
@item @command{LOCK_DEALLOC(9)}
@findex LOCK_DEALLOC(9)
@tab Deallocate a basic lock.
@item @command{LOCK_OWNED(9)}
@findex LOCK_OWNED(9)
@tab Determine whether a basic lock is head by the caller.
@item @command{TRYLOCK(9)}
@findex TRYLOCK(9)
@tab Try to lock a basic lock.
@item @command{UNLOCK(9)}
@findex UNLOCK(9)
@tab Unlock a basic lock.
@end multitable

@subsubsection STREAMS Locks

@multitable @columnfractions .30 .70
@item @command{MPSTR_QLOCK(9)}
@findex MPSTR_QLOCK(9)
@tab Release a queue from exclusive access.
@item @command{MPSTR_QRELE(9)}
@findex MPSTR_QRELE(9)
@tab Acquire a queue for exclusive access.
@item @command{MPSTR_STPLOCK(9)}
@findex MPSTR_STPLOCK(9)
@tab Acquire a stream head for exclusive access.
@item @command{MPSTR_STPRELE(9)}
@findex MPSTR_STPRELE(9)
@tab Release a stream head from exclusive access.
@end multitable

@subsubsection Read/Write Locks

@multitable @columnfractions .30 .70
@item @command{RW_ALLOC(9)}
@findex RW_ALLOC(9)
@tab Allocate and initialize a read/write lock.
@item @command{RW_DEALLOC(9)}
@findex RW_DEALLOC(9)
@tab Deallocate a read/write lock.
@item @command{RW_RDLOCK(9)}
@findex RW_RDLOCK(9)
@tab Acquire a read/write lock in read mode.
@item @command{RW_TRYRDLOCK(9)}
@findex RW_TRYRDLOCK(9)
@tab Attempt to acquire a read/write lock in read mode.
@item @command{RW_TRYWRLOCK(9)}
@findex RW_TRYWRLOCK(9)
@tab Attempt to acquire a read/write lock in write mode.
@item @command{RW_UNLOCK(9)}
@findex RW_UNLOCK(9)
@tab Release a read/write lock.
@item @command{RW_WRLOCK(9)}
@findex RW_WRLOCK(9)
@tab Acquire a read/write lock in write mode.
@end multitable

@subsubsection Sleep Locks

@multitable @columnfractions .30 .70
@item @command{SLEEP_ALLOC(9)}
@findex SLEEP_ALLOC(9)
@tab Allocate a sleep lock.
@item @command{SLEEP_DEALLOC(9)}
@findex SLEEP_DEALLOC(9)
@tab Deallocate a sleep lock.
@item @command{SLEEP_LOCK(9)}
@findex SLEEP_LOCK(9)
@tab Acquire a sleep lock.
@item @command{SLEEP_LOCKAVAIL(9)}
@findex SLEEP_LOCKAVAIL(9)
@tab Determine whether a sleep lock is available.
@item @command{SLEEP_LOCKOWNED(9)}
@findex SLEEP_LOCKOWNED(9)
@tab Determine whether a sleep lock is held by the caller.
@item @command{SLEEP_LOCK_SIG(9)}
@findex SLEEP_LOCK_SIG(9)
@tab Acquire a sleep lock.
@item @command{SLEEP_TRYLOCK(9)}
@findex SLEEP_TRYLOCK(9)
@tab Attempt to acquire a sleep lock.
@item @command{SLEEP_UNLOCK(9)}
@findex SLEEP_UNLOCK(9)
@tab Release a sleep lock.
@end multitable

@subsubsection Synchronization Variables

@multitable @columnfractions .30 .70
@item @command{SV_ALLOC(9)}
@findex SV_ALLOC(9)
@tab Allocate a basic condition variable.
@item @command{SV_BROADCAST(9)}
@findex SV_BROADCAST(9)
@tab Broadcast a basic condition variable.
@item @command{SV_DEALLOC(9)}
@findex SV_DEALLOC(9)
@tab Deallocate a basic condition variable.
@item @command{SV_SIGNAL(9)}
@findex SV_SIGNAL(9)
@tab Signal a basic condition variable.
@item @command{SV_WAIT(9)}
@findex SV_WAIT(9)
@tab Wait on a basic condition variable.
@item @command{SV_WAIT_SIG(9)}
@findex SV_WAIT_SIG(9)
@tab Interruptible wait on a basic condition variable.
@end multitable

@subsubsection Resource Allocation

@multitable @columnfractions .30 .70
@item @command{rmalloc(9)}
@findex rmalloc(9)
@tab Allocate a number of units from a resource map.
@item @command{rmallocmap(9)}
@findex rmallocmap(9)
@tab Allocated a resource map.
@item @command{rmallocmap_wait(9)}
@findex rmallocmap_wait(9)
@tab Allocated a resource map.
@item @command{rmalloc_wait(9)}
@findex rmalloc_wait(9)
@tab Allocate a number of units from a resource map.
@item @command{rmfree(9)}
@findex rmfree(9)
@tab Free a number of units from a resource map.
@item @command{rmfreemap(9)}
@findex rmfreemap(9)
@tab Free a resource map.
@item @command{rmget(9)}
@findex rmget(9)
@tab Allocated a number of units from a resource map.
@item @command{rminit(9)}
@findex rminit(9)
@tab Initialize a resource map.
@item @command{rmsetwant(9)}
@findex rmsetwant(9)
@tab Wait for resources on a resource map.
@item @command{rmwanted(9)}
@findex rmwanted(9)
@tab Waiters on a resource map.
@end multitable

@subsubsection Device Numbering

@multitable @columnfractions .20 .80
@item @command{major(9)}
@findex major(9)
@tab Get the internal major number of a device.
@item @command{makedev(9)}
@findex makedev(9)
@tab Make a device number from internal major and minor device numbers.
@item @command{minor(9)}
@findex minor(9)
@tab Get the internal minor number of a device.
@end multitable

@node Configuration ala SVR 4.2 MP
@subsection Configuration ala SVR 4.2 MP
@cindex configuration, SVR 4.2 MP
@cindex SVR 4.2 MP, configuration
@cindex SVR 4.2 MP


@node AIX Portability
@section Porting from AIX 5L Version 5.1
@cindex porting, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, portability
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@menu
* Differences from AIX 5L Version 5.1::
* Commonalities with AIX 5L Version 5.1::
* Compatibility Functions for AIX 5L Version 5.1::
* Configuration ala AIX 5L Version 5.1::
@end menu

@node Differences from AIX 5L Version 5.1
@subsection Differences from AIX 5L Version 5.1
@cindex differences, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, differences
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@node Commonalities with AIX 5L Version 5.1
@subsection Commonalities with AIX 5L Version 5.1
@cindex commonalities, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, commonalities
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@node Compatibility Functions for AIX 5L Version 5.1
@subsection Compatibility Functions for AIX 5L Version 5.1
@cindex compatibility functions, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, compatibility functions
@cindex AIX 5L Version 5.1
@cindex AIX PSE

@subsubsection Core Extensions

@multitable @columnfractions .20 .80
@item @command{putctl2(9)}
@findex putctl2(9)
@tab Put a 2 byte control message on a @cite{STREAMS} message queue.
@command{putctl2(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{splstr(9)}
@findex splstr(9)
@tab Set or restore priority levels.
@command{splstr(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{splx(9)}
@findex splx(9)
@tab Set or restore priority levels.
@command{splx(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld together two pairs of @cite{STREAMS} message queues.
@command{weldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two pairs of @cite{STREAMS} message queues.
@command{unweldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@end multitable

@subsubsection Common Module Utilities

@multitable @columnfractions .30 .70
@item @command{mi_bufcall(9)}
@findex mi_bufcall(9)
@tab Reliable alternative to @command{buffcall(9)}.
@item @command{mi_close_comm(9)}
@findex mi_close_comm(9)
@tab @cite{STREAMS} common minor device close utility.
@item @command{mi_next_ptr(9)}
@findex mi_next_ptr(9)
@tab @cite{STREAMS} minor device list traversal.
@item @command{mi_open_comm(9)}
@findex mi_open_comm(9)
@tab @cite{STREAMS} common minor device open utility.
@item @command{mi_prev_ptr(9)}
@findex mi_prev_ptr(9)
@tab @cite{STREAMS} minor device list traversal.
@end multitable

@subsubsection Registration

@multitable @columnfractions .20 .80
@item @command{str_install(9)}
@findex str_install(9)
@tab Install a @cite{STREAMS} module or driver.
@end multitable

@subsubsection Message Filtering

@multitable @columnfractions .20 .80
@item @command{wantio(9)}
@findex wantio(9)
@tab Perform direct I/O from a @cite{STREAMS} driver.
@item @command{wantmsg(9)}
@findex wantmsg(9)
@tab Provide a filter of wanted messages from a @cite{STREAMS} module.
@end multitable

@node Configuration ala AIX 5L Version 5.1
@subsection Configuration ala AIX 5L Version 5.1
@cindex configuration, AIX 5L Version 5.1
@cindex AIX 5L Version 5.1, configuration
@cindex AIX PSE


@node HP-UX Portability
@section Porting from HP-UX 11.0i v2
@cindex porting, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, portability
@cindex HP-UX 11.0i v2
@cindex HP-UX

@menu
* Differences from HP-UX 11.0i v2::
* Commonalities with HP-UX 11.0i v2::
* Compatibility Functions for HP-UX 11.0i v2::
* Configuration ala HP-UX 11.0i v2::
@end menu

@node Differences from HP-UX 11.0i v2
@subsection Differences from HP-UX 11.0i v2
@cindex differences, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, differences
@cindex HP-UX 11.0i v2
@cindex HP-UX

@node Commonalities with HP-UX 11.0i v2
@subsection Commonalities with HP-UX 11.0i v2
@cindex commonalities, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, commonalities
@cindex HP-UX 11.0i v2
@cindex HP-UX

@node Compatibility Functions for HP-UX 11.0i v2
@subsection Compatibility Functions for HP-UX 11.0i v2
@cindex compatibility functions, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, compatibility functions
@cindex HP-UX 11.0i v2
@cindex HP-UX

@subsubsection Core Extensions

@multitable @columnfractions .20 .80
@item @command{streams_put(9)}
@findex streams_put(9)
@tab Invoke the put procedure for a @cite{STREAMS} module or driver with a @cite{STREAMS} message.
@command{streams_put(9)}
@findex streams_put(9)
is implemented using @command{put(9)}.
@findex put(9)
@command{put(9)}
@findex put(9)
is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{putctl2(9)}
@findex putctl2(9)
@tab Put a 2 byte control message on a @cite{STREAMS} message queue.
@command{putctl2(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{putnextctl2(9)}
@findex putnextctl2(9)
@tab Put a 2 byte control message on the downstream @cite{STREAMS} message queue.
@command{putnextctl2(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two pairs of streams queues.
@command{unweldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld together two pairs of streams queues.
@command{weldq(9)} is a @dfn{@value{PACKAGE_TITLE}} core function.
@end multitable

@subsubsection Registration

@multitable @columnfractions .20 .80
@item @command{str_install(9)}
@findex str_install(9)
@tab Install a @cite{STREAMS} module or driver.
@item @command{str_uninstall(9)}
@findex str_uninstall(9)
@tab Uninstall a @cite{STREAMS} module or driver.
@end multitable

@subsubsection Sleeping

@multitable @columnfractions .20 .80
@item @command{streams_get_sleep_lock(9)}
@findex streams_get_sleep_lock(9)
@tab Provide access to the global sleep lock.
@end multitable

@node Configuration ala HP-UX 11.0i v2
@subsection Configuration ala HP-UX 11.0i v2
@cindex configuration, HP-UX 11.0i v2
@cindex HP-UX 11.0i v2, configuration
@cindex HP-UX 11.0i v2
@cindex HP-UX


@node OSF/1 Portability
@section Porting from OSF/1 1.2/Digital UNIX
@cindex porting, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, portability
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@menu
* Differences from OSF/1 1.2/Digital UNIX::
* Commonalities with OSF/1 1.2/Digital UNIX::
* Compatibility Functions for OSF/1 1.2/Digital UNIX::
* Configuration ala OSF/1 1.2/Digital UNIX::
@end menu

@node Differences from OSF/1 1.2/Digital UNIX
@subsection Differences from OSF/1 1.2/Digital UNIX
@cindex differences, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, differences
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@node Commonalities with OSF/1 1.2/Digital UNIX
@subsection Commonalities with OSF/1 1.2/Digital UNIX
@cindex commonalities, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, commonalities
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@node Compatibility Functions for OSF/1 1.2/Digital UNIX
@subsection Compatibility Functions for OSF/1 1.2/Digital UNIX
@cindex compatibility functions, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, compatibility functions
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1

@subsubsection Core Extensions

@multitable @columnfractions .20 .80
@item @command{lbolt(9)}
@findex lbolt(9)
@tab Time in ticks since reboot
@command{lbolt(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{puthere(9)}
@findex puthere(9)
@tab Invoke the put procedure for a @cite{STREAMS} module or driver with a @cite{STREAMS} message.
@command{puthere(9)}
@findex puthere(9)
is implemented using @command{put(9)}.
@findex put(9)
@command{put(9)}
@findex put(9)
is a  @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{weldq(9)}
@findex weldq(9)
@tab Weld together two pairs of streams queues.
@command{weldq(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@item @command{unweldq(9)}
@findex unweldq(9)
@tab Unweld two pairs of streams queues.
@command{unweldq(9)} is a  @dfn{@value{PACKAGE_TITLE}} core function.
@end multitable

@subsubsection Common Module Utilities

@multitable @columnfractions .30 .70
@item @command{streams_close_comm(9)}
@findex streams_close_comm(9)
@tab Common minor device close utility.
@item @command{streams_open_comm(9)}
@findex streams_open_comm(9)
@tab Common minor device open utility.
@item @command{streams_open_ocomm(9)}
@findex streams_open_ocomm(9)
@tab Common minor device open utility.
@end multitable

@subsubsection Registration

@multitable @columnfractions .20 .80
@item @command{strmod_add(9)}
@findex strmod_add(9)
@tab Add a @cite{STREAMS} module.
@item @command{strmod_del(9)}
@findex strmod_del(9)
@tab Delete a @cite{STREAMS} module or driver from the kernel.
@end multitable

@subsubsection Others

@multitable @columnfractions .20 .80
@item @command{time(9)}
@findex time(9)
@tab (undoc).
@end multitable

@node Configuration ala OSF/1 1.2/Digital UNIX
@subsection Configuration ala OSF/1 1.2/Digital UNIX
@cindex configuration, OSF/1 1.2/Digital UNIX
@cindex OSF/1 1.2/Digital UNIX, configuration
@cindex OSF/1 1.2/Digital UNIX
@cindex OSF/1


@node UnixWare Portability
@section Porting from UnixWare 7.1.3 (OpenUnix 8)
@cindex porting, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), portability
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@menu
* Differences from UnixWare 7.1.3 (OpenUnix 8)::
* Commonalities with UnixWare 7.1.3 (OpenUnix 8)::
* Compatibility Functions for UnixWare 7.1.3 (OpenUnix 8)::
* Configuration ala UnixWare 7.1.3 (OpenUnix 8)::
@end menu

@node Differences from UnixWare 7.1.3 (OpenUnix 8)
@subsection Differences from UnixWare 7.1.3 (OpenUnix 8)
@cindex differences, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), differences
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@node Commonalities with UnixWare 7.1.3 (OpenUnix 8)
@subsection Commonalities with UnixWare 7.1.3 (OpenUnix 8)
@cindex commonalities, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), commonalities
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

@cite{UnixWare} provides most of the core functions provide by @cite{@value{PACKAGE_TITLE}} along with
all of the compatibility functions provided by the @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
compatibility module.  In addition the functions provided here in the @cite{UnixWare} compatibility
module are provided.

@node Compatibility Functions for UnixWare 7.1.3 (OpenUnix 8)
@subsection Compatibility Functions for UnixWare 7.1.3 (OpenUnix 8)
@cindex compatibility functions, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), compatibility functions
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare

The following compatibility functions are in addition to all @cite{SVR 4.2}
@cindex SVR 4.2
compatibility functions.

@subsubsection Device Numbering

Device numbering has evolved since @cite{UNIX Sytem V Release 3.0} and provides internal, external
and extended device numbering.  These functions are provided for backward compatibility with some
drivers that were written for the older system.  These are core functions in the
@dfn{@value{PACKAGE_TITLE}} implementation.

@multitable @columnfractions .20 .80
@item @command{emajor(9)}
@findex emajor(9)
@tab Get the external (real) major device number from the device number.
@item @command{eminor(9)}
@findex eminor(9)
@tab Get the external extended minor device number from the device number.
@item @command{etoimajor(9)}
@findex etoimajor(9)
@tab Convert an external major device number to an internal major device number.
@item @command{getemajor(9)}
@findex getemajor(9)
@tab Get the external (real) major device number.
@item @command{geteminor(9)}
@findex geteminor(9)
@tab Get the external minor device number.
@item @command{itoemajor(9)}
@findex itoemajor(9)
@tab Convert an internal major device number to an external major device number.
@end multitable

@subsubsection Memory Alignment

In attempting to unify several desparaging @cite{UNIX}-based systems (in particular @cite{XENIX}
@cindex XENIX
and @cite{UnixWare},
@cindex UnixWare
it became necessary to sometimes address the alignment of data buffers.  Certainly a better way to
accomplish this would be to allocate data buffers using other allocators that provide the required
alignment and other buffer characteristics and then allocating a message and data block with a call
to @command{esballoc(9)}.
@findex esballoc(9)
Nevertheless, these functions were provided for making message blocks, data blocks and data buffers
meet specific physical requirements.

@dfn{@value{PACKAGE_TITLE}} provides these functions for compatibility, however, most of the physical
requirements provided are ignored.

@multitable @columnfractions .30 .70
@item @command{allocb_physreq(9)}
@findex allocb_physreq(9)
@tab Allocate a @cite{STREAMS} message and data block.
@item @command{msgphysreq(9)}
@findex msgphysreq(9)
@tab Cause a message block to meet physical requirements.
@item @command{msgpullup_physreq(9)}
@findex msgpullup_physreq(9)
@tab Pull up bytes in a @cite{STREAMS} message.
@item @command{msgscgth(9)}
@findex msgscgth(9)
@tab (undoc).
@end multitable

@subsubsection Direct @cite{STREAMS} Input-Output Controls

@multitable @columnfractions .20 .80
@item @command{strioccall(9)}
@findex strioccall(9)
@tab (undoc).
@end multitable

@node Configuration ala UnixWare 7.1.3 (OpenUnix 8)
@subsection Configuration ala UnixWare 7.1.3 (OpenUnix 8)
@cindex configuration, UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare 7.1.3 (OpenUnix 8), configuration
@cindex UnixWare 7.1.3 (OpenUnix 8)
@cindex UnixWare


@node Solaris Portability
@section Porting from Solaris 9/SunOS 5.9
@cindex porting, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, portability
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@menu
* Differences from Solaris 9/SunOS 5.9::
* Commonalities with Solaris 9/SunOS 5.9::
* Compatibility Functions for Solaris 9/SunOS 5.9::
* Configuration ala Solaris 9/SunOS 5.9::
@end menu

@node Differences from Solaris 9/SunOS 5.9
@subsection Differences from Solaris 9/SunOS 5.9
@cindex differences, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, differences
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@node Commonalities with Solaris 9/SunOS 5.9
@subsection Commonalities with Solaris 9/SunOS 5.9
@cindex commonalities, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, commonalities
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@node Compatibility Functions for Solaris 9/SunOS 5.9
@subsection Compatibility Functions for Solaris 9/SunOS 5.9
@cindex compatibility functions, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, compatibility functions
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS

@subsubsection STREAMS Queue Referenced Callbacks

@multitable @columnfractions .20 .80
@item @command{qbufcall(9)}
@findex qbufcall(9)
@tab Install a @cite{STREAMS} buffer callback.
@item @command{qunbufcall(9)}
@findex qunbufcall(9)
@tab Cancel a @cite{STREAMS} buffer callback.
@item @command{qtimeout(9)}
@findex qtimeout(9)
@tab Start a timer associated with a queue.
@item @command{quntimeout(9)}
@findex quntimeout(9)
@tab Stop a timer associated with a queue.
@item @command{qwait(9)}
@findex qwait(9)
@tab Wait for a queue message.
@item @command{qwait_sig(9)}
@findex qwait_sig(9)
@tab Wait for a queue message or signal.
@item @command{queclass(9)}
@findex queclass(9)
@tab Return the class of a @cite{STREAMS} message.
@item @command{qwriter(9)}
@findex qwriter(9)
@tab @cite{STREAMS} mutex upgrade.
@end multitable

@subsubsection STREAMS Registration

@multitable @columnfractions .20 .80
@item @command{install_driver(9)}
@findex install_driver(9)
@tab Install a device driver.
@item @command{mod_info(9)}
@findex mod_info(9)
@tab Provides information on a loadable kernel module to the @cite{STREAMS} executive.
@item @command{mod_install(9)}
@findex mod_install(9)
@tab Installs a loadable kernel module in the @cite{STREAMS} executive.
@item @command{mod_remove(9)}
@findex mod_remove(9)
@tab Removes a loadable module from the @cite{STREAMS} executive.
@end multitable

@subsubsection DDI
@cindex DDI/DKI

@cite{Solaris} provides a wide array of Device Driver Interface functions available for use by device
drivers.  Many of these functions are useful for @cite{STREAMS} device and pseudo-device drivers and
modules.  Almost all of these functions, however, are @cite{Solaris}-specific and are completely
non-portable to other @cite{UNIX}-based operating systems.  To make matters worse for portability,
many of these functions have no @cite{SVR 4.2 MP}
@cindex SVR 4.2 MP
equivalents.

@multitable @columnfractions .40 .60
@item @command{ddi_create_minor_node(9)}
@findex ddi_create_minor_node(9)
@tab Create a minor node for this device.
@item @command{ddi_remove_minor_node(9)}
@findex ddi_remove_minor_node(9)
@tab Remove a minor node for a device.
@item @command{ddi_driver_major(9)}
@findex ddi_driver_major(9)
@tab Find the major device number associated with a driver.
@item @command{ddi_getiminor(9)}
@findex ddi_getiminor(9)
@tab Get the internal minor device number.
@item @command{ddi_driver_name(9)}
@findex ddi_driver_name(9)
@tab Return normalized driver name.
@item @command{ddi_get_cred(9)}
@findex ddi_get_cred(9)
@tab Get a reference to the credentials of the current user.
@item @command{ddi_get_instance(9)}
@findex ddi_get_instance(9)
@tab Get device instance number.
@item @command{ddi_get_lbolt(9)}
@findex ddi_get_lbolt(9)
@tab Get the current value of the system tick clock.
@item @command{ddi_get_pid(9)}
@findex ddi_get_pid(9)
@tab Get the process id of the current process.
@item @command{ddi_get_time(9)}
@findex ddi_get_time(9)
@tab Get the current time in seconds since the epoch.
@item @command{ddi_removing_power(9)}
@findex ddi_removing_power(9)
@tab
@item @command{ddi_get_soft_state(9)}
@findex ddi_get_soft_state(9)
@tab
@item @command{ddi_soft_state(9)}
@findex ddi_soft_state(9)
@tab
@item @command{ddi_soft_state_fini(9)}
@findex ddi_soft_state_fini(9)
@tab
@item @command{ddi_soft_state_free(9)}
@findex ddi_soft_state_free(9)
@tab
@item @command{ddi_soft_state_init(9)}
@findex ddi_soft_state_init(9)
@tab
@item @command{ddi_soft_state_zalloc(9)}
@findex ddi_soft_state_zalloc(9)
@tab
@item @command{ddi_umem_alloc(9)}
@findex ddi_umem_alloc
@tab Allocate page aligned kernel memory.
@item @command{ddi_umem_free(9)}
@findex ddi_umem_free
@tab Free page aligned kernel memory.
@end multitable

@subsubsection Loadable Module Interface

@multitable @columnfractions .20 .80
@item @command{_fini(9)}
@findex _fini(9)
@tab
@item @command{_info(9)}
@findex _info(9)
@tab
@item @command{_init(9)}
@findex _init(9)
@tab
@item @command{attach(9)}
@findex attach(9)
@tab Attach a device to the system or resume a suspended device.
@item @command{getinfo(9)}
@findex getinfo(9)
@tab
@item @command{identify(9)}
@findex identify(9)
@tab Determine if a driver is associated with a device.
@item @command{detach(9)}
@findex detach(9)
@tab Detach a device from the system or suspend a device.
@item @command{power(9)}
@findex power(9)
@tab Power a device attached to the system.
@item @command{probe(9)}
@findex probe(9)
@tab
@end multitable

@node Configuration ala Solaris 9/SunOS 5.9
@subsection Configuration ala Solaris 9/SunOS 5.9
@cindex configuration, Solaris 9/SunOS 5.9
@cindex Solaris 9/SunOS 5.9, configuration
@cindex Solaris 9/SunOS 5.9
@cindex Solaris
@cindex SunOS


@node SUX Portability
@section Porting from Super/UX
@cindex porting, Super/UX
@cindex Super/UX, portability
@cindex Super/UX

@menu
* Differences from Super/UX::
* Commonalities with Super/UX::
* Compatibility Functions for Super/UX::
* Configuration ala Super/UX::
@end menu

@node Differences from Super/UX
@subsection Differences from Super/UX
@cindex differences, Super/UX
@cindex Super/UX, differences
@cindex Super/UX

@node Commonalities with Super/UX
@subsection Commonalities with Super/UX
@cindex commonalities, Super/UX
@cindex Super/UX, commonalities
@cindex Super/UX

@node Compatibility Functions for Super/UX
@subsection Compatibility Functions for Super/UX
@cindex compatibility functions, Super/UX
@cindex Super/UX, compatibilty functions
@cindex Super/UX

@multitable @columnfractions .20 .80
@item @command{lbolt(9)}
@tab time in ticks since reboot
@end multitable

@node Configuration ala Super/UX
@subsection Configuration ala Super/UX
@cindex configuration, Super/UX
@cindex Super/UX, configuration
@cindex Super/UX


@node UXP Portability
@section Porting from UXP/V
@cindex porting, UXP/V
@cindex UXP/V, portability
@cindex UXP/V

@menu
* Differences from UXP/V::
* Commonalities with UXP/V::
* Compatibility Functions for UXP/V::
* Configuration ala UXP/V::
@end menu

@node Differences from UXP/V
@subsection Differences from UXP/V
@cindex differences, UXP/V
@cindex UXP/V, differences
@cindex UXP/V

@node Commonalities with UXP/V
@subsection Commonalities with UXP/V
@cindex commonalities, UXP/V
@cindex UXP/V, commonalities
@cindex UXP/V

@node Compatibility Functions for UXP/V
@subsection Compatibility Functions for UXP/V
@cindex compatibility functions, UXP/V
@cindex UXP/V, compatibility functions
@cindex UXP/V

@node Configuration ala UXP/V
@subsection Configuration ala UXP/V
@cindex configuration, UXP/V
@cindex UXP/V, configuration
@cindex UXP/V


@node LiS Portability
@section Porting from LiS 2.18.1
@cindex porting, LiS 2.18.1
@cindex LiS 2.18.1, portability
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@menu
* Differences from LiS 2.18.1::
* Commonalities with LiS 2.18.1::
* Compatibility Functions for LiS 2.18.1::
* Configuration ala LiS 2.18.1::
@end menu

@node Differences from LiS 2.18.1
@subsection Differences from LiS 2.18.1
@cindex differences, LiS 2.18.1
@cindex LiS 2.18.1, differences
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@node Commonalities with LiS 2.18.1
@subsection Commonalities with LiS 2.18.1
@cindex commonalities, LiS 2.18.1
@cindex LiS 2.18.1, commonalities
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@node Compatibility Functions for LiS 2.18.1
@subsection Compatibility Functions for LiS 2.18.1
@cindex compatibility functions, LiS 2.18.1
@cindex LiS 2.18.1, compatibility functions
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@subsubsection Extensions

@multitable @columnfractions .40 .60
@item @command{lis_appq(9)}
@findex lis_appq(9)
@tab Append one @cite{STREAMS} message after another.
@item @command{lis_date(9)}
@findex lis_date(9)
@tab
@item @command{lis_esbbcall(9)}
@findex lis_esbbcall(9)
@tab Install a buffer callback for an extended @cite{STREAMS} message block.
@item @command{lis_find_strdev(9)}
@findex lis_find_strdev(9)
@tab
@item @command{lis_OTHER(9)}
@findex lis_OTHER(9)
@tab Return the other queue of a @cite{STREAMS} queue pair..
This function is intended to accommodate a common miss-spelling of
@command{OTHERQ(9)}.
@findex OTHERQ(9)
@item @command{lis_version(9)}
@findex lis_version(9)
@tab
@item @command{lis_xmsgsize(9)}
@findex lis_xmsgsize(9)
@tab Calculate the size of message blocks in a @cite{STREAMS} message.
@end multitable

@subsubsection Device Creation and Deletion

@multitable @columnfractions .40 .60
@item @command{lis_mknod(9)}
@findex lis_mknod(9)
@tab Make block or character special files.
@item @command{lis_unlink(9)}
@findex lis_unlink(9)
@tab Remove a file.
@item @command{lis_mount(9)}
@findex lis_mount(9)
@tab Mount a file system.
@item @command{lis_umount2(9)}
@findex lis_umount2(9)
@tab Unmount a file system.
@item @command{lis_umount(9)}
@findex lis_umount(9)
@tab Unmount a file system.
@end multitable

@subsubsection Registration

@multitable @columnfractions .40 .60
@item @command{lis_register_strdev(9)}
@findex lis_register_strdev(9)
@tab Register a @cite{STREAMS} device.
@item @command{lis_register_strmod(9)}
@findex lis_register_strmod(9)
@tab Register a @cite{STREAMS} module.
@item @command{lis_unregister_strdev(9)}
@findex lis_unregister_strdev(9)
@tab Unregister a @cite{STREAMS} device.
@item @command{lis_unregsiter_strmod(9)}
@findex lis_unregister_strmod(9)
@tab Unregister a @cite{STREAMS} module.
@end multitable

@node Configuration ala LiS 2.18.1
@subsection Configuration ala LiS 2.18.1
@cindex configuration, LiS 2.18.1
@cindex LiS 2.18.1, configuration
@cindex LiS 2.18.1
@cindex LiS
@cindex Linux STREAMS (LiS)

@multitable @columnfractions .40 .60
@end multitable

@node Development
@section Developing Portable STREAMS Modules
@cindex developing portable streams modules

In the process of creating the @dfn{@value{PACKAGE_TITLE}} subsystem in such a way so as to facilitate
portability of @cite{STREAMS} drivers and modules from a wide range of @cite{UNIX} operating system
variants, a number of guidelines for the development of portable @cite{STREAMS} drivers and modules
have been developed.  These guidelines, when adhered to, will allow the resulting driver or module
to be ported to another @cite{STREAMS} implementation with minimal effort.  These portability
guidelines are collected here.

@menu
* Memory Allocation::
* Alignment of Message Buffers::
* Disabling and Enabling Queue Procedures::
* Freezing and Unfreezing Streams::
* Passing Messages from Interrupt Service Routines::
* Timeout Call Back and Link Identifiers::
* Synchronization with Timeouts and Callback Functions::
* Synchronization with Callout Functions::
* Synchronization of Drivers and Modules::
* Special STREAMS Message Types::
* Use of Message Allocation Priorities::
* Device Numbering::
* Registration and Deregistration::
@end menu

@node Memory Allocation
@subsection Memory Allocation

Portable @cite{STREAMS} modules and drivers will always allocate memory using the @cite{SVR4}
@cindex SVR4
memory allocators/deallocators: @manpage{kmem_alloc(9)}, @manpage{kmem_zalloc(9)} and
@manpage{kmem_free(9)}.

Additional eligible allocators are:

@manpage{rmallocmap(9)}
@manpage{rmfreemap(9)}
@manpage{rmalloc(9)}
@manpage{rmalloc_wait(9)}
@manpage{rmfree(9)}
@manpage{rminit(9)}
@manpage{rmsetwant(9)}
@manpage{rmwanted(9)}

Unfortunately, these resource map allocators are not available on @cite{AIX}
@cindex AIX
so, if portability to the @cite{AIX}
@cindex AIX
is important, then do not use these allocators.

Additional eligible allocators are:

@manpage{kmem_fast_alloc(9)}
@manpage{kmem_fast_free(9)}

@node Alignment of Message Buffers
@subsection Alignment of Message Buffers

@node Disabling and Enabling Queue Procedures
@subsection Disabling and Enabling Queue Procedures

Portable @cite{STREAMS} modules and drivers will always call @manpage{qprocson(9)} before returning
from its queue open procedure (see @manpage{qopen(9))}.

Portable @cite{STREAMS} modules and drivers will always call @manpage{qprocsoff(9)} upon entering
its queue close procedure (see @manpage{qclose(9)}).

@node Freezing and Unfreezing Streams
@subsection Freezing and Unfreezing Streams

@node Passing Messages from Interrupt Service Routines
@subsection Passing Messages from Interrupt Service Routines

@node Timeout Call Back and Link Identifiers
@subsection Timeout Call Back and Link Identifiers

Although buffer callbacks identifiers (see @manpage{bufcall(9)}), timeout identifiers (see
@manpage{timeout(9)}), and multiplexing driver link identifiers (see @var{I_LINK}
@vindex I_LINK
and @var{I_PLINK} under
@vindex I_PLINK
@manpage{streamio(7)}), are often illustrated as small integer numbers, with some @cite{STREAMS}
implementations, including @dfn{@value{PACKAGE_TITLE}}, these identifiers are kernel addresses
(pointers) and are never small integer values like 1, 2, or 3.

Also, there is no guarantee that the identifier will be positive.  It is guaranteed that the
returned identifier will not be zero (0).  Zero is used by these function as a return value to
indicate an error.

Portable @cite{STREAMS} drivers and modules will not depend upon the returned identifier from
@manpage{bufcall(9)}, @manpage{timeout(9)} or @manpage{streamio(7)} as being any specific range of
value.  Portable drivers and modules will save any returned identifiers in data types that will not
loose the precision of the identifier.

@node Synchronization with Timeouts and Callback Functions
@subsection Synchronization with Timeouts and Callback Functions

@node Synchronization with Callout Functions
@subsection Synchronization with Callout Functions

@node Synchronization of Drivers and Modules
@subsection Synchronization of Drivers and Modules

@node Special STREAMS Message Types
@subsection Special @cite{STREAMS} Message Types

@node Use of Message Allocation Priorities
@subsection Use of Message Allocation Priorities

@node Registration and Deregistration
@subsection Registration and Deregistration

@node Device Numbering
@subsection Device Numbering

@subsubheading UNIX Device Numbering

@quotation
In versions of @cite{UNIX System V} previous to @cite{Release 4}, the major and minor device numbers
were each 8 bit, and they were packed into a 16 bit word (usually a C Language @var{short}
variable).  Under @cite{UNIX System V Release 4}, the device numbers are held in a @samp{dev_t}
@tpindex dev_t
variable, which is often implemented as a 32 bit integer.  The minor device number is held as 14
bits, and a further 8 bits are used for the major device number.  @samp{dev_t}
@tpindex dev_t
is ofter referred to as the "expanded device type", since it allows many more minor devices than
before.

Many drivers were written for earlier releases, an may eventually be ported to @cite{UNIX System V
Release 4}.  In earlier releases, some manufacturers got around the 256 minor device number limit by
using multiple major device numbers for a device.  Devices were created with different major device
numbers (the external major device number) but they all mapped to the same device driver entry in
the device switch tables (the internal device number).  Even under this scheme, each major device
could only support 256 minor devices, but the driver could support many more.  This has been
recognized in @cite{UNIX System V Release 4}, and functions are provided to do this mapping; for
example, the function @command{etoimajor}() and so on, give a machine independent interface to the
device number mapping.@footnote{@cite{The Magic Garden Explained}}
@end quotation

@subsubheading Linux Device Numbering

Versions of the @b{Linux} kernel in the 2.4 kernel series and prior to 2.6 also provided an 8 bit
major device number and an 8 bit minor device number grouped into a 16-bit combined device number.
Linux 2.6 kernels (and some patched 2.4 kernels) now have larger device numbers.  These extended
device numbers are 12 bits for major device number and 20 bits for minor device number, with 32 bits
for the combined device number.

@subsubheading LiS Device Numbering
@cindex Linux STREAMS (LiS)

@cite{LiS}
@cindex Linux STREAMS (LiS)
prior to the 2.18.0 release was incapable of providing an internal representation of the device
number and the number of minor device numbers for a device driver was restricted to 256, just as in
@cite{UNIX System V Release 3.2}.@footnote{Actually, 255 as the kernel reserved minor device number
255 for expansion.}  Many @url{http://www.openss7.org/, OpenSS7} device drivers written for
@cite{LiS}
@cindex Linux STREAMS (LiS)
would allocate additional major device numbers if required.  Good examples of devices that require
more than 255 minor device numbers are INET clone devices, SCTP streams, SS7 signalling link
streams, MG media channels, etc.  These streams are often @var{I_PLINK}ed
@vindex I_PLINK
under a multiplexing driver and do not even consume a system file descriptor.

@subsubheading @value{PACKAGE_TITLE} Device Numbering

@dfn{@value{PACKAGE_TITLE}} began with extended device numbering.  The @file{specfs} shadow special
character device file system used by @dfn{@value{PACKAGE_TITLE}} uses the @samp{inode} number to hold the
@samp{dev_t}
@tpindex dev_t
device number instead of the @samp{inode->i_rdev}, which on older kernels is only a 16-bit
@var{short}.

In earlier versions of @dfn{@value{PACKAGE_TITLE}}, the internal device numbering is 16-bits for major
device number and 16-bits for minor device number.  This will soon be changed to 12-bits for major
device number and 20-bits for minor device number to accommodate the newer @b{Linux} scheme.

On 2.6 @b{Linux} kernels that support the newer extended device numbers, external device numbers and
internal device numbers will be the same.  On 2.4 @b{Linux} kernels with the older 16-bit device
numbers, external device number and internal device numbers will differ.  In some situations, an
internal device number can exists with no corresponding external device number (accessed only via a
clone device or direct access to the mounted @file{specfs} shadow special character device
file system).

@multitable @columnfractions .20 .80
@item @command{etoimajor(9)}
@findex etoimajor(9)
@tab change external to internal major device number
@item @command{getemajor(9)}
@findex getemajor(9)
@tab get external major device number
@item @command{geteminor(9)}
@findex geteminor(9)
@tab get external minor device number
@item @command{itoemajor(9)}
@findex itoemajor(9)
@tab change internal to external major device number
@end multitable


@node Copying
@appendix Copying

@menu
* GNU General Public License::		GPL
* GNU Free Documentation License::	FDL
@end menu

@include texi/gpl.texi

@include texi/fdl.texi

@node Index
@unnumbered Index

@c @page
@c @node Indices
@c @unnumbered Indices
@c @menu
@c * Concept Index::		Index of Concepts
@c * Type Index::			Index of Data Types
@c * Function Index::		Index of Functions and Macros
@c * Variable Index::		Index of Variables and Constants
@c * File Index::			Index of Files and Programs
@c @end menu
@c 
@c @page
@c @node Concept Index
@c @unnumberedsec Concept Index
@printindex cp

@c @page
@c @node Type Index
@c @unnumberedsec Type Index
@c @printindex tp
@c 
@c @page
@c @node Function Index
@c @unnumberedsec Function and Macro Index
@c @printindex fn
@c 
@c @page
@c @node Variable Index
@c @unnumberedsec Variable and Constant Macro Index
@c @printindex vr
@c 
@c @page
@c @node File Index
@c @unnumberedsec Program and File Index
@c @printindex pg

@page
@shortcontents
@page
@contents
@bye

