'\" rtp
.\" -*- nroff -*- vim: ft=nroff noautoindent nocindent nosmartindent
.\"
.\" @(#) $Id: put.9.man,v 0.9.2.18 2005/07/26 12:50:41 brian unstable $
.\"
.\" =========================================================================
.\"
.\" Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
.\"
.\" All Rights Reserved.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" -------------------------------------------------------------------------
.\"
.\" U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
.\" on behalf of the U.S. Government ("Government"), the following
.\" provisions apply to you.  If the Software is supplied by the Department
.\" of Defense ("DoD"), it is classified as "Commercial Computer Software"
.\" under paragraph 252.227-7014 of the DoD Supplement to the Federal
.\" Acquisition Regulations ("DFARS") (or any successor regulations) and the
.\" Government is acquiring only the license rights granted herein (the
.\" license rights customarily provided to non-Government users).  If the
.\" Software is supplied to any unit or agency of the Government other than
.\" DoD, it is classified as "Restricted Computer Software" and the
.\" Government's rights in the Software are defined in paragraph 52.227-19
.\" of the Federal Acquisition Regulations ("FAR") (or any successor
.\" regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
.\" NASA Supplement to the FAR (or any successor regulations).
.\"
.\" =========================================================================
.\" 
.\" Commercial licensing and support of this software is available from
.\" OpenSS7 Corporation at a fee.  See http://www.openss7.com/
.\" 
.\" =========================================================================
.\"
.\" Last Modified $Date: 2005/07/26 12:50:41 $ by $Author: brian $
.\"
.\" =========================================================================
.so streams.macros
.R1
bracket-label "\fR[\fB" "\fR]" "\fR, \fB"
no-default-database
database streams.refs
accumulate
move-punctuation
abbreviate A
join-authors ", " ", " " and "
et-al " et al" 2 3
abbreviate-label-ranges ".."
sort-adjacent-labels
.R2
.\"
.\"
.TH PUT 9 "@PACKAGE_DATE@" "@PACKAGE@-@VERSION@" "@PACKAGE_TITLE@ DDI/DKI"
.\"
.\"
.SH NAME
.B put, puthere, streams_put
\- invoke the put procedure for a \fISTREAMS\fP module or driver with a \fISTREAMS\fP message
.\"
.\"
.SH SYNOPSIS
.PP
.B #include <sys/stream.h>
.HP
.BI "void put(queue_t *" q ", mblk_t *" mp );
.\"
.\"
.SH ARGUMENTS
.TP
.I q
the queue to which to put the message.
.TP
.I mp
the message to put to the queue.
.\"
.\"
.SH DESCRIPTION
.PP
.BR put ()
calls the
.I q->q_info->qi_putp
procedure associated with the passed in queue, with the arguments
.IR q " and " mp .
.PP
As a side-effect,
.BR put ()
will wake up any processes waiting with
.BR qwait (9)
or
.BR qwait_sig (9)
on the specified queue.
.\"
.\"
.SH RETURN
.PP
.BR put ()
returns
.BR void .
.\"
.\"
.SH ERRORS
.PP
.BR put ()
fails silently when a queue band structure cannot be allocated for the band
specified in
.IR mp->b_band .
The caller can ensure that a queue band structure exists for the band in
question by calling
.BR strqset (9)
for the band.
.\"
.\"
.SH CONTEXT
.PP
.BR put ()
can be called from any context; however, if called from interrupt service
routine (hard IRQ) context, in general, calling of the queue's put procedure
will be deferred and run under soft interrupt context the next time that the
.I STREAMS
soft interrupt is scheduled to run.
.PP
If the driver or module is synchronized then invocation of the
.BR put ()
procedure will be deferred and run under soft interrupt context the next time
that the
.I STREAMS
scheduler is run; however, if it is not synchronized
.RB ( SQLVL_NONE ),
then the module's
.BR put ()
procedure will be invoked under interrupt service routine (hard IRQ) context.
.PP
Driver
.BR put ()
procedures that expect to be invoked under interrupt service routine context
must never call
.BR putnext (9)
unless all
.BR put ()
procedures in the stream are either syncrhonized, or are not synchronized
.RB ( SQLVL_NONE )
but expect to be invoked under interrupt service routine context.
(The
stream head is marked
.BR SQLVL_NONE ,
but its read side
.BR put ()
procedure but is also MP-safe and can be called under interrupt service routine
context.)
.PP
For portable
.I STREAMS
drivers, the foregoing condition cannot normally be guaranteed, so it is good
practice for drivers whose
.BR put ()
procedures are invoked under interrupt service routine context to include a service
procedure and use
.BR putq (9)
to defer processing to the driver's service procedure that will run later within
the context of the
.I STREAMS
scheduler.
.PP
See also
.BR putnext (9).
.\"
.\"
.SH MP-STREAMS
.PP
.BR put ()
is MP-safe.  The driver or module put procedures invoked must also be MP-safe.
.PP
Under
.B @PACKAGE_TITLE@
any
.BR put ()
procedure could be executed concurrently with any queue
.BR qopen (9),
.BR qclose (9),
.BR put (),
.BR srv (9)
procedure,
.BR esbbcall (9),
.BR bufcall (9),
.BR qbufcall (9),
.BR timeout (9),
.BR qtimeout (9)
callback function,
or interrupt service routine.
The
.BR put ()
procedure itself must perform its own mutual exclusion.
.PP
See
.BR mp-streams (9)
for general
.I MP-STREAMS
considerations.
.\"
.\"
.SH USAGE
.PP
The following guidelines provide best practice for the writing of safe and
portable
.RB put ()
procedures for drivers an modules:
.IP \(em \w'\(em\(em'u
Modules and drivers should process all recognized and handled
high-priority message types directly from the
.BR put ()
procedure without delay.  Where access to module private data is required to
complete processing, mutual exclusion must be performed to ensure that the
.BR put ()
procedure remains MP-safe.
.IP \(em
Modules and drivers should process all recognized and handled
normal-priority message types other than
.BR M_DATA (9),
.BR M_PROTOC (9)
and
.BR M_DELAY (9)
directly from the
.BR put ()
procedure, without delay, provided that consideration is given to message
ordering, queued messages and mutual exclusion of shared module private
state information.
.IP \(em
Modules and drivers may process all recognized and handled
normal-priority message types
.BR M_DATA (9),
.BR M_PROTOC (9)
and
.BR M_DELAY (9)
directly from the
.BR put ()
procedure, without delay, provided that consideration is given to message
ordering, queued messages and mutual exclusion of shared module private
state information.
.IP \(em
Modules should pass unrecognized or unhandled message types (and unhandled
.BR M_IOCTL
messages) upstream and downstream using
.BR putnext (9)
directly from the
.BR put ()
procedure, without delay, given that there are no queued messages.
.IP \(em
Drivers should delete unrecognized or unhandled message types using
.BR freemsg (9)
directly from the
.BR put ()
procedure without delay.
.IP \(em
Drivers should respond with
.BR M_IOCNAK (9)
to unhandled
.BR M_IOCTL
messages directly from the
.BR put ()
procedure without delay.
.IP \(em
.BR M_FLUSH (9)
is a high-priority message
that should be handled directly from the
.BR put ()
procedure, without delay.
See
.BR M_FLUSH (9)
for more information on cannonical processing of this message.
.IP \(em
.BR M_DATA (9),
.BR M_PROTO (9)
and
.BR M_DELAY (9)
are normal priority messages that
may be handled directly from the 
.B put ()
procedure if there are no queued messages.
.IP \(em
.BR M_IOCTL (9),
.BR M_IOCDATA (9),
.BR M_IOCACK (9),
.BR M_IOCNAK (9),
.BR M_COPYIN (9)
and
.BR M_COPYOUT (9)
messages should be acted upon immediately from the
.RB put ()
procedure.
.IP ""
If the
.B M_IOCTL (9)
message is not handled, the driver should delete it using
.BR freemsg (9).
The module should pass it along using
.BR putnext (9).
.IP ""
If the
.BR M_IOCTL (9)
message is handled, cannonical
.BR M_IOCTL (9)
processing mechanisms should be used to avoid holding input output control state
information in the module's private structures during
.BR M_COPYIN (9)
and
.BR M_COPYOUT (9)
operations.  Final results that change module private structure state should use
mutual exclusion mechanisms to keep the
.BR put ()
procedure MP-safe.
.IP \(em
.BR M_PCPROTO (9)
is a high-priority message
that should be handled directly from the
.BR put ()
procedure, without delay.
See
.BR M_PCPROTO (9)
for more information on cannonical processing of this message.
.IP \(em
.BR M_READ (9)
is a high-priority message
that should be handled directly from the
.BR put ()
procedure, without delay.
See
.BR M_READ (9)
for more information on cannonical processing of this message.
.IP \(em
.BR M_LETSPLAY (9),
.BR M_DONTPLAY (9)
and
.BR M_BACKDONE (9)
are high-priority messages that
should be processed immediated from the
.BR put ()
procedure.
See
.BR M_LETSPLAY (9)
for more information on cannonical processing of these messages.
.IP \(em
.BR M_BREAK (9)
messages should be processed immediated from the
.BR put ()
procedure.
.IP \(em
.BR M_STOP (9),
.BR M_START (9),
.BR M_STOPI (9)
and
.BR M_STARTI (9)
are high-priority messages that
should be processed immediated from the
.BR put ()
procedure.
See
.BR M_STOP (9),
.BR M_START (9),
.BR M_STOPI (9)
and
.BR M_STARTI (9)
for more information on cannonical processing of these messages.
.IP \(em
.BR M_ERROR (9)
and
.BR M_HANGUP (9)
are high-priority messages that
should be processed immediated from the
.BR put ()
procedure.
.\"
.\"
.SH NOTICES
.PP
.BR puthere ()
is an
.IR OSF/1 \(rg-specific
function:
.B _OSF_SOURCE
must be defined before including DDI/DKI include files to expose this symbol.
.B @PACKAGE_TITLE@
.[
lfs
.]
must also have been compiled with
.B CONFIG_STREAMS_COMPAT_OSF
or
.B CONFIG_STREAMS_COMPAT_OSF_MODULE
defined.
.PP
.BR streams_put ()
is an
.IR HP-UX \(rg-specific
function:
.B _HPUX_SOURCE
must be defined before including DDI/DKI include files to expose this symbol.
.B @PACKAGE_TITLE@
.[
lfs
.]
must also have been compiled with
.B CONFIG_STREAMS_COMPAT_HPUX
or
.B CONFIG_STREAMS_COMPAT_HPUX_MODULE
defined.
.\"
.\"
.SH EXAMPLES
.PP
Following is an example of canonical
.BR put ()
procedure processing for modules or drivers:
.PP
.nf
\fC\s-1\
int
xxx_put(queue_t *q, mblk_t *mp)
{
  if (pcmsg(mp->b_datap->db_type) || q->q_count == 0) {
    priv_t p;

    p = q->q_ptr;
    switch (mp->b_datap->db_type) {
    case M_FLUSH:
    {
      /* 
       * perform canonial M_FLUSH handling without locks
       */
      return (0);
    }
    case M_DATA:
    case M_PROTO:
    case M_PCPROTO:
    {
      pl_t pl;

      if ((pl = TRYLOCK(&p->priv_lock, plstr)) == invpl)
        putq(q, mp);
      else {
        /* 
         * process message
         */
        UNLOCK(&p->priv_lock, pl);
      }
      return (0);
    }
    }
  }
  putq(q, mp);
  return (0);
}\
\s+1\fP
.fi
.PP
Note that checking
.I q->q_count
in this fashion introduces a race condition between messages arriving at the
queue from other concurrent invocations of
.BR xxx_put ,
however, if such concurrent execution can occur, then the message ordering is of
no consequence, or can already be disrupted.
.PP
Note that if the driver or module does not have a service procedure,
.BR LOCK (9)
should be used instead of
.BR TRYLOCK (9).
Of course, reader writer locks, synchronization levels, or any other
non-blocking mutual exclusion mechanism could have been used.
.\"
.\"
.SH "SEE ALSO"
.PP
.BR qopen (9),
.BR qclose (9),
.BR qprocson (9),
.BR qprocsoff (9),
.BR freezestr (9),
.BR unfreezestr (9),
.BR srv (9),
.BR esbbcall (9),
.BR bufcall (9),
.BR qbufcall (9),
.BR timeout (9),
.BR qtimeout (9).
.\"
.\"
.SH BUGS
.PP
.BR put ()
has no known bugs.
.\"
.\"
.SH COMPATIBILITY
.PP
.BR put ()
is compatible with
.IR "SVR 4.2 DDI/DKI" ,
.[
usldk
.]
and implementations based on
.IR "SVR 4" ,
with the following portability considerations:
.IP \(em \w'\(em\(em'u
.BR put ()
called with invalid arguments will have undefined results.
.I LiS
fails silently when
.IR mp " or " q
is
.BR NULL ,
or
.I q
does not reference a valid queue structure,
or
.I q->q_info
is
.BR NULL ,
or
.I q->q_info->qi_putp
is
.BR NULL .
When
.I LiS
fails silently, it frees
.I mp
using
.BR freemsg (9).
.IP \(em
.BR put ()
cannot be invoked while
.BR qprocsoff (9)
is in effect for
.IR q
because no other queue has a references to the queue for which
.BR qprocsoff (9)
has been executed, or for which
.BR qprocson (9)
has not yet been executed.
.I LiS
discards messages passed to
.BR lis_safe_putmsg ()
when 
.BR qprocsoff (9)
has been executed for
.IR q .
It is invalid to call
.BR put ()
for a queue that has not had
.BR qprocson (9)
called, or which has called
.BR qprocsoff (9),
so this difference should not present a problem.
.IP \(em
.BR put (),
.BR putnext (9),
.BR qreply (9)
will invoke a queue's put procedure shared and multi-threaded.
This is equivalent to
.IR Solaris \(rg
drivers with the
.B D_MP
flag set or with the
.B D_MTPUTSHARED
flag set.
.IP \(em
.BR put ()
may be called on a stream frozen with
.BR freezestr (9).
.IR "SVR 4.2 MP DDI/DKI" ,
.[
usldk
.]
.IR Solaris \(rg,
.[
solspg
.]
.IR SUPER-UX \(rg
.[
suxspg
.]
and
.IR UnixWare \(rg
.[
uw7spg
.]
do not permit
.BR put ()
to be called on a stream frozen with
.BR freezestr (9).
Portable
.I STREAMS
drivers and modules should not call
.BR put ()
on a stream frozen with
.BR freezestr (9).
.IP \(em
Under
.IR OSF/1 \(rg
this function is called
.BR puthere ().
.IP \(em
.BR puthere ()
is an
.IR OSF/1 \(rg-specific
function and should not be used by portable
.I STREAMS
drivers and modules.  The more common
.BR put ()
function should be called in its stead.
.IP \(em
.BR puthere ()
is provided for source level compatibility with
.IR OSF/1 \(rg
for the purpose of porting
.IR OSF/1 \(rg
drivers to
.BR Linux .
Because internal structure and definitions for
.B @PACKAGE_TITLE@
.[
lfs
.]
differ from that of
.IR OSF/1 \(rg,
binaries are incompatible.
.IP \(em
.BR puthere ()
only provides functionality comparable to
.IR OSF/1 \(rg
for use by
.I STREAMS
drivers and modules.  Any and all functionality provided by
.BR puthere ()
in support of
.RI non- STREAMS
devices are not supported.
.IP \(em
Under
.IR HP-UX \(rg
this function is called
.BR streams_put ().
.IP \(em
.BR streams_put ()
is an
.IR HP-UX \(rg-specific
function and should not be used by portable
.I STREAMS
drivers and modules.  The more common
.BR put ()
function should be called in its stead.
.IP \(em
.BR streams_put ()
is provided for source level compatibility with
.IR HP-UX \(rg
for the purpose of porting
.IR HP-UX \(rg
drivers to
.BR Linux .
Because internal structure and definitions for
.B @PACKAGE_TITLE@
.[
lfs
.]
differ from that of
.IR HP-UX \(rg,
binaries are incompatible.
.IP \(em
.BR streams_put ()
only provides functionality comparable to
.IR HP-UX \(rg
for use by
.I STREAMS
drivers and modules.  Any and all functionality provided by
.BR streams_put ()
in support of
.RI non- STREAMS
devices are not supported.
.IP \(em
.I LiS
holds an exclusive nesting queue procedures lock while calling
.BR put ().
Unfortunately, these locks disable interrupts, meaning that interrupts are
disabled while
.BR put ()
executes.
.I LiS
.BR lis_safe_putnext (9)
and
.BR lis_safe_qreply (9)
also call this function, meaning that all message passing functions in
.I LiS
lock out interrupts until the entire thread of execution completes.
.I  LiS
drivers and modules calling
.B @PACKAGE_TITLE@
.[
lfs
.]
.BR put ()
should notice superior interrupt service routine latency and performance.  It
is normally the case that put procedures are MP-safe as then normally use only
MP-safe queue and message utility functions.  Also, most put procedures are
inherently invoked single threaded (from a single-threaded service procedure).
Lack of locking should not present a problem.
.IP ""
Because
.I LiS
also uses this lock for service procedures, this means that while the
.I LiS
scheduler is running (at kernel thread priority 50), interrupts,
timeouts, bottom halves, hi tasklets and soft interrupts are indefinitely
postponed.  This is not acceptable for soft-real-time performance.  Rewrite
.I LiS
put procedures to be MP-safe.
.IP \(em
Symbol
.BR lis_safe_putmsg ()
is provided for compatibility with
.IR LiS .
See
.BR liscompat (9).
.BR lis_safe_putmsg ()
simply calls
.BR put ()
directly.
.IP \(em
Binary compatibility is not guaranteed.
.PP
See
.BR osfcompat (9),
.BR hpuxcompat (9)
and
.BR STREAMS (9)
for additional compatibility information.
.\"
.\"
.SH CONFORMANCE
.PP
.BR put ():
.IR "SVR 4.2 DDI/DKI" ;
.[
usldk
.]
.[
uslspg
.]
.BR puthere ():
.IR OSF/1 \(rg
documentation;
.[
osfdoc
.]
.[
osfspg
.]
.BR streams_put ():
.IR HP-UX \(rg
documentation.
.[
hpuxdoc
.]
.[
hpuxspg
.]
.\"
.\"
.SH HISTORY
.PP
.BR put ()
first appeared in
.IR "SVR 4.0 MP" " and " "SVR 4.2 MP" ;
.[
svr4dk
.]
.[
usldk
.]
.BR puthere ()
first appeared in
.IR OSF/1 \(rg;
.BR streams_put ()
first appeared in
.IR HP-UX \(rg.
.\"
.\"
.[
$LIST$
.]
.TI
