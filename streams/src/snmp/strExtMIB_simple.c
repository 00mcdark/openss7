/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "strExtMIB_simple.h"

/* 
 * strExtMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid strExtMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 1000 };

/* 
 * variable7 strExtMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the strExtMIB_simple mib section 
 */

struct variable7 strExtMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   STREXTSTRLOGRECORDNEXTINDEX  2
	{STREXTSTRLOGRECORDNEXTINDEX, ASN_UNSIGNED, RONLY, var_strExtStrlogRecordTable, 4, {1, 1, 1, 1}},
#define   STREXTSTRLOGRECORDTIMESTAMP  5
	{STREXTSTRLOGRECORDTIMESTAMP, ASN_TIMETICKS, RONLY, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 2}},
#define   STREXTSTRLOGRECORDMID  6
	{STREXTSTRLOGRECORDMID, ASN_UNSIGNED, RWRITE, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 3}},
#define   STREXTSTRLOGRECORDSID  7
	{STREXTSTRLOGRECORDSID, ASN_UNSIGNED, RWRITE, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 4}},
#define   STREXTSTRLOGRECORDLEVEL  8
	{STREXTSTRLOGRECORDLEVEL, ASN_UNSIGNED, RWRITE, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 5}},
#define   STREXTSTRLOGRECORDFLAGS  9
	{STREXTSTRLOGRECORDFLAGS, ASN_BIT_STR, RWRITE, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 6}},
#define   STREXTSTRLOGRECORDMSGSTRING  10
	{STREXTSTRLOGRECORDMSGSTRING, ASN_OCTET_STR, RWRITE, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 7}},
#define   STREXTSTRLOGRECORDROWSTATUS  11
	{STREXTSTRLOGRECORDROWSTATUS, ASN_INTEGER, RWRITE, var_strExtStrlogRecordTable, 5, {1, 1, 1, 2, 8}},
#define   STRNLOGARGS           12
	{STRNLOGARGS, ASN_UNSIGNED, RWRITE, var_strExtMIB, 3, {1, 2, 1}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_strExtMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_strExtMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("strExtMIB_simple", strExtMIB_simple_variables, variable7, strExtMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_strExtMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_strExtMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strExtStrlogRecordTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strExtMIB_simple above.
 */
unsigned char *
var_strExtStrlogRecordTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case STREXTSTRLOGRECORDNEXTINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDTIMESTAMP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case STREXTSTRLOGRECORDMID:
		*write_method = write_strExtStrlogRecordMid;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDSID:
		*write_method = write_strExtStrlogRecordSid;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDLEVEL:
		*write_method = write_strExtStrlogRecordLevel;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDFLAGS:
		*write_method = write_strExtStrlogRecordFlags;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case STREXTSTRLOGRECORDMSGSTRING:
		*write_method = write_strExtStrlogRecordMsgString;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case STREXTSTRLOGRECORDROWSTATUS:
		*write_method = write_strExtStrlogRecordRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strExtStrlogRecordTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strExtMIB_simple above.
 */
unsigned char *
var_strExtStrlogRecordTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case STREXTSTRLOGRECORDNEXTINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDTIMESTAMP:

		long_ret = 0;
		return (u_char *) &long_ret;
	case STREXTSTRLOGRECORDMID:
		*write_method = write_strExtStrlogRecordMid;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDSID:
		*write_method = write_strExtStrlogRecordSid;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDLEVEL:
		*write_method = write_strExtStrlogRecordLevel;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case STREXTSTRLOGRECORDFLAGS:
		*write_method = write_strExtStrlogRecordFlags;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case STREXTSTRLOGRECORDMSGSTRING:
		*write_method = write_strExtStrlogRecordMsgString;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case STREXTSTRLOGRECORDROWSTATUS:
		*write_method = write_strExtStrlogRecordRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_strExtStrlogRecordMid(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strExtStrlogRecordMid not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to strExtStrlogRecordMid: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do
		   something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strExtStrlogRecordSid(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strExtStrlogRecordSid not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to strExtStrlogRecordSid: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do
		   something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strExtStrlogRecordLevel(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strExtStrlogRecordLevel not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to strExtStrlogRecordLevel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do
		   something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strExtStrlogRecordFlags(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to strExtStrlogRecordFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to strExtStrlogRecordFlags: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something
		   with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strExtStrlogRecordMsgString(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to strExtStrlogRecordMsgString not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to strExtStrlogRecordMsgString: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something
		   with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strExtStrlogRecordRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strExtStrlogRecordRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to strExtStrlogRecordRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do
		   something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strNlogargs(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strNlogargs not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to strNlogargs: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do
		   something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything
		   done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
