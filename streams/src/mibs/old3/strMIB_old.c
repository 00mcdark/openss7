/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */


#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */


/* This should always be included first before anything else */
#include <config.h>


/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"


#else /* !IN_UCD_SNMP_SOURCE */


#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>


#endif /* !IN_UCD_SNMP_SOURCE */


#include "strMIB_old.h"


/* 
 * strMIB_old_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


oid strMIB_old_variables_oid[] = { 1,3,6,1,4,1,29591,1,1,1 };


/* 
 * variable7 strMIB_old_variables:
 *   this variable defines function callbacks and type return information 
 *   for the strMIB_old mib section 
 */


struct variable7 strMIB_old_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   STRMODNAME            4
  { STRMODNAME          , ASN_OCTET_STR , RONLY , var_strModTable, 6, { 1,1,1,1,1,2 } },
#define   STRMODTYPE            5
  { STRMODTYPE          , ASN_INTEGER   , RONLY , var_strModTable, 6, { 1,1,1,1,1,3 } },
#define   STRMODMAJOR           6
  { STRMODMAJOR         , ASN_UNSIGNED  , RONLY , var_strModTable, 6, { 1,1,1,1,1,4 } },
#define   STRMODINFOQUEUES      10
  { STRMODINFOQUEUES    , ASN_BIT_STR   , RONLY , var_strModInfoTable, 6, { 1,1,2,1,1,2 } },
#define   STRMODINFOMINPSZ      11
  { STRMODINFOMINPSZ    , ASN_INTEGER   , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,3 } },
#define   STRMODINFOMAXPSZ      12
  { STRMODINFOMAXPSZ    , ASN_INTEGER   , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,4 } },
#define   STRMODINFOHIWAT       13
  { STRMODINFOHIWAT     , ASN_UNSIGNED  , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,5 } },
#define   STRMODINFOLOWAT       14
  { STRMODINFOLOWAT     , ASN_UNSIGNED  , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,6 } },
#define   STRMODINFOTRACELEVEL  15
  { STRMODINFOTRACELEVEL, ASN_UNSIGNED  , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,7 } },
#define   STRMODSTATQUEUES      19
  { STRMODSTATQUEUES    , ASN_BIT_STR   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,2 } },
#define   STRMODSTATPCNT        20
  { STRMODSTATPCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,3 } },
#define   STRMODSTATSCNT        21
  { STRMODSTATSCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,4 } },
#define   STRMODSTATOCNT        22
  { STRMODSTATOCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,5 } },
#define   STRMODSTATCCNT        23
  { STRMODSTATCCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,6 } },
#define   STRMODSTATACNT        24
  { STRMODSTATACNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,7 } },
#define   STRMODSTATPRIVATE     25
  { STRMODSTATPRIVATE   , ASN_OCTET_STR , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,8 } },
#define   STRMODSTATFLAGS       26
  { STRMODSTATFLAGS     , ASN_UNSIGNED  , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,9 } },
#define   STRAPSHMAJOR          30
  { STRAPSHMAJOR        , ASN_UNSIGNED  , RONLY , var_strApshTable, 6, { 1,1,4,1,1,2 } },
#define   STRAPSHMODULES        33
  { STRAPSHMODULES      , ASN_OCTET_STR , RWRITE, var_strApshTable, 6, { 1,1,4,1,1,5 } },
#define   STRAPSHSTATUS         34
  { STRAPSHSTATUS       , ASN_INTEGER   , RWRITE, var_strApshTable, 6, { 1,1,4,1,1,6 } },
#define   STRSTATSSTRUCTURE     37
  { STRSTATSSTRUCTURE   , ASN_INTEGER   , RONLY , var_strStatsTable, 6, { 1,1,5,1,1,1 } },
#define   STRSTATSCURRENTALLOCS  38
  { STRSTATSCURRENTALLOCS, ASN_GAUGE     , RONLY , var_strStatsTable, 6, { 1,1,5,1,1,2 } },
#define   STRSTATSHIGHWATERMARK  39
  { STRSTATSHIGHWATERMARK, ASN_GAUGE     , RONLY , var_strStatsTable, 6, { 1,1,5,1,1,3 } },
#define   STRCLTIME             40
  { STRCLTIME           , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,1 } },
#define   STRMAXAPUSH           41
  { STRMAXAPUSH         , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,2 } },
#define   STRMAXMBLK            42
  { STRMAXMBLK          , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,3 } },
#define   STRMAXSTRAMOD         43
  { STRMAXSTRAMOD       , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,4 } },
#define   STRMAXSTRDEV          44
  { STRMAXSTRDEV        , ASN_UNSIGNED  , RONLY , var_strMIB_old, 4, { 1,2,1,5 } },
#define   STRMAXSTRMOD          45
  { STRMAXSTRMOD        , ASN_UNSIGNED  , RONLY , var_strMIB_old, 4, { 1,2,1,6 } },
#define   STRMSGPRIORITY        46
  { STRMSGPRIORITY      , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,7 } },
#define   STRNBAND              47
  { STRNBAND            , ASN_UNSIGNED  , RONLY , var_strMIB_old, 4, { 1,2,1,8 } },
#define   STRNSTRMSGS           48
  { STRNSTRMSGS         , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,9 } },
#define   STRNSTRPUSH           49
  { STRNSTRPUSH         , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,10 } },
#define   STRHIWAT              50
  { STRHIWAT            , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,11 } },
#define   STRLOWAT              51
  { STRLOWAT            , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,12 } },
#define   STRMAXPSZ             52
  { STRMAXPSZ           , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,13 } },
#define   STRMINPSZ             53
  { STRMINPSZ           , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,14 } },
#define   STRREUSEFMODSW        54
  { STRREUSEFMODSW      , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,15 } },
#define   STRRTIME              55
  { STRRTIME            , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,16 } },
#define   STRSTRHOLD            56
  { STRSTRHOLD          , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,17 } },
#define   STRSTRCTLSZ           57
  { STRSTRCTLSZ         , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,18 } },
#define   STRSTRMSGSZ           58
  { STRSTRMSGSZ         , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,19 } },
#define   STRSTRTHRESH          59
  { STRSTRTHRESH        , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,20 } },
#define   STRLOWTHRESH          60
  { STRLOWTHRESH        , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,21 } },
#define   STRMEDTHRESH          61
  { STRMEDTHRESH        , ASN_UNSIGNED  , RWRITE, var_strMIB_old, 4, { 1,2,1,22 } },
#define   STRIOCTIME            62
  { STRIOCTIME          , ASN_INTEGER   , RWRITE, var_strMIB_old, 4, { 1,2,1,23 } },

};
/*    (L = length of the oidsuffix) */


/*
 * init_strMIB_old():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_strMIB_old(void) {


  /* register ourselves with the agent to handle our mib tree */
  REGISTER_MIB("strMIB_old", strMIB_old_variables, variable7,
               strMIB_old_variables_oid);


  /* place any other initialization junk you need here */
}


/*
 * var_strMIB_old():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_strMIB_old(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRCLTIME:
        *write_method = write_strCltime;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMAXAPUSH:
        *write_method = write_strMaxApush;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMAXMBLK:
        *write_method = write_strMaxMblk;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMAXSTRAMOD:
        *write_method = write_strMaxStramod;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMAXSTRDEV:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMAXSTRMOD:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMSGPRIORITY:
        *write_method = write_strMsgPriority;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRNBAND:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRNSTRMSGS:
        *write_method = write_strNstrmsgs;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRNSTRPUSH:
        *write_method = write_strNstrpush;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRHIWAT:
        *write_method = write_strHiwat;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRLOWAT:
        *write_method = write_strLowat;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMAXPSZ:
        *write_method = write_strMaxpsz;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMINPSZ:
        *write_method = write_strMinpsz;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRREUSEFMODSW:
        *write_method = write_strReuseFmodsw;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRRTIME:
        *write_method = write_strRtime;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRSTRHOLD:
        *write_method = write_strStrhold;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRSTRCTLSZ:
        *write_method = write_strStrctlsz;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRSTRMSGSZ:
        *write_method = write_strStrmsgsz;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRSTRTHRESH:
        *write_method = write_strStrthresh;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRLOWTHRESH:
        *write_method = write_strLowthresh;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMEDTHRESH:
        *write_method = write_strMedthresh;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRIOCTIME:
        *write_method = write_strIoctime;
        long_ret = 0;
        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}


/*
 * var_strModTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB_old above.
 */
unsigned char *
var_strModTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRMODNAME:
        
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case STRMODTYPE:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODMAJOR:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strModInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB_old above.
 */
unsigned char *
var_strModInfoTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRMODINFOQUEUES:
        
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case STRMODINFOMINPSZ:
        *write_method = write_strModInfoMinpsz;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODINFOMAXPSZ:
        *write_method = write_strModInfoMaxpsz;
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODINFOHIWAT:
        *write_method = write_strModInfoHiwat;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMODINFOLOWAT:
        *write_method = write_strModInfoLowat;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRMODINFOTRACELEVEL:
        *write_method = write_strModInfoTraceLevel;
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strModStatTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB_old above.
 */
unsigned char *
var_strModStatTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRMODSTATQUEUES:
        
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case STRMODSTATPCNT:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODSTATSCNT:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODSTATOCNT:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODSTATCCNT:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODSTATACNT:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRMODSTATPRIVATE:
        
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case STRMODSTATFLAGS:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strApshTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB_old above.
 */
unsigned char *
var_strApshTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRAPSHMAJOR:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case STRAPSHMODULES:
        *write_method = write_strApshModules;
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case STRAPSHSTATUS:
        *write_method = write_strApshStatus;
        long_ret = 0;
        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB_old above.
 */
unsigned char *
var_strStatsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRSTATSSTRUCTURE:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRSTATSCURRENTALLOCS:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case STRSTATSHIGHWATERMARK:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}




int
write_strModInfoMinpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strModInfoMinpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strModInfoMinpsz: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strModInfoMaxpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strModInfoMaxpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strModInfoMaxpsz: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strModInfoHiwat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strModInfoHiwat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strModInfoHiwat: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strModInfoLowat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strModInfoLowat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strModInfoLowat: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strModInfoTraceLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strModInfoTraceLevel not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strModInfoTraceLevel: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strApshModules(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned char string[SPRINT_MAX_LEN];
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR){
              fprintf(stderr, "write to strApshModules not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(string)){
              fprintf(stderr,"write to strApshModules: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          string = (char *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in string for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strApshStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strApshStatus not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strApshStatus: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strCltime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strCltime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strCltime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMaxApush(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMaxApush not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strMaxApush: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMaxMblk(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMaxMblk not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strMaxMblk: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMaxStramod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMaxStramod not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strMaxStramod: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMsgPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strMsgPriority not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strMsgPriority: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strNstrmsgs(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strNstrmsgs not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strNstrmsgs: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strNstrpush(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strNstrpush not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strNstrpush: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strHiwat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strHiwat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strHiwat: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strLowat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strLowat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strLowat: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMaxpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strMaxpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strMaxpsz: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMinpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strMinpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strMinpsz: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strReuseFmodsw(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strReuseFmodsw not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strReuseFmodsw: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strRtime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strRtime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strRtime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strStrhold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strStrhold not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strStrhold: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strStrctlsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strStrctlsz not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strStrctlsz: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strStrmsgsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strStrmsgsz not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strStrmsgsz: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strStrthresh(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strStrthresh not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strStrthresh: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strLowthresh(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strLowthresh not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strLowthresh: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strMedthresh(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned long *ulong_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMedthresh not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(ulong_ret)){
              fprintf(stderr,"write to strMedthresh: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          ulong_ret = (unsigned long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_strIoctime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strIoctime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to strIoctime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}






