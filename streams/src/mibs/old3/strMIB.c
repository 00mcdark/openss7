/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */


/* This should always be included first before anything else */
#include <config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif


/* minimal include directives */
#include "mibincl.h"
#include "header_complex.h"
#include "strMIB.h"
#include "snmp-tc.h"


/* 
 * strMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


oid strMIB_variables_oid[] = { 1,3,6,1,4,1,29591,1,1,1 };


/* 
 * variable7 strMIB_variables:
 *   this variable defines function callbacks and type return information 
 *   for the strMIB mib section 
 */


struct variable7 strMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   STRMODNAME            4
  { STRMODNAME          , ASN_OCTET_STR , RONLY , var_strModTable, 6, { 1,1,1,1,1,2 } },
#define   STRMODTYPE            5
  { STRMODTYPE          , ASN_INTEGER   , RONLY , var_strModTable, 6, { 1,1,1,1,1,3 } },
#define   STRMODMAJOR           6
  { STRMODMAJOR         , ASN_UNSIGNED  , RONLY , var_strModTable, 6, { 1,1,1,1,1,4 } },
#define   STRMODINFOQUEUES      10
  { STRMODINFOQUEUES    , ASN_BIT_STR   , RONLY , var_strModInfoTable, 6, { 1,1,2,1,1,2 } },
#define   STRMODINFOMINPSZ      11
  { STRMODINFOMINPSZ    , ASN_INTEGER   , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,3 } },
#define   STRMODINFOMAXPSZ      12
  { STRMODINFOMAXPSZ    , ASN_INTEGER   , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,4 } },
#define   STRMODINFOHIWAT       13
  { STRMODINFOHIWAT     , ASN_UNSIGNED  , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,5 } },
#define   STRMODINFOLOWAT       14
  { STRMODINFOLOWAT     , ASN_UNSIGNED  , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,6 } },
#define   STRMODINFOTRACELEVEL  15
  { STRMODINFOTRACELEVEL, ASN_UNSIGNED  , RWRITE, var_strModInfoTable, 6, { 1,1,2,1,1,7 } },
#define   STRMODSTATQUEUES      19
  { STRMODSTATQUEUES    , ASN_BIT_STR   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,2 } },
#define   STRMODSTATPCNT        20
  { STRMODSTATPCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,3 } },
#define   STRMODSTATSCNT        21
  { STRMODSTATSCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,4 } },
#define   STRMODSTATOCNT        22
  { STRMODSTATOCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,5 } },
#define   STRMODSTATCCNT        23
  { STRMODSTATCCNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,6 } },
#define   STRMODSTATACNT        24
  { STRMODSTATACNT      , ASN_COUNTER   , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,7 } },
#define   STRMODSTATPRIVATE     25
  { STRMODSTATPRIVATE   , ASN_OCTET_STR , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,8 } },
#define   STRMODSTATFLAGS       26
  { STRMODSTATFLAGS     , ASN_UNSIGNED  , RONLY , var_strModStatTable, 6, { 1,1,3,1,1,9 } },
#define   STRAPSHMAJOR          30
  { STRAPSHMAJOR        , ASN_UNSIGNED  , RONLY , var_strApshTable, 6, { 1,1,4,1,1,2 } },
#define   STRAPSHMODULES        33
  { STRAPSHMODULES      , ASN_OCTET_STR , RWRITE, var_strApshTable, 6, { 1,1,4,1,1,5 } },
#define   STRAPSHSTATUS         34
  { STRAPSHSTATUS       , ASN_INTEGER   , RWRITE, var_strApshTable, 6, { 1,1,4,1,1,6 } },
#define   STRSTATSSTRUCTURE     37
  { STRSTATSSTRUCTURE   , ASN_INTEGER   , RONLY , var_strStatsTable, 6, { 1,1,5,1,1,1 } },
#define   STRSTATSCURRENTALLOCS  38
  { STRSTATSCURRENTALLOCS, ASN_GAUGE     , RONLY , var_strStatsTable, 6, { 1,1,5,1,1,2 } },
#define   STRSTATSHIGHWATERMARK  39
  { STRSTATSHIGHWATERMARK, ASN_GAUGE     , RONLY , var_strStatsTable, 6, { 1,1,5,1,1,3 } },
#define   STRCLTIME             40
  { STRCLTIME           , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,1 } },
#define   STRMAXAPUSH           41
  { STRMAXAPUSH         , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,2 } },
#define   STRMAXMBLK            42
  { STRMAXMBLK          , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,3 } },
#define   STRMAXSTRAMOD         43
  { STRMAXSTRAMOD       , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,4 } },
#define   STRMAXSTRDEV          44
  { STRMAXSTRDEV        , ASN_UNSIGNED  , RONLY , var_strMIB, 4, { 1,2,1,5 } },
#define   STRMAXSTRMOD          45
  { STRMAXSTRMOD        , ASN_UNSIGNED  , RONLY , var_strMIB, 4, { 1,2,1,6 } },
#define   STRMSGPRIORITY        46
  { STRMSGPRIORITY      , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,7 } },
#define   STRNBAND              47
  { STRNBAND            , ASN_UNSIGNED  , RONLY , var_strMIB, 4, { 1,2,1,8 } },
#define   STRNSTRMSGS           48
  { STRNSTRMSGS         , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,9 } },
#define   STRNSTRPUSH           49
  { STRNSTRPUSH         , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,10 } },
#define   STRHIWAT              50
  { STRHIWAT            , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,11 } },
#define   STRLOWAT              51
  { STRLOWAT            , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,12 } },
#define   STRMAXPSZ             52
  { STRMAXPSZ           , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,13 } },
#define   STRMINPSZ             53
  { STRMINPSZ           , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,14 } },
#define   STRREUSEFMODSW        54
  { STRREUSEFMODSW      , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,15 } },
#define   STRRTIME              55
  { STRRTIME            , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,16 } },
#define   STRSTRHOLD            56
  { STRSTRHOLD          , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,17 } },
#define   STRSTRCTLSZ           57
  { STRSTRCTLSZ         , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,18 } },
#define   STRSTRMSGSZ           58
  { STRSTRMSGSZ         , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,19 } },
#define   STRSTRTHRESH          59
  { STRSTRTHRESH        , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,20 } },
#define   STRLOWTHRESH          60
  { STRLOWTHRESH        , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,21 } },
#define   STRMEDTHRESH          61
  { STRMEDTHRESH        , ASN_UNSIGNED  , RWRITE, var_strMIB, 4, { 1,2,1,22 } },
#define   STRIOCTIME            62
  { STRIOCTIME          , ASN_INTEGER   , RWRITE, var_strMIB, 4, { 1,2,1,23 } },

};
/*    (L = length of the oidsuffix) */


/* global storage of our data, saved in and configured by header_complex() */
static struct header_complex_index *strModTableStorage = NULL;

static struct header_complex_index *strModInfoTableStorage = NULL;

static struct header_complex_index *strModStatTableStorage = NULL;

static struct header_complex_index *strApshTableStorage = NULL;

static struct header_complex_index *strStatsTableStorage = NULL;




/*
 * init_strMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_strMIB(void) {
  DEBUGMSGTL(("strMIB", "initializing...  "));


  /* register ourselves with the agent to handle our mib tree */
  REGISTER_MIB("strMIB", strMIB_variables, variable7,
               strMIB_variables_oid);


  /* register our config handler(s) to deal with registrations */
  snmpd_register_config_handler("strModTable", parse_strModTable, NULL,
                                "HELP STRING");

  snmpd_register_config_handler("strModInfoTable", parse_strModInfoTable, NULL,
                                "HELP STRING");

  snmpd_register_config_handler("strModStatTable", parse_strModStatTable, NULL,
                                "HELP STRING");

  snmpd_register_config_handler("strApshTable", parse_strApshTable, NULL,
                                "HELP STRING");

  snmpd_register_config_handler("strStatsTable", parse_strStatsTable, NULL,
                                "HELP STRING");




  /* we need to be called back later to store our data */
  snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
                         store_strMIB, NULL);


  /* place any other initialization junk you need here */


  DEBUGMSGTL(("strMIB", "done.\n"));
}


/* 
 * strModTable_add(): adds a structure node to our data set 
 */
int
strModTable_add(struct strModTable_data *thedata) {
  struct variable_list *vars = NULL;


  DEBUGMSGTL(("strMIB", "adding data...  "));
 /* add the index variables to the varbind list, which is 
    used by header_complex to index the data */


  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (unsigned long *) thedata->strModIdnum, sizeof(thedata->strModIdnum)); /* strModIdnum */



  header_complex_add_data(&strModTableStorage, vars, thedata);
  DEBUGMSGTL(("strModTable","registered an entry\n"));


  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}


/*
 * parse_strModTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_strModTable(const char *token, char *line) {
  size_t tmpint;
  struct strModTable_data *StorageTmp = SNMP_MALLOC_STRUCT(strModTable_data);
  struct variable_list *vars = NULL;


    DEBUGMSGTL(("strMIB", "parsing config...  "));


  if (StorageTmp == NULL) {
    config_perror("malloc failure");
    return;
  }


  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModIdnum, &tmpint);

  line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->strModName, &StorageTmp->strModNameLen);
  if (StorageTmp->strModName == NULL) {
    config_perror("invalid specification for strModName");
    return;
  }

  line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->strModType, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModMajor, &tmpint);




  strModTable_add(StorageTmp);
    

  DEBUGMSGTL(("strMIB", "done.\n"));
}




/*
 * store_strModTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_strModTable(int majorID, int minorID, void *serverarg, void *clientarg) {
  char line[SNMP_MAXBUF];
  char *cptr;
  size_t tmpint;
  struct strModTable_data *StorageTmp;
  struct header_complex_index *hcindex;


  DEBUGMSGTL(("strMIB", "storing data...  "));


  for(hcindex=strModTableStorage; hcindex != NULL; 
      hcindex = hcindex->next) {
    StorageTmp = (struct strModTable_data *) hcindex->data;


/*   XXX:  if (StorageTmp->strModTableStorageType == ST_NONVOLATILE) { */


        memset(line,0,sizeof(line));
        strcat(line, "strModTable ");
        cptr = line + strlen(line);


    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModIdnum, &tmpint);
    cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->strModName, &StorageTmp->strModNameLen);
    cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->strModType, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModMajor, &tmpint);



    snmpd_store_config(line);
/*   } */
  }
  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}

/* 
 * strModInfoTable_add(): adds a structure node to our data set 
 */
int
strModInfoTable_add(struct strModInfoTable_data *thedata) {
  struct variable_list *vars = NULL;


  DEBUGMSGTL(("strMIB", "adding data...  "));
 /* add the index variables to the varbind list, which is 
    used by header_complex to index the data */


  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (unsigned long *) thedata->strModInfoIndex, sizeof(thedata->strModInfoIndex)); /* strModInfoIndex */



  header_complex_add_data(&strModInfoTableStorage, vars, thedata);
  DEBUGMSGTL(("strModInfoTable","registered an entry\n"));


  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}


/*
 * parse_strModInfoTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_strModInfoTable(const char *token, char *line) {
  size_t tmpint;
  struct strModInfoTable_data *StorageTmp = SNMP_MALLOC_STRUCT(strModInfoTable_data);
  struct variable_list *vars = NULL;


    DEBUGMSGTL(("strMIB", "parsing config...  "));


  if (StorageTmp == NULL) {
    config_perror("malloc failure");
    return;
  }


  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModInfoIndex, &tmpint);

  line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->strModInfoQueues, &StorageTmp->strModInfoQueuesLen);
  if (StorageTmp->strModInfoQueues == NULL) {
    config_perror("invalid specification for strModInfoQueues");
    return;
  }

  line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->strModInfoMinpsz, &tmpint);

  line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->strModInfoMaxpsz, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModInfoHiwat, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModInfoLowat, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModInfoTraceLevel, &tmpint);




  strModInfoTable_add(StorageTmp);
    

  DEBUGMSGTL(("strMIB", "done.\n"));
}




/*
 * store_strModInfoTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_strModInfoTable(int majorID, int minorID, void *serverarg, void *clientarg) {
  char line[SNMP_MAXBUF];
  char *cptr;
  size_t tmpint;
  struct strModInfoTable_data *StorageTmp;
  struct header_complex_index *hcindex;


  DEBUGMSGTL(("strMIB", "storing data...  "));


  for(hcindex=strModInfoTableStorage; hcindex != NULL; 
      hcindex = hcindex->next) {
    StorageTmp = (struct strModInfoTable_data *) hcindex->data;


/*   XXX:  if (StorageTmp->strModInfoTableStorageType == ST_NONVOLATILE) { */


        memset(line,0,sizeof(line));
        strcat(line, "strModInfoTable ");
        cptr = line + strlen(line);


    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModInfoIndex, &tmpint);
    cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->strModInfoQueues, &StorageTmp->strModInfoQueuesLen);
    cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->strModInfoMinpsz, &tmpint);
    cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->strModInfoMaxpsz, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModInfoHiwat, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModInfoLowat, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModInfoTraceLevel, &tmpint);



    snmpd_store_config(line);
/*   } */
  }
  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}

/* 
 * strModStatTable_add(): adds a structure node to our data set 
 */
int
strModStatTable_add(struct strModStatTable_data *thedata) {
  struct variable_list *vars = NULL;


  DEBUGMSGTL(("strMIB", "adding data...  "));
 /* add the index variables to the varbind list, which is 
    used by header_complex to index the data */


  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (unsigned long *) thedata->strModStatIndex, sizeof(thedata->strModStatIndex)); /* strModStatIndex */



  header_complex_add_data(&strModStatTableStorage, vars, thedata);
  DEBUGMSGTL(("strModStatTable","registered an entry\n"));


  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}


/*
 * parse_strModStatTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_strModStatTable(const char *token, char *line) {
  size_t tmpint;
  struct strModStatTable_data *StorageTmp = SNMP_MALLOC_STRUCT(strModStatTable_data);
  struct variable_list *vars = NULL;


    DEBUGMSGTL(("strMIB", "parsing config...  "));


  if (StorageTmp == NULL) {
    config_perror("malloc failure");
    return;
  }


  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModStatIndex, &tmpint);

  line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->strModStatQueues, &StorageTmp->strModStatQueuesLen);
  if (StorageTmp->strModStatQueues == NULL) {
    config_perror("invalid specification for strModStatQueues");
    return;
  }

  line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->strModStatPCnt, &tmpint);

  line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->strModStatScnt, &tmpint);

  line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->strModStatOcnt, &tmpint);

  line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->strModStatCcnt, &tmpint);

  line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->strModStatAcnt, &tmpint);

  line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->strModStatPrivate, &StorageTmp->strModStatPrivateLen);
  if (StorageTmp->strModStatPrivate == NULL) {
    config_perror("invalid specification for strModStatPrivate");
    return;
  }

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strModStatFlags, &tmpint);




  strModStatTable_add(StorageTmp);
    

  DEBUGMSGTL(("strMIB", "done.\n"));
}




/*
 * store_strModStatTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_strModStatTable(int majorID, int minorID, void *serverarg, void *clientarg) {
  char line[SNMP_MAXBUF];
  char *cptr;
  size_t tmpint;
  struct strModStatTable_data *StorageTmp;
  struct header_complex_index *hcindex;


  DEBUGMSGTL(("strMIB", "storing data...  "));


  for(hcindex=strModStatTableStorage; hcindex != NULL; 
      hcindex = hcindex->next) {
    StorageTmp = (struct strModStatTable_data *) hcindex->data;


/*   XXX:  if (StorageTmp->strModStatTableStorageType == ST_NONVOLATILE) { */


        memset(line,0,sizeof(line));
        strcat(line, "strModStatTable ");
        cptr = line + strlen(line);


    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModStatIndex, &tmpint);
    cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->strModStatQueues, &StorageTmp->strModStatQueuesLen);
    cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->strModStatPCnt, &tmpint);
    cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->strModStatScnt, &tmpint);
    cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->strModStatOcnt, &tmpint);
    cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->strModStatCcnt, &tmpint);
    cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->strModStatAcnt, &tmpint);
    cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->strModStatPrivate, &StorageTmp->strModStatPrivateLen);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strModStatFlags, &tmpint);



    snmpd_store_config(line);
/*   } */
  }
  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}

/* 
 * strApshTable_add(): adds a structure node to our data set 
 */
int
strApshTable_add(struct strApshTable_data *thedata) {
  struct variable_list *vars = NULL;


  DEBUGMSGTL(("strMIB", "adding data...  "));
 /* add the index variables to the varbind list, which is 
    used by header_complex to index the data */


  snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) thedata->strApshName, thedata->strApshNameLen); /* strApshName */
  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (unsigned long *) thedata->strApshMinor, sizeof(thedata->strApshMinor)); /* strApshMinor */



  header_complex_add_data(&strApshTableStorage, vars, thedata);
  DEBUGMSGTL(("strApshTable","registered an entry\n"));


  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}


/*
 * parse_strApshTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_strApshTable(const char *token, char *line) {
  size_t tmpint;
  struct strApshTable_data *StorageTmp = SNMP_MALLOC_STRUCT(strApshTable_data);
  struct variable_list *vars = NULL;


    DEBUGMSGTL(("strMIB", "parsing config...  "));


  if (StorageTmp == NULL) {
    config_perror("malloc failure");
    return;
  }


  line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->strApshName, &StorageTmp->strApshNameLen);
  if (StorageTmp->strApshName == NULL) {
    config_perror("invalid specification for strApshName");
    return;
  }

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strApshMajor, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strApshMinor, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strApshLastMinor, &tmpint);

  line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->strApshModules, &StorageTmp->strApshModulesLen);
  if (StorageTmp->strApshModules == NULL) {
    config_perror("invalid specification for strApshModules");
    return;
  }

  line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->strApshStatus, &tmpint);




  strApshTable_add(StorageTmp);
    

  DEBUGMSGTL(("strMIB", "done.\n"));
}




/*
 * store_strApshTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_strApshTable(int majorID, int minorID, void *serverarg, void *clientarg) {
  char line[SNMP_MAXBUF];
  char *cptr;
  size_t tmpint;
  struct strApshTable_data *StorageTmp;
  struct header_complex_index *hcindex;


  DEBUGMSGTL(("strMIB", "storing data...  "));


  for(hcindex=strApshTableStorage; hcindex != NULL; 
      hcindex = hcindex->next) {
    StorageTmp = (struct strApshTable_data *) hcindex->data;


/*   XXX:  if (StorageTmp->strApshTableStorageType == ST_NONVOLATILE) { */


        memset(line,0,sizeof(line));
        strcat(line, "strApshTable ");
        cptr = line + strlen(line);


    cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->strApshName, &StorageTmp->strApshNameLen);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strApshMajor, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strApshMinor, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strApshLastMinor, &tmpint);
    cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->strApshModules, &StorageTmp->strApshModulesLen);
    cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->strApshStatus, &tmpint);



    snmpd_store_config(line);
/*   } */
  }
  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}

/* 
 * strStatsTable_add(): adds a structure node to our data set 
 */
int
strStatsTable_add(struct strStatsTable_data *thedata) {
  struct variable_list *vars = NULL;


  DEBUGMSGTL(("strMIB", "adding data...  "));
 /* add the index variables to the varbind list, which is 
    used by header_complex to index the data */


  snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (long *) thedata->strStatsStructure, sizeof(thedata->strStatsStructure)); /* strStatsStructure */



  header_complex_add_data(&strStatsTableStorage, vars, thedata);
  DEBUGMSGTL(("strStatsTable","registered an entry\n"));


  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}


/*
 * parse_strStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_strStatsTable(const char *token, char *line) {
  size_t tmpint;
  struct strStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(strStatsTable_data);
  struct variable_list *vars = NULL;


    DEBUGMSGTL(("strMIB", "parsing config...  "));


  if (StorageTmp == NULL) {
    config_perror("malloc failure");
    return;
  }


  line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->strStatsStructure, &tmpint);

  line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->strStatsCurrentAllocs, &tmpint);

  line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->strStatsHighWaterMark, &tmpint);




  strStatsTable_add(StorageTmp);
    

  DEBUGMSGTL(("strMIB", "done.\n"));
}




/*
 * store_strStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_strStatsTable(int majorID, int minorID, void *serverarg, void *clientarg) {
  char line[SNMP_MAXBUF];
  char *cptr;
  size_t tmpint;
  struct strStatsTable_data *StorageTmp;
  struct header_complex_index *hcindex;


  DEBUGMSGTL(("strMIB", "storing data...  "));


  for(hcindex=strStatsTableStorage; hcindex != NULL; 
      hcindex = hcindex->next) {
    StorageTmp = (struct strStatsTable_data *) hcindex->data;


/*   XXX:  if (StorageTmp->strStatsTableStorageType == ST_NONVOLATILE) { */


        memset(line,0,sizeof(line));
        strcat(line, "strStatsTable ");
        cptr = line + strlen(line);


    cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->strStatsStructure, &tmpint);
    cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->strStatsCurrentAllocs, &tmpint);
    cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->strStatsHighWaterMark, &tmpint);



    snmpd_store_config(line);
/*   } */
  }
  DEBUGMSGTL(("strMIB", "done.\n"));
  return SNMPERR_SUCCESS;
}




/*
 * var_strModTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


struct strModTable_data *StorageTmp = NULL;


  DEBUGMSGTL(("strMIB", "var_strModTable: Entering...  \n"));
  /* 
   * this assumes you have registered all your data properly
   */
  if ((StorageTmp =
       header_complex(strModTableStorage, vp,name,length,exact,
                           var_len,write_method)) == NULL)
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRMODNAME:
        
        *var_len = StorageTmp->strModNameLen;
        return (u_char *) StorageTmp->strModName;

    case STRMODTYPE:
        
        *var_len = sizeof(StorageTmp->strModType);
        return (u_char *) &StorageTmp->strModType;

    case STRMODMAJOR:
        
        *var_len = sizeof(StorageTmp->strModMajor);
        return (u_char *) &StorageTmp->strModMajor;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strModInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModInfoTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


struct strModInfoTable_data *StorageTmp = NULL;


  DEBUGMSGTL(("strMIB", "var_strModInfoTable: Entering...  \n"));
  /* 
   * this assumes you have registered all your data properly
   */
  if ((StorageTmp =
       header_complex(strModInfoTableStorage, vp,name,length,exact,
                           var_len,write_method)) == NULL)
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRMODINFOQUEUES:
        
        *var_len = StorageTmp->strModInfoQueuesLen;
        return (u_char *) StorageTmp->strModInfoQueues;

    case STRMODINFOMINPSZ:
        *write_method = write_strModInfoMinpsz;
        *var_len = sizeof(StorageTmp->strModInfoMinpsz);
        return (u_char *) &StorageTmp->strModInfoMinpsz;

    case STRMODINFOMAXPSZ:
        *write_method = write_strModInfoMaxpsz;
        *var_len = sizeof(StorageTmp->strModInfoMaxpsz);
        return (u_char *) &StorageTmp->strModInfoMaxpsz;

    case STRMODINFOHIWAT:
        *write_method = write_strModInfoHiwat;
        *var_len = sizeof(StorageTmp->strModInfoHiwat);
        return (u_char *) &StorageTmp->strModInfoHiwat;

    case STRMODINFOLOWAT:
        *write_method = write_strModInfoLowat;
        *var_len = sizeof(StorageTmp->strModInfoLowat);
        return (u_char *) &StorageTmp->strModInfoLowat;

    case STRMODINFOTRACELEVEL:
        *write_method = write_strModInfoTraceLevel;
        *var_len = sizeof(StorageTmp->strModInfoTraceLevel);
        return (u_char *) &StorageTmp->strModInfoTraceLevel;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strModStatTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModStatTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


struct strModStatTable_data *StorageTmp = NULL;


  DEBUGMSGTL(("strMIB", "var_strModStatTable: Entering...  \n"));
  /* 
   * this assumes you have registered all your data properly
   */
  if ((StorageTmp =
       header_complex(strModStatTableStorage, vp,name,length,exact,
                           var_len,write_method)) == NULL)
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRMODSTATQUEUES:
        
        *var_len = StorageTmp->strModStatQueuesLen;
        return (u_char *) StorageTmp->strModStatQueues;

    case STRMODSTATPCNT:
        
        *var_len = sizeof(StorageTmp->strModStatPCnt);
        return (u_char *) &StorageTmp->strModStatPCnt;

    case STRMODSTATSCNT:
        
        *var_len = sizeof(StorageTmp->strModStatScnt);
        return (u_char *) &StorageTmp->strModStatScnt;

    case STRMODSTATOCNT:
        
        *var_len = sizeof(StorageTmp->strModStatOcnt);
        return (u_char *) &StorageTmp->strModStatOcnt;

    case STRMODSTATCCNT:
        
        *var_len = sizeof(StorageTmp->strModStatCcnt);
        return (u_char *) &StorageTmp->strModStatCcnt;

    case STRMODSTATACNT:
        
        *var_len = sizeof(StorageTmp->strModStatAcnt);
        return (u_char *) &StorageTmp->strModStatAcnt;

    case STRMODSTATPRIVATE:
        
        *var_len = StorageTmp->strModStatPrivateLen;
        return (u_char *) StorageTmp->strModStatPrivate;

    case STRMODSTATFLAGS:
        
        *var_len = sizeof(StorageTmp->strModStatFlags);
        return (u_char *) &StorageTmp->strModStatFlags;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strApshTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strApshTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


struct strApshTable_data *StorageTmp = NULL;


  DEBUGMSGTL(("strMIB", "var_strApshTable: Entering...  \n"));
  /* 
   * this assumes you have registered all your data properly
   */
  if ((StorageTmp =
       header_complex(strApshTableStorage, vp,name,length,exact,
                           var_len,write_method)) == NULL)
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRAPSHMAJOR:
        
        *var_len = sizeof(StorageTmp->strApshMajor);
        return (u_char *) &StorageTmp->strApshMajor;

    case STRAPSHMODULES:
        *write_method = write_strApshModules;
        *var_len = StorageTmp->strApshModulesLen;
        return (u_char *) StorageTmp->strApshModules;

    case STRAPSHSTATUS:
        *write_method = write_strApshStatus;
        *var_len = sizeof(StorageTmp->strApshStatus);
        return (u_char *) &StorageTmp->strApshStatus;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_strStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strStatsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


struct strStatsTable_data *StorageTmp = NULL;


  DEBUGMSGTL(("strMIB", "var_strStatsTable: Entering...  \n"));
  /* 
   * this assumes you have registered all your data properly
   */
  if ((StorageTmp =
       header_complex(strStatsTableStorage, vp,name,length,exact,
                           var_len,write_method)) == NULL)
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRSTATSSTRUCTURE:
        
        *var_len = sizeof(StorageTmp->strStatsStructure);
        return (u_char *) &StorageTmp->strStatsStructure;

    case STRSTATSCURRENTALLOCS:
        
        *var_len = sizeof(StorageTmp->strStatsCurrentAllocs);
        return (u_char *) &StorageTmp->strStatsCurrentAllocs;

    case STRSTATSHIGHWATERMARK:
        
        *var_len = sizeof(StorageTmp->strStatsHighWaterMark);
        return (u_char *) &StorageTmp->strStatsHighWaterMark;


    default:
      ERROR_MSG("");
  }
  return NULL;
}




int
write_strModInfoMinpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strModInfoTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1);


  DEBUGMSGTL(("strMIB", "write_strModInfoMinpsz entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strModInfoTableStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strModInfoMinpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strModInfoMinpsz;
             StorageTmp->strModInfoMinpsz = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strModInfoMinpsz = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strModInfoMaxpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strModInfoTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1);


  DEBUGMSGTL(("strMIB", "write_strModInfoMaxpsz entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strModInfoTableStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strModInfoMaxpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strModInfoMaxpsz;
             StorageTmp->strModInfoMaxpsz = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strModInfoMaxpsz = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strModInfoHiwat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strModInfoTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1);


  DEBUGMSGTL(("strMIB", "write_strModInfoHiwat entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strModInfoTableStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strModInfoHiwat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strModInfoHiwat;
             StorageTmp->strModInfoHiwat = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strModInfoHiwat = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strModInfoLowat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strModInfoTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1);


  DEBUGMSGTL(("strMIB", "write_strModInfoLowat entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strModInfoTableStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strModInfoLowat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strModInfoLowat;
             StorageTmp->strModInfoLowat = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strModInfoLowat = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strModInfoTraceLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strModInfoTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1);


  DEBUGMSGTL(("strMIB", "write_strModInfoTraceLevel entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strModInfoTableStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strModInfoTraceLevel not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strModInfoTraceLevel;
             StorageTmp->strModInfoTraceLevel = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strModInfoTraceLevel = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strApshModules(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static char * tmpvar;
  struct strApshTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1);


  DEBUGMSGTL(("strMIB", "write_strApshModules entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strApshTableStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 7 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR){
              fprintf(stderr, "write to strApshModules not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in string for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strApshModules;
             tmplen = StorageTmp->strApshModulesLen;
             memdup((u_char **) &StorageTmp->strApshModules, var_val, var_val_len);
             StorageTmp->strApshModulesLen = var_val_len;
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             SNMP_FREE(StorageTmp->strApshModules);
             StorageTmp->strApshModules = tmpvar;
             StorageTmp->strApshModulesLen = tmplen;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
     SNMP_FREE(tmpvar);
          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strCltime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strCltime entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strCltime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strCltime;
             StorageTmp->strCltime = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strCltime = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMaxApush(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMaxApush entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMaxApush not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMaxApush;
             StorageTmp->strMaxApush = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMaxApush = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMaxMblk(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMaxMblk entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMaxMblk not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMaxMblk;
             StorageTmp->strMaxMblk = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMaxMblk = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMaxStramod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMaxStramod entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMaxStramod not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMaxStramod;
             StorageTmp->strMaxStramod = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMaxStramod = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMsgPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMsgPriority entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strMsgPriority not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMsgPriority;
             StorageTmp->strMsgPriority = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMsgPriority = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strNstrmsgs(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strNstrmsgs entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strNstrmsgs not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strNstrmsgs;
             StorageTmp->strNstrmsgs = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strNstrmsgs = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strNstrpush(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strNstrpush entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strNstrpush not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strNstrpush;
             StorageTmp->strNstrpush = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strNstrpush = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strHiwat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strHiwat entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strHiwat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strHiwat;
             StorageTmp->strHiwat = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strHiwat = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strLowat(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strLowat entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strLowat not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strLowat;
             StorageTmp->strLowat = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strLowat = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMaxpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMaxpsz entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strMaxpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMaxpsz;
             StorageTmp->strMaxpsz = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMaxpsz = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMinpsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMinpsz entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strMinpsz not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMinpsz;
             StorageTmp->strMinpsz = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMinpsz = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strReuseFmodsw(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strReuseFmodsw entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strReuseFmodsw not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strReuseFmodsw;
             StorageTmp->strReuseFmodsw = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strReuseFmodsw = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strRtime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strRtime entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strRtime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strRtime;
             StorageTmp->strRtime = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strRtime = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strStrhold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strStrhold entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strStrhold not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strStrhold;
             StorageTmp->strStrhold = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strStrhold = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strStrctlsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strStrctlsz entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strStrctlsz not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strStrctlsz;
             StorageTmp->strStrctlsz = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strStrctlsz = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strStrmsgsz(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strStrmsgsz entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strStrmsgsz not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strStrmsgsz;
             StorageTmp->strStrmsgsz = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strStrmsgsz = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strStrthresh(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strStrthresh entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strStrthresh not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strStrthresh;
             StorageTmp->strStrthresh = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strStrthresh = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strLowthresh(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strLowthresh entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strLowthresh not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strLowthresh;
             StorageTmp->strLowthresh = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strLowthresh = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strMedthresh(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strMedthresh entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED){
              fprintf(stderr, "write to strMedthresh not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in ulong_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strMedthresh;
             StorageTmp->strMedthresh = *((unsigned long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strMedthresh = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}



int
write_strIoctime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static int tmpvar;
  struct strMIB_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1);


  DEBUGMSGTL(("strMIB", "write_strIoctime entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strMIBStorage, NULL,
                      &name[sizeof(strMIB_variables_oid)/sizeof(oid) + 5 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to strIoctime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strIoctime;
             StorageTmp->strIoctime = *((long *) var_val);
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             StorageTmp->strIoctime = tmpvar;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */

          break;
  }
  return SNMP_ERR_NOERROR;
}






int
write_strApshStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  struct strApshTable_data *StorageTmp = NULL;
  static struct strApshTable_data *StorageNew, *StorageDel;
  size_t newlen=name_len - (sizeof(strApshTable_variables_oid)/sizeof(oid) + 3 - 1);
  static int old_value;
  int set_value;
  static struct variable_list *vars, *vp;
  struct header_complex_index *hciptr;
  char who[MAX_OID_LEN], flagName[MAX_OID_LEN];


  StorageTmp =
    header_complex(strApshTableStorage, NULL,
                   &name[sizeof(strApshTable_variables_oid)/sizeof(oid) + 3 - 1], 
                   &newlen, 1, NULL, NULL);
  

  

  if (var_val_type != ASN_INTEGER || var_val == NULL){
    fprintf(stderr, "write to strApshStatus not ASN_INTEGER\n");
    return SNMP_ERR_WRONGTYPE;
  }
  set_value = *((long *) var_val);


  /* check legal range, and notReady is reserved for us, not a user */
  if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
    return SNMP_ERR_INCONSISTENTVALUE;
    

  switch ( action ) {
        case RESERVE1:
  /* stage one: test validity */
          if (StorageTmp == NULL) {
            /* create the row now? */


            /* ditch illegal values now */
            if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
              return SNMP_ERR_INCONSISTENTVALUE;
    

            /* destroying a non-existent row is actually legal */
            if (set_value == RS_DESTROY) {
              return SNMP_ERR_NOERROR;
            }


            /* illegal creation values */
            if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
              return SNMP_ERR_INCONSISTENTVALUE;
            }
          } else {
            /* row exists.  Check for a valid state change */
            if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
              /* can't create a row that exists */
              return SNMP_ERR_INCONSISTENTVALUE;
            }
    /* XXX: interaction with row storage type needed */
          }
          break;




        case RESERVE2:
          /* memory reseveration, final preparation... */
          if (StorageTmp == NULL) {
            /* creation */
            vars = NULL;


  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0); /* strModIdnum */
  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0); /* strModInfoIndex */
  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0); /* strModStatIndex */
  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0); /* strApshName */
  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0); /* strApshMinor */

                    

            if (header_complex_parse_oid(&(name[sizeof(strApshTable_variables_oid)/sizeof(oid)+2]), newlen,
                                         vars) != SNMPERR_SUCCESS) {
              /* XXX: free, zero vars */
              return SNMP_ERR_INCONSISTENTNAME;
            }
            vp = vars;


            StorageNew = SNMP_MALLOC_STRUCT(strApshTable_data);
            memdup((u_char **) &(StorageNew->strModIdnum), 
                   vp->val.ulong_ret,
                   vp->val_len);
            StorageNew->strModIdnumLen = vp->val_len;
            vp = vp->next_variable;
            memdup((u_char **) &(StorageNew->strModInfoIndex), 
                   vp->val.ulong_ret,
                   vp->val_len);
            StorageNew->strModInfoIndexLen = vp->val_len;
            vp = vp->next_variable;
            memdup((u_char **) &(StorageNew->strModStatIndex), 
                   vp->val.ulong_ret,
                   vp->val_len);
            StorageNew->strModStatIndexLen = vp->val_len;
            vp = vp->next_variable;
            memdup((u_char **) &(StorageNew->strApshName), 
                   vp->val.string,
                   vp->val_len);
            StorageNew->strApshNameLen = vp->val_len;
            vp = vp->next_variable;
            memdup((u_char **) &(StorageNew->strApshMinor), 
                   vp->val.ulong_ret,
                   vp->val_len);
            StorageNew->strApshMinorLen = vp->val_len;
            vp = vp->next_variable;





            /* XXX: fill in default row values here into StorageNew */


            StorageNew->strApshStatus = set_value;
            /* XXX: free, zero vars, no longer needed? */
          }
          

          break;




        case FREE:
          /* XXX: free, zero vars */
          /* Release any resources that have been allocated */
          break;




        case ACTION:
             /* The variable has been stored in set_value for you to
             use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in
             the UNDO case */
             

             if (StorageTmp == NULL) {
               /* row creation, so add it */
               if (StorageNew != NULL)
                 strApshTable_add(StorageNew);
               /* XXX: ack, and if it is NULL? */
             } else if (set_value != RS_DESTROY) {
               /* set the flag? */
               old_value = StorageTmp->strApshStatus;
               StorageTmp->strApshStatus = *((long *) var_val);
             } else {
               /* destroy...  extract it for now */
               hciptr =
                 header_complex_find_entry(strApshTableStorage,
                                           StorageTmp);
               StorageDel =
                 header_complex_extract_entry(&strApshTableStorage,
                                              hciptr);
             }
          break;




        case UNDO:
             /* Back out any changes made in the ACTION case */
             if (StorageTmp == NULL) {
               /* row creation, so remove it again */
               hciptr =
                 header_complex_find_entry(strApshTableStorage,
                                           StorageTmp);
               StorageDel =
                 header_complex_extract_entry(&strApshTableStorage,
                                              hciptr);
               /* XXX: free it */
             } else if (StorageDel != NULL) {
               /* row deletion, so add it again */
               strApshTable_add(StorageDel);
             } else {
               StorageTmp->strApshStatus = old_value;
             }
          break;




        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          if (StorageDel != NULL) {
            StorageDel = 0;
            /* XXX: free it, its dead */
          } else {
            if (StorageTmp && StorageTmp->strApshStatus == RS_CREATEANDGO) {
                StorageTmp->strApshStatus = RS_ACTIVE;
            } else if (StorageTmp &&
                       StorageTmp->strApshStatus == RS_CREATEANDWAIT) {
                StorageTmp->strApshStatus = RS_NOTINSERVICE;
            }
          }
          break;
  }
  return SNMP_ERR_NOERROR;
}




