/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */


/* This should always be included first before anything else */
#include <config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif


/* minimal include directives */
#include "mibincl.h"
#include "header_complex.h"
#include "strApshTable.h"
#include "snmp-tc.h"


/* 
 * strApshTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


oid strApshTable_variables_oid[] = { 1,3,6,1,4,1,29591,1,1,1,1,1,4,1 };


/* 
 * variable2 strApshTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the strApshTable mib section 
 */


struct variable2 strApshTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   STRAPSHMAJOR          4
  { STRAPSHMAJOR        , ASN_UNSIGNED  , RONLY , var_strApshTable, 2, { 1,2 } },
#define   STRAPSHMODULES        7
  { STRAPSHMODULES      , ASN_OCTET_STR , RWRITE, var_strApshTable, 2, { 1,5 } },
#define   STRAPSHSTATUS         8
  { STRAPSHSTATUS       , ASN_INTEGER   , RWRITE, var_strApshTable, 2, { 1,6 } },

};
/*    (L = length of the oidsuffix) */


/* global storage of our data, saved in and configured by header_complex() */
static struct header_complex_index *strApshTableStorage = NULL;




/*
 * init_strApshTable():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_strApshTable(void) {
  DEBUGMSGTL(("strApshTable", "initializing...  "));


  /* register ourselves with the agent to handle our mib tree */
  REGISTER_MIB("strApshTable", strApshTable_variables, variable2,
               strApshTable_variables_oid);


  /* register our config handler(s) to deal with registrations */
  snmpd_register_config_handler("strApshTable", parse_strApshTable, NULL,
                                "HELP STRING");




  /* we need to be called back later to store our data */
  snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
                         store_strApshTable, NULL);


  /* place any other initialization junk you need here */


  DEBUGMSGTL(("strApshTable", "done.\n"));
}


/* 
 * strApshTable_add(): adds a structure node to our data set 
 */
int
strApshTable_add(struct strApshTable_data *thedata) {
  struct variable_list *vars = NULL;


  DEBUGMSGTL(("strApshTable", "adding data...  "));
 /* add the index variables to the varbind list, which is 
    used by header_complex to index the data */


  snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) thedata->strApshName, thedata->strApshNameLen); /* strApshName */
  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (unsigned long *) thedata->strApshMinor, sizeof(thedata->strApshMinor)); /* strApshMinor */



  header_complex_add_data(&strApshTableStorage, vars, thedata);
  DEBUGMSGTL(("strApshTable","registered an entry\n"));


  DEBUGMSGTL(("strApshTable", "done.\n"));
  return SNMPERR_SUCCESS;
}


/*
 * parse_strApshTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_strApshTable(const char *token, char *line) {
  size_t tmpint;
  struct strApshTable_data *StorageTmp = SNMP_MALLOC_STRUCT(strApshTable_data);
  struct variable_list *vars = NULL;


    DEBUGMSGTL(("strApshTable", "parsing config...  "));


  if (StorageTmp == NULL) {
    config_perror("malloc failure");
    return;
  }


  line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->strApshName, &StorageTmp->strApshNameLen);
  if (StorageTmp->strApshName == NULL) {
    config_perror("invalid specification for strApshName");
    return;
  }

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strApshMajor, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strApshMinor, &tmpint);

  line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->strApshLastMinor, &tmpint);

  line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->strApshModules, &StorageTmp->strApshModulesLen);
  if (StorageTmp->strApshModules == NULL) {
    config_perror("invalid specification for strApshModules");
    return;
  }

  line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->strApshStatus, &tmpint);




  strApshTable_add(StorageTmp);
    

  DEBUGMSGTL(("strApshTable", "done.\n"));
}




/*
 * store_strApshTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_strApshTable(int majorID, int minorID, void *serverarg, void *clientarg) {
  char line[SNMP_MAXBUF];
  char *cptr;
  size_t tmpint;
  struct strApshTable_data *StorageTmp;
  struct header_complex_index *hcindex;


  DEBUGMSGTL(("strApshTable", "storing data...  "));


  for(hcindex=strApshTableStorage; hcindex != NULL; 
      hcindex = hcindex->next) {
    StorageTmp = (struct strApshTable_data *) hcindex->data;


/*   XXX:  if (StorageTmp->strApshTableStorageType == ST_NONVOLATILE) { */


        memset(line,0,sizeof(line));
        strcat(line, "strApshTable ");
        cptr = line + strlen(line);


    cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->strApshName, &StorageTmp->strApshNameLen);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strApshMajor, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strApshMinor, &tmpint);
    cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->strApshLastMinor, &tmpint);
    cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->strApshModules, &StorageTmp->strApshModulesLen);
    cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->strApshStatus, &tmpint);



    snmpd_store_config(line);
/*   } */
  }
  DEBUGMSGTL(("strApshTable", "done.\n"));
  return SNMPERR_SUCCESS;
}




/*
 * var_strApshTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strApshTable above.
 */
unsigned char *
var_strApshTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


struct strApshTable_data *StorageTmp = NULL;


  DEBUGMSGTL(("strApshTable", "var_strApshTable: Entering...  \n"));
  /* 
   * this assumes you have registered all your data properly
   */
  if ((StorageTmp =
       header_complex(strApshTableStorage, vp,name,length,exact,
                           var_len,write_method)) == NULL)
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case STRAPSHMAJOR:
        
        *var_len = sizeof(StorageTmp->strApshMajor);
        return (u_char *) &StorageTmp->strApshMajor;

    case STRAPSHMODULES:
        *write_method = write_strApshModules;
        *var_len = StorageTmp->strApshModulesLen;
        return (u_char *) StorageTmp->strApshModules;

    case STRAPSHSTATUS:
        *write_method = write_strApshStatus;
        *var_len = sizeof(StorageTmp->strApshStatus);
        return (u_char *) &StorageTmp->strApshStatus;


    default:
      ERROR_MSG("");
  }
  return NULL;
}




int
write_strApshModules(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  static char * tmpvar;
  struct strApshTable_data *StorageTmp = NULL;
  static size_t tmplen;
  size_t newlen=name_len - (sizeof(strApshTable_variables_oid)/sizeof(oid) + 3 - 1);


  DEBUGMSGTL(("strApshTable", "write_strApshModules entering action=%d...  \n", action));
  if ((StorageTmp =
       header_complex(strApshTableStorage, NULL,
                      &name[sizeof(strApshTable_variables_oid)/sizeof(oid) + 3 - 1], 
                      &newlen, 1, NULL, NULL)) == NULL)
      return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR){
              fprintf(stderr, "write to strApshModules not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;


        case RESERVE2:
             /* memory reseveration, final preparation... */
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in string for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
             tmpvar = StorageTmp->strApshModules;
             tmplen = StorageTmp->strApshModulesLen;
             memdup((u_char **) &StorageTmp->strApshModules, var_val, var_val_len);
             StorageTmp->strApshModulesLen = var_val_len;
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
             SNMP_FREE(StorageTmp->strApshModules);
             StorageTmp->strApshModules = tmpvar;
             StorageTmp->strApshModulesLen = tmplen;
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
     SNMP_FREE(tmpvar);
          break;
  }
  return SNMP_ERR_NOERROR;
}






int
write_strApshStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t    name_len)
{
  struct strApshTable_data *StorageTmp = NULL;
  static struct strApshTable_data *StorageNew, *StorageDel;
  size_t newlen=name_len - (sizeof(strApshTable_variables_oid)/sizeof(oid) + 3 - 1);
  static int old_value;
  int set_value;
  static struct variable_list *vars, *vp;
  struct header_complex_index *hciptr;
  char who[MAX_OID_LEN], flagName[MAX_OID_LEN];


  StorageTmp =
    header_complex(strApshTableStorage, NULL,
                   &name[sizeof(strApshTable_variables_oid)/sizeof(oid) + 3 - 1], 
                   &newlen, 1, NULL, NULL);
  

  

  if (var_val_type != ASN_INTEGER || var_val == NULL){
    fprintf(stderr, "write to strApshStatus not ASN_INTEGER\n");
    return SNMP_ERR_WRONGTYPE;
  }
  set_value = *((long *) var_val);


  /* check legal range, and notReady is reserved for us, not a user */
  if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
    return SNMP_ERR_INCONSISTENTVALUE;
    

  switch ( action ) {
        case RESERVE1:
  /* stage one: test validity */
          if (StorageTmp == NULL) {
            /* create the row now? */


            /* ditch illegal values now */
            if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
              return SNMP_ERR_INCONSISTENTVALUE;
    

            /* destroying a non-existent row is actually legal */
            if (set_value == RS_DESTROY) {
              return SNMP_ERR_NOERROR;
            }


            /* illegal creation values */
            if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
              return SNMP_ERR_INCONSISTENTVALUE;
            }
          } else {
            /* row exists.  Check for a valid state change */
            if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
              /* can't create a row that exists */
              return SNMP_ERR_INCONSISTENTVALUE;
            }
    /* XXX: interaction with row storage type needed */
          }
          break;




        case RESERVE2:
          /* memory reseveration, final preparation... */
          if (StorageTmp == NULL) {
            /* creation */
            vars = NULL;


  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0); /* strApshName */
  	  snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0); /* strApshMinor */

                    

            if (header_complex_parse_oid(&(name[sizeof(strApshTable_variables_oid)/sizeof(oid)+2]), newlen,
                                         vars) != SNMPERR_SUCCESS) {
              /* XXX: free, zero vars */
              return SNMP_ERR_INCONSISTENTNAME;
            }
            vp = vars;


            StorageNew = SNMP_MALLOC_STRUCT(strApshTable_data);
            memdup((u_char **) &(StorageNew->strApshName), 
                   vp->val.string,
                   vp->val_len);
            StorageNew->strApshNameLen = vp->val_len;
            vp = vp->next_variable;
            memdup((u_char **) &(StorageNew->strApshMinor), 
                   vp->val.ulong_ret,
                   vp->val_len);
            StorageNew->strApshMinorLen = vp->val_len;
            vp = vp->next_variable;





            /* XXX: fill in default row values here into StorageNew */


            StorageNew->strApshStatus = set_value;
            /* XXX: free, zero vars, no longer needed? */
          }
          

          break;




        case FREE:
          /* XXX: free, zero vars */
          /* Release any resources that have been allocated */
          break;




        case ACTION:
             /* The variable has been stored in set_value for you to
             use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in
             the UNDO case */
             

             if (StorageTmp == NULL) {
               /* row creation, so add it */
               if (StorageNew != NULL)
                 strApshTable_add(StorageNew);
               /* XXX: ack, and if it is NULL? */
             } else if (set_value != RS_DESTROY) {
               /* set the flag? */
               old_value = StorageTmp->strApshStatus;
               StorageTmp->strApshStatus = *((long *) var_val);
             } else {
               /* destroy...  extract it for now */
               hciptr =
                 header_complex_find_entry(strApshTableStorage,
                                           StorageTmp);
               StorageDel =
                 header_complex_extract_entry(&strApshTableStorage,
                                              hciptr);
             }
          break;




        case UNDO:
             /* Back out any changes made in the ACTION case */
             if (StorageTmp == NULL) {
               /* row creation, so remove it again */
               hciptr =
                 header_complex_find_entry(strApshTableStorage,
                                           StorageTmp);
               StorageDel =
                 header_complex_extract_entry(&strApshTableStorage,
                                              hciptr);
               /* XXX: free it */
             } else if (StorageDel != NULL) {
               /* row deletion, so add it again */
               strApshTable_add(StorageDel);
             } else {
               StorageTmp->strApshStatus = old_value;
             }
          break;




        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          if (StorageDel != NULL) {
            StorageDel = 0;
            /* XXX: free it, its dead */
          } else {
            if (StorageTmp && StorageTmp->strApshStatus == RS_CREATEANDGO) {
                StorageTmp->strApshStatus = RS_ACTIVE;
            } else if (StorageTmp &&
                       StorageTmp->strApshStatus == RS_CREATEANDWAIT) {
                StorageTmp->strApshStatus = RS_NOTINSERVICE;
            }
          }
          break;
  }
  return SNMP_ERR_NOERROR;
}




