/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.4.6.2 2006/04/18 17:36:51 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "strMIB.h"

/* 
 * strMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid strMIB_variables_oid[] = { };

/* 
 * variable4 strMIB_variables:
 *   this variable defines function callbacks and type return information 
 *   for the strMIB mib section 
 */

struct variable7 strMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define STRCLTIME		1
	{STRCLTIME, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 1}},
#define STRMAXAPUSH		2
	{STRMAXAPUSH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 2}},
#define STRMAXMBLK		3
	{STRMAXMBLK, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 3}},
#define STRMAXSTRAMOD		4
	{STRMAXSTRAMOD, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 4}},
#define STRMAXSTRDEV		5
	{STRMAXSTRDEV, ASN_UNSIGNED, RONLY, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 5}},
#define STRMAXSTRMOD		6
	{STRMAXSTRMOD, ASN_UNSIGNED, RONLY, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 6}},
#define STRMSGPRIORITY		7
	{STRMSGPRIORITY, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 7}},
#define STRNBAND		8
	{STRNBAND, ASN_UNSIGNED, RONLY, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 8}},
#define STRNSTRMSGS		9
	{STRNSTRMSGS, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 9}},
#define STRNSTRPUSH		10
	{STRNSTRPUSH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 10}},
#define STRHIWAT		11
	{STRHIWAT, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 11}},
#define STRLOWAT		12
	{STRLOWAT, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 12}},
#define STRMAXPSZ		13
	{STRMAXPSZ, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 13}},
#define STRMINPSZ		14
	{STRMINPSZ, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 14}},
#define STRREUSEFMODSW		15
	{STRREUSEFMODSW, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 15}},
#define STRRTIME		16
	{STRRTIME, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 16}},
#define STRSTRHOLD		17
	{STRSTRHOLD, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 17}},
#define STRSTRCTLSZ		18
	{STRSTRCTLSZ, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 18}},
#define STRSTRMSGSZ		19
	{STRSTRMSGSZ, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 19}},
#define STRSTRTHRESH		20
	{STRSTRTHRESH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 20}},
#define STRLOWTHRESH		21
	{STRLOWTHRESH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 21}},
#define STRMEDTHRESH		22
	{STRMEDTHRESH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 22}},
#define STRIOCTIME		23
	{STRIOCTIME, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 23}},

#define STRMODIDNUM		24
	{STRMODIDNUM, ASN_UNSIGNED, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 1}},
#define STRMODNAME		25
	{STRMODNAME, ASN_OCTET_STR, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 2}},
#define STRMODTYPE		26
	{STRMODTYPE, ASN_INTEGER, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 3}},
#define STRMODMAJOR		27
	{STRMODMAJOR, ASN_UNSIGNED, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 4}},
#define STRMODINFOINDEX		28
	{STRMODINFOINDEX, ASN_UNSIGNED, RONLY, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 1}},
#define STRMODINFOQUEUES		29
	{STRMODINFOQUEUES, ASN_OCTET_STR, RONLY, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 2}},
#define STRMODINFOMINPSZ		30
	{STRMODINFOMINPSZ, ASN_INTEGER, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 3}},
#define STRMODINFOMAXPSZ		31
	{STRMODINFOMAXPSZ, ASN_INTEGER, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 4}},
#define STRMODINFOHIWAT		32
	{STRMODINFOHIWAT, ASN_UNSIGNED, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 5}},
#define STRMODINFOLOWAT		33
	{STRMODINFOLOWAT, ASN_UNSIGNED, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 6}},
#define STRMODINFOTRACELEVEL		34
	{STRMODINFOTRACELEVEL, ASN_UNSIGNED, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 7}},
#define STRMODSTATINDEX		35
	{STRMODSTATINDEX, ASN_UNSIGNED, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 1}},
#define STRMODSTATQUEUES		36
	{STRMODSTATQUEUES, ASN_OCTET_STR, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 2}},
#define STRMODSTATPCNT		37
	{STRMODSTATPCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 3}},
#define STRMODSTATSCNT		38
	{STRMODSTATSCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 4}},
#define STRMODSTATOCNT		39
	{STRMODSTATOCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 5}},
#define STRMODSTATCCNT		40
	{STRMODSTATCCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 6}},
#define STRMODSTATACNT		41
	{STRMODSTATACNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 7}},
#define STRMODSTATPRIVATE		42
	{STRMODSTATPRIVATE, ASN_OCTET_STR, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 8}},
#define STRMODSTATFLAGS		43
	{STRMODSTATFLAGS, ASN_UNSIGNED, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 9}},
#define STRAPSHNAME		44
	{STRAPSHNAME, ASN_OCTET_STR, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 1}},
#define STRAPSHMAJOR		45
	{STRAPSHMAJOR, ASN_UNSIGNED, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 2}},
#define STRAPSHMINOR		46
	{STRAPSHMINOR, ASN_UNSIGNED, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 3}},
#define STRAPSHLASTMINOR		47
	{STRAPSHLASTMINOR, ASN_UNSIGNED, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 4}},
#define STRAPSHMODULES		48
	{STRAPSHMODULES, ASN_OCTET_STR, RWRITE, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 5}},
#define STRAPSHSTATUS		49
	{STRAPSHSTATUS, ASN_INTEGER, RWRITE, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 6}},
#define STRSTATSSTRUCTURE		50
	{STRSTATSSTRUCTURE, ASN_INTEGER, RONLY, var_strStatsTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 5, 1, 1, 1}},
#define STRSTATSCURRENTALLOCS		51
	{STRSTATSCURRENTALLOCS, ASN_GAUGE, RONLY, var_strStatsTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 5, 1, 1, 2}},
#define STRSTATSHIGHWATERMARK		52
	{STRSTATSHIGHWATERMARK, ASN_GAUGE, RONLY, var_strStatsTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 5, 1, 1, 3}},
};

/*    (L = length of the oidsuffix) */

/** Initializes the strMIB module */
void
init_strMIB(void)
{

	DEBUGMSGTL(("strMIB", "Initializing\n"));

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("strMIB", strMIB_variables, variable4, strMIB_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_strMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_strMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		WriteMethod ** write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRCLTIME:
		*write_method = write_strCltime;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMAXAPUSH:
		*write_method = write_strMaxApush;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMAXMBLK:
		*write_method = write_strMaxMblk;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMAXSTRAMOD:
		*write_method = write_strMaxStramod;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMAXSTRDEV:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMAXSTRMOD:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMSGPRIORITY:
		*write_method = write_strMsgPriority;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRNBAND:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRNSTRMSGS:
		*write_method = write_strNstrmsgs;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRNSTRPUSH:
		*write_method = write_strNstrpush;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRHIWAT:
		*write_method = write_strHiwat;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRLOWAT:
		*write_method = write_strLowat;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMAXPSZ:
		*write_method = write_strMaxpsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMINPSZ:
		*write_method = write_strMinpsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRREUSEFMODSW:
		*write_method = write_strReuseFmodsw;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRRTIME:
		*write_method = write_strRtime;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTRHOLD:
		*write_method = write_strStrhold;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTRCTLSZ:
		*write_method = write_strStrctlsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTRMSGSZ:
		*write_method = write_strStrmsgsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTRTHRESH:
		*write_method = write_strStrthresh;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRLOWTHRESH:
		*write_method = write_strLowthresh;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMEDTHRESH:
		*write_method = write_strMedthresh;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRIOCTIME:
		*write_method = write_strIoctime;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strModTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		WriteMethod ** write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRMODIDNUM:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODNAME:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODTYPE:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODMAJOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strModInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModInfoTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		    WriteMethod ** write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRMODINFOINDEX:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOQUEUES:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOMINPSZ:
		*write_method = write_strModInfoMinpsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOMAXPSZ:
		*write_method = write_strModInfoMaxpsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOHIWAT:
		*write_method = write_strModInfoHiwat;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOLOWAT:
		*write_method = write_strModInfoLowat;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOTRACELEVEL:
		*write_method = write_strModInfoTraceLevel;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strModStatTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModStatTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		    WriteMethod ** write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRMODSTATINDEX:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATQUEUES:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATPCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATSCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATOCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATCCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATACNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATPRIVATE:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATFLAGS:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strApshTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strApshTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		 WriteMethod ** write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRAPSHNAME:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHMAJOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHMINOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHLASTMINOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHMODULES:
		*write_method = write_strApshModules;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHSTATUS:
		*write_method = write_strApshStatus;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRSTATSSTRUCTURE:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTATSCURRENTALLOCS:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTATSHIGHWATERMARK:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_strCltime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
		oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxApush(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxMblk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		 u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxStramod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		    u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMsgPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		     u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strNstrmsgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strNstrpush(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strHiwat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
	       oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strLowat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
	       oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
		oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMinpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
		oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strReuseFmodsw(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		     u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strRtime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
	       oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrhold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		 u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrctlsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrmsgsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrthresh(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strLowthresh(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMedthresh(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strIoctime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		 u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoMinpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoMaxpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoHiwat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		      u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoLowat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		      u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoTraceLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			   u_char *statP, oid * name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strApshModules(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		     u_char *statP, oid * name, size_t name_len)
{
	char value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to strMIB not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(char)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(char *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strApshStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		    u_char *statP, oid * name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}
