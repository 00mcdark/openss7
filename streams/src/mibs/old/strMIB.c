/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.4.6.2 2006/04/18 17:36:51 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "strMIB.h"

/* name of backing sysctl file */
char sysctl_fname[256] = "/etc/streams.conf";

/* file pointer for backing sysctl file */
FILE *sysctl_file = NULL;

/* file descriptor for SAD/SC driver */
int sad_fd = 0;

/* /proc/streams */
enum {
	CTL_STREAMS = 11,		/* STREAMS */
};

/* /proc/sys/streams */
enum {
	STREAMS_MAXPSZ = 1,
	STREAMS_MINPSZ = 2,
	STREAMS_HIWAT = 3,
	STREAMS_LOWAT = 4,
	STREAMS_CLTIME = 5,
	STREAMS_RTIME = 6,
	STREAMS_IOCTIME = 7,
	STREAMS_NSTRPUSH = 8,
	STREAMS_STRTHRESH = 9,
	STREAMS_STRHOLD = 10,
	STREAMS_STRCTLSZ = 11,
	STREAMS_STRMSGSZ = 12,
	STREAMS_NSTRMSGS = 13,
	STREAMS_NBAND = 14,
	STREAMS_REUSE_FMODSW = 15,
	STREAMS_MAX_APUSH = 16,
	STREAMS_MAX_STRAMOD = 17,
	STREAMS_MAX_STRDEV = 18,
	STREAMS_MAX_STRMOD = 19,
	STREAMS_MAX_MBLK = 20,
	STREAMS_MSG_PRIORITY = 21,
};

/* This is where to keep a copy of old values hanging around waiting for an undo. */

static struct scalars {
	long maxpsz;			/* stream head default max packet size */
	long minpsz;			/* stream head default min packet size */
	ulong hiwat;			/* stream head default hi water mark */
	ulong lowat;			/* stream head default lo water mark */
	ulong cltime;			/* close wait time in msec */
	ulong rtime;			/* msec to wait to forward held msg */
	ulong ioctime;			/* msec to wait for ioctl() acknowledgement */
	ulong nstrpush;			/* max pushed modules */
	ulong strthresh;		/* memory limit */
	ulong strhold;			/* active stream hold feature */
	ulong strctlsz;			/* maximum stream control size */
	ulong strmsgsz;			/* maximum stream message size */
	ulong nstrmsgs;			/* maximum number of streams messages */
	ulong nband;			/* number of queue bands */
	ulong reuse_fmodsw;		/* reuse fmodsw entries (int for sysctl) */
	ulong max_apush;		/* max autopushed mods per str */
	ulong max_stramod;		/* max autopushed modules */
	ulong max_strdev;		/* max streams devices */
	ulong max_strmod;		/* max streams modules */
	ulong max_mblk;			/* max of headers on free list */
	ulong strmsgpriority;		/* observer message allocation priority (int for sysctl) */
} old, cur, new;

/* 
 * strMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid strMIB_variables_oid[] = { };

/* 
 * variable4 strMIB_variables:
 *   this variable defines function callbacks and type return information 
 *   for the strMIB mib section 
 */

struct variable7 strMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define STRCLTIME		1
	{STRCLTIME, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 1}},
#define STRMAXAPUSH		2
	{STRMAXAPUSH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 2}},
#define STRMAXMBLK		3
	{STRMAXMBLK, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 3}},
#define STRMAXSTRAMOD		4
	{STRMAXSTRAMOD, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 4}},
#define STRMAXSTRDEV		5
	{STRMAXSTRDEV, ASN_UNSIGNED, RONLY, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 5}},
#define STRMAXSTRMOD		6
	{STRMAXSTRMOD, ASN_UNSIGNED, RONLY, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 6}},
#define STRMSGPRIORITY		7
	{STRMSGPRIORITY, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 7}},
#define STRNBAND		8
	{STRNBAND, ASN_UNSIGNED, RONLY, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 8}},
#define STRNSTRMSGS		9
	{STRNSTRMSGS, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 9}},
#define STRNSTRPUSH		10
	{STRNSTRPUSH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 10}},
#define STRHIWAT		11
	{STRHIWAT, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 11}},
#define STRLOWAT		12
	{STRLOWAT, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 12}},
#define STRMAXPSZ		13
	{STRMAXPSZ, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 13}},
#define STRMINPSZ		14
	{STRMINPSZ, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 14}},
#define STRREUSEFMODSW		15
	{STRREUSEFMODSW, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 15}},
#define STRRTIME		16
	{STRRTIME, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 16}},
#define STRSTRHOLD		17
	{STRSTRHOLD, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 17}},
#define STRSTRCTLSZ		18
	{STRSTRCTLSZ, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 18}},
#define STRSTRMSGSZ		19
	{STRSTRMSGSZ, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 19}},
#define STRSTRTHRESH		20
	{STRSTRTHRESH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 20}},
#define STRLOWTHRESH		21
	{STRLOWTHRESH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 21}},
#define STRMEDTHRESH		22
	{STRMEDTHRESH, ASN_UNSIGNED, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 22}},
#define STRIOCTIME		23
	{STRIOCTIME, ASN_INTEGER, RWRITE, var_strMIB, 15,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 2, 1, 23}},

#define STRMODIDNUM		24
	{STRMODIDNUM, ASN_UNSIGNED, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 1}},
#define STRMODNAME		25
	{STRMODNAME, ASN_OCTET_STR, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 2}},
#define STRMODTYPE		26
	{STRMODTYPE, ASN_INTEGER, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 3}},
#define STRMODMAJOR		27
	{STRMODMAJOR, ASN_UNSIGNED, RONLY, var_strModTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 1, 1, 1, 4}},
#define STRMODINFOINDEX		28
	{STRMODINFOINDEX, ASN_UNSIGNED, RONLY, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 1}},
#define STRMODINFOQUEUES		29
	{STRMODINFOQUEUES, ASN_OCTET_STR, RONLY, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 2}},
#define STRMODINFOMINPSZ		30
	{STRMODINFOMINPSZ, ASN_INTEGER, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 3}},
#define STRMODINFOMAXPSZ		31
	{STRMODINFOMAXPSZ, ASN_INTEGER, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 4}},
#define STRMODINFOHIWAT		32
	{STRMODINFOHIWAT, ASN_UNSIGNED, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 5}},
#define STRMODINFOLOWAT		33
	{STRMODINFOLOWAT, ASN_UNSIGNED, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 6}},
#define STRMODINFOTRACELEVEL		34
	{STRMODINFOTRACELEVEL, ASN_UNSIGNED, RWRITE, var_strModInfoTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 2, 1, 1, 7}},
#define STRMODSTATINDEX		35
	{STRMODSTATINDEX, ASN_UNSIGNED, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 1}},
#define STRMODSTATQUEUES		36
	{STRMODSTATQUEUES, ASN_OCTET_STR, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 2}},
#define STRMODSTATPCNT		37
	{STRMODSTATPCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 3}},
#define STRMODSTATSCNT		38
	{STRMODSTATSCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 4}},
#define STRMODSTATOCNT		39
	{STRMODSTATOCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 5}},
#define STRMODSTATCCNT		40
	{STRMODSTATCCNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 6}},
#define STRMODSTATACNT		41
	{STRMODSTATACNT, ASN_COUNTER, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 7}},
#define STRMODSTATPRIVATE		42
	{STRMODSTATPRIVATE, ASN_OCTET_STR, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 8}},
#define STRMODSTATFLAGS		43
	{STRMODSTATFLAGS, ASN_UNSIGNED, RONLY, var_strModStatTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 3, 1, 1, 9}},
#define STRAPSHNAME		44
	{STRAPSHNAME, ASN_OCTET_STR, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 1}},
#define STRAPSHMAJOR		45
	{STRAPSHMAJOR, ASN_UNSIGNED, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 2}},
#define STRAPSHMINOR		46
	{STRAPSHMINOR, ASN_UNSIGNED, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 3}},
#define STRAPSHLASTMINOR		47
	{STRAPSHLASTMINOR, ASN_UNSIGNED, RONLY, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 4}},
#define STRAPSHMODULES		48
	{STRAPSHMODULES, ASN_OCTET_STR, RWRITE, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 5}},
#define STRAPSHSTATUS		49
	{STRAPSHSTATUS, ASN_INTEGER, RWRITE, var_strApshTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 4, 1, 1, 6}},
#define STRSTATSSTRUCTURE		50
	{STRSTATSSTRUCTURE, ASN_INTEGER, RONLY, var_strStatsTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 5, 1, 1, 1}},
#define STRSTATSCURRENTALLOCS		51
	{STRSTATSCURRENTALLOCS, ASN_GAUGE, RONLY, var_strStatsTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 5, 1, 1, 2}},
#define STRSTATSHIGHWATERMARK		52
	{STRSTATSHIGHWATERMARK, ASN_GAUGE, RONLY, var_strStatsTable, 17,
	 {, 3, 6, 1, 4, 1, 29591, 1, 1, 1, 1, 1, 5, 1, 1, 3}},
};

/*    (L = length of the oidsuffix) */

/** Initializes the strMIB module */
void
init_strMIB(void)
{

	DEBUGMSGTL(("strMIB", "Initializing\n"));

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("strMIB", strMIB_variables, variable4, strMIB_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_strMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_strMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len,
	   WriteMethod **write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	ulong time;
	int value;
	int cvec[] = { CTL_STREAMS, 0 };
	int clen = 2;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRCLTIME:
		cvec[1] = STREAMS_CLTIME;
		*write_method = write_strCltime;
		if (!sysctl(cvec, clen, &time, sizeof(time), NULL, 0)) {
			/* convert milliseconds to centiseconds */
			cur.cltime = (time + 9) / 10;
			return ((u_char *) &cur.cltime);
		}
		break;
	case STRMAXAPUSH:
		cvec[1] = STREAMS_MAX_APUSH;
		*write_method = write_strMaxApush;
		if (!sysctl(cvec, clen, &cur.max_apush, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.max_apush);
		break;
	case STRMAXMBLK:
		cvec[1] = STREAMS_MAX_MBLK;
		*write_method = write_strMaxMblk;
		if (!sysctl(cvec, clen, &cur.max_mblk, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.max_mblk);
		break;
	case STRMAXSTRAMOD:
		cvec[1] = STREAMS_MAX_STRAMOD;
		*write_method = write_strMaxStramod;
		if (!sysctl(cvec, clen, &cur.max_stramod, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.max_stramod);
		break;
	case STRMAXSTRDEV:
		cvec[1] = STREAMS_MAX_STRDEV;
		if (!sysctl(cvec, clen, &cur.max_strdev, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.max_strdev);
		break;
	case STRMAXSTRMOD:
		cvec[1] = STREAMS_MAX_STRMOD;
		if (!sysctl(cvec, clen, &cur.max_strmod, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.max_strmod);
		break;
	case STRMSGPRIORITY:
		cvec[1] = STREAMS_MSG_PRIORITY;
		*write_method = write_strMsgPriority;
		if (!sysctl(cvec, clen, &cur.msg_priority, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.msg_priority);
		break;
	case STRNBAND:
		cvec[1] = STREAMS_NBAND;
		if (!sysctl(cvec, clen, &cur.nband, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.nband);
		break;
	case STRNSTRMSGS:
		cvec[1] = STREAMS_NSTRMSGS;
		*write_method = write_strNstrmsgs;
		if (!sysctl(cvec, clen, &cur.nstrmsgs, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.nstrmsgs);
		break;
	case STRNSTRPUSH:
		cvec[1] = STREAMS_NSTRPUSH;
		*write_method = write_strNstrpush;
		if (!sysctl(cvec, clen, &cur.nstrpush, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.nstrpush);
		break;
	case STRHIWAT:
		cvec[1] = STREAMS_HIWAT;
		*write_method = write_strHiwat;
		if (!sysctl(cvec, clen, &cur.hiwat, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.hiwat);
		break;
	case STRLOWAT:
		cvec[1] = STREAMS_LOWAT;
		*write_method = write_strLowat;
		if (!sysctl(cvec, clen, &cur.lowat, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.lowat);
		break;
	case STRMAXPSZ:
		cvec[1] = STREAMS_MAXPSZ;
		*write_method = write_strMaxpsz;
		if (!sysctl(cvec, clen, &cur.maxpsz, sizeof(long), NULL, 0))
			return ((u_char *) &cur.maxpsz);
		break;
	case STRMINPSZ:
		cvec[1] = STREAMS_MINPSZ;
		*write_method = write_strMinpsz;
		if (!sysctl(cvec, clen, &cur.minpsz, sizeof(long), NULL, 0))
			return ((u_char *) &cur.minpsz);
		break;
	case STRREUSEFMODSW:
		cvec[1] = STREAMS_REUSE_FMODSW;
		*write_method = write_strReuseFmodsw;
		if (!sysctl(cvec, clen, &value, sizeof(value), NULL, 0)) {
			&cur.reuse_fmodsw = (value ? TV_TRUE : TV_FALSE);
			return ((u_char *) &cur.reuse_fmodsw);
		}
		break;
	case STRRTIME:
		cvec[1] = STREAMS_RTIME;
		*write_method = write_strRtime;
		if (!sysctl(cvec, clen, &time, sizeof(time), NULL, 0)) {
			/* convert milliseconds to centiseconds */
			cur.rtime = (time + 9) / 10;
			return ((u_char *) &cur.rtime);
		}
		break;
	case STRSTRHOLD:
		cvec[1] = STREAMS_STRHOLD;
		*write_method = write_strStrhold;
		if (!sysctl(cvec, clen, &value, sizeof(value), NULL, 0)) {
			cur.strhold = (value ? TV_TRUE : TV_FALSE);
			return ((u_char *) &cur.strhold);
		}
		break;
	case STRSTRCTLSZ:
		cvec[1] = STREAMS_STRCTLSZ;
		*write_method = write_strStrctlsz;
		if (!sysctl(cvec, clen, &cur.strctlsz, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.strctlsz);
		break;
	case STRSTRMSGSZ:
		cvec[1] = STREAMS_STRMSGSZ;
		*write_method = write_strStrmsgsz;
		if (!sysctl(cvec, clen, &cur.strmsgsz, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.strmsgsz);
		break;
	case STRSTRTHRESH:
		cvec[1] = STREAMS_STRTHRESH;
		*write_method = write_strStrthresh;
		if (!sysctl(cvec, clen, &cur.strthresh, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.strthresh);
		break;
	case STRLOWTHRESH:
		/* Linux Fast-STREAMS does notimplement thresholds. */
		cvec[1] = STREAMS_STRTHRESH;
		if (!sysctl(cvec, clen, &cur.strthresh, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.strthresh);
		break;
	case STRMEDTHRESH:
		/* Linux Fast-STREAMS does notimplement thresholds. */
		cvec[1] = STREAMS_STRTHRESH;
		if (!sysctl(cvec, clen, &cur.strthresh, sizeof(ulong), NULL, 0))
			return ((u_char *) &cur.strthresh);
		break;
	case STRIOCTIME:
		cvec[1] = STREAMS_IOCTIME;
		*write_method = write_strIoctime;
		if (!sysctl(cvec, clen, &time, sizeof(time), NULL, 0)) {
			/* convert milliseconds to centiseconds */
			cur.ioctime = (time + 9) / 10;
			return ((u_char *) &cur.ioctime);
		}
		break;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strModTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len,
		WriteMethod **write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
#define TABLE_SIZE (1<<16)
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;
#undef TABLE_SIZE

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRMODIDNUM:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODNAME:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODTYPE:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODMAJOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strModInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModInfoTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len,
		    WriteMethod **write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRMODINFOINDEX:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOQUEUES:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOMINPSZ:
		*write_method = write_strModInfoMinpsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOMAXPSZ:
		*write_method = write_strModInfoMaxpsz;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOHIWAT:
		*write_method = write_strModInfoHiwat;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOLOWAT:
		*write_method = write_strModInfoLowat;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODINFOTRACELEVEL:
		*write_method = write_strModInfoTraceLevel;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strModStatTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strModStatTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len,
		    WriteMethod **write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRMODSTATINDEX:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATQUEUES:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATPCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATSCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATOCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATCCNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATACNT:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATPRIVATE:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRMODSTATFLAGS:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
var_strApshTable_validate(struct variable *vp, oid *name, size_t *length, int exact,
			  size_t *var_len, WriteMethod **write_method)
{
	oid newname[MAX_OID_LEN];
	int cmp;

	/* get a copy of our oid */
	memcpy((char *)newname, (char *)vp->name, (int)vp->namelen * sizeof(oid[0]));
	newname[vp->namelen] = 0;

	/* compare it with the oid in the request (+1 because of extra instance subidentifier) */
	cmp = snmp_oid_compare(name, *length, (int)vp->namelen + 1);
	/* when an exact match is required, it is required; when an exact match is not required, we
	 * must be lexically to the right (get-next) of the requested OID. */
	if ((exact && (cmp != 0)) || (!exact && (result >= 0)))
		return  (MATCH_FAILED);

	memcpy((char *)name, (char *)newname, ((int) vp->namelen + 1) & sizeof(oid[0]));
	*length = vp->namelen + 1;
	*write_method = (WriteMethod *)0;
	*var_len = sizeof(long);
	return (MATCH_SUCCEEDED);
}

/*
 * var_strApshTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strApshTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len,
		 WriteMethod **write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRAPSHNAME:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHMAJOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHMINOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHLASTMINOR:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHMODULES:
		*write_method = write_strApshModules;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRAPSHSTATUS:
		*write_method = write_strApshStatus;
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_strStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_strMIB above.
 */
unsigned char *
var_strStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len,
		  WriteMethod **write_method)
{
	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *  See the implementation documentation for the meaning of this.
	 *  You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *  you will need to provide the replacement code yourself.
	 *  Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {
	case STRSTATSSTRUCTURE:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTATSCURRENTALLOCS:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	case STRSTATSHIGHWATERMARK:
		VAR = VALUE;	/* XXX */
		return (u_char *) &VAR;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

#define MAXTIME ((1<<28))	/* about 3 days in milliseconds */

int
write_strCltime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
		oid *name, size_t name_len)
{
	int cvec[] = { CTRL_STREAMS, STREAMS_CLTIME };
	int clen = 2;
	ulong oldtime, newtime;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: write: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: write: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (0 >= *(long *) var_val || *(long *) var_val > MAXTIME) {
			fprintf(stderr, "%s:[RESERVE1]: write: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:
		/* commit file is opened on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.cltime = *(long *) var_val;
		break;
	case FREE:
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.cltime = cur.cltime;
		cur.cltime = new.cltime;
		newtime = new.cltime * 10;	/* convert centiseconds to milliseconds */
		if (sysctl(cvec, clen, &oldtime, sizeof(oldtime), &newtime, sizeof(newtime))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.cltime = (oldtime + 9) / 10;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldtime = old.cltime * 10;	/* convert centiseconds to milliseconds */
		if (sysctl(cvec, clen, NULL, 0, &oldtime, sizeof(oldtime)))
			return SNMP_ERR_UNDOFAILED;
		cur.cltime = old.cltime;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.cltime = %lu\n", (ulong) cur.cltime * 10) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxApush(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_MAX_APUSH };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* can be zero for all we care */
		break;

	case RESERVE2:
		/* commit file is opened on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.max_apush = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxMblk(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		 u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_MAX_APUSH };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMaxStramod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		    u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_MAX_STRAMOD };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVED1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVED1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Less than 8 is so unusable, that we had better protect the STREAMS subsystem
		   from erroneous writes beneath that value. */
		if (8 > *(u_long *) var_val) {
			fprintf(stderr, "%s:[RESERVED1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.max_stramod = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.max_stramod = cur.max_stramod;
		cur.max_stramod = new.max_stramod;
		if (sysctl
		    (cvec, clen, &old.max_stramod, sizeof(old.max_stramod), &cur.max_stramod,
		     sizeof(cur.max_stramod))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (sysctl(cvec, clen, NULL, 0, &old.max_stramod, sizeof(old.max_stramod)))
			return SNMP_ERR_UNDOFAILED;
		cur.max_stramod = old.max_stramod;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.max_stramod = %lu\n", cur.max_stramod) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMsgPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		     u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_MSG_PRIORITY };
	int clen = 2;
	int oldvalue, newvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (*(long *) var_val != TV_TRUE && *(long *) var_val != TV_FALSE) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.msg_priority = *(long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.msg_priority = cur.msg_priority;
		cur.msg_priority = new.msg_priority;
		newvalue = (new.msg_priority == TV_TRUE) ? 1 : 0;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.msg_priority = (oldvalue ? TV_TRUE : TV_FALSE);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (old.msg_priority == TV_TRUE) ? 1 : 0;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.msg_priority = old.msg_priority;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (cur.msg_priority == TV_TRUE) ? 1 : 0;
		if (fprintf(sysctl_file, "streams.msg_priority = %lu\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strNstrmsgs(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_NSTRMSGS };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVED1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVED1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* We had better place a lower limit on this to protect ourselves from erroneous
		   writes. */
		if (1024 > *(u_long *) var_val) {
			fprintf(stderr, "%s:[RESERVED1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.nstrmsgs = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.nstrmsgs = cur.nstrmsgs;
		cur.nstrmsgs = new.nstrmsgs;
		if (sysctl
		    (cvec, clen, &old.nstrmsgs, sizeof(old.nstrmsgs), &cur.nstrmsgs,
		     sizeof(cur.nstrmsgs))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (sysctl(cvec, clen, NULL, 0, &old.nstrmsgs, sizeof(old.nstrmsgs)))
			return SNMP_ERR_UNDOFAILED;
		cur.nstrmsgs = old.nstrmsgs;
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.nstrmsgs = %lu\n", cur.nstrmsgs) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strNstrpush(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_NSTRPUSH };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVED1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVED1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Less than 8 is so unusabled, that we had better protect the STREAMS subsystem
		   from erronous writes beneath that value. */
		if (8 > *(u_long *) var_val) {
			fprintf(stderr, "%s:[RESERVED1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.nstrpush = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.nstrpush = cur.nstrpush;
		cur.nstrpush = new.nstrpush;
		if (sysctl
		    (cvec, clen, &old.nstrpush, sizeof(old.nstrpush), &cur.nstrpush,
		     sizeof(cur.nstrpush))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (sysctl(cvec, clen, NULL, 0, &old.nstrpush, sizeof(old.nstrpush)))
			return SNMP_ERR_UNDOFAILED;
		cur.nstrpush = old.nstrpush;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.nstrpush = %lu\n", cur.nstrpush) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strHiwat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
	       oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_HIWAT };
	int clen = 2;
	size_t newvalue, oldvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVED1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVED1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.hiwat = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.hiwat = cur.hiwat;
		cur.hiwat = new.hiwat;
		newvalue = (size_t) new.hiwat;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.hiwat = (u_long) oldvalue;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (size_t) old.hiwat;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.hiwat = old.hiwat;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (size_t) cur.hiwat;
		if (fprintf(sysctl_file, "streams.hiwat = %zu\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strLowat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
	       oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_LOWAT };
	int clen = 2;
	size_t newvalue, oldvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.lowat = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.lowat = cur.lowat;
		cur.lowat = new.lowat;
		newvalue = (size_t) new.lowat;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.lowat = (u_long) oldvalue;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (size_t) old.lowat;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.lowat = old.lowat;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (size_t) cur.lowat;
		if (fprintf(sysctl_file, "streams.lowat = %zu\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

#define MEMEXTMAX   (1<<18)	/* maximum memory extent */
#define MEMEXTMIN   (1<<5)	/* minimum memory extent */

int
write_strMaxpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
		oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_MAXPSZ };
	int clen = 2;
	ssize_t oldvalue, newvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* max packet size cannot be less than the minimum allocatable memory extent or
		   larger than the maximum allocatable memory exten */
		if (MEMEXTMIN > *(long *) var_val || *(long *) var_val > MEMEXTMAX) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.maxpsz = *(long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.maxpsz = cur.maxpsz;
		cur.maxpsz = new.maxpsz;
		newvalue = (ssize_t) new.maxpsz;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.maxpsz = (long) oldvalue;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (ssize_t) old.maxpsz;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.maxpsz = old.maxpsz;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (ssize_t) cur.maxpsz;
		if (fprintf(sysctl_file, "streams.maxpsz = %zd\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strMinpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
		oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_MINPSZ };
	int clen = 2;
	ssize_t newvalue, oldvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (MEMEXTMIN > *(long *) var_val || *(long *) var_val > MEMEXTMAX) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.minpsz = *(long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.minpsz = cur.minpsz;
		cur.minpsz = new.minpsz;
		newvalue = (ssize_t) new.minpsz;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.minpsz = (long) oldvalue;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (ssize_t) old.minpsz;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.minpsz = old.minpsz;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (ssize_t) cur.minpsz;
		if (fprintf(sysctl_file, "streams.minpsz = %zd\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strReuseFmodsw(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		     u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_REUSE_FMODSW };
	int clen = 2;
	int oldvalue, newvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (*(long *) var_val != TV_TRUE && *(long *) var_val != TV_FALSE) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.reuse_fmodsw = *(long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.reuse_fmodsw = cur.reuse_fmodsw;
		cur.reuse_fmodsw = new.reuse_fmodsw;
		newvalue = (new.reuse_fmodsw == TV_TRUE) ? 1 : 0;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.reuse_fmodsw = (oldvalue ? TV_TRUE : TV_FALSE);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (old.reuse_fmodsw == TV_TRUE) ? 1 : 0;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.reuse_fmodsw = old.reuse_fmodsw;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (cur.reuse_fmodsw == TV_TRUE) ? 1 : 0;
		if (fprintf(sysctl_file, "streams.reuse_fmodsw = %lu\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strRtime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP,
	       oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_RTIME };
	int clen = 2;
	ulong oldtime, newtime;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (0 >= *(long *) var_val || *(long *) var_val > MAXTIME) {
			fprintf(stderr, "%s:[RESERVE1]: write: outside range\n", __FUNCTION__);
			return SNMP_ERRR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* commit file is opened on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.rtime = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.rtime = cur.rtime;
		cur.rtime = new.rtime;
		newtime = new.rtime * 10;	/* convert centiseconds to milliseconds */
		if (sysctl(cvec, clen, &oldtime, sizeof(oldtime), &newtime, sizeof(newtime))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.rtime = (oldtime + 9) / 10;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldtime = old.rtime * 10;	/* convert centiseconds to milliseconds */
		if (sysctl(cvec, clen, NULL, 0, &oldtime, sizeof(oldtime)))
			return SNMP_ERR_UNDOFAILED;
		cur.rtime = old.rtime;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.rtime = %lu\n", (ulong) cur.rtime * 10) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrhold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		 u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_STRHOLD };
	int clen = 2;
	int oldvalue, newvalue;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (*(long *) var_val != TV_TRUE && *(long *) var_val != TV_FALSE) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.strhold = *(long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.strhold = cur.strhold;
		cur.strhold = new.strhold;
		newvalue = (new.strhold == TV_TRUE) ? 1 : 0;
		if (sysctl(cvec, clen, &oldvalue, sizeof(oldvalue), &newvalue, sizeof(newvalue))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.strhold = (oldvalue ? TV_TRUE : TV_FALSE);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldvalue = (old.strhold == TV_TRUE) ? 1 : 0;
		if (sysctl(cvec, clen, NULL, 0, &oldvalue, sizeof(oldvalue)))
			return SNMP_ERR_UNDOFAILED;
		cur.strhold = old.strhold;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		newvalue = (cur.strhold == TV_TRUE) ? 1 : 0;
		if (fprintf(sysctl_file, "streams.strhold = %lu\n", newvalue) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrctlsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_STRCTLSZ };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* max packet size cannot be less than the minimum allocatable memory extent or
		   larger than the maximum allocatable memory exten */
		if (MEMEXTMIN > *(u_long *) var_val || *(u_long *) var_val > MEMEXTMAX) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.strctlsz = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.strctlsz = cur.strctlsz;
		cur.strctlsz = new.strctlsz;
		if (sysctl
		    (cvec, clen, &old.strctlsz, sizeof(old.strctlsz), &new.strctlsz,
		     sizeof(new.strctlsz))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (sysctl(cvec, clen, NULL, 0, &old.strctlsz, sizeof(old.strctlsz)))
			return SNMP_ERR_UNDOFAILED;
		cur.strctlsz = old.strctlsz;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.strctlsz = %lu\n", cur.strctlsz) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrmsgsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_STRMSGSZ };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVE1]: not ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		/* max packet size cannot be less than the minimum allocatable memory extent or
		   larger than the maximum allocatable memory exten */
		if (MEMEXTMIN > *(u_long *) var_val || *(u_long *) var_val > MEMEXTMAX) {
			fprintf(stderr, "%s:[RESERVE1]: out of range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.strmsgsz = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.strmsgsz = cur.strmsgsz;
		cur.strmsgsz = new.strmsgsz;
		if (sysctl
		    (cvec, clen, &old.strmsgsz, sizeof(old.strmsgsz), &new.strmsgsz,
		     sizeof(new.strmsgsz))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (sysctl(cvec, clen, NULL, 0, &old.strmsgsz, sizeof(old.strmsgsz)))
			return SNMP_ERR_UNDOFAILED;
		cur.strmsgsz = old.strmsgsz;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.strmsgsz = %lu\n", cur.strmsgsstrmsgsz) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strStrthresh(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_STRTHRESH };
	int clen = 2;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "%s:[RESERVE1]: ASN_UNSIGNED\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "%s:[RESERVE1]: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (*(u_long *) var_val == 0) {
			fprintf(stderr, "%s:[RESERVE1]: range\n", __FUNCTION__);
			return SNMP_ERR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* open commit file on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.strthresh = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.strthresh = cur.strthresh;
		cur.strthresh = new.strthresh;
		if (sysctl
		    (cvec, clen, &old.strthresh, sizeof(old.strthresh), &cur.strthresh,
		     sizeof(cur.strthresh))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:	/* doesn't exist now */
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:	/* read or write permission denied */
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:	/* invalid value */
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (sysctl(cvec, clen, NULL, 0, &old.strthresh, sizeof(old.strthresh)))
			return SNMP_ERR_UNDOFAILED;
		cur.strthresh = old.strthresh;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.strthresh = %lu\n", cur.strthresh) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strIoctime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		 u_char *statP, oid *name, size_t name_len)
{
	int cvec[] = { CTL_STREAMS, STREAMS_IOCTIME };
	int clen = 2;
	ulong oldtime, newtime;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "%s:[RESERVE1]: write not ASN_INTEGER\n", __FUNCTION__);
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "%s:[RESERVE1]: write: bad length\n", __FUNCTION__);
			return SNMP_ERR_WRONGLENGTH;
		}
		if (0 >= *(long *) var_val || *(long *) var_val > MAXTIME) {
			fprintf(stderr, "%s:[RESERVE1]: write: outside range\n", __FUNCTION__);
			return SNMP_ERRR_WRONGVALUE;
		}
		break;

	case RESERVE2:
		/* commit file is opened on demand */
		if (sysctl_file == NULL && (sysctl_file = fopen(sysctl_fname, "a")) == NULL) {
			fprintf(stderr, "%s:[RESERVE2]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		}
		new.ioctime = *(u_long *) var_val;
		break;

	case FREE:
		/* Release any resources that have been allocated */
		/* commit file closed at end of request */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		old.ioctime = cur.ioctime;
		cur.ioctime = new.ioctime;
		newtime = new.ioctime * 10;	/* convert centiseconds to milliseconds */
		if (sysctl(cvec, clen, &oldtime, sizeof(oldtime), &newtime, sizeof(newtime))) {
			int err = errno;

			fprintf(stderr, "%s:[ACTION]: %s\n", __FUNCTION__, strerror(err));
			switch (err) {
			case ENOTDIR:
				return SNMP_ERR_NOSUCHNAME;
			case EPERM:
				return SNMP_ERR_NOTWRITABLE;
			case EINVAL:
				return SNMP_ERR_WRONGVALUE;
			case EFAULT:
			default:
				break;
			}
			return SNMP_ERR_GENERR;
		}
		old.ioctime = (oldtime + 9) / 10;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		oldtime = old.ioctime * 10;	/* convert centiseconds to milliseconds */
		if (sysctl(cvec, clen, NULL, 0, &oldtime, sizeof(oldtime)))
			return SNMP_ERR_UNDOFAILED;
		cur.ioctime = old.ioctime;
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		if (sysctl_file == NULL)
			return SNMP_ERR_COMMITFAILED;
		if (fprintf(sysctl_file, "streams.ioctime = %lu\n", (ulong) cur.ioctime * 10) == -1) {
			fprintf(stderr, "%s:[COMMIT]: %s\n", __FUNCTION__, strerror(errno));
			return SNMP_ERR_COMMITFAILED;
		}
		/* commit file closed at end of request */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoMinpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid *name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoMaxpsz(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid *name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoHiwat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		      u_char *statP, oid *name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoLowat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		      u_char *statP, oid *name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strModInfoTraceLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			   u_char *statP, oid *name, size_t name_len)
{
	u_long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to strMIB not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(u_long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strApshModules(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		     u_char *statP, oid *name, size_t name_len)
{
	char value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to strMIB not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(char)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(char *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_strApshStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		    u_char *statP, oid *name, size_t name_len)
{
	long value;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to strMIB not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			fprintf(stderr, "write to strMIB: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		value = *(long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* 
		 * The variable has been stored in 'value' for you to use,
		 * and you have just been asked to do something with it.
		 * Note that anything done here must be reversable in the UNDO case
		 */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* 
		 * Things are working well, so it's now safe to make the change
		 * permanently.  Make sure that anything done here can't fail!
		 */
		break;
	}
	return SNMP_ERR_NOERROR;
}
