/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-data-access.m2c,v $
 *
 * $Id:$
 */
#ifndef STRMIB_DATA_ACCESS_H
#define STRMIB_DATA_ACCESS_H

#ifdef __cplusplus
extern "C" {
#endif

/* *********************************************************************
 * function declarations
 */

/* *********************************************************************
 * Table declarations
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModTable is subid 1 of strMod.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1, length: 14
*/

        int strModTable_init_data(strModTable_registration * strModTable_reg);

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
/* *********************************************************************
 * Since we have no idea how you really access your data, we'll go with
 * a worst case example: a flat text file.
 */
#define MAX_LINE_SIZE 256
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

/**
 * loop context
 *
 * TODO:
 * define loop context structure
 *
 *  Since the actual loop is in the MFD handler, a loop contex parameter
 *  is provided to help you keep track of where you are in between calls
 *  to functions that you wrote and the master MFD handler calls. The
 *  structure of this context is user defineable, and is defined in the
 *  file strModTable_data_access.h.
 *
 *  E.G., if your data is stored in a linked list, the obvious thing you
 *  want to know from one function call to the next is your current
 *  position in the linked list.  Thus the easiest context to use is a
 *  pointer within the linked list.  For an array, the current index to
 *  that array would be easiest.
 *
 *  The funtion calls are actually passed a reference to the loop
 *  context, to allow the loop context to be allocated memory. Here are
 *  some simple examples definitions for various data formats. These
 *  definitions are used in examples later on.
 *
 */
        typedef struct strModTable_loop_context_s {
                /*
                 * temporary context used during iteration
                 */
                strModTable_rowreq_ctx *rowreq_ctx;

                /*
                 * this example code is based on a data source that is a
                 * text file to be read and parsed.
                 */
                FILE *filep;
                char line[MAX_LINE_SIZE];
        } strModTable_loop_context;

/*
 * define a reference to the loop context
 *
 * NOTE: DO NOT ADD ITEMS TO THIS STRUCTURE!
 */
        typedef struct strModTable_ref_loop_ctx_s {
                strModTable_loop_context *loop_ctx;
        } strModTable_ref_loop_ctx;

        int strModTable_loop_get_first(strModTable_registration * strModTable_reg,
                                       strModTable_ref_loop_ctx * loop_ctx_ref,
                                       strModTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModTable_loop_get_next(strModTable_registration * strModTable_reg,
                                      strModTable_ref_loop_ctx * loop_ctx_ref,
                                      strModTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModTable_loop_get_data(strModTable_registration * strModTable_reg,
                                      strModTable_ref_loop_ctx * loop_ctx_ref,
                                      strModTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModTable_loop_save_position(strModTable_registration * strModTable_reg,
                                           strModTable_ref_loop_ctx * loop_ctx_ref,
                                           strModTable_ref_loop_ctx * save_loop_ctx_ref, int reuse);
        int strModTable_loop_cleanup_context(strModTable_registration * strModTable_reg,
                                             strModTable_ref_loop_ctx * ref);

        int strModTable_row_prep(strModTable_rowreq_ctx * rowreq_ctx);

/**********************************************************************
 **********************************************************************
 ***
 *** Table strModInfoTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModInfoTable is subid 1 of strModInfo.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1, length: 14
*/

        int strModInfoTable_init_data(strModInfoTable_registration * strModInfoTable_reg);

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
/* *********************************************************************
 * Since we have no idea how you really access your data, we'll go with
 * a worst case example: a flat text file.
 */
#define MAX_LINE_SIZE 256
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

/**
 * loop context
 *
 * TODO:
 * define loop context structure
 *
 *  Since the actual loop is in the MFD handler, a loop contex parameter
 *  is provided to help you keep track of where you are in between calls
 *  to functions that you wrote and the master MFD handler calls. The
 *  structure of this context is user defineable, and is defined in the
 *  file strModInfoTable_data_access.h.
 *
 *  E.G., if your data is stored in a linked list, the obvious thing you
 *  want to know from one function call to the next is your current
 *  position in the linked list.  Thus the easiest context to use is a
 *  pointer within the linked list.  For an array, the current index to
 *  that array would be easiest.
 *
 *  The funtion calls are actually passed a reference to the loop
 *  context, to allow the loop context to be allocated memory. Here are
 *  some simple examples definitions for various data formats. These
 *  definitions are used in examples later on.
 *
 */
        typedef struct strModInfoTable_loop_context_s {
                /*
                 * temporary context used during iteration
                 */
                strModInfoTable_rowreq_ctx *rowreq_ctx;

                /*
                 * this example code is based on a data source that is a
                 * text file to be read and parsed.
                 */
                FILE *filep;
                char line[MAX_LINE_SIZE];
        } strModInfoTable_loop_context;

/*
 * define a reference to the loop context
 *
 * NOTE: DO NOT ADD ITEMS TO THIS STRUCTURE!
 */
        typedef struct strModInfoTable_ref_loop_ctx_s {
                strModInfoTable_loop_context *loop_ctx;
        } strModInfoTable_ref_loop_ctx;

        int strModInfoTable_loop_get_first(strModInfoTable_registration * strModInfoTable_reg,
                                           strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                                           strModInfoTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModInfoTable_loop_get_next(strModInfoTable_registration * strModInfoTable_reg,
                                          strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                                          strModInfoTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModInfoTable_loop_get_data(strModInfoTable_registration * strModInfoTable_reg,
                                          strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                                          strModInfoTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModInfoTable_loop_save_position(strModInfoTable_registration * strModInfoTable_reg,
                                               strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                                               strModInfoTable_ref_loop_ctx * save_loop_ctx_ref,
                                               int reuse);
        int strModInfoTable_loop_cleanup_context(strModInfoTable_registration * strModInfoTable_reg,
                                                 strModInfoTable_ref_loop_ctx * ref);

        int strModInfoTable_row_prep(strModInfoTable_rowreq_ctx * rowreq_ctx);

        int strModInfoTable_validate_index(strModInfoTable_registration * strModInfoTable_reg,
                                           strModInfoTable_rowreq_ctx * rowreq_ctx);
        int strModInfoTable_strModIdnum_check_index(strModInfoTable_rowreq_ctx * rowreq_ctx);   /* external */
        int strModInfoIndex_check_index(strModInfoTable_rowreq_ctx * rowreq_ctx);       /* internal */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModStatTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModStatTable is subid 1 of strModStat.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1, length: 14
*/

        int strModStatTable_init_data(strModStatTable_registration * strModStatTable_reg);

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
/* *********************************************************************
 * Since we have no idea how you really access your data, we'll go with
 * a worst case example: a flat text file.
 */
#define MAX_LINE_SIZE 256
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

/**
 * loop context
 *
 * TODO:
 * define loop context structure
 *
 *  Since the actual loop is in the MFD handler, a loop contex parameter
 *  is provided to help you keep track of where you are in between calls
 *  to functions that you wrote and the master MFD handler calls. The
 *  structure of this context is user defineable, and is defined in the
 *  file strModStatTable_data_access.h.
 *
 *  E.G., if your data is stored in a linked list, the obvious thing you
 *  want to know from one function call to the next is your current
 *  position in the linked list.  Thus the easiest context to use is a
 *  pointer within the linked list.  For an array, the current index to
 *  that array would be easiest.
 *
 *  The funtion calls are actually passed a reference to the loop
 *  context, to allow the loop context to be allocated memory. Here are
 *  some simple examples definitions for various data formats. These
 *  definitions are used in examples later on.
 *
 */
        typedef struct strModStatTable_loop_context_s {
                /*
                 * temporary context used during iteration
                 */
                strModStatTable_rowreq_ctx *rowreq_ctx;

                /*
                 * this example code is based on a data source that is a
                 * text file to be read and parsed.
                 */
                FILE *filep;
                char line[MAX_LINE_SIZE];
        } strModStatTable_loop_context;

/*
 * define a reference to the loop context
 *
 * NOTE: DO NOT ADD ITEMS TO THIS STRUCTURE!
 */
        typedef struct strModStatTable_ref_loop_ctx_s {
                strModStatTable_loop_context *loop_ctx;
        } strModStatTable_ref_loop_ctx;

        int strModStatTable_loop_get_first(strModStatTable_registration * strModStatTable_reg,
                                           strModStatTable_ref_loop_ctx * loop_ctx_ref,
                                           strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModStatTable_loop_get_next(strModStatTable_registration * strModStatTable_reg,
                                          strModStatTable_ref_loop_ctx * loop_ctx_ref,
                                          strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModStatTable_loop_get_data(strModStatTable_registration * strModStatTable_reg,
                                          strModStatTable_ref_loop_ctx * loop_ctx_ref,
                                          strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strModStatTable_loop_save_position(strModStatTable_registration * strModStatTable_reg,
                                               strModStatTable_ref_loop_ctx * loop_ctx_ref,
                                               strModStatTable_ref_loop_ctx * save_loop_ctx_ref,
                                               int reuse);
        int strModStatTable_loop_cleanup_context(strModStatTable_registration * strModStatTable_reg,
                                                 strModStatTable_ref_loop_ctx * ref);

        int strModStatTable_row_prep(strModStatTable_rowreq_ctx * rowreq_ctx);

/**********************************************************************
 **********************************************************************
 ***
 *** Table strApshTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strApshTable is subid 1 of strApsh.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1, length: 14
*/

        int strApshTable_init_data(strApshTable_registration * strApshTable_reg);

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
/* *********************************************************************
 * Since we have no idea how you really access your data, we'll go with
 * a worst case example: a flat text file.
 */
#define MAX_LINE_SIZE 256
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

/**
 * loop context
 *
 * TODO:
 * define loop context structure
 *
 *  Since the actual loop is in the MFD handler, a loop contex parameter
 *  is provided to help you keep track of where you are in between calls
 *  to functions that you wrote and the master MFD handler calls. The
 *  structure of this context is user defineable, and is defined in the
 *  file strApshTable_data_access.h.
 *
 *  E.G., if your data is stored in a linked list, the obvious thing you
 *  want to know from one function call to the next is your current
 *  position in the linked list.  Thus the easiest context to use is a
 *  pointer within the linked list.  For an array, the current index to
 *  that array would be easiest.
 *
 *  The funtion calls are actually passed a reference to the loop
 *  context, to allow the loop context to be allocated memory. Here are
 *  some simple examples definitions for various data formats. These
 *  definitions are used in examples later on.
 *
 */
        typedef struct strApshTable_loop_context_s {
                /*
                 * temporary context used during iteration
                 */
                strApshTable_rowreq_ctx *rowreq_ctx;

                /*
                 * this example code is based on a data source that is a
                 * text file to be read and parsed.
                 */
                FILE *filep;
                char line[MAX_LINE_SIZE];
        } strApshTable_loop_context;

/*
 * define a reference to the loop context
 *
 * NOTE: DO NOT ADD ITEMS TO THIS STRUCTURE!
 */
        typedef struct strApshTable_ref_loop_ctx_s {
                strApshTable_loop_context *loop_ctx;
        } strApshTable_ref_loop_ctx;

        int strApshTable_loop_get_first(strApshTable_registration * strApshTable_reg,
                                        strApshTable_ref_loop_ctx * loop_ctx_ref,
                                        strApshTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strApshTable_loop_get_next(strApshTable_registration * strApshTable_reg,
                                       strApshTable_ref_loop_ctx * loop_ctx_ref,
                                       strApshTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strApshTable_loop_get_data(strApshTable_registration * strApshTable_reg,
                                       strApshTable_ref_loop_ctx * loop_ctx_ref,
                                       strApshTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strApshTable_loop_save_position(strApshTable_registration * strApshTable_reg,
                                            strApshTable_ref_loop_ctx * loop_ctx_ref,
                                            strApshTable_ref_loop_ctx * save_loop_ctx_ref,
                                            int reuse);
        int strApshTable_loop_cleanup_context(strApshTable_registration * strApshTable_reg,
                                              strApshTable_ref_loop_ctx * ref);

        int strApshTable_row_prep(strApshTable_rowreq_ctx * rowreq_ctx);

        int strApshTable_validate_index(strApshTable_registration * strApshTable_reg,
                                        strApshTable_rowreq_ctx * rowreq_ctx);
        int strApshName_check_index(strApshTable_rowreq_ctx * rowreq_ctx);      /* internal */
        int strApshMinor_check_index(strApshTable_rowreq_ctx * rowreq_ctx);     /* internal */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strStatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strStatsTable is subid 1 of strStats.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.5.1, length: 14
*/

        int strStatsTable_init_data(strStatsTable_registration * strStatsTable_reg);

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
/* *********************************************************************
 * Since we have no idea how you really access your data, we'll go with
 * a worst case example: a flat text file.
 */
#define MAX_LINE_SIZE 256
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

/**
 * loop context
 *
 * TODO:
 * define loop context structure
 *
 *  Since the actual loop is in the MFD handler, a loop contex parameter
 *  is provided to help you keep track of where you are in between calls
 *  to functions that you wrote and the master MFD handler calls. The
 *  structure of this context is user defineable, and is defined in the
 *  file strStatsTable_data_access.h.
 *
 *  E.G., if your data is stored in a linked list, the obvious thing you
 *  want to know from one function call to the next is your current
 *  position in the linked list.  Thus the easiest context to use is a
 *  pointer within the linked list.  For an array, the current index to
 *  that array would be easiest.
 *
 *  The funtion calls are actually passed a reference to the loop
 *  context, to allow the loop context to be allocated memory. Here are
 *  some simple examples definitions for various data formats. These
 *  definitions are used in examples later on.
 *
 */
        typedef struct strStatsTable_loop_context_s {
                /*
                 * temporary context used during iteration
                 */
                strStatsTable_rowreq_ctx *rowreq_ctx;

                /*
                 * this example code is based on a data source that is a
                 * text file to be read and parsed.
                 */
                FILE *filep;
                char line[MAX_LINE_SIZE];
        } strStatsTable_loop_context;

/*
 * define a reference to the loop context
 *
 * NOTE: DO NOT ADD ITEMS TO THIS STRUCTURE!
 */
        typedef struct strStatsTable_ref_loop_ctx_s {
                strStatsTable_loop_context *loop_ctx;
        } strStatsTable_ref_loop_ctx;

        int strStatsTable_loop_get_first(strStatsTable_registration * strStatsTable_reg,
                                         strStatsTable_ref_loop_ctx * loop_ctx_ref,
                                         strStatsTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strStatsTable_loop_get_next(strStatsTable_registration * strStatsTable_reg,
                                        strStatsTable_ref_loop_ctx * loop_ctx_ref,
                                        strStatsTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strStatsTable_loop_get_data(strStatsTable_registration * strStatsTable_reg,
                                        strStatsTable_ref_loop_ctx * loop_ctx_ref,
                                        strStatsTable_ref_rowreq_ctx * rowreq_ctx_ref);
        int strStatsTable_loop_save_position(strStatsTable_registration * strStatsTable_reg,
                                             strStatsTable_ref_loop_ctx * loop_ctx_ref,
                                             strStatsTable_ref_loop_ctx * save_loop_ctx_ref,
                                             int reuse);
        int strStatsTable_loop_cleanup_context(strStatsTable_registration * strStatsTable_reg,
                                               strStatsTable_ref_loop_ctx * ref);

        int strStatsTable_row_prep(strStatsTable_rowreq_ctx * rowreq_ctx);

#ifdef __cplusplus
}
#endif
#endif                                  /* STRMIB_DATA_ACCESS_H */
