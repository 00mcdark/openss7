/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-data-access.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "strMIB.h"

#include "strMIB_data_access.h"

/** @defgroup data_access data_access: Routines to access data
 *
 * These routines are used to locate the data used to satisfy
 * requests.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModTable is subid 1 of strMod.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1, length: 14
*/

/**
 * initialization for strModTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param strModTable_reg
 *        Pointer to strModTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
strModTable_init_data(strModTable_registration * strModTable_reg)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_init_data", "called\n"));

        /*
         * TODO:303:o: Initialize strModTable data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * if you are the sole writer for the file, you could
         * open it here. However, as stated earlier, we are assuming
         * the worst case, which in this case means that the file is
         * written to by someone else, and might not even exist when
         * we start up. So we can't do anything here.
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModTable_init_data */

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    strModTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          strModTable_loop_save_position(loop,pos);
 *       strModTable_loop_get_next(loop,data)
 *    }
 *    strModTable_loop_get_data(pos,data)
 *    strModTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  strModTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  strModTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and its indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  strModTable_loop_init_context, save it in your
 *  strModTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  strModTable_loop_get_next, and simply call that function.]
 *
 * @param strModTable_reg Pointer to a strModTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
strModTable_loop_get_first(strModTable_registration * strModTable_reg,
                           strModTable_ref_loop_ctx * loop_ctx_ref,
                           strModTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_loop_get_first", "called\n"));

        netsnmp_assert(rowreq_ctx_ref);
        netsnmp_assert(loop_ctx_ref);

        /*
         * allocate memory for new structure
         */
        loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModTable_loop_context);
        if (NULL == loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * allocate a temporary context to use during iteration
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = strModTable_allocate_rowreq_ctx(NULL);
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                SNMP_FREE(loop_ctx_ref->loop_ctx);
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         * TODO:
         * set up loop context
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * open our data file.
         */
        loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
        if (NULL == loop_ctx_ref->loop_ctx->filep) {
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * in this example, after opening the file, get next does the same thing
         * as get first, we let's just call get next...
         */
        return strModTable_loop_get_next(strModTable_reg, loop_ctx_ref, rowreq_ctx_ref);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModTable_loop_get_first */

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in strModTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param strModTable_reg Pointer to a strModTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
strModTable_loop_get_next(strModTable_registration * strModTable_reg,
                          strModTable_ref_loop_ctx * loop_ctx_ref,
                          strModTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_loop_get_next", "called\n"));

        netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
        netsnmp_assert(rowreq_ctx_ref);

        /*
         * we just need the index for now. Reuse the one in the loop context's
         * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * get a line (skip blank lines)
         */
        do {
                if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                           loop_ctx_ref->loop_ctx->filep)) {
                        /* we're done */
                        fclose(loop_ctx_ref->loop_ctx->filep);
                        loop_ctx_ref->loop_ctx->filep = NULL;
                }
        } while (loop_ctx_ref->loop_ctx->filep && (loop_ctx_ref->loop_ctx->line[0] == '\n'));

        /*
         * check for end of data
         */
        if (NULL == loop_ctx_ref->loop_ctx->filep)
                return MFD_END_OF_DATA;

        /*
         * TODO:
         * set local vars for index from loop_ctx_ref->loop_ctx
         *  this can be done in one of two ways:
         */

        /*
         * 1) individually
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModIdnum
         */

        /*
         * OR
         */

        /*
         * 2) by calling strModTable_indexes_set()
         * strModTable_indexes_set(rowreq_ctx_ref->tbl_idx,
         *       strModIdnum
         *      );
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModTable_loop_get_next */

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param strModTable_reg Pointer to a strModTable_registration *
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModTable_loop_save_position(strModTable_registration * strModTable_reg,
                               strModTable_ref_loop_ctx * loop_ctx_ref,
                               strModTable_ref_loop_ctx * save_loop_ctx_ref, int reuse)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_loop_save_position", "called\n"));

        netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

        /*
         * TODO:
         * 1) allocate new loop context, unless you can reuse a previous pointer.
         * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
         */
        if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
                save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModTable_loop_context);
        if (NULL == save_loop_ctx_ref->loop_ctx) {
                snmp_log(LOG_ERR, "could not allocate memory\n");
                return MFD_ERROR;
        }

        /*
         * if you can reuse a previously saved contex, just swap
         * it out with the loop iterator
         */
        if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
                strModTable_rowreq_ctx *tmp_rowreq_ctx = save_loop_ctx_ref->loop_ctx->rowreq_ctx;

                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
                loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
        } else {
                /*
                 * take the current pointer
                 */
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

                /*
                 * allocate a new context to replace the one you just took.
                 */
                loop_ctx_ref->loop_ctx->rowreq_ctx = strModTable_allocate_rowreq_ctx(NULL);
                if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                        SNMP_FREE(loop_ctx_ref->loop_ctx);
                        return MFD_ERROR;
                }
        }

        /*
         * TRANSIENT data: copy all the data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModName
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModType
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModMajor
         *     from the loop context
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModTable_loop_save_position */

/**
 * set strModTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param strModTable_reg Pointer to a strModTable_registration *
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
strModTable_loop_get_data(strModTable_registration * strModTable_reg,
                          strModTable_ref_loop_ctx * loop_ctx_ref,
                          strModTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_loop_get_data", "called\n"));

        netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
        netsnmp_assert(NULL != rowreq_ctx_ref);
        netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

        /*
         * take temporary row request context from loop context
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

        /*
         * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
         * in loop_save_position, we saved line to do that
         */
        /*
         * strModName(2)/StreamsModuleName/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H
         */
    /** no mapping */
        /*
         * make sure there is enough space for strModName data
         */
        if ((NULL == rowreq_ctx_ref->rowreq_ctx->data.strModName) ||
            (rowreq_ctx_ref->rowreq_ctx->data.strModName_len <
             (loop_ctx_ref->loop_ctx->strModName_len *
              sizeof(loop_ctx_ref->loop_ctx->strModName[0])))) {
                snmp_log(LOG_ERR, "not enough space for value\n");
                return MFD_ERROR;
        }
        rowreq_ctx_ref->rowreq_ctx->data.strModName_len =
            loop_ctx_ref->loop_ctx->strModName_len * sizeof(loop_ctx_ref->loop_ctx->strModName[0]);
        memcpy(rowreq_ctx_ref->rowreq_ctx->data.strModName, loop_ctx_ref->loop_ctx->strModName,
               loop_ctx_ref->loop_ctx->strModName_len *
               sizeof(loop_ctx_ref->loop_ctx->strModName[0]));

        /*
         * strModType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModType = loop_ctx_ref->loop_ctx->strModType;

        /*
         * strModMajor(4)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/w/e/R/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModMajor = loop_ctx_ref->loop_ctx->strModMajor;

        return MFD_SUCCESS;
}                               /* strModTable_loop_get_data */

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param strModTable_reg Pointer to a strModTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModTable_loop_cleanup_context(strModTable_registration * strModTable_reg,
                                 strModTable_ref_loop_ctx * loop_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_loop_cleanup_context", "called\n"));

        netsnmp_assert(loop_ctx_ref);

        if (!loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * release the row request context, if it wasn't taken
         */
        if (loop_ctx_ref->loop_ctx->rowreq_ctx)
                strModTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

        /*
         * TODO:
         * release resources
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * close file
         */
        if (loop_ctx_ref->loop_ctx->filep)
                fclose(loop_ctx_ref->loop_ctx->filep);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         * free loop context
         */
        free(loop_ctx_ref->loop_ctx);

        return MFD_SUCCESS;
}                               /* strModTable_loop_cleanup_context */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
strModTable_row_prep(strModTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_row_prep", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:390:o: Prepare row for request.
         * If populating row data was delayed, this is the place to
         * fill in the row for this request.
         */

        return MFD_SUCCESS;
}                               /* strModTable_row_prep */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strModInfoTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModInfoTable is subid 1 of strModInfo.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1, length: 14
*/

/**
 * initialization for strModInfoTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param strModInfoTable_reg
 *        Pointer to strModInfoTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
strModInfoTable_init_data(strModInfoTable_registration * strModInfoTable_reg)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_init_data", "called\n"));

        /*
         * TODO:303:o: Initialize strModInfoTable data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * if you are the sole writer for the file, you could
         * open it here. However, as stated earlier, we are assuming
         * the worst case, which in this case means that the file is
         * written to by someone else, and might not even exist when
         * we start up. So we can't do anything here.
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModInfoTable_init_data */

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    strModInfoTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          strModInfoTable_loop_save_position(loop,pos);
 *       strModInfoTable_loop_get_next(loop,data)
 *    }
 *    strModInfoTable_loop_get_data(pos,data)
 *    strModInfoTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  strModInfoTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  strModInfoTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and its indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  strModInfoTable_loop_init_context, save it in your
 *  strModInfoTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  strModInfoTable_loop_get_next, and simply call that function.]
 *
 * @param strModInfoTable_reg Pointer to a strModInfoTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
strModInfoTable_loop_get_first(strModInfoTable_registration * strModInfoTable_reg,
                               strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                               strModInfoTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_loop_get_first", "called\n"));

        netsnmp_assert(rowreq_ctx_ref);
        netsnmp_assert(loop_ctx_ref);

        /*
         * allocate memory for new structure
         */
        loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModInfoTable_loop_context);
        if (NULL == loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * allocate a temporary context to use during iteration
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = strModInfoTable_allocate_rowreq_ctx(NULL);
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                SNMP_FREE(loop_ctx_ref->loop_ctx);
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         * TODO:
         * set up loop context
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * open our data file.
         */
        loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
        if (NULL == loop_ctx_ref->loop_ctx->filep) {
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * in this example, after opening the file, get next does the same thing
         * as get first, we let's just call get next...
         */
        return strModInfoTable_loop_get_next(strModInfoTable_reg, loop_ctx_ref, rowreq_ctx_ref);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModInfoTable_loop_get_first */

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in strModInfoTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param strModInfoTable_reg Pointer to a strModInfoTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
strModInfoTable_loop_get_next(strModInfoTable_registration * strModInfoTable_reg,
                              strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                              strModInfoTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_loop_get_next", "called\n"));

        netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
        netsnmp_assert(rowreq_ctx_ref);

        /*
         * we just need the index for now. Reuse the one in the loop context's
         * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * get a line (skip blank lines)
         */
        do {
                if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                           loop_ctx_ref->loop_ctx->filep)) {
                        /* we're done */
                        fclose(loop_ctx_ref->loop_ctx->filep);
                        loop_ctx_ref->loop_ctx->filep = NULL;
                }
        } while (loop_ctx_ref->loop_ctx->filep && (loop_ctx_ref->loop_ctx->line[0] == '\n'));

        /*
         * check for end of data
         */
        if (NULL == loop_ctx_ref->loop_ctx->filep)
                return MFD_END_OF_DATA;

        /*
         * TODO:
         * set local vars for index from loop_ctx_ref->loop_ctx
         *  this can be done in one of two ways:
         */

        /*
         * 1) individually
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModIdnum
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModInfoIndex
         */

        /*
         * OR
         */

        /*
         * 2) by calling strModInfoTable_indexes_set()
         * strModInfoTable_indexes_set(rowreq_ctx_ref->tbl_idx,
         *       strModIdnum
         *       strModInfoIndex
         *      );
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModInfoTable_loop_get_next */

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModInfoTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param strModInfoTable_reg Pointer to a strModInfoTable_registration *
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModInfoTable_loop_save_position(strModInfoTable_registration * strModInfoTable_reg,
                                   strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                                   strModInfoTable_ref_loop_ctx * save_loop_ctx_ref, int reuse)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_loop_save_position", "called\n"));

        netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

        /*
         * TODO:
         * 1) allocate new loop context, unless you can reuse a previous pointer.
         * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
         */
        if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
                save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModInfoTable_loop_context);
        if (NULL == save_loop_ctx_ref->loop_ctx) {
                snmp_log(LOG_ERR, "could not allocate memory\n");
                return MFD_ERROR;
        }

        /*
         * if you can reuse a previously saved contex, just swap
         * it out with the loop iterator
         */
        if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
                strModInfoTable_rowreq_ctx *tmp_rowreq_ctx =
                    save_loop_ctx_ref->loop_ctx->rowreq_ctx;
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
                loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
        } else {
                /*
                 * take the current pointer
                 */
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

                /*
                 * allocate a new context to replace the one you just took.
                 */
                loop_ctx_ref->loop_ctx->rowreq_ctx = strModInfoTable_allocate_rowreq_ctx(NULL);
                if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                        SNMP_FREE(loop_ctx_ref->loop_ctx);
                        return MFD_ERROR;
                }
        }

        /*
         * TRANSIENT data: copy all the data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModInfoQueues
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModInfoMinpsz
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModInfoMaxpsz
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModInfoHiwat
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModInfoLowat
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModInfoTraceLevel
         *     from the loop context
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModInfoTable_loop_save_position */

/**
 * set strModInfoTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModInfoTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param strModInfoTable_reg Pointer to a strModInfoTable_registration *
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
strModInfoTable_loop_get_data(strModInfoTable_registration * strModInfoTable_reg,
                              strModInfoTable_ref_loop_ctx * loop_ctx_ref,
                              strModInfoTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_loop_get_data", "called\n"));

        netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
        netsnmp_assert(NULL != rowreq_ctx_ref);
        netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

        /*
         * take temporary row request context from loop context
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

        /*
         * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
         * in loop_save_position, we saved line to do that
         */
        /*
         * strModInfoQueues(2)/StreamsModuleQueues/ASN_OCTET_STR/char(u_long)//L/A/w/E/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModInfoQueues =
            loop_ctx_ref->loop_ctx->strModInfoQueues;

        /*
         * strModInfoMinpsz(3)/INTEGER/ASN_INTEGER/long(long)//l/A/W/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModInfoMinpsz =
            loop_ctx_ref->loop_ctx->strModInfoMinpsz;

        /*
         * strModInfoMaxpsz(4)/INTEGER/ASN_INTEGER/long(long)//l/A/W/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModInfoMaxpsz =
            loop_ctx_ref->loop_ctx->strModInfoMaxpsz;

        /*
         * strModInfoHiwat(5)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/W/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModInfoHiwat = loop_ctx_ref->loop_ctx->strModInfoHiwat;

        /*
         * strModInfoLowat(6)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/W/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModInfoLowat = loop_ctx_ref->loop_ctx->strModInfoLowat;

        /*
         * strModInfoTraceLevel(7)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/W/e/R/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModInfoTraceLevel =
            loop_ctx_ref->loop_ctx->strModInfoTraceLevel;

        return MFD_SUCCESS;
}                               /* strModInfoTable_loop_get_data */

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param strModInfoTable_reg Pointer to a strModInfoTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModInfoTable_loop_cleanup_context(strModInfoTable_registration * strModInfoTable_reg,
                                     strModInfoTable_ref_loop_ctx * loop_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_loop_cleanup_context", "called\n"));

        netsnmp_assert(loop_ctx_ref);

        if (!loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * release the row request context, if it wasn't taken
         */
        if (loop_ctx_ref->loop_ctx->rowreq_ctx)
                strModInfoTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

        /*
         * TODO:
         * release resources
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * close file
         */
        if (loop_ctx_ref->loop_ctx->filep)
                fclose(loop_ctx_ref->loop_ctx->filep);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         * free loop context
         */
        free(loop_ctx_ref->loop_ctx);

        return MFD_SUCCESS;
}                               /* strModInfoTable_loop_cleanup_context */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
strModInfoTable_row_prep(strModInfoTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_row_prep", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:390:o: Prepare row for request.
         * If populating row data was delayed, this is the place to
         * fill in the row for this request.
         */

        return MFD_SUCCESS;
}                               /* strModInfoTable_row_prep */

/*
 * TODO:420:r: Implement strModInfoTable index validation.
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModIdnum
 * strModIdnum is subid 1 of strModEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.1
 * Description:
Indicates the driver or module STREAMS module id.  The 
		 STREAMS module id is unique within the entire system 
		 and is used as an index to this and other tables.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE strModIdnum IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of strModIdnum external index portion
 *
 * NOTE: this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       strModInfoTable_validate_index() function.
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_ERROR     : the incoming value is NOT legal
 */
int
strModInfoTable_strModIdnum_check_index(strModInfoTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_strModIdnum_check_index", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:424:M: |-> Check strModInfoTable external index strModIdnum.
         * check that index value in the table context (rowreq_ctx)
         * for the external index strModIdnum is legal.
         */

        return MFD_SUCCESS;     /*  external index strModIdnum ok */
}                               /* strModInfoTable_strModIdnum_check_index */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoIndex
 * strModInfoIndex is subid 1 of strModInfoEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.1
 * Description:
Provide an index for the STREAMS information entry.  
		 STREAMS module and non-multiplexing driver can have one 
		 or two entries.  STREAMS multiplexing drivers can have 
		 one to four entries.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 4;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE strModInfoIndex IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of strModInfoIndex index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_ERROR     : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       strModInfoTable_validate_index() function.
 *
 * @note Also keep in mind that if the index refers to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 * The following checks have already been done for you:
 *    The value is in (one of) the range set(s):  1 - 4
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 */
int
strModInfoIndex_check_index(strModInfoTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoIndex_check_index", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:426:M: |-> Check strModInfoTable index strModInfoIndex.
         * check that index value in the table context is legal.
         * (rowreq_ctx->tbl_index.strModInfoIndex)
         */

        return MFD_SUCCESS;     /* strModInfoIndex index ok */
}                               /* strModInfoIndex_check_index */

/**
 * verify specified index is valid.
 *
 * This check is independent of whether or not the values specified for
 * the columns of the new row are valid. Column values and row consistency
 * will be checked later. At this point, only the index values should be
 * checked.
 *
 * All of the individual index validation functions have been called, so this
 * is the place to make sure they are valid as a whole when combined. If
 * you only have one index, then you probably don't need to do anything else
 * here.
 * 
 * @note Keep in mind that if the indexes refer to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 *
 * @param strModInfoTable_reg
 *        Pointer to the user registration data
 * @param strModInfoTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS            : success
 * @retval MFD_CANNOT_CREATE_NOW  : index not valid right now
 * @retval MFD_CANNOT_CREATE_EVER : index never valid
 */
int
strModInfoTable_validate_index(strModInfoTable_registration * strModInfoTable_reg,
                               strModInfoTable_rowreq_ctx * rowreq_ctx)
{
        int rc = MFD_SUCCESS;

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_validate_index", "called\n"));

    /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:430:M: |-> Validate potential strModInfoTable index.
         */
        if (1) {
                snmp_log(LOG_WARNING, "invalid index for a new row in the "
                         "strModInfoTable table.\n");
                /*
                 * determine failure type.
                 *
                 * If the index could not ever be created, return MFD_NOT_EVER
                 * If the index can not be created under the present circumstances
                 * (even though it could be created under other circumstances),
                 * return MFD_NOT_NOW.
                 */
                if (0) {
                        return MFD_CANNOT_CREATE_EVER;
                } else {
                        return MFD_CANNOT_CREATE_NOW;
                }
        }

        return rc;
}                               /* strModInfoTable_validate_index */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strModStatTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModStatTable is subid 1 of strModStat.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1, length: 14
*/

/**
 * initialization for strModStatTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param strModStatTable_reg
 *        Pointer to strModStatTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
strModStatTable_init_data(strModStatTable_registration * strModStatTable_reg)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_init_data", "called\n"));

        /*
         * TODO:303:o: Initialize strModStatTable data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * if you are the sole writer for the file, you could
         * open it here. However, as stated earlier, we are assuming
         * the worst case, which in this case means that the file is
         * written to by someone else, and might not even exist when
         * we start up. So we can't do anything here.
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_init_data */

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    strModStatTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          strModStatTable_loop_save_position(loop,pos);
 *       strModStatTable_loop_get_next(loop,data)
 *    }
 *    strModStatTable_loop_get_data(pos,data)
 *    strModStatTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  strModStatTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  strModStatTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and its indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  strModStatTable_loop_init_context, save it in your
 *  strModStatTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  strModStatTable_loop_get_next, and simply call that function.]
 *
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
strModStatTable_loop_get_first(strModStatTable_registration * strModStatTable_reg,
                               strModStatTable_ref_loop_ctx * loop_ctx_ref,
                               strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_get_first", "called\n"));

        netsnmp_assert(rowreq_ctx_ref);
        netsnmp_assert(loop_ctx_ref);

        /*
         * allocate memory for new structure
         */
        loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModStatTable_loop_context);
        if (NULL == loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * allocate a temporary context to use during iteration
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = strModStatTable_allocate_rowreq_ctx(NULL);
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                SNMP_FREE(loop_ctx_ref->loop_ctx);
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         * TODO:
         * set up loop context
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * open our data file.
         */
        loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
        if (NULL == loop_ctx_ref->loop_ctx->filep) {
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * in this example, after opening the file, get next does the same thing
         * as get first, we let's just call get next...
         */
        return strModStatTable_loop_get_next(strModStatTable_reg, loop_ctx_ref, rowreq_ctx_ref);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_get_first */

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in strModStatTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
strModStatTable_loop_get_next(strModStatTable_registration * strModStatTable_reg,
                              strModStatTable_ref_loop_ctx * loop_ctx_ref,
                              strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_get_next", "called\n"));

        netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
        netsnmp_assert(rowreq_ctx_ref);

        /*
         * we just need the index for now. Reuse the one in the loop context's
         * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * get a line (skip blank lines)
         */
        do {
                if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                           loop_ctx_ref->loop_ctx->filep)) {
                        /* we're done */
                        fclose(loop_ctx_ref->loop_ctx->filep);
                        loop_ctx_ref->loop_ctx->filep = NULL;
                }
        } while (loop_ctx_ref->loop_ctx->filep && (loop_ctx_ref->loop_ctx->line[0] == '\n'));

        /*
         * check for end of data
         */
        if (NULL == loop_ctx_ref->loop_ctx->filep)
                return MFD_END_OF_DATA;

        /*
         * TODO:
         * set local vars for index from loop_ctx_ref->loop_ctx
         *  this can be done in one of two ways:
         */

        /*
         * 1) individually
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModIdnum
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModStatIndex
         */

        /*
         * OR
         */

        /*
         * 2) by calling strModStatTable_indexes_set()
         * strModStatTable_indexes_set(rowreq_ctx_ref->tbl_idx,
         *       strModIdnum
         *       strModStatIndex
         *      );
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_get_next */

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModStatTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModStatTable_loop_save_position(strModStatTable_registration * strModStatTable_reg,
                                   strModStatTable_ref_loop_ctx * loop_ctx_ref,
                                   strModStatTable_ref_loop_ctx * save_loop_ctx_ref, int reuse)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_save_position", "called\n"));

        netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

        /*
         * TODO:
         * 1) allocate new loop context, unless you can reuse a previous pointer.
         * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
         */
        if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
                save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModStatTable_loop_context);
        if (NULL == save_loop_ctx_ref->loop_ctx) {
                snmp_log(LOG_ERR, "could not allocate memory\n");
                return MFD_ERROR;
        }

        /*
         * if you can reuse a previously saved contex, just swap
         * it out with the loop iterator
         */
        if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
                strModStatTable_rowreq_ctx *tmp_rowreq_ctx =
                    save_loop_ctx_ref->loop_ctx->rowreq_ctx;
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
                loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
        } else {
                /*
                 * take the current pointer
                 */
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

                /*
                 * allocate a new context to replace the one you just took.
                 */
                loop_ctx_ref->loop_ctx->rowreq_ctx = strModStatTable_allocate_rowreq_ctx(NULL);
                if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                        SNMP_FREE(loop_ctx_ref->loop_ctx);
                        return MFD_ERROR;
                }
        }

        /*
         * TRANSIENT data: copy all the data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatQueues
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatPCnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatScnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatOcnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatCcnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatAcnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatFlags
         *     from the loop context
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_save_position */

/**
 * set strModStatTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModStatTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
strModStatTable_loop_get_data(strModStatTable_registration * strModStatTable_reg,
                              strModStatTable_ref_loop_ctx * loop_ctx_ref,
                              strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_get_data", "called\n"));

        netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
        netsnmp_assert(NULL != rowreq_ctx_ref);
        netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

        /*
         * take temporary row request context from loop context
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

        /*
         * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
         * in loop_save_position, we saved line to do that
         */
        /*
         * strModStatQueues(2)/StreamsModuleQueues/ASN_OCTET_STR/char(u_long)//L/A/w/E/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatQueues =
            loop_ctx_ref->loop_ctx->strModStatQueues;

        /*
         * strModStatPCnt(3)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatPCnt = loop_ctx_ref->loop_ctx->strModStatPCnt;

        /*
         * strModStatScnt(4)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatScnt = loop_ctx_ref->loop_ctx->strModStatScnt;

        /*
         * strModStatOcnt(5)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatOcnt = loop_ctx_ref->loop_ctx->strModStatOcnt;

        /*
         * strModStatCcnt(6)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatCcnt = loop_ctx_ref->loop_ctx->strModStatCcnt;

        /*
         * strModStatAcnt(7)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatAcnt = loop_ctx_ref->loop_ctx->strModStatAcnt;

        /*
         * strModStatPrivate(8)/OCTETSTR/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h
         */
    /** no mapping */
        /*
         * make sure there is enough space for strModStatPrivate data
         */
        if ((NULL == rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate) ||
            (rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate_len <
             (loop_ctx_ref->loop_ctx->strModStatPrivate_len *
              sizeof(loop_ctx_ref->loop_ctx->strModStatPrivate[0])))) {
                snmp_log(LOG_ERR, "not enough space for value\n");
                return MFD_ERROR;
        }
        rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate_len =
            loop_ctx_ref->loop_ctx->strModStatPrivate_len *
            sizeof(loop_ctx_ref->loop_ctx->strModStatPrivate[0]);
        memcpy(rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate,
               loop_ctx_ref->loop_ctx->strModStatPrivate,
               loop_ctx_ref->loop_ctx->strModStatPrivate_len *
               sizeof(loop_ctx_ref->loop_ctx->strModStatPrivate[0]));

        /*
         * strModStatFlags(9)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatFlags = loop_ctx_ref->loop_ctx->strModStatFlags;

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_get_data */

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModStatTable_loop_cleanup_context(strModStatTable_registration * strModStatTable_reg,
                                     strModStatTable_ref_loop_ctx * loop_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_cleanup_context", "called\n"));

        netsnmp_assert(loop_ctx_ref);

        if (!loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * release the row request context, if it wasn't taken
         */
        if (loop_ctx_ref->loop_ctx->rowreq_ctx)
                strModStatTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

        /*
         * TODO:
         * release resources
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * close file
         */
        if (loop_ctx_ref->loop_ctx->filep)
                fclose(loop_ctx_ref->loop_ctx->filep);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         * free loop context
         */
        free(loop_ctx_ref->loop_ctx);

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_cleanup_context */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
strModStatTable_row_prep(strModStatTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_row_prep", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:390:o: Prepare row for request.
         * If populating row data was delayed, this is the place to
         * fill in the row for this request.
         */

        return MFD_SUCCESS;
}                               /* strModStatTable_row_prep */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strApshTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strApshTable is subid 1 of strApsh.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1, length: 14
*/

/**
 * initialization for strApshTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param strApshTable_reg
 *        Pointer to strApshTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
strApshTable_init_data(strApshTable_registration * strApshTable_reg)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_init_data", "called\n"));

        /*
         * TODO:303:o: Initialize strApshTable data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * if you are the sole writer for the file, you could
         * open it here. However, as stated earlier, we are assuming
         * the worst case, which in this case means that the file is
         * written to by someone else, and might not even exist when
         * we start up. So we can't do anything here.
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strApshTable_init_data */

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    strApshTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          strApshTable_loop_save_position(loop,pos);
 *       strApshTable_loop_get_next(loop,data)
 *    }
 *    strApshTable_loop_get_data(pos,data)
 *    strApshTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  strApshTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  strApshTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and its indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  strApshTable_loop_init_context, save it in your
 *  strApshTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  strApshTable_loop_get_next, and simply call that function.]
 *
 * @param strApshTable_reg Pointer to a strApshTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
strApshTable_loop_get_first(strApshTable_registration * strApshTable_reg,
                            strApshTable_ref_loop_ctx * loop_ctx_ref,
                            strApshTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_loop_get_first", "called\n"));

        netsnmp_assert(rowreq_ctx_ref);
        netsnmp_assert(loop_ctx_ref);

        /*
         * allocate memory for new structure
         */
        loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strApshTable_loop_context);
        if (NULL == loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * allocate a temporary context to use during iteration
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = strApshTable_allocate_rowreq_ctx(NULL);
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                SNMP_FREE(loop_ctx_ref->loop_ctx);
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         * TODO:
         * set up loop context
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * open our data file.
         */
        loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
        if (NULL == loop_ctx_ref->loop_ctx->filep) {
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * in this example, after opening the file, get next does the same thing
         * as get first, we let's just call get next...
         */
        return strApshTable_loop_get_next(strApshTable_reg, loop_ctx_ref, rowreq_ctx_ref);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strApshTable_loop_get_first */

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in strApshTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param strApshTable_reg Pointer to a strApshTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
strApshTable_loop_get_next(strApshTable_registration * strApshTable_reg,
                           strApshTable_ref_loop_ctx * loop_ctx_ref,
                           strApshTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_loop_get_next", "called\n"));

        netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
        netsnmp_assert(rowreq_ctx_ref);

        /*
         * we just need the index for now. Reuse the one in the loop context's
         * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * get a line (skip blank lines)
         */
        do {
                if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                           loop_ctx_ref->loop_ctx->filep)) {
                        /* we're done */
                        fclose(loop_ctx_ref->loop_ctx->filep);
                        loop_ctx_ref->loop_ctx->filep = NULL;
                }
        } while (loop_ctx_ref->loop_ctx->filep && (loop_ctx_ref->loop_ctx->line[0] == '\n'));

        /*
         * check for end of data
         */
        if (NULL == loop_ctx_ref->loop_ctx->filep)
                return MFD_END_OF_DATA;

        /*
         * TODO:
         * set local vars for index from loop_ctx_ref->loop_ctx
         *  this can be done in one of two ways:
         */

        /*
         * 1) individually
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strApshName
         *     and rowreq_ctx_ref->tbl_idx->strApshName_len
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strApshMinor
         */

        /*
         * OR
         */

        /*
         * 2) by calling strApshTable_indexes_set()
         * strApshTable_indexes_set(rowreq_ctx_ref->tbl_idx,
         *       strApshName_ptr, strApshName_len
         *       strApshMinor
         *      );
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strApshTable_loop_get_next */

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strApshTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param strApshTable_reg Pointer to a strApshTable_registration *
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strApshTable_loop_save_position(strApshTable_registration * strApshTable_reg,
                                strApshTable_ref_loop_ctx * loop_ctx_ref,
                                strApshTable_ref_loop_ctx * save_loop_ctx_ref, int reuse)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_loop_save_position", "called\n"));

        netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

        /*
         * TODO:
         * 1) allocate new loop context, unless you can reuse a previous pointer.
         * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
         */
        if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
                save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strApshTable_loop_context);
        if (NULL == save_loop_ctx_ref->loop_ctx) {
                snmp_log(LOG_ERR, "could not allocate memory\n");
                return MFD_ERROR;
        }

        /*
         * if you can reuse a previously saved contex, just swap
         * it out with the loop iterator
         */
        if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
                strApshTable_rowreq_ctx *tmp_rowreq_ctx = save_loop_ctx_ref->loop_ctx->rowreq_ctx;

                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
                loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
        } else {
                /*
                 * take the current pointer
                 */
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

                /*
                 * allocate a new context to replace the one you just took.
                 */
                loop_ctx_ref->loop_ctx->rowreq_ctx = strApshTable_allocate_rowreq_ctx(NULL);
                if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                        SNMP_FREE(loop_ctx_ref->loop_ctx);
                        return MFD_ERROR;
                }
        }

        /*
         * TRANSIENT data: copy all the data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strApshMajor
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strApshLastMinor
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strApshModules
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strApshStatus
         *     from the loop context
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strApshTable_loop_save_position */

/**
 * set strApshTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strApshTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param strApshTable_reg Pointer to a strApshTable_registration *
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
strApshTable_loop_get_data(strApshTable_registration * strApshTable_reg,
                           strApshTable_ref_loop_ctx * loop_ctx_ref,
                           strApshTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_loop_get_data", "called\n"));

        netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
        netsnmp_assert(NULL != rowreq_ctx_ref);
        netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

        /*
         * take temporary row request context from loop context
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

        /*
         * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
         * in loop_save_position, we saved line to do that
         */
        /*
         * strApshMajor(2)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/w/e/R/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strApshMajor = loop_ctx_ref->loop_ctx->strApshMajor;

        /*
         * strApshLastMinor(4)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strApshLastMinor =
            loop_ctx_ref->loop_ctx->strApshLastMinor;

        /*
         * strApshModules(5)/StreamsModuleList/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H
         */
    /** no mapping */
        /*
         * make sure there is enough space for strApshModules data
         */
        if ((NULL == rowreq_ctx_ref->rowreq_ctx->data.strApshModules) ||
            (rowreq_ctx_ref->rowreq_ctx->data.strApshModules_len <
             (loop_ctx_ref->loop_ctx->strApshModules_len *
              sizeof(loop_ctx_ref->loop_ctx->strApshModules[0])))) {
                snmp_log(LOG_ERR, "not enough space for value\n");
                return MFD_ERROR;
        }
        rowreq_ctx_ref->rowreq_ctx->data.strApshModules_len =
            loop_ctx_ref->loop_ctx->strApshModules_len *
            sizeof(loop_ctx_ref->loop_ctx->strApshModules[0]);
        memcpy(rowreq_ctx_ref->rowreq_ctx->data.strApshModules,
               loop_ctx_ref->loop_ctx->strApshModules,
               loop_ctx_ref->loop_ctx->strApshModules_len *
               sizeof(loop_ctx_ref->loop_ctx->strApshModules[0]));

        /*
         * strApshStatus(6)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strApshStatus = loop_ctx_ref->loop_ctx->strApshStatus;

        return MFD_SUCCESS;
}                               /* strApshTable_loop_get_data */

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param strApshTable_reg Pointer to a strApshTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strApshTable_loop_cleanup_context(strApshTable_registration * strApshTable_reg,
                                  strApshTable_ref_loop_ctx * loop_ctx_ref)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_loop_cleanup_context", "called\n"));

        netsnmp_assert(loop_ctx_ref);

        if (!loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * release the row request context, if it wasn't taken
         */
        if (loop_ctx_ref->loop_ctx->rowreq_ctx)
                strApshTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

        /*
         * TODO:
         * release resources
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * close file
         */
        if (loop_ctx_ref->loop_ctx->filep)
                fclose(loop_ctx_ref->loop_ctx->filep);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         * free loop context
         */
        free(loop_ctx_ref->loop_ctx);

        return MFD_SUCCESS;
}                               /* strApshTable_loop_cleanup_context */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
strApshTable_row_prep(strApshTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_row_prep", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:390:o: Prepare row for request.
         * If populating row data was delayed, this is the place to
         * fill in the row for this request.
         */

        return MFD_SUCCESS;
}                               /* strApshTable_row_prep */

/*
 * TODO:420:r: Implement strApshTable index validation.
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshName
 * strApshName is subid 1 of strApshEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.1
 * Description:
Provides the driver name.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 1a
 *
 * Ranges:  1 - 8;
 *
 * Its syntax is StreamsModuleName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 8)
 *
 *
 *
 * NOTE: NODE strApshName IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of strApshName index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_ERROR     : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       strApshTable_validate_index() function.
 *
 * @note Also keep in mind that if the index refers to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 * The following checks have already been done for you:
 *    The length is in (one of) the range set(s):  1 - 8
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 */
int
strApshName_check_index(strApshTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshName_check_index", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:426:M: |-> Check strApshTable index strApshName.
         * check that index value in the table context is legal.
         * (rowreq_ctx->tbl_index.strApshName)
         */

        return MFD_SUCCESS;     /* strApshName index ok */
}                               /* strApshName_check_index */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshMinor
 * strApshMinor is subid 3 of strApshEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.3
 * Description:
Provides the minor device number or the start of a 
		 range of minor device numbers, to which the autopush 
		 specification applies.  When specified as 'FFFFFFFF'X, 
		 the specification applies to all minor device numbers 
		 for this driver and LastMinor is ignored.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383, 0;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE strApshMinor IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of strApshMinor index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_ERROR     : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       strApshTable_validate_index() function.
 *
 * @note Also keep in mind that if the index refers to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 * The following checks have already been done for you:
 *    The value is in (one of) the range set(s):  0 - 16383, 0
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 */
int
strApshMinor_check_index(strApshTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshMinor_check_index", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:426:M: |-> Check strApshTable index strApshMinor.
         * check that index value in the table context is legal.
         * (rowreq_ctx->tbl_index.strApshMinor)
         */

        return MFD_SUCCESS;     /* strApshMinor index ok */
}                               /* strApshMinor_check_index */

/**
 * verify specified index is valid.
 *
 * This check is independent of whether or not the values specified for
 * the columns of the new row are valid. Column values and row consistency
 * will be checked later. At this point, only the index values should be
 * checked.
 *
 * All of the individual index validation functions have been called, so this
 * is the place to make sure they are valid as a whole when combined. If
 * you only have one index, then you probably don't need to do anything else
 * here.
 * 
 * @note Keep in mind that if the indexes refer to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 *
 * @param strApshTable_reg
 *        Pointer to the user registration data
 * @param strApshTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS            : success
 * @retval MFD_CANNOT_CREATE_NOW  : index not valid right now
 * @retval MFD_CANNOT_CREATE_EVER : index never valid
 */
int
strApshTable_validate_index(strApshTable_registration * strApshTable_reg,
                            strApshTable_rowreq_ctx * rowreq_ctx)
{
        int rc = MFD_SUCCESS;

        DEBUGMSGTL(("verbose:strApshTable:strApshTable_validate_index", "called\n"));

    /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:430:M: |-> Validate potential strApshTable index.
         */
        if (1) {
                snmp_log(LOG_WARNING, "invalid index for a new row in the "
                         "strApshTable table.\n");
                /*
                 * determine failure type.
                 *
                 * If the index could not ever be created, return MFD_NOT_EVER
                 * If the index can not be created under the present circumstances
                 * (even though it could be created under other circumstances),
                 * return MFD_NOT_NOW.
                 */
                if (0) {
                        return MFD_CANNOT_CREATE_EVER;
                } else {
                        return MFD_CANNOT_CREATE_NOW;
                }
        }

        return rc;
}                               /* strApshTable_validate_index */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strStatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strStatsTable is subid 1 of strStats.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.5.1, length: 14
*/

/**
 * initialization for strStatsTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param strStatsTable_reg
 *        Pointer to strStatsTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
strStatsTable_init_data(strStatsTable_registration * strStatsTable_reg)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_init_data", "called\n"));

        /*
         * TODO:303:o: Initialize strStatsTable data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * if you are the sole writer for the file, you could
         * open it here. However, as stated earlier, we are assuming
         * the worst case, which in this case means that the file is
         * written to by someone else, and might not even exist when
         * we start up. So we can't do anything here.
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strStatsTable_init_data */

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    strStatsTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          strStatsTable_loop_save_position(loop,pos);
 *       strStatsTable_loop_get_next(loop,data)
 *    }
 *    strStatsTable_loop_get_data(pos,data)
 *    strStatsTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  strStatsTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  strStatsTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and its indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  strStatsTable_loop_init_context, save it in your
 *  strStatsTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  strStatsTable_loop_get_next, and simply call that function.]
 *
 * @param strStatsTable_reg Pointer to a strStatsTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
strStatsTable_loop_get_first(strStatsTable_registration * strStatsTable_reg,
                             strStatsTable_ref_loop_ctx * loop_ctx_ref,
                             strStatsTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_loop_get_first", "called\n"));

        netsnmp_assert(rowreq_ctx_ref);
        netsnmp_assert(loop_ctx_ref);

        /*
         * allocate memory for new structure
         */
        loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strStatsTable_loop_context);
        if (NULL == loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * allocate a temporary context to use during iteration
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = strStatsTable_allocate_rowreq_ctx(NULL);
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                SNMP_FREE(loop_ctx_ref->loop_ctx);
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         * TODO:
         * set up loop context
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * open our data file.
         */
        loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
        if (NULL == loop_ctx_ref->loop_ctx->filep) {
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * in this example, after opening the file, get next does the same thing
         * as get first, we let's just call get next...
         */
        return strStatsTable_loop_get_next(strStatsTable_reg, loop_ctx_ref, rowreq_ctx_ref);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strStatsTable_loop_get_first */

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in strStatsTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param strStatsTable_reg Pointer to a strStatsTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
strStatsTable_loop_get_next(strStatsTable_registration * strStatsTable_reg,
                            strStatsTable_ref_loop_ctx * loop_ctx_ref,
                            strStatsTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_loop_get_next", "called\n"));

        netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
        netsnmp_assert(rowreq_ctx_ref);

        /*
         * we just need the index for now. Reuse the one in the loop context's
         * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * get a line (skip blank lines)
         */
        do {
                if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                           loop_ctx_ref->loop_ctx->filep)) {
                        /* we're done */
                        fclose(loop_ctx_ref->loop_ctx->filep);
                        loop_ctx_ref->loop_ctx->filep = NULL;
                }
        } while (loop_ctx_ref->loop_ctx->filep && (loop_ctx_ref->loop_ctx->line[0] == '\n'));

        /*
         * check for end of data
         */
        if (NULL == loop_ctx_ref->loop_ctx->filep)
                return MFD_END_OF_DATA;

        /*
         * TODO:
         * set local vars for index from loop_ctx_ref->loop_ctx
         *  this can be done in one of two ways:
         */

        /*
         * 1) individually
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strStatsStructure
         */

        /*
         * OR
         */

        /*
         * 2) by calling strStatsTable_indexes_set()
         * strStatsTable_indexes_set(rowreq_ctx_ref->tbl_idx,
         *       strStatsStructure
         *      );
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strStatsTable_loop_get_next */

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strStatsTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param strStatsTable_reg Pointer to a strStatsTable_registration *
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strStatsTable_loop_save_position(strStatsTable_registration * strStatsTable_reg,
                                 strStatsTable_ref_loop_ctx * loop_ctx_ref,
                                 strStatsTable_ref_loop_ctx * save_loop_ctx_ref, int reuse)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_loop_save_position", "called\n"));

        netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

        /*
         * TODO:
         * 1) allocate new loop context, unless you can reuse a previous pointer.
         * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
         */
        if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
                save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strStatsTable_loop_context);
        if (NULL == save_loop_ctx_ref->loop_ctx) {
                snmp_log(LOG_ERR, "could not allocate memory\n");
                return MFD_ERROR;
        }

        /*
         * if you can reuse a previously saved contex, just swap
         * it out with the loop iterator
         */
        if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
                strStatsTable_rowreq_ctx *tmp_rowreq_ctx = save_loop_ctx_ref->loop_ctx->rowreq_ctx;

                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
                loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
        } else {
                /*
                 * take the current pointer
                 */
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

                /*
                 * allocate a new context to replace the one you just took.
                 */
                loop_ctx_ref->loop_ctx->rowreq_ctx = strStatsTable_allocate_rowreq_ctx(NULL);
                if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                        SNMP_FREE(loop_ctx_ref->loop_ctx);
                        return MFD_ERROR;
                }
        }

        /*
         * TRANSIENT data: copy all the data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strStatsCurrentAllocs
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strStatsHighWaterMark
         *     from the loop context
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strStatsTable_loop_save_position */

/**
 * set strStatsTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strStatsTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param strStatsTable_reg Pointer to a strStatsTable_registration *
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
strStatsTable_loop_get_data(strStatsTable_registration * strStatsTable_reg,
                            strStatsTable_ref_loop_ctx * loop_ctx_ref,
                            strStatsTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_loop_get_data", "called\n"));

        netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
        netsnmp_assert(NULL != rowreq_ctx_ref);
        netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

        /*
         * take temporary row request context from loop context
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

        /*
         * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
         * in loop_save_position, we saved line to do that
         */
        /*
         * strStatsCurrentAllocs(2)/GAUGE/ASN_GAUGE/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strStatsCurrentAllocs =
            loop_ctx_ref->loop_ctx->strStatsCurrentAllocs;

        /*
         * strStatsHighWaterMark(3)/GAUGE/ASN_GAUGE/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strStatsHighWaterMark =
            loop_ctx_ref->loop_ctx->strStatsHighWaterMark;

        return MFD_SUCCESS;
}                               /* strStatsTable_loop_get_data */

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param strStatsTable_reg Pointer to a strStatsTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strStatsTable_loop_cleanup_context(strStatsTable_registration * strStatsTable_reg,
                                   strStatsTable_ref_loop_ctx * loop_ctx_ref)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_loop_cleanup_context", "called\n"));

        netsnmp_assert(loop_ctx_ref);

        if (!loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * release the row request context, if it wasn't taken
         */
        if (loop_ctx_ref->loop_ctx->rowreq_ctx)
                strStatsTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

        /*
         * TODO:
         * release resources
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * close file
         */
        if (loop_ctx_ref->loop_ctx->filep)
                fclose(loop_ctx_ref->loop_ctx->filep);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         * free loop context
         */
        free(loop_ctx_ref->loop_ctx);

        return MFD_SUCCESS;
}                               /* strStatsTable_loop_cleanup_context */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
strStatsTable_row_prep(strStatsTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_row_prep", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:390:o: Prepare row for request.
         * If populating row data was delayed, this is the place to
         * fill in the row for this request.
         */

        return MFD_SUCCESS;
}                               /* strStatsTable_row_prep */

/** @} */
