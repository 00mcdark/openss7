/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.20 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "strMIB.h"

/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement strStatsTable get routines.
 * TODO:240:M: Implement strStatsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModTable is subid 1 of strMod.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strModTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strModTable_indexes_set_tbl_idx(strModTable_mib_index * tbl_idx, u_long strModIdnum_val)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_indexes_set_tbl_idx", "called\n"));

        /* strModIdnum(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strModIdnum = strModIdnum_val;

        return MFD_SUCCESS;
}                               /* strModTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strModTable_indexes_set(strModTable_rowreq_ctx * rowreq_ctx, u_long strModIdnum_val)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_indexes_set", "called\n"));

        if (MFD_SUCCESS != strModTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strModIdnum_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strModTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strModTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModName
 * strModName is subid 2 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.2
 * Description:
Indicates the name of the STREAMS driver or module as an 
		 index into the table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 1a
 *
 * Ranges:  1 - 8;
 *
 * Its syntax is StreamsModuleName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 8)
 */
/**
 * Extract the current value of the strModName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param strModName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by strModName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*strModName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update strModName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
strModName_get(strModTable_rowreq_ctx * rowreq_ctx, char **strModName_val_ptr_ptr,
               size_t *strModName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
        netsnmp_assert((NULL != strModName_val_ptr_ptr) && (NULL != *strModName_val_ptr_ptr));
        netsnmp_assert(NULL != strModName_val_ptr_len_ptr);

        DEBUGMSGTL(("verbose:strModTable:strModName_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModName data.
 * copy (* strModName_val_ptr_ptr ) data and (* strModName_val_ptr_len_ptr ) from rowreq_ctx->data
 */
        /*
         * make sure there is enough space for strModName data
         */
        if ((NULL == (*strModName_val_ptr_ptr)) ||
            ((*strModName_val_ptr_len_ptr) <
             (rowreq_ctx->data.strModName_len * sizeof(rowreq_ctx->data.strModName[0])))) {
                /*
                 * allocate space for strModName data
                 */
                (*strModName_val_ptr_ptr) =
                    malloc(rowreq_ctx->data.strModName_len *
                           sizeof(rowreq_ctx->data.strModName[0]));
                if (NULL == (*strModName_val_ptr_ptr)) {
                        snmp_log(LOG_ERR, "could not allocate memory\n");
                        return MFD_ERROR;
                }
        }
        (*strModName_val_ptr_len_ptr) =
            rowreq_ctx->data.strModName_len * sizeof(rowreq_ctx->data.strModName[0]);
        memcpy((*strModName_val_ptr_ptr), rowreq_ctx->data.strModName,
               rowreq_ctx->data.strModName_len * sizeof(rowreq_ctx->data.strModName[0]));

        return MFD_SUCCESS;
}                               /* strModName_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModType
 * strModType is subid 3 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.3
 * Description:
Indicates the type of the object, whether a STREAMS 
		 driver or module.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 1/8. Values:  module(1), driver(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the strModType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModType_get(strModTable_rowreq_ctx * rowreq_ctx, u_long * strModType_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModType_val_ptr);

        DEBUGMSGTL(("verbose:strModTable:strModType_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModType data.
 * copy (* strModType_val_ptr ) from rowreq_ctx->data
 */
        (*strModType_val_ptr) = rowreq_ctx->data.strModType;

        return MFD_SUCCESS;
}                               /* strModType_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModMajor
 * strModMajor is subid 4 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.4
 * Description:
Indicates the major device number of a STREAMS driver or 
		 zero (0) for a STREAMS module.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModMajor data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModMajor_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModMajor_get(strModTable_rowreq_ctx * rowreq_ctx, u_long * strModMajor_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModMajor_val_ptr);

        DEBUGMSGTL(("verbose:strModTable:strModMajor_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModMajor data.
 * copy (* strModMajor_val_ptr ) from rowreq_ctx->data
 */
        (*strModMajor_val_ptr) = rowreq_ctx->data.strModMajor;

        return MFD_SUCCESS;
}                               /* strModMajor_get */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strModInfoTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModInfoTable is subid 1 of strModInfo.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strModInfoTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strModInfoTable_indexes_set_tbl_idx(strModInfoTable_mib_index * tbl_idx, u_long strModIdnum_val,
                                    u_long strModInfoIndex_val)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_indexes_set_tbl_idx", "called\n"));

        /* strModIdnum(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strModIdnum = strModIdnum_val;

        /* strModInfoIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strModInfoIndex = strModInfoIndex_val;

        return MFD_SUCCESS;
}                               /* strModInfoTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strModInfoTable_indexes_set(strModInfoTable_rowreq_ctx * rowreq_ctx, u_long strModIdnum_val,
                            u_long strModInfoIndex_val)
{
        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTable_indexes_set", "called\n"));

        if (MFD_SUCCESS !=
            strModInfoTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strModIdnum_val,
                                                strModInfoIndex_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strModInfoTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strModInfoTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoQueues
 * strModInfoQueues is subid 2 of strModInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.2
 * Description:
Identifies to which queues in the module the STREAMS 
		 information applies.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 3/8. Values:  rq(0), wq(1), muxrq(2), muxwq(3)
 *
 * Its syntax is StreamsModuleQueues (based on perltype BITS)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (u_long)
 * This data type requires a length.
 */
/**
 * Extract the current value of the strModInfoQueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModInfoQueues_val_ptr
 *        Pointer to storage for a char variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModInfoQueues_get(strModInfoTable_rowreq_ctx * rowreq_ctx, u_long * strModInfoQueues_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModInfoQueues_val_ptr);

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoQueues_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModInfoQueues data.
 * copy (* strModInfoQueues_val_ptr ) from rowreq_ctx->data
 */
        return MFD_SKIP;
        /*
         * TODO:242:o: update or replace BITS tests (get).
         * If strModInfoQueues data is stored in SNMP BIT order, individual
         * bit tests are redundant, and you can do a straight copy. If not, then
         * update each if condition to test the correct bit.
         *
         * NOTE WELL: setting bit '0' for:
         *             C  0x0000001
         *          SNMP  0x8000000
         *
         * assuming generated code keeps strModInfoQueues BITS in SNMP order.
         */
        (*strModInfoQueues_val_ptr) = rowreq_ctx->data.strModInfoQueues;

        return MFD_SUCCESS;
}                               /* strModInfoQueues_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoMinpsz
 * strModInfoMinpsz is subid 3 of strModInfoEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.3
 * Description:
Specifies the minimum packet size associated with the 
		 driver or module for the queues indicated in the 
		 strModInfoQueues column.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the strModInfoMinpsz data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModInfoMinpsz_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModInfoMinpsz_get(strModInfoTable_rowreq_ctx * rowreq_ctx, long *strModInfoMinpsz_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModInfoMinpsz_val_ptr);

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoMinpsz_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModInfoMinpsz data.
 * copy (* strModInfoMinpsz_val_ptr ) from rowreq_ctx->data
 */
        (*strModInfoMinpsz_val_ptr) = rowreq_ctx->data.strModInfoMinpsz;

        return MFD_SUCCESS;
}                               /* strModInfoMinpsz_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoMaxpsz
 * strModInfoMaxpsz is subid 4 of strModInfoEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.4
 * Description:
Specifies the maximum packet size associated with the 
		 driver or module for the queues indicated in the 
		 strModInfoQueues column.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the strModInfoMaxpsz data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModInfoMaxpsz_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModInfoMaxpsz_get(strModInfoTable_rowreq_ctx * rowreq_ctx, long *strModInfoMaxpsz_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModInfoMaxpsz_val_ptr);

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoMaxpsz_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModInfoMaxpsz data.
 * copy (* strModInfoMaxpsz_val_ptr ) from rowreq_ctx->data
 */
        (*strModInfoMaxpsz_val_ptr) = rowreq_ctx->data.strModInfoMaxpsz;

        return MFD_SUCCESS;
}                               /* strModInfoMaxpsz_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoHiwat
 * strModInfoHiwat is subid 5 of strModInfoEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.5
 * Description:
Specifies the high water mark associated with the 
		 driver or module for the queues indicated in the 
		 strModInfoQueues column.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModInfoHiwat data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModInfoHiwat_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModInfoHiwat_get(strModInfoTable_rowreq_ctx * rowreq_ctx, u_long * strModInfoHiwat_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModInfoHiwat_val_ptr);

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoHiwat_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModInfoHiwat data.
 * copy (* strModInfoHiwat_val_ptr ) from rowreq_ctx->data
 */
        (*strModInfoHiwat_val_ptr) = rowreq_ctx->data.strModInfoHiwat;

        return MFD_SUCCESS;
}                               /* strModInfoHiwat_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoLowat
 * strModInfoLowat is subid 6 of strModInfoEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.6
 * Description:
Specifies the low water mark associated with the 
		 driver or module for the queues indicated in the 
		 strModInfoQueues column.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModInfoLowat data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModInfoLowat_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModInfoLowat_get(strModInfoTable_rowreq_ctx * rowreq_ctx, u_long * strModInfoLowat_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModInfoLowat_val_ptr);

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoLowat_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModInfoLowat data.
 * copy (* strModInfoLowat_val_ptr ) from rowreq_ctx->data
 */
        (*strModInfoLowat_val_ptr) = rowreq_ctx->data.strModInfoLowat;

        return MFD_SUCCESS;
}                               /* strModInfoLowat_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModInfoEntry.strModInfoTraceLevel
 * strModInfoTraceLevel is subid 7 of strModInfoEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.2.1.1.7
 * Description:
Specifies the trace level associated with the driver or 
		 module for the queues indicated in the strModInfoQueues 
		 column.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModInfoTraceLevel data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModInfoTraceLevel_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModInfoTraceLevel_get(strModInfoTable_rowreq_ctx * rowreq_ctx,
                         u_long * strModInfoTraceLevel_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModInfoTraceLevel_val_ptr);

        DEBUGMSGTL(("verbose:strModInfoTable:strModInfoTraceLevel_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModInfoTraceLevel data.
 * copy (* strModInfoTraceLevel_val_ptr ) from rowreq_ctx->data
 */
        (*strModInfoTraceLevel_val_ptr) = rowreq_ctx->data.strModInfoTraceLevel;

        return MFD_SUCCESS;
}                               /* strModInfoTraceLevel_get */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strModStatTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModStatTable is subid 1 of strModStat.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strModStatTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strModStatTable_indexes_set_tbl_idx(strModStatTable_mib_index * tbl_idx, u_long strModIdnum_val,
                                    u_long strModStatIndex_val)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_indexes_set_tbl_idx", "called\n"));

        /* strModIdnum(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strModIdnum = strModIdnum_val;

        /* strModStatIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strModStatIndex = strModStatIndex_val;

        return MFD_SUCCESS;
}                               /* strModStatTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strModStatTable_indexes_set(strModStatTable_rowreq_ctx * rowreq_ctx, u_long strModIdnum_val,
                            u_long strModStatIndex_val)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_indexes_set", "called\n"));

        if (MFD_SUCCESS !=
            strModStatTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strModIdnum_val,
                                                strModStatIndex_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strModStatTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strModStatTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatQueues
 * strModStatQueues is subid 2 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.2
 * Description:
Identifies to which queues in the module the STREAMS 
		 statistics applies.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 3/8. Values:  rq(0), wq(1), muxrq(2), muxwq(3)
 *
 * Its syntax is StreamsModuleQueues (based on perltype BITS)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (u_long)
 * This data type requires a length.
 */
/**
 * Extract the current value of the strModStatQueues data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatQueues_val_ptr
 *        Pointer to storage for a char variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatQueues_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatQueues_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatQueues_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatQueues_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatQueues data.
 * copy (* strModStatQueues_val_ptr ) from rowreq_ctx->data
 */
        return MFD_SKIP;
        /*
         * TODO:242:o: update or replace BITS tests (get).
         * If strModStatQueues data is stored in SNMP BIT order, individual
         * bit tests are redundant, and you can do a straight copy. If not, then
         * update each if condition to test the correct bit.
         *
         * NOTE WELL: setting bit '0' for:
         *             C  0x0000001
         *          SNMP  0x8000000
         *
         * assuming generated code keeps strModStatQueues BITS in SNMP order.
         */
        (*strModStatQueues_val_ptr) = rowreq_ctx->data.strModStatQueues;

        return MFD_SUCCESS;
}                               /* strModStatQueues_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatPCnt
 * strModStatPCnt is subid 3 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.3
 * Description:
Indicates the statistics associated with queue put 
		 procedure calls.  While this is typically the number of 
		 times that the put procedure was called, the module may 
		 increment this count on some other basis, or not at 
		 all.  See the specific module documentation for 
		 information.

		 This count is associated with the ms_pcnt member of the 
		 queue's module_stat structure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModStatPCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatPCnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatPCnt_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatPCnt_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatPCnt_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatPCnt_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatPCnt data.
 * copy (* strModStatPCnt_val_ptr ) from rowreq_ctx->data
 */
        (*strModStatPCnt_val_ptr) = rowreq_ctx->data.strModStatPCnt;

        return MFD_SUCCESS;
}                               /* strModStatPCnt_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatScnt
 * strModStatScnt is subid 4 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.4
 * Description:
Indicates the statistics associated with queue put 
		 procedure calls.  While this is typically the number of 
		 times that the put procedure was called, the module may 
		 increment this count on some other basis, or not at 
		 all.  See the specific module documentation for 
		 information.

		 This count is associated with the ms_scnt member of the 
		 queue's module_stat structure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModStatScnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatScnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatScnt_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatScnt_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatScnt_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatScnt_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatScnt data.
 * copy (* strModStatScnt_val_ptr ) from rowreq_ctx->data
 */
        (*strModStatScnt_val_ptr) = rowreq_ctx->data.strModStatScnt;

        return MFD_SUCCESS;
}                               /* strModStatScnt_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatOcnt
 * strModStatOcnt is subid 5 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.5
 * Description:
Indicates the statistics associated with module open 
		 routine calls.  While this is typically the number of 
		 times that the module open routine was called, the 
		 module may increment this count on some other basis, or 
		 not at all.  See the specific module documentation for 
		 information.

		 This count is associated with the ms_ocnt member of the 
		 queue's module_stat structure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModStatOcnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatOcnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatOcnt_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatOcnt_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatOcnt_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatOcnt_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatOcnt data.
 * copy (* strModStatOcnt_val_ptr ) from rowreq_ctx->data
 */
        (*strModStatOcnt_val_ptr) = rowreq_ctx->data.strModStatOcnt;

        return MFD_SUCCESS;
}                               /* strModStatOcnt_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatCcnt
 * strModStatCcnt is subid 6 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.6
 * Description:
Indicates the statistics assocaited with module close 
		 routine calls.  While this is typically the number of 
		 times that the module close routine was called, the 
		 module may increment this count on some other basis, or 
		 not at all.  See the specific module documentation for 
		 information.
		 
		 This count is associated with the ms_ccnt member of the 
		 queue's module_stat structure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModStatCcnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatCcnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatCcnt_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatCcnt_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatCcnt_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatCcnt_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatCcnt data.
 * copy (* strModStatCcnt_val_ptr ) from rowreq_ctx->data
 */
        (*strModStatCcnt_val_ptr) = rowreq_ctx->data.strModStatCcnt;

        return MFD_SUCCESS;
}                               /* strModStatCcnt_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatAcnt
 * strModStatAcnt is subid 7 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.7
 * Description:
Indicates the statistics associated with module admin 
		 routine calls.  While this is typically the number of 
		 times that the module admin routine was called, the 
		 module may increment this count on some other basis, or 
		 not at all.  See the specific module documentation for 
		 information.
		 
		 This count is associated with the ms_acnt member of the 
		 queue's module_stat structure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModStatAcnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatAcnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatAcnt_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatAcnt_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatAcnt_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatAcnt_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatAcnt data.
 * copy (* strModStatAcnt_val_ptr ) from rowreq_ctx->data
 */
        (*strModStatAcnt_val_ptr) = rowreq_ctx->data.strModStatAcnt;

        return MFD_SUCCESS;
}                               /* strModStatAcnt_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatPrivate
 * strModStatPrivate is subid 8 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.8
 * Description:
Indicates the private statistics associated with the 
		 module.  The format of this area is not defined by 
		 STREAMS.  See the specific module documentation for 
		 information.
		 
		 This data is associated with the ms_xprt and ms_xsize 
		 members of the queue's module_stat structure.  If no 
		 such structure is provided, or, if ms_xsize is zero, 
		 this will be a null string.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the strModStatPrivate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatPrivate_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param strModStatPrivate_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by strModStatPrivate.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*strModStatPrivate_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update strModStatPrivate_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
strModStatPrivate_get(strModStatTable_rowreq_ctx * rowreq_ctx, char **strModStatPrivate_val_ptr_ptr,
                      size_t *strModStatPrivate_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
        netsnmp_assert((NULL != strModStatPrivate_val_ptr_ptr)
                       && (NULL != *strModStatPrivate_val_ptr_ptr));
        netsnmp_assert(NULL != strModStatPrivate_val_ptr_len_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatPrivate_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatPrivate data.
 * copy (* strModStatPrivate_val_ptr_ptr ) data and (* strModStatPrivate_val_ptr_len_ptr ) from rowreq_ctx->data
 */
        /*
         * make sure there is enough space for strModStatPrivate data
         */
        if ((NULL == (*strModStatPrivate_val_ptr_ptr)) ||
            ((*strModStatPrivate_val_ptr_len_ptr) <
             (rowreq_ctx->data.strModStatPrivate_len *
              sizeof(rowreq_ctx->data.strModStatPrivate[0])))) {
                /*
                 * allocate space for strModStatPrivate data
                 */
                (*strModStatPrivate_val_ptr_ptr) =
                    malloc(rowreq_ctx->data.strModStatPrivate_len *
                           sizeof(rowreq_ctx->data.strModStatPrivate[0]));
                if (NULL == (*strModStatPrivate_val_ptr_ptr)) {
                        snmp_log(LOG_ERR, "could not allocate memory\n");
                        return MFD_ERROR;
                }
        }
        (*strModStatPrivate_val_ptr_len_ptr) =
            rowreq_ctx->data.strModStatPrivate_len * sizeof(rowreq_ctx->data.strModStatPrivate[0]);
        memcpy((*strModStatPrivate_val_ptr_ptr), rowreq_ctx->data.strModStatPrivate,
               rowreq_ctx->data.strModStatPrivate_len *
               sizeof(rowreq_ctx->data.strModStatPrivate[0]));

        return MFD_SUCCESS;
}                               /* strModStatPrivate_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModStatEntry.strModStatFlags
 * strModStatFlags is subid 9 of strModStatEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1.1.9
 * Description:
Indicates the boolean statistics associated with the 
		 module in a 32-bit flags word.  The format of these 
		 flags is not defined by STREAMS.  See the specific 
		 module documentation for information.

		 This data is assocaited with the ms_flags member of the 
		 queue's module_stat structure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModStatFlags data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModStatFlags_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModStatFlags_get(strModStatTable_rowreq_ctx * rowreq_ctx, u_long * strModStatFlags_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModStatFlags_val_ptr);

        DEBUGMSGTL(("verbose:strModStatTable:strModStatFlags_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModStatFlags data.
 * copy (* strModStatFlags_val_ptr ) from rowreq_ctx->data
 */
        (*strModStatFlags_val_ptr) = rowreq_ctx->data.strModStatFlags;

        return MFD_SUCCESS;
}                               /* strModStatFlags_get */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strApshTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strApshTable is subid 1 of strApsh.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strApshTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strApshTable_indexes_set_tbl_idx(strApshTable_mib_index * tbl_idx, char *strApshName_val_ptr,
                                 size_t strApshName_val_ptr_len, u_long strApshMinor_val)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_indexes_set_tbl_idx", "called\n"));

        /* strApshName(1)/StreamsModuleName/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/H */
        tbl_idx->strApshName_len = sizeof(tbl_idx->strApshName) / sizeof(tbl_idx->strApshName[0]);      /* max length */
        /*
         * make sure there is enough space for strApshName data
         */
        if ((NULL == tbl_idx->strApshName) ||
            (tbl_idx->strApshName_len < (strApshName_val_ptr_len))) {
                snmp_log(LOG_ERR, "not enough space for value\n");
                return MFD_ERROR;
        }
        tbl_idx->strApshName_len = strApshName_val_ptr_len;
        memcpy(tbl_idx->strApshName, strApshName_val_ptr,
               strApshName_val_ptr_len * sizeof(strApshName_val_ptr[0]));

        /* strApshMinor(3)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strApshMinor = strApshMinor_val;

        return MFD_SUCCESS;
}                               /* strApshTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strApshTable_indexes_set(strApshTable_rowreq_ctx * rowreq_ctx, char *strApshName_val_ptr,
                         size_t strApshName_val_ptr_len, u_long strApshMinor_val)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_indexes_set", "called\n"));

        if (MFD_SUCCESS !=
            strApshTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strApshName_val_ptr,
                                             strApshName_val_ptr_len, strApshMinor_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strApshTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strApshTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshMajor
 * strApshMajor is subid 2 of strApshEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.2
 * Description:
Provides the primary majro device number associated 
		 with the driver.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strApshMajor data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strApshMajor_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strApshMajor_get(strApshTable_rowreq_ctx * rowreq_ctx, u_long * strApshMajor_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strApshMajor_val_ptr);

        DEBUGMSGTL(("verbose:strApshTable:strApshMajor_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strApshMajor data.
 * copy (* strApshMajor_val_ptr ) from rowreq_ctx->data
 */
        (*strApshMajor_val_ptr) = rowreq_ctx->data.strApshMajor;

        return MFD_SUCCESS;
}                               /* strApshMajor_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshLastMinor
 * strApshLastMinor is subid 4 of strApshEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.4
 * Description:
Provides the last minor device number in a range.  This 
		 value is always zero (0) when the Minor number is 
		 'FFFFFFFF'X.  The agent must ensure that the range 
		 specified by this number does not overlap with other 
		 ranges specified in this autopush specification entry.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE strApshLastMinor IS NOT ACCESSIBLE
 *
 *
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshModules
 * strApshModules is subid 5 of strApshEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.5
 * Description:
Provides a STREAMS module list flowing the 
		 StreamsModuleList textual convention.  This is a 
		 space-separated list of Streams module names.  When 
		 this entry is created, it is persistent accross agent 
		 reboots, and might first be verified by the agent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 1a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is StreamsModuleList (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the strApshModules data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strApshModules_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param strApshModules_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by strApshModules.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*strApshModules_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update strApshModules_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
strApshModules_get(strApshTable_rowreq_ctx * rowreq_ctx, char **strApshModules_val_ptr_ptr,
                   size_t *strApshModules_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
        netsnmp_assert((NULL != strApshModules_val_ptr_ptr)
                       && (NULL != *strApshModules_val_ptr_ptr));
        netsnmp_assert(NULL != strApshModules_val_ptr_len_ptr);

        DEBUGMSGTL(("verbose:strApshTable:strApshModules_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strApshModules data.
 * copy (* strApshModules_val_ptr_ptr ) data and (* strApshModules_val_ptr_len_ptr ) from rowreq_ctx->data
 */
        /*
         * make sure there is enough space for strApshModules data
         */
        if ((NULL == (*strApshModules_val_ptr_ptr)) ||
            ((*strApshModules_val_ptr_len_ptr) <
             (rowreq_ctx->data.strApshModules_len * sizeof(rowreq_ctx->data.strApshModules[0])))) {
                /*
                 * allocate space for strApshModules data
                 */
                (*strApshModules_val_ptr_ptr) =
                    malloc(rowreq_ctx->data.strApshModules_len *
                           sizeof(rowreq_ctx->data.strApshModules[0]));
                if (NULL == (*strApshModules_val_ptr_ptr)) {
                        snmp_log(LOG_ERR, "could not allocate memory\n");
                        return MFD_ERROR;
                }
        }
        (*strApshModules_val_ptr_len_ptr) =
            rowreq_ctx->data.strApshModules_len * sizeof(rowreq_ctx->data.strApshModules[0]);
        memcpy((*strApshModules_val_ptr_ptr), rowreq_ctx->data.strApshModules,
               rowreq_ctx->data.strApshModules_len * sizeof(rowreq_ctx->data.strApshModules[0]));

        return MFD_SUCCESS;
}                               /* strApshModules_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshStatus
 * strApshStatus is subid 6 of strApshEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.6
 * Description:
Provides management stations with the ability to add 
		 rows to, or delete rows from, the STREAMS autopush table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the strApshStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strApshStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strApshStatus_get(strApshTable_rowreq_ctx * rowreq_ctx, u_long * strApshStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strApshStatus_val_ptr);

        (*strApshStatus_val_ptr) = rowreq_ctx->data.strApshStatus;

        return MFD_SUCCESS;
}                               /* strApshStatus_get */

/**********************************************************************
 **********************************************************************
 ***
 *** Table strStatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strStatsTable is subid 1 of strStats.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.5.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strStatsTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strStatsTable_indexes_set_tbl_idx(strStatsTable_mib_index * tbl_idx, u_long strStatsStructure_val)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_indexes_set_tbl_idx", "called\n"));

        /* strStatsStructure(1)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
        tbl_idx->strStatsStructure = strStatsStructure_val;

        return MFD_SUCCESS;
}                               /* strStatsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strStatsTable_indexes_set(strStatsTable_rowreq_ctx * rowreq_ctx, u_long strStatsStructure_val)
{
        DEBUGMSGTL(("verbose:strStatsTable:strStatsTable_indexes_set", "called\n"));

        if (MFD_SUCCESS !=
            strStatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strStatsStructure_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strStatsTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strStatsTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strStatsEntry.strStatsCurrentAllocs
 * strStatsCurrentAllocs is subid 2 of strStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.5.1.1.2
 * Description:
Provides the number of objects of the structure type 
		 currently allocated.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strStatsCurrentAllocs data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strStatsCurrentAllocs_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strStatsCurrentAllocs_get(strStatsTable_rowreq_ctx * rowreq_ctx,
                          u_long * strStatsCurrentAllocs_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strStatsCurrentAllocs_val_ptr);

        DEBUGMSGTL(("verbose:strStatsTable:strStatsCurrentAllocs_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strStatsCurrentAllocs data.
 * copy (* strStatsCurrentAllocs_val_ptr ) from rowreq_ctx->data
 */
        (*strStatsCurrentAllocs_val_ptr) = rowreq_ctx->data.strStatsCurrentAllocs;

        return MFD_SUCCESS;
}                               /* strStatsCurrentAllocs_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strStatsEntry.strStatsHighWaterMark
 * strStatsHighWaterMark is subid 3 of strStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.5.1.1.3
 * Description:
Provides the maximum number of objects of the structure 
		 type that were allocated at one time (the maximum 
		 historical value of strStatsCurrentAlloc) since the 
		 last time that the system was rebooted.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strStatsHighWaterMark data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strStatsHighWaterMark_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strStatsHighWaterMark_get(strStatsTable_rowreq_ctx * rowreq_ctx,
                          u_long * strStatsHighWaterMark_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strStatsHighWaterMark_val_ptr);

        DEBUGMSGTL(("verbose:strStatsTable:strStatsHighWaterMark_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strStatsHighWaterMark data.
 * copy (* strStatsHighWaterMark_val_ptr ) from rowreq_ctx->data
 */
        (*strStatsHighWaterMark_val_ptr) = rowreq_ctx->data.strStatsHighWaterMark;

        return MFD_SUCCESS;
}                               /* strStatsHighWaterMark_get */

/** @} */
