************************************************************************
strModTable README
------------------------------------------------------------------------
  This readme file describes the code generated by mib2c (using the MIBs
  for Dummies (MFD) configuration file). The code generated was
  generated specifically for the following SNMP table:

     strModTable

  Your code will be called when the snmp agent receives requests for
  the strModTable table.  The agent will start by looking for the right
  row in your existing data to operate on, if one exists.


  Configuration Variables
  ------------------------------------------------------------
  Some variables used for code generation may be set to affect the code
  generation. You may override these variables by setting them in the
  file defaults/table-strModTable.m2d, and then re-running mib2c.

    m2c_table_settable (currently '0')
    --------------------------------------------------------
    This variable determines whether or not code is generated to support
    MIB object which have an access of read-write or read-create. The
    default is set based on whether or not the table contains writable
    objects, but can be over-ridden.

    Syntax: @eval $m2c_table_settable = 0@


    m2c_table_dependencies (currently '0')
    --------------------------------------------------------
    This variable determines whether or not code is generated to support
    checking dependencies between columns, rows or tables. The default
    is set based on whether or not the table contains writable objects,
    but can be over-ridden.

    Syntax: @eval $m2c_table_dependencies = 0@


    m2c_table_row_creation (currently '0')
    --------------------------------------------------------
    This variable determines whether or not code is generated to support
    checking creation of new rows via SNMP. The default is set based on
    whether or not the table contains read-create objects, but can be
    over-ridden.

    Syntax: @eval $m2c_table_row_creation = 0@


    m2c_context_reg (currently 'netsnmp_data_list')
    --------------------------------------------------------
    This variable contains the structure name to typedef for the
    strModTable_registration.

    During initilization, you will provide a pointer to a structure of
    this type. This pointer is used as a parameter to many functions so
    that you have access to your registration data. The default is a
    netsnmp_data_list pointer, which will allow you to keep multiple
    pointers tagged by a text name. If you have a new or existing structure
    you would rather use, you can redefine this variable.
    

    To avoid regenerating code, you may also change this typedef directly
    in the strModTable.h header.

    Syntax: @eval $m2c_context_reg = "struct my_registration_context@


    m2c_data_context (currently 'generated')
    --------------------------------------------------------
    This variable contains the structure name to typedef for the
    strModTable_data.

    This typedef is used in the row request context structure for the table,
    strModTable_rowreq_ctx.

    The typedef in the primary table context will be used for the data and
    undo structure types. This structure should contain all the data
    needed for all the columns in the table. The default is 'generated',
    which will cuase a new data strcuture to be generated with data members
    for each column.

    To avoid regenerating code, you may also change this typedef directly
    in the strModTable.h header.

    Syntax: @eval $m2c_data_context = "struct my_data_context"@


    m2c_data_allocate (currently '0')
    --------------------------------------------------------
    This variable determines whether or not the data context (see above)
    requires memory to be allocated. The default generated data structure
    does not. If you are using a custom data context which needs to
    allocate memory, override this value and two additional functions
    will be generated:

      strModTable_allocate_data
      strModTable_release_data

    Syntax: @eval $m2c_data_allocate = 1@


    m2c_data_init (currently '1')
    --------------------------------------------------------
    This variable determines whether or not the data context (see above)
    or any other items you have added to the table context requires
    initialization. The default generated data structure does not. If you
    are using a custom data context or have added items needing initialization
    to the table context, override this value and two additional functions
    will be generated:

      strModTable_rowreq_ctx_init
      strModTable_rowreq_ctx_cleanup

    Syntax: @eval 1 = 1@


    m2c_table_access (currently 'unsorted-external')
    ------------------------------------------------------------------
    This variable determines which data interface will be use to generate
    code for looking up data for a given index. The default is the
    'container-cached' access code, which caches the data in a netsnmp-
    container (usually a sorted array).

    Available options can be determined by checking for mib2c configuration
    files that begin with 'mfd-access-*'.

    Syntax: @eval $m2c_table_access = 'unsorted-external'@

 
    m2c_include_examples (currently '1')
    ------------------------------------------------------------------
    This variable determines whether or not to generate example code. The
    default is to generate example code.

    Syntax: @eval $m2c_include_examples = 0@


    m2c_data_transient (currently '2')
    ------------------------------------------------------------------
    This variable determines how the generated example code deals with the
    data during data lookup. See the table readme file for details on how
    the current table access method interprets this value. In general,
    a value of 0 indicates persistent data, 1 indicates semi-transient and
    2 indicates transient data.

    Syntax: @eval $m2c_data_transient = 0@


 Index(es) for the strModTable table
  ------------------------------------------------------------
  The index(es) for the strModTable table are:

     strModIdnum:
        Syntax:      UNSIGNED32
        DataType:    UNSIGNED32
        ASN type:    ASN_UNSIGNED
        C-code type: u_long

  You should know how to set all these values from your data context,
  strModTable_data.


************************************************************************
strModTable File Overview
------------------------------------------------------------------------
  Several files have been generated to implement the strModTable
  table. We'll go through these files, one by one, explaining each and
  letting you know which you need to edit.


File: strModTable_data_access.[c|h]
------------------------------------------------------------------------
  The strModTable_data_access file contains the interface to your data in
  its raw format.  These functions are used to build the row cache or 
  locate the row (depending on the table access method).

  Set MIB context
  -----------------
  TODO : Set MIB index values
  FUNC : strModTable_indexes_set
  WHERE: strModTable_data_access.c

  This is a convenience function for setting the index context from
  the native C data. Where necessary, value mapping should be done.

  This function should update the table index values (found in
  tbl_idx) for the given raw data.

  
  unsorted-external summary
  -------------------------
    The unsorted-external data access code is for cases when you data is
    kept UNSORTED and EXTERNAL to the agent/sub-agent.

    This code was generated based on the following assumptions or settings:

    1) The raw data for this table is UNSORTED.

       UNSORTED data is data that is not kept in the same order as the way
       SNMP expects the index(es) for the table to be kept. [It could very
       well be sorted in some other order, but for the purpose of SNMP, the
       order is incorrect.]  If you're not sure if your data is sorted
       in an SNMP compliant way, its likely not.

       Because the raw data is unsorted, to satisfy a particular request, the
       entire data set must be examined to find the apropriate index. This
       is done via a simple loop. The MFD handler will call your get_first
       function and the call the get_next function repeatedly, until it
       returns SNMPERR_NO_VARS.

    2) The raw data for this table is EXTERNAL.

       EXTERNAL data is data that is owned by some other process,
       device, file or mechanism.  The agent must use some interface to
       read or modify the data.  An external process may modify the data
       without the agent's knowledge. For example, the Net-SNMP agent
       implements the interface table (ifTable), which reports on
       network interfaces. The host operating system owns this data, and
       Net-SNMP must use system calls to report or manipulate the data.
       Examples of external data include data stored in kernel space, in
       files, in another non-memory shared process, and data stored in
       devices.

    3) The raw data for this table is TRANSIENT.

       TRANSIENT data is data that may be overwritten by another funtion
       or process. For example, many OS functions return data in a
       static buffer that will be reused the next time the function is
       called.  Because of this, we will assume that you will copy the
       raw data retrieved from these other sources to a generated
       structure for use within the Net-SNMP agent.  (Don't worry, we'll
       help you)


  The unsorted external data access code works by calling a few simple
  functions to get the index value for each row. Once the agent determines
  which row is needed to process an incoming request, another function
  is called to retrieve the data for that row.

  A simplified version of the pseudo-code looks like this:

     strModTable_loop_init_context(loop)
     strModTable_loop_get_first(loop,data)
     while( no_error ) {
        if( best_match(data, key)
           strModTable_loop_save_position(loop,pos);
        strModTable_loop_get_next(loop,data)
     }
     strModTable_loop_get_data(pos,data)
     strModTable_loop_cleanup_context(loop)

  We will talk about each individual step below.


  Defining context for the loop
  -----------------------------
    TODO : typedef strModTable_loop_context
    WHERE: strModTable_data_access.h

    Since the actual loop is in the MFD handler, a loop contex parameter
    is provided to help you keep track of where you are in between calls
    to functions that you wrote and the master MFD handler calls. The
    structure of this context is user defineable, and is defined in the
    file strModTable_data_access.h.

    E.G., if your data is stored in a linked list, the obvious thing you
    want to know from one function call to the next is your current
    position in the linked list.  Thus the easiest context to use is a
    pointer within the linked list.  For an array, the current index to
    that array would be easiest.

    The funtion calls are actually passed a reference to the loop
    context, to allow the loop context to be allocated memory. Here are
    some simple examples definitions for various data formats. These
    definitions are used in examples later on.

      Linked list
      -----------
          typedef list_node strModTable_loop_context;

      Array
      -----
          typedef integer strModTable_loop_context;

      File
      ----
          typedef struct strModTable_loop_context_s {
               char *      file_name;
               FILE *      f;
               char        line[128];
          } strModTable_loop_context;


  Initialization
  --------------
    TODO : Initialization
    FUNC : strModTable_loop_init_data
    WHERE: strModTable_data_access.c

    The strModTable_loop_init_data function will be called during startup to
    allow for any initialization needed for the data access routines.


  Preparing for the loop
  ----------------------
    TODO : initialize loop context
    FUNC : strModTable_loop_init_context
    WHERE: strModTable_data_access.c

    This function will be called before the start of a new itertion over
    the data. The loop context that is initialized here will be passed to
    strModTable_loop_get_first and strModTable_loop_get_next.
  
    Set the loop context variable ref->loop_ctx so that the iteration
    functions (get_first and get_next) can locate the apropriate data
    context.

    The primary purpose of the loop_init_context call  is to initialize
    the loop context data (ref). Here are some simple examples, based on the
    earlier example loop contexts.

      Linked list
      -----------
          ref->loop_ctx = my_table_head_ptr;

      Array
      -----
          /* instead of actually allocating memory, just use the pointer */
          /* as an integer */
          (integer)(ref->loop_ctx) = 0;

      File
      ----
          ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModTable_loop_context);
          /* error checking here */
          ref->loop_ctx->file_name = (char*) reg->mfd_user_ctx;
          ref->loop_ctx->f = fopen( ref->loop_ctx->file_name, "r+" );


  The Loop
  --------
    TODO : return raw data
    FUNC : strModTable_loop_get_first
    WHERE: strModTable_data_access.c

    This function is called to return set the index(es) for the first
    strModTable_data in the data set.

    Note that during the loop, the only important thing is the indexes.
    If access to your data is cheap/fast (e.g. you have a pointer to a
    structure in memory), it would make sense to update the data here.
    If, however, the accessing the data invovles more work (e.g. parsing
    some other existing data, or peforming calculations to derive the data),
    then you should limit yourslef to setting the indexes. Extracting the
    can be put off until the desired row is found See the notes on
    strModTable_loop_get_data().

    Note that this function does not correspond to a SNMP GET pdu, and
    you should return data items in whatever order they are already in.
    (In fact, if your data is already ordered in the same order as the
    SNMP indexes, you shouldn't be using the unsorted-access code).
  
    This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
    values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).

      Linked list
      -----------
          rowreq_ctx_ref->rowreq_ctx->data = loop_ctx_ref->loop_ctx;

      Array
      -----
          /* assuming registration has array of pointers */
          rowreq_ctx_ref->rowreq_ctx->data = reg->mfd_user_ctx[(integer)(ref->loop_ctx)];

      File
      ----
          fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                loop_ctx_ref->loop_ctx->f);
          rowreq_ctx_ref->rowreq_ctx->data = loop_ctx_ref->loop_ctx->line;


    TODO : return raw data
    FUNC : strModTable_loop_get_next
    WHERE: strModTable_data_access.c

    This function returns the next data item in the data set. The same
    caveat applies here as did above. The indexes are the important parts
    during loop processing.

    Note that this function does not correspond to a SNMP GET-NEXT pdu, and
    you should return data items in whatever order they are already in.
    (In fact, if your data is already ordered in the same order as the
    SNMP indexes, you shouldn't be using the unsorted-access code).

      Linked list
      -----------
          loop_ctx_ref->loop_ctx = loop_ctx_ref->loop_ctx->next;
          rowreq_ctx_ref->rowreq_ctx->data = loop_ctx_ref->loop_ctx;

      Array
      -----
          ++((integer)(ref->loop_ctx));
          /* assuming registration has array of pointers */
          rowreq_ctx_ref->rowreq_ctx->data = reg->mfd_user_ctx[(integer)(ref->loop_ctx)];

      File
      ----
          fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                loop_ctx_ref->loop_ctx->f);
          rowreq_ctx_ref->rowreq_ctx->data = loop_ctx_ref->loop_ctx->line;


  Updating the Index
  ------------------
    TODO : update index for the raw data
    FUNC : strModTable_indexes_set
    WHERE: strModTable_data_access.c

    This is a convenience function for setting the index context from
    the native C data. Where necessary, value mapping should be done.

    This function should update the table index values (found in
    tbl_idx) for the given raw data.


  Saving a position in the loop
  -----------------------------
    TODO : Saving a position in the loop
    FUNC : strModTable_loop_save_position
    WHERE: strModTable_data_access.c

    During loop iteration, the iterator keeps track of the row that
    is the current best match. This function is called when the
    current row is a better match than any previous row.
  
    You should save any information you need to be able to locate this row
    again from the current loop context to a new loop context.
  
    At the end of the loop, when the best match has been found, the saved
    loop context will be used to get the data for the row by calling
    strModTable_loop_get_data().
  
    Since your data is transient, you need to make a copy of it before
    the iterator moves on to the next row.


  Returning Data For an Index
  ---------------------------
    TODO : copy transient raw data to generated structure
    FUNC : strModTable_loop_get_data
    WHERE: strModTable_data_access.c

    At the end of the loop, when the best match has been found, the saved
    loop context will be used to get the data for the row by calling
    strModTable_loop_get_data().


  Cleaning up after the loop
  --------------------------
    TODO : release any allocated memory
    FUNC : strModTable_loop_cleanup_context
    WHERE: strModTable_data_access.c

    This function will be called once the loop iteration has completed
    to release any memory allocated for loop reference.
    The purpose of the loop_cleanup_context call is to release any memory
    allocated for the loop context data. Here are some simple examples, based
    on the earlier example loop contexts.

      Linked list
      -----------
          /* nothing to do */

      Array
      -----
          /* nothing to do */

      File
      ----
          free(ref->loop_ctx);




File: strModTable_enums.h
------------------------------------------------------------------------
  This file contains macros for mapping enumeration values when the
  enumerated values defined by the MIB do not match the values used
  internally.

  Review this file to see if any values need to be updated.


File: strModTable_data_get.c
------------------------------------------------------------------------
  Get data for column
  -------------------
  TODO : retrieve column data from raw data
  FUNC : strModName_get

  Get data for column
  -------------------
  TODO : retrieve column data from raw data
  FUNC : strModType_get

  Get data for column
  -------------------
  TODO : retrieve column data from raw data
  FUNC : strModMajor_get



File: strModTable_data_set.c
------------------------------------------------------------------------

  This table does not support set requests.


************************************************************************
strModTable Reference
------------------------------------------------------------------------

Function flow
----------------------------------------------------
To give you the general idea of how the functions flow works, this
example flow is from a complete table implementation.

NOTE: Depending on your configuration, some of the functions used in the
      examples below  may not have been generated for the
      strModTable table.

      Conversely, the examples below may not include some functions that
      were generated for the strModTable table.

To watch the flow of the strModTable table, use the
following debug tokens:

        snmp_agent
        helper:table:req
        strModTable
        verbose:strModTable
        internal:strModTable

e.g.
        snmpd -f -Le -DstrModTable,verbose:strModTable,internal:strModTable


Initialization
--------------------------------
init_xxxTable: called                           xxx.c
   initialize_table_xxxTable                    xxx.c
      _xxxTable_initialize_interface            xxx_interface.c
         xxxTable_init_data                     xxx_data_access.c
      _xxxTable_container_init                  xxx_interface.c
         xxxTable_container_init                xxx_data_access.c


GET Request
--------------------------------
_cache_load                                     xxx_interface.c
   xxxTable_cache_load                          xxx_data_access.c
      xxxTable_allocate_rowreq_ctx              xxx_interface.c
         xxxTable_allocate_data                 xxx_data_get.c
         xxxTable_rowreq_ctx_init               xxx_data_get.c
      xxxTable_indexes_set                      xxx_data_get.c
         xxxTable_indexes_set_tbl_idx           xxx_data_get.c

xxxTable_pre_request                              

_mfd_xxxTable_object_lookup                     xxx_interface.c
   xxxTable_row_prep                            xxx_data_access.c

_mfd_xxxTable_get_values                        xxx_interface.c
   _mfd_xxxTable_get_column                     xxx_interface.c
      yyy_get                                   xxx_data_get.c

xxxTable_post_request


GETNEXT Request
--------------------------------
_cache_load                                     ...
xxxTable_pre_request                            ...
_mfd_xxxTable_object_lookup                     ...
_mfd_xxxTable_get_values                        ...
xxxTable_post_request                           ...


SET Request: success
--------------------------------
_cache_load                                     ...
xxxTable_pre_request
_mfd_xxxTable_object_lookup                     ...

_mfd_xxxTable_check_objects                     xxx_interface.c
   _xxxTable_check_column                       xxx_interface.c
      yyy_check_value                           xxx_data_set.c

_mfd_xxxTable_undo_setup                        xxx_interface.c
   xxxTable_allocate_data                       ...
   xxxTable_undo_setup                          xxx_interface.c
      _xxxTable_undo_setup_column               xxx_interface.c
         yyy_undo_setup                         xxx_data_set.c

_mfd_xxxTable_set_values                        xxx_interface.c
   _xxxTable_set_column                         xxx_interface.c
      yyy_set                                   xxx_data_set.c

_mfd_xxxTable_check_dependencies                xxx_interface.c
   xxxTable_check_dependencies                  xxx_data_set.c

_mfd_xxxTable_commit                            xxx_interface.c
   xxxTable_commit                              xxx_data_set.c

_mfd_xxxTable_undo_cleanup                      xxx_interface.c
   xxxTable_undo_cleanup                        xxx_data_set.c
      xxxTable_release_data                     ...

xxxTable_post_request                           ...


SET Request: row creation
--------------------------------
_cache_load                                     ...
xxxTable_pre_request

_mfd_xxxTable_object_lookup                     ...
   xxxTable_index_from_oid                      xxx_interface.c
   xxxTable_allocate_rowreq_ctx                 ...
      ...
   _xxxTable_check_indexes                      xxx_interface.c
      yyy_check_index                           xxx_data_set.c
      xxxTable_validate_index                   xxx_data_set.c

_mfd_xxxTable_check_objects                     ...
   _xxxTable_check_column                       ...
      yyy_check_value                           ...
   _xxxTable_check_column                       ...
      yyy_check_value                           ...

_mfd_xxxTable_undo_setup                        ...
_mfd_xxxTable_set_values                        ...
_mfd_xxxTable_check_dependencies                ...
_mfd_xxxTable_commit                            ...
_mfd_xxxTable_undo_cleanup                      ...
xxxTable_post_request                           ...


SET Resuest: value error
--------------------------------
_cache_load                                     ...
xxxTable_pre_request                            ...
_mfd_xxxTable_object_lookup                     ...

_mfd_xxxTable_check_objects                     ...
   _xxxTable_check_column                       ...
      yyy_check_value                           ...
      ERROR:"yyy value not supported"

xxxTable_post_request                           ...


SET Request: commit failure
--------------------------------
_cache_load                                     ...
xxxTable_pre_request                            ...
_mfd_xxxTable_object_lookup                     ...
_mfd_xxxTable_check_objects                     ...
_mfd_xxxTable_undo_setup                        ...
_mfd_xxxTable_set_values                        ...
_mfd_xxxTable_check_dependencies                ...

_mfd_xxxTable_commit                            ...
   xxxTable_commit                              ...
   ERROR: bad rc -1

_mfd_xxxTable_undo_commit                       xxx_interface.c
   xxxTable_undo_commit                         xxx_data_set.c

_mfd_xxxTable_undo_values                       xxx_interface.c
   _xxxTable_undo_column                        xxx_interface.c
      yyy_undo                                  xxx_data_set.c

_mfd_xxxTable_undo_cleanup                      ...
xxxTable_post_request                           ...


Row release (user initiated)
--------------------------------
xxxTable_release_rowreq_ctx                     xxx_interface.c
   xxxTable_rowreq_ctx_cleanup                  xxx_data_get.c
   xxxTable_release_data                        xxx_data_get.c



Table / column details
----------------------------------------------------
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModTable is subid 1 of strMod.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1, length: 14
*/

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModIdnum
 * strModIdnum is subid 1 of strModEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.1
 * Description:
Indicates the driver or module STREAMS module id.  The 
		 STREAMS module id is unique within the entire system 
		 and is used as an index to this and other tables.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE strModIdnum IS NOT ACCESSIBLE
 *
 *
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModName
 * strModName is subid 2 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.2
 * Description:
Indicates the name of the STREAMS driver or module as an 
		 index into the table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 1a
 *
 * Ranges:  1 - 8;
 *
 * Its syntax is StreamsModuleName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 8)
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModType
 * strModType is subid 3 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.3
 * Description:
Indicates the type of the object, whether a STREAMS 
		 driver or module.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 1/8. Values:  module(1), driver(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModMajor
 * strModMajor is subid 4 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.4
 * Description:
Indicates the major device number of a STREAMS driver or 
		 zero (0) for a STREAMS module.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */


