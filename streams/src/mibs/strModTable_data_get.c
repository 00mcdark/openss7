/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.20 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "strModTable.h"

/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement strModTable get routines.
 * TODO:240:M: Implement strModTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModTable is subid 1 of strMod.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strModTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strModTable_indexes_set_tbl_idx(strModTable_mib_index * tbl_idx, u_long strModIdnum_val)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_indexes_set_tbl_idx", "called\n"));

        /* strModIdnum(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strModIdnum = strModIdnum_val;

        return MFD_SUCCESS;
}                               /* strModTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strModTable_indexes_set(strModTable_rowreq_ctx * rowreq_ctx, u_long strModIdnum_val)
{
        DEBUGMSGTL(("verbose:strModTable:strModTable_indexes_set", "called\n"));

        if (MFD_SUCCESS != strModTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strModIdnum_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strModTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strModTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModName
 * strModName is subid 2 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.2
 * Description:
Indicates the name of the STREAMS driver or module as an 
		 index into the table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 1a
 *
 * Ranges:  1 - 8;
 *
 * Its syntax is StreamsModuleName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 8)
 */
/**
 * Extract the current value of the strModName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param strModName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by strModName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*strModName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update strModName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
strModName_get(strModTable_rowreq_ctx * rowreq_ctx, char **strModName_val_ptr_ptr,
               size_t *strModName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
        netsnmp_assert((NULL != strModName_val_ptr_ptr) && (NULL != *strModName_val_ptr_ptr));
        netsnmp_assert(NULL != strModName_val_ptr_len_ptr);

        DEBUGMSGTL(("verbose:strModTable:strModName_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModName data.
 * copy (* strModName_val_ptr_ptr ) data and (* strModName_val_ptr_len_ptr ) from rowreq_ctx->data
 */
        /*
         * make sure there is enough space for strModName data
         */
        if ((NULL == (*strModName_val_ptr_ptr)) ||
            ((*strModName_val_ptr_len_ptr) <
             (rowreq_ctx->data.strModName_len * sizeof(rowreq_ctx->data.strModName[0])))) {
                /*
                 * allocate space for strModName data
                 */
                (*strModName_val_ptr_ptr) =
                    malloc(rowreq_ctx->data.strModName_len *
                           sizeof(rowreq_ctx->data.strModName[0]));
                if (NULL == (*strModName_val_ptr_ptr)) {
                        snmp_log(LOG_ERR, "could not allocate memory\n");
                        return MFD_ERROR;
                }
        }
        (*strModName_val_ptr_len_ptr) =
            rowreq_ctx->data.strModName_len * sizeof(rowreq_ctx->data.strModName[0]);
        memcpy((*strModName_val_ptr_ptr), rowreq_ctx->data.strModName,
               rowreq_ctx->data.strModName_len * sizeof(rowreq_ctx->data.strModName[0]));

        return MFD_SUCCESS;
}                               /* strModName_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModType
 * strModType is subid 3 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.3
 * Description:
Indicates the type of the object, whether a STREAMS 
		 driver or module.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 1/8. Values:  module(1), driver(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the strModType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModType_get(strModTable_rowreq_ctx * rowreq_ctx, u_long * strModType_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModType_val_ptr);

        DEBUGMSGTL(("verbose:strModTable:strModType_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModType data.
 * copy (* strModType_val_ptr ) from rowreq_ctx->data
 */
        (*strModType_val_ptr) = rowreq_ctx->data.strModType;

        return MFD_SUCCESS;
}                               /* strModType_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strModEntry.strModMajor
 * strModMajor is subid 4 of strModEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.1.1.1.4
 * Description:
Indicates the major device number of a STREAMS driver or 
		 zero (0) for a STREAMS module.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strModMajor data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strModMajor_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strModMajor_get(strModTable_rowreq_ctx * rowreq_ctx, u_long * strModMajor_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strModMajor_val_ptr);

        DEBUGMSGTL(("verbose:strModTable:strModMajor_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strModMajor data.
 * copy (* strModMajor_val_ptr ) from rowreq_ctx->data
 */
        (*strModMajor_val_ptr) = rowreq_ctx->data.strModMajor;

        return MFD_SUCCESS;
}                               /* strModMajor_get */

/** @} */
