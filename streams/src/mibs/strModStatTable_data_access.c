/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-data-access.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "strModStatTable.h"

#include "strModStatTable_data_access.h"

/** @defgroup data_access data_access: Routines to access data
 *
 * These routines are used to locate the data used to satisfy
 * requests.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strModStatTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strModStatTable is subid 1 of strModStat.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.3.1, length: 14
*/

/**
 * initialization for strModStatTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param strModStatTable_reg
 *        Pointer to strModStatTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
strModStatTable_init_data(strModStatTable_registration * strModStatTable_reg)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_init_data", "called\n"));

        /*
         * TODO:303:o: Initialize strModStatTable data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * if you are the sole writer for the file, you could
         * open it here. However, as stated earlier, we are assuming
         * the worst case, which in this case means that the file is
         * written to by someone else, and might not even exist when
         * we start up. So we can't do anything here.
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_init_data */

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    strModStatTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          strModStatTable_loop_save_position(loop,pos);
 *       strModStatTable_loop_get_next(loop,data)
 *    }
 *    strModStatTable_loop_get_data(pos,data)
 *    strModStatTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  strModStatTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  strModStatTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and its indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  strModStatTable_loop_init_context, save it in your
 *  strModStatTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  strModStatTable_loop_get_next, and simply call that function.]
 *
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
strModStatTable_loop_get_first(strModStatTable_registration * strModStatTable_reg,
                               strModStatTable_ref_loop_ctx * loop_ctx_ref,
                               strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_get_first", "called\n"));

        netsnmp_assert(rowreq_ctx_ref);
        netsnmp_assert(loop_ctx_ref);

        /*
         * allocate memory for new structure
         */
        loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModStatTable_loop_context);
        if (NULL == loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * allocate a temporary context to use during iteration
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = strModStatTable_allocate_rowreq_ctx(NULL);
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                SNMP_FREE(loop_ctx_ref->loop_ctx);
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         * TODO:
         * set up loop context
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * open our data file.
         */
        loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
        if (NULL == loop_ctx_ref->loop_ctx->filep) {
                return MFD_RESOURCE_UNAVAILABLE;
        }

        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * in this example, after opening the file, get next does the same thing
         * as get first, we let's just call get next...
         */
        return strModStatTable_loop_get_next(strModStatTable_reg, loop_ctx_ref, rowreq_ctx_ref);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_get_first */

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in strModStatTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
strModStatTable_loop_get_next(strModStatTable_registration * strModStatTable_reg,
                              strModStatTable_ref_loop_ctx * loop_ctx_ref,
                              strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_get_next", "called\n"));

        netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
        netsnmp_assert(rowreq_ctx_ref);

        /*
         * we just need the index for now. Reuse the one in the loop context's
         * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * get a line (skip blank lines)
         */
        do {
                if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                           loop_ctx_ref->loop_ctx->filep)) {
                        /* we're done */
                        fclose(loop_ctx_ref->loop_ctx->filep);
                        loop_ctx_ref->loop_ctx->filep = NULL;
                }
        } while (loop_ctx_ref->loop_ctx->filep && (loop_ctx_ref->loop_ctx->line[0] == '\n'));

        /*
         * check for end of data
         */
        if (NULL == loop_ctx_ref->loop_ctx->filep)
                return MFD_END_OF_DATA;

        /*
         * TODO:
         * set local vars for index from loop_ctx_ref->loop_ctx
         *  this can be done in one of two ways:
         */

        /*
         * 1) individually
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModIdnum
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->strModStatIndex
         */

        /*
         * OR
         */

        /*
         * 2) by calling strModStatTable_indexes_set()
         * strModStatTable_indexes_set(rowreq_ctx_ref->tbl_idx,
         *       strModIdnum
         *       strModStatIndex
         *      );
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_get_next */

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModStatTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModStatTable_loop_save_position(strModStatTable_registration * strModStatTable_reg,
                                   strModStatTable_ref_loop_ctx * loop_ctx_ref,
                                   strModStatTable_ref_loop_ctx * save_loop_ctx_ref, int reuse)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_save_position", "called\n"));

        netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

        /*
         * TODO:
         * 1) allocate new loop context, unless you can reuse a previous pointer.
         * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
         */
        if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
                save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(strModStatTable_loop_context);
        if (NULL == save_loop_ctx_ref->loop_ctx) {
                snmp_log(LOG_ERR, "could not allocate memory\n");
                return MFD_ERROR;
        }

        /*
         * if you can reuse a previously saved contex, just swap
         * it out with the loop iterator
         */
        if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
                strModStatTable_rowreq_ctx *tmp_rowreq_ctx =
                    save_loop_ctx_ref->loop_ctx->rowreq_ctx;
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
                loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
        } else {
                /*
                 * take the current pointer
                 */
                save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

                /*
                 * allocate a new context to replace the one you just took.
                 */
                loop_ctx_ref->loop_ctx->rowreq_ctx = strModStatTable_allocate_rowreq_ctx(NULL);
                if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
                        SNMP_FREE(loop_ctx_ref->loop_ctx);
                        return MFD_ERROR;
                }
        }

        /*
         * TRANSIENT data: copy all the data.
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatQueues
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatPCnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatScnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatOcnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatCcnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatAcnt
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate
         *     from the loop context
         */
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->data.strModStatFlags
         *     from the loop context
         */
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_save_position */

/**
 * set strModStatTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  strModStatTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
strModStatTable_loop_get_data(strModStatTable_registration * strModStatTable_reg,
                              strModStatTable_ref_loop_ctx * loop_ctx_ref,
                              strModStatTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_get_data", "called\n"));

        netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
        netsnmp_assert(NULL != rowreq_ctx_ref);
        netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

        /*
         * take temporary row request context from loop context
         */
        rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

        /*
         * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
         * in loop_save_position, we saved line to do that
         */
#if 0
        /*
         * strModStatQueues(2)/StreamsModuleQueues/ASN_OCTET_STR/char(u_long)//L/A/w/E/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatQueues =
            loop_ctx_ref->loop_ctx->strModStatQueues;

        /*
         * strModStatPCnt(3)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatPCnt = loop_ctx_ref->loop_ctx->strModStatPCnt;

        /*
         * strModStatScnt(4)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatScnt = loop_ctx_ref->loop_ctx->strModStatScnt;

        /*
         * strModStatOcnt(5)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatOcnt = loop_ctx_ref->loop_ctx->strModStatOcnt;

        /*
         * strModStatCcnt(6)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatCcnt = loop_ctx_ref->loop_ctx->strModStatCcnt;

        /*
         * strModStatAcnt(7)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatAcnt = loop_ctx_ref->loop_ctx->strModStatAcnt;

        /*
         * strModStatPrivate(8)/OCTETSTR/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h
         */
    /** no mapping */
        /*
         * make sure there is enough space for strModStatPrivate data
         */
        if ((NULL == rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate) ||
            (rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate_len <
             (loop_ctx_ref->loop_ctx->strModStatPrivate_len *
              sizeof(loop_ctx_ref->loop_ctx->strModStatPrivate[0])))) {
                snmp_log(LOG_ERR, "not enough space for value\n");
                return MFD_ERROR;
        }
        rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate_len =
            loop_ctx_ref->loop_ctx->strModStatPrivate_len *
            sizeof(loop_ctx_ref->loop_ctx->strModStatPrivate[0]);
        memcpy(rowreq_ctx_ref->rowreq_ctx->data.strModStatPrivate,
               loop_ctx_ref->loop_ctx->strModStatPrivate,
               loop_ctx_ref->loop_ctx->strModStatPrivate_len *
               sizeof(loop_ctx_ref->loop_ctx->strModStatPrivate[0]));

        /*
         * strModStatFlags(9)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/w/e/r/d/h
         */
    /** no mapping */
        rowreq_ctx_ref->rowreq_ctx->data.strModStatFlags = loop_ctx_ref->loop_ctx->strModStatFlags;
#endif

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_get_data */

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param strModStatTable_reg Pointer to a strModStatTable_registration *
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
strModStatTable_loop_cleanup_context(strModStatTable_registration * strModStatTable_reg,
                                     strModStatTable_ref_loop_ctx * loop_ctx_ref)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_loop_cleanup_context", "called\n"));

        netsnmp_assert(loop_ctx_ref);

        if (!loop_ctx_ref->loop_ctx)
                return MFD_ERROR;

        /*
         * release the row request context, if it wasn't taken
         */
        if (loop_ctx_ref->loop_ctx->rowreq_ctx)
                strModStatTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

        /*
         * TODO:
         * release resources
         */
        /*
         ***************************************************
         ***             START EXAMPLE CODE              ***
         ***---------------------------------------------***/
        /*
         * close file
         */
        if (loop_ctx_ref->loop_ctx->filep)
                fclose(loop_ctx_ref->loop_ctx->filep);
        /*
         ***---------------------------------------------***
         ***              END  EXAMPLE CODE              ***
         ***************************************************/

        /*
         * free loop context
         */
        free(loop_ctx_ref->loop_ctx);

        return MFD_SUCCESS;
}                               /* strModStatTable_loop_cleanup_context */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
strModStatTable_row_prep(strModStatTable_rowreq_ctx * rowreq_ctx)
{
        DEBUGMSGTL(("verbose:strModStatTable:strModStatTable_row_prep", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

        /*
         * TODO:390:o: Prepare row for request.
         * If populating row data was delayed, this is the place to
         * fill in the row for this request.
         */

        return MFD_SUCCESS;
}                               /* strModStatTable_row_prep */

/** @} */
