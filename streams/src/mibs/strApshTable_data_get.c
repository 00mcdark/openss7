/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.20 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "strApshTable.h"

/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement strApshTable get routines.
 * TODO:240:M: Implement strApshTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table strApshTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * OPENSS7-STREAMS-MIB::strApshTable is subid 1 of strApsh.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1, length: 14
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement strApshTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
strApshTable_indexes_set_tbl_idx(strApshTable_mib_index * tbl_idx, char *strApshName_val_ptr,
                                 size_t strApshName_val_ptr_len, u_long strApshMinor_val)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_indexes_set_tbl_idx", "called\n"));

        /* strApshName(1)/StreamsModuleName/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/H */
        tbl_idx->strApshName_len = sizeof(tbl_idx->strApshName) / sizeof(tbl_idx->strApshName[0]);      /* max length */
        /*
         * make sure there is enough space for strApshName data
         */
        if ((NULL == tbl_idx->strApshName) ||
            (tbl_idx->strApshName_len < (strApshName_val_ptr_len))) {
                snmp_log(LOG_ERR, "not enough space for value\n");
                return MFD_ERROR;
        }
        tbl_idx->strApshName_len = strApshName_val_ptr_len;
        memcpy(tbl_idx->strApshName, strApshName_val_ptr,
               strApshName_val_ptr_len * sizeof(strApshName_val_ptr[0]));

        /* strApshMinor(3)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h */
        tbl_idx->strApshMinor = strApshMinor_val;

        return MFD_SUCCESS;
}                               /* strApshTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
strApshTable_indexes_set(strApshTable_rowreq_ctx * rowreq_ctx, char *strApshName_val_ptr,
                         size_t strApshName_val_ptr_len, u_long strApshMinor_val)
{
        DEBUGMSGTL(("verbose:strApshTable:strApshTable_indexes_set", "called\n"));

        if (MFD_SUCCESS !=
            strApshTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, strApshName_val_ptr,
                                             strApshName_val_ptr_len, strApshMinor_val))
                return MFD_ERROR;

        /*
         * convert mib index to oid index
         */
        rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
        if (0 != strApshTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
                return MFD_ERROR;
        }

        return MFD_SUCCESS;
}                               /* strApshTable_indexes_set */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshMajor
 * strApshMajor is subid 2 of strApshEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.2
 * Description:
Provides the primary majro device number associated 
		 with the driver.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the strApshMajor data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strApshMajor_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strApshMajor_get(strApshTable_rowreq_ctx * rowreq_ctx, u_long * strApshMajor_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strApshMajor_val_ptr);

        DEBUGMSGTL(("verbose:strApshTable:strApshMajor_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strApshMajor data.
 * copy (* strApshMajor_val_ptr ) from rowreq_ctx->data
 */
        (*strApshMajor_val_ptr) = rowreq_ctx->data.strApshMajor;

        return MFD_SUCCESS;
}                               /* strApshMajor_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshLastMinor
 * strApshLastMinor is subid 4 of strApshEntry.
 * Its status is Current, and its access level is NoAccess.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.4
 * Description:
Provides the last minor device number in a range.  This 
		 value is always zero (0) when the Minor number is 
		 'FFFFFFFF'X.  The agent must ensure that the range 
		 specified by this number does not overlap with other 
		 ranges specified in this autopush specification entry.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 16383;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE strApshLastMinor IS NOT ACCESSIBLE
 *
 *
 */
/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshModules
 * strApshModules is subid 5 of strApshEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.5
 * Description:
Provides a STREAMS module list flowing the 
		 StreamsModuleList textual convention.  This is a 
		 space-separated list of Streams module names.  When 
		 this entry is created, it is persistent accross agent 
		 reboots, and might first be verified by the agent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 1a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is StreamsModuleList (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the strApshModules data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strApshModules_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param strApshModules_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by strApshModules.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*strApshModules_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update strApshModules_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
strApshModules_get(strApshTable_rowreq_ctx * rowreq_ctx, char **strApshModules_val_ptr_ptr,
                   size_t *strApshModules_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
        netsnmp_assert((NULL != strApshModules_val_ptr_ptr)
                       && (NULL != *strApshModules_val_ptr_ptr));
        netsnmp_assert(NULL != strApshModules_val_ptr_len_ptr);

        DEBUGMSGTL(("verbose:strApshTable:strApshModules_get", "called\n"));

        netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the strApshModules data.
 * copy (* strApshModules_val_ptr_ptr ) data and (* strApshModules_val_ptr_len_ptr ) from rowreq_ctx->data
 */
        /*
         * make sure there is enough space for strApshModules data
         */
        if ((NULL == (*strApshModules_val_ptr_ptr)) ||
            ((*strApshModules_val_ptr_len_ptr) <
             (rowreq_ctx->data.strApshModules_len * sizeof(rowreq_ctx->data.strApshModules[0])))) {
                /*
                 * allocate space for strApshModules data
                 */
                (*strApshModules_val_ptr_ptr) =
                    malloc(rowreq_ctx->data.strApshModules_len *
                           sizeof(rowreq_ctx->data.strApshModules[0]));
                if (NULL == (*strApshModules_val_ptr_ptr)) {
                        snmp_log(LOG_ERR, "could not allocate memory\n");
                        return MFD_ERROR;
                }
        }
        (*strApshModules_val_ptr_len_ptr) =
            rowreq_ctx->data.strApshModules_len * sizeof(rowreq_ctx->data.strApshModules[0]);
        memcpy((*strApshModules_val_ptr_ptr), rowreq_ctx->data.strApshModules,
               rowreq_ctx->data.strApshModules_len * sizeof(rowreq_ctx->data.strApshModules[0]));

        return MFD_SUCCESS;
}                               /* strApshModules_get */

/*---------------------------------------------------------------------
 * OPENSS7-STREAMS-MIB::strApshEntry.strApshStatus
 * strApshStatus is subid 6 of strApshEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.29591.1.1.1.1.1.4.1.1.6
 * Description:
Provides management stations with the ability to add 
		 rows to, or delete rows from, the STREAMS autopush table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the strApshStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param strApshStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
strApshStatus_get(strApshTable_rowreq_ctx * rowreq_ctx, u_long * strApshStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
        netsnmp_assert(NULL != strApshStatus_val_ptr);

        (*strApshStatus_val_ptr) = rowreq_ctx->data.strApshStatus;

        return MFD_SUCCESS;
}                               /* strApshStatus_get */

/** @} */
