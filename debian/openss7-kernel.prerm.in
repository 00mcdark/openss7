#!/bin/sh
# @configure_input@
# =============================================================================
# 
# @(#) $RCSfile$ $Name$($Revision$) $Date$
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2008-2011  Monavacon Limited <http://www.monavacon.com/>
# Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>, or write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date$ by $Author$
#
# =============================================================================
subpkg=kernel
@openss7_header@
datarootdir=@datarootdir@
# -----------------------------------------------------------------------------
# Auxiliary functions:
# -----------------------------------------------------------------------------
#
# prerm_modules_remove(), prerm_modules_replace() - For older 2.4 module
#   systems, we cannot perform weak updates, so the simplification is that
#   modules only apply to the kernel for which they were built.  In this case
#   preparing for module removal consists of moving the kernel modules out of
#   the way, performing a depmod (so that dependencies no longer include the
#   modules) and then placing them back (where they can be backed-up during
#   upgrade).  This cannot work under weak-updates because the situation is more
#   complex, so the openss7-modules awk script performs this function instead
#   for 2.6 module systems.
#
prerm_modules_remove () { :
    if [ -d @kmoduledir@/@ksubdir@ ]; then
	mkdir -p /var/run/${name}.$$
	cp -a @kmoduledir@/@ksubdir@ /var/run/${name}.$$/
	rm -fr -- @kmoduledir@/@ksubdir@
    fi
}
prerm_modules_replace () { :
    if [ -d /var/run/${name}.$$/@ksubdir@ ]; then
	cp -a /var/run/${name}.$$/@ksubdir@ @kmoduledir@/
	rm -fr -- /var/run/${name}.$$
    fi
}
#
# prerm_depmod() - Perform a depmod on the kernel, particularly when it is the
#   running kernel, so that the removed modules are also removed from the module
#   dependencies generated by depmod.  Move them temporarily out of the way,
#   perform the depmod, and then move them back.  Also invoked when the removal
#   or upgrade process fails so that dependencies of the installed modules are
#   restored.
#
prerm_depmod () { :
    if which depmod >/dev/null 2>&1; then
	if [ "@kversion@" = "`uname -r`" ] ; then
	    if [ -r @ksysmap@ ]
	    then depmod -ae -F @ksysmap@ 2>&1 || :
	    else depmod -ae 2>&1 || :
	    fi
	elif [ -r @ksysmap@ ] ; then
	    UNAME_MACHINE=@target_cpu@ \
	    depmod -ae -F @ksysmap@ @kversion@ 2>&1 || :
	fi
    fi
    :
    return 0
}
#
# prerm_stop_scripts() - Stop init scripts when they are still hanging around.
#   Note that when the init scripts are already stopped this has no (negative)
#   effect.  Note that our previous practice of stopping init scripts when
#   removing or upgrading modules is questionable and possibly too disruptive to
#   a running system.  Instead of stopping init scripts, the user should be
#   warned that restarting the subsystems might be required.  Under debian we
#   can use debconf for this purpose too.
#
prerm_stop_scripts () { :
    reverse=
    list="${initfiles}" ; for i in $list ; do
        reverse="$i${reverse:+ }$reverse"
    done
    for i in $reverse ; do
        if [ -f @initrddir@/$i ] ; then
            /sbin/service $i stop >/dev/null 2>&1 || \
		@initrddir@/$i stop >/dev/null 2>&1 || :
        fi
    done
    :
    return 0
}
#
# Under RPM (rpm is very bad with installation order and prerequisites) we used
# to have to perform some of the functions of the init scripts to shut down the
# STREAMS subsystem because stupid RPM would remove the -base subpackage
# (containing the init scripts) before removing the -kernel subpackage.  The
# functions that follow basically do that.  prerm_kill_daemons shuts down the
# strace and strerr logging daemons, prerm_umount_specfs unmounts the specfs
# filesystem (so /dev/streams is no longer accessible), prerm_rmnods removes the
# (external) streams devices from /dev, prerm_kill_streams kills all processes
# holding open a stream, and remove_depends attempts to remove the currently
# loaded kernel modules.  If any of these actions fail (e.g. a client module has
# permanent links under a multiplexing driver), then the user is told that a
# reboot is required.
#
# Probably a better approach for automatic repository-based upgrades is to leave
# the system running, but as most older 2.4 systems do not really have any
# repository access, update is manual and performing these actions simply avoids
# having to type them in manually.
#
#
# prerm_kill_daemons() - Kill daemons with prejudice.  Stopping init scripts
#   should have stopped these daemons already.  One situation is where init
#   scripts have been removed already (or not fully installed) without stopping
#   them.
#
prerm_kill_daemons () { :
    reverse=
    list="${initfiles}" ; for i in $list ; do
	reverse="${i}${reverse:+ }${reverse}"
    done
    for i in $reverse ; do
	n=`echo "$i" | sed -e 's,\.sh$,,'`
	if [ -r /var/run/${n}.pid ] ; then
	    kill -TERM `cat /var/run/${n}.pid` || :
	    rm -f /var/run/${n}.pid
	    rm -f /var/lock/subsys/${n}
	    rm -f /var/lock/subsys/${n}.init
	fi
    done
    :
    return 0
}
#
# prerm_umount_specfs() - Unmount the Special Shadow Filesystem, making device
#  nodes in the /dev/streams directory no longer available.
#
prerm_umount_specfs () { :
    umount -a -t specfs
    return $?
}
#
# prerm_rmnods() - Remove device nodes in the /dev directory.
#
prerm_rmnods () { :
    if [ -x "@sbindir@/@STRCONF_DEVICES@" ]; then
	echo "${package}: removing old devices."
	@sbindir@/@STRCONF_DEVICES@ --remove || :
    fi
    return 0
}
#
# prerm_kill_streams() - Uses lsof to determine which processes are holding
#   opens STREAMS drivers and sends those processes a TERM signal followed five
#   seconds later by a KILL signal if the process still exists.  This ensures
#   that all STREAMS drivers are closed.  When the specfs is unmounted and
#   STREAMS devices removed before this operation is performed, killed processes
#   that respawn will be unable to reopen the STREAMS drivers because the device
#   nodes no longer exist.  Note that this is not infalable: when STREAMS are
#   permanently linked beneath a multiplexing driver,  it may still be
#   impossible to remove all STREAMS kernel modules.
#
prerm_kill_streams () { :
    if lsof | grep '\<STR\>' >/dev/null 2>&1 ; then
        if [ -x @sbindir@/fdetach ] ; then
            @sbindir@/fdetach -a 2>/dev/null || :
        fi
        for signal in TERM KILL ; do
            if lsof | grep '\<STR\>' >/dev/null 2>&1 ; then
                lsof | grep '\<STR\>' | \
                while read fields ; do
                    set -- $fields
                    if [ ":$5" != ':CHR' ] ; then continue; fi
                    ind=`expr $# - 1`
                    eval "val=\"\${$ind}\""
                    if [ ":$val" != ':STR' ] ; then continue; fi
                    kill -$signal $2 >/dev/null 2>&1 || :
                done
                sleep 5
            fi
        done
    fi
    lsof | grep '\<STR\>' >/dev/null 2>&1 && false || true
    return $?
}
#
# remove_depends() - A recursive function that peforms a depth first traversal
#   of the dependency graph rooted at the kernel module supplied as an argument,
#   removing modules that have no dependents.  This is so that entire kernel
#   module stacks can be removed.
#
remove_depends () {
    local modrex depend depends
    modrex=`echo $1 | sed -e 's,[-_],[-_],g'`
    depends=`grep "^$modrex[[:space:]]" /proc/modules 2>/dev/null | cut -f4 '-d ' | sed -e 's|^-$||;s|,$||;s|,| |g'`
    for depend in $depends ; do
        remove_depends $depend || return $?
    done
    if grep "^$modrex[[:space:]]" /proc/modules >/dev/null 2>&1 ; then
        rmmod $1 >/dev/null 2>&1 || return $?
    fi
    return 0
}
prerm_kill () {
    local reboot='no'
    prerm_stop_scripts	    || :
    prerm_kill_daemons	    || :
    prerm_umount_specfs	    || reboot='yes'
    prerm_rmnods	    || :
    prerm_kill_streams	    || reboot='yes'
    remove_depends streams  || reboot='yes'
    remove_depends specfs   || reboot='yes'
    if [ ":$reboot" = ':yes' ] ; then
	echo "$script: reboot required." >&2
    fi
    :
    return 0
}
prerm_kill_running () { :
    if [ "@kversion@" = "`uname -r`" ]; then
	prerm_kill || :
    fi
    :
    return 0
}
#
# The --delete-modules option to the openss7-modules awk script denotes that
# kernel modules are to be removed from @kmoduledir@/@ksubdir@ and
# --remove-modules denotes that weak links in any other subtree that point to
# or are relinked versions of the to be removed modules are to be removed as
# well.  After the removal, depmod is performed on the directories with removed
# links or modules to update dependencies.  This does not consider whether a
# given kernel directory is for the running kernel or not when removing links
# and modules; however, some information is provided in the return code.
# Nevertheless, this is not the proper place to process the return code.
#
prerm_updates () { :
    local retval=0
    if [ -x "@sbindir@/${name}-modules" ] ; then
	@sbindir@/${name}-modules -- -q -e \
	    --delete-modules \
	    --remove-modules @kversion@ || :
    fi
    :
    return 0
}
prerm_kernel () { :
    @WITH_KO_MODULES_FALSE@prerm_modules_remove || :
    @WITH_KO_MODULES_FALSE@prerm_depmod || :
    @WITH_KO_MODULES_FALSE@prerm_modules_replace || :
    @WITH_KO_MODULES_FALSE@prerm_kill_running || :
    @WITH_KO_MODULES_TRUE@prerm_updates || :
    return 0
}
prerm_kernel_failed () { :
    @WITH_KO_MODULES_FALSE@prerm_depmod || return $?
    @WITH_KO_MODULES_TRUE@prerm_restore || return $?
    return 0
}
#   xxx-prerm remove
#	- package's files removed (except conffiles)
#   xxx-postrm remove
#	- all scripts except postrm removed
#   xxx-postrm purge
#	- file list removed
#
# The prerm script will:
#
# 1.  Remove any weak links to the modules that are about to be removed (for
#     kernels other than @kversion@) by calling openss7-update --remove-modules
#     @kversion@.  This may as last step remove the modules themselves.  The
#     openss7-update script can be passed the EVR of the modules so that they
#     may be identified by their srcversion.
# 2.  If the running kernel was linked to the modules being removed, those
#     symbolic links must be removed and a depmod performed so that the running
#     kernel will not attempt to load any modules that are about to be
#     installed.  Note that this may result in an error because client modules
#     may be present.
# 3.  Do not stop any running subsystems regardless of whether @kversion@ is the
#     running kernel.
#
# The postrm script will:
#
# 1.  Do nothing.
#
prerm_kernel_remove () { :
    prerm_kernel
}
#   old-prerm upgrade new-version
#   new-preinst upgrade old-version
#	- files are unpacked, backups of old files
#   old-postrm upgrade new-version
#	- old files not in new version are removed
#	- new files list replaces old
#	- new scripts replace old
#	- backup files are deleted
#	- "Unpacked" state
#   new-postinst configure [most-recently-configured-version]
#
# This is an upgrade of the package for @kversion@.  An older version of the
# package is installed.  Actions that need to be performed are as follows:
#
# The prerm script will:
#
# 1.  Remove openss7 modules and any weak links to those modules (for kernels
#     other than @kversion@) by calling openss7-update --remove-modules
#     @kversion@.
# 2.  If the running kernel was linked to the modules being removed, those
#     symbolic links must be removed and a depmod performed so that the running
#     kernel will not attempt to load any modules that are about to be
#     installed.  Note that this may result in an error because client modules
#     may be present.
# 3.  Do not stop any running subsystems regardless of whether @kversion@ is the
#     running kernel.
#
# The preinst script will:
#
# 1.  Remove any weak links by calling openss7-update --remove-kernel
#     @kversion@.
# 2.  Perform a depmod so that no attempt is made to load the kernel modules
#     that are about to be installed.  Note that this may result in an error
#     because client modules may be present.
# 3.  Do not stop any running subsystems regardless of whether @kversion@ is the
#     running kernel.
# 4.  Touch /.openss7-update-@kversion@ to indicate to init scripts that
#     openss7-update --boot-kernel @kversion@ should be run on reboot.
#
# The postrm script will:
#
# 1.  Do nothing.  The new modules could be relinked at this stage, but it is
#     not wise to use scripts is a questionable state to relink newer version
#     modules.
#
# The postinst script will:
#
# 1.  Relink installed kernel modules for the running kernel if required.
# 2.  Perform a weak update using openss7-update --add-modules @kversion@.  Note
#     that this will not affect the running kernel when @kversion@ is other than
#     the running kernel.
# 3.  Perform a depmod so that kernel module dependencies are proper.
# 4.  Can start init scripts for the running kernel if desired and they are not
#     already running.  The user can be prompted using debconf.
# 5.  If init scripts are running or kernel modules are loaded and the
#     installation is for the running kernel, warn the user that a restart of
#     the STREAMS subsystems is recommended.  The user can be prompted using
#     debconf.
#
# Note that if the package is not configured, kernel modules will be installed
# in the directories; however, they will not be included in the depmod files and
# therefore will not load.  If the kernel should be rebooted a depmod on reboot
# will include these modules, however, the postinst actions will be performed by
# the init scripts on shutdown and reboot if necessary (as signalled by the
# presence of the /.openss7-update-@kversion@ file) and modules will be properly
# linked either before or after reboot and depmod performed again when necessary
# before the init scripts attempt to start the subsystem.
#
prerm_kernel_upgrade () { :
    prerm_kernel
}
# -----------------------------------------------------------------------------
# Primary functions:
# -----------------------------------------------------------------------------
# xxx-prerm remove
remove_prerm () { :
    prerm_kernel_remove
    return $?
}
# con-prerm remove 'in-favour' package new-version
conflict_prerm () { :
    prerm_kernel_remove
    return $?
}
# old-prerm upgrade new-version
upgrade_prerm () { :
    prerm_kernel_upgrade
    return $?
}
# old-prerm upgrade new-version ***FAILED***
# new-prerm failed-upgrade old-version
failed_upgrade_prerm () { :
    prerm_kernel_failed
    return $?
}
# dec-prerm deconfigure 'in-favour' package-being-installed version ['removing' conflicting-package version]
deconfigure_prerm () { :
    prerm_kernel_remove || :
    return $?
}
@mscript_prerm@
@mscript_debhelper@
# =============================================================================
#
# $Log$
# =============================================================================
# vim: ft=sh sw=4 noet nocin nosi formatoptions+=tcqlorn
