#!/bin/bash
# @configure_input@
# =============================================================================
# 
# @(#) $RCSfile$ $Name$($Revision$) $Date$
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2008-2011  Monavacon Limited <http://www.monavacon.com/>
# Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>, or write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date$ by $Author$
#
# =============================================================================
subpkg=kernel
@openss7_header@
datarootdir=@datarootdir@
# -----------------------------------------------------------------------------
# Auxiliary functions:
# -----------------------------------------------------------------------------
#
# remove_depmods() - A little recursive function to delete all modules dependent
#   on an initial module set (in our case "streams.o").  The function echos the
#   list of modules to remove to stdout.
#
remove_depmods () {
    local t
    [ $# -gt 0 ] || return 0
    echo "$*"
    for t in $@ ; do
	prereq=prereq_`echo $t | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$||;s|[^a-zA-Z0-9_]|_|g'`
	eval "remove_depmods \$$prereq"
    done
}
#
# preinst_modules() - This is a fresh install of this version of kernel module.
#   Make sure that there are no tarball installed kernel modules hanging around
#   for this kernel version.  Because kernel module packages are named
#   differently for different kernels, it is important that this function not be
#   too zealous and remove kernel modules from our other installed packages.
#
preinst_modules () { :
    local list m b modl_mods line dep
    list="${modules}" ; modl_mods=
    if [ -d @kmoduledir@ ] ; then
	for m in `find @kmoduledir@ \( -name 'streams*.o' -o -name 'streams*.ko' -o -name 'streams*.o.gz' -o -name 'streams*.ko.gz' \) 2>/dev/null` ; do
		b=`echo $m | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?||'`
		case " $list " in (*" $b "*) ;; (*) continue ;; esac
		echo "$m"
		modl_mods="$modl_mods${modl_mods:+ }$m"
	done
	if [ -n "$modl_mods" -a -f @kmoduledir@/modules.dep ] ; then
#	    First we can build a dependency tree from every dependency
#	    expression that can be found in the modules.dep file.
	    xtrace=`set -o | sed -n 's,xtrace[[:space:]]*on,set +o xtrace,p;t;s,xtrace[[:space:]]*off,set -o xtrace,p;t'`
	    set +x
	    dep= ; while read line ; do
		case $line in
		    (*\\)   line="`echo $line | sed -e 's|\\$||'`"
			    dep="$dep${dep:+ }$line"; continue ;;
		    (*)     dep="$dep${dep:+ }$line" ;;
		esac
		[ -n "$dep" ] || continue;
		set -- $dep
		if [ $# -ge 2 ] ; then
		    t=`echo $1 | sed -e 's|:$||'`
		    target=target_`echo $t | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$||;s|[^a-zA-Z0-9_]|_|g'`
		    shift
		    for p in $@ ; do
			prereq=prereq_`echo $p | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$||;s|[^a-zA-Z0-9_]|_|g'`
			eval "$prereq=\"\$$prereq\${$prereq:+ }$t\""
			eval "$target=\"\$$target\${$target:+ }$p\""
		    done
		fi
		dep=
	    done < @kmoduledir@/modules.dep
	    eval "$xtrace"
	fi
    fi
#   remove conflicting and dependent modules
    if [ -n "$modl_mods" ] ; then
	rm -f -- $modl_mods
	for m in $list ; do
	    prereq=prereq_`echo $m | sed -r -e 's|^.*/||;s|\.(k)?o(\.gz)?(:)?$||;s|[^a-zA-Z0-9_]|_|g'`
	    eval "modl_deps=\"\`remove_depmods \$$prereq\`\""
	    [ -n "$modl_deps" ] || continue
	    rm -f -- $modl_deps
	done
    fi
    :
    return 0
}
#
# preinst_stop_scripts() - Stop init scripts when they are still hanging around.
#   Note that when the init scripts are already stopped this has no (negative)
#   effect.  Note that our previous practice of stopping init scripts when
#   removing or upgrading modules is questionable and possibly too disruptive to
#   a running system.  Instead of stopping scripts, the user should be warned
#   that restarting the subsystem might be required.  Under debian we can use
#   debconf for this purpose too.
#
preinst_stop_scripts () {
    local reverse= list="${initfiles}" i tried=1
    for i in $list ; do
        reverse="$i${reverse:+ }$reverse"
    done
    for i in $reverse ; do
	if [ -f "@initrddir@/$i" ]; then tried=0
	    [ -x "`which invoke-rc.d 2>/dev/null`" ] && invoke-rc.d $i stop && continue || true
	    [ -x "`which service     2>/dev/null`" ] && service     $i stop && continue || true
	    [ -x "@initrddir@/$i"                  ] && @initrddir@/$i stop && continue || true
	fi
    done
    return $tried
}
#
# preinst_kill_daemons() - Kill daemons with prejudice.  Stopping init scripts
#   should have stopped these daemons already.  One situation is where init
#   scripts have been removed already (or not fully installed) without stopping
#   them.
#
preinst_kill_daemons () {
    local reverse= list="${initfiles}" i n
    for i in $list ; do
	reverse="${i}${reverse:+ }${reverse}"
    done
    for i in $reverse ; do
	n=`echo "$i" | sed -e 's,\.sh$,,'`
	if [ -r /var/run/${n}.pid ] ; then
	    kill -TERM `cat /var/run/${n}.pid` || :
	    rm -f /var/run/${n}.pid || :
	    rm -f /var/lock/subsys/${n} || :
	    rm -f /var/lock/subsys/${n}.init || :
	fi
    done
}
#
# preinst_umount_specfs() - Unmount the Special Shadow Filesystem, making device
#  nodes in the /dev/streams directory no longer available.  Note that this
#  should succeed even while kernel modules are loaded.
#
preinst_umount_specfs () {
    local retval=0 device mountpoint fstype options
    while read device mountpoint fstype options
    do
	if [ ":$fstype" = ":specfs" ]
	then
	    umount -t specfs -- $mountpoint || retval=$?
	fi
    done </etc/mtab
    return $retval
}
#
# preinst_rmnods() - Remove device nodes in the /dev directory.
#
preinst_rmnods () { :
    if [ -x "@sbindir@/@STRCONF_DEVICES@" ]; then
	@sbindir@/@STRCONF_DEVICES@ --remove || :
    fi
}
#
# preinst_kill_streams() - Uses lsof to determine which processes are holding
#   opens STREAMS drivers and sends those processes a TERM signal followed five
#   seconds later by a KILL signal if the process still exists.  This ensures
#   that all STREAMS drivers are closed.  When the specfs is unmounted and
#   STREAMS devices removed before this operation is performed, killed processes
#   that respawn will be unable to reopen the STREAMS drivers because the device
#   nodes no longer exist.  Note that this is not infalable: when STREAMS are
#   permanently linked beneath a multiplexing driver, it may still be impossible
#   to remove all STREAMS kernel modules.
#
preinst_kill_streams () {
    local fields ind val signal
    if lsof | grep '\<STR\>' >/dev/null 2>&1 ; then
	if [ -x "`which fdetach 2>/dev/null`" ] ; then
	    fdetach -a 2>/dev/null || :
	fi
        for signal in TERM KILL ; do
            if lsof | grep '\<STR\>' >/dev/null 2>&1 ; then
                lsof | grep '\<STR\>' | \
                while read fields ; do
                    set -- $fields
                    if [ ":$5" != ':CHR' ] ; then continue; fi
                    ind=`expr $# - 1`
                    eval "val=\"\${$ind}\""
                    if [ ":$val" != ':STR' ] ; then continue; fi
                    kill -$signal $2 >/dev/null 2>&1 || :
                done
                sleep 5
            fi
        done
    fi
    lsof | grep '\<STR\>' >/dev/null 2>&1 && false || true
    return $?
}
#
# remove_depends() - A recursive function that peforms a depth first traversal
#   of the dependency graph rooted at the kernel module supplied as an argument,
#   removing modules that have no dependents.  This is so that entire kernel
#   module stacks can be removed.
#
remove_depends () {
    local modrex depend depends
    modrex=`echo $1 | sed -e 's,[-_],[-_],g'`
    depends=`grep "^$modrex[[:space:]]" /proc/modules 2>/dev/null | cut -f4 '-d ' | sed -e 's|^-$||;s|,$||;s|,| |g'`
    for depend in $depends ; do
        remove_depends $depend || return $?
    done
    if grep "^$modrex[[:space:]]" /proc/modules >/dev/null 2>&1 ; then
        rmmod $1 >/dev/null 2>&1 || return $?
    fi
    return 0
}
#
# preinst_shutdown() - Shutdown the STREAMS subsystem with prejudice.  First
#   attempt to shutdown using init scripts.  If that suceeds fully, all other
#   steps reduce to null operations.  When it does not succeed, the other steps
#   are largely what the initscripts would do shutting down anyway, but we can
#   determine whether a reboot will be required.
#
preinst_shutdown () {
    local reboot='no'
    preinst_stop_scripts    || :
    preinst_kill_daemons    || :
    preinst_umount_specfs   || reboot='yes'
    preinst_rmnods	    || :
    preinst_kill_streams    || reboot='yes'
    remove_depends streams  || reboot='yes'
    remove_depends specfs   || reboot='yes'
    if [ ":$reboot" = ':yes' ] ; then
	echo "$script: warning: reboot required." >&2
    fi
    :
    return 0
}
#
# preinst_running() - Shutdown STREAMS on the running kernel if the running
#   kernel is the same as the version of the modules we are installing or
#   upgrading.  If streams does not happen to be running on the running kernel,
#   this reduces to a null operation.
#
preinst_running () {
    if [ "@kversion@" = "`uname -r`" ]; then
	preinst_shutdown || :
    fi
}
#   new-preinst install
#	- files are unpacked
#	- file list added
#	- scripts added
#	- "Unpacked" state
#   new-postinst configure
#
# This is a fresh installation of the package for @kversion@.  Either the
# package has never been installed before, or a purge was performed on the
# package after it was removed (unlikely, but possible).  Actions that need to
# be performed are as follows:
#
# The preinst script will:
#
# 1.  Seek out and remove any non-deb or old LiS installations.
# 2.  Remove any weak links by calling openss7-update --remove-kernel @kversion@
# 3.  Perform a depmod so that no attempt is made to load the kernel modules
#     that are about to be installed.  Note that this may result in an error
#     because client modules may be present.
# 4.  Do not stop any running subsystems regardless of whether @kversion@ is the
#     running kernel.
# 5.  Touch /.openss7-update-@kversion@ to indicate to init scripts that
#     openss7-update --boot-kernel @kversion@ should be run on reboot.
#
# The postinst script will:
#
# 1.  Relink installed kernel modules for the running kernel if required.  This
#     is performed with openss7-update --add-modules @kversion@.
# 2.  Perform a weak update using openss7-update --add-modules @kversion@.  Note
#     that this will not affect the running kernel when @kversion@ is other than
#     the running kernel.
# 3.  Perform a depmod so that kernel module dependencies are proper. (This will
#     be performed by openss7-update.)
# 4.  Can start init scripts for the running kernel if desired and they are not
#     already running.  The user can be prompted using debconf.  However, it is
#     best to leave them in their previous state by default.
# 5.  If init scripts are running or kernel modules are loaded and the
#     installation is for the running kernel, warn the user that a restart of
#     the STREAMS subsystems is recommended.  The user can be prompted using
#     debconf.  However, it is best to leave them in their previous state by
#     default.
#
# Note that if the package is not configured, kernel modules will be installed
# in the directories; however, they will not be included in the depmod files and
# therefore will not load.  If the kernel should be rebooted a depmod on reboot
# will include these modules, however, the postinst actions will be performed by
# the init scripts on shutdown and reboot if necessary (as signalled by the
# presence of the /.openss7-update-@kversion@ file) and modules will be properly
# linked either before or after reboot and depmod performed again when necessary
# before the init scripts attempt to start the subsystem.
#
preinst_kernel_install () { :
    preinst_modules
    preinst_running
}
#   new-preinst install old-version
#	- files are unpacked
#	- file list added
#	- scripts added
#	- "Unpacked" state
#   new-postinst configure most-recently-configured-version
#
# This is a reinstallation of the package for @kversion@.  A version of the
# package (old-version) has been installed before.  Actions that need to be
# performed are the same as for a fresh install; however, there is no need to
# seek out non-deb or LiS installations are remove them because this would have
# been performed on the previous fresh install.
#
preinst_kernel_reinstall () { :
    @WITH_KO_MODULES_FALSE@preinst_running
}
#   old-prerm upgrade new-version
#   new-preinst upgrade old-version
#	- files are unpacked, backups of old files
#   old-postrm upgrade new-version
#	- old files not in new version are removed
#	- new files list replaces old
#	- new scripts replace old
#	- backup files are deleted
#	- "Unpacked" state
#   new-postinst configure [most-recently-configured-version]
#
# This is an upgrade of the package for @kversion@.  An older version of the
# package is installed.  Actions that need to be performed are as follows:
#
# The prerm script will:
#
# 1.  Remove any weak links to the modules that are about to be removed (for
#     kernels other than @kversion@) by calling openss7-update --remove-modules
#     @kversion@.  This may as last step remove the modules themselves.  The
#     openss7-update script can be passed the EVR of the modules so that they
#     may be identified by their srcversion.
# 2.  If the running kernel was linked to the modules being removed, those
#     symbolic links must be removed and a depmod performed so that the running
#     kernel will not attempt to load any modules that are about to be
#     installed.  Note that this may result in an error because client modules
#     may be present.
# 3.  Do not stop any running subsystems regardless of whether @kversion@ is the
#     running kernel.
#
# The preinst script will:
#
# 1.  Remove any weak links by calling openss7-update --remove-kernel
#     @kversion@.
# 2.  Perform a depmod so that no attempt is made to load the kernel modules
#     that are about to be installed.  Note that this may result in an error
#     because client modules may be present.
# 3.  Do not stop any running subsystems regardless of whether @kversion@ is the
#     running kernel.
# 4.  Touch /.openss7-update-@kversion@ to indicate to init scripts that
#     openss7-update --boot-kernel @kversion@ should be run on reboot.
#
# The postrm script will:
#
# 1.  Do nothing.  The new modules could be relinked at this stage, but it is
#     not wise to use scripts is a questionable state to relink newer version
#     modules.
#
# The postinst script will:
#
# 1.  Relink installed kernel modules for the running kernel if required.  This
#     is performed with openss7-update --add-modules @kversion@.
# 2.  Perform a weak update using openss7-update --add-modules @kversion@.  Note
#     that this will not affect the running kernel when @kversion@ is other than
#     the running kernel.
# 3.  Perform a depmod so that kernel module dependencies are proper. (This will
#     be performed by openss7-update.)
# 4.  Can start init scripts for the running kernel if desired and they are not
#     already running.  The user can be prompted using debconf.  However, it is
#     best to leave them in their previous state by default.
# 5.  If init scripts are running or kernel modules are loaded and the
#     installation is for the running kernel, warn the user that a restart of
#     the STREAMS subsystems is recommended.  The user can be prompted using
#     debconf.  However, it is best to leave them in their previous state by
#     default.
#
# Note that if the package is not configured, kernel modules will be installed
# in the directories; however, they will not be included in the depmod files and
# therefore will not load.  If the kernel should be rebooted a depmod on reboot
# will include these modules, however, the postinst actions will be performed by
# the init scripts on shutdown and reboot if necessary (as signalled by the
# presence of the /.openss7-update-@kversion@ file) and modules will be properly
# linked either before or after reboot and depmod performed again when necessary
# before the init scripts attempt to start the subsystem.
#
preinst_kernel_upgrade () { :
    @WITH_KO_MODULES_FALSE@preinst_running
}
preinst_kernel_abort () { :
    @WITH_KO_MODULES_FALSE@preinst_running
}
# -----------------------------------------------------------------------------
# Primary functions:
# -----------------------------------------------------------------------------
# new-preinst install
install_preinst () { :
    preinst_kernel_install
}
# new-preinst install old-version
reinstall_preinst () { :
    preinst_kernel_reinstall
}
# new-preinst upgrade old-version
upgrade_preinst () { :
    preinst_kernel_upgrade
}
# old-postrm upgrade new-version ...FAILED
# new-postrm failed-upgrade old-version ...FAILED
# old-preinst abort-upgrade new-version
abort_upgrade_preinst () { :
    preinst_kernel_abort
}
@mscript_preinst@
@mscript_debhelper@
# =============================================================================
#
# $Log$
# =============================================================================
# vim: ft=sh sw=4 noet nocin nosi formatoptions+=tcqlorn
