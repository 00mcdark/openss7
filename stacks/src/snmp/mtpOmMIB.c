/*****************************************************************************

 @(#) $RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2008-12-31 16:04:46 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-31 16:04:46 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpOmMIB.c,v $
 Revision 0.9.2.4  2008-12-31 16:04:46  brian
 - updated mibs

 Revision 0.9.2.3  2008-12-27 15:29:46  brian
 - split MTP and MTP OM mib

 Revision 0.9.2.2  2008-12-24 13:08:25  brian
 - building ss7confd

 *****************************************************************************/

#ident "@(#) $RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2008-12-31 16:04:46 $"

static char const ident[] = "$RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2008-12-31 16:04:46 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ss7MIB.h"
#include "x400pMIB.h"
#include "mtpMIB.h"
#include "mtpOmMIB.h"
#include "sccpMIB.h"
#include "sccpOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int mtpOmMIB_refresh = 1;
volatile int mtpOmSpTable_refresh = 1;
volatile int mtpOmSpInt5minTable_refresh = 1;
volatile int mtpOmSpInt15minTable_refresh = 1;
volatile int mtpOmSpSiTable_refresh = 1;
volatile int mtpOmSpSiInt5minTable_refresh = 1;
volatile int mtpOmSpSiInt15minTable_refresh = 1;
volatile int mtpOmSpStudyTable_refresh = 1;
volatile int mtpOmSpStudyInt5minTable_refresh = 1;
volatile int mtpOmSpStudyInt15minTable_refresh = 1;
volatile int mtpOmSpStudyMapTable_refresh = 1;
volatile int mtpOmRsTable_refresh = 1;
volatile int mtpOmRsInt5minTable_refresh = 1;
volatile int mtpOmRsInt15minTable_refresh = 1;
volatile int mtpOmRsSiTable_refresh = 1;
volatile int mtpOmRsSiInt5minTable_refresh = 1;
volatile int mtpOmRsSiInt15minTable_refresh = 1;
volatile int mtpOmLsTable_refresh = 1;
volatile int mtpOmLsInt5minTable_refresh = 1;
volatile int mtpOmLsInt15minTable_refresh = 1;
volatile int mtpOmSlStatsTable_refresh = 1;
volatile int mtpOmSlL3Table_refresh = 1;
volatile int mtpOmSlL3Int5minTable_refresh = 1;
volatile int mtpOmSlL3Int15minTable_refresh = 1;
volatile int mtpOmSlL2Table_refresh = 1;
volatile int mtpOmSlL2Int5minTable_refresh = 1;
volatile int mtpOmSlL2Int15minTable_refresh = 1;
volatile int mtpOmSdtStatsTable_refresh = 1;
volatile int mtpOmSdlStatsTable_refresh = 1;

/*
 * mtpOmMIB_variables_oid: object identifier for mtpOmMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpOmMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1 };
oid mtpOmSpSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 4, 1 };
oid mtpOmSpStudyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 7, 1 };
oid mtpOmSpStudyMapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 10, 1 };
oid mtpOmRsSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 2, 4, 1 };

/*
 * variable7 mtpOmMIB_variables: tree for mtpOmMIB
 * This variable defines function callbacks and type return information for the mtpOmMIB mib section
 */
struct variable7 mtpOmMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPOMSPVALIDINTERVALS  (4 % 256)
	{MTPOMSPVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 1}},
#define   MTPOMSPTIMEDISCONTINUITY  (5 % 256)
	{MTPOMSPTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPOMSPDISCARDEDMSUS  (6 % 256)
	{MTPOMSPDISCARDEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPOMSPRECEIVEDTFCSTATUS0  (7 % 256)
	{MTPOMSPRECEIVEDTFCSTATUS0, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPOMSPRECEIVEDTFCSTATUS1  (8 % 256)
	{MTPOMSPRECEIVEDTFCSTATUS1, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPOMSPRECEIVEDTFCSTATUS2  (9 % 256)
	{MTPOMSPRECEIVEDTFCSTATUS2, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPOMSPOCTETSXFERRED  (10 % 256)
	{MTPOMSPOCTETSXFERRED, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPOMSPINT5MINTIMESTAMP  (15 % 256)
	{MTPOMSPINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 2}},
#define   MTPOMSPINT5MINDISCARDEDMSUS  (16 % 256)
	{MTPOMSPINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 3}},
#define   MTPOMSPINT5MINRECEIVEDTFCSTATUS0  (17 % 256)
	{MTPOMSPINT5MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 4}},
#define   MTPOMSPINT5MINRECEIVEDTFCSTATUS1  (18 % 256)
	{MTPOMSPINT5MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 5}},
#define   MTPOMSPINT5MINRECEIVEDTFCSTATUS2  (19 % 256)
	{MTPOMSPINT5MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 6}},
#define   MTPOMSPINT5MINOCTETSXFERRED  (20 % 256)
	{MTPOMSPINT5MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 7}},
#define   MTPOMSPINT15MINTIMESTAMP  (25 % 256)
	{MTPOMSPINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 2}},
#define   MTPOMSPINT15MINDISCARDEDMSUS  (26 % 256)
	{MTPOMSPINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 3}},
#define   MTPOMSPINT15MINRECEIVEDTFCSTATUS0  (27 % 256)
	{MTPOMSPINT15MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 4}},
#define   MTPOMSPINT15MINRECEIVEDTFCSTATUS1  (28 % 256)
	{MTPOMSPINT15MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 5}},
#define   MTPOMSPINT15MINRECEIVEDTFCSTATUS2  (29 % 256)
	{MTPOMSPINT15MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 6}},
#define   MTPOMSPINT15MINOCTETSXFERRED  (30 % 256)
	{MTPOMSPINT15MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 7}},
#define   MTPOMSPSIVALIDINTERVALS  (35 % 256)
	{MTPOMSPSIVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 2}},
#define   MTPOMSPSITIMEDISCONTINUITY  (36 % 256)
	{MTPOMSPSITIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 3}},
#define   MTPOMSPSITRANSMITTEDUPUNAVAILABLE  (37 % 256)
	{MTPOMSPSITRANSMITTEDUPUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 4}},
#define   MTPOMSPSIRECEIVEDUPUNAVAILABLE  (38 % 256)
	{MTPOMSPSIRECEIVEDUPUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 5}},
#define   MTPOMSPSIHANDLEDOCTETSSIO  (39 % 256)
	{MTPOMSPSIHANDLEDOCTETSSIO, ASN_COUNTER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 6}},
#define   MTPOMSPSISTATUS       (40 % 256)
	{MTPOMSPSISTATUS, ASN_INTEGER, RWRITE, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 7}},
#define   MTPOMSPSIINT5MINTIMESTAMP  (46 % 256)
	{MTPOMSPSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 2}},
#define   MTPOMSPSIINT5MINTRANSMITTEDUPUNAVAILABLE  (47 % 256)
	{MTPOMSPSIINT5MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 3}},
#define   MTPOMSPSIINT5MINRECEIVEDUPUNAVAILABLE  (48 % 256)
	{MTPOMSPSIINT5MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 4}},
#define   MTPOMSPSIINT5MINHANDLEDOCTETSSIO  (49 % 256)
	{MTPOMSPSIINT5MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 5}},
#define   MTPOMSPSIINT15MINTIMESTAMP  (55 % 256)
	{MTPOMSPSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 2}},
#define   MTPOMSPSIINT15MINTRANSMITTEDUPUNAVAILABLE  (56 % 256)
	{MTPOMSPSIINT15MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 3}},
#define   MTPOMSPSIINT15MINRECEIVEDUPUNAVAILABLE  (57 % 256)
	{MTPOMSPSIINT15MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 4}},
#define   MTPOMSPSIINT15MINHANDLEDOCTETSSIO  (58 % 256)
	{MTPOMSPSIINT15MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 5}},
#define   MTPOMSPSTUDYVALIDINTERVALS  (62 % 256)
	{MTPOMSPSTUDYVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 2}},
#define   MTPOMSPSTUDYTIMEDISCONTINUITY  (63 % 256)
	{MTPOMSPSTUDYTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 3}},
#define   MTPOMSPSTUDYHANDLEDOCTETSOPCDPCSIO  (64 % 256)
	{MTPOMSPSTUDYHANDLEDOCTETSOPCDPCSIO, ASN_COUNTER, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 4}},
#define   MTPOMSPSTUDYHANDLEDMSUSOPCDPCSIO  (65 % 256)
	{MTPOMSPSTUDYHANDLEDMSUSOPCDPCSIO, ASN_COUNTER, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 5}},
#define   MTPOMSPSTUDYSTATUS    (66 % 256)
	{MTPOMSPSTUDYSTATUS, ASN_INTEGER, RWRITE, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 6}},
#define   MTPOMSPSTUDYINT5MINTIMESTAMP  (71 % 256)
	{MTPOMSPSTUDYINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 2}},
#define   MTPOMSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO  (72 % 256)
	{MTPOMSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 3}},
#define   MTPOMSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO  (73 % 256)
	{MTPOMSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 4}},
#define   MTPOMSPSTUDYINT15MINTIMESTAMP  (78 % 256)
	{MTPOMSPSTUDYINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 2}},
#define   MTPOMSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO  (79 % 256)
	{MTPOMSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 3}},
#define   MTPOMSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO  (80 % 256)
	{MTPOMSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 4}},
#define   MTPOMSPSTUDYMAPSTATUS  (88 % 256)
	{MTPOMSPSTUDYMAPSTATUS, ASN_INTEGER, RWRITE, var_mtpOmSpStudyMapTable, 6, {1, 1, 1, 10, 1, 3}},
#define   MTPOMRSVALIDINTERVALS  (92 % 256)
	{MTPOMRSVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 1}},
#define   MTPOMRSTIMEDISCONTINUITY  (93 % 256)
	{MTPOMRSTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPOMRSRECEIVEDOCTETSOPC  (94 % 256)
	{MTPOMRSRECEIVEDOCTETSOPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPOMRSTRANSMITTEDOCTETSDPC  (95 % 256)
	{MTPOMRSTRANSMITTEDOCTETSDPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPOMRSRECEIVEDMSUSOPC  (96 % 256)
	{MTPOMRSRECEIVEDMSUSOPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPOMRSTRANSMITTEDMSUSDPC  (97 % 256)
	{MTPOMRSTRANSMITTEDMSUSDPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPOMRSROUTESETUNAVAILABLE  (98 % 256)
	{MTPOMRSROUTESETUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPOMRSROUTESETUNAVAILABLEDURATION  (99 % 256)
	{MTPOMRSROUTESETUNAVAILABLEDURATION, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPOMRSINT5MINTIMESTAMP  (104 % 256)
	{MTPOMRSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 2}},
#define   MTPOMRSINT5MINRECEIVEDOCTETSOPC  (105 % 256)
	{MTPOMRSINT5MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 3}},
#define   MTPOMRSINT5MINTRANSMITTEDOCTETSDPC  (106 % 256)
	{MTPOMRSINT5MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 4}},
#define   MTPOMRSINT5MINRECEIVEDMSUSOPC  (107 % 256)
	{MTPOMRSINT5MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 5}},
#define   MTPOMRSINT5MINTRANSMITTEDMSUSDPC  (108 % 256)
	{MTPOMRSINT5MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 6}},
#define   MTPOMRSINT5MINROUTESETUNAVAILABLE  (109 % 256)
	{MTPOMRSINT5MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 7}},
#define   MTPOMRSINT5MINROUTESETUNAVAILABLEDURATION  (110 % 256)
	{MTPOMRSINT5MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 8}},
#define   MTPOMRSINT15MINTIMESTAMP  (115 % 256)
	{MTPOMRSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 2}},
#define   MTPOMRSINT15MINRECEIVEDOCTETSOPC  (116 % 256)
	{MTPOMRSINT15MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 3}},
#define   MTPOMRSINT15MINTRANSMITTEDOCTETSDPC  (117 % 256)
	{MTPOMRSINT15MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 4}},
#define   MTPOMRSINT15MINRECEIVEDMSUSOPC  (118 % 256)
	{MTPOMRSINT15MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 5}},
#define   MTPOMRSINT15MINTRANSMITTEDMSUSDPC  (119 % 256)
	{MTPOMRSINT15MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 6}},
#define   MTPOMRSINT15MINROUTESETUNAVAILABLE  (120 % 256)
	{MTPOMRSINT15MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 7}},
#define   MTPOMRSINT15MINROUTESETUNAVAILABLEDURATION  (121 % 256)
	{MTPOMRSINT15MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 8}},
#define   MTPOMRSSIVALIDINTERVALS  (125 % 256)
	{MTPOMRSSIVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 2}},
#define   MTPOMRSSITIMEDISCONTINUITY  (126 % 256)
	{MTPOMRSSITIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 3}},
#define   MTPOMRSSIRECEIVEDOCTETSOPCSIO  (127 % 256)
	{MTPOMRSSIRECEIVEDOCTETSOPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 4}},
#define   MTPOMRSSITRANSMITTEDOCTETSDPCSIO  (128 % 256)
	{MTPOMRSSITRANSMITTEDOCTETSDPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 5}},
#define   MTPOMRSSIRECEIVEDMSUSOPCSIO  (129 % 256)
	{MTPOMRSSIRECEIVEDMSUSOPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 6}},
#define   MTPOMRSSITRANSMITTEDMSUSDPCSIO  (130 % 256)
	{MTPOMRSSITRANSMITTEDMSUSDPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 7}},
#define   MTPOMRSSISTATUS       (131 % 256)
	{MTPOMRSSISTATUS, ASN_INTEGER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 8}},
#define   MTPOMRSSIINT5MINTIMESTAMP  (136 % 256)
	{MTPOMRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 2}},
#define   MTPOMRSSIINT5MINRECEIVEDOCTETSOPCSIO  (137 % 256)
	{MTPOMRSSIINT5MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 3}},
#define   MTPOMRSSIINT5MINTRANSMITTEDOCTETSDPCSIO  (138 % 256)
	{MTPOMRSSIINT5MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 4}},
#define   MTPOMRSSIINT5MINRECEIVEDMSUSOPCSIO  (139 % 256)
	{MTPOMRSSIINT5MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 5}},
#define   MTPOMRSSIINT5MINTRANSMITTEDMSUSDPCSIO  (140 % 256)
	{MTPOMRSSIINT5MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 6}},
#define   MTPOMRSSIINT15MINTIMESTAMP  (145 % 256)
	{MTPOMRSSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 2}},
#define   MTPOMRSSIINT15MINRECEIVEDOCTETSOPCSIO  (146 % 256)
	{MTPOMRSSIINT15MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 3}},
#define   MTPOMRSSIINT15MINTRANSMITTEDOCTETSDPCSIO  (147 % 256)
	{MTPOMRSSIINT15MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 4}},
#define   MTPOMRSSIINT15MINRECEIVEDMSUSOPCSIO  (148 % 256)
	{MTPOMRSSIINT15MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 5}},
#define   MTPOMRSSIINT15MINTRANSMITTEDMSUSDPCSIO  (149 % 256)
	{MTPOMRSSIINT15MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 6}},
#define   MTPOMLSVALIDINTERVALS  (153 % 256)
	{MTPOMLSVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 1}},
#define   MTPOMLSTIMEDISCONTINUITY  (154 % 256)
	{MTPOMLSTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPOMLSADJACENTINACCESSIBLEEVENTS  (155 % 256)
	{MTPOMLSADJACENTINACCESSIBLEEVENTS, ASN_COUNTER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPOMLSADJACENTINACCESSIBLEDURATION  (156 % 256)
	{MTPOMLSADJACENTINACCESSIBLEDURATION, ASN_COUNTER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPOMLSSLSUNAVAILABLE  (157 % 256)
	{MTPOMLSSLSUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPOMLSINT5MINTIMESTAMP  (162 % 256)
	{MTPOMLSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 2}},
#define   MTPOMLSINT5MINADJACENTINACCESSIBLEEVENTS  (163 % 256)
	{MTPOMLSINT5MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 3}},
#define   MTPOMLSINT5MINADJACENTINACCESSIBLEDURATION  (164 % 256)
	{MTPOMLSINT5MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 4}},
#define   MTPOMLSINT5MINSLSUNAVAILABLE  (165 % 256)
	{MTPOMLSINT5MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 5}},
#define   MTPOMLSINT15MINTIMESTAMP  (170 % 256)
	{MTPOMLSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 2}},
#define   MTPOMLSINT15MINADJACENTINACCESSIBLEEVENTS  (171 % 256)
	{MTPOMLSINT15MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 3}},
#define   MTPOMLSINT15MINADJACENTINACCESSIBLEDURATION  (172 % 256)
	{MTPOMLSINT15MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 4}},
#define   MTPOMLSINT15MINSLSUNAVAILABLE  (173 % 256)
	{MTPOMLSINT15MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 5}},
#define   MTPOMSLSTATSDURINSERVICE  (179 % 256)
	{MTPOMSLSTATSDURINSERVICE, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 1}},
#define   MTPOMSLSTATSFAILALIGNORPROVING  (180 % 256)
	{MTPOMSLSTATSFAILALIGNORPROVING, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPOMSLSTATSNACKSRECEIVED  (181 % 256)
	{MTPOMSLSTATSNACKSRECEIVED, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPOMSLSTATSDURUNAVAIL  (182 % 256)
	{MTPOMSLSTATSDURUNAVAIL, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPOMSLSTATSDURUNAVAILFAILED  (183 % 256)
	{MTPOMSLSTATSDURUNAVAILFAILED, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPOMSLSTATSDURUNAVAILRPO  (184 % 256)
	{MTPOMSLSTATSDURUNAVAILRPO, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPOMSLSTATSSIBSSENT  (185 % 256)
	{MTPOMSLSTATSSIBSSENT, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPOMSLSTATSTRANSIOSIFOCTETS  (186 % 256)
	{MTPOMSLSTATSTRANSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPOMSLSTATSRETRANSOCTETS  (187 % 256)
	{MTPOMSLSTATSRETRANSOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPOMSLSTATSTRANMSUS  (188 % 256)
	{MTPOMSLSTATSTRANMSUS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPOMSLSTATSRECVSIOSIFOCTETS  (189 % 256)
	{MTPOMSLSTATSRECVSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 11}},
#define   MTPOMSLSTATSRECVMSUS  (190 % 256)
	{MTPOMSLSTATSRECVMSUS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 12}},
#define   MTPOMSLSTATSCONGONSETIND0  (191 % 256)
	{MTPOMSLSTATSCONGONSETIND0, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 13}},
#define   MTPOMSLSTATSCONGONSETIND1  (192 % 256)
	{MTPOMSLSTATSCONGONSETIND1, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 14}},
#define   MTPOMSLSTATSCONGONSETIND2  (193 % 256)
	{MTPOMSLSTATSCONGONSETIND2, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 15}},
#define   MTPOMSLSTATSCONGONSETIND3  (194 % 256)
	{MTPOMSLSTATSCONGONSETIND3, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 16}},
#define   MTPOMSLSTATSDURCONGSTATUS0  (195 % 256)
	{MTPOMSLSTATSDURCONGSTATUS0, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 17}},
#define   MTPOMSLSTATSDURCONGSTATUS1  (196 % 256)
	{MTPOMSLSTATSDURCONGSTATUS1, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 18}},
#define   MTPOMSLSTATSDURCONGSTATUS2  (197 % 256)
	{MTPOMSLSTATSDURCONGSTATUS2, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 19}},
#define   MTPOMSLSTATSDURCONGSTATUS3  (198 % 256)
	{MTPOMSLSTATSDURCONGSTATUS3, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 20}},
#define   MTPOMSLSTATSCONGDISCDIND0  (199 % 256)
	{MTPOMSLSTATSCONGDISCDIND0, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 21}},
#define   MTPOMSLSTATSCONGDISCDIND1  (200 % 256)
	{MTPOMSLSTATSCONGDISCDIND1, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 22}},
#define   MTPOMSLSTATSCONGDISCDIND2  (201 % 256)
	{MTPOMSLSTATSCONGDISCDIND2, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 23}},
#define   MTPOMSLSTATSCONGDISCDIND3  (202 % 256)
	{MTPOMSLSTATSCONGDISCDIND3, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 24}},
#define   MTPOMSLL3VALIDINTERVALS  (208 % 256)
	{MTPOMSLL3VALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 1}},
#define   MTPOMSLL3TIMEDISCONTINUITY  (209 % 256)
	{MTPOMSLL3TIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPOMSLL3SLUNAVAILABILITYDURATION  (210 % 256)
	{MTPOMSLL3SLUNAVAILABILITYDURATION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPOMSLL3SLLOCALINHIBITION  (211 % 256)
	{MTPOMSLL3SLLOCALINHIBITION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPOMSLL3SLREMOTEINHIBITION  (212 % 256)
	{MTPOMSLL3SLREMOTEINHIBITION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 5}},
#define   MTPOMSLL3SLFAILED     (213 % 256)
	{MTPOMSLL3SLFAILED, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 6}},
#define   MTPOMSLL3SLREMOTEPROCOUTAGE  (214 % 256)
	{MTPOMSLL3SLREMOTEPROCOUTAGE, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 7}},
#define   MTPOMSLL3LOCALMGMTINHIBIT  (215 % 256)
	{MTPOMSLL3LOCALMGMTINHIBIT, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 8}},
#define   MTPOMSLL3LOCALMGMTUNINHIBIT  (216 % 256)
	{MTPOMSLL3LOCALMGMTUNINHIBIT, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 9}},
#define   MTPOMSLL3LOCALBUSY    (217 % 256)
	{MTPOMSLL3LOCALBUSY, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 10}},
#define   MTPOMSLL3SLCONGESTEDSTARTS  (218 % 256)
	{MTPOMSLL3SLCONGESTEDSTARTS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 11}},
#define   MTPOMSLL3SLCONGESTEDDURATION  (219 % 256)
	{MTPOMSLL3SLCONGESTEDDURATION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 12}},
#define   MTPOMSLL3SLCONGESTIONSTOPS  (220 % 256)
	{MTPOMSLL3SLCONGESTIONSTOPS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 13}},
#define   MTPOMSLL3DISCARDEDMSUS  (221 % 256)
	{MTPOMSLL3DISCARDEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 14}},
#define   MTPOMSLL3CONGESTIONEVENTSMSULOSS  (222 % 256)
	{MTPOMSLL3CONGESTIONEVENTSMSULOSS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 15}},
#define   MTPOMSLL3CHANGEOVERS  (223 % 256)
	{MTPOMSLL3CHANGEOVERS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 16}},
#define   MTPOMSLL3CHANGEBACKS  (224 % 256)
	{MTPOMSLL3CHANGEBACKS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 17}},
#define   MTPOMSLL3RESTORATIONS  (225 % 256)
	{MTPOMSLL3RESTORATIONS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 18}},
#define   MTPOMSLL3INT5MINTIMESTAMP  (232 % 256)
	{MTPOMSLL3INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPOMSLL3INT5MINSLUNAVAILABILITYDURATION  (233 % 256)
	{MTPOMSLL3INT5MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPOMSLL3INT5MINSLLOCALINHIBITION  (234 % 256)
	{MTPOMSLL3INT5MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPOMSLL3INT5MINSLREMOTEINHIBITION  (235 % 256)
	{MTPOMSLL3INT5MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPOMSLL3INT5MINSLFAILED  (236 % 256)
	{MTPOMSLL3INT5MINSLFAILED, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPOMSLL3INT5MINSLREMOTEPROCOUTAGE  (237 % 256)
	{MTPOMSLL3INT5MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPOMSLL3INT5MINLOCALMGMTINHIBIT  (238 % 256)
	{MTPOMSLL3INT5MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 8}},
#define   MTPOMSLL3INT5MINLOCALMGMTUNINHIBIT  (239 % 256)
	{MTPOMSLL3INT5MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 9}},
#define   MTPOMSLL3INT5MINLOCALBUSY  (240 % 256)
	{MTPOMSLL3INT5MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 10}},
#define   MTPOMSLL3INT5MINSLCONGESTEDSTARTS  (241 % 256)
	{MTPOMSLL3INT5MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 11}},
#define   MTPOMSLL3INT5MINSLCONGESTEDDURATION  (242 % 256)
	{MTPOMSLL3INT5MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 12}},
#define   MTPOMSLL3INT5MINSLCONGESTIONSTOPS  (243 % 256)
	{MTPOMSLL3INT5MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 13}},
#define   MTPOMSLL3INT5MINDISCARDEDMSUS  (244 % 256)
	{MTPOMSLL3INT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 14}},
#define   MTPOMSLL3INT5MINCONGESTIONEVENTSMSULOSS  (245 % 256)
	{MTPOMSLL3INT5MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 15}},
#define   MTPOMSLL3INT5MINCHANGEOVERS  (246 % 256)
	{MTPOMSLL3INT5MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 16}},
#define   MTPOMSLL3INT5MINCHANGEBACKS  (247 % 256)
	{MTPOMSLL3INT5MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 17}},
#define   MTPOMSLL3INT5MINRESTORATIONS  (248 % 256)
	{MTPOMSLL3INT5MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 18}},
#define   MTPOMSLL3INT15MINTIMESTAMP  (255 % 256)
	{MTPOMSLL3INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 2}},
#define   MTPOMSLL3INT15MINSLUNAVAILABILITYDURATION  (256 % 256)
	{MTPOMSLL3INT15MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 3}},
#define   MTPOMSLL3INT15MINSLLOCALINHIBITION  (257 % 256)
	{MTPOMSLL3INT15MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 4}},
#define   MTPOMSLL3INT15MINSLREMOTEINHIBITION  (258 % 256)
	{MTPOMSLL3INT15MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 5}},
#define   MTPOMSLL3INT15MINSLFAILED  (259 % 256)
	{MTPOMSLL3INT15MINSLFAILED, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 6}},
#define   MTPOMSLL3INT15MINSLREMOTEPROCOUTAGE  (260 % 256)
	{MTPOMSLL3INT15MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 7}},
#define   MTPOMSLL3INT15MINLOCALMGMTINHIBIT  (261 % 256)
	{MTPOMSLL3INT15MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 8}},
#define   MTPOMSLL3INT15MINLOCALMGMTUNINHIBIT  (262 % 256)
	{MTPOMSLL3INT15MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 9}},
#define   MTPOMSLL3INT15MINLOCALBUSY  (263 % 256)
	{MTPOMSLL3INT15MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 10}},
#define   MTPOMSLL3INT15MINSLCONGESTEDSTARTS  (264 % 256)
	{MTPOMSLL3INT15MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 11}},
#define   MTPOMSLL3INT15MINSLCONGESTEDDURATION  (265 % 256)
	{MTPOMSLL3INT15MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 12}},
#define   MTPOMSLL3INT15MINSLCONGESTIONSTOPS  (266 % 256)
	{MTPOMSLL3INT15MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 13}},
#define   MTPOMSLL3INT15MINDISCARDEDMSUS  (267 % 256)
	{MTPOMSLL3INT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 14}},
#define   MTPOMSLL3INT15MINCONGESTIONEVENTSMSULOSS  (268 % 256)
	{MTPOMSLL3INT15MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 15}},
#define   MTPOMSLL3INT15MINCHANGEOVERS  (269 % 256)
	{MTPOMSLL3INT15MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 16}},
#define   MTPOMSLL3INT15MINCHANGEBACKS  (270 % 256)
	{MTPOMSLL3INT15MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 17}},
#define   MTPOMSLL3INT15MINRESTORATIONS  (271 % 256)
	{MTPOMSLL3INT15MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 18}},
#define   MTPOMSLL2VALIDINTERVALS  (277 % 256)
	{MTPOMSLL2VALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 1}},
#define   MTPOMSLL2TIMEDISCONTINUITY  (278 % 256)
	{MTPOMSLL2TIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 2}},
#define   MTPOMSLL2SLINSERVICEDURATION  (279 % 256)
	{MTPOMSLL2SLINSERVICEDURATION, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 3}},
#define   MTPOMSLL2SLALIGNMENT  (280 % 256)
	{MTPOMSLL2SLALIGNMENT, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 4}},
#define   MTPOMSLL2SIGNUNITSRECEIVED  (281 % 256)
	{MTPOMSLL2SIGNUNITSRECEIVED, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 5}},
#define   MTPOMSLL2NEGACKRECEIVED  (282 % 256)
	{MTPOMSLL2NEGACKRECEIVED, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 6}},
#define   MTPOMSLL2TRANSMITTEDOCTETSSIFSIO  (283 % 256)
	{MTPOMSLL2TRANSMITTEDOCTETSSIFSIO, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 7}},
#define   MTPOMSLL2RETRANSMITTEDOCTETS  (284 % 256)
	{MTPOMSLL2RETRANSMITTEDOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 8}},
#define   MTPOMSLL2TRANSMITTEDMSUS  (285 % 256)
	{MTPOMSLL2TRANSMITTEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 9}},
#define   MTPOMSLL2RECEIVEDOCTETSSIFSIO  (286 % 256)
	{MTPOMSLL2RECEIVEDOCTETSSIFSIO, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 10}},
#define   MTPOMSLL2RECEIVEDMSUS  (287 % 256)
	{MTPOMSLL2RECEIVEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 11}},
#define   MTPOMSLL2INT5MINTIMESTAMP  (294 % 256)
	{MTPOMSLL2INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 2}},
#define   MTPOMSLL2INT5MINSLINSERVICEDURATION  (295 % 256)
	{MTPOMSLL2INT5MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 3}},
#define   MTPOMSLL2INT5MINSLALIGNMENT  (296 % 256)
	{MTPOMSLL2INT5MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 4}},
#define   MTPOMSLL2INT5MINSIGNUNITSRECEIVED  (297 % 256)
	{MTPOMSLL2INT5MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 5}},
#define   MTPOMSLL2INT5MINNEGACKRECEIVED  (298 % 256)
	{MTPOMSLL2INT5MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 6}},
#define   MTPOMSLL2INT5MINTRANSMITTEDOCTETSSIFSIO  (299 % 256)
	{MTPOMSLL2INT5MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 7}},
#define   MTPOMSLL2INT5MINRETRANSMITTEDOCTETS  (300 % 256)
	{MTPOMSLL2INT5MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 8}},
#define   MTPOMSLL2INT5MINTRANSMITTEDMSUS  (301 % 256)
	{MTPOMSLL2INT5MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 9}},
#define   MTPOMSLL2INT5MINRECEIVEDOCTETSSIFSIO  (302 % 256)
	{MTPOMSLL2INT5MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 10}},
#define   MTPOMSLL2INT5MINRECEIVEDMSUS  (303 % 256)
	{MTPOMSLL2INT5MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 11}},
#define   MTPOMSLL2INT15MINTIMESTAMP  (310 % 256)
	{MTPOMSLL2INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 2}},
#define   MTPOMSLL2INT15MINSLINSERVICEDURATION  (311 % 256)
	{MTPOMSLL2INT15MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 3}},
#define   MTPOMSLL2INT15MINSLALIGNMENT  (312 % 256)
	{MTPOMSLL2INT15MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 4}},
#define   MTPOMSLL2INT15MINSIGNUNITSRECEIVED  (313 % 256)
	{MTPOMSLL2INT15MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 5}},
#define   MTPOMSLL2INT15MINNEGACKRECEIVED  (314 % 256)
	{MTPOMSLL2INT15MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 6}},
#define   MTPOMSLL2INT15MINTRANSMITTEDOCTETSSIFSIO  (315 % 256)
	{MTPOMSLL2INT15MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 7}},
#define   MTPOMSLL2INT15MINRETRANSMITTEDOCTETS  (316 % 256)
	{MTPOMSLL2INT15MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 8}},
#define   MTPOMSLL2INT15MINTRANSMITTEDMSUS  (317 % 256)
	{MTPOMSLL2INT15MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 9}},
#define   MTPOMSLL2INT15MINRECEIVEDOCTETSSIFSIO  (318 % 256)
	{MTPOMSLL2INT15MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 10}},
#define   MTPOMSLL2INT15MINRECEIVEDMSUS  (319 % 256)
	{MTPOMSLL2INT15MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 11}},
#define   MTPOMSDTSTATSTXBYTES  (323 % 256)
	{MTPOMSDTSTATSTXBYTES, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 1}},
#define   MTPOMSDTSTATSTXSUS    (324 % 256)
	{MTPOMSDTSTATSTXSUS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPOMSDTSTATSTXSUSREPEATED  (325 % 256)
	{MTPOMSDTSTATSTXSUSREPEATED, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPOMSDTSTATSTXUNDERRUNS  (326 % 256)
	{MTPOMSDTSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPOMSDTSTATSTXABORTS  (327 % 256)
	{MTPOMSDTSTATSTXABORTS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPOMSDTSTATSTXBUFFEROVERFLOWS  (328 % 256)
	{MTPOMSDTSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPOMSDTSTATSTXSUSINERROR  (329 % 256)
	{MTPOMSDTSTATSTXSUSINERROR, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPOMSDTSTATSRXBYTES  (330 % 256)
	{MTPOMSDTSTATSRXBYTES, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPOMSDTSTATSRXSUSCOMPRESSED  (331 % 256)
	{MTPOMSDTSTATSRXSUSCOMPRESSED, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 9}},
#define   MTPOMSDTSTATSRXOVERRUNS  (332 % 256)
	{MTPOMSDTSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 10}},
#define   MTPOMSDTSTATSRXABORTS  (333 % 256)
	{MTPOMSDTSTATSRXABORTS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 11}},
#define   MTPOMSDTSTATSRXBUFFEROVERFLOWS  (334 % 256)
	{MTPOMSDTSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 12}},
#define   MTPOMSDTSTATSRXSUSINERROR  (335 % 256)
	{MTPOMSDTSTATSRXSUSINERROR, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 13}},
#define   MTPOMSDTSTATSRXSYNCTRANSITIONS  (336 % 256)
	{MTPOMSDTSTATSRXSYNCTRANSITIONS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 14}},
#define   MTPOMSDTSTATSRXBITSOCTETCOUNTED  (337 % 256)
	{MTPOMSDTSTATSRXBITSOCTETCOUNTED, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 15}},
#define   MTPOMSDTSTATSRXCRCERRORS  (338 % 256)
	{MTPOMSDTSTATSRXCRCERRORS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 16}},
#define   MTPOMSDTSTATSRXFRAMEERRORS  (339 % 256)
	{MTPOMSDTSTATSRXFRAMEERRORS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 17}},
#define   MTPOMSDTSTATSRXFRAMEOVERFLOWS  (340 % 256)
	{MTPOMSDTSTATSRXFRAMEOVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 18}},
#define   MTPOMSDTSTATSRXFRAMETOOLONG  (341 % 256)
	{MTPOMSDTSTATSRXFRAMETOOLONG, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 19}},
#define   MTPOMSDTSTATSRXFRAMETOOSHORT  (342 % 256)
	{MTPOMSDTSTATSRXFRAMETOOSHORT, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 20}},
#define   MTPOMSDTSTATSRXRESIDUEERRORS  (343 % 256)
	{MTPOMSDTSTATSRXRESIDUEERRORS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 21}},
#define   MTPOMSDTSTATSCARRIERCTSLOST  (344 % 256)
	{MTPOMSDTSTATSCARRIERCTSLOST, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 22}},
#define   MTPOMSDTSTATSCARRIERDCDLOST  (345 % 256)
	{MTPOMSDTSTATSCARRIERDCDLOST, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 23}},
#define   MTPOMSDTSTATSCARRIERLOST  (346 % 256)
	{MTPOMSDTSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 24}},
#define   MTPOMSDLSTATSRXOCTETS  (350 % 256)
	{MTPOMSDLSTATSRXOCTETS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 1}},
#define   MTPOMSDLSTATSTXOCTETS  (351 % 256)
	{MTPOMSDLSTATSTXOCTETS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPOMSDLSTATSRXOVERRUNS  (352 % 256)
	{MTPOMSDLSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPOMSDLSTATSTXUNDERRUNS  (353 % 256)
	{MTPOMSDLSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPOMSDLSTATSRXBUFFEROVERFLOWS  (354 % 256)
	{MTPOMSDLSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPOMSDLSTATSTXBUFFEROVERFLOWS  (355 % 256)
	{MTPOMSDLSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPOMSDLSTATSLEADCTSLOST  (356 % 256)
	{MTPOMSDLSTATSLEADCTSLOST, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPOMSDLSTATSLEADDCDLOST  (357 % 256)
	{MTPOMSDLSTATSLEADDCDLOST, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPOMSDLSTATSCARRIERLOST  (358 % 256)
	{MTPOMSDLSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 9}},
#define   MTPOMSDLSTATSBIPOLARVIOLATIONS  (359 % 256)
	{MTPOMSDLSTATSBIPOLARVIOLATIONS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 10}},
#define   MTPOM1STANDINTERVALACTIVATE  (360 % 256)
	{MTPOM1STANDINTERVALACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 1}},
#define   MTPOM1STANDINTERVALDEACTIVATE  (361 % 256)
	{MTPOM1STANDINTERVALDEACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 2}},
#define   MTPOM5MINACTIVATE     (362 % 256)
	{MTPOM5MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 3}},
#define   MTPOM5MINDEAACTIVATE  (363 % 256)
	{MTPOM5MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 4}},
#define   MTPOM15MINACTIVATE    (364 % 256)
	{MTPOM15MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 5}},
#define   MTPOM15MINDEAACTIVATE  (365 % 256)
	{MTPOM15MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 6}},
#define   MTPOMDISCONTINUITYTIME  (367 % 256)
	{MTPOMDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_mtpOmMIB, 3, {1, 2, 8}},
#define   MTPOMTIMESTAMP        (368 % 256)
	{MTPOMTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmMIB, 3, {1, 2, 9}},
#define   MTPOM5MINMAXINTERVALS  (369 % 256)
	{MTPOM5MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_mtpOmMIB, 3, {1, 2, 10}},
#define   MTPOM15MINMAXINTERVALS  (370 % 256)
	{MTPOM15MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_mtpOmMIB, 3, {1, 2, 11}},

};

/* (L = length of the oidsuffix) */
struct mtpOmMIB_data *mtpOmMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpOmSpTableStorage = NULL;
struct header_complex_index *mtpOmSpInt5minTableStorage = NULL;
struct header_complex_index *mtpOmSpInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSpSiTableStorage = NULL;
struct header_complex_index *mtpOmSpSiInt5minTableStorage = NULL;
struct header_complex_index *mtpOmSpSiInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyInt5minTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyMapTableStorage = NULL;
struct header_complex_index *mtpOmRsTableStorage = NULL;
struct header_complex_index *mtpOmRsInt5minTableStorage = NULL;
struct header_complex_index *mtpOmRsInt15minTableStorage = NULL;
struct header_complex_index *mtpOmRsSiTableStorage = NULL;
struct header_complex_index *mtpOmRsSiInt5minTableStorage = NULL;
struct header_complex_index *mtpOmRsSiInt15minTableStorage = NULL;
struct header_complex_index *mtpOmLsTableStorage = NULL;
struct header_complex_index *mtpOmLsInt5minTableStorage = NULL;
struct header_complex_index *mtpOmLsInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSlStatsTableStorage = NULL;
struct header_complex_index *mtpOmSlL3TableStorage = NULL;
struct header_complex_index *mtpOmSlL3Int5minTableStorage = NULL;
struct header_complex_index *mtpOmSlL3Int15minTableStorage = NULL;
struct header_complex_index *mtpOmSlL2TableStorage = NULL;
struct header_complex_index *mtpOmSlL2Int5minTableStorage = NULL;
struct header_complex_index *mtpOmSlL2Int15minTableStorage = NULL;
struct header_complex_index *mtpOmSdtStatsTableStorage = NULL;
struct header_complex_index *mtpOmSdlStatsTableStorage = NULL;

/*
 * init_mtpOmMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_mtpOmMIB(void)
{
	DEBUGMSGTL(("mtpOmMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpOmMIB", mtpOmMIB_variables, variable7, mtpOmMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpOmMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpOmMIB", parse_mtpOmMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpTable", parse_mtpOmSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpInt5minTable", parse_mtpOmSpInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpInt15minTable", parse_mtpOmSpInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpSiTable", parse_mtpOmSpSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpSiInt5minTable", parse_mtpOmSpSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpSiInt15minTable", parse_mtpOmSpSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyTable", parse_mtpOmSpStudyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyInt5minTable", parse_mtpOmSpStudyInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyInt15minTable", parse_mtpOmSpStudyInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyMapTable", parse_mtpOmSpStudyMapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsTable", parse_mtpOmRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsInt5minTable", parse_mtpOmRsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsInt15minTable", parse_mtpOmRsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsSiTable", parse_mtpOmRsSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsSiInt5minTable", parse_mtpOmRsSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsSiInt15minTable", parse_mtpOmRsSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmLsTable", parse_mtpOmLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmLsInt5minTable", parse_mtpOmLsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmLsInt15minTable", parse_mtpOmLsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlStatsTable", parse_mtpOmSlStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL3Table", parse_mtpOmSlL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL3Int5minTable", parse_mtpOmSlL3Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL3Int15minTable", parse_mtpOmSlL3Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL2Table", parse_mtpOmSlL2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL2Int5minTable", parse_mtpOmSlL2Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL2Int15minTable", parse_mtpOmSlL2Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSdtStatsTable", parse_mtpOmSdtStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSdlStatsTable", parse_mtpOmSdlStatsTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyMapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmLsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmLsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL3Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL3Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL2Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL2Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSdtStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSdlStatsTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * deinit_mtpOmMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_mtpOmMIB(void)
{
	DEBUGMSGTL(("mtpOmMIB", "deinitializating...  "));
	unregister_mib(mtpOmMIB_variables_oid, sizeof(mtpOmMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpOmMIB");
	snmpd_unregister_config_handler("mtpOmSpTable");
	snmpd_unregister_config_handler("mtpOmSpInt5minTable");
	snmpd_unregister_config_handler("mtpOmSpInt15minTable");
	snmpd_unregister_config_handler("mtpOmSpSiTable");
	snmpd_unregister_config_handler("mtpOmSpSiInt5minTable");
	snmpd_unregister_config_handler("mtpOmSpSiInt15minTable");
	snmpd_unregister_config_handler("mtpOmSpStudyTable");
	snmpd_unregister_config_handler("mtpOmSpStudyInt5minTable");
	snmpd_unregister_config_handler("mtpOmSpStudyInt15minTable");
	snmpd_unregister_config_handler("mtpOmSpStudyMapTable");
	snmpd_unregister_config_handler("mtpOmRsTable");
	snmpd_unregister_config_handler("mtpOmRsInt5minTable");
	snmpd_unregister_config_handler("mtpOmRsInt15minTable");
	snmpd_unregister_config_handler("mtpOmRsSiTable");
	snmpd_unregister_config_handler("mtpOmRsSiInt5minTable");
	snmpd_unregister_config_handler("mtpOmRsSiInt15minTable");
	snmpd_unregister_config_handler("mtpOmLsTable");
	snmpd_unregister_config_handler("mtpOmLsInt5minTable");
	snmpd_unregister_config_handler("mtpOmLsInt15minTable");
	snmpd_unregister_config_handler("mtpOmSlStatsTable");
	snmpd_unregister_config_handler("mtpOmSlL3Table");
	snmpd_unregister_config_handler("mtpOmSlL3Int5minTable");
	snmpd_unregister_config_handler("mtpOmSlL3Int15minTable");
	snmpd_unregister_config_handler("mtpOmSlL2Table");
	snmpd_unregister_config_handler("mtpOmSlL2Int5minTable");
	snmpd_unregister_config_handler("mtpOmSlL2Int15minTable");
	snmpd_unregister_config_handler("mtpOmSdtStatsTable");
	snmpd_unregister_config_handler("mtpOmSdlStatsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

int
term_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpOmMIB();
	return 0;
}

/*
 * mtpOmMIB_add(): adds a structure node for scalars
 */
int
mtpOmMIB_add(struct mtpOmMIB_data *thedata)
{
	DEBUGMSGTL(("mtpOmMIB", "adding data...  "));
	mtpOmMIBStorage = thedata;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmMIB(): parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmMIB_data);

	DEBUGMSGTL(("mtpOmMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
#if 0
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm1stAndIntervalActivate, &tmpsize);
	StorageTmp->mtpOm1stAndIntervalActivateLen = tmpsize;
	if (StorageTmp->mtpOm1stAndIntervalActivate == NULL) {
		config_perror("invalid specification for mtpOm1stAndIntervalActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm1stAndIntervalDeactivate, &tmpsize);
	StorageTmp->mtpOm1stAndIntervalDeactivateLen = tmpsize;
	if (StorageTmp->mtpOm1stAndIntervalDeactivate == NULL) {
		config_perror("invalid specification for mtpOm1stAndIntervalDeactivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm5MinActivate, &tmpsize);
	StorageTmp->mtpOm5MinActivateLen = tmpsize;
	if (StorageTmp->mtpOm5MinActivate == NULL) {
		config_perror("invalid specification for mtpOm5MinActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm5MinDeaActivate, &tmpsize);
	StorageTmp->mtpOm5MinDeaActivateLen = tmpsize;
	if (StorageTmp->mtpOm5MinDeaActivate == NULL) {
		config_perror("invalid specification for mtpOm5MinDeaActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm15MinActivate, &tmpsize);
	StorageTmp->mtpOm15MinActivateLen = tmpsize;
	if (StorageTmp->mtpOm15MinActivate == NULL) {
		config_perror("invalid specification for mtpOm15MinActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm15MinDeaActivate, &tmpsize);
	StorageTmp->mtpOm15MinDeaActivateLen = tmpsize;
	if (StorageTmp->mtpOm15MinDeaActivate == NULL) {
		config_perror("invalid specification for mtpOm15MinDeaActivate");
		return;
	}

	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmTimeStamp, &tmpsize);
#endif
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOm5MinMaxIntervals, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOm15MinMaxIntervals, &tmpsize);

	mtpOmMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpOmMIB", "storing data...  "));
	refresh_mtpOmMIB();
	if ((StorageTmp = mtpOmMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpOmMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->mtpOmMIBStorageType == ST_NONVOLATILE) */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpOmMIB ");
		cptr = line + strlen(line);
#if 0
		tmpsize = StorageTmp->mtpOm1stAndIntervalActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm1stAndIntervalActivate, &tmpsize);
		tmpsize = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm1stAndIntervalDeactivate, &tmpsize);
		tmpsize = StorageTmp->mtpOm5MinActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm5MinActivate, &tmpsize);
		tmpsize = StorageTmp->mtpOm5MinDeaActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm5MinDeaActivate, &tmpsize);
		tmpsize = StorageTmp->mtpOm15MinActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm15MinActivate, &tmpsize);
		tmpsize = StorageTmp->mtpOm15MinDeaActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm15MinDeaActivate, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmTimeStamp, &tmpsize);
#endif
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOm5MinMaxIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOm15MinMaxIntervals, &tmpsize);

		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpOmMIB: refresh mtpOmMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpOmMIB(void)
{
	if (mtpOmMIBStorage == NULL) {
		struct mtpOmMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(mtpOmMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->mtpOm5MinMaxIntervals = 96;
		StorageNew->mtpOm15MinMaxIntervals = 96;

		mtpOmMIBStorage = StorageNew;
		mtpOmMIB_refresh = 1;
	}
	if (mtpOmMIB_refresh == 0)
		return;
	mtpOmMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_mtpOmMIB(): locate variables in mtpOmMIB
 *
 * This function is called every time the agent gets a request for a scalar variable that might be
 * found within your mib section registered above.  It is up to you to do the right thing and return
 * the correct value.  You should also correct the value of "var_len" if necessary.
 *
 * Please see the documentation for more information about writing module extensions, and check out
 * the examples in the examples and mibII directories.
 */
u_char *
var_mtpOmMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpOmMIB();
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOM1STANDINTERVALACTIVATE:
		*write_method = write_mtpOm1stAndIntervalActivate;
		*var_len = StorageTmp->mtpOm1stAndIntervalActivateLen;
		return (u_char *) StorageTmp->mtpOm1stAndIntervalActivate;
	case MTPOM1STANDINTERVALDEACTIVATE:
		*write_method = write_mtpOm1stAndIntervalDeactivate;
		*var_len = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
		return (u_char *) StorageTmp->mtpOm1stAndIntervalDeactivate;
	case MTPOM5MINACTIVATE:
		*write_method = write_mtpOm5MinActivate;
		*var_len = StorageTmp->mtpOm5MinActivateLen;
		return (u_char *) StorageTmp->mtpOm5MinActivate;
	case MTPOM5MINDEAACTIVATE:
		*write_method = write_mtpOm5MinDeaActivate;
		*var_len = StorageTmp->mtpOm5MinDeaActivateLen;
		return (u_char *) StorageTmp->mtpOm5MinDeaActivate;
	case MTPOM15MINACTIVATE:
		*write_method = write_mtpOm15MinActivate;
		*var_len = StorageTmp->mtpOm15MinActivateLen;
		return (u_char *) StorageTmp->mtpOm15MinActivate;
	case MTPOM15MINDEAACTIVATE:
		*write_method = write_mtpOm15MinDeaActivate;
		*var_len = StorageTmp->mtpOm15MinDeaActivateLen;
		return (u_char *) StorageTmp->mtpOm15MinDeaActivate;
	case MTPOMDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmDiscontinuityTime);
		return (u_char *) &StorageTmp->mtpOmDiscontinuityTime;
	case MTPOMTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmTimeStamp);
		return (u_char *) &StorageTmp->mtpOmTimeStamp;
	case MTPOM5MINMAXINTERVALS:
		*write_method = write_mtpOm5MinMaxIntervals;
		*var_len = sizeof(StorageTmp->mtpOm5MinMaxIntervals);
		return (u_char *) &StorageTmp->mtpOm5MinMaxIntervals;
	case MTPOM15MINMAXINTERVALS:
		*write_method = write_mtpOm15MinMaxIntervals;
		*var_len = sizeof(StorageTmp->mtpOm15MinMaxIntervals);
		return (u_char *) &StorageTmp->mtpOm15MinMaxIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * mtpOmSpTable_add(): adds a structure node to our data set
 */
int
mtpOmSpTable_add(struct mtpOmSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));

	header_complex_add_data(&mtpOmSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpTable_del(): delete a structure
 */
int
mtpOmSpTable_del(struct mtpOmSpTable_data **thedata)
{
	struct mtpOmSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpTable(): parse configuration file for mtpOmSpTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpTable_data);

	DEBUGMSGTL(("mtpOmSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpOctetsXferred, &tmpsize);

	mtpOmSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpTable", "done.\n"));
}

/*
 * store_mtpOmSpTable(): store configuraiton file for mtpOmSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpTable", "storing data...  "));
	refresh_mtpOmSpTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpReceivedTFCstatus0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpReceivedTFCstatus1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpReceivedTFCstatus2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpOctetsXferred, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpInt5minTable_add(): adds a structure node to our data set
 */
int
mtpOmSpInt5minTable_add(struct mtpOmSpInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpOmSpInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpInt5minInterval, sizeof(thedata->mtpOmSpInt5minInterval));

	header_complex_add_data(&mtpOmSpInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpInt5minTable_del(): delete a structure
 */
int
mtpOmSpInt5minTable_del(struct mtpOmSpInt5minTable_data **thedata)
{
	struct mtpOmSpInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpInt5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpInt5minTable(): parse configuration file for mtpOmSpInt5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpInt5minTable_data);

	DEBUGMSGTL(("mtpOmSpInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minOctetsXferred, &tmpsize);

	mtpOmSpInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpInt5minTable", "done.\n"));
}

/*
 * store_mtpOmSpInt5minTable(): store configuraiton file for mtpOmSpInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpInt5minTable", "storing data...  "));
	refresh_mtpOmSpInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpInt5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpInt5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpInt5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus0, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus1, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus2, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minOctetsXferred, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpInt15minTable_add(): adds a structure node to our data set
 */
int
mtpOmSpInt15minTable_add(struct mtpOmSpInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpOmSpInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpInt15minInterval, sizeof(thedata->mtpOmSpInt15minInterval));

	header_complex_add_data(&mtpOmSpInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpInt15minTable_del(): delete a structure
 */
int
mtpOmSpInt15minTable_del(struct mtpOmSpInt15minTable_data **thedata)
{
	struct mtpOmSpInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpInt15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpInt15minTable(): parse configuration file for mtpOmSpInt15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpInt15minTable_data);

	DEBUGMSGTL(("mtpOmSpInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minOctetsXferred, &tmpsize);

	mtpOmSpInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpInt15minTable", "done.\n"));
}

/*
 * store_mtpOmSpInt15minTable(): store configuraiton file for mtpOmSpInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpInt15minTable", "storing data...  "));
	refresh_mtpOmSpInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpInt15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpInt15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpInt15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus0, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus1, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus2, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minOctetsXferred, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpSiTable_add(): adds a structure node to our data set
 */
int
mtpOmSpSiTable_add(struct mtpOmSpSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpOmSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));

	header_complex_add_data(&mtpOmSpSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpSiTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpSiTable_del(): delete a structure
 */
int
mtpOmSpSiTable_del(struct mtpOmSpSiTable_data **thedata)
{
	struct mtpOmSpSiTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpSiTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpSiTable(): parse configuration file for mtpOmSpSiTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpSiTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpSiTable_data);

	DEBUGMSGTL(("mtpOmSpSiTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpSiTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpSiTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpSiReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpSiHandledOctetsSIO, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiStatus, &tmpsize);

	mtpOmSpSiTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpSiTable", "done.\n"));
}

/*
 * store_mtpOmSpSiTable(): store configuraiton file for mtpOmSpSiTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpSiTable", "storing data...  "));
	refresh_mtpOmSpSiTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpSiTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpSiTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpSiTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpSiTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpSiTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpSiReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpSiHandledOctetsSIO, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiStatus, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpSiInt5minTable_add(): adds a structure node to our data set
 */
int
mtpOmSpSiInt5minTable_add(struct mtpOmSpSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpOmSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
	/* mtpOmSpSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiInt5minInterval, sizeof(thedata->mtpOmSpSiInt5minInterval));

	header_complex_add_data(&mtpOmSpSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpSiInt5minTable_del(): delete a structure
 */
int
mtpOmSpSiInt5minTable_del(struct mtpOmSpSiInt5minTable_data **thedata)
{
	struct mtpOmSpSiInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpSiInt5minTable(): parse configuration file for mtpOmSpSiInt5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpSiInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpSiInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO, &tmpsize);

	mtpOmSpSiInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "done.\n"));
}

/*
 * store_mtpOmSpSiInt5minTable(): store configuraiton file for mtpOmSpSiInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "storing data...  "));
	refresh_mtpOmSpSiInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpSiInt5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpSiInt5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpSiInt5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpSiInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpSiInt15minTable_add(): adds a structure node to our data set
 */
int
mtpOmSpSiInt15minTable_add(struct mtpOmSpSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpOmSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
	/* mtpOmSpSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiInt15minInterval, sizeof(thedata->mtpOmSpSiInt15minInterval));

	header_complex_add_data(&mtpOmSpSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpSiInt15minTable_del(): delete a structure
 */
int
mtpOmSpSiInt15minTable_del(struct mtpOmSpSiInt15minTable_data **thedata)
{
	struct mtpOmSpSiInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpSiInt15minTable(): parse configuration file for mtpOmSpSiInt15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpSiInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpSiInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO, &tmpsize);

	mtpOmSpSiInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "done.\n"));
}

/*
 * store_mtpOmSpSiInt15minTable(): store configuraiton file for mtpOmSpSiInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "storing data...  "));
	refresh_mtpOmSpSiInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpSiInt15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpSiInt15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpSiInt15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpSiInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyTable_add(): adds a structure node to our data set
 */
int
mtpOmSpStudyTable_add(struct mtpOmSpStudyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpStudyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpOmSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));

	header_complex_add_data(&mtpOmSpStudyTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpStudyTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyTable_del(): delete a structure
 */
int
mtpOmSpStudyTable_del(struct mtpOmSpStudyTable_data **thedata)
{
	struct mtpOmSpStudyTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpStudyTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpStudyTable(): parse configuration file for mtpOmSpStudyTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpStudyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpStudyTable_data);

	DEBUGMSGTL(("mtpOmSpStudyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpStudyValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpStudyTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpStudyStatus, &tmpsize);

	mtpOmSpStudyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpStudyTable", "done.\n"));
}

/*
 * store_mtpOmSpStudyTable(): store configuraiton file for mtpOmSpStudyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpStudyTable", "storing data...  "));
	refresh_mtpOmSpStudyTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpStudyTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpStudyValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpStudyTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpStudyStatus, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyInt5minTable_add(): adds a structure node to our data set
 */
int
mtpOmSpStudyInt5minTable_add(struct mtpOmSpStudyInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpOmSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
	/* mtpOmSpStudyInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyInt5minInterval, sizeof(thedata->mtpOmSpStudyInt5minInterval));

	header_complex_add_data(&mtpOmSpStudyInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyInt5minTable_del(): delete a structure
 */
int
mtpOmSpStudyInt5minTable_del(struct mtpOmSpStudyInt5minTable_data **thedata)
{
	struct mtpOmSpStudyInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpStudyInt5minTable(): parse configuration file for mtpOmSpStudyInt5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpStudyInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpStudyInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio, &tmpsize);

	mtpOmSpStudyInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "done.\n"));
}

/*
 * store_mtpOmSpStudyInt5minTable(): store configuraiton file for mtpOmSpStudyInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "storing data...  "));
	refresh_mtpOmSpStudyInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyInt5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpStudyInt5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyInt5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpStudyInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyInt15minTable_add(): adds a structure node to our data set
 */
int
mtpOmSpStudyInt15minTable_add(struct mtpOmSpStudyInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpOmSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
	/* mtpOmSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyInt15minInterval, sizeof(thedata->mtpOmSpStudyInt15minInterval));

	header_complex_add_data(&mtpOmSpStudyInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyInt15minTable_del(): delete a structure
 */
int
mtpOmSpStudyInt15minTable_del(struct mtpOmSpStudyInt15minTable_data **thedata)
{
	struct mtpOmSpStudyInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpStudyInt15minTable(): parse configuration file for mtpOmSpStudyInt15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpStudyInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpStudyInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio, &tmpsize);

	mtpOmSpStudyInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "done.\n"));
}

/*
 * store_mtpOmSpStudyInt15minTable(): store configuraiton file for mtpOmSpStudyInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "storing data...  "));
	refresh_mtpOmSpStudyInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyInt15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpStudyInt15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyInt15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpStudyInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyMapTable_add(): adds a structure node to our data set
 */
int
mtpOmSpStudyMapTable_add(struct mtpOmSpStudyMapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSpStudyMapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpOmSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
	/* mtpOmSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
	/* mtpOmOpcRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmOpcRsId, sizeof(thedata->mtpOmOpcRsId));
	/* mtpOmDpcRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmDpcRsId, sizeof(thedata->mtpOmDpcRsId));

	header_complex_add_data(&mtpOmSpStudyMapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSpStudyMapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSpStudyMapTable_del(): delete a structure
 */
int
mtpOmSpStudyMapTable_del(struct mtpOmSpStudyMapTable_data **thedata)
{
	struct mtpOmSpStudyMapTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSpStudyMapTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSpStudyMapTable(): parse configuration file for mtpOmSpStudyMapTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSpStudyMapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyMapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSpStudyMapTable_data);

	DEBUGMSGTL(("mtpOmSpStudyMapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmOpcRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmDpcRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpStudyMapStatus, &tmpsize);

	mtpOmSpStudyMapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSpStudyMapTable", "done.\n"));
}

/*
 * store_mtpOmSpStudyMapTable(): store configuraiton file for mtpOmSpStudyMapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyMapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyMapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSpStudyMapTable", "storing data...  "));
	refresh_mtpOmSpStudyMapTable();
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyMapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyMapTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSpStudyMapTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyMapTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmOpcRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmDpcRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpStudyMapStatus, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsTable_add(): adds a structure node to our data set
 */
int
mtpOmRsTable_add(struct mtpOmRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));

	header_complex_add_data(&mtpOmRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmRsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsTable_del(): delete a structure
 */
int
mtpOmRsTable_del(struct mtpOmRsTable_data **thedata)
{
	struct mtpOmRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmRsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmRsTable(): parse configuration file for mtpOmRsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmRsTable_data);

	DEBUGMSGTL(("mtpOmRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsRouteSetUnavailableDuration, &tmpsize);

	mtpOmRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmRsTable", "done.\n"));
}

/*
 * store_mtpOmRsTable(): store configuraiton file for mtpOmRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmRsTable", "storing data...  "));
	refresh_mtpOmRsTable();
	(void) tmpsize;
	for (hcindex = mtpOmRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmRsTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsReceivedMSUsOpc, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsTransmittedMSUsDpc, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsRouteSetUnavailableDuration, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsInt5minTable_add(): adds a structure node to our data set
 */
int
mtpOmRsInt5minTable_add(struct mtpOmRsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmRsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpOmRsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsInt5minInterval, sizeof(thedata->mtpOmRsInt5minInterval));

	header_complex_add_data(&mtpOmRsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmRsInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsInt5minTable_del(): delete a structure
 */
int
mtpOmRsInt5minTable_del(struct mtpOmRsInt5minTable_data **thedata)
{
	struct mtpOmRsInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmRsInt5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmRsInt5minTable(): parse configuration file for mtpOmRsInt5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmRsInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmRsInt5minTable_data);

	DEBUGMSGTL(("mtpOmRsInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration, &tmpsize);

	mtpOmRsInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmRsInt5minTable", "done.\n"));
}

/*
 * store_mtpOmRsInt5minTable(): store configuraiton file for mtpOmRsInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmRsInt5minTable", "storing data...  "));
	refresh_mtpOmRsInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmRsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsInt5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmRsInt5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsInt5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minReceivedMSUsOpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsInt15minTable_add(): adds a structure node to our data set
 */
int
mtpOmRsInt15minTable_add(struct mtpOmRsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmRsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpOmRsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsInt15minInterval, sizeof(thedata->mtpOmRsInt15minInterval));

	header_complex_add_data(&mtpOmRsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmRsInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsInt15minTable_del(): delete a structure
 */
int
mtpOmRsInt15minTable_del(struct mtpOmRsInt15minTable_data **thedata)
{
	struct mtpOmRsInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmRsInt15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmRsInt15minTable(): parse configuration file for mtpOmRsInt15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmRsInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmRsInt15minTable_data);

	DEBUGMSGTL(("mtpOmRsInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration, &tmpsize);

	mtpOmRsInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmRsInt15minTable", "done.\n"));
}

/*
 * store_mtpOmRsInt15minTable(): store configuraiton file for mtpOmRsInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmRsInt15minTable", "storing data...  "));
	refresh_mtpOmRsInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmRsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsInt15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmRsInt15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsInt15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minReceivedMSUsOpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsSiTable_add(): adds a structure node to our data set
 */
int
mtpOmRsSiTable_add(struct mtpOmRsSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmRsSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpOmRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiCode, sizeof(thedata->mtpOmRsSiCode));

	header_complex_add_data(&mtpOmRsSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmRsSiTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsSiTable_del(): delete a structure
 */
int
mtpOmRsSiTable_del(struct mtpOmRsSiTable_data **thedata)
{
	struct mtpOmRsSiTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmRsSiTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmRsSiTable(): parse configuration file for mtpOmRsSiTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmRsSiTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmRsSiTable_data);

	DEBUGMSGTL(("mtpOmRsSiTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsSiTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiStatus, &tmpsize);

	mtpOmRsSiTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmRsSiTable", "done.\n"));
}

/*
 * store_mtpOmRsSiTable(): store configuraiton file for mtpOmRsSiTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmRsSiTable", "storing data...  "));
	refresh_mtpOmRsSiTable();
	(void) tmpsize;
	for (hcindex = mtpOmRsSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsSiTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmRsSiTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsSiTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsSiTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiReceivedMSUsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiStatus, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsSiInt5minTable_add(): adds a structure node to our data set
 */
int
mtpOmRsSiInt5minTable_add(struct mtpOmRsSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpOmRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiCode, sizeof(thedata->mtpOmRsSiCode));
	/* mtpOmRsSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiInt5minInterval, sizeof(thedata->mtpOmRsSiInt5minInterval));

	header_complex_add_data(&mtpOmRsSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsSiInt5minTable_del(): delete a structure
 */
int
mtpOmRsSiInt5minTable_del(struct mtpOmRsSiInt5minTable_data **thedata)
{
	struct mtpOmRsSiInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmRsSiInt5minTable(): parse configuration file for mtpOmRsSiInt5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmRsSiInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsSiInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio, &tmpsize);

	mtpOmRsSiInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "done.\n"));
}

/*
 * store_mtpOmRsSiInt5minTable(): store configuraiton file for mtpOmRsSiInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "storing data...  "));
	refresh_mtpOmRsSiInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmRsSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsSiInt5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmRsSiInt5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsSiInt5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsSiInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsSiInt15minTable_add(): adds a structure node to our data set
 */
int
mtpOmRsSiInt15minTable_add(struct mtpOmRsSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpOmRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiCode, sizeof(thedata->mtpOmRsSiCode));
	/* mtpOmRsSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiInt15minInterval, sizeof(thedata->mtpOmRsSiInt15minInterval));

	header_complex_add_data(&mtpOmRsSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmRsSiInt15minTable_del(): delete a structure
 */
int
mtpOmRsSiInt15minTable_del(struct mtpOmRsSiInt15minTable_data **thedata)
{
	struct mtpOmRsSiInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmRsSiInt15minTable(): parse configuration file for mtpOmRsSiInt15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmRsSiInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsSiInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio, &tmpsize);

	mtpOmRsSiInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "done.\n"));
}

/*
 * store_mtpOmRsSiInt15minTable(): store configuraiton file for mtpOmRsSiInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "storing data...  "));
	refresh_mtpOmRsSiInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmRsSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsSiInt15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmRsSiInt15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsSiInt15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsSiInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmLsTable_add(): adds a structure node to our data set
 */
int
mtpOmLsTable_add(struct mtpOmLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));

	header_complex_add_data(&mtpOmLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmLsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmLsTable_del(): delete a structure
 */
int
mtpOmLsTable_del(struct mtpOmLsTable_data **thedata)
{
	struct mtpOmLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmLsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmLsTable(): parse configuration file for mtpOmLsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmLsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmLsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmLsTable_data);

	DEBUGMSGTL(("mtpOmLsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmLsValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmLsTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmLsAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmLsAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmLsSlsUnavailable, &tmpsize);

	mtpOmLsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmLsTable", "done.\n"));
}

/*
 * store_mtpOmLsTable(): store configuraiton file for mtpOmLsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmLsTable", "storing data...  "));
	refresh_mtpOmLsTable();
	(void) tmpsize;
	for (hcindex = mtpOmLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmLsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmLsTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmLsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmLsValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmLsTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmLsAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmLsAdjacentInaccessibleDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmLsSlsUnavailable, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmLsInt5minTable_add(): adds a structure node to our data set
 */
int
mtpOmLsInt5minTable_add(struct mtpOmLsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmLsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpOmLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmLsInt5minInterval, sizeof(thedata->mtpOmLsInt5minInterval));

	header_complex_add_data(&mtpOmLsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmLsInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmLsInt5minTable_del(): delete a structure
 */
int
mtpOmLsInt5minTable_del(struct mtpOmLsInt5minTable_data **thedata)
{
	struct mtpOmLsInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmLsInt5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmLsInt5minTable(): parse configuration file for mtpOmLsInt5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmLsInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmLsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmLsInt5minTable_data);

	DEBUGMSGTL(("mtpOmLsInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmLsInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmLsInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt5minSlsUnavailable, &tmpsize);

	mtpOmLsInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmLsInt5minTable", "done.\n"));
}

/*
 * store_mtpOmLsInt5minTable(): store configuraiton file for mtpOmLsInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmLsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmLsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmLsInt5minTable", "storing data...  "));
	refresh_mtpOmLsInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmLsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmLsInt5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmLsInt5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmLsInt5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmLsInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmLsInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt5minSlsUnavailable, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmLsInt15minTable_add(): adds a structure node to our data set
 */
int
mtpOmLsInt15minTable_add(struct mtpOmLsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmLsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpOmLsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmLsInt15minInterval, sizeof(thedata->mtpOmLsInt15minInterval));

	header_complex_add_data(&mtpOmLsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmLsInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmLsInt15minTable_del(): delete a structure
 */
int
mtpOmLsInt15minTable_del(struct mtpOmLsInt15minTable_data **thedata)
{
	struct mtpOmLsInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmLsInt15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmLsInt15minTable(): parse configuration file for mtpOmLsInt15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmLsInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmLsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmLsInt15minTable_data);

	DEBUGMSGTL(("mtpOmLsInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmLsInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmLsInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt15minSlsUnavailable, &tmpsize);

	mtpOmLsInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmLsInt15minTable", "done.\n"));
}

/*
 * store_mtpOmLsInt15minTable(): store configuraiton file for mtpOmLsInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmLsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmLsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmLsInt15minTable", "storing data...  "));
	refresh_mtpOmLsInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmLsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmLsInt15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmLsInt15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmLsInt15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmLsInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmLsInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt15minSlsUnavailable, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlStatsTable_add(): adds a structure node to our data set
 */
int
mtpOmSlStatsTable_add(struct mtpOmSlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpOmSlStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlStatsTable_del(): delete a structure
 */
int
mtpOmSlStatsTable_del(struct mtpOmSlStatsTable_data **thedata)
{
	struct mtpOmSlStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlStatsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlStatsTable(): parse configuration file for mtpOmSlStatsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlStatsTable_data);

	DEBUGMSGTL(("mtpOmSlStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurInService, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsFailAlignOrProving, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsNacksReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurUnavail, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurUnavailFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurUnavailRpo, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsSibsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsTranSioSifOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsRetransOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsTranMsus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsRecvSioSifOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsRecvMsus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd3, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus3, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd3, &tmpsize);

	mtpOmSlStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlStatsTable", "done.\n"));
}

/*
 * store_mtpOmSlStatsTable(): store configuraiton file for mtpOmSlStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlStatsTable", "storing data...  "));
	refresh_mtpOmSlStatsTable();
	(void) tmpsize;
	for (hcindex = mtpOmSlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlStatsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlStatsTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlStatsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurInService, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsFailAlignOrProving, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsNacksReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurUnavail, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurUnavailFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurUnavailRpo, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsSibsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsTranSioSifOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsRetransOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsTranMsus, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsRecvSioSifOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsRecvMsus, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd3, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus3, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd3, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL3Table_add(): adds a structure node to our data set
 */
int
mtpOmSlL3Table_add(struct mtpOmSlL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlL3Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpOmSlL3TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlL3Table", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL3Table_del(): delete a structure
 */
int
mtpOmSlL3Table_del(struct mtpOmSlL3Table_data **thedata)
{
	struct mtpOmSlL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlL3Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlL3Table(): parse configuration file for mtpOmSlL3Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlL3Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL3Table_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlL3Table_data);

	DEBUGMSGTL(("mtpOmSlL3Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlL3ValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL3TimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3LocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3LocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3LocalBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3DiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3CongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3Changeovers, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3Changebacks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3Restorations, &tmpsize);

	mtpOmSlL3Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlL3Table", "done.\n"));
}

/*
 * store_mtpOmSlL3Table(): store configuraiton file for mtpOmSlL3Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlL3Table", "storing data...  "));
	refresh_mtpOmSlL3Table();
	(void) tmpsize;
	for (hcindex = mtpOmSlL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL3Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlL3TableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL3Table ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlL3ValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL3TimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3LocalMgmtInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3LocalMgmtUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3LocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlCongestedStarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlCongestedDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3DiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3CongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3Changeovers, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3Changebacks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3Restorations, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL3Int5minTable_add(): adds a structure node to our data set
 */
int
mtpOmSlL3Int5minTable_add(struct mtpOmSlL3Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpOmSlL3Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL3Int5minInterval, sizeof(thedata->mtpOmSlL3Int5minInterval));

	header_complex_add_data(&mtpOmSlL3Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL3Int5minTable_del(): delete a structure
 */
int
mtpOmSlL3Int5minTable_del(struct mtpOmSlL3Int5minTable_data **thedata)
{
	struct mtpOmSlL3Int5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlL3Int5minTable(): parse configuration file for mtpOmSlL3Int5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlL3Int5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL3Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlL3Int5minTable_data);

	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL3Int5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL3Int5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minRestorations, &tmpsize);

	mtpOmSlL3Int5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "done.\n"));
}

/*
 * store_mtpOmSlL3Int5minTable(): store configuraiton file for mtpOmSlL3Int5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL3Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL3Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "storing data...  "));
	refresh_mtpOmSlL3Int5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSlL3Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL3Int5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlL3Int5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL3Int5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL3Int5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL3Int5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minLocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlCongestedStarts, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlCongestedDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minChangeovers, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minChangebacks, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minRestorations, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL3Int15minTable_add(): adds a structure node to our data set
 */
int
mtpOmSlL3Int15minTable_add(struct mtpOmSlL3Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpOmSlL3Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL3Int15minInterval, sizeof(thedata->mtpOmSlL3Int15minInterval));

	header_complex_add_data(&mtpOmSlL3Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL3Int15minTable_del(): delete a structure
 */
int
mtpOmSlL3Int15minTable_del(struct mtpOmSlL3Int15minTable_data **thedata)
{
	struct mtpOmSlL3Int15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlL3Int15minTable(): parse configuration file for mtpOmSlL3Int15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlL3Int15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL3Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlL3Int15minTable_data);

	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL3Int15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL3Int15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minRestorations, &tmpsize);

	mtpOmSlL3Int15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "done.\n"));
}

/*
 * store_mtpOmSlL3Int15minTable(): store configuraiton file for mtpOmSlL3Int15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL3Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL3Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "storing data...  "));
	refresh_mtpOmSlL3Int15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSlL3Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL3Int15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlL3Int15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL3Int15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL3Int15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL3Int15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minLocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlCongestedStarts, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlCongestedDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minChangeovers, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minChangebacks, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minRestorations, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL2Table_add(): adds a structure node to our data set
 */
int
mtpOmSlL2Table_add(struct mtpOmSlL2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlL2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpOmSlL2TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlL2Table", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlL2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL2Table_del(): delete a structure
 */
int
mtpOmSlL2Table_del(struct mtpOmSlL2Table_data **thedata)
{
	struct mtpOmSlL2Table_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlL2Table", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlL2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlL2Table(): parse configuration file for mtpOmSlL2Table
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlL2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL2Table_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlL2Table_data);

	DEBUGMSGTL(("mtpOmSlL2Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlL2ValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL2TimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2SlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2SlAlignment, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2SignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2NegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2RetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2TransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2ReceivedMSUs, &tmpsize);

	mtpOmSlL2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlL2Table", "done.\n"));
}

/*
 * store_mtpOmSlL2Table(): store configuraiton file for mtpOmSlL2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlL2Table", "storing data...  "));
	refresh_mtpOmSlL2Table();
	(void) tmpsize;
	for (hcindex = mtpOmSlL2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL2Table_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlL2TableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL2Table ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlL2ValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL2TimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2SlInServiceDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2SlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2SignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2NegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2RetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2TransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2ReceivedMSUs, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlL2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL2Int5minTable_add(): adds a structure node to our data set
 */
int
mtpOmSlL2Int5minTable_add(struct mtpOmSlL2Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpOmSlL2Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL2Int5minInterval, sizeof(thedata->mtpOmSlL2Int5minInterval));

	header_complex_add_data(&mtpOmSlL2Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL2Int5minTable_del(): delete a structure
 */
int
mtpOmSlL2Int5minTable_del(struct mtpOmSlL2Int5minTable_data **thedata)
{
	struct mtpOmSlL2Int5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlL2Int5minTable(): parse configuration file for mtpOmSlL2Int5minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlL2Int5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL2Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlL2Int5minTable_data);

	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL2Int5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL2Int5minTimestamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minReceivedMSUs, &tmpsize);

	mtpOmSlL2Int5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "done.\n"));
}

/*
 * store_mtpOmSlL2Int5minTable(): store configuraiton file for mtpOmSlL2Int5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL2Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL2Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "storing data...  "));
	refresh_mtpOmSlL2Int5minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSlL2Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL2Int5minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlL2Int5minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL2Int5minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL2Int5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL2Int5minTimestamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minSlInServiceDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minSlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minSignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minNegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minRetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minTransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minReceivedMSUs, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL2Int15minTable_add(): adds a structure node to our data set
 */
int
mtpOmSlL2Int15minTable_add(struct mtpOmSlL2Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpOmSlL2Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL2Int15minInterval, sizeof(thedata->mtpOmSlL2Int15minInterval));

	header_complex_add_data(&mtpOmSlL2Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSlL2Int15minTable_del(): delete a structure
 */
int
mtpOmSlL2Int15minTable_del(struct mtpOmSlL2Int15minTable_data **thedata)
{
	struct mtpOmSlL2Int15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSlL2Int15minTable(): parse configuration file for mtpOmSlL2Int15minTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSlL2Int15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL2Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSlL2Int15minTable_data);

	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL2Int15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL2Int15minTimestamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minReceivedMSUs, &tmpsize);

	mtpOmSlL2Int15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "done.\n"));
}

/*
 * store_mtpOmSlL2Int15minTable(): store configuraiton file for mtpOmSlL2Int15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL2Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL2Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "storing data...  "));
	refresh_mtpOmSlL2Int15minTable();
	(void) tmpsize;
	for (hcindex = mtpOmSlL2Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL2Int15minTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSlL2Int15minTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL2Int15minTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL2Int15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL2Int15minTimestamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minSlInServiceDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minSlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minSignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minNegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minRetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minTransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minReceivedMSUs, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSdtStatsTable_add(): adds a structure node to our data set
 */
int
mtpOmSdtStatsTable_add(struct mtpOmSdtStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSdtStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));

	header_complex_add_data(&mtpOmSdtStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSdtStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSdtStatsTable_del(): delete a structure
 */
int
mtpOmSdtStatsTable_del(struct mtpOmSdtStatsTable_data **thedata)
{
	struct mtpOmSdtStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSdtStatsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSdtStatsTable(): parse configuration file for mtpOmSdtStatsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSdtStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSdtStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSdtStatsTable_data);

	DEBUGMSGTL(("mtpOmSdtStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxBytes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxSus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxSusRepeated, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxUnderruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxAborts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxSusInError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxBytes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxSusCompressed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxOverruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxAborts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxSusInError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxSyncTransitions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxBitsOctetCounted, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxCrcErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameTooLong, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameTooShort, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxResidueErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsCarrierCtsLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsCarrierDcdLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsCarrierLost, &tmpsize);

	mtpOmSdtStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSdtStatsTable", "done.\n"));
}

/*
 * store_mtpOmSdtStatsTable(): store configuraiton file for mtpOmSdtStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSdtStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSdtStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSdtStatsTable", "storing data...  "));
	refresh_mtpOmSdtStatsTable();
	(void) tmpsize;
	for (hcindex = mtpOmSdtStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSdtStatsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSdtStatsTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSdtStatsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxBytes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxSus, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxSusRepeated, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxUnderruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxAborts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxSusInError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxBytes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxSusCompressed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxOverruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxAborts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxSusInError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxSyncTransitions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxBitsOctetCounted, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxCrcErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameTooLong, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameTooShort, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxResidueErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsCarrierCtsLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsCarrierDcdLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsCarrierLost, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSdlStatsTable_add(): adds a structure node to our data set
 */
int
mtpOmSdlStatsTable_add(struct mtpOmSdlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmSdlStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdlId, sizeof(thedata->mtpSdlId));

	header_complex_add_data(&mtpOmSdlStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpOmSdlStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpOmSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpOmSdlStatsTable_del(): delete a structure
 */
int
mtpOmSdlStatsTable_del(struct mtpOmSdlStatsTable_data **thedata)
{
	struct mtpOmSdlStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmSdlStatsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmSdlStatsTable(): parse configuration file for mtpOmSdlStatsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmSdlStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSdlStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmSdlStatsTable_data);

	DEBUGMSGTL(("mtpOmSdlStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsRxOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsTxOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsRXOverruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsTxUnderruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsRxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsTxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsLeadCtsLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsLeadDcdLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsCarrierLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsBipolarViolations, &tmpsize);

	mtpOmSdlStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmSdlStatsTable", "done.\n"));
}

/*
 * store_mtpOmSdlStatsTable(): store configuraiton file for mtpOmSdlStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSdlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSdlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmSdlStatsTable", "storing data...  "));
	refresh_mtpOmSdlStatsTable();
	(void) tmpsize;
	for (hcindex = mtpOmSdlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSdlStatsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->mtpOmSdlStatsTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSdlStatsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsRxOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsTxOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsRXOverruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsTxUnderruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsRxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsTxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsLeadCtsLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsLeadDcdLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsCarrierLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsBipolarViolations, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpOmSpTable(): refresh mtpOmSpTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpTable(void)
{
	if (mtpOmSpTable_refresh == 0)
		return;
	mtpOmSpTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpTable_row(): refresh mtpOmSpTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpTable_row(struct mtpOmSpTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpTable_request = sa_request;
}

/*
 * var_mtpOmSpTable(): locate variables in mtpOmSpTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpValidIntervals);
		return (u_char *) &StorageTmp->mtpOmSpValidIntervals;
	case MTPOMSPTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmSpTimeDiscontinuity;
	case MTPOMSPDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpOmSpDiscardedMSUs;
	case MTPOMSPRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpOmSpReceivedTFCstatus0;
	case MTPOMSPRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpOmSpReceivedTFCstatus1;
	case MTPOMSPRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpOmSpReceivedTFCstatus2;
	case MTPOMSPOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpOctetsXferred);
		return (u_char *) &StorageTmp->mtpOmSpOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpInt5minTable(): refresh mtpOmSpInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpInt5minTable(void)
{
	if (mtpOmSpInt5minTable_refresh == 0)
		return;
	mtpOmSpInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpInt5minTable_row(): refresh mtpOmSpInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpInt5minTable_row(struct mtpOmSpInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpInt5minTable_request = sa_request;
}

/*
 * var_mtpOmSpInt5minTable(): locate variables in mtpOmSpInt5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSpInt5minTimeStamp;
	case MTPOMSPINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpOmSpInt5minDiscardedMSUs;
	case MTPOMSPINT5MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpOmSpInt5minReceivedTFCstatus0;
	case MTPOMSPINT5MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpOmSpInt5minReceivedTFCstatus1;
	case MTPOMSPINT5MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpOmSpInt5minReceivedTFCstatus2;
	case MTPOMSPINT5MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minOctetsXferred);
		return (u_char *) &StorageTmp->mtpOmSpInt5minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpInt15minTable(): refresh mtpOmSpInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpInt15minTable(void)
{
	if (mtpOmSpInt15minTable_refresh == 0)
		return;
	mtpOmSpInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpInt15minTable_row(): refresh mtpOmSpInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpInt15minTable_row(struct mtpOmSpInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpInt15minTable_request = sa_request;
}

/*
 * var_mtpOmSpInt15minTable(): locate variables in mtpOmSpInt15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSpInt15minTimeStamp;
	case MTPOMSPINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpOmSpInt15minDiscardedMSUs;
	case MTPOMSPINT15MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpOmSpInt15minReceivedTFCstatus0;
	case MTPOMSPINT15MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpOmSpInt15minReceivedTFCstatus1;
	case MTPOMSPINT15MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpOmSpInt15minReceivedTFCstatus2;
	case MTPOMSPINT15MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minOctetsXferred);
		return (u_char *) &StorageTmp->mtpOmSpInt15minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpSiTable(): refresh mtpOmSpSiTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpSiTable(void)
{
	if (mtpOmSpSiTable_refresh == 0)
		return;
	mtpOmSpSiTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpSiTable_row(): refresh mtpOmSpSiTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpSiTable_row(struct mtpOmSpSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpSiTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpSiTable_request = sa_request;
}

/*
 * var_mtpOmSpSiTable(): locate variables in mtpOmSpSiTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpSiTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpSiTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSIVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiValidIntervals);
		return (u_char *) &StorageTmp->mtpOmSpSiValidIntervals;
	case MTPOMSPSITIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmSpSiTimeDiscontinuity;
	case MTPOMSPSITRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpOmSpSiTransmittedUPUnavailable;
	case MTPOMSPSIRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpOmSpSiReceivedUPUnavailable;
	case MTPOMSPSIHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpOmSpSiHandledOctetsSIO;
	case MTPOMSPSISTATUS:
		*write_method = write_mtpOmSpSiStatus;
		*var_len = sizeof(StorageTmp->mtpOmSpSiStatus);
		return (u_char *) &StorageTmp->mtpOmSpSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpSiInt5minTable(): refresh mtpOmSpSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpSiInt5minTable(void)
{
	if (mtpOmSpSiInt5minTable_refresh == 0)
		return;
	mtpOmSpSiInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpSiInt5minTable_row(): refresh mtpOmSpSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpSiInt5minTable_row(struct mtpOmSpSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpSiInt5minTable_request = sa_request;
}

/*
 * var_mtpOmSpSiInt5minTable(): locate variables in mtpOmSpSiInt5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpSiInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpSiInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSpSiInt5minTimeStamp;
	case MTPOMSPSIINT5MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable;
	case MTPOMSPSIINT5MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable;
	case MTPOMSPSIINT5MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpSiInt15minTable(): refresh mtpOmSpSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpSiInt15minTable(void)
{
	if (mtpOmSpSiInt15minTable_refresh == 0)
		return;
	mtpOmSpSiInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpSiInt15minTable_row(): refresh mtpOmSpSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpSiInt15minTable_row(struct mtpOmSpSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpSiInt15minTable_request = sa_request;
}

/*
 * var_mtpOmSpSiInt15minTable(): locate variables in mtpOmSpSiInt15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpSiInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpSiInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSpSiInt15minTimeStamp;
	case MTPOMSPSIINT15MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable;
	case MTPOMSPSIINT15MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable;
	case MTPOMSPSIINT15MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpStudyTable(): refresh mtpOmSpStudyTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyTable(void)
{
	if (mtpOmSpStudyTable_refresh == 0)
		return;
	mtpOmSpStudyTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpStudyTable_row(): refresh mtpOmSpStudyTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpStudyTable_row(struct mtpOmSpStudyTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpStudyTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpStudyTable_request = sa_request;
}

/*
 * var_mtpOmSpStudyTable(): locate variables in mtpOmSpStudyTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpStudyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpStudyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpStudyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSTUDYVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyValidIntervals);
		return (u_char *) &StorageTmp->mtpOmSpStudyValidIntervals;
	case MTPOMSPSTUDYTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmSpStudyTimeDiscontinuity;
	case MTPOMSPSTUDYHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio;
	case MTPOMSPSTUDYHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio;
	case MTPOMSPSTUDYSTATUS:
		*write_method = write_mtpOmSpStudyStatus;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyStatus);
		return (u_char *) &StorageTmp->mtpOmSpStudyStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpStudyInt5minTable(): refresh mtpOmSpStudyInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyInt5minTable(void)
{
	if (mtpOmSpStudyInt5minTable_refresh == 0)
		return;
	mtpOmSpStudyInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpStudyInt5minTable_row(): refresh mtpOmSpStudyInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpStudyInt5minTable_row(struct mtpOmSpStudyInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpStudyInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpStudyInt5minTable_request = sa_request;
}

/*
 * var_mtpOmSpStudyInt5minTable(): locate variables in mtpOmSpStudyInt5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpStudyInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpStudyInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpStudyInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSTUDYINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSpStudyInt5minTimeStamp;
	case MTPOMSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio;
	case MTPOMSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpStudyInt15minTable(): refresh mtpOmSpStudyInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyInt15minTable(void)
{
	if (mtpOmSpStudyInt15minTable_refresh == 0)
		return;
	mtpOmSpStudyInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpStudyInt15minTable_row(): refresh mtpOmSpStudyInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpStudyInt15minTable_row(struct mtpOmSpStudyInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpStudyInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpStudyInt15minTable_request = sa_request;
}

/*
 * var_mtpOmSpStudyInt15minTable(): locate variables in mtpOmSpStudyInt15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpStudyInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpStudyInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpStudyInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSTUDYINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSpStudyInt15minTimeStamp;
	case MTPOMSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio;
	case MTPOMSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSpStudyMapTable(): refresh mtpOmSpStudyMapTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyMapTable(void)
{
	if (mtpOmSpStudyMapTable_refresh == 0)
		return;
	mtpOmSpStudyMapTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSpStudyMapTable_row(): refresh mtpOmSpStudyMapTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSpStudyMapTable_row(struct mtpOmSpStudyMapTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSpStudyMapTable_request == sa_request)
		return;
	StorageTmp->mtpOmSpStudyMapTable_request = sa_request;
}

/*
 * var_mtpOmSpStudyMapTable(): locate variables in mtpOmSpStudyMapTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyMapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyMapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyMapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSpStudyMapTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSpStudyMapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSpStudyMapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSPSTUDYMAPSTATUS:
		*write_method = write_mtpOmSpStudyMapStatus;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyMapStatus);
		return (u_char *) &StorageTmp->mtpOmSpStudyMapStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmRsTable(): refresh mtpOmRsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsTable(void)
{
	if (mtpOmRsTable_refresh == 0)
		return;
	mtpOmRsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmRsTable_row(): refresh mtpOmRsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmRsTable_row(struct mtpOmRsTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmRsTable_request == sa_request)
		return;
	StorageTmp->mtpOmRsTable_request = sa_request;
}

/*
 * var_mtpOmRsTable(): locate variables in mtpOmRsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmRsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmRsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMRSVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsValidIntervals);
		return (u_char *) &StorageTmp->mtpOmRsValidIntervals;
	case MTPOMRSTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmRsTimeDiscontinuity;
	case MTPOMRSRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpOmRsReceivedOctetsOPC;
	case MTPOMRSTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpOmRsTransmittedOctetsDPC;
	case MTPOMRSRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpOmRsReceivedMSUsOpc;
	case MTPOMRSTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpOmRsTransmittedMSUsDpc;
	case MTPOMRSROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpOmRsRouteSetUnavailable;
	case MTPOMRSROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpOmRsRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmRsInt5minTable(): refresh mtpOmRsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsInt5minTable(void)
{
	if (mtpOmRsInt5minTable_refresh == 0)
		return;
	mtpOmRsInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmRsInt5minTable_row(): refresh mtpOmRsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmRsInt5minTable_row(struct mtpOmRsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmRsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmRsInt5minTable_request = sa_request;
}

/*
 * var_mtpOmRsInt5minTable(): locate variables in mtpOmRsInt5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmRsInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmRsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmRsInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMRSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmRsInt5minTimeStamp;
	case MTPOMRSINT5MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpOmRsInt5minReceivedOctetsOPC;
	case MTPOMRSINT5MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC;
	case MTPOMRSINT5MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpOmRsInt5minReceivedMSUsOpc;
	case MTPOMRSINT5MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc;
	case MTPOMRSINT5MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpOmRsInt5minRouteSetUnavailable;
	case MTPOMRSINT5MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmRsInt15minTable(): refresh mtpOmRsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsInt15minTable(void)
{
	if (mtpOmRsInt15minTable_refresh == 0)
		return;
	mtpOmRsInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmRsInt15minTable_row(): refresh mtpOmRsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmRsInt15minTable_row(struct mtpOmRsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmRsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmRsInt15minTable_request = sa_request;
}

/*
 * var_mtpOmRsInt15minTable(): locate variables in mtpOmRsInt15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmRsInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmRsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmRsInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMRSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmRsInt15minTimeStamp;
	case MTPOMRSINT15MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpOmRsInt15minReceivedOctetsOPC;
	case MTPOMRSINT15MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC;
	case MTPOMRSINT15MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpOmRsInt15minReceivedMSUsOpc;
	case MTPOMRSINT15MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc;
	case MTPOMRSINT15MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpOmRsInt15minRouteSetUnavailable;
	case MTPOMRSINT15MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmRsSiTable(): refresh mtpOmRsSiTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsSiTable(void)
{
	if (mtpOmRsSiTable_refresh == 0)
		return;
	mtpOmRsSiTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmRsSiTable_row(): refresh mtpOmRsSiTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmRsSiTable_row(struct mtpOmRsSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmRsSiTable_request == sa_request)
		return;
	StorageTmp->mtpOmRsSiTable_request = sa_request;
}

/*
 * var_mtpOmRsSiTable(): locate variables in mtpOmRsSiTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmRsSiTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmRsSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmRsSiTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMRSSIVALIDINTERVALS:
		*write_method = write_mtpOmRsSiValidIntervals;
		*var_len = sizeof(StorageTmp->mtpOmRsSiValidIntervals);
		return (u_char *) &StorageTmp->mtpOmRsSiValidIntervals;
	case MTPOMRSSITIMEDISCONTINUITY:
		*write_method = write_mtpOmRsSiTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpOmRsSiTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmRsSiTimeDiscontinuity;
	case MTPOMRSSIRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiReceivedOctetsOpcSio;
	case MTPOMRSSITRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio;
	case MTPOMRSSIRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiReceivedMSUsOpcSio;
	case MTPOMRSSITRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio;
	case MTPOMRSSISTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiStatus);
		return (u_char *) &StorageTmp->mtpOmRsSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmRsSiInt5minTable(): refresh mtpOmRsSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsSiInt5minTable(void)
{
	if (mtpOmRsSiInt5minTable_refresh == 0)
		return;
	mtpOmRsSiInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmRsSiInt5minTable_row(): refresh mtpOmRsSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmRsSiInt5minTable_row(struct mtpOmRsSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmRsSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmRsSiInt5minTable_request = sa_request;
}

/*
 * var_mtpOmRsSiInt5minTable(): locate variables in mtpOmRsSiInt5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmRsSiInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmRsSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmRsSiInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmRsSiInt5minTimeStamp;
	case MTPOMRSSIINT5MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio;
	case MTPOMRSSIINT5MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio;
	case MTPOMRSSIINT5MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio;
	case MTPOMRSSIINT5MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmRsSiInt15minTable(): refresh mtpOmRsSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsSiInt15minTable(void)
{
	if (mtpOmRsSiInt15minTable_refresh == 0)
		return;
	mtpOmRsSiInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmRsSiInt15minTable_row(): refresh mtpOmRsSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmRsSiInt15minTable_row(struct mtpOmRsSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmRsSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmRsSiInt15minTable_request = sa_request;
}

/*
 * var_mtpOmRsSiInt15minTable(): locate variables in mtpOmRsSiInt15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmRsSiInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmRsSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmRsSiInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMRSSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmRsSiInt15minTimeStamp;
	case MTPOMRSSIINT15MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio;
	case MTPOMRSSIINT15MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio;
	case MTPOMRSSIINT15MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio;
	case MTPOMRSSIINT15MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmLsTable(): refresh mtpOmLsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmLsTable(void)
{
	if (mtpOmLsTable_refresh == 0)
		return;
	mtpOmLsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmLsTable_row(): refresh mtpOmLsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmLsTable_row(struct mtpOmLsTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmLsTable_request == sa_request)
		return;
	StorageTmp->mtpOmLsTable_request = sa_request;
}

/*
 * var_mtpOmLsTable(): locate variables in mtpOmLsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmLsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmLsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmLsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmLsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMLSVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsValidIntervals);
		return (u_char *) &StorageTmp->mtpOmLsValidIntervals;
	case MTPOMLSTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmLsTimeDiscontinuity;
	case MTPOMLSADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpOmLsAdjacentInaccessibleEvents;
	case MTPOMLSADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpOmLsAdjacentInaccessibleDuration;
	case MTPOMLSSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsSlsUnavailable);
		return (u_char *) &StorageTmp->mtpOmLsSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmLsInt5minTable(): refresh mtpOmLsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmLsInt5minTable(void)
{
	if (mtpOmLsInt5minTable_refresh == 0)
		return;
	mtpOmLsInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmLsInt5minTable_row(): refresh mtpOmLsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmLsInt5minTable_row(struct mtpOmLsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmLsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmLsInt5minTable_request = sa_request;
}

/*
 * var_mtpOmLsInt5minTable(): locate variables in mtpOmLsInt5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmLsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmLsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmLsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmLsInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmLsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmLsInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMLSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmLsInt5minTimeStamp;
	case MTPOMLSINT5MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents;
	case MTPOMLSINT5MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration;
	case MTPOMLSINT5MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minSlsUnavailable);
		return (u_char *) &StorageTmp->mtpOmLsInt5minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmLsInt15minTable(): refresh mtpOmLsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmLsInt15minTable(void)
{
	if (mtpOmLsInt15minTable_refresh == 0)
		return;
	mtpOmLsInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmLsInt15minTable_row(): refresh mtpOmLsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmLsInt15minTable_row(struct mtpOmLsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmLsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmLsInt15minTable_request = sa_request;
}

/*
 * var_mtpOmLsInt15minTable(): locate variables in mtpOmLsInt15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmLsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmLsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmLsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmLsInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmLsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmLsInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMLSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmLsInt15minTimeStamp;
	case MTPOMLSINT15MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents;
	case MTPOMLSINT15MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration;
	case MTPOMLSINT15MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minSlsUnavailable);
		return (u_char *) &StorageTmp->mtpOmLsInt15minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlStatsTable(): refresh mtpOmSlStatsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlStatsTable(void)
{
	if (mtpOmSlStatsTable_refresh == 0)
		return;
	mtpOmSlStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlStatsTable_row(): refresh mtpOmSlStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlStatsTable_row(struct mtpOmSlStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlStatsTable_request == sa_request)
		return;
	StorageTmp->mtpOmSlStatsTable_request = sa_request;
}

/*
 * var_mtpOmSlStatsTable(): locate variables in mtpOmSlStatsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLSTATSDURINSERVICE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurInService);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurInService;
	case MTPOMSLSTATSFAILALIGNORPROVING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsFailAlignOrProving);
		return (u_char *) &StorageTmp->mtpOmSlStatsFailAlignOrProving;
	case MTPOMSLSTATSNACKSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsNacksReceived);
		return (u_char *) &StorageTmp->mtpOmSlStatsNacksReceived;
	case MTPOMSLSTATSDURUNAVAIL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurUnavail);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurUnavail;
	case MTPOMSLSTATSDURUNAVAILFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurUnavailFailed);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurUnavailFailed;
	case MTPOMSLSTATSDURUNAVAILRPO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurUnavailRpo);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurUnavailRpo;
	case MTPOMSLSTATSSIBSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsSibsSent);
		return (u_char *) &StorageTmp->mtpOmSlStatsSibsSent;
	case MTPOMSLSTATSTRANSIOSIFOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsTranSioSifOctets);
		return (u_char *) &StorageTmp->mtpOmSlStatsTranSioSifOctets;
	case MTPOMSLSTATSRETRANSOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsRetransOctets);
		return (u_char *) &StorageTmp->mtpOmSlStatsRetransOctets;
	case MTPOMSLSTATSTRANMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsTranMsus);
		return (u_char *) &StorageTmp->mtpOmSlStatsTranMsus;
	case MTPOMSLSTATSRECVSIOSIFOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsRecvSioSifOctets);
		return (u_char *) &StorageTmp->mtpOmSlStatsRecvSioSifOctets;
	case MTPOMSLSTATSRECVMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsRecvMsus);
		return (u_char *) &StorageTmp->mtpOmSlStatsRecvMsus;
	case MTPOMSLSTATSCONGONSETIND0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd0);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd0;
	case MTPOMSLSTATSCONGONSETIND1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd1);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd1;
	case MTPOMSLSTATSCONGONSETIND2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd2);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd2;
	case MTPOMSLSTATSCONGONSETIND3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd3);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd3;
	case MTPOMSLSTATSDURCONGSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus0);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus0;
	case MTPOMSLSTATSDURCONGSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus1);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus1;
	case MTPOMSLSTATSDURCONGSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus2);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus2;
	case MTPOMSLSTATSDURCONGSTATUS3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus3);
		return (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus3;
	case MTPOMSLSTATSCONGDISCDIND0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd0);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd0;
	case MTPOMSLSTATSCONGDISCDIND1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd1);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd1;
	case MTPOMSLSTATSCONGDISCDIND2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd2);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd2;
	case MTPOMSLSTATSCONGDISCDIND3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd3);
		return (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd3;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlL3Table(): refresh mtpOmSlL3Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL3Table(void)
{
	if (mtpOmSlL3Table_refresh == 0)
		return;
	mtpOmSlL3Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlL3Table_row(): refresh mtpOmSlL3Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlL3Table_row(struct mtpOmSlL3Table_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlL3Table_request == sa_request)
		return;
	StorageTmp->mtpOmSlL3Table_request = sa_request;
}

/*
 * var_mtpOmSlL3Table(): locate variables in mtpOmSlL3Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL3Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlL3Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlL3TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlL3Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLL3VALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3ValidIntervals);
		return (u_char *) &StorageTmp->mtpOmSlL3ValidIntervals;
	case MTPOMSLL3TIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3TimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmSlL3TimeDiscontinuity;
	case MTPOMSLL3SLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpOmSlL3SlUnavailabilityDuration;
	case MTPOMSLL3SLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlLocalInhibition);
		return (u_char *) &StorageTmp->mtpOmSlL3SlLocalInhibition;
	case MTPOMSLL3SLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpOmSlL3SlRemoteInhibition;
	case MTPOMSLL3SLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlFailed);
		return (u_char *) &StorageTmp->mtpOmSlL3SlFailed;
	case MTPOMSLL3SLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpOmSlL3SlRemoteProcOutage;
	case MTPOMSLL3LOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3LocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpOmSlL3LocalMgmtInhibit;
	case MTPOMSLL3LOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3LocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpOmSlL3LocalMgmtUninhibit;
	case MTPOMSLL3LOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3LocalBusy);
		return (u_char *) &StorageTmp->mtpOmSlL3LocalBusy;
	case MTPOMSLL3SLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlCongestedStarts);
		return (u_char *) &StorageTmp->mtpOmSlL3SlCongestedStarts;
	case MTPOMSLL3SLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlCongestedDuration);
		return (u_char *) &StorageTmp->mtpOmSlL3SlCongestedDuration;
	case MTPOMSLL3SLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlCongestionStops);
		return (u_char *) &StorageTmp->mtpOmSlL3SlCongestionStops;
	case MTPOMSLL3DISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3DiscardedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL3DiscardedMSUs;
	case MTPOMSLL3CONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3CongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpOmSlL3CongestionEventsMSULoss;
	case MTPOMSLL3CHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Changeovers);
		return (u_char *) &StorageTmp->mtpOmSlL3Changeovers;
	case MTPOMSLL3CHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Changebacks);
		return (u_char *) &StorageTmp->mtpOmSlL3Changebacks;
	case MTPOMSLL3RESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Restorations);
		return (u_char *) &StorageTmp->mtpOmSlL3Restorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlL3Int5minTable(): refresh mtpOmSlL3Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL3Int5minTable(void)
{
	if (mtpOmSlL3Int5minTable_refresh == 0)
		return;
	mtpOmSlL3Int5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlL3Int5minTable_row(): refresh mtpOmSlL3Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlL3Int5minTable_row(struct mtpOmSlL3Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlL3Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSlL3Int5minTable_request = sa_request;
}

/*
 * var_mtpOmSlL3Int5minTable(): locate variables in mtpOmSlL3Int5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL3Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL3Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL3Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlL3Int5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlL3Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlL3Int5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLL3INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minTimeStamp;
	case MTPOMSLL3INT5MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration;
	case MTPOMSLL3INT5MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlLocalInhibition;
	case MTPOMSLL3INT5MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition;
	case MTPOMSLL3INT5MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlFailed);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlFailed;
	case MTPOMSLL3INT5MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage;
	case MTPOMSLL3INT5MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit;
	case MTPOMSLL3INT5MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit;
	case MTPOMSLL3INT5MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minLocalBusy);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minLocalBusy;
	case MTPOMSLL3INT5MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlCongestedStarts;
	case MTPOMSLL3INT5MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlCongestedDuration;
	case MTPOMSLL3INT5MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlCongestionStops);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minSlCongestionStops;
	case MTPOMSLL3INT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minDiscardedMSUs;
	case MTPOMSLL3INT5MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss;
	case MTPOMSLL3INT5MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minChangeovers);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minChangeovers;
	case MTPOMSLL3INT5MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minChangebacks);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minChangebacks;
	case MTPOMSLL3INT5MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minRestorations);
		return (u_char *) &StorageTmp->mtpOmSlL3Int5minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlL3Int15minTable(): refresh mtpOmSlL3Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL3Int15minTable(void)
{
	if (mtpOmSlL3Int15minTable_refresh == 0)
		return;
	mtpOmSlL3Int15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlL3Int15minTable_row(): refresh mtpOmSlL3Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlL3Int15minTable_row(struct mtpOmSlL3Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlL3Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSlL3Int15minTable_request = sa_request;
}

/*
 * var_mtpOmSlL3Int15minTable(): locate variables in mtpOmSlL3Int15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL3Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL3Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL3Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlL3Int15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlL3Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlL3Int15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLL3INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minTimeStamp);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minTimeStamp;
	case MTPOMSLL3INT15MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration;
	case MTPOMSLL3INT15MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlLocalInhibition;
	case MTPOMSLL3INT15MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition;
	case MTPOMSLL3INT15MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlFailed);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlFailed;
	case MTPOMSLL3INT15MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage;
	case MTPOMSLL3INT15MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit;
	case MTPOMSLL3INT15MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit;
	case MTPOMSLL3INT15MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minLocalBusy);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minLocalBusy;
	case MTPOMSLL3INT15MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlCongestedStarts;
	case MTPOMSLL3INT15MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlCongestedDuration;
	case MTPOMSLL3INT15MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlCongestionStops);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minSlCongestionStops;
	case MTPOMSLL3INT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minDiscardedMSUs;
	case MTPOMSLL3INT15MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss;
	case MTPOMSLL3INT15MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minChangeovers);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minChangeovers;
	case MTPOMSLL3INT15MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minChangebacks);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minChangebacks;
	case MTPOMSLL3INT15MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minRestorations);
		return (u_char *) &StorageTmp->mtpOmSlL3Int15minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlL2Table(): refresh mtpOmSlL2Table
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL2Table(void)
{
	if (mtpOmSlL2Table_refresh == 0)
		return;
	mtpOmSlL2Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlL2Table_row(): refresh mtpOmSlL2Table row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlL2Table_row(struct mtpOmSlL2Table_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlL2Table_request == sa_request)
		return;
	StorageTmp->mtpOmSlL2Table_request = sa_request;
}

/*
 * var_mtpOmSlL2Table(): locate variables in mtpOmSlL2Table
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlL2Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlL2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlL2Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLL2VALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2ValidIntervals);
		return (u_char *) &StorageTmp->mtpOmSlL2ValidIntervals;
	case MTPOMSLL2TIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2TimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpOmSlL2TimeDiscontinuity;
	case MTPOMSLL2SLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2SlInServiceDuration);
		return (u_char *) &StorageTmp->mtpOmSlL2SlInServiceDuration;
	case MTPOMSLL2SLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2SlAlignment);
		return (u_char *) &StorageTmp->mtpOmSlL2SlAlignment;
	case MTPOMSLL2SIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2SignUnitsReceived);
		return (u_char *) &StorageTmp->mtpOmSlL2SignUnitsReceived;
	case MTPOMSLL2NEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2NegAckReceived);
		return (u_char *) &StorageTmp->mtpOmSlL2NegAckReceived;
	case MTPOMSLL2TRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO;
	case MTPOMSLL2RETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2RetransmittedOctets);
		return (u_char *) &StorageTmp->mtpOmSlL2RetransmittedOctets;
	case MTPOMSLL2TRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2TransmittedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL2TransmittedMSUs;
	case MTPOMSLL2RECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO;
	case MTPOMSLL2RECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2ReceivedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL2ReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlL2Int5minTable(): refresh mtpOmSlL2Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL2Int5minTable(void)
{
	if (mtpOmSlL2Int5minTable_refresh == 0)
		return;
	mtpOmSlL2Int5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlL2Int5minTable_row(): refresh mtpOmSlL2Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlL2Int5minTable_row(struct mtpOmSlL2Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlL2Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSlL2Int5minTable_request = sa_request;
}

/*
 * var_mtpOmSlL2Int5minTable(): locate variables in mtpOmSlL2Int5minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL2Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL2Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL2Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlL2Int5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlL2Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlL2Int5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLL2INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minTimestamp);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minTimestamp;
	case MTPOMSLL2INT5MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minSlInServiceDuration);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minSlInServiceDuration;
	case MTPOMSLL2INT5MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minSlAlignment);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minSlAlignment;
	case MTPOMSLL2INT5MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minSignUnitsReceived);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minSignUnitsReceived;
	case MTPOMSLL2INT5MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minNegAckReceived);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minNegAckReceived;
	case MTPOMSLL2INT5MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO;
	case MTPOMSLL2INT5MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minRetransmittedOctets);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minRetransmittedOctets;
	case MTPOMSLL2INT5MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minTransmittedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minTransmittedMSUs;
	case MTPOMSLL2INT5MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO;
	case MTPOMSLL2INT5MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minReceivedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL2Int5minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSlL2Int15minTable(): refresh mtpOmSlL2Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL2Int15minTable(void)
{
	if (mtpOmSlL2Int15minTable_refresh == 0)
		return;
	mtpOmSlL2Int15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSlL2Int15minTable_row(): refresh mtpOmSlL2Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSlL2Int15minTable_row(struct mtpOmSlL2Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSlL2Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpOmSlL2Int15minTable_request = sa_request;
}

/*
 * var_mtpOmSlL2Int15minTable(): locate variables in mtpOmSlL2Int15minTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL2Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL2Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL2Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSlL2Int15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSlL2Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSlL2Int15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSLL2INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minTimestamp);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minTimestamp;
	case MTPOMSLL2INT15MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minSlInServiceDuration);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minSlInServiceDuration;
	case MTPOMSLL2INT15MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minSlAlignment);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minSlAlignment;
	case MTPOMSLL2INT15MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minSignUnitsReceived);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minSignUnitsReceived;
	case MTPOMSLL2INT15MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minNegAckReceived);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minNegAckReceived;
	case MTPOMSLL2INT15MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO;
	case MTPOMSLL2INT15MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minRetransmittedOctets);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minRetransmittedOctets;
	case MTPOMSLL2INT15MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minTransmittedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minTransmittedMSUs;
	case MTPOMSLL2INT15MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO;
	case MTPOMSLL2INT15MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minReceivedMSUs);
		return (u_char *) &StorageTmp->mtpOmSlL2Int15minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSdtStatsTable(): refresh mtpOmSdtStatsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSdtStatsTable(void)
{
	if (mtpOmSdtStatsTable_refresh == 0)
		return;
	mtpOmSdtStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSdtStatsTable_row(): refresh mtpOmSdtStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSdtStatsTable_row(struct mtpOmSdtStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSdtStatsTable_request == sa_request)
		return;
	StorageTmp->mtpOmSdtStatsTable_request = sa_request;
}

/*
 * var_mtpOmSdtStatsTable(): locate variables in mtpOmSdtStatsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSdtStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSdtStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSdtStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSdtStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSdtStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSdtStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSDTSTATSTXBYTES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxBytes);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxBytes;
	case MTPOMSDTSTATSTXSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxSus);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxSus;
	case MTPOMSDTSTATSTXSUSREPEATED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxSusRepeated);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxSusRepeated;
	case MTPOMSDTSTATSTXUNDERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxUnderruns);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxUnderruns;
	case MTPOMSDTSTATSTXABORTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxAborts);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxAborts;
	case MTPOMSDTSTATSTXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxBufferOverflows);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxBufferOverflows;
	case MTPOMSDTSTATSTXSUSINERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxSusInError);
		return (u_char *) &StorageTmp->mtpOmSdtStatsTxSusInError;
	case MTPOMSDTSTATSRXBYTES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxBytes);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxBytes;
	case MTPOMSDTSTATSRXSUSCOMPRESSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxSusCompressed);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxSusCompressed;
	case MTPOMSDTSTATSRXOVERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxOverruns);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxOverruns;
	case MTPOMSDTSTATSRXABORTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxAborts);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxAborts;
	case MTPOMSDTSTATSRXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxBufferOverflows);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxBufferOverflows;
	case MTPOMSDTSTATSRXSUSINERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxSusInError);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxSusInError;
	case MTPOMSDTSTATSRXSYNCTRANSITIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxSyncTransitions);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxSyncTransitions;
	case MTPOMSDTSTATSRXBITSOCTETCOUNTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxBitsOctetCounted);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxBitsOctetCounted;
	case MTPOMSDTSTATSRXCRCERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxCrcErrors);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxCrcErrors;
	case MTPOMSDTSTATSRXFRAMEERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameErrors);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameErrors;
	case MTPOMSDTSTATSRXFRAMEOVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameOverflows);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameOverflows;
	case MTPOMSDTSTATSRXFRAMETOOLONG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameTooLong);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameTooLong;
	case MTPOMSDTSTATSRXFRAMETOOSHORT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameTooShort);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameTooShort;
	case MTPOMSDTSTATSRXRESIDUEERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxResidueErrors);
		return (u_char *) &StorageTmp->mtpOmSdtStatsRxResidueErrors;
	case MTPOMSDTSTATSCARRIERCTSLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsCarrierCtsLost);
		return (u_char *) &StorageTmp->mtpOmSdtStatsCarrierCtsLost;
	case MTPOMSDTSTATSCARRIERDCDLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsCarrierDcdLost);
		return (u_char *) &StorageTmp->mtpOmSdtStatsCarrierDcdLost;
	case MTPOMSDTSTATSCARRIERLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsCarrierLost);
		return (u_char *) &StorageTmp->mtpOmSdtStatsCarrierLost;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpOmSdlStatsTable(): refresh mtpOmSdlStatsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSdlStatsTable(void)
{
	if (mtpOmSdlStatsTable_refresh == 0)
		return;
	mtpOmSdlStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpOmSdlStatsTable_row(): refresh mtpOmSdlStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_mtpOmSdlStatsTable_row(struct mtpOmSdlStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpOmSdlStatsTable_request == sa_request)
		return;
	StorageTmp->mtpOmSdlStatsTable_request = sa_request;
}

/*
 * var_mtpOmSdlStatsTable(): locate variables in mtpOmSdlStatsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSdlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSdlStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSdlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpOmSdlStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpOmSdlStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpOmSdlStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOMSDLSTATSRXOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsRxOctets);
		return (u_char *) &StorageTmp->mtpOmSdlStatsRxOctets;
	case MTPOMSDLSTATSTXOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsTxOctets);
		return (u_char *) &StorageTmp->mtpOmSdlStatsTxOctets;
	case MTPOMSDLSTATSRXOVERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsRXOverruns);
		return (u_char *) &StorageTmp->mtpOmSdlStatsRXOverruns;
	case MTPOMSDLSTATSTXUNDERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsTxUnderruns);
		return (u_char *) &StorageTmp->mtpOmSdlStatsTxUnderruns;
	case MTPOMSDLSTATSRXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsRxBufferOverflows);
		return (u_char *) &StorageTmp->mtpOmSdlStatsRxBufferOverflows;
	case MTPOMSDLSTATSTXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsTxBufferOverflows);
		return (u_char *) &StorageTmp->mtpOmSdlStatsTxBufferOverflows;
	case MTPOMSDLSTATSLEADCTSLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsLeadCtsLost);
		return (u_char *) &StorageTmp->mtpOmSdlStatsLeadCtsLost;
	case MTPOMSDLSTATSLEADDCDLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsLeadDcdLost);
		return (u_char *) &StorageTmp->mtpOmSdlStatsLeadDcdLost;
	case MTPOMSDLSTATSCARRIERLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsCarrierLost);
		return (u_char *) &StorageTmp->mtpOmSdlStatsCarrierLost;
	case MTPOMSDLSTATSBIPOLARVIOLATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsBipolarViolations);
		return (u_char *) &StorageTmp->mtpOmSdlStatsBipolarViolations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mtpOmRsSiValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmRsSiValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpOmRsSiTableStorage, NULL, &name[sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..96 */
		if ((0 > set_value || set_value > 96)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOmRsSiValidIntervals;
		StorageTmp->mtpOmRsSiValidIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOmRsSiValidIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOmRsSiTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmRsSiTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpOmRsSiTableStorage, NULL, &name[sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiTimeDiscontinuity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOmRsSiTimeDiscontinuity;
		StorageTmp->mtpOmRsSiTimeDiscontinuity = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOmRsSiTimeDiscontinuity = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm1stAndIntervalActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm1stAndIntervalActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm1stAndIntervalActivate;
		old_length = StorageTmp->mtpOm1stAndIntervalActivateLen;
		StorageTmp->mtpOm1stAndIntervalActivate = objid;
		StorageTmp->mtpOm1stAndIntervalActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm1stAndIntervalActivate = old_value;
		StorageTmp->mtpOm1stAndIntervalActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm1stAndIntervalDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm1stAndIntervalDeactivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalDeactivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalDeactivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm1stAndIntervalDeactivate;
		old_length = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
		StorageTmp->mtpOm1stAndIntervalDeactivate = objid;
		StorageTmp->mtpOm1stAndIntervalDeactivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm1stAndIntervalDeactivate = old_value;
		StorageTmp->mtpOm1stAndIntervalDeactivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm5MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm5MinActivate;
		old_length = StorageTmp->mtpOm5MinActivateLen;
		StorageTmp->mtpOm5MinActivate = objid;
		StorageTmp->mtpOm5MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinActivate = old_value;
		StorageTmp->mtpOm5MinActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm5MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm5MinDeaActivate;
		old_length = StorageTmp->mtpOm5MinDeaActivateLen;
		StorageTmp->mtpOm5MinDeaActivate = objid;
		StorageTmp->mtpOm5MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinDeaActivate = old_value;
		StorageTmp->mtpOm5MinDeaActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm15MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm15MinActivate;
		old_length = StorageTmp->mtpOm15MinActivateLen;
		StorageTmp->mtpOm15MinActivate = objid;
		StorageTmp->mtpOm15MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinActivate = old_value;
		StorageTmp->mtpOm15MinActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm15MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm15MinDeaActivate;
		old_length = StorageTmp->mtpOm15MinDeaActivateLen;
		StorageTmp->mtpOm15MinDeaActivate = objid;
		StorageTmp->mtpOm15MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinDeaActivate = old_value;
		StorageTmp->mtpOm15MinDeaActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm5MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..288 */
		if ((0 > set_value || set_value > 288)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm5MinMaxIntervals;
		StorageTmp->mtpOm5MinMaxIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinMaxIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm15MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..672 */
		if ((0 > set_value || set_value > 672)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->mtpOm15MinMaxIntervals;
		StorageTmp->mtpOm15MinMaxIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinMaxIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOmSpSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSpSiTable_data *StorageTmp = NULL;
	static struct mtpOmSpSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpOmSpSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpOmSpSiTableStorage, NULL, &name[sizeof(mtpOmSpSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSpSiStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSpSiTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSpSiTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmSpSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpOmSpSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmSpSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpOmSpSiStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpOmSpSiTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpOmSpSiTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmSpSiStatus;
			StorageTmp->mtpOmSpSiStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpOmSpSiTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpOmSpSiTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpOmSpSiTableStorage, StorageNew);
			header_complex_extract_entry(&mtpOmSpSiTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmSpSiStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpOmSpSiTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmSpSiStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmSpSiStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmSpSiTable_del(&StorageDel);
			/* mtpOmSpSiTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOmSpStudyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSpStudyTable_data *StorageTmp = NULL;
	static struct mtpOmSpStudyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpOmSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpOmSpStudyTableStorage, NULL, &name[sizeof(mtpOmSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpStudyStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSpStudyStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSpStudyTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSpStudyTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmSpStudyId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpOmSpStudyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmSpStudyId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpOmSpStudyStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpOmSpStudyTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpOmSpStudyTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmSpStudyStatus;
			StorageTmp->mtpOmSpStudyStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpOmSpStudyTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpOmSpStudyTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpOmSpStudyTableStorage, StorageNew);
			header_complex_extract_entry(&mtpOmSpStudyTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmSpStudyStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpOmSpStudyTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmSpStudyStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmSpStudyStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmSpStudyTable_del(&StorageDel);
			/* mtpOmSpStudyTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOmSpStudyMapStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSpStudyMapTable_data *StorageTmp = NULL;
	static struct mtpOmSpStudyMapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpOmSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpOmSpStudyMapTableStorage, NULL, &name[sizeof(mtpOmSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpStudyMapStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSpStudyMapStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSpStudyMapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSpStudyMapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmSpSiCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmSpStudyId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmOpcRsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmDpcRsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpOmSpStudyMapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyMapTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmSpSiCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmSpStudyId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmOpcRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmDpcRsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpOmSpStudyMapStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpOmSpStudyMapTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpOmSpStudyMapTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmSpStudyMapStatus;
			StorageTmp->mtpOmSpStudyMapStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpOmSpStudyMapTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpOmSpStudyMapTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpOmSpStudyMapTableStorage, StorageNew);
			header_complex_extract_entry(&mtpOmSpStudyMapTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmSpStudyMapStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpOmSpStudyMapTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmSpStudyMapStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmSpStudyMapStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmSpStudyMapTable_del(&StorageDel);
			/* mtpOmSpStudyMapTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOmRsSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	static struct mtpOmRsSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpOmRsSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpOmRsSiTableStorage, NULL, &name[sizeof(mtpOmRsSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmRsSiStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmRsSiTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmRsSiTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOmRsSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpOmRsSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmRsSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpOmRsSiStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			mtpOmRsSiTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			mtpOmRsSiTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmRsSiStatus;
			StorageTmp->mtpOmRsSiStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(mtpOmRsSiTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&mtpOmRsSiTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpOmRsSiTableStorage, StorageNew);
			header_complex_extract_entry(&mtpOmRsSiTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmRsSiStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			mtpOmRsSiTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmRsSiStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->mtpOmRsSiStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmRsSiTable_del(&StorageDel);
			/* mtpOmRsSiTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
