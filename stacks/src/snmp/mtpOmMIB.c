/*****************************************************************************

 @(#) $RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 0.9.2.3 $) $Date: 2008-12-27 15:29:46 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-27 15:29:46 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpOmMIB.c,v $
 Revision 0.9.2.3  2008-12-27 15:29:46  brian
 - split MTP and MTP OM mib

 Revision 0.9.2.2  2008-12-24 13:08:25  brian
 - building ss7confd

 *****************************************************************************/

#ident "@(#) $RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 0.9.2.3 $) $Date: 2008-12-27 15:29:46 $"

static char const ident[] = "$RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 0.9.2.3 $) $Date: 2008-12-27 15:29:46 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ss7MIB.h"
#include "x400pMIB.h"
#include "mtpMIB.h"
#include "mtpOmMIB.h"
#include "sccpMIB.h"
#include "sccpOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int mtpOmMIB_refresh = 1;
volatile int mtpSpCurrentTable_refresh = 1;
volatile int mtpSpInt5minTable_refresh = 1;
volatile int mtpSpInt15minTable_refresh = 1;
volatile int mtpSpSiTable_refresh = 1;
volatile int mtpSpSiInt5minTable_refresh = 1;
volatile int mtpSpSiInt15minTable_refresh = 1;
volatile int mtpSpStudyTable_refresh = 1;
volatile int mtpSpStudyInt5minTable_refresh = 1;
volatile int mtpSpStudyInt15minTable_refresh = 1;
volatile int mtpSpStudyMapTable_refresh = 1;
volatile int mtpRsCurrentTable_refresh = 1;
volatile int mtpRsInt5minTable_refresh = 1;
volatile int mtpRsInt15minTable_refresh = 1;
volatile int mtpRsSiTable_refresh = 1;
volatile int mtpRsSiInt5minTable_refresh = 1;
volatile int mtpRsSiInt15minTable_refresh = 1;
volatile int mtpLsCurrentTable_refresh = 1;
volatile int mtpLsInt5minTable_refresh = 1;
volatile int mtpLsInt15minTable_refresh = 1;
volatile int mtpSlStatsTable_refresh = 1;
volatile int mtpSlL3CurrentTable_refresh = 1;
volatile int mtpSlL3Int5minTable_refresh = 1;
volatile int mtpSlL3Int15minTable_refresh = 1;
volatile int mtpSlL2CurrentTable_refresh = 1;
volatile int mtpSlL2Int5minTable_refresh = 1;
volatile int mtpSlL2Int15minTable_refresh = 1;
volatile int mtpSdtStatsTable_refresh = 1;
volatile int mtpSdlStatsTable_refresh = 1;

/*
 * mtpOmMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid mtpOmMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1 };
oid mtpSpSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 4, 1 };
oid mtpSpStudyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 7, 1 };
oid mtpSpStudyMapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 10, 1 };
oid mtpRsSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 2, 4, 1 };

/*
 * variable7 mtpOmMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the mtpOmMIB mib section
 */
struct variable7 mtpOmMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   MTPSPCURRENTVALIDINTERVALS  (4 % 256)
	{MTPSPCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 1}},
#define   MTPSPCURRENTTIMEDISCONTINUITY  (5 % 256)
	{MTPSPCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSPCURRENTDISCARDEDMSUS  (6 % 256)
	{MTPSPCURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS0  (7 % 256)
	{MTPSPCURRENTRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS1  (8 % 256)
	{MTPSPCURRENTRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS2  (9 % 256)
	{MTPSPCURRENTRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSPCURRENTOCTETSXFERRED  (10 % 256)
	{MTPSPCURRENTOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSPINT5MINTIMESTAMP  (15 % 256)
	{MTPSPINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 1, 2, 1, 2}},
#define   MTPSPINT5MINDISCARDEDMSUS  (16 % 256)
	{MTPSPINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 1, 2, 1, 3}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS0  (17 % 256)
	{MTPSPINT5MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 1, 2, 1, 4}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS1  (18 % 256)
	{MTPSPINT5MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 1, 2, 1, 5}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS2  (19 % 256)
	{MTPSPINT5MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 1, 2, 1, 6}},
#define   MTPSPINT5MINOCTETSXFERRED  (20 % 256)
	{MTPSPINT5MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 1, 2, 1, 7}},
#define   MTPSPINT15MINTIMESTAMP  (25 % 256)
	{MTPSPINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 1, 3, 1, 2}},
#define   MTPSPINT15MINDISCARDEDMSUS  (26 % 256)
	{MTPSPINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 1, 3, 1, 3}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS0  (27 % 256)
	{MTPSPINT15MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 1, 3, 1, 4}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS1  (28 % 256)
	{MTPSPINT15MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 1, 3, 1, 5}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS2  (29 % 256)
	{MTPSPINT15MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 1, 3, 1, 6}},
#define   MTPSPINT15MINOCTETSXFERRED  (30 % 256)
	{MTPSPINT15MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 1, 3, 1, 7}},
#define   MTPSPSIVALIDINTERVALS  (35 % 256)
	{MTPSPSIVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpSiTable, 6, {1, 1, 1, 4, 1, 2}},
#define   MTPSPSITIMEDISCONTINUITY  (36 % 256)
	{MTPSPSITIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpSiTable, 6, {1, 1, 1, 4, 1, 3}},
#define   MTPSPSITRANSMITTEDUPUNAVAILABLE  (37 % 256)
	{MTPSPSITRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 1, 4, 1, 4}},
#define   MTPSPSIRECEIVEDUPUNAVAILABLE  (38 % 256)
	{MTPSPSIRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 1, 4, 1, 5}},
#define   MTPSPSIHANDLEDOCTETSSIO  (39 % 256)
	{MTPSPSIHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 1, 4, 1, 6}},
#define   MTPSPSISTATUS         (40 % 256)
	{MTPSPSISTATUS, ASN_INTEGER, RWRITE, var_mtpSpSiTable, 6, {1, 1, 1, 4, 1, 7}},
#define   MTPSPSIINT5MINTIMESTAMP  (46 % 256)
	{MTPSPSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 2}},
#define   MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE  (47 % 256)
	{MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 3}},
#define   MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE  (48 % 256)
	{MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 4}},
#define   MTPSPSIINT5MINHANDLEDOCTETSSIO  (49 % 256)
	{MTPSPSIINT5MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 5}},
#define   MTPSPSIINT15MINTIMESTAMP  (55 % 256)
	{MTPSPSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 2}},
#define   MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE  (56 % 256)
	{MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 3}},
#define   MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE  (57 % 256)
	{MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 4}},
#define   MTPSPSIINT15MINHANDLEDOCTETSSIO  (58 % 256)
	{MTPSPSIINT15MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 5}},
#define   MTPSPSTUDYVALIDINTERVALS  (62 % 256)
	{MTPSPSTUDYVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpStudyTable, 6, {1, 1, 1, 7, 1, 2}},
#define   MTPSPSTUDYTIMEDISCONTINUITY  (63 % 256)
	{MTPSPSTUDYTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpStudyTable, 6, {1, 1, 1, 7, 1, 3}},
#define   MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO  (64 % 256)
	{MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 1, 7, 1, 4}},
#define   MTPSPSTUDYHANDLEDMSUSOPCDPCSIO  (65 % 256)
	{MTPSPSTUDYHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 1, 7, 1, 5}},
#define   MTPSPSTUDYSTATUS      (66 % 256)
	{MTPSPSTUDYSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyTable, 6, {1, 1, 1, 7, 1, 6}},
#define   MTPSPSTUDYINT5MINTIMESTAMP  (71 % 256)
	{MTPSPSTUDYINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 2}},
#define   MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO  (72 % 256)
	{MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 3}},
#define   MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO  (73 % 256)
	{MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 4}},
#define   MTPSPSTUDYINT15MINTIMESTAMP  (78 % 256)
	{MTPSPSTUDYINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 2}},
#define   MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO  (79 % 256)
	{MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 3}},
#define   MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO  (80 % 256)
	{MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 4}},
#define   MTPSPSTUDYMAPSTATUS   (88 % 256)
	{MTPSPSTUDYMAPSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyMapTable, 6, {1, 1, 1, 10, 1, 3}},
#define   MTPRSCURRENTVALIDINTERVALS  (92 % 256)
	{MTPRSCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 1}},
#define   MTPRSCURRENTTIMEDISCONTINUITY  (93 % 256)
	{MTPRSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPRSCURRENTRECEIVEDOCTETSOPC  (94 % 256)
	{MTPRSCURRENTRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPRSCURRENTTRANSMITTEDOCTETSDPC  (95 % 256)
	{MTPRSCURRENTTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPRSCURRENTRECEIVEDMSUSOPC  (96 % 256)
	{MTPRSCURRENTRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPRSCURRENTTRANSMITTEDMSUSDPC  (97 % 256)
	{MTPRSCURRENTTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPRSCURRENTROUTESETUNAVAILABLE  (98 % 256)
	{MTPRSCURRENTROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPRSCURRENTROUTESETUNAVAILABLEDURATION  (99 % 256)
	{MTPRSCURRENTROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsCurrentTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPRSINT5MINTIMESTAMP  (104 % 256)
	{MTPRSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 2}},
#define   MTPRSINT5MINRECEIVEDOCTETSOPC  (105 % 256)
	{MTPRSINT5MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 3}},
#define   MTPRSINT5MINTRANSMITTEDOCTETSDPC  (106 % 256)
	{MTPRSINT5MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 4}},
#define   MTPRSINT5MINRECEIVEDMSUSOPC  (107 % 256)
	{MTPRSINT5MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 5}},
#define   MTPRSINT5MINTRANSMITTEDMSUSDPC  (108 % 256)
	{MTPRSINT5MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 6}},
#define   MTPRSINT5MINROUTESETUNAVAILABLE  (109 % 256)
	{MTPRSINT5MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 7}},
#define   MTPRSINT5MINROUTESETUNAVAILABLEDURATION  (110 % 256)
	{MTPRSINT5MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 2, 2, 1, 8}},
#define   MTPRSINT15MINTIMESTAMP  (115 % 256)
	{MTPRSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 2}},
#define   MTPRSINT15MINRECEIVEDOCTETSOPC  (116 % 256)
	{MTPRSINT15MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 3}},
#define   MTPRSINT15MINTRANSMITTEDOCTETSDPC  (117 % 256)
	{MTPRSINT15MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 4}},
#define   MTPRSINT15MINRECEIVEDMSUSOPC  (118 % 256)
	{MTPRSINT15MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 5}},
#define   MTPRSINT15MINTRANSMITTEDMSUSDPC  (119 % 256)
	{MTPRSINT15MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 6}},
#define   MTPRSINT15MINROUTESETUNAVAILABLE  (120 % 256)
	{MTPRSINT15MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 7}},
#define   MTPRSINT15MINROUTESETUNAVAILABLEDURATION  (121 % 256)
	{MTPRSINT15MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 2, 3, 1, 8}},
#define   MTPRSSIVALIDINTERVALS  (125 % 256)
	{MTPRSSIVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 2}},
#define   MTPRSSITIMEDISCONTINUITY  (126 % 256)
	{MTPRSSITIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 3}},
#define   MTPRSSIRECEIVEDOCTETSOPCSIO  (127 % 256)
	{MTPRSSIRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 4}},
#define   MTPRSSITRANSMITTEDOCTETSDPCSIO  (128 % 256)
	{MTPRSSITRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 5}},
#define   MTPRSSIRECEIVEDMSUSOPCSIO  (129 % 256)
	{MTPRSSIRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 6}},
#define   MTPRSSITRANSMITTEDMSUSDPCSIO  (130 % 256)
	{MTPRSSITRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 7}},
#define   MTPRSSISTATUS         (131 % 256)
	{MTPRSSISTATUS, ASN_INTEGER, RONLY, var_mtpRsSiTable, 6, {1, 1, 2, 4, 1, 8}},
#define   MTPRSSIINT5MINTIMESTAMP  (136 % 256)
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 2}},
#define   MTPRSSIINT5MINRECEIVEDOCTETSOPCSIO  (137 % 256)
	{MTPRSSIINT5MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 3}},
#define   MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO  (138 % 256)
	{MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 4}},
#define   MTPRSSIINT5MINRECEIVEDMSUSOPCSIO  (139 % 256)
	{MTPRSSIINT5MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 5}},
#define   MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO  (140 % 256)
	{MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 6}},
#define   MTPRSSIINT15MINTIMESTAMP  (145 % 256)
	{MTPRSSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 2}},
#define   MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO  (146 % 256)
	{MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 3}},
#define   MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO  (147 % 256)
	{MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 4}},
#define   MTPRSSIINT15MINRECEIVEDMSUSOPCSIO  (148 % 256)
	{MTPRSSIINT15MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 5}},
#define   MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO  (149 % 256)
	{MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 6}},
#define   MTPLSCURRENTVALIDINTERVALS  (153 % 256)
	{MTPLSCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpLsCurrentTable, 6, {1, 1, 3, 1, 1, 1}},
#define   MTPLSCURRENTTIMEDISCONTINUITY  (154 % 256)
	{MTPLSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpLsCurrentTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPLSCURRENTADJACENTINACCESSIBLEEVENTS  (155 % 256)
	{MTPLSCURRENTADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpLsCurrentTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPLSCURRENTADJACENTINACCESSIBLEDURATION  (156 % 256)
	{MTPLSCURRENTADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpLsCurrentTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPLSCURRENTSLSUNAVAILABLE  (157 % 256)
	{MTPLSCURRENTSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpLsCurrentTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPLSINT5MINTIMESTAMP  (162 % 256)
	{MTPLSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpLsInt5minTable, 6, {1, 1, 3, 2, 1, 2}},
#define   MTPLSINT5MINADJACENTINACCESSIBLEEVENTS  (163 % 256)
	{MTPLSINT5MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpLsInt5minTable, 6, {1, 1, 3, 2, 1, 3}},
#define   MTPLSINT5MINADJACENTINACCESSIBLEDURATION  (164 % 256)
	{MTPLSINT5MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpLsInt5minTable, 6, {1, 1, 3, 2, 1, 4}},
#define   MTPLSINT5MINSLSUNAVAILABLE  (165 % 256)
	{MTPLSINT5MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpLsInt5minTable, 6, {1, 1, 3, 2, 1, 5}},
#define   MTPLSINT15MINTIMESTAMP  (170 % 256)
	{MTPLSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 3, 3, 1, 2}},
#define   MTPLSINT15MINADJACENTINACCESSIBLEEVENTS  (171 % 256)
	{MTPLSINT15MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 3, 3, 1, 3}},
#define   MTPLSINT15MINADJACENTINACCESSIBLEDURATION  (172 % 256)
	{MTPLSINT15MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 3, 3, 1, 4}},
#define   MTPLSINT15MINSLSUNAVAILABLE  (173 % 256)
	{MTPLSINT15MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 3, 3, 1, 5}},
#define   MTPSLSTATSDURINSERVICE  (179 % 256)
	{MTPSLSTATSDURINSERVICE, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 1}},
#define   MTPSLSTATSFAILALIGNORPROVING  (180 % 256)
	{MTPSLSTATSFAILALIGNORPROVING, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPSLSTATSNACKSRECEIVED  (181 % 256)
	{MTPSLSTATSNACKSRECEIVED, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPSLSTATSDURUNAVAIL  (182 % 256)
	{MTPSLSTATSDURUNAVAIL, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPSLSTATSDURUNAVAILFAILED  (183 % 256)
	{MTPSLSTATSDURUNAVAILFAILED, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPSLSTATSDURUNAVAILRPO  (184 % 256)
	{MTPSLSTATSDURUNAVAILRPO, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPSLSTATSSIBSSENT    (185 % 256)
	{MTPSLSTATSSIBSSENT, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPSLSTATSTRANSIOSIFOCTETS  (186 % 256)
	{MTPSLSTATSTRANSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPSLSTATSRETRANSOCTETS  (187 % 256)
	{MTPSLSTATSRETRANSOCTETS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPSLSTATSTRANMSUS    (188 % 256)
	{MTPSLSTATSTRANMSUS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPSLSTATSRECVSIOSIFOCTETS  (189 % 256)
	{MTPSLSTATSRECVSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 11}},
#define   MTPSLSTATSRECVMSUS    (190 % 256)
	{MTPSLSTATSRECVMSUS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 12}},
#define   MTPSLSTATSCONGONSETIND0  (191 % 256)
	{MTPSLSTATSCONGONSETIND0, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 13}},
#define   MTPSLSTATSCONGONSETIND1  (192 % 256)
	{MTPSLSTATSCONGONSETIND1, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 14}},
#define   MTPSLSTATSCONGONSETIND2  (193 % 256)
	{MTPSLSTATSCONGONSETIND2, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 15}},
#define   MTPSLSTATSCONGONSETIND3  (194 % 256)
	{MTPSLSTATSCONGONSETIND3, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 16}},
#define   MTPSLSTATSDURCONGSTATUS0  (195 % 256)
	{MTPSLSTATSDURCONGSTATUS0, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 17}},
#define   MTPSLSTATSDURCONGSTATUS1  (196 % 256)
	{MTPSLSTATSDURCONGSTATUS1, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 18}},
#define   MTPSLSTATSDURCONGSTATUS2  (197 % 256)
	{MTPSLSTATSDURCONGSTATUS2, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 19}},
#define   MTPSLSTATSDURCONGSTATUS3  (198 % 256)
	{MTPSLSTATSDURCONGSTATUS3, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 20}},
#define   MTPSLSTATSCONGDISCDIND0  (199 % 256)
	{MTPSLSTATSCONGDISCDIND0, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 21}},
#define   MTPSLSTATSCONGDISCDIND1  (200 % 256)
	{MTPSLSTATSCONGDISCDIND1, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 22}},
#define   MTPSLSTATSCONGDISCDIND2  (201 % 256)
	{MTPSLSTATSCONGDISCDIND2, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 23}},
#define   MTPSLSTATSCONGDISCDIND3  (202 % 256)
	{MTPSLSTATSCONGDISCDIND3, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 4, 1, 1, 24}},
#define   MTPSLL3CURRENTVALIDINTERVALS  (208 % 256)
	{MTPSLL3CURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 1}},
#define   MTPSLL3CURRENTTIMEDISCONTINUITY  (209 % 256)
	{MTPSLL3CURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPSLL3CURRENTSLUNAVAILABILITYDURATION  (210 % 256)
	{MTPSLL3CURRENTSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPSLL3CURRENTSLLOCALINHIBITION  (211 % 256)
	{MTPSLL3CURRENTSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPSLL3CURRENTSLREMOTEINHIBITION  (212 % 256)
	{MTPSLL3CURRENTSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 5}},
#define   MTPSLL3CURRENTSLFAILED  (213 % 256)
	{MTPSLL3CURRENTSLFAILED, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 6}},
#define   MTPSLL3CURRENTSLREMOTEPROCOUTAGE  (214 % 256)
	{MTPSLL3CURRENTSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 7}},
#define   MTPSLL3CURRENTLOCALMGMTINHIBIT  (215 % 256)
	{MTPSLL3CURRENTLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 8}},
#define   MTPSLL3CURRENTLOCALMGMTUNINHIBIT  (216 % 256)
	{MTPSLL3CURRENTLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 9}},
#define   MTPSLL3CURRENTLOCALBUSY  (217 % 256)
	{MTPSLL3CURRENTLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 10}},
#define   MTPSLL3CURRENTSLCONGESTEDSTARTS  (218 % 256)
	{MTPSLL3CURRENTSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 11}},
#define   MTPSLL3CURRENTSLCONGESTEDDURATION  (219 % 256)
	{MTPSLL3CURRENTSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 12}},
#define   MTPSLL3CURRENTSLCONGESTIONSTOPS  (220 % 256)
	{MTPSLL3CURRENTSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 13}},
#define   MTPSLL3CURRENTDISCARDEDMSUS  (221 % 256)
	{MTPSLL3CURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 14}},
#define   MTPSLL3CURRENTCONGESTIONEVENTSMSULOSS  (222 % 256)
	{MTPSLL3CURRENTCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 15}},
#define   MTPSLL3CURRENTCHANGEOVERS  (223 % 256)
	{MTPSLL3CURRENTCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 16}},
#define   MTPSLL3CURRENTCHANGEBACKS  (224 % 256)
	{MTPSLL3CURRENTCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 17}},
#define   MTPSLL3CURRENTRESTORATIONS  (225 % 256)
	{MTPSLL3CURRENTRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 4, 2, 1, 18}},
#define   MTPSLL3INT5MINTIMESTAMP  (232 % 256)
	{MTPSLL3INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPSLL3INT5MINSLUNAVAILABILITYDURATION  (233 % 256)
	{MTPSLL3INT5MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPSLL3INT5MINSLLOCALINHIBITION  (234 % 256)
	{MTPSLL3INT5MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPSLL3INT5MINSLREMOTEINHIBITION  (235 % 256)
	{MTPSLL3INT5MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPSLL3INT5MINSLFAILED  (236 % 256)
	{MTPSLL3INT5MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPSLL3INT5MINSLREMOTEPROCOUTAGE  (237 % 256)
	{MTPSLL3INT5MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPSLL3INT5MINLOCALMGMTINHIBIT  (238 % 256)
	{MTPSLL3INT5MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 8}},
#define   MTPSLL3INT5MINLOCALMGMTUNINHIBIT  (239 % 256)
	{MTPSLL3INT5MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 9}},
#define   MTPSLL3INT5MINLOCALBUSY  (240 % 256)
	{MTPSLL3INT5MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 10}},
#define   MTPSLL3INT5MINSLCONGESTEDSTARTS  (241 % 256)
	{MTPSLL3INT5MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 11}},
#define   MTPSLL3INT5MINSLCONGESTEDDURATION  (242 % 256)
	{MTPSLL3INT5MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 12}},
#define   MTPSLL3INT5MINSLCONGESTIONSTOPS  (243 % 256)
	{MTPSLL3INT5MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 13}},
#define   MTPSLL3INT5MINDISCARDEDMSUS  (244 % 256)
	{MTPSLL3INT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 14}},
#define   MTPSLL3INT5MINCONGESTIONEVENTSMSULOSS  (245 % 256)
	{MTPSLL3INT5MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 15}},
#define   MTPSLL3INT5MINCHANGEOVERS  (246 % 256)
	{MTPSLL3INT5MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 16}},
#define   MTPSLL3INT5MINCHANGEBACKS  (247 % 256)
	{MTPSLL3INT5MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 17}},
#define   MTPSLL3INT5MINRESTORATIONS  (248 % 256)
	{MTPSLL3INT5MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 18}},
#define   MTPSLL3INT15MINTIMESTAMP  (255 % 256)
	{MTPSLL3INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 2}},
#define   MTPSLL3INT15MINSLUNAVAILABILITYDURATION  (256 % 256)
	{MTPSLL3INT15MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 3}},
#define   MTPSLL3INT15MINSLLOCALINHIBITION  (257 % 256)
	{MTPSLL3INT15MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 4}},
#define   MTPSLL3INT15MINSLREMOTEINHIBITION  (258 % 256)
	{MTPSLL3INT15MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 5}},
#define   MTPSLL3INT15MINSLFAILED  (259 % 256)
	{MTPSLL3INT15MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 6}},
#define   MTPSLL3INT15MINSLREMOTEPROCOUTAGE  (260 % 256)
	{MTPSLL3INT15MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 7}},
#define   MTPSLL3INT15MINLOCALMGMTINHIBIT  (261 % 256)
	{MTPSLL3INT15MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 8}},
#define   MTPSLL3INT15MINLOCALMGMTUNINHIBIT  (262 % 256)
	{MTPSLL3INT15MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 9}},
#define   MTPSLL3INT15MINLOCALBUSY  (263 % 256)
	{MTPSLL3INT15MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 10}},
#define   MTPSLL3INT15MINSLCONGESTEDSTARTS  (264 % 256)
	{MTPSLL3INT15MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 11}},
#define   MTPSLL3INT15MINSLCONGESTEDDURATION  (265 % 256)
	{MTPSLL3INT15MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 12}},
#define   MTPSLL3INT15MINSLCONGESTIONSTOPS  (266 % 256)
	{MTPSLL3INT15MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 13}},
#define   MTPSLL3INT15MINDISCARDEDMSUS  (267 % 256)
	{MTPSLL3INT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 14}},
#define   MTPSLL3INT15MINCONGESTIONEVENTSMSULOSS  (268 % 256)
	{MTPSLL3INT15MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 15}},
#define   MTPSLL3INT15MINCHANGEOVERS  (269 % 256)
	{MTPSLL3INT15MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 16}},
#define   MTPSLL3INT15MINCHANGEBACKS  (270 % 256)
	{MTPSLL3INT15MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 17}},
#define   MTPSLL3INT15MINRESTORATIONS  (271 % 256)
	{MTPSLL3INT15MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 18}},
#define   MTPSLL2CURRENTVALIDINTERVALS  (277 % 256)
	{MTPSLL2CURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 1}},
#define   MTPSLL2CURRENTTIMEDISCONTINUITY  (278 % 256)
	{MTPSLL2CURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 2}},
#define   MTPSLL2CURRENTSLINSERVICEDURATION  (279 % 256)
	{MTPSLL2CURRENTSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 3}},
#define   MTPSLL2CURRENTSLALIGNMENT  (280 % 256)
	{MTPSLL2CURRENTSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 4}},
#define   MTPSLL2CURRENTSIGNUNITSRECEIVED  (281 % 256)
	{MTPSLL2CURRENTSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 5}},
#define   MTPSLL2CURRENTNEGACKRECEIVED  (282 % 256)
	{MTPSLL2CURRENTNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 6}},
#define   MTPSLL2CURRENTTRANSMITTEDOCTETSSIFSIO  (283 % 256)
	{MTPSLL2CURRENTTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 7}},
#define   MTPSLL2CURRENTRETRANSMITTEDOCTETS  (284 % 256)
	{MTPSLL2CURRENTRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 8}},
#define   MTPSLL2CURRENTTRANSMITTEDMSUS  (285 % 256)
	{MTPSLL2CURRENTTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 9}},
#define   MTPSLL2CURRENTRECEIVEDOCTETSSIFSIO  (286 % 256)
	{MTPSLL2CURRENTRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 10}},
#define   MTPSLL2CURRENTRECEIVEDMSUS  (287 % 256)
	{MTPSLL2CURRENTRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 4, 5, 1, 11}},
#define   MTPSLL2INT5MINTIMESTAMP  (294 % 256)
	{MTPSLL2INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 2}},
#define   MTPSLL2INT5MINSLINSERVICEDURATION  (295 % 256)
	{MTPSLL2INT5MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 3}},
#define   MTPSLL2INT5MINSLALIGNMENT  (296 % 256)
	{MTPSLL2INT5MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 4}},
#define   MTPSLL2INT5MINSIGNUNITSRECEIVED  (297 % 256)
	{MTPSLL2INT5MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 5}},
#define   MTPSLL2INT5MINNEGACKRECEIVED  (298 % 256)
	{MTPSLL2INT5MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 6}},
#define   MTPSLL2INT5MINTRANSMITTEDOCTETSSIFSIO  (299 % 256)
	{MTPSLL2INT5MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 7}},
#define   MTPSLL2INT5MINRETRANSMITTEDOCTETS  (300 % 256)
	{MTPSLL2INT5MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 8}},
#define   MTPSLL2INT5MINTRANSMITTEDMSUS  (301 % 256)
	{MTPSLL2INT5MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 9}},
#define   MTPSLL2INT5MINRECEIVEDOCTETSSIFSIO  (302 % 256)
	{MTPSLL2INT5MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 10}},
#define   MTPSLL2INT5MINRECEIVEDMSUS  (303 % 256)
	{MTPSLL2INT5MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 11}},
#define   MTPSLL2INT15MINTIMESTAMP  (310 % 256)
	{MTPSLL2INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 2}},
#define   MTPSLL2INT15MINSLINSERVICEDURATION  (311 % 256)
	{MTPSLL2INT15MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 3}},
#define   MTPSLL2INT15MINSLALIGNMENT  (312 % 256)
	{MTPSLL2INT15MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 4}},
#define   MTPSLL2INT15MINSIGNUNITSRECEIVED  (313 % 256)
	{MTPSLL2INT15MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 5}},
#define   MTPSLL2INT15MINNEGACKRECEIVED  (314 % 256)
	{MTPSLL2INT15MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 6}},
#define   MTPSLL2INT15MINTRANSMITTEDOCTETSSIFSIO  (315 % 256)
	{MTPSLL2INT15MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 7}},
#define   MTPSLL2INT15MINRETRANSMITTEDOCTETS  (316 % 256)
	{MTPSLL2INT15MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 8}},
#define   MTPSLL2INT15MINTRANSMITTEDMSUS  (317 % 256)
	{MTPSLL2INT15MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 9}},
#define   MTPSLL2INT15MINRECEIVEDOCTETSSIFSIO  (318 % 256)
	{MTPSLL2INT15MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 10}},
#define   MTPSLL2INT15MINRECEIVEDMSUS  (319 % 256)
	{MTPSLL2INT15MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 11}},
#define   MTPSDTSTATSTXBYTES    (323 % 256)
	{MTPSDTSTATSTXBYTES, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 1}},
#define   MTPSDTSTATSTXSUS      (324 % 256)
	{MTPSDTSTATSTXSUS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPSDTSTATSTXSUSREPEATED  (325 % 256)
	{MTPSDTSTATSTXSUSREPEATED, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPSDTSTATSTXUNDERRUNS  (326 % 256)
	{MTPSDTSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPSDTSTATSTXABORTS   (327 % 256)
	{MTPSDTSTATSTXABORTS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPSDTSTATSTXBUFFEROVERFLOWS  (328 % 256)
	{MTPSDTSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPSDTSTATSTXSUSINERROR  (329 % 256)
	{MTPSDTSTATSTXSUSINERROR, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPSDTSTATSRXBYTES    (330 % 256)
	{MTPSDTSTATSRXBYTES, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPSDTSTATSRXSUSCOMPRESSED  (331 % 256)
	{MTPSDTSTATSRXSUSCOMPRESSED, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 9}},
#define   MTPSDTSTATSRXOVERRUNS  (332 % 256)
	{MTPSDTSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 10}},
#define   MTPSDTSTATSRXABORTS   (333 % 256)
	{MTPSDTSTATSRXABORTS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 11}},
#define   MTPSDTSTATSRXBUFFEROVERFLOWS  (334 % 256)
	{MTPSDTSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 12}},
#define   MTPSDTSTATSRXSUSINERROR  (335 % 256)
	{MTPSDTSTATSRXSUSINERROR, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 13}},
#define   MTPSDTSTATSRXSYNCTRANSITIONS  (336 % 256)
	{MTPSDTSTATSRXSYNCTRANSITIONS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 14}},
#define   MTPSDTSTATSRXBITSOCTETCOUNTED  (337 % 256)
	{MTPSDTSTATSRXBITSOCTETCOUNTED, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 15}},
#define   MTPSDTSTATSRXCRCERRORS  (338 % 256)
	{MTPSDTSTATSRXCRCERRORS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 16}},
#define   MTPSDTSTATSRXFRAMEERRORS  (339 % 256)
	{MTPSDTSTATSRXFRAMEERRORS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 17}},
#define   MTPSDTSTATSRXFRAMEOVERFLOWS  (340 % 256)
	{MTPSDTSTATSRXFRAMEOVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 18}},
#define   MTPSDTSTATSRXFRAMETOOLONG  (341 % 256)
	{MTPSDTSTATSRXFRAMETOOLONG, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 19}},
#define   MTPSDTSTATSRXFRAMETOOSHORT  (342 % 256)
	{MTPSDTSTATSRXFRAMETOOSHORT, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 20}},
#define   MTPSDTSTATSRXRESIDUEERRORS  (343 % 256)
	{MTPSDTSTATSRXRESIDUEERRORS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 21}},
#define   MTPSDTSTATSCARRIERCTSLOST  (344 % 256)
	{MTPSDTSTATSCARRIERCTSLOST, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 22}},
#define   MTPSDTSTATSCARRIERDCDLOST  (345 % 256)
	{MTPSDTSTATSCARRIERDCDLOST, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 23}},
#define   MTPSDTSTATSCARRIERLOST  (346 % 256)
	{MTPSDTSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 5, 1, 1, 24}},
#define   MTPSDLSTATSRXOCTETS   (350 % 256)
	{MTPSDLSTATSRXOCTETS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 1}},
#define   MTPSDLSTATSTXOCTETS   (351 % 256)
	{MTPSDLSTATSTXOCTETS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPSDLSTATSRXOVERRUNS  (352 % 256)
	{MTPSDLSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPSDLSTATSTXUNDERRUNS  (353 % 256)
	{MTPSDLSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPSDLSTATSRXBUFFEROVERFLOWS  (354 % 256)
	{MTPSDLSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPSDLSTATSTXBUFFEROVERFLOWS  (355 % 256)
	{MTPSDLSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPSDLSTATSLEADCTSLOST  (356 % 256)
	{MTPSDLSTATSLEADCTSLOST, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPSDLSTATSLEADDCDLOST  (357 % 256)
	{MTPSDLSTATSLEADDCDLOST, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPSDLSTATSCARRIERLOST  (358 % 256)
	{MTPSDLSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 9}},
#define   MTPSDLSTATSBIPOLARVIOLATIONS  (359 % 256)
	{MTPSDLSTATSBIPOLARVIOLATIONS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 6, 1, 1, 10}},
#define   MTPOM1STANDINTERVALACTIVATE  (360 % 256)
	{MTPOM1STANDINTERVALACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 1}},
#define   MTPOM1STANDINTERVALDEACTIVATE  (361 % 256)
	{MTPOM1STANDINTERVALDEACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 2}},
#define   MTPOM5MINACTIVATE     (362 % 256)
	{MTPOM5MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 3}},
#define   MTPOM5MINDEAACTIVATE  (363 % 256)
	{MTPOM5MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 4}},
#define   MTPOM15MINACTIVATE    (364 % 256)
	{MTPOM15MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 5}},
#define   MTPOM15MINDEAACTIVATE  (365 % 256)
	{MTPOM15MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 6}},
#define   MTPOMDISCONTINUITYTIME  (367 % 256)
	{MTPOMDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_mtpOmMIB, 3, {1, 2, 8}},
#define   MTPOMTIMESTAMP        (368 % 256)
	{MTPOMTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmMIB, 3, {1, 2, 9}},
#define   MTPOM5MINMAXINTERVALS  (369 % 256)
	{MTPOM5MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_mtpOmMIB, 3, {1, 2, 10}},
#define   MTPOM15MINMAXINTERVALS  (370 % 256)
	{MTPOM15MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_mtpOmMIB, 3, {1, 2, 11}},

};

/*    (L = length of the oidsuffix) */
struct mtpOmMIB_data *mtpOmMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpSpCurrentTableStorage = NULL;
struct header_complex_index *mtpSpInt5minTableStorage = NULL;
struct header_complex_index *mtpSpInt15minTableStorage = NULL;
struct header_complex_index *mtpSpSiTableStorage = NULL;
struct header_complex_index *mtpSpSiInt5minTableStorage = NULL;
struct header_complex_index *mtpSpSiInt15minTableStorage = NULL;
struct header_complex_index *mtpSpStudyTableStorage = NULL;
struct header_complex_index *mtpSpStudyInt5minTableStorage = NULL;
struct header_complex_index *mtpSpStudyInt15minTableStorage = NULL;
struct header_complex_index *mtpSpStudyMapTableStorage = NULL;
struct header_complex_index *mtpRsCurrentTableStorage = NULL;
struct header_complex_index *mtpRsInt5minTableStorage = NULL;
struct header_complex_index *mtpRsInt15minTableStorage = NULL;
struct header_complex_index *mtpRsSiTableStorage = NULL;
struct header_complex_index *mtpRsSiInt5minTableStorage = NULL;
struct header_complex_index *mtpRsSiInt15minTableStorage = NULL;
struct header_complex_index *mtpLsCurrentTableStorage = NULL;
struct header_complex_index *mtpLsInt5minTableStorage = NULL;
struct header_complex_index *mtpLsInt15minTableStorage = NULL;
struct header_complex_index *mtpSlStatsTableStorage = NULL;
struct header_complex_index *mtpSlL3CurrentTableStorage = NULL;
struct header_complex_index *mtpSlL3Int5minTableStorage = NULL;
struct header_complex_index *mtpSlL3Int15minTableStorage = NULL;
struct header_complex_index *mtpSlL2CurrentTableStorage = NULL;
struct header_complex_index *mtpSlL2Int5minTableStorage = NULL;
struct header_complex_index *mtpSlL2Int15minTableStorage = NULL;
struct header_complex_index *mtpSdtStatsTableStorage = NULL;
struct header_complex_index *mtpSdlStatsTableStorage = NULL;

/*
 * init_mtpOmMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_mtpOmMIB(void)
{
	DEBUGMSGTL(("mtpOmMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpOmMIB", mtpOmMIB_variables, variable7, mtpOmMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpOmMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpOmMIB", parse_mtpOmMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpCurrentTable", parse_mtpSpCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt5minTable", parse_mtpSpInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt15minTable", parse_mtpSpInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiTable", parse_mtpSpSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt5minTable", parse_mtpSpSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt15minTable", parse_mtpSpSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyTable", parse_mtpSpStudyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt5minTable", parse_mtpSpStudyInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt15minTable", parse_mtpSpStudyInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyMapTable", parse_mtpSpStudyMapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsCurrentTable", parse_mtpRsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt5minTable", parse_mtpRsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt15minTable", parse_mtpRsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiTable", parse_mtpRsSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt5minTable", parse_mtpRsSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt15minTable", parse_mtpRsSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsCurrentTable", parse_mtpLsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsInt5minTable", parse_mtpLsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsInt15minTable", parse_mtpLsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlStatsTable", parse_mtpSlStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3CurrentTable", parse_mtpSlL3CurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3Int5minTable", parse_mtpSlL3Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3Int15minTable", parse_mtpSlL3Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2CurrentTable", parse_mtpSlL2CurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2Int5minTable", parse_mtpSlL2Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2Int15minTable", parse_mtpSlL2Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtStatsTable", parse_mtpSdtStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlStatsTable", parse_mtpSdlStatsTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyMapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3CurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2CurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlStatsTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * deinit_mtpOmMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_mtpOmMIB(void)
{
	DEBUGMSGTL(("mtpOmMIB", "deinitializating...  "));
	unregister_mib(mtpOmMIB_variables_oid, sizeof(mtpOmMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpOmMIB");
	snmpd_unregister_config_handler("mtpSpCurrentTable");
	snmpd_unregister_config_handler("mtpSpInt5minTable");
	snmpd_unregister_config_handler("mtpSpInt15minTable");
	snmpd_unregister_config_handler("mtpSpSiTable");
	snmpd_unregister_config_handler("mtpSpSiInt5minTable");
	snmpd_unregister_config_handler("mtpSpSiInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyTable");
	snmpd_unregister_config_handler("mtpSpStudyInt5minTable");
	snmpd_unregister_config_handler("mtpSpStudyInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyMapTable");
	snmpd_unregister_config_handler("mtpRsCurrentTable");
	snmpd_unregister_config_handler("mtpRsInt5minTable");
	snmpd_unregister_config_handler("mtpRsInt15minTable");
	snmpd_unregister_config_handler("mtpRsSiTable");
	snmpd_unregister_config_handler("mtpRsSiInt5minTable");
	snmpd_unregister_config_handler("mtpRsSiInt15minTable");
	snmpd_unregister_config_handler("mtpLsCurrentTable");
	snmpd_unregister_config_handler("mtpLsInt5minTable");
	snmpd_unregister_config_handler("mtpLsInt15minTable");
	snmpd_unregister_config_handler("mtpSlStatsTable");
	snmpd_unregister_config_handler("mtpSlL3CurrentTable");
	snmpd_unregister_config_handler("mtpSlL3Int5minTable");
	snmpd_unregister_config_handler("mtpSlL3Int15minTable");
	snmpd_unregister_config_handler("mtpSlL2CurrentTable");
	snmpd_unregister_config_handler("mtpSlL2Int5minTable");
	snmpd_unregister_config_handler("mtpSlL2Int15minTable");
	snmpd_unregister_config_handler("mtpSdtStatsTable");
	snmpd_unregister_config_handler("mtpSdlStatsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

int
term_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpOmMIB();
	return 0;
}

/*
 * mtpOmMIB_add(): adds a structure node for scalars
 */
int
mtpOmMIB_add(struct mtpOmMIB_data *thedata)
{
	DEBUGMSGTL(("mtpOmMIB", "adding data...  "));
	mtpOmMIBStorage = thedata;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpOmMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpOmMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpOmMIB_data);

	DEBUGMSGTL(("mtpOmMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm1stAndIntervalActivate, &tmpsize);
	StorageTmp->mtpOm1stAndIntervalActivateLen = tmpsize;
	if (StorageTmp->mtpOm1stAndIntervalActivate == NULL) {
		config_perror("invalid specification for mtpOm1stAndIntervalActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm1stAndIntervalDeactivate, &tmpsize);
	StorageTmp->mtpOm1stAndIntervalDeactivateLen = tmpsize;
	if (StorageTmp->mtpOm1stAndIntervalDeactivate == NULL) {
		config_perror("invalid specification for mtpOm1stAndIntervalDeactivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm5MinActivate, &tmpsize);
	StorageTmp->mtpOm5MinActivateLen = tmpsize;
	if (StorageTmp->mtpOm5MinActivate == NULL) {
		config_perror("invalid specification for mtpOm5MinActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm5MinDeaActivate, &tmpsize);
	StorageTmp->mtpOm5MinDeaActivateLen = tmpsize;
	if (StorageTmp->mtpOm5MinDeaActivate == NULL) {
		config_perror("invalid specification for mtpOm5MinDeaActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm15MinActivate, &tmpsize);
	StorageTmp->mtpOm15MinActivateLen = tmpsize;
	if (StorageTmp->mtpOm15MinActivate == NULL) {
		config_perror("invalid specification for mtpOm15MinActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm15MinDeaActivate, &tmpsize);
	StorageTmp->mtpOm15MinDeaActivateLen = tmpsize;
	if (StorageTmp->mtpOm15MinDeaActivate == NULL) {
		config_perror("invalid specification for mtpOm15MinDeaActivate");
		return;
	}

	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOm5MinMaxIntervals, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOm15MinMaxIntervals, &tmpsize);

	mtpOmMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpOmMIB", "storing data...  "));
	refresh_mtpOmMIB();
	if ((StorageTmp = mtpOmMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpOmMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->mtpOmMIBStorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "mtpOmMIB ");
	cptr = line + strlen(line);
	tmpsize = StorageTmp->mtpOm1stAndIntervalActivateLen;
	cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm1stAndIntervalActivate, &tmpsize);
	tmpsize = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
	cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm1stAndIntervalDeactivate, &tmpsize);
	tmpsize = StorageTmp->mtpOm5MinActivateLen;
	cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm5MinActivate, &tmpsize);
	tmpsize = StorageTmp->mtpOm5MinDeaActivateLen;
	cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm5MinDeaActivate, &tmpsize);
	tmpsize = StorageTmp->mtpOm15MinActivateLen;
	cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm15MinActivate, &tmpsize);
	tmpsize = StorageTmp->mtpOm15MinDeaActivateLen;
	cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm15MinDeaActivate, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmInterval, &tmpsize);
	cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmDiscontinuityTime, &tmpsize);
	cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmTimeStamp, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOm5MinMaxIntervals, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOm15MinMaxIntervals, &tmpsize);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpOmMIB: refresh mtpOmMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_mtpOmMIB(void)
{
	if (mtpOmMIBStorage == NULL) {
		struct mtpOmMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(mtpOmMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->mtpOm5MinMaxIntervals = 96;
		StorageNew->mtpOm15MinMaxIntervals = 96;

		mtpOmMIBStorage = StorageNew;
		mtpOmMIB_refresh = 1;
	}
	if (mtpOmMIB_refresh == 0)
		return;
	mtpOmMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_mtpOmMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_mtpOmMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpOmMIB();
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPOM1STANDINTERVALACTIVATE:
		*write_method = write_mtpOm1stAndIntervalActivate;
		*var_len = StorageTmp->mtpOm1stAndIntervalActivateLen;
		return (uint8_t *) StorageTmp->mtpOm1stAndIntervalActivate;
	case MTPOM1STANDINTERVALDEACTIVATE:
		*write_method = write_mtpOm1stAndIntervalDeactivate;
		*var_len = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
		return (uint8_t *) StorageTmp->mtpOm1stAndIntervalDeactivate;
	case MTPOM5MINACTIVATE:
		*write_method = write_mtpOm5MinActivate;
		*var_len = StorageTmp->mtpOm5MinActivateLen;
		return (uint8_t *) StorageTmp->mtpOm5MinActivate;
	case MTPOM5MINDEAACTIVATE:
		*write_method = write_mtpOm5MinDeaActivate;
		*var_len = StorageTmp->mtpOm5MinDeaActivateLen;
		return (uint8_t *) StorageTmp->mtpOm5MinDeaActivate;
	case MTPOM15MINACTIVATE:
		*write_method = write_mtpOm15MinActivate;
		*var_len = StorageTmp->mtpOm15MinActivateLen;
		return (uint8_t *) StorageTmp->mtpOm15MinActivate;
	case MTPOM15MINDEAACTIVATE:
		*write_method = write_mtpOm15MinDeaActivate;
		*var_len = StorageTmp->mtpOm15MinDeaActivateLen;
		return (uint8_t *) StorageTmp->mtpOm15MinDeaActivate;
	case MTPOMDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmDiscontinuityTime);
		return (uint8_t *) &StorageTmp->mtpOmDiscontinuityTime;
	case MTPOMTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpOmTimeStamp);
		return (uint8_t *) &StorageTmp->mtpOmTimeStamp;
	case MTPOM5MINMAXINTERVALS:
		*write_method = write_mtpOm5MinMaxIntervals;
		*var_len = sizeof(StorageTmp->mtpOm5MinMaxIntervals);
		return (uint8_t *) &StorageTmp->mtpOm5MinMaxIntervals;
	case MTPOM15MINMAXINTERVALS:
		*write_method = write_mtpOm15MinMaxIntervals;
		*var_len = sizeof(StorageTmp->mtpOm15MinMaxIntervals);
		return (uint8_t *) &StorageTmp->mtpOm15MinMaxIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * mtpSpCurrentTable_add(): adds a structure node to our data set
 */
int
mtpSpCurrentTable_add(struct mtpSpCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));

	header_complex_add_data(&mtpSpCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpCurrentTable_data);

	DEBUGMSGTL(("mtpSpCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpCurrentValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpsize);

	mtpSpCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
}

/*
 * store_mtpSpCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpCurrentTable", "storing data...  "));
	refresh_mtpSpCurrentTable();
	(void) tmpsize;
	for (hcindex = mtpSpCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpCurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpCurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpCurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpCurrentValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpInt5minTable_add(): adds a structure node to our data set
 */
int
mtpSpInt5minTable_add(struct mtpSpInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpInt5minInterval, sizeof(thedata->mtpSpInt5minInterval));

	header_complex_add_data(&mtpSpInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt5minTable_data);

	DEBUGMSGTL(("mtpSpInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpsize);

	mtpSpInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
}

/*
 * store_mtpSpInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt5minTable", "storing data...  "));
	refresh_mtpSpInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpSpInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpInt15minTable_add(): adds a structure node to our data set
 */
int
mtpSpInt15minTable_add(struct mtpSpInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpInt15minInterval, sizeof(thedata->mtpSpInt15minInterval));

	header_complex_add_data(&mtpSpInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt15minTable_data);

	DEBUGMSGTL(("mtpSpInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpsize);

	mtpSpInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
}

/*
 * store_mtpSpInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt15minTable", "storing data...  "));
	refresh_mtpSpInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpSpInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpSiTable_add(): adds a structure node to our data set
 */
int
mtpSpSiTable_add(struct mtpSpSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));

	header_complex_add_data(&mtpSpSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);

	DEBUGMSGTL(("mtpSpSiTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiStatus, &tmpsize);

	mtpSpSiTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
}

/*
 * store_mtpSpSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiTable", "storing data...  "));
	refresh_mtpSpSiTable();
	(void) tmpsize;
	for (hcindex = mtpSpSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpSiTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpSiInt5minTable_add(): adds a structure node to our data set
 */
int
mtpSpSiInt5minTable_add(struct mtpSpSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiInt5minInterval, sizeof(thedata->mtpSpSiInt5minInterval));

	header_complex_add_data(&mtpSpSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpSpSiInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpsize);

	mtpSpSiInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "storing data...  "));
	refresh_mtpSpSiInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpSpSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpSiInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpSiInt15minTable_add(): adds a structure node to our data set
 */
int
mtpSpSiInt15minTable_add(struct mtpSpSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiInt15minInterval, sizeof(thedata->mtpSpSiInt15minInterval));

	header_complex_add_data(&mtpSpSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpSpSiInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpsize);

	mtpSpSiInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "storing data...  "));
	refresh_mtpSpSiInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpSpSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpSiInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyTable_add(struct mtpSpStudyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));

	header_complex_add_data(&mtpSpStudyTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpStudyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);

	DEBUGMSGTL(("mtpSpStudyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyStatus, &tmpsize);

	mtpSpStudyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
}

/*
 * store_mtpSpStudyTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpStudyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyTable", "storing data...  "));
	refresh_mtpSpStudyTable();
	(void) tmpsize;
	for (hcindex = mtpSpStudyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyInt5minTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyInt5minTable_add(struct mtpSpStudyInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));
	/* mtpSpStudyInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyInt5minInterval, sizeof(thedata->mtpSpStudyInt5minInterval));

	header_complex_add_data(&mtpSpStudyInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpStudyInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpsize);

	mtpSpStudyInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpStudyInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "storing data...  "));
	refresh_mtpSpStudyInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpSpStudyInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyInt15minTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyInt15minTable_add(struct mtpSpStudyInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));

	header_complex_add_data(&mtpSpStudyInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpStudyInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpsize);

	mtpSpStudyInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpStudyInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "storing data...  "));
	refresh_mtpSpStudyInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpSpStudyInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyMapTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyMapTable_add(struct mtpSpStudyMapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyMapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));
	/* mtpOpcRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpOpcRsId, sizeof(thedata->mtpOpcRsId));
	/* mtpDpcRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpDpcRsId, sizeof(thedata->mtpDpcRsId));

	header_complex_add_data(&mtpSpStudyMapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyMapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyMapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyMapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpStudyMapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);

	DEBUGMSGTL(("mtpSpStudyMapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOpcRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDpcRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyMapStatus, &tmpsize);

	mtpSpStudyMapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
}

/*
 * store_mtpSpStudyMapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyMapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpStudyMapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyMapTable", "storing data...  "));
	refresh_mtpSpStudyMapTable();
	(void) tmpsize;
	for (hcindex = mtpSpStudyMapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyMapTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyMapTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyMapTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOpcRsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDpcRsId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyMapStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsCurrentTable_add(): adds a structure node to our data set
 */
int
mtpRsCurrentTable_add(struct mtpRsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));

	header_complex_add_data(&mtpRsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsCurrentTable_data);

	DEBUGMSGTL(("mtpRsCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCurrentValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpsize);

	mtpRsCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
}

/*
 * store_mtpRsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsCurrentTable", "storing data...  "));
	refresh_mtpRsCurrentTable();
	(void) tmpsize;
	for (hcindex = mtpRsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsCurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsCurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsCurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCurrentValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsInt5minTable_add(): adds a structure node to our data set
 */
int
mtpRsInt5minTable_add(struct mtpRsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsInt5minInterval, sizeof(thedata->mtpRsInt5minInterval));

	header_complex_add_data(&mtpRsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt5minTable_data);

	DEBUGMSGTL(("mtpRsInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpsize);

	mtpRsInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
}

/*
 * store_mtpRsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt5minTable", "storing data...  "));
	refresh_mtpRsInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpRsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsInt15minTable_add(): adds a structure node to our data set
 */
int
mtpRsInt15minTable_add(struct mtpRsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsInt15minInterval, sizeof(thedata->mtpRsInt15minInterval));

	header_complex_add_data(&mtpRsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt15minTable_data);

	DEBUGMSGTL(("mtpRsInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpsize);

	mtpRsInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
}

/*
 * store_mtpRsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt15minTable", "storing data...  "));
	refresh_mtpRsInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpRsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsSiTable_add(): adds a structure node to our data set
 */
int
mtpRsSiTable_add(struct mtpRsSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));

	header_complex_add_data(&mtpRsSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);

	DEBUGMSGTL(("mtpRsSiTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiStatus, &tmpsize);

	mtpRsSiTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
}

/*
 * store_mtpRsSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiTable", "storing data...  "));
	refresh_mtpRsSiTable();
	(void) tmpsize;
	for (hcindex = mtpRsSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsSiTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsSiInt5minTable_add(): adds a structure node to our data set
 */
int
mtpRsSiInt5minTable_add(struct mtpRsSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiInt5minInterval, sizeof(thedata->mtpRsSiInt5minInterval));

	header_complex_add_data(&mtpRsSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpRsSiInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpsize);

	mtpRsSiInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "storing data...  "));
	refresh_mtpRsSiInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpRsSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsSiInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minReceivedOctetsOpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsSiInt15minTable_add(): adds a structure node to our data set
 */
int
mtpRsSiInt15minTable_add(struct mtpRsSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiInt15minInterval, sizeof(thedata->mtpRsSiInt15minInterval));

	header_complex_add_data(&mtpRsSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpRsSiInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpsize);

	mtpRsSiInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "storing data...  "));
	refresh_mtpRsSiInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpRsSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsSiInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsCurrentTable_add(): adds a structure node to our data set
 */
int
mtpLsCurrentTable_add(struct mtpLsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));

	header_complex_add_data(&mtpLsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsCurrentTable_data);

	DEBUGMSGTL(("mtpLsCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCurrentValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsCurrentTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentSlsUnavailable, &tmpsize);

	mtpLsCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
}

/*
 * store_mtpLsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsCurrentTable", "storing data...  "));
	refresh_mtpLsCurrentTable();
	(void) tmpsize;
	for (hcindex = mtpLsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsCurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsCurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsCurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCurrentValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsCurrentTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentSlsUnavailable, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsInt5minTable_add(): adds a structure node to our data set
 */
int
mtpLsInt5minTable_add(struct mtpLsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));

	header_complex_add_data(&mtpLsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsInt5minTable_data);

	DEBUGMSGTL(("mtpLsInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt5minAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt5minAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt5minSlsUnavailable, &tmpsize);

	mtpLsInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
}

/*
 * store_mtpLsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsInt5minTable", "storing data...  "));
	refresh_mtpLsInt5minTable();
	(void) tmpsize;
	for (hcindex = mtpLsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsInt5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt5minAdjacentInaccessibleEvents, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt5minAdjacentInaccessibleDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt5minSlsUnavailable, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsInt15minTable_add(): adds a structure node to our data set
 */
int
mtpLsInt15minTable_add(struct mtpLsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpLsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt15minInterval, sizeof(thedata->mtpLsInt15minInterval));

	header_complex_add_data(&mtpLsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsInt15minTable_data);

	DEBUGMSGTL(("mtpLsInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minSlsUnavailable, &tmpsize);

	mtpLsInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
}

/*
 * store_mtpLsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsInt15minTable", "storing data...  "));
	refresh_mtpLsInt15minTable();
	(void) tmpsize;
	for (hcindex = mtpLsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsInt15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minSlsUnavailable, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlStatsTable_add(): adds a structure node to our data set
 */
int
mtpSlStatsTable_add(struct mtpSlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlStatsTable_data);

	DEBUGMSGTL(("mtpSlStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurInService, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsFailAlignOrProving, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsNacksReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurUnavail, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurUnavailFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurUnavailRpo, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsSibsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsTranSioSifOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsRetransOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsTranMsus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsRecvSioSifOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsRecvMsus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd3, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus3, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd3, &tmpsize);

	mtpSlStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlStatsTable", "done.\n"));
}

/*
 * store_mtpSlStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlStatsTable", "storing data...  "));
	refresh_mtpSlStatsTable();
	(void) tmpsize;
	for (hcindex = mtpSlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurInService, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsFailAlignOrProving, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsNacksReceived, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurUnavail, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurUnavailFailed, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurUnavailRpo, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsSibsSent, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsTranSioSifOctets, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsRetransOctets, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsTranMsus, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsRecvSioSifOctets, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsRecvMsus, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd0, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd1, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd2, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd3, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus0, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus1, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus2, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus3, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd0, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd1, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd2, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd3, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3CurrentTable_add(): adds a structure node to our data set
 */
int
mtpSlL3CurrentTable_add(struct mtpSlL3CurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3CurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlL3CurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3CurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3CurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3CurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3CurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3CurrentTable_data);

	DEBUGMSGTL(("mtpSlL3CurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3CurrentValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL3CurrentTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentRestorations, &tmpsize);

	mtpSlL3CurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL3CurrentTable", "done.\n"));
}

/*
 * store_mtpSlL3CurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3CurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3CurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3CurrentTable", "storing data...  "));
	refresh_mtpSlL3CurrentTable();
	(void) tmpsize;
	for (hcindex = mtpSlL3CurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3CurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3CurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3CurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3CurrentValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL3CurrentTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlLocalInhibition, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlRemoteInhibition, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlFailed, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlRemoteProcOutage, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentLocalMgmtInhibit, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentLocalBusy, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlCongestedStarts, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlCongestedDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlCongestionStops, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentDiscardedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentChangeovers, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentChangebacks, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentRestorations, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3Int5minTable_add(): adds a structure node to our data set
 */
int
mtpSlL3Int5minTable_add(struct mtpSlL3Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL3Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL3Int5minInterval, sizeof(thedata->mtpSlL3Int5minInterval));

	header_complex_add_data(&mtpSlL3Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3Int5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3Int5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3Int5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3Int5minTable_data);

	DEBUGMSGTL(("mtpSlL3Int5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL3Int5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL3Int5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minRestorations, &tmpsize);

	mtpSlL3Int5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL3Int5minTable", "done.\n"));
}

/*
 * store_mtpSlL3Int5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3Int5minTable", "storing data...  "));
	refresh_mtpSlL3Int5minTable();
	(void) tmpsize;
	for (hcindex = mtpSlL3Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3Int5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3Int5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3Int5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL3Int5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL3Int5minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlLocalInhibition, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlRemoteInhibition, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlFailed, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlRemoteProcOutage, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minLocalMgmtInhibit, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minLocalBusy, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlCongestedStarts, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlCongestedDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlCongestionStops, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minDiscardedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minChangeovers, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minChangebacks, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minRestorations, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3Int15minTable_add(): adds a structure node to our data set
 */
int
mtpSlL3Int15minTable_add(struct mtpSlL3Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL3Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL3Int15minInterval, sizeof(thedata->mtpSlL3Int15minInterval));

	header_complex_add_data(&mtpSlL3Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3Int15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3Int15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3Int15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3Int15minTable_data);

	DEBUGMSGTL(("mtpSlL3Int15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL3Int15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL3Int15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minRestorations, &tmpsize);

	mtpSlL3Int15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL3Int15minTable", "done.\n"));
}

/*
 * store_mtpSlL3Int15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3Int15minTable", "storing data...  "));
	refresh_mtpSlL3Int15minTable();
	(void) tmpsize;
	for (hcindex = mtpSlL3Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3Int15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3Int15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3Int15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL3Int15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL3Int15minTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlLocalInhibition, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlRemoteInhibition, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlFailed, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlRemoteProcOutage, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minLocalMgmtInhibit, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minLocalBusy, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlCongestedStarts, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlCongestedDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlCongestionStops, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minDiscardedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minChangeovers, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minChangebacks, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minRestorations, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2CurrentTable_add(): adds a structure node to our data set
 */
int
mtpSlL2CurrentTable_add(struct mtpSlL2CurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2CurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlL2CurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2CurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2CurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2CurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2CurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2CurrentTable_data);

	DEBUGMSGTL(("mtpSlL2CurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2CurrentValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL2CurrentTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentReceivedMSUs, &tmpsize);

	mtpSlL2CurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL2CurrentTable", "done.\n"));
}

/*
 * store_mtpSlL2CurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2CurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2CurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2CurrentTable", "storing data...  "));
	refresh_mtpSlL2CurrentTable();
	(void) tmpsize;
	for (hcindex = mtpSlL2CurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2CurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2CurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2CurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2CurrentValidIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL2CurrentTimeDiscontinuity, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentSlInServiceDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentSlAlignment, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentSignUnitsReceived, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentNegAckReceived, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentRetransmittedOctets, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentTransmittedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentReceivedMSUs, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2Int5minTable_add(): adds a structure node to our data set
 */
int
mtpSlL2Int5minTable_add(struct mtpSlL2Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL2Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL2Int5minInterval, sizeof(thedata->mtpSlL2Int5minInterval));

	header_complex_add_data(&mtpSlL2Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2Int5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2Int5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2Int5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2Int5minTable_data);

	DEBUGMSGTL(("mtpSlL2Int5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2Int5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL2Int5minTimestamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minReceivedMSUs, &tmpsize);

	mtpSlL2Int5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL2Int5minTable", "done.\n"));
}

/*
 * store_mtpSlL2Int5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2Int5minTable", "storing data...  "));
	refresh_mtpSlL2Int5minTable();
	(void) tmpsize;
	for (hcindex = mtpSlL2Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2Int5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2Int5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2Int5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2Int5minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL2Int5minTimestamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minSlInServiceDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minSlAlignment, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minSignUnitsReceived, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minNegAckReceived, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minRetransmittedOctets, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minTransmittedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minReceivedMSUs, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2Int15minTable_add(): adds a structure node to our data set
 */
int
mtpSlL2Int15minTable_add(struct mtpSlL2Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL2Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL2Int15minInterval, sizeof(thedata->mtpSlL2Int15minInterval));

	header_complex_add_data(&mtpSlL2Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2Int15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2Int15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2Int15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2Int15minTable_data);

	DEBUGMSGTL(("mtpSlL2Int15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2Int15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL2Int15minTimestamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minReceivedMSUs, &tmpsize);

	mtpSlL2Int15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSlL2Int15minTable", "done.\n"));
}

/*
 * store_mtpSlL2Int15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2Int15minTable", "storing data...  "));
	refresh_mtpSlL2Int15minTable();
	(void) tmpsize;
	for (hcindex = mtpSlL2Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2Int15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2Int15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2Int15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2Int15minInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL2Int15minTimestamp, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minSlInServiceDuration, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minSlAlignment, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minSignUnitsReceived, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minNegAckReceived, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minRetransmittedOctets, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minTransmittedMSUs, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minReceivedMSUs, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdtStatsTable_add(): adds a structure node to our data set
 */
int
mtpSdtStatsTable_add(struct mtpSdtStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));

	header_complex_add_data(&mtpSdtStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdtStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdtStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdtStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdtStatsTable_data);

	DEBUGMSGTL(("mtpSdtStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxBytes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxSus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxSusRepeated, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxUnderruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxAborts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxSusInError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxBytes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxSusCompressed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxOverruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxAborts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxSusInError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxSyncTransitions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxBitsOctetCounted, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxCrcErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameTooLong, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameTooShort, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxResidueErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsCarrierCtsLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsCarrierDcdLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsCarrierLost, &tmpsize);

	mtpSdtStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdtStatsTable", "done.\n"));
}

/*
 * store_mtpSdtStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdtStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtStatsTable", "storing data...  "));
	refresh_mtpSdtStatsTable();
	(void) tmpsize;
	for (hcindex = mtpSdtStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSdtStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdtStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxBytes, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxSus, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxSusRepeated, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxUnderruns, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxAborts, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxBufferOverflows, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxSusInError, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxBytes, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxSusCompressed, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxOverruns, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxAborts, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxBufferOverflows, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxSusInError, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxSyncTransitions, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxBitsOctetCounted, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxCrcErrors, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameErrors, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameOverflows, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameTooLong, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameTooShort, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxResidueErrors, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsCarrierCtsLost, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsCarrierDcdLost, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsCarrierLost, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdlStatsTable_add(): adds a structure node to our data set
 */
int
mtpSdlStatsTable_add(struct mtpSdlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSdlId, sizeof(thedata->mtpSdlId));

	header_complex_add_data(&mtpSdlStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdlStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdlStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdlStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdlStatsTable_data);

	DEBUGMSGTL(("mtpSdlStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsRxOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsTxOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsRXOverruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsTxUnderruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsRxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsTxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsLeadCtsLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsLeadDcdLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsCarrierLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsBipolarViolations, &tmpsize);

	mtpSdlStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpSdlStatsTable", "done.\n"));
}

/*
 * store_mtpSdlStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlStatsTable", "storing data...  "));
	refresh_mtpSdlStatsTable();
	(void) tmpsize;
	for (hcindex = mtpSdlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSdlStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdlStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlId, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsRxOctets, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsTxOctets, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsRXOverruns, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsTxUnderruns, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsRxBufferOverflows, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsTxBufferOverflows, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsLeadCtsLost, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsLeadDcdLost, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsCarrierLost, &tmpsize);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsBipolarViolations, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpSpCurrentTable(): refresh mtpSpCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpCurrentTable(void)
{
	if (mtpSpCurrentTable_refresh == 0)
		return;
	mtpSpCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpCurrentTable_row(): refresh mtpSpCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpCurrentTable_row(struct mtpSpCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSpCurrentTable_request = sa_request;
}

/*
 * var_mtpSpCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSpCurrentValidIntervals;
	case MTPSPCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSpCurrentTimeDiscontinuity;
	case MTPSPCURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSpCurrentDiscardedMSUs;
	case MTPSPCURRENTRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus0);
		return (uint8_t *) &StorageTmp->mtpSpCurrentReceivedTFCstatus0;
	case MTPSPCURRENTRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus1);
		return (uint8_t *) &StorageTmp->mtpSpCurrentReceivedTFCstatus1;
	case MTPSPCURRENTRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus2);
		return (uint8_t *) &StorageTmp->mtpSpCurrentReceivedTFCstatus2;
	case MTPSPCURRENTOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentOctetsXferred);
		return (uint8_t *) &StorageTmp->mtpSpCurrentOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt5minTable(): refresh mtpSpInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt5minTable(void)
{
	if (mtpSpInt5minTable_refresh == 0)
		return;
	mtpSpInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpInt5minTable_row(): refresh mtpSpInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt5minTable_row(struct mtpSpInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt5minTable_request = sa_request;
}

/*
 * var_mtpSpInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpInt5minTimeStamp;
	case MTPSPINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSpInt5minDiscardedMSUs;
	case MTPSPINT5MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus0);
		return (uint8_t *) &StorageTmp->mtpSpInt5minReceivedTFCstatus0;
	case MTPSPINT5MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus1);
		return (uint8_t *) &StorageTmp->mtpSpInt5minReceivedTFCstatus1;
	case MTPSPINT5MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus2);
		return (uint8_t *) &StorageTmp->mtpSpInt5minReceivedTFCstatus2;
	case MTPSPINT5MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minOctetsXferred);
		return (uint8_t *) &StorageTmp->mtpSpInt5minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt15minTable(): refresh mtpSpInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt15minTable(void)
{
	if (mtpSpInt15minTable_refresh == 0)
		return;
	mtpSpInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpInt15minTable_row(): refresh mtpSpInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt15minTable_row(struct mtpSpInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt15minTable_request = sa_request;
}

/*
 * var_mtpSpInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpInt15minTimeStamp;
	case MTPSPINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSpInt15minDiscardedMSUs;
	case MTPSPINT15MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus0);
		return (uint8_t *) &StorageTmp->mtpSpInt15minReceivedTFCstatus0;
	case MTPSPINT15MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus1);
		return (uint8_t *) &StorageTmp->mtpSpInt15minReceivedTFCstatus1;
	case MTPSPINT15MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus2);
		return (uint8_t *) &StorageTmp->mtpSpInt15minReceivedTFCstatus2;
	case MTPSPINT15MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minOctetsXferred);
		return (uint8_t *) &StorageTmp->mtpSpInt15minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiTable(): refresh mtpSpSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiTable(void)
{
	if (mtpSpSiTable_refresh == 0)
		return;
	mtpSpSiTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpSiTable_row(): refresh mtpSpSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiTable_row(struct mtpSpSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiTable_request = sa_request;
}

/*
 * var_mtpSpSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpSiTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSIVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSpSiValidIntervals;
	case MTPSPSITIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSpSiTimeDiscontinuity;
	case MTPSPSITRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTransmittedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiTransmittedUPUnavailable;
	case MTPSPSIRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiReceivedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiReceivedUPUnavailable;
	case MTPSPSIHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiHandledOctetsSIO);
		return (uint8_t *) &StorageTmp->mtpSpSiHandledOctetsSIO;
	case MTPSPSISTATUS:
		*write_method = write_mtpSpSiStatus;
		*var_len = sizeof(StorageTmp->mtpSpSiStatus);
		return (uint8_t *) &StorageTmp->mtpSpSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt5minTable(): refresh mtpSpSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt5minTable(void)
{
	if (mtpSpSiInt5minTable_refresh == 0)
		return;
	mtpSpSiInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpSiInt5minTable_row(): refresh mtpSpSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt5minTable_row(struct mtpSpSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt5minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpSiInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minTimeStamp;
	case MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable;
	case MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minReceivedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable;
	case MTPSPSIINT5MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minHandledOctetsSIO);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt15minTable(): refresh mtpSpSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt15minTable(void)
{
	if (mtpSpSiInt15minTable_refresh == 0)
		return;
	mtpSpSiInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpSiInt15minTable_row(): refresh mtpSpSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt15minTable_row(struct mtpSpSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt15minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpSiInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minTimeStamp;
	case MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable;
	case MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minReceivedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable;
	case MTPSPSIINT15MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minHandledOctetsSIO);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyTable(): refresh mtpSpStudyTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyTable(void)
{
	if (mtpSpStudyTable_refresh == 0)
		return;
	mtpSpStudyTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyTable_row(): refresh mtpSpStudyTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyTable_row(struct mtpSpStudyTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyTable_request = sa_request;
}

/*
 * var_mtpSpStudyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpStudyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpStudyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSpStudyValidIntervals;
	case MTPSPSTUDYTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSpStudyTimeDiscontinuity;
	case MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio;
	case MTPSPSTUDYHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio;
	case MTPSPSTUDYSTATUS:
		*write_method = write_mtpSpStudyStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyStatus);
		return (uint8_t *) &StorageTmp->mtpSpStudyStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt5minTable(): refresh mtpSpStudyInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt5minTable(void)
{
	if (mtpSpStudyInt5minTable_refresh == 0)
		return;
	mtpSpStudyInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyInt5minTable_row(): refresh mtpSpStudyInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt5minTable_row(struct mtpSpStudyInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt5minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpStudyInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpStudyInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt5minTimeStamp;
	case MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio;
	case MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt15minTable(): refresh mtpSpStudyInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt15minTable(void)
{
	if (mtpSpStudyInt15minTable_refresh == 0)
		return;
	mtpSpStudyInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyInt15minTable_row(): refresh mtpSpStudyInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt15minTable_row(struct mtpSpStudyInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt15minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpStudyInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpStudyInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt15minTimeStamp;
	case MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio;
	case MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyMapTable(): refresh mtpSpStudyMapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyMapTable(void)
{
	if (mtpSpStudyMapTable_refresh == 0)
		return;
	mtpSpStudyMapTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyMapTable_row(): refresh mtpSpStudyMapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyMapTable_row(struct mtpSpStudyMapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyMapTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyMapTable_request = sa_request;
}

/*
 * var_mtpSpStudyMapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSpStudyMapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyMapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSpStudyMapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyMapTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyMapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyMapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYMAPSTATUS:
		*write_method = write_mtpSpStudyMapStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyMapStatus);
		return (uint8_t *) &StorageTmp->mtpSpStudyMapStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsCurrentTable(): refresh mtpRsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsCurrentTable(void)
{
	if (mtpRsCurrentTable_refresh == 0)
		return;
	mtpRsCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsCurrentTable_row(): refresh mtpRsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsCurrentTable_row(struct mtpRsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpRsCurrentTable_request = sa_request;
}

/*
 * var_mtpRsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpRsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpRsCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpRsCurrentValidIntervals;
	case MTPRSCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpRsCurrentTimeDiscontinuity;
	case MTPRSCURRENTRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedOctetsOPC);
		return (uint8_t *) &StorageTmp->mtpRsCurrentReceivedOctetsOPC;
	case MTPRSCURRENTTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedOctetsDPC);
		return (uint8_t *) &StorageTmp->mtpRsCurrentTransmittedOctetsDPC;
	case MTPRSCURRENTRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedMSUsOpc);
		return (uint8_t *) &StorageTmp->mtpRsCurrentReceivedMSUsOpc;
	case MTPRSCURRENTTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedMSUsDpc);
		return (uint8_t *) &StorageTmp->mtpRsCurrentTransmittedMSUsDpc;
	case MTPRSCURRENTROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailable);
		return (uint8_t *) &StorageTmp->mtpRsCurrentRouteSetUnavailable;
	case MTPRSCURRENTROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailableDuration);
		return (uint8_t *) &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt5minTable(): refresh mtpRsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt5minTable(void)
{
	if (mtpRsInt5minTable_refresh == 0)
		return;
	mtpRsInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsInt5minTable_row(): refresh mtpRsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt5minTable_row(struct mtpRsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt5minTable_request = sa_request;
}

/*
 * var_mtpRsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpRsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpRsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsInt5minTimeStamp;
	case MTPRSINT5MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedOctetsOPC);
		return (uint8_t *) &StorageTmp->mtpRsInt5minReceivedOctetsOPC;
	case MTPRSINT5MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedOctetsDPC);
		return (uint8_t *) &StorageTmp->mtpRsInt5minTransmittedOctetsDPC;
	case MTPRSINT5MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedMSUsOpc);
		return (uint8_t *) &StorageTmp->mtpRsInt5minReceivedMSUsOpc;
	case MTPRSINT5MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedMSUsDpc);
		return (uint8_t *) &StorageTmp->mtpRsInt5minTransmittedMSUsDpc;
	case MTPRSINT5MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailable);
		return (uint8_t *) &StorageTmp->mtpRsInt5minRouteSetUnavailable;
	case MTPRSINT5MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailableDuration);
		return (uint8_t *) &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt15minTable(): refresh mtpRsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt15minTable(void)
{
	if (mtpRsInt15minTable_refresh == 0)
		return;
	mtpRsInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsInt15minTable_row(): refresh mtpRsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt15minTable_row(struct mtpRsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt15minTable_request = sa_request;
}

/*
 * var_mtpRsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpRsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpRsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsInt15minTimeStamp;
	case MTPRSINT15MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedOctetsOPC);
		return (uint8_t *) &StorageTmp->mtpRsInt15minReceivedOctetsOPC;
	case MTPRSINT15MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedOctetsDPC);
		return (uint8_t *) &StorageTmp->mtpRsInt15minTransmittedOctetsDPC;
	case MTPRSINT15MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedMSUsOpc);
		return (uint8_t *) &StorageTmp->mtpRsInt15minReceivedMSUsOpc;
	case MTPRSINT15MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedMSUsDpc);
		return (uint8_t *) &StorageTmp->mtpRsInt15minTransmittedMSUsDpc;
	case MTPRSINT15MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailable);
		return (uint8_t *) &StorageTmp->mtpRsInt15minRouteSetUnavailable;
	case MTPRSINT15MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailableDuration);
		return (uint8_t *) &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiTable(): refresh mtpRsSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiTable(void)
{
	if (mtpRsSiTable_refresh == 0)
		return;
	mtpRsSiTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsSiTable_row(): refresh mtpRsSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiTable_row(struct mtpRsSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiTable_request = sa_request;
}

/*
 * var_mtpRsSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpRsSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpRsSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsSiTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSIVALIDINTERVALS:
		*write_method = write_mtpRsSiValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsSiValidIntervals);
		return (uint8_t *) &StorageTmp->mtpRsSiValidIntervals;
	case MTPRSSITIMEDISCONTINUITY:
		*write_method = write_mtpRsSiTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsSiTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpRsSiTimeDiscontinuity;
	case MTPRSSIRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedOctetsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiReceivedOctetsOpcSio;
	case MTPRSSITRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedOctetsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiTransmittedOctetsDpcSio;
	case MTPRSSIRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedMSUsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiReceivedMSUsOpcSio;
	case MTPRSSITRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedMSUsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiTransmittedMSUsDpcSio;
	case MTPRSSISTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiStatus);
		return (uint8_t *) &StorageTmp->mtpRsSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt5minTable(): refresh mtpRsSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt5minTable(void)
{
	if (mtpRsSiInt5minTable_refresh == 0)
		return;
	mtpRsSiInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsSiInt5minTable_row(): refresh mtpRsSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt5minTable_row(struct mtpRsSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt5minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpRsSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpRsSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsSiInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTimeStamp;
	case MTPRSSIINT5MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minReceivedOctetsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minReceivedOctetsOpcSio;
	case MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio;
	case MTPRSSIINT5MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio;
	case MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt15minTable(): refresh mtpRsSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt15minTable(void)
{
	if (mtpRsSiInt15minTable_refresh == 0)
		return;
	mtpRsSiInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsSiInt15minTable_row(): refresh mtpRsSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt15minTable_row(struct mtpRsSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt15minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpRsSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpRsSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsSiInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minTimeStamp;
	case MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio;
	case MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio;
	case MTPRSSIINT15MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio;
	case MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsCurrentTable(): refresh mtpLsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsCurrentTable(void)
{
	if (mtpLsCurrentTable_refresh == 0)
		return;
	mtpLsCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsCurrentTable_row(): refresh mtpLsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsCurrentTable_row(struct mtpLsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpLsCurrentTable_request = sa_request;
}

/*
 * var_mtpLsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpLsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpLsCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpLsCurrentValidIntervals;
	case MTPLSCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpLsCurrentTimeDiscontinuity;
	case MTPLSCURRENTADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents);
		return (uint8_t *) &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents;
	case MTPLSCURRENTADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration);
		return (uint8_t *) &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration;
	case MTPLSCURRENTSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentSlsUnavailable);
		return (uint8_t *) &StorageTmp->mtpLsCurrentSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsInt5minTable(): refresh mtpLsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsInt5minTable(void)
{
	if (mtpLsInt5minTable_refresh == 0)
		return;
	mtpLsInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsInt5minTable_row(): refresh mtpLsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsInt5minTable_row(struct mtpLsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpLsInt5minTable_request = sa_request;
}

/*
 * var_mtpLsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpLsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpLsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpLsInt5minTimeStamp;
	case MTPLSINT5MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt5minAdjacentInaccessibleEvents);
		return (uint8_t *) &StorageTmp->mtpLsInt5minAdjacentInaccessibleEvents;
	case MTPLSINT5MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt5minAdjacentInaccessibleDuration);
		return (uint8_t *) &StorageTmp->mtpLsInt5minAdjacentInaccessibleDuration;
	case MTPLSINT5MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt5minSlsUnavailable);
		return (uint8_t *) &StorageTmp->mtpLsInt5minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsInt15minTable(): refresh mtpLsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsInt15minTable(void)
{
	if (mtpLsInt15minTable_refresh == 0)
		return;
	mtpLsInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsInt15minTable_row(): refresh mtpLsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsInt15minTable_row(struct mtpLsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpLsInt15minTable_request = sa_request;
}

/*
 * var_mtpLsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpLsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpLsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpLsInt15minTimeStamp;
	case MTPLSINT15MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents);
		return (uint8_t *) &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents;
	case MTPLSINT15MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration);
		return (uint8_t *) &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration;
	case MTPLSINT15MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minSlsUnavailable);
		return (uint8_t *) &StorageTmp->mtpLsInt15minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlStatsTable(): refresh mtpSlStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlStatsTable(void)
{
	if (mtpSlStatsTable_refresh == 0)
		return;
	mtpSlStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlStatsTable_row(): refresh mtpSlStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlStatsTable_row(struct mtpSlStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSlStatsTable_request = sa_request;
}

/*
 * var_mtpSlStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLSTATSDURINSERVICE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurInService);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurInService;
	case MTPSLSTATSFAILALIGNORPROVING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsFailAlignOrProving);
		return (uint8_t *) &StorageTmp->mtpSlStatsFailAlignOrProving;
	case MTPSLSTATSNACKSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsNacksReceived);
		return (uint8_t *) &StorageTmp->mtpSlStatsNacksReceived;
	case MTPSLSTATSDURUNAVAIL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurUnavail);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurUnavail;
	case MTPSLSTATSDURUNAVAILFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurUnavailFailed);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurUnavailFailed;
	case MTPSLSTATSDURUNAVAILRPO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurUnavailRpo);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurUnavailRpo;
	case MTPSLSTATSSIBSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsSibsSent);
		return (uint8_t *) &StorageTmp->mtpSlStatsSibsSent;
	case MTPSLSTATSTRANSIOSIFOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsTranSioSifOctets);
		return (uint8_t *) &StorageTmp->mtpSlStatsTranSioSifOctets;
	case MTPSLSTATSRETRANSOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsRetransOctets);
		return (uint8_t *) &StorageTmp->mtpSlStatsRetransOctets;
	case MTPSLSTATSTRANMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsTranMsus);
		return (uint8_t *) &StorageTmp->mtpSlStatsTranMsus;
	case MTPSLSTATSRECVSIOSIFOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsRecvSioSifOctets);
		return (uint8_t *) &StorageTmp->mtpSlStatsRecvSioSifOctets;
	case MTPSLSTATSRECVMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsRecvMsus);
		return (uint8_t *) &StorageTmp->mtpSlStatsRecvMsus;
	case MTPSLSTATSCONGONSETIND0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd0);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd0;
	case MTPSLSTATSCONGONSETIND1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd1);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd1;
	case MTPSLSTATSCONGONSETIND2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd2);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd2;
	case MTPSLSTATSCONGONSETIND3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd3);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd3;
	case MTPSLSTATSDURCONGSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus0);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus0;
	case MTPSLSTATSDURCONGSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus1);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus1;
	case MTPSLSTATSDURCONGSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus2);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus2;
	case MTPSLSTATSDURCONGSTATUS3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus3);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus3;
	case MTPSLSTATSCONGDISCDIND0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd0);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd0;
	case MTPSLSTATSCONGDISCDIND1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd1);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd1;
	case MTPSLSTATSCONGDISCDIND2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd2);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd2;
	case MTPSLSTATSCONGDISCDIND3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd3);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd3;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3CurrentTable(): refresh mtpSlL3CurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3CurrentTable(void)
{
	if (mtpSlL3CurrentTable_refresh == 0)
		return;
	mtpSlL3CurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3CurrentTable_row(): refresh mtpSlL3CurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3CurrentTable_row(struct mtpSlL3CurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3CurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3CurrentTable_request = sa_request;
}

/*
 * var_mtpSlL3CurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlL3CurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3CurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlL3CurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3CurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3CurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3CurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3CURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentValidIntervals;
	case MTPSLL3CURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentTimeDiscontinuity;
	case MTPSLL3CURRENTSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration;
	case MTPSLL3CURRENTSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlLocalInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlLocalInhibition;
	case MTPSLL3CURRENTSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlRemoteInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlRemoteInhibition;
	case MTPSLL3CURRENTSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlFailed);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlFailed;
	case MTPSLL3CURRENTSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlRemoteProcOutage);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlRemoteProcOutage;
	case MTPSLL3CURRENTLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentLocalMgmtInhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentLocalMgmtInhibit;
	case MTPSLL3CURRENTLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit;
	case MTPSLL3CURRENTLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentLocalBusy);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentLocalBusy;
	case MTPSLL3CURRENTSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlCongestedStarts);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlCongestedStarts;
	case MTPSLL3CURRENTSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlCongestedDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlCongestedDuration;
	case MTPSLL3CURRENTSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlCongestionStops);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlCongestionStops;
	case MTPSLL3CURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentDiscardedMSUs;
	case MTPSLL3CURRENTCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss;
	case MTPSLL3CURRENTCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentChangeovers);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentChangeovers;
	case MTPSLL3CURRENTCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentChangebacks);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentChangebacks;
	case MTPSLL3CURRENTRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentRestorations);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3Int5minTable(): refresh mtpSlL3Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3Int5minTable(void)
{
	if (mtpSlL3Int5minTable_refresh == 0)
		return;
	mtpSlL3Int5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3Int5minTable_row(): refresh mtpSlL3Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3Int5minTable_row(struct mtpSlL3Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3Int5minTable_request = sa_request;
}

/*
 * var_mtpSlL3Int5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlL3Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlL3Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3Int5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3Int5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minTimeStamp;
	case MTPSLL3INT5MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration;
	case MTPSLL3INT5MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlLocalInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlLocalInhibition;
	case MTPSLL3INT5MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlRemoteInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlRemoteInhibition;
	case MTPSLL3INT5MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlFailed);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlFailed;
	case MTPSLL3INT5MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlRemoteProcOutage);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlRemoteProcOutage;
	case MTPSLL3INT5MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minLocalMgmtInhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minLocalMgmtInhibit;
	case MTPSLL3INT5MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit;
	case MTPSLL3INT5MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minLocalBusy);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minLocalBusy;
	case MTPSLL3INT5MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlCongestedStarts);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlCongestedStarts;
	case MTPSLL3INT5MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlCongestedDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlCongestedDuration;
	case MTPSLL3INT5MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlCongestionStops);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlCongestionStops;
	case MTPSLL3INT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minDiscardedMSUs;
	case MTPSLL3INT5MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss;
	case MTPSLL3INT5MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minChangeovers);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minChangeovers;
	case MTPSLL3INT5MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minChangebacks);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minChangebacks;
	case MTPSLL3INT5MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minRestorations);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3Int15minTable(): refresh mtpSlL3Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3Int15minTable(void)
{
	if (mtpSlL3Int15minTable_refresh == 0)
		return;
	mtpSlL3Int15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3Int15minTable_row(): refresh mtpSlL3Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3Int15minTable_row(struct mtpSlL3Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3Int15minTable_request = sa_request;
}

/*
 * var_mtpSlL3Int15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlL3Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlL3Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3Int15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3Int15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minTimeStamp;
	case MTPSLL3INT15MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration;
	case MTPSLL3INT15MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlLocalInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlLocalInhibition;
	case MTPSLL3INT15MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlRemoteInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlRemoteInhibition;
	case MTPSLL3INT15MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlFailed);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlFailed;
	case MTPSLL3INT15MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlRemoteProcOutage);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlRemoteProcOutage;
	case MTPSLL3INT15MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minLocalMgmtInhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minLocalMgmtInhibit;
	case MTPSLL3INT15MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit;
	case MTPSLL3INT15MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minLocalBusy);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minLocalBusy;
	case MTPSLL3INT15MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlCongestedStarts);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlCongestedStarts;
	case MTPSLL3INT15MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlCongestedDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlCongestedDuration;
	case MTPSLL3INT15MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlCongestionStops);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlCongestionStops;
	case MTPSLL3INT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minDiscardedMSUs;
	case MTPSLL3INT15MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss;
	case MTPSLL3INT15MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minChangeovers);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minChangeovers;
	case MTPSLL3INT15MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minChangebacks);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minChangebacks;
	case MTPSLL3INT15MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minRestorations);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2CurrentTable(): refresh mtpSlL2CurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2CurrentTable(void)
{
	if (mtpSlL2CurrentTable_refresh == 0)
		return;
	mtpSlL2CurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2CurrentTable_row(): refresh mtpSlL2CurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2CurrentTable_row(struct mtpSlL2CurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2CurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2CurrentTable_request = sa_request;
}

/*
 * var_mtpSlL2CurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlL2CurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2CurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlL2CurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2CurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2CurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2CurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2CURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentValidIntervals;
	case MTPSLL2CURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentTimeDiscontinuity;
	case MTPSLL2CURRENTSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentSlInServiceDuration);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentSlInServiceDuration;
	case MTPSLL2CURRENTSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentSlAlignment);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentSlAlignment;
	case MTPSLL2CURRENTSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentSignUnitsReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentSignUnitsReceived;
	case MTPSLL2CURRENTNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentNegAckReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentNegAckReceived;
	case MTPSLL2CURRENTTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO;
	case MTPSLL2CURRENTRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentRetransmittedOctets);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentRetransmittedOctets;
	case MTPSLL2CURRENTTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentTransmittedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentTransmittedMSUs;
	case MTPSLL2CURRENTRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO;
	case MTPSLL2CURRENTRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentReceivedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2Int5minTable(): refresh mtpSlL2Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2Int5minTable(void)
{
	if (mtpSlL2Int5minTable_refresh == 0)
		return;
	mtpSlL2Int5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2Int5minTable_row(): refresh mtpSlL2Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2Int5minTable_row(struct mtpSlL2Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2Int5minTable_request = sa_request;
}

/*
 * var_mtpSlL2Int5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlL2Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlL2Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2Int5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2Int5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minTimestamp);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minTimestamp;
	case MTPSLL2INT5MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minSlInServiceDuration);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minSlInServiceDuration;
	case MTPSLL2INT5MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minSlAlignment);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minSlAlignment;
	case MTPSLL2INT5MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minSignUnitsReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minSignUnitsReceived;
	case MTPSLL2INT5MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minNegAckReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minNegAckReceived;
	case MTPSLL2INT5MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO;
	case MTPSLL2INT5MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minRetransmittedOctets);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minRetransmittedOctets;
	case MTPSLL2INT5MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minTransmittedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minTransmittedMSUs;
	case MTPSLL2INT5MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO;
	case MTPSLL2INT5MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minReceivedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2Int15minTable(): refresh mtpSlL2Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2Int15minTable(void)
{
	if (mtpSlL2Int15minTable_refresh == 0)
		return;
	mtpSlL2Int15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2Int15minTable_row(): refresh mtpSlL2Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2Int15minTable_row(struct mtpSlL2Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2Int15minTable_request = sa_request;
}

/*
 * var_mtpSlL2Int15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSlL2Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSlL2Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2Int15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2Int15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minTimestamp);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minTimestamp;
	case MTPSLL2INT15MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minSlInServiceDuration);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minSlInServiceDuration;
	case MTPSLL2INT15MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minSlAlignment);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minSlAlignment;
	case MTPSLL2INT15MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minSignUnitsReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minSignUnitsReceived;
	case MTPSLL2INT15MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minNegAckReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minNegAckReceived;
	case MTPSLL2INT15MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO;
	case MTPSLL2INT15MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minRetransmittedOctets);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minRetransmittedOctets;
	case MTPSLL2INT15MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minTransmittedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minTransmittedMSUs;
	case MTPSLL2INT15MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO;
	case MTPSLL2INT15MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minReceivedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdtStatsTable(): refresh mtpSdtStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdtStatsTable(void)
{
	if (mtpSdtStatsTable_refresh == 0)
		return;
	mtpSdtStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdtStatsTable_row(): refresh mtpSdtStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdtStatsTable_row(struct mtpSdtStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSdtStatsTable_request = sa_request;
}

/*
 * var_mtpSdtStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSdtStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSdtStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdtStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdtStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSDTSTATSTXBYTES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxBytes);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxBytes;
	case MTPSDTSTATSTXSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxSus);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxSus;
	case MTPSDTSTATSTXSUSREPEATED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxSusRepeated);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxSusRepeated;
	case MTPSDTSTATSTXUNDERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxUnderruns);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxUnderruns;
	case MTPSDTSTATSTXABORTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxAborts);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxAborts;
	case MTPSDTSTATSTXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxBufferOverflows;
	case MTPSDTSTATSTXSUSINERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxSusInError);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxSusInError;
	case MTPSDTSTATSRXBYTES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxBytes);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxBytes;
	case MTPSDTSTATSRXSUSCOMPRESSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxSusCompressed);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxSusCompressed;
	case MTPSDTSTATSRXOVERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxOverruns);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxOverruns;
	case MTPSDTSTATSRXABORTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxAborts);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxAborts;
	case MTPSDTSTATSRXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxBufferOverflows;
	case MTPSDTSTATSRXSUSINERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxSusInError);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxSusInError;
	case MTPSDTSTATSRXSYNCTRANSITIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxSyncTransitions);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxSyncTransitions;
	case MTPSDTSTATSRXBITSOCTETCOUNTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxBitsOctetCounted);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxBitsOctetCounted;
	case MTPSDTSTATSRXCRCERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxCrcErrors);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxCrcErrors;
	case MTPSDTSTATSRXFRAMEERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameErrors);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameErrors;
	case MTPSDTSTATSRXFRAMEOVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameOverflows);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameOverflows;
	case MTPSDTSTATSRXFRAMETOOLONG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameTooLong);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameTooLong;
	case MTPSDTSTATSRXFRAMETOOSHORT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameTooShort);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameTooShort;
	case MTPSDTSTATSRXRESIDUEERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxResidueErrors);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxResidueErrors;
	case MTPSDTSTATSCARRIERCTSLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsCarrierCtsLost);
		return (uint8_t *) &StorageTmp->mtpSdtStatsCarrierCtsLost;
	case MTPSDTSTATSCARRIERDCDLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsCarrierDcdLost);
		return (uint8_t *) &StorageTmp->mtpSdtStatsCarrierDcdLost;
	case MTPSDTSTATSCARRIERLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsCarrierLost);
		return (uint8_t *) &StorageTmp->mtpSdtStatsCarrierLost;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdlStatsTable(): refresh mtpSdlStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdlStatsTable(void)
{
	if (mtpSdlStatsTable_refresh == 0)
		return;
	mtpSdlStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdlStatsTable_row(): refresh mtpSdlStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdlStatsTable_row(struct mtpSdlStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSdlStatsTable_request = sa_request;
}

/*
 * var_mtpSdlStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpOmMIB above.
 */
uint8_t *
var_mtpSdlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpSdlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdlStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdlStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSDLSTATSRXOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsRxOctets);
		return (uint8_t *) &StorageTmp->mtpSdlStatsRxOctets;
	case MTPSDLSTATSTXOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsTxOctets);
		return (uint8_t *) &StorageTmp->mtpSdlStatsTxOctets;
	case MTPSDLSTATSRXOVERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsRXOverruns);
		return (uint8_t *) &StorageTmp->mtpSdlStatsRXOverruns;
	case MTPSDLSTATSTXUNDERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsTxUnderruns);
		return (uint8_t *) &StorageTmp->mtpSdlStatsTxUnderruns;
	case MTPSDLSTATSRXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsRxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdlStatsRxBufferOverflows;
	case MTPSDLSTATSTXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsTxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdlStatsTxBufferOverflows;
	case MTPSDLSTATSLEADCTSLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsLeadCtsLost);
		return (uint8_t *) &StorageTmp->mtpSdlStatsLeadCtsLost;
	case MTPSDLSTATSLEADDCDLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsLeadDcdLost);
		return (uint8_t *) &StorageTmp->mtpSdlStatsLeadDcdLost;
	case MTPSDLSTATSCARRIERLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsCarrierLost);
		return (uint8_t *) &StorageTmp->mtpSdlStatsCarrierLost;
	case MTPSDLSTATSBIPOLARVIOLATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsBipolarViolations);
		return (uint8_t *) &StorageTmp->mtpSdlStatsBipolarViolations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mtpRsSiValidIntervals(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpRsSiValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiValidIntervals;
		StorageTmp->mtpRsSiValidIntervals = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiValidIntervals = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTimeDiscontinuity(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpRsSiTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpOmMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTimeDiscontinuity;
		StorageTmp->mtpRsSiTimeDiscontinuity = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTimeDiscontinuity = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm1stAndIntervalActivate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm1stAndIntervalActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(oid *)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm1stAndIntervalActivate;
		tmplen = StorageTmp->mtpOm1stAndIntervalActivateLen;
		memdup((void *) &StorageTmp->mtpOm1stAndIntervalActivate, var_val, var_val_len);
		StorageTmp->mtpOm1stAndIntervalActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpOm1stAndIntervalActivate);
		StorageTmp->mtpOm1stAndIntervalActivate = tmpvar;
		StorageTmp->mtpOm1stAndIntervalActivateLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm1stAndIntervalDeactivate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm1stAndIntervalDeactivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalDeactivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(oid *)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalDeactivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm1stAndIntervalDeactivate;
		tmplen = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
		memdup((void *) &StorageTmp->mtpOm1stAndIntervalDeactivate, var_val, var_val_len);
		StorageTmp->mtpOm1stAndIntervalDeactivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpOm1stAndIntervalDeactivate);
		StorageTmp->mtpOm1stAndIntervalDeactivate = tmpvar;
		StorageTmp->mtpOm1stAndIntervalDeactivateLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm5MinActivate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(oid *)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm5MinActivate;
		tmplen = StorageTmp->mtpOm5MinActivateLen;
		memdup((void *) &StorageTmp->mtpOm5MinActivate, var_val, var_val_len);
		StorageTmp->mtpOm5MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpOm5MinActivate);
		StorageTmp->mtpOm5MinActivate = tmpvar;
		StorageTmp->mtpOm5MinActivateLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm5MinDeaActivate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(oid *)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm5MinDeaActivate;
		tmplen = StorageTmp->mtpOm5MinDeaActivateLen;
		memdup((void *) &StorageTmp->mtpOm5MinDeaActivate, var_val, var_val_len);
		StorageTmp->mtpOm5MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpOm5MinDeaActivate);
		StorageTmp->mtpOm5MinDeaActivate = tmpvar;
		StorageTmp->mtpOm5MinDeaActivateLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm15MinActivate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(oid *)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm15MinActivate;
		tmplen = StorageTmp->mtpOm15MinActivateLen;
		memdup((void *) &StorageTmp->mtpOm15MinActivate, var_val, var_val_len);
		StorageTmp->mtpOm15MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpOm15MinActivate);
		StorageTmp->mtpOm15MinActivate = tmpvar;
		StorageTmp->mtpOm15MinActivateLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm15MinDeaActivate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(oid *)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm15MinDeaActivate;
		tmplen = StorageTmp->mtpOm15MinDeaActivateLen;
		memdup((void *) &StorageTmp->mtpOm15MinDeaActivate, var_val, var_val_len);
		StorageTmp->mtpOm15MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpOm15MinDeaActivate);
		StorageTmp->mtpOm15MinDeaActivate = tmpvar;
		StorageTmp->mtpOm15MinDeaActivateLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm5MinMaxIntervals(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..288 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm5MinMaxIntervals;
		StorageTmp->mtpOm5MinMaxIntervals = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinMaxIntervals = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpOm15MinMaxIntervals(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..672 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpOm15MinMaxIntervals;
		StorageTmp->mtpOm15MinMaxIntervals = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinMaxIntervals = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpSiStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpSiTable_data *StorageTmp = NULL;
	static struct mtpSpSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpSiTableStorage, NULL, &name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpSiStatus;
			StorageTmp->mtpSpSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpSiStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyTable_data *StorageTmp = NULL;
	static struct mtpSpStudyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyTableStorage, NULL, &name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);
			StorageNew->mtpSpStudyId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyStatus;
			StorageTmp->mtpSpStudyStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyMapStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyMapTable_data *StorageTmp = NULL;
	static struct mtpSpStudyMapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyMapTableStorage, NULL, &name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyMapStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpOpcRsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpDpcRsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpStudyId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOpcRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpDpcRsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyMapStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyMapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyMapStatus;
			StorageTmp->mtpSpStudyMapStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyMapTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyMapStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyMapStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyMapStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static struct mtpRsSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);
			StorageNew->mtpRsSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsSiStatus;
			StorageTmp->mtpRsSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsSiStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
