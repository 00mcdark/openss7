/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>

/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */

/* These are messed up on both. */
#include "ds_agent.h"

#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */

#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */

/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */

#include "mtpMIB2_openss7.h"

#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */

#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>

#ifdef _GNU_SOURCE
#include <getopt.h>
#endif

static const char sa_program[] = "mtpmib2";

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))

#if !defined MODULE
static int sa_dump = 0;			/* default packet dump */
static int sa_debug = 0;		/* default no debug */
static int sa_nomead = 1;		/* default daemon mode */
static int sa_output = 1;		/* default normal output */
static int sa_agentx = 1;		/* default agentx mode */
static int sa_alarms = 1;		/* default application alarms */
static int sa_fclose = 1;		/* default close files between requests */

static int sa_logaddr = 0;		/* log addresses */
static int sa_logfillog = 0;		/* log to sa_logfile */
static int sa_logstderr = 0;		/* log to standard error */
static int sa_logstdout = 0;		/* log to standard output */
static int sa_logsyslog = 0;		/* log to system logs */
static int sa_logcallog = 0;		/* log to callback logs */
static int sa_appendlog = 0;		/* append to log file without truncating */

static char sa_logfile[256] = "/var/log/mtpmib2.log";
static char sa_pidfile[256] = "/var/run/mtpmib2.pid";
static char sa_sysctlf[256] = "/etc/mtpmib2.conf";

int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
static FILE *stdlog = NULL;

/* file descriptor for MIB use */
static int sa_fd = 0;

/* indication to reread MIB configuration */
static int sa_changed = 1;

/* indications that statistics, the mib or its tables need to be refreshed */
static int sa_stats_refresh = 1;
#endif				/* !defined MODULE */

/* request number for per-request actions */
static int sa_request = 1;

static volatile int mtpMIB2_refresh = 1;
static volatile int mtpMtTable_refresh = 1;
static volatile int mtpMsTable_refresh = 1;
static volatile int mtpNaProfileTable_refresh = 1;
static volatile int mtpNaTable_refresh = 1;
static volatile int mtpGsTable_refresh = 1;
static volatile int mtpGsListTable_refresh = 1;
static volatile int mtpGsRuleTable_refresh = 1;
static volatile int mtpSpProfileTable_refresh = 1;
static volatile int mtpSpTable_refresh = 1;
static volatile int mtpSpCurrentTable_refresh = 1;
static volatile int mtpSpInt5minTable_refresh = 1;
static volatile int mtpSpInt15minTable_refresh = 1;
static volatile int mtpSpSiTable_refresh = 1;
static volatile int mtpSpSiInt5minTable_refresh = 1;
static volatile int mtpSpSiInt15minTable_refresh = 1;
static volatile int mtpSpStudyTable_refresh = 1;
static volatile int mtpSpStudyInt5minTable_refresh = 1;
static volatile int mtpSpStudyInt15minTable_refresh = 1;
static volatile int mtpSpStudyMapTable_refresh = 1;
static volatile int mtpRsProfileTable_refresh = 1;
static volatile int mtpRsTable_refresh = 1;
static volatile int mtpRsCurrentTable_refresh = 1;
static volatile int mtpRsInt5minTable_refresh = 1;
static volatile int mtpRsInt15minTable_refresh = 1;
static volatile int mtpRsSiTable_refresh = 1;
static volatile int mtpRsSiInt5minTable_refresh = 1;
static volatile int mtpRsSiInt15minTable_refresh = 1;
static volatile int mtpRlTable_refresh = 1;
static volatile int mtpRtProfileTable_refresh = 1;
static volatile int mtpRtTable_refresh = 1;
static volatile int mtpLsTable_refresh = 1;
static volatile int mtpLkProfileTable_refresh = 1;
static volatile int mtpLkTable_refresh = 1;
static volatile int mtpLkCurrentTable_refresh = 1;
static volatile int mtpLkInt5minTable_refresh = 1;
static volatile int mtpLkInt15minTable_refresh = 1;
static volatile int mtpSlProfileTable_refresh = 1;
static volatile int mtpSlTable_refresh = 1;
static volatile int mtpSlSdlListTable_refresh = 1;
static volatile int mtpSlSdtListTable_refresh = 1;
static volatile int mtpSlCurrentTable_refresh = 1;
static volatile int mtpSlInt5minTable_refresh = 1;
static volatile int mtpSlInt15minTable_refresh = 1;
static volatile int mtpL2ProfileTable_refresh = 1;
static volatile int mtpNbandTable_refresh = 1;
static volatile int mtpSaalTable_refresh = 1;
static volatile int mtpM2paTable_refresh = 1;
static volatile int mtpL2Table_refresh = 1;
static volatile int mtpL2CurrentTable_refresh = 1;
static volatile int mtpL2Int5minTable_refresh = 1;
static volatile int mtpL2Int15minTable_refresh = 1;
static volatile int mtpSdtTable_refresh = 1;
static volatile int mtpSdlTable_refresh = 1;

/* 
 * mtpMIB2_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid mtpMIB2_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1 };
oid mtpMtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 1, 1, 1 };
oid mtpMsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 2, 1, 1 };
oid mtpNaProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 2, 1 };
oid mtpNaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 4, 1 };
oid mtpGsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 1, 1 };
oid mtpGsListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 2, 1 };
oid mtpGsRuleTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 3, 1 };
oid mtpSpProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 2, 1 };
oid mtpSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 4, 1 };
oid mtpSpSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 8, 1 };
oid mtpSpStudyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 11, 1 };
oid mtpSpStudyMapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 14, 1 };
oid mtpRsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 2, 1 };
oid mtpRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 3, 1 };
oid mtpRsSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 7, 1 };
oid mtpRlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 7, 1, 1 };
oid mtpRtProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 2, 1 };
oid mtpRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 3, 1 };
oid mtpLsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 1, 1 };
oid mtpLkProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 2, 1 };
oid mtpLkTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 3, 1 };
oid mtpSlProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 2, 2 };
oid mtpSlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 3, 1 };
oid mtpSlSdlListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 4, 1 };
oid mtpSlSdtListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 5, 1 };
oid mtpL2ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 2, 1 };
oid mtpNbandTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 3, 1 };
oid mtpSaalTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 4, 1 };
oid mtpM2paTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 5, 1 };
oid mtpL2Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 6, 1 };
oid mtpSdtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 1, 1 };
oid mtpSdlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 14, 1, 1 };

/* 
 * variable7 mtpMIB2_variables:
 *   this variable defines function callbacks and type return information 
 *   for the mtpMIB2 mib section 
 */

struct variable7 mtpMIB2_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   MTPMTNAME             5
	{MTPMTNAME, ASN_OCTET_STR, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPMTSPINDEX          6
	{MTPMTSPINDEX, ASN_UNSIGNED, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPMTUSERPART         7
	{MTPMTUSERPART, ASN_INTEGER, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPMTUSERPARTSTATUS   8
	{MTPMTUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPMTUSAGESTATE       9
	{MTPMTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPMTALARMSEVERITYASSIGNMENT  10
	{MTPMTALARMSEVERITYASSIGNMENT, ASN_OBJECT_ID, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPMTLONGMESSAGESUPPORTED  11
	{MTPMTLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPMTSTATUS           12
	{MTPMTSTATUS, ASN_INTEGER, RWRITE, var_mtpMtTable, 6, {1, 1, 1, 1, 1, 9}},
#define   MTPMSNAME             16
	{MTPMSNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPMSALARMSTATUS      17
	{MTPMSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPMSOPERATIONALSTATE  18
	{MTPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPMSUSAGESTATE       19
	{MTPMSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPMSMANAGEDELEMENTTYPE  20
	{MTPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPMSMODELCODE        21
	{MTPMSMODELCODE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPMSVENDORNAME       22
	{MTPMSVENDORNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPMSUSERLABEL        23
	{MTPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 9}},
#define   MTPMSVERSION          24
	{MTPMSVERSION, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 10}},
#define   MTPMSALARMSEVERITYASSIGNMENT  25
	{MTPMSALARMSEVERITYASSIGNMENT, ASN_OBJECT_ID, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 11}},
#define   MTPMSNETWORKELEMENTALIASES  26
	{MTPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 12}},
#define   MTPMSSTATUS           27
	{MTPMSSTATUS, ASN_INTEGER, RWRITE, var_mtpMsTable, 6, {1, 1, 2, 1, 1, 13}},
#define   MTPNAPROFILENEXTINDEX  28
	{MTPNAPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 3, 1}},
#define   MTPNAPROFILENAME      32
	{MTPNAPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 2}},
#define   MTPNAPROTOCOLVARIANT  33
	{MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 3}},
#define   MTPNAPROTOCOLYEAR     34
	{MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 4}},
#define   MTPNAPROTOCOLOPTIONS  35
	{MTPNAPROTOCOLOPTIONS, ASN_BIT_STR, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 5}},
#define   MTPNANETWORKINDICATOR  36
	{MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 6}},
#define   MTPNAPOINTCODEFORMAT  37
	{MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 8}},
#define   MTPNAPOINTCODEFORMAT  38
	{MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 8}},
#define   MTPNAPROFILESTATUS    39
	{MTPNAPROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpNaProfileTable, 6, {1, 1, 3, 2, 1, 9}},
#define   MTPNANEXTINDEX        40
	{MTPNANEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 3, 3}},
#define   MTPNANAME             44
	{MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 4, 1, 2}},
#define   MTPNAPROFILE          45
	{MTPNAPROFILE, ASN_UNSIGNED, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 4, 1, 3}},
#define   MTPNASPDEFAULT        46
	{MTPNASPDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 4, 1, 4}},
#define   MTPNASTATUS           47
	{MTPNASTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 3, 4, 1, 5}},
#define   MTPGSNAME             52
	{MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPGSADMINISTRATIVESTATE  53
	{MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  54
	{MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPGSLISTMODE         55
	{MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  56
	{MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  57
	{MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPGSSTATUS           58
	{MTPGSSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPGSLISTOBJECT       64
	{MTPGSLISTOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpGsListTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPGSLISTCONTENT      65
	{MTPGSLISTCONTENT, ASN_UNSIGNED, RWRITE, var_mtpGsListTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPGSLISTSTATUS       66
	{MTPGSLISTSTATUS, ASN_INTEGER, RWRITE, var_mtpGsListTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPGSRULEDESIGNATEDDPCFIRST  73
	{MTPGSRULEDESIGNATEDDPCFIRST, ASN_OCTET_STR, RWRITE, var_mtpGsRuleTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPGSRULEDESIGNATEDDPCLAST  74
	{MTPGSRULEDESIGNATEDDPCLAST, ASN_OCTET_STR, RWRITE, var_mtpGsRuleTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPGSRULESIMASK       75
	{MTPGSRULESIMASK, ASN_BIT_STR, RWRITE, var_mtpGsRuleTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPGSRULEMESSAGETREATMENT  76
	{MTPGSRULEMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsRuleTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPGSRULECOMMENT      77
	{MTPGSRULECOMMENT, ASN_OCTET_STR, RWRITE, var_mtpGsRuleTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPGSRULESTATUS       78
	{MTPGSRULESTATUS, ASN_INTEGER, RWRITE, var_mtpGsRuleTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPSPPROFILENEXTINDEX  79
	{MTPSPPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 5, 1}},
#define   MTPSPPROFILENAME      83
	{MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 2}},
#define   MTPSPPROFILETIMERT1R  84
	{MTPSPPROFILETIMERT1R, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 3}},
#define   MTPSPPROFILETIMERT18  85
	{MTPSPPROFILETIMERT18, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 4}},
#define   MTPSPPROFILETIMERT20  86
	{MTPSPPROFILETIMERT20, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 5}},
#define   MTPSPPROFILETIMERT22A  87
	{MTPSPPROFILETIMERT22A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 6}},
#define   MTPSPPROFILETIMERT23A  88
	{MTPSPPROFILETIMERT23A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 7}},
#define   MTPSPPROFILETIMERT24A  89
	{MTPSPPROFILETIMERT24A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 8}},
#define   MTPSPPROFILETIMERT26A  90
	{MTPSPPROFILETIMERT26A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 9}},
#define   MTPSPPROFILETIMERT27A  91
	{MTPSPPROFILETIMERT27A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 10}},
#define   MTPSPPROFILERSDEFAULT  92
	{MTPSPPROFILERSDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 11}},
#define   MTPSPPROFILELKDEFAULT  93
	{MTPSPPROFILELKDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 12}},
#define   MTPSPPROFILESTATUS    94
	{MTPSPPROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 5, 2, 1, 13}},
#define   MTPSPNEXTINDEX        95
	{MTPSPNEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 5, 3}},
#define   MTPSPNAME             99
	{MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 2}},
#define   MTPSPMSINDEX          100
	{MTPSPMSINDEX, ASN_UNSIGNED, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 3}},
#define   MTPSPNAINDEX          101
	{MTPSPNAINDEX, ASN_UNSIGNED, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 4}},
#define   MTPSPPROFILE          102
	{MTPSPPROFILE, ASN_UNSIGNED, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 5}},
#define   MTPSPRSDEFAULT        103
	{MTPSPRSDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 6}},
#define   MTPSPLKDEFAULT        104
	{MTPSPLKDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 7}},
#define   MTPSPPOINTCODE        105
	{MTPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 8}},
#define   MTPSPTYPE             106
	{MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 9}},
#define   MTPSPFLAGS            107
	{MTPSPFLAGS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 10}},
#define   MTPSPUSERS            108
	{MTPSPUSERS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 11}},
#define   MTPSPOPERATIONALSTATE  109
	{MTPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 12}},
#define   MTPSPPROCEDURALSTATUS  110
	{MTPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 13}},
#define   MTPSPAVAILABILITYSTATUS  111
	{MTPSPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 14}},
#define   MTPSPALARMSTATUS      112
	{MTPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 15}},
#define   MTPSPSTATUS           113
	{MTPSPSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 5, 4, 1, 16}},
#define   MTPSPCURRENTVALIDINTERVALS  117
	{MTPSPCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 1}},
#define   MTPSPCURRENTTIMEDISCONTINUITY  118
	{MTPSPCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 2}},
#define   MTPSPCURRENTDISCARDEDMSUS  119
	{MTPSPCURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 3}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS0  120
	{MTPSPCURRENTRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 4}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS1  121
	{MTPSPCURRENTRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 5}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS2  122
	{MTPSPCURRENTRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 6}},
#define   MTPSPCURRENTOCTETSXFERRED  123
	{MTPSPCURRENTOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 5, 5, 1, 7}},
#define   MTPSPINT5MINTIMESTAMP  128
	{MTPSPINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 5, 6, 1, 2}},
#define   MTPSPINT5MINDISCARDEDMSUS  129
	{MTPSPINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 5, 6, 1, 3}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS0  130
	{MTPSPINT5MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 5, 6, 1, 4}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS1  131
	{MTPSPINT5MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 5, 6, 1, 5}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS2  132
	{MTPSPINT5MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 5, 6, 1, 6}},
#define   MTPSPINT5MINOCTETSXFERRED  133
	{MTPSPINT5MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 5, 6, 1, 7}},
#define   MTPSPINT15MINTIMESTAMP  138
	{MTPSPINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 5, 7, 1, 2}},
#define   MTPSPINT15MINDISCARDEDMSUS  139
	{MTPSPINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 5, 7, 1, 3}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS0  140
	{MTPSPINT15MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 5, 7, 1, 4}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS1  141
	{MTPSPINT15MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 5, 7, 1, 5}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS2  142
	{MTPSPINT15MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 5, 7, 1, 6}},
#define   MTPSPINT15MINOCTETSXFERRED  143
	{MTPSPINT15MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 5, 7, 1, 7}},
#define   MTPSPSIVALIDINTERVALS  148
	{MTPSPSIVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpSiTable, 6, {1, 1, 5, 8, 1, 2}},
#define   MTPSPSITIMEDISCONTINUITY  149
	{MTPSPSITIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpSiTable, 6, {1, 1, 5, 8, 1, 3}},
#define   MTPSPSITRANSMITTEDUPUNAVAILABLE  150
	{MTPSPSITRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 5, 8, 1, 4}},
#define   MTPSPSIRECEIVEDUPUNAVAILABLE  151
	{MTPSPSIRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 5, 8, 1, 5}},
#define   MTPSPSIHANDLEDOCTETSSIO  152
	{MTPSPSIHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 5, 8, 1, 6}},
#define   MTPSPSISTATUS         153
	{MTPSPSISTATUS, ASN_INTEGER, RWRITE, var_mtpSpSiTable, 6, {1, 1, 5, 8, 1, 7}},
#define   MTPSPSIINT5MINTIMESTAMP  159
	{MTPSPSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 5, 9, 1, 2}},
#define   MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE  160
	{MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 5, 9, 1, 3}},
#define   MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE  161
	{MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 5, 9, 1, 4}},
#define   MTPSPSIINT5MINHANDLEDOCTETSSIO  162
	{MTPSPSIINT5MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 5, 9, 1, 5}},
#define   MTPSPSIINT15MINTIMESTAMP  168
	{MTPSPSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 5, 10, 1, 2}},
#define   MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE  169
	{MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 5, 10, 1, 3}},
#define   MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE  170
	{MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 5, 10, 1, 4}},
#define   MTPSPSIINT15MINHANDLEDOCTETSSIO  171
	{MTPSPSIINT15MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 5, 10, 1, 5}},
#define   MTPSPSTUDYVALIDINTERVALS  175
	{MTPSPSTUDYVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpStudyTable, 6, {1, 1, 5, 11, 1, 2}},
#define   MTPSPSTUDYTIMEDISCONTINUITY  176
	{MTPSPSTUDYTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpStudyTable, 6, {1, 1, 5, 11, 1, 3}},
#define   MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO  177
	{MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 5, 11, 1, 4}},
#define   MTPSPSTUDYHANDLEDMSUSOPCDPCSIO  178
	{MTPSPSTUDYHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 5, 11, 1, 5}},
#define   MTPSPSTUDYSTATUS      179
	{MTPSPSTUDYSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyTable, 6, {1, 1, 5, 11, 1, 6}},
#define   MTPSPSTUDYINT5MINTIMESTAMP  184
	{MTPSPSTUDYINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 5, 12, 1, 2}},
#define   MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO  185
	{MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 5, 12, 1, 3}},
#define   MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO  186
	{MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 5, 12, 1, 4}},
#define   MTPSPSTUDYINT15MININTERVAL  191
	{MTPSPSTUDYINT15MININTERVAL, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 5, 13, 1, 2}},
#define   MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO  192
	{MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 5, 13, 1, 3}},
#define   MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO  193
	{MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 5, 13, 1, 4}},
#define   MTPSPSTUDYMAPSTATUS   201
	{MTPSPSTUDYMAPSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyMapTable, 6, {1, 1, 5, 14, 1, 1}},
#define   MTPRSPROFILENEXTINDEX  202
	{MTPRSPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 6, 1}},
#define   MTPRSPROFILENAME      206
	{MTPRSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 2}},
#define   MTPRSPROFILETIMERT8   207
	{MTPRSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 3}},
#define   MTPRSPROFILETIMERT11  208
	{MTPRSPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 4}},
#define   MTPRSPROFILETIMERT15  209
	{MTPRSPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 5}},
#define   MTPRSPROFILETIMERT16  210
	{MTPRSPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 6}},
#define   MTPRSPROFILETIMERT18A  211
	{MTPRSPROFILETIMERT18A, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 7}},
#define   MTPRSPROFILERTDEFAULT  212
	{MTPRSPROFILERTDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 8}},
#define   MTPRSPROFILESTATUS    213
	{MTPRSPROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 6, 2, 1, 9}},
#define   MTPRSNAME             217
	{MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 2}},
#define   MTPRSPROFILE          218
	{MTPRSPROFILE, ASN_UNSIGNED, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 3}},
#define   MTPRSRTDEFAULT        219
	{MTPRSRTDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 4}},
#define   MTPRSADMINISTRATIVESTATE  220
	{MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 5}},
#define   MTPRSOPERATIONALSTATE  221
	{MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 6}},
#define   MTPRSALARMSEVERITYASSIGNMENT  222
	{MTPRSALARMSEVERITYASSIGNMENT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 7}},
#define   MTPRSCONGSTATE        223
	{MTPRSCONGSTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 8}},
#define   MTPRSCONGLEVEL        224
	{MTPRSCONGLEVEL, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 9}},
#define   MTPRSLOADSHARINGINFORMATION  225
	{MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 10}},
#define   MTPRSLOADSHARINGOBJECT  226
	{MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 11}},
#define   MTPRSREMOTEEXCHANGELABEL  227
	{MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 12}},
#define   MTPRSALARMSTATUS      228
	{MTPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 13}},
#define   MTPRSSTATUS           229
	{MTPRSSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 6, 3, 1, 14}},
#define   MTPRSCURRENTVALIDINTERVALS  233
	{MTPRSCURRENTVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 1}},
#define   MTPRSCURRENTTIMEDISCONTINUITY  234
	{MTPRSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 2}},
#define   MTPRSCURRENTRECEIVEDOCTETSOPC  235
	{MTPRSCURRENTRECEIVEDOCTETSOPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 3}},
#define   MTPRSCURRENTTRANSMITTEDOCTETSDPC  236
	{MTPRSCURRENTTRANSMITTEDOCTETSDPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 4}},
#define   MTPRSCURRENTRECEIVEDMSUSOPC  237
	{MTPRSCURRENTRECEIVEDMSUSOPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 5}},
#define   MTPRSCURRENTTRANSMITTEDMSUSDPC  238
	{MTPRSCURRENTTRANSMITTEDMSUSDPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 6}},
#define   MTPRSCURRENTROUTESETUNAVAILABLE  239
	{MTPRSCURRENTROUTESETUNAVAILABLE, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 7}},
#define   MTPRSCURRENTROUTESETUNAVAILABLEDURATION  240
	{MTPRSCURRENTROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 6, 4, 1, 8}},
#define   MTPRSINT5MINTIMESTAMP  245
	{MTPRSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 2}},
#define   MTPRSINT5MINRECEIVEDOCTETSOPC  246
	{MTPRSINT5MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 3}},
#define   MTPRSINT5MINTRANSMITTEDOCTETSDPC  247
	{MTPRSINT5MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 4}},
#define   MTPRSINT5MINRECEIVEDMSUSOPC  248
	{MTPRSINT5MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 5}},
#define   MTPRSINT5MINTRANSMITTEDMSUSDPC  249
	{MTPRSINT5MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 6}},
#define   MTPRSINT5MINROUTESETUNAVAILABLE  250
	{MTPRSINT5MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 7}},
#define   MTPRSINT5MINROUTESETUNAVAILABLEDURATION  251
	{MTPRSINT5MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 6, 5, 1, 8}},
#define   MTPRSINT15MINTIMESTAMP  256
	{MTPRSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 2}},
#define   MTPRSINT15MINRECEIVEDOCTETSOPC  257
	{MTPRSINT15MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 3}},
#define   MTPRSINT15MINTRANSMITTEDOCTETSDPC  258
	{MTPRSINT15MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 4}},
#define   MTPRSINT15MINRECEIVEDMSUSOPC  259
	{MTPRSINT15MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 5}},
#define   MTPRSINT15MINTRANSMITTEDMSUSDPC  260
	{MTPRSINT15MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 6}},
#define   MTPRSINT15MINROUTESETUNAVAILABLE  261
	{MTPRSINT15MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 7}},
#define   MTPRSINT15MINROUTESETUNAVAILABLEDURATION  262
	{MTPRSINT15MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 6, 6, 1, 8}},
#define   MTPRSSIVALIDINTERVALS  266
	{MTPRSSIVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 2}},
#define   MTPRSSITIMEDISCONTINUITY  267
	{MTPRSSITIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 3}},
#define   MTPRSSIRECEIVEDOCTETSOPCSIO  268
	{MTPRSSIRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 4}},
#define   MTPRSSITRANSMITTEDOCTETSDPCSIO  269
	{MTPRSSITRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 5}},
#define   MTPRSSIRECEIVEDMSUSOPCSIO  270
	{MTPRSSIRECEIVEDMSUSOPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 6}},
#define   MTPRSSITRANSMITTEDMSUSDPCSIO  271
	{MTPRSSITRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 7}},
#define   MTPRSSISTATUS         272
	{MTPRSSISTATUS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 6, 7, 1, 8}},
#define   MTPRSSIINT5MINTIMESTAMP  277
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 8, 1, 3}},
#define   MTPRSSIINT5MINTIMESTAMP  278
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 8, 1, 3}},
#define   MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO  279
	{MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 8, 1, 4}},
#define   MTPRSSIINT5MINRECEIVEDMSUSOPCSIO  280
	{MTPRSSIINT5MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 8, 1, 5}},
#define   MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO  281
	{MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 6, 8, 1, 6}},
#define   MTPRSSIINT15MINTIMESTAMP  286
	{MTPRSSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 9, 1, 2}},
#define   MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO  287
	{MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 9, 1, 3}},
#define   MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO  288
	{MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 9, 1, 4}},
#define   MTPRSSIINT15MINRECEIVEDMSUSOPCSIO  289
	{MTPRSSIINT15MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 9, 1, 5}},
#define   MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO  290
	{MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 6, 9, 1, 6}},
#define   MTPRLPROFILE          294
	{MTPRLPROFILE, ASN_UNSIGNED, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPRLRTDEFAULT        295
	{MTPRLRTDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPRLRSINDEX          296
	{MTPRLRSINDEX, ASN_UNSIGNED, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPRLLSINDEX          297
	{MTPRLLSINDEX, ASN_UNSIGNED, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPRLRSCOST           298
	{MTPRLRSCOST, ASN_UNSIGNED, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPRLADMINISTRATIVESTATE  299
	{MTPRLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPRLOPERATIONALSTATE  300
	{MTPRLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRLCONGSTATE        301
	{MTPRLCONGSTATE, ASN_INTEGER, RONLY, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 9}},
#define   MTPRLCONGLEVEL        302
	{MTPRLCONGLEVEL, ASN_INTEGER, RONLY, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 10}},
#define   MTPRLSTATUS           303
	{MTPRLSTATUS, ASN_INTEGER, RWRITE, var_mtpRlTable, 6, {1, 1, 7, 1, 1, 11}},
#define   MTPRTPROFILENEXTINDEX  304
	{MTPRTPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 8, 1}},
#define   MTPRTPROFILENAME      308
	{MTPRTPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPRTPROFILETIMERT6   309
	{MTPRTPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPRTPROFILETIMERT10  310
	{MTPRTPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPRTPROFILESTATUS    311
	{MTPRTPROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPRTNAME             315
	{MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 2}},
#define   MTPRTPROFILE          316
	{MTPRTPROFILE, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 3}},
#define   MTPRTRLINDEX          317
	{MTPRTRLINDEX, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 4}},
#define   MTPRTLKINDEX          318
	{MTPRTLKINDEX, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 5}},
#define   MTPRTRLSLOT           319
	{MTPRTRLSLOT, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 6}},
#define   MTPRTADMINISTRATIVESTATE  320
	{MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 7}},
#define   MTPRTOPERATIONALSTATE  321
	{MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 8}},
#define   MTPRTAVAILABILITYSTATUS  322
	{MTPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 9}},
#define   MTPRTUSAGESTATE       323
	{MTPRTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 10}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  324
	{MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 11}},
#define   MTPRTFIXEDPRIORITY    325
	{MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 12}},
#define   MTPRTFLEXIBLEPRIORITY  326
	{MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 13}},
#define   MTPRTPRIORITYMODE     327
	{MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 14}},
#define   MTPRTLOADSHARINGINFORMATION  328
	{MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 15}},
#define   MTPRTLOADSHARINGOBJECT  329
	{MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 16}},
#define   MTPRTSLSLIST          330
	{MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 17}},
#define   MTPRTSTATUS           331
	{MTPRTSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 3, 1, 18}},
#define   MTPLSNAME             335
	{MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPLSLKDEFAULT        336
	{MTPLSLKDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPLSADMINISTRATIVESTATE  337
	{MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPLSOPERATIONALSTATE  338
	{MTPLSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 5}},
#define   MTPLSAVAILABILITYSTATUS  339
	{MTPLSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 6}},
#define   MTPLSUSAGESTATE       340
	{MTPLSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 7}},
#define   MTPLSADJPC            341
	{MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 8}},
#define   MTPLSMAXCAPACITY      342
	{MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 9}},
#define   MTPLSCURRENTCAPACITY  343
	{MTPLSCURRENTCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 10}},
#define   MTPLSCONGESTIONCONTROLMETHOD  344
	{MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 11}},
#define   MTPLSPERIODICLINKTESTFLAG  345
	{MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 12}},
#define   MTPLSINLSLOADSHAREALGORITHM  346
	{MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 13}},
#define   MTPLSNUMNORMACTSLS    347
	{MTPLSNUMNORMACTSLS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 14}},
#define   MTPLSALARMSEVERITYASSIGNMENT  348
	{MTPLSALARMSEVERITYASSIGNMENT, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 15}},
#define   MTPLSALARMSTATUS      349
	{MTPLSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 16}},
#define   MTPLSSTATUS           350
	{MTPLSSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 1, 1, 17}},
#define   MTPLKPROFILENEXTINDEX  351
	{MTPLKPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 10, 1}},
#define   MTPLKPROFILETIMERT7   355
	{MTPLKPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 2}},
#define   MTPLKPROFILETIMERT19  356
	{MTPLKPROFILETIMERT19, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 3}},
#define   MTPLKPROFILETIMERT21  357
	{MTPLKPROFILETIMERT21, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 4}},
#define   MTPLKPROFILETIMERT25A  358
	{MTPLKPROFILETIMERT25A, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 5}},
#define   MTPLKPROFILETIMERT28A  359
	{MTPLKPROFILETIMERT28A, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 6}},
#define   MTPLKPROFILETIMERT29A  360
	{MTPLKPROFILETIMERT29A, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 7}},
#define   MTPLKPROFILETIMERT30A  361
	{MTPLKPROFILETIMERT30A, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 8}},
#define   MTPLKPROFILESLDEFAULT  362
	{MTPLKPROFILESLDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 9}},
#define   MTPLKPROFILESTATUS    363
	{MTPLKPROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpLkProfileTable, 6, {1, 1, 10, 2, 1, 10}},
#define   MTPLKNAME             367
	{MTPLKNAME, ASN_OCTET_STR, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 2}},
#define   MTPLKPROFILE          368
	{MTPLKPROFILE, ASN_UNSIGNED, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 3}},
#define   MTPLKSLDEFAULT        369
	{MTPLKSLDEFAULT, ASN_UNSIGNED, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 4}},
#define   MTPLKLSINDEX          370
	{MTPLKLSINDEX, ASN_UNSIGNED, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 5}},
#define   MTPLKRSINDEX          371
	{MTPLKRSINDEX, ASN_UNSIGNED, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 6}},
#define   MTPLKADJPC            372
	{MTPLKADJPC, ASN_OCTET_STR, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 7}},
#define   MTPLKMAXCAPACITY      373
	{MTPLKMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 8}},
#define   MTPLKCURRENTCAPACITY  374
	{MTPLKCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 9}},
#define   MTPLKCONGESTIONCONTROLMETHOD  375
	{MTPLKCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 10}},
#define   MTPLKUSAGESTATE       376
	{MTPLKUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 11}},
#define   MTPLKOPERATIONALSTATE  377
	{MTPLKOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 12}},
#define   MTPLKAVAILABILITYSTATUS  378
	{MTPLKAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 13}},
#define   MTPLKPERIODICLINKTESTFLAG  379
	{MTPLKPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 14}},
#define   MTPLKPERIODICLINKTESTFAIL  380
	{MTPLKPERIODICLINKTESTFAIL, ASN_INTEGER, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 15}},
#define   MTPLKADMINISTRATIVESTATE  381
	{MTPLKADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 16}},
#define   MTPLKINLSLOADSHARINGALGORITHM  382
	{MTPLKINLSLOADSHARINGALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 17}},
#define   MTPLKNUMBEROFNORMALLYACTIVESIGNLINKS  383
	{MTPLKNUMBEROFNORMALLYACTIVESIGNLINKS, ASN_UNSIGNED, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 18}},
#define   MTPLKALARMSTATUS      384
	{MTPLKALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 19}},
#define   MTPLKALARMSEVERITYASSIGNEMNT  385
	{MTPLKALARMSEVERITYASSIGNEMNT, ASN_OBJECT_ID, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 20}},
#define   MTPLKSTATUS           386
	{MTPLKSTATUS, ASN_INTEGER, RWRITE, var_mtpLkTable, 6, {1, 1, 10, 3, 1, 21}},
#define   MTPLKCURRENTVALIDINTERVALS  390
	{MTPLKCURRENTVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpLkCurrentTable, 6, {1, 1, 10, 4, 1, 1}},
#define   MTPLKCURRENTTIMEDISCONTINUITY  391
	{MTPLKCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpLkCurrentTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPLKCURRENTADJACENTINACCESSIBLEEVENTS  392
	{MTPLKCURRENTADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RWRITE, var_mtpLkCurrentTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPLKCURRENTADJACENTINACCESSIBLEDURATION  393
	{MTPLKCURRENTADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RWRITE, var_mtpLkCurrentTable, 6, {1, 1, 10, 4, 1, 4}},
#define   MTPLKCURRENTSLSUNAVAILABLE  394
	{MTPLKCURRENTSLSUNAVAILABLE, ASN_GAUGE, RWRITE, var_mtpLkCurrentTable, 6, {1, 1, 10, 4, 1, 5}},
#define   MTPLKINT15MINTIMESTAMP  407
	{MTPLKINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpLkInt15minTable, 6, {1, 1, 10, 6, 1, 2}},
#define   MTPLKINT15MINADJACENTINACCESSIBLEEVENTS  408
	{MTPLKINT15MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpLkInt15minTable, 6, {1, 1, 10, 6, 1, 3}},
#define   MTPLKINT15MINADJACENTINACCESSIBLEDURATION  409
	{MTPLKINT15MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpLkInt15minTable, 6, {1, 1, 10, 6, 1, 4}},
#define   MTPLKINT15MINSLSUNAVAILABLE  410
	{MTPLKINT15MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpLkInt15minTable, 6, {1, 1, 10, 6, 1, 5}},
#define   MTPSLPROFILENEXTINDEX  411
	{MTPSLPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 11, 1}},
#define   MTPSLPROFILENAME      415
	{MTPSLPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 2}},
#define   MTPSLPROFILETIMERT1   416
	{MTPSLPROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 3}},
#define   MTPSLPROFILETIMERT2   417
	{MTPSLPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 4}},
#define   MTPSLPROFILETIMERT3   418
	{MTPSLPROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 5}},
#define   MTPSLPROFILETIMERT4   419
	{MTPSLPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 6}},
#define   MTPSLPROFILETIMERT5   420
	{MTPSLPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 7}},
#define   MTPSLPROFILETIMERT12  421
	{MTPSLPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 8}},
#define   MTPSLPROFILETIMERT13  422
	{MTPSLPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 9}},
#define   MTPSLPROFILETIMERT14  423
	{MTPSLPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 10}},
#define   MTPSLPROFILETIMERT17  424
	{MTPSLPROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 11}},
#define   MTPSLPROFILETIMERT19A  425
	{MTPSLPROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 12}},
#define   MTPSLPROFILETIMERT20A  426
	{MTPSLPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 13}},
#define   MTPSLPROFILETIMERT21A  427
	{MTPSLPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 14}},
#define   MTPSLPROFILETIMERT22  428
	{MTPSLPROFILETIMERT22, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 15}},
#define   MTPSLPROFILETIMERT23  429
	{MTPSLPROFILETIMERT23, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 16}},
#define   MTPSLPROFILETIMERT24  430
	{MTPSLPROFILETIMERT24, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 17}},
#define   MTPSLPROFILETIMERT31A  431
	{MTPSLPROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 18}},
#define   MTPSLPROFILETIMERT32A  432
	{MTPSLPROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 19}},
#define   MTPSLPROFILETIMERT33A  433
	{MTPSLPROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 20}},
#define   MTPSLPROFILETIMERT34A  434
	{MTPSLPROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 21}},
#define   MTPSLPROFILETIMERT1T  435
	{MTPSLPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 22}},
#define   MTPSLPROFILETIMERT2T  436
	{MTPSLPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 23}},
#define   MTPSLPROFILETIMERT1S  437
	{MTPSLPROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 24}},
#define   MTPSLPROFILEL2DEFAULT  438
	{MTPSLPROFILEL2DEFAULT, ASN_UNSIGNED, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 25}},
#define   MTPSLPROFILESTATUS    439
	{MTPSLPROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpSlProfileTable, 6, {1, 1, 11, 2, 2, 26}},
#define   MTPSLNAME             443
	{MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 2}},
#define   MTPSLPROFILE          444
	{MTPSLPROFILE, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 3}},
#define   MTPSLL2DEFAULT        445
	{MTPSLL2DEFAULT, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 4}},
#define   MTPSLLKINDEX          446
	{MTPSLLKINDEX, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 5}},
#define   MTPSLCODE             447
	{MTPSLCODE, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPSLSLSCODECURRENTLIST  448
	{MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 7}},
#define   MTPSLMAXCAPACITY      449
	{MTPSLMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 8}},
#define   MTPSLCURRENTCAPACITY  450
	{MTPSLCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 9}},
#define   MTPSLLINKSTATUS       451
	{MTPSLLINKSTATUS, ASN_BIT_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 10}},
#define   MTPSLADMINISTRATIVESTATE  452
	{MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 11}},
#define   MTPSLOPERATIONALSTATE  453
	{MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 12}},
#define   MTPSLUSAGESTATE       454
	{MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 13}},
#define   MTPSLPROCEDURALSTATUS  455
	{MTPSLPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 14}},
#define   MTPSLLOCALINHIBIT     456
	{MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 15}},
#define   MTPSLLOCALUNINHIBIT   457
	{MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 16}},
#define   MTPSLREPLACEST        458
	{MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 17}},
#define   MTPSLALARMSEVERITYASSIGNMENT  459
	{MTPSLALARMSEVERITYASSIGNMENT, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 18}},
#define   MTPSLCONGESTIONLEVEL  460
	{MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 19}},
#define   MTPSLRELATEDLINKGROUPNUMBER  461
	{MTPSLRELATEDLINKGROUPNUMBER, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 20}},
#define   MTPSLSDLLIST          462
	{MTPSLSDLLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 21}},
#define   MTPSLSDTLIST          463
	{MTPSLSDTLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 22}},
#define   MTPSLTEST             464
	{MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 23}},
#define   MTPSLSLSCODENORMALLIST  465
	{MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 24}},
#define   MTPSLALARMSTATUS      466
	{MTPSLALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 25}},
#define   MTPSLSTATUS           467
	{MTPSLSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 26}},
#define   MTPSLCODE             472
	{MTPSLCODE, ASN_UNSIGNED, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPSLSDLLISTPOINTER   474
	{MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 11, 4, 1, 2}},
#define   MTPSLSDLLISTSTATUS    475
	{MTPSLSDLLISTSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 11, 4, 1, 3}},
#define   MTPSLCODE             480
	{MTPSLCODE, ASN_UNSIGNED, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPSLSDTLISTPOINTER   482
	{MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 11, 5, 1, 2}},
#define   MTPSLSDTLISTSTATUS    483
	{MTPSLSDTLISTSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 11, 5, 1, 3}},
#define   MTPSLCURRENTVALIDINTERVALS  487
	{MTPSLCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 1}},
#define   MTPSLCURRENTTIMEDISCONTINUITY  488
	{MTPSLCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 2}},
#define   MTPSLCURRENTSLUNAVAILABILITYDURATION  489
	{MTPSLCURRENTSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 3}},
#define   MTPSLCURRENTSLLOCALINHIBITION  490
	{MTPSLCURRENTSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 4}},
#define   MTPSLCURRENTSLREMOTEINHIBITION  491
	{MTPSLCURRENTSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 5}},
#define   MTPSLCURRENTSLFAILED  492
	{MTPSLCURRENTSLFAILED, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 6}},
#define   MTPSLCURRENTSLREMOTEPROCOUTAGE  493
	{MTPSLCURRENTSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 7}},
#define   MTPSLCURRENTLOCALMGMTINHIBIT  494
	{MTPSLCURRENTLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 8}},
#define   MTPSLCURRENTLOCALMGMTUNINHIBIT  495
	{MTPSLCURRENTLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 9}},
#define   MTPSLCURRENTLOCALBUSY  496
	{MTPSLCURRENTLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 10}},
#define   MTPSLCURRENTSLCONGESTEDSTARTS  497
	{MTPSLCURRENTSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 11}},
#define   MTPSLCURRENTSLCONGESTEDDURATION  498
	{MTPSLCURRENTSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 12}},
#define   MTPSLCURRENTSLCONGESTIONSTOPS  499
	{MTPSLCURRENTSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 13}},
#define   MTPSLCURRENTDISCARDEDMSUS  500
	{MTPSLCURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 14}},
#define   MTPSLCURRENTCONGESTIONEVENTSMSULOSS  501
	{MTPSLCURRENTCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 15}},
#define   MTPSLCURRENTCHANGEOVERS  502
	{MTPSLCURRENTCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 16}},
#define   MTPSLCURRENTCHANGEBACKS  503
	{MTPSLCURRENTCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 17}},
#define   MTPSLCURRENTRESTORATIONS  504
	{MTPSLCURRENTRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlCurrentTable, 6, {1, 1, 11, 6, 1, 18}},
#define   MTPSLINT5MINTIMESTAMP  509
	{MTPSLINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 2}},
#define   MTPSLINT5MINSLUNAVAILABILITYDURATION  510
	{MTPSLINT5MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 3}},
#define   MTPSLINT5MINSLLOCALINHIBITION  511
	{MTPSLINT5MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 4}},
#define   MTPSLINT5MINSLREMOTEINHIBITION  512
	{MTPSLINT5MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 5}},
#define   MTPSLINT5MINSLFAILED  513
	{MTPSLINT5MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 6}},
#define   MTPSLINT5MINSLREMOTEPROCOUTAGE  514
	{MTPSLINT5MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 7}},
#define   MTPSLINT5MINLOCALMGMTINHIBIT  515
	{MTPSLINT5MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 8}},
#define   MTPSLINT5MINLOCALMGMTUNINHIBIT  516
	{MTPSLINT5MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 9}},
#define   MTPSLINT5MINLOCALBUSY  517
	{MTPSLINT5MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 10}},
#define   MTPSLINT5MINSLCONGESTEDSTARTS  518
	{MTPSLINT5MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 11}},
#define   MTPSLINT5MINSLCONGESTEDDURATION  519
	{MTPSLINT5MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 12}},
#define   MTPSLINT5MINSLCONGESTIONSTOPS  520
	{MTPSLINT5MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 13}},
#define   MTPSLINT5MINDISCARDEDMSUS  521
	{MTPSLINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 14}},
#define   MTPSLINT5MINCONGESTIONEVENTSMSULOSS  522
	{MTPSLINT5MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 15}},
#define   MTPSLINT5MINCHANGEOVERS  523
	{MTPSLINT5MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 16}},
#define   MTPSLINT5MINCHANGEBACKS  524
	{MTPSLINT5MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 17}},
#define   MTPSLINT5MINRESTORATIONS  525
	{MTPSLINT5MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlInt5minTable, 6, {1, 1, 11, 7, 1, 18}},
#define   MTPSLINT15MINTIMESTAMP  530
	{MTPSLINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 2}},
#define   MTPSLINT15MINSLUNAVAILABILITYDURATION  531
	{MTPSLINT15MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 3}},
#define   MTPSLINT15MINSLLOCALINHIBITION  532
	{MTPSLINT15MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 4}},
#define   MTPSLINT15MINSLREMOTEINHIBITION  533
	{MTPSLINT15MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 5}},
#define   MTPSLINT15MINSLFAILED  534
	{MTPSLINT15MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 6}},
#define   MTPSLINT15MINSLREMOTEPROCOUTAGE  535
	{MTPSLINT15MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 7}},
#define   MTPSLINT15MINLOCALMGMTINHIBIT  536
	{MTPSLINT15MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 8}},
#define   MTPSLINT15MINLOCALMGMTUNINHIBIT  537
	{MTPSLINT15MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 9}},
#define   MTPSLINT15MINLOCALBUSY  538
	{MTPSLINT15MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 10}},
#define   MTPSLINT15MINSLCONGESTEDSTARTS  539
	{MTPSLINT15MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 11}},
#define   MTPSLINT15MINSLCONGESTEDDURATION  540
	{MTPSLINT15MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 12}},
#define   MTPSLINT15MINSLCONGESTIONSTOPS  541
	{MTPSLINT15MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 13}},
#define   MTPSLINT15MINDISCARDEDMSUS  542
	{MTPSLINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 14}},
#define   MTPSLINT15MINCONGESTIONEVENTSMSULOSS  543
	{MTPSLINT15MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 15}},
#define   MTPSLINT15MINCHANGEOVERS  544
	{MTPSLINT15MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 16}},
#define   MTPSLINT15MINCHANGEBACKS  545
	{MTPSLINT15MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 17}},
#define   MTPSLINT15MINRESTORATIONS  546
	{MTPSLINT15MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlInt15minTable, 6, {1, 1, 11, 8, 1, 18}},
#define   MTPL2PROFILENEXTINDEX  547
	{MTPL2PROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_mtpMIB2, 4, {1, 1, 12, 1}},
#define   MTPL2PROFILETRANSMISSIONRATE  551
	{MTPL2PROFILETRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 2}},
#define   MTPL2PROFILENAME      552
	{MTPL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 3}},
#define   MTPL2PROFILETIMERT1   553
	{MTPL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 4}},
#define   MTPL2PROFILETIMERT2   554
	{MTPL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 5}},
#define   MTPL2PROFILETIMERT2L  555
	{MTPL2PROFILETIMERT2L, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 6}},
#define   MTPL2PROFILETIMERT2H  556
	{MTPL2PROFILETIMERT2H, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 7}},
#define   MTPL2PROFILETIMERT3   557
	{MTPL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 8}},
#define   MTPL2PROFILETIMERT4N  558
	{MTPL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 9}},
#define   MTPL2PROFILETIMERT4E  559
	{MTPL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 10}},
#define   MTPL2PROFILETIMERT5   560
	{MTPL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 11}},
#define   MTPL2PROFILETIMERT6   561
	{MTPL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 12}},
#define   MTPL2PROFILETIMERT7   562
	{MTPL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 13}},
#define   MTPL2PROFILEM         563
	{MTPL2PROFILEM, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 14}},
#define   MTPL2PROFILEN1        564
	{MTPL2PROFILEN1, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 15}},
#define   MTPL2PROFILEN2        565
	{MTPL2PROFILEN2, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 16}},
#define   MTPL2PROFILERBACCEPT  566
	{MTPL2PROFILERBACCEPT, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 17}},
#define   MTPL2PROFILERBDISCARD  567
	{MTPL2PROFILERBDISCARD, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 18}},
#define   MTPL2PROFILERBABATE   568
	{MTPL2PROFILERBABATE, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 19}},
#define   MTPL2PROFILETBABATE0  569
	{MTPL2PROFILETBABATE0, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 20}},
#define   MTPL2PROFILETBONSET0  570
	{MTPL2PROFILETBONSET0, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 21}},
#define   MTPL2PROFILETBDISCARD0  571
	{MTPL2PROFILETBDISCARD0, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 22}},
#define   MTPL2PROFILETBABATE1  572
	{MTPL2PROFILETBABATE1, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 23}},
#define   MTPL2PROFILETBONSET1  573
	{MTPL2PROFILETBONSET1, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 24}},
#define   MTPL2PROFILETBDISCARD1  574
	{MTPL2PROFILETBDISCARD1, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 25}},
#define   MTPL2PROFILETBABATE2  575
	{MTPL2PROFILETBABATE2, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 26}},
#define   MTPL2PROFILETBONSET2  576
	{MTPL2PROFILETBONSET2, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 27}},
#define   MTPL2PROFILETBDISCARD2  577
	{MTPL2PROFILETBDISCARD2, ASN_UNSIGNED, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 28}},
#define   MTPL2PROFILESTATUS    578
	{MTPL2PROFILESTATUS, ASN_INTEGER, RWRITE, var_mtpL2ProfileTable, 6, {1, 1, 12, 2, 1, 29}},
#define   MTPNBANDTRANSMISSIONRATE  582
	{MTPNBANDTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbandTable, 6, {1, 1, 12, 3, 1, 1}},
#define   MTPNBANDSTATUS        583
	{MTPNBANDSTATUS, ASN_INTEGER, RWRITE, var_mtpNbandTable, 6, {1, 1, 12, 3, 1, 2}},
#define   MTPSAALBUFFERRELEASE  587
	{MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 1}},
#define   MTPSAALMAXCC          588
	{MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 2}},
#define   MTPSAALMAXNRP         589
	{MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  590
	{MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  591
	{MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 5}},
#define   MTPSAALMAXPD          592
	{MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  593
	{MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 7}},
#define   MTPSAALMAXSTAT        594
	{MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 8}},
#define   MTPSAALN1             595
	{MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  596
	{MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  597
	{MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  598
	{MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 12}},
#define   MTPSAALNNITIMERT1     599
	{MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 13}},
#define   MTPSAALNNITIMERT2     600
	{MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 14}},
#define   MTPSAALNNITIMERT3     601
	{MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   602
	{MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  603
	{MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  604
	{MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  605
	{MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  606
	{MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  607
	{MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  608
	{MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  609
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  610
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  611
	{MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 25}},
#define   MTPSAALSTATUS         612
	{MTPSAALSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 4, 1, 26}},
#define   MTPM2PAN1             616
	{MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 1}},
#define   MTPM2PAPROVING        617
	{MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  618
	{MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 3}},
#define   MTPM2PALOOPDELAYLOWER  619
	{MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 4}},
#define   MTPM2PALOOPDELAYUPPER  620
	{MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 5}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  621
	{MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 6}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  622
	{MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 7}},
#define   MTPM2PASCTPNODELAY    623
	{MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 8}},
#define   MTPM2PASCTPMAXSEG     624
	{MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 9}},
#define   MTPM2PASCTPHEARTBEATITVL  625
	{MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 10}},
#define   MTPM2PASCTPHEARTBEAT  626
	{MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 11}},
#define   MTPM2PASCTPRTOINITIAL  627
	{MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 12}},
#define   MTPM2PASCTPRTOMIN     628
	{MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 13}},
#define   MTPM2PASCTPRTOMAX     629
	{MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 14}},
#define   MTPM2PASCTPPATHMAXRETRANS  630
	{MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 15}},
#define   MTPM2PASCTPCOOKIELIFE  631
	{MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 16}},
#define   MTPM2PASCTPCOOKIEINC  632
	{MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 17}},
#define   MTPM2PASCTPMAXINITRETRIES  633
	{MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 18}},
#define   MTPM2PASCTPMAXBURST   634
	{MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 19}},
#define   MTPM2PASCTPASSOCMAXRETRANS  635
	{MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 20}},
#define   MTPM2PASCTPSACKDELAY  636
	{MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 21}},
#define   MTPM2PASCTPLIFETIME   637
	{MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 22}},
#define   MTPM2PAPROVINGATTEMPTS  638
	{MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 23}},
#define   MTPM2PASTATUS         639
	{MTPM2PASTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 5, 1, 24}},
#define   MTPL2NAME             643
	{MTPL2NAME, ASN_OCTET_STR, RWRITE, var_mtpL2Table, 6, {1, 1, 12, 6, 1, 2}},
#define   MTPL2PROFILE          644
	{MTPL2PROFILE, ASN_UNSIGNED, RWRITE, var_mtpL2Table, 6, {1, 1, 12, 6, 1, 3}},
#define   MTPL2STATUS           645
	{MTPL2STATUS, ASN_INTEGER, RWRITE, var_mtpL2Table, 6, {1, 1, 12, 6, 1, 4}},
#define   MTPL2CURRENTVALIDINTERVALS  649
	{MTPL2CURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 1}},
#define   MTPL2CURRENTTIMEDISCONTINUITY  650
	{MTPL2CURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 2}},
#define   MTPL2CURRENTSLINSERVICEDURATION  651
	{MTPL2CURRENTSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 3}},
#define   MTPL2CURRENTSLALIGNMENT  652
	{MTPL2CURRENTSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 4}},
#define   MTPL2CURRENTSIGNUNITSRECEIVED  653
	{MTPL2CURRENTSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 5}},
#define   MTPL2CURRENTNEGACKRECEIVED  654
	{MTPL2CURRENTNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 6}},
#define   MTPL2CURRENTTRANSMITTEDOCTETSSIFSIO  655
	{MTPL2CURRENTTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 7}},
#define   MTPL2CURRENTRETRANSMITTEDOCTETS  656
	{MTPL2CURRENTRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 8}},
#define   MTPL2CURRENTTRANSMITTEDMSUS  657
	{MTPL2CURRENTTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 9}},
#define   MTPL2CURRENTRECEIVEDOCTETSSIFSIO  658
	{MTPL2CURRENTRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 10}},
#define   MTPL2CURRENTRECEIVEDMSUS  659
	{MTPL2CURRENTRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpL2CurrentTable, 6, {1, 1, 12, 7, 1, 11}},
#define   MTPL2INT5MINTIMESTAMP  663
	{MTPL2INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 2}},
#define   MTPL2INT5MINSLINSERVICEDURATION  664
	{MTPL2INT5MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 3}},
#define   MTPL2INT5MINSLALIGNMENT  665
	{MTPL2INT5MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 4}},
#define   MTPL2INT5MINSIGNUNITSRECEIVED  666
	{MTPL2INT5MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 5}},
#define   MTPL2INT5MINNEGACKRECEIVED  667
	{MTPL2INT5MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 6}},
#define   MTPL2INT5MINTRANSMITTEDOCTETSSIFSIO  668
	{MTPL2INT5MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 7}},
#define   MTPL2INT5MINRETRANSMITTEDOCTETS  669
	{MTPL2INT5MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 8}},
#define   MTPL2INT5MINTRANSMITTEDMSUS  670
	{MTPL2INT5MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 9}},
#define   MTPL2INT5MINRECEIVEDOCTETSSIFSIO  671
	{MTPL2INT5MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 10}},
#define   MTPL2INT5MINRECEIVEDMSUS  672
	{MTPL2INT5MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpL2Int5minTable, 6, {1, 1, 12, 8, 1, 11}},
#define   MTPL2INT15MINTIMESTAMP  676
	{MTPL2INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 2}},
#define   MTPL2INT15MINSLINSERVICEDURATION  677
	{MTPL2INT15MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 3}},
#define   MTPL2INT15MINSLALIGNMENT  678
	{MTPL2INT15MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 4}},
#define   MTPL2INT15MINSIGNUNITSRECEIVED  679
	{MTPL2INT15MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 5}},
#define   MTPL2INT15MINNEGACKRECEIVED  680
	{MTPL2INT15MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 6}},
#define   MTPL2INT15MINTRANSMITTEDOCTETSSIFSIO  681
	{MTPL2INT15MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 7}},
#define   MTPL2INT15MINRETRANSMITTEDOCTETS  682
	{MTPL2INT15MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 8}},
#define   MTPL2INT15MINTRANSMITTEDMSUS  683
	{MTPL2INT15MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 9}},
#define   MTPL2INT15MINRECEIVEDOCTETSSIFSIO  684
	{MTPL2INT15MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 10}},
#define   MTPL2INT15MINRECEIVEDMSUS  685
	{MTPL2INT15MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpL2Int15minTable, 6, {1, 1, 12, 9, 1, 11}},
#define   MTPSDTADMINISTRATIVESTATE  689
	{MTPSDTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 2}},
#define   MTPSDTOPERATIONALSTATE  690
	{MTPSDTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 3}},
#define   MTPSDTUSAGESTATE      691
	{MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 4}},
#define   MTPSDTPROCEDURALSTATUS  692
	{MTPSDTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 5}},
#define   MTPSDTAVAILABILITYSTATUS  693
	{MTPSDTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 6}},
#define   MTPSDTEQUIPMENTPOINTER  694
	{MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 7}},
#define   MTPSDTNAME            695
	{MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 8}},
#define   MTPSDTSTATUS          696
	{MTPSDTSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 13, 1, 1, 9}},
#define   MTPSDLADJPC           700
	{MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 2}},
#define   MTPSDLTRANSMISSIONRATE  701
	{MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       702
	{MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 4}},
#define   MTPSDLOPERATIONALSTATE  703
	{MTPSDLOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  704
	{MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 6}},
#define   MTPSDLCIC             705
	{MTPSDLCIC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 7}},
#define   MTPSDLNAME            706
	{MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      707
	{MTPSDLSTMCHANNEL, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    708
	{MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 10}},
#define   MTPSDLROWSTATUS       709
	{MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 14, 1, 1, 11}},
#define   MTPM2PADEFAULTSCTPNODELAY  710
	{MTPM2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 1}},
#define   MTPM2PADEFAULTSCTPMAXSEG  711
	{MTPM2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 2}},
#define   MTPM2PADEFAULTSCTPHEARTBEATITVL  712
	{MTPM2PADEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 3}},
#define   MTPM2PADEFAULTSCTPHEARTBEAT  713
	{MTPM2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 4}},
#define   MTPM2PADEFAULTSCTPRTOINITIAL  714
	{MTPM2PADEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 5}},
#define   MTPM2PADEFAULTSCTPRTOMIN  715
	{MTPM2PADEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 6}},
#define   MTPM2PADEFAULTSCTPRTOMAX  716
	{MTPM2PADEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 7}},
#define   MTPM2PADEFAULTSCTPPATHMAXRETRANS  717
	{MTPM2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 8}},
#define   MTPM2PADEFAULTSCTPCOOKIELIFE  718
	{MTPM2PADEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 9}},
#define   MTPM2PADEFAULTSCTPCOOKIEINC  719
	{MTPM2PADEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 10}},
#define   MTPM2PADEFAULTSCTPMAXINITRETRIES  720
	{MTPM2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 11}},
#define   MTPM2PADEFAULTSCTPMAXBURST  721
	{MTPM2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 12}},
#define   MTPM2PADEFAULTSCTPASSOCMAXRETRANS  722
	{MTPM2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 13}},
#define   MTPM2PADEFAULTSCTPSACKDELAY  723
	{MTPM2PADEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 14}},
#define   MTPM2PADEFAULTSCTPLIFETIME  724
	{MTPM2PADEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 15}},

};

/*    (L = length of the oidsuffix) */

static struct mtpMIB2_data *mtpMIB2Storage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
static struct header_complex_index *mtpMtTableStorage = NULL;
static struct header_complex_index *mtpMsTableStorage = NULL;
static struct header_complex_index *mtpNaProfileTableStorage = NULL;
static struct header_complex_index *mtpNaTableStorage = NULL;
static struct header_complex_index *mtpGsTableStorage = NULL;
static struct header_complex_index *mtpGsListTableStorage = NULL;
static struct header_complex_index *mtpGsRuleTableStorage = NULL;
static struct header_complex_index *mtpSpProfileTableStorage = NULL;
static struct header_complex_index *mtpSpTableStorage = NULL;
static struct header_complex_index *mtpSpCurrentTableStorage = NULL;
static struct header_complex_index *mtpSpInt5minTableStorage = NULL;
static struct header_complex_index *mtpSpInt15minTableStorage = NULL;
static struct header_complex_index *mtpSpSiTableStorage = NULL;
static struct header_complex_index *mtpSpSiInt5minTableStorage = NULL;
static struct header_complex_index *mtpSpSiInt15minTableStorage = NULL;
static struct header_complex_index *mtpSpStudyTableStorage = NULL;
static struct header_complex_index *mtpSpStudyInt5minTableStorage = NULL;
static struct header_complex_index *mtpSpStudyInt15minTableStorage = NULL;
static struct header_complex_index *mtpSpStudyMapTableStorage = NULL;
static struct header_complex_index *mtpRsProfileTableStorage = NULL;
static struct header_complex_index *mtpRsTableStorage = NULL;
static struct header_complex_index *mtpRsCurrentTableStorage = NULL;
static struct header_complex_index *mtpRsInt5minTableStorage = NULL;
static struct header_complex_index *mtpRsInt15minTableStorage = NULL;
static struct header_complex_index *mtpRsSiTableStorage = NULL;
static struct header_complex_index *mtpRsSiInt5minTableStorage = NULL;
static struct header_complex_index *mtpRsSiInt15minTableStorage = NULL;
static struct header_complex_index *mtpRlTableStorage = NULL;
static struct header_complex_index *mtpRtProfileTableStorage = NULL;
static struct header_complex_index *mtpRtTableStorage = NULL;
static struct header_complex_index *mtpLsTableStorage = NULL;
static struct header_complex_index *mtpLkProfileTableStorage = NULL;
static struct header_complex_index *mtpLkTableStorage = NULL;
static struct header_complex_index *mtpLkCurrentTableStorage = NULL;
static struct header_complex_index *mtpLkInt5minTableStorage = NULL;
static struct header_complex_index *mtpLkInt15minTableStorage = NULL;
static struct header_complex_index *mtpSlProfileTableStorage = NULL;
static struct header_complex_index *mtpSlTableStorage = NULL;
static struct header_complex_index *mtpSlSdlListTableStorage = NULL;
static struct header_complex_index *mtpSlSdtListTableStorage = NULL;
static struct header_complex_index *mtpSlCurrentTableStorage = NULL;
static struct header_complex_index *mtpSlInt5minTableStorage = NULL;
static struct header_complex_index *mtpSlInt15minTableStorage = NULL;
static struct header_complex_index *mtpL2ProfileTableStorage = NULL;
static struct header_complex_index *mtpNbandTableStorage = NULL;
static struct header_complex_index *mtpSaalTableStorage = NULL;
static struct header_complex_index *mtpM2paTableStorage = NULL;
static struct header_complex_index *mtpL2TableStorage = NULL;
static struct header_complex_index *mtpL2CurrentTableStorage = NULL;
static struct header_complex_index *mtpL2Int5minTableStorage = NULL;
static struct header_complex_index *mtpL2Int15minTableStorage = NULL;
static struct header_complex_index *mtpSdtTableStorage = NULL;
static struct header_complex_index *mtpSdlTableStorage = NULL;

/*
 * init_mtpMIB2():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_mtpMIB2(void)
{
	DEBUGMSGTL(("mtpMIB2", "initializing...  "));

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB2", mtpMIB2_variables, variable7, mtpMIB2_variables_oid);

	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB2, NULL);

	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB2", parse_mtpMIB2, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMtTable", parse_mtpMtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMsTable", parse_mtpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaProfileTable", parse_mtpNaProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsListTable", parse_mtpGsListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsRuleTable", parse_mtpGsRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpCurrentTable", parse_mtpSpCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt5minTable", parse_mtpSpInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt15minTable", parse_mtpSpInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiTable", parse_mtpSpSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt5minTable", parse_mtpSpSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt15minTable", parse_mtpSpSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyTable", parse_mtpSpStudyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt5minTable", parse_mtpSpStudyInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt15minTable", parse_mtpSpStudyInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyMapTable", parse_mtpSpStudyMapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsProfileTable", parse_mtpRsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsCurrentTable", parse_mtpRsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt5minTable", parse_mtpRsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt15minTable", parse_mtpRsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiTable", parse_mtpRsSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt5minTable", parse_mtpRsSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt15minTable", parse_mtpRsSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRlTable", parse_mtpRlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtProfileTable", parse_mtpRtProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLkProfileTable", parse_mtpLkProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLkTable", parse_mtpLkTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLkCurrentTable", parse_mtpLkCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLkInt5minTable", parse_mtpLkInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLkInt15minTable", parse_mtpLkInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlProfileTable", parse_mtpSlProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlCurrentTable", parse_mtpSlCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlInt5minTable", parse_mtpSlInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlInt15minTable", parse_mtpSlInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL2ProfileTable", parse_mtpL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbandTable", parse_mtpNbandTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL2Table", parse_mtpL2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL2CurrentTable", parse_mtpL2CurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL2Int5minTable", parse_mtpL2Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL2Int15minTable", parse_mtpL2Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB2, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyMapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLkProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLkTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLkCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLkInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLkInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbandTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL2CurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL2Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL2Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);

	/* place any other initialization junk you need here */

	DEBUGMSGTL(("mtpMIB2", "done.\n"));
}

/*
 * deinit_mtpMIB2():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_mtpMIB2(void)
{
	DEBUGMSGTL(("mtpMIB2", "deinitializating...  "));

	unregister_mib(mtpMIB2_variables_oid, sizeof(mtpMIB2_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB2");
	snmpd_unregister_config_handler("mtpMtTable");
	snmpd_unregister_config_handler("mtpMsTable");
	snmpd_unregister_config_handler("mtpNaProfileTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsListTable");
	snmpd_unregister_config_handler("mtpGsRuleTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpSpCurrentTable");
	snmpd_unregister_config_handler("mtpSpInt5minTable");
	snmpd_unregister_config_handler("mtpSpInt15minTable");
	snmpd_unregister_config_handler("mtpSpSiTable");
	snmpd_unregister_config_handler("mtpSpSiInt5minTable");
	snmpd_unregister_config_handler("mtpSpSiInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyTable");
	snmpd_unregister_config_handler("mtpSpStudyInt5minTable");
	snmpd_unregister_config_handler("mtpSpStudyInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyMapTable");
	snmpd_unregister_config_handler("mtpRsProfileTable");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRsCurrentTable");
	snmpd_unregister_config_handler("mtpRsInt5minTable");
	snmpd_unregister_config_handler("mtpRsInt15minTable");
	snmpd_unregister_config_handler("mtpRsSiTable");
	snmpd_unregister_config_handler("mtpRsSiInt5minTable");
	snmpd_unregister_config_handler("mtpRsSiInt15minTable");
	snmpd_unregister_config_handler("mtpRlTable");
	snmpd_unregister_config_handler("mtpRtProfileTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpLkProfileTable");
	snmpd_unregister_config_handler("mtpLkTable");
	snmpd_unregister_config_handler("mtpLkCurrentTable");
	snmpd_unregister_config_handler("mtpLkInt5minTable");
	snmpd_unregister_config_handler("mtpLkInt15minTable");
	snmpd_unregister_config_handler("mtpSlProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpSlCurrentTable");
	snmpd_unregister_config_handler("mtpSlInt5minTable");
	snmpd_unregister_config_handler("mtpSlInt15minTable");
	snmpd_unregister_config_handler("mtpL2ProfileTable");
	snmpd_unregister_config_handler("mtpNbandTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpL2Table");
	snmpd_unregister_config_handler("mtpL2CurrentTable");
	snmpd_unregister_config_handler("mtpL2Int5minTable");
	snmpd_unregister_config_handler("mtpL2Int15minTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdlTable");

	/* place any other de-initialization junk you need here */

	DEBUGMSGTL(("mtpMIB2", "done.\n"));
}

int
term_mtpMIB2(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpMIB2();
	return 0;
}

/*
 * mtpMIB2_add(): adds a structure node for scalars
 */
int
mtpMIB2_add(struct mtpMIB2_data *thedata)
{
	DEBUGMSGTL(("mtpMIB2", "adding data...  "));

	mtpMIB2Storage = thedata;

	DEBUGMSGTL(("mtpMIB2", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMIB2():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMIB2(const char *token, char *line)
{
	size_t tmpint;
	struct mtpMIB2_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMIB2_data);

	DEBUGMSGTL(("mtpMIB2", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNaProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNaNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileNextIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpint);

	mtpMIB2_add(StorageTmp);

	(void) tmpint;

	DEBUGMSGTL(("mtpMIB2", "done.\n"));
}

/*
 * store_mtpMIB2():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB2(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpMIB2_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB2", "storing data...  "));

	refresh_mtpMIB2();

	if ((StorageTmp = mtpMIB2Storage) == NULL) {
		DEBUGMSGTL(("mtpMIB2", "error.\n"));
		return SNMPERR_GENERR;
	}

	(void) tmpint;

	/* XXX: if (StorageTmp->mtpMIB2StorageType == ST_NONVOLATILE) { */

	memset(line, 0, sizeof(line));
	strcat(line, "mtpMIB2 ");
	cptr = line + strlen(line);

	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNaProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNaNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileNextIndex, &tmpint);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpint);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpint);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("mtpMIB2", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpMIB2: refresh mtpMIB2 scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB2(void)
{
	if (mtpMIB2Storage == NULL) {
		if ((mtpMIB2Storage = SNMP_MALLOC_STRUCT(mtpMIB2_data)) == NULL)
			return;

		/* Update scalar defaults as required here... */

		mtpMIB2_refresh = 1;
	}

	if (mtpMIB2_refresh == 0)
		return;
	mtpMIB2_refresh = 0;

	/* Update scalars as required here... */

}

/*
 * var_mtpMIB2():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_mtpMIB2(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB2_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* Refresh the MIB values if required. */
	refresh_mtpMIB2();

	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return NULL;

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPNAPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpNaProfileNextIndex);
		return (u_char *) &StorageTmp->mtpNaProfileNextIndex;

	case MTPNANEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpNaNextIndex);
		return (u_char *) &StorageTmp->mtpNaNextIndex;

	case MTPSPPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpProfileNextIndex);
		return (u_char *) &StorageTmp->mtpSpProfileNextIndex;

	case MTPSPNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpNextIndex);
		return (u_char *) &StorageTmp->mtpSpNextIndex;

	case MTPRSPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsProfileNextIndex);
		return (u_char *) &StorageTmp->mtpRsProfileNextIndex;

	case MTPRTPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtProfileNextIndex);
		return (u_char *) &StorageTmp->mtpRtProfileNextIndex;

	case MTPLKPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkProfileNextIndex);
		return (u_char *) &StorageTmp->mtpLkProfileNextIndex;

	case MTPSLPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlProfileNextIndex);
		return (u_char *) &StorageTmp->mtpSlProfileNextIndex;

	case MTPL2PROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2ProfileNextIndex);
		return (u_char *) &StorageTmp->mtpL2ProfileNextIndex;

	case MTPM2PADEFAULTSCTPNODELAY:
		*write_method = write_mtpM2paDefaultSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpNoDelay;

	case MTPM2PADEFAULTSCTPMAXSEG:
		*write_method = write_mtpM2paDefaultSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxseg;

	case MTPM2PADEFAULTSCTPHEARTBEATITVL:
		*write_method = write_mtpM2paDefaultSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;

	case MTPM2PADEFAULTSCTPHEARTBEAT:
		*write_method = write_mtpM2paDefaultSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpHeartbeat;

	case MTPM2PADEFAULTSCTPRTOINITIAL:
		*write_method = write_mtpM2paDefaultSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoInitial;

	case MTPM2PADEFAULTSCTPRTOMIN:
		*write_method = write_mtpM2paDefaultSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMin;

	case MTPM2PADEFAULTSCTPRTOMAX:
		*write_method = write_mtpM2paDefaultSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpRtoMax;

	case MTPM2PADEFAULTSCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;

	case MTPM2PADEFAULTSCTPCOOKIELIFE:
		*write_method = write_mtpM2paDefaultSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieLife;

	case MTPM2PADEFAULTSCTPCOOKIEINC:
		*write_method = write_mtpM2paDefaultSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpCookieInc;

	case MTPM2PADEFAULTSCTPMAXINITRETRIES:
		*write_method = write_mtpM2paDefaultSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxInitRetries;

	case MTPM2PADEFAULTSCTPMAXBURST:
		*write_method = write_mtpM2paDefaultSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpMaxBurst;

	case MTPM2PADEFAULTSCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;

	case MTPM2PADEFAULTSCTPSACKDELAY:
		*write_method = write_mtpM2paDefaultSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpSackDelay;

	case MTPM2PADEFAULTSCTPLIFETIME:
		*write_method = write_mtpM2paDefaultSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paDefaultSctpLifetime;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/* 
 * mtpMtTable_add(): adds a structure node to our data set 
 */
int
mtpMtTable_add(struct mtpMtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpMtUserPart */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpMtUserPart, sizeof(thedata->mtpMtUserPart));

	header_complex_add_data(&mtpMtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpMtTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpMtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMtTable_data);

	DEBUGMSGTL(("mtpMtTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMtIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMtName, &StorageTmp->mtpMtNameLen);
	if (StorageTmp->mtpMtName == NULL) {
		config_perror("invalid specification for mtpMtName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMtSpIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMtUserPart, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMtUserPartStatus, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMtUsageState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMtAlarmSeverityAssignment, &StorageTmp->mtpMtAlarmSeverityAssignmentLen);
	if (StorageTmp->mtpMtAlarmSeverityAssignment == NULL) {
		config_perror("invalid specification for mtpMtAlarmSeverityAssignment");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMtLongMessageSupported, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMtStatus, &tmpint);

	mtpMtTable_add(StorageTmp);

	DEBUGMSGTL(("mtpMtTable", "done.\n"));
}

/*
 * store_mtpMtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpMtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpMtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMtTable", "storing data...  "));

	refresh_mtpMtTable();

	for (hcindex = mtpMtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMtTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpMtTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpMtTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMtIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMtName, &StorageTmp->mtpMtNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMtSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMtUserPart, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMtUserPartStatus, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMtAlarmSeverityAssignment, &StorageTmp->mtpMtAlarmSeverityAssignmentLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMtLongMessageSupported, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMtStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpMsTable_add(): adds a structure node to our data set 
 */
int
mtpMsTable_add(struct mtpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpMsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsIndex, sizeof(thedata->mtpMsIndex));

	header_complex_add_data(&mtpMsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpMsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpMsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
	if (StorageTmp->mtpMsName == NULL) {
		config_perror("invalid specification for mtpMsName");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
	if (StorageTmp->mtpMsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpMsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsUsageState, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
	if (StorageTmp->mtpMsManagedElementType == NULL) {
		config_perror("invalid specification for mtpMsManagedElementType");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
	if (StorageTmp->mtpMsModelCode == NULL) {
		config_perror("invalid specification for mtpMsModelCode");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
	if (StorageTmp->mtpMsVendorName == NULL) {
		config_perror("invalid specification for mtpMsVendorName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
	if (StorageTmp->mtpMsUserLabel == NULL) {
		config_perror("invalid specification for mtpMsUserLabel");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
	if (StorageTmp->mtpMsVersion == NULL) {
		config_perror("invalid specification for mtpMsVersion");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMsAlarmSeverityAssignment, &StorageTmp->mtpMsAlarmSeverityAssignmentLen);
	if (StorageTmp->mtpMsAlarmSeverityAssignment == NULL) {
		config_perror("invalid specification for mtpMsAlarmSeverityAssignment");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
	if (StorageTmp->mtpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for mtpMsNetworkElementAliases");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsStatus, &tmpint);

	mtpMsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpMsTable", "done.\n"));
}

/*
 * store_mtpMsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMsTable", "storing data...  "));

	refresh_mtpMsTable();

	for (hcindex = mtpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpMsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpMsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsUsageState, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMsAlarmSeverityAssignment, &StorageTmp->mtpMsAlarmSeverityAssignmentLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpNaProfileTable_add(): adds a structure node to our data set 
 */
int
mtpNaProfileTable_add(struct mtpNaProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpNaProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpNaProfileIndex, sizeof(thedata->mtpNaProfileIndex));

	header_complex_add_data(&mtpNaProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpNaProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNaProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNaProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNaProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNaProfileTable_data);

	DEBUGMSGTL(("mtpNaProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNaProfileIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaProfileName, &StorageTmp->mtpNaProfileNameLen);
	if (StorageTmp->mtpNaProfileName == NULL) {
		config_perror("invalid specification for mtpNaProfileName");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProfileStatus, &tmpint);

	mtpNaProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpNaProfileTable", "done.\n"));
}

/*
 * store_mtpNaProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNaProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaProfileTable", "storing data...  "));

	refresh_mtpNaProfileTable();

	for (hcindex = mtpNaProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpNaProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpNaProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNaProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaProfileName, &StorageTmp->mtpNaProfileNameLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNaProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpNaTable_add(): adds a structure node to our data set 
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpNaIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpNaIndex, sizeof(thedata->mtpNaIndex));

	header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNaTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNaIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNaProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNaSpDefault, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaStatus, &tmpint);

	mtpNaTable_add(StorageTmp);

	DEBUGMSGTL(("mtpNaTable", "done.\n"));
}

/*
 * store_mtpNaTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaTable", "storing data...  "));

	refresh_mtpNaTable();

	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpNaTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpNaTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNaIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNaProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNaSpDefault, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpGsTable_add(): adds a structure node to our data set 
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpGsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsIndex, sizeof(thedata->mtpGsIndex));

	header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsStatus, &tmpint);

	mtpGsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpGsTable", "done.\n"));
}

/*
 * store_mtpGsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsTable", "storing data...  "));

	refresh_mtpGsTable();

	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpGsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpGsListTable_add(): adds a structure node to our data set 
 */
int
mtpGsListTable_add(struct mtpGsListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpGsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsIndex, sizeof(thedata->mtpGsIndex));
	/* mtpGsListIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsListIndex, sizeof(thedata->mtpGsListIndex));

	header_complex_add_data(&mtpGsListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsListTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpGsListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsListTable_data);

	DEBUGMSGTL(("mtpGsListTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsListIndex, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsListObject, &StorageTmp->mtpGsListObjectLen);
	if (StorageTmp->mtpGsListObject == NULL) {
		config_perror("invalid specification for mtpGsListObject");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsListContent, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListStatus, &tmpint);

	mtpGsListTable_add(StorageTmp);

	DEBUGMSGTL(("mtpGsListTable", "done.\n"));
}

/*
 * store_mtpGsListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsListTable", "storing data...  "));

	refresh_mtpGsListTable();

	for (hcindex = mtpGsListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsListTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpGsListTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsListTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsListIndex, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsListObject, &StorageTmp->mtpGsListObjectLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsListContent, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpGsRuleTable_add(): adds a structure node to our data set 
 */
int
mtpGsRuleTable_add(struct mtpGsRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpGsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsIndex, sizeof(thedata->mtpGsIndex));
	/* mtpGsListIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsListIndex, sizeof(thedata->mtpGsListIndex));
	/* mtpGsRuleIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsRuleIndex, sizeof(thedata->mtpGsRuleIndex));

	header_complex_add_data(&mtpGsRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsRuleTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpGsRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsRuleTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsRuleTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsRuleTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsRuleTable_data);

	DEBUGMSGTL(("mtpGsRuleTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsListIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsRuleIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsRuleDesignatedDPCFirst, &StorageTmp->mtpGsRuleDesignatedDPCFirstLen);
	if (StorageTmp->mtpGsRuleDesignatedDPCFirst == NULL) {
		config_perror("invalid specification for mtpGsRuleDesignatedDPCFirst");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsRuleDesignatedDPCLast, &StorageTmp->mtpGsRuleDesignatedDPCLastLen);
	if (StorageTmp->mtpGsRuleDesignatedDPCLast == NULL) {
		config_perror("invalid specification for mtpGsRuleDesignatedDPCLast");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpGsRuleSiMask, &StorageTmp->mtpGsRuleSiMaskLen);
	if (StorageTmp->mtpGsRuleSiMask == NULL) {
		config_perror("invalid specification for mtpGsRuleSiMask");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRuleMessageTreatment, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsRuleComment, &StorageTmp->mtpGsRuleCommentLen);
	if (StorageTmp->mtpGsRuleComment == NULL) {
		config_perror("invalid specification for mtpGsRuleComment");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRuleStatus, &tmpint);

	mtpGsRuleTable_add(StorageTmp);

	DEBUGMSGTL(("mtpGsRuleTable", "done.\n"));
}

/*
 * store_mtpGsRuleTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsRuleTable", "storing data...  "));

	refresh_mtpGsRuleTable();

	for (hcindex = mtpGsRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsRuleTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpGsRuleTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsRuleTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsListIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsRuleIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsRuleDesignatedDPCFirst, &StorageTmp->mtpGsRuleDesignatedDPCFirstLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsRuleDesignatedDPCLast, &StorageTmp->mtpGsRuleDesignatedDPCLastLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpGsRuleSiMask, &StorageTmp->mtpGsRuleSiMaskLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRuleMessageTreatment, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsRuleComment, &StorageTmp->mtpGsRuleCommentLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRuleStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpProfileTable_add(): adds a structure node to our data set 
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpProfileIndex, sizeof(thedata->mtpSpProfileIndex));

	header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpProfileIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1R, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT18, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT24A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT26A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT27A, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpProfileRsDefault, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpProfileLkDefault, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileStatus, &tmpint);

	mtpSpProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
}

/*
 * store_mtpSpProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpProfileTable", "storing data...  "));

	refresh_mtpSpProfileTable();

	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1R, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT18, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT24A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT26A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT27A, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpProfileRsDefault, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpProfileLkDefault, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpTable_add(): adds a structure node to our data set 
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));

	header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpMsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpNaIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpRsDefault, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpLkDefault, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
	if (StorageTmp->mtpSpPointCode == NULL) {
		config_perror("invalid specification for mtpSpPointCode");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpFlags, &StorageTmp->mtpSpFlagsLen);
	if (StorageTmp->mtpSpFlags == NULL) {
		config_perror("invalid specification for mtpSpFlags");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
	if (StorageTmp->mtpSpUsers == NULL) {
		config_perror("invalid specification for mtpSpUsers");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
	if (StorageTmp->mtpSpAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSpAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStatus, &tmpint);

	mtpSpTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpTable", "done.\n"));
}

/*
 * store_mtpSpTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpTable", "storing data...  "));

	refresh_mtpSpTable();

	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpMsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpNaIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpRsDefault, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpLkDefault, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpFlags, &StorageTmp->mtpSpFlagsLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpSpCurrentTable_add(struct mtpSpCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));

	header_complex_add_data(&mtpSpCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpCurrentTable_data);

	DEBUGMSGTL(("mtpSpCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpint);

	mtpSpCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
}

/*
 * store_mtpSpCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpCurrentTable", "storing data...  "));

	refresh_mtpSpCurrentTable();

	for (hcindex = mtpSpCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSpInt5minTable_add(struct mtpSpInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpSpInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpInt5minInterval, sizeof(thedata->mtpSpInt5minInterval));

	header_complex_add_data(&mtpSpInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt5minTable_data);

	DEBUGMSGTL(("mtpSpInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpint);

	mtpSpInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
}

/*
 * store_mtpSpInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt5minTable", "storing data...  "));

	refresh_mtpSpInt5minTable();

	for (hcindex = mtpSpInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSpInt15minTable_add(struct mtpSpInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpSpInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpInt15minInterval, sizeof(thedata->mtpSpInt15minInterval));

	header_complex_add_data(&mtpSpInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt15minTable_data);

	DEBUGMSGTL(("mtpSpInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpint);

	mtpSpInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
}

/*
 * store_mtpSpInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt15minTable", "storing data...  "));

	refresh_mtpSpInt15minTable();

	for (hcindex = mtpSpInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpSiTable_add(): adds a structure node to our data set 
 */
int
mtpSpSiTable_add(struct mtpSpSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));

	header_complex_add_data(&mtpSpSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);

	DEBUGMSGTL(("mtpSpSiTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiStatus, &tmpint);

	mtpSpSiTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
}

/*
 * store_mtpSpSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiTable", "storing data...  "));

	refresh_mtpSpSiTable();

	for (hcindex = mtpSpSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpSiTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpSiInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSpSiInt5minTable_add(struct mtpSpSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiInt5minInterval, sizeof(thedata->mtpSpSiInt5minInterval));

	header_complex_add_data(&mtpSpSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpSpSiInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpint);

	mtpSpSiInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "storing data...  "));

	refresh_mtpSpSiInt5minTable();

	for (hcindex = mtpSpSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpSiInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpSiInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSpSiInt15minTable_add(struct mtpSpSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiInt15minInterval, sizeof(thedata->mtpSpSiInt15minInterval));

	header_complex_add_data(&mtpSpSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpSpSiInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpint);

	mtpSpSiInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "storing data...  "));

	refresh_mtpSpSiInt15minTable();

	for (hcindex = mtpSpSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpSiInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyTable_add(struct mtpSpStudyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));

	header_complex_add_data(&mtpSpStudyTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);

	DEBUGMSGTL(("mtpSpStudyTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyStatus, &tmpint);

	mtpSpStudyTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
}

/*
 * store_mtpSpStudyTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyTable", "storing data...  "));

	refresh_mtpSpStudyTable();

	for (hcindex = mtpSpStudyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyInt5minTable_add(struct mtpSpStudyInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));
	/* mtpSpStudyInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyInt5minInterval, sizeof(thedata->mtpSpStudyInt5minInterval));

	header_complex_add_data(&mtpSpStudyInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpint);

	mtpSpStudyInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "storing data...  "));

	refresh_mtpSpStudyInt5minTable();

	for (hcindex = mtpSpStudyInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyInt15minTable_add(struct mtpSpStudyInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (u_char *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));

	header_complex_add_data(&mtpSpStudyInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpint);

	mtpSpStudyInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "storing data...  "));

	refresh_mtpSpStudyInt15minTable();

	for (hcindex = mtpSpStudyInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSpStudyMapTable_add(): adds a structure node to our data set 
 */
int
mtpSpStudyMapTable_add(struct mtpSpStudyMapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyMapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsIndex, sizeof(thedata->mtpRsIndex));
	/* mtpRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsIndex, sizeof(thedata->mtpRsIndex));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpStudyIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpStudyIndex, sizeof(thedata->mtpSpStudyIndex));

	header_complex_add_data(&mtpSpStudyMapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyMapTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyMapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyMapTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyMapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);

	DEBUGMSGTL(("mtpSpStudyMapTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyMapStatus, &tmpint);

	mtpSpStudyMapTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
}

/*
 * store_mtpSpStudyMapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyMapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyMapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyMapTable", "storing data...  "));

	refresh_mtpSpStudyMapTable();

	for (hcindex = mtpSpStudyMapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyMapTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSpStudyMapTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyMapTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyMapStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsProfileTable_add(): adds a structure node to our data set 
 */
int
mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpRsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsProfileIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
	if (StorageTmp->mtpRsProfileName == NULL) {
		config_perror("invalid specification for mtpRsProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT8, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT11, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT15, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT16, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT18A, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsProfileRtDefault, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileStatus, &tmpint);

	mtpRsProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
}

/*
 * store_mtpRsProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsProfileTable", "storing data...  "));

	refresh_mtpRsProfileTable();

	for (hcindex = mtpRsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT8, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT11, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT15, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT16, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT18A, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsProfileRtDefault, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsTable_add(): adds a structure node to our data set 
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsIndex, sizeof(thedata->mtpRsIndex));

	header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsRtDefault, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAlarmSeverityAssignment, &StorageTmp->mtpRsAlarmSeverityAssignmentLen);
	if (StorageTmp->mtpRsAlarmSeverityAssignment == NULL) {
		config_perror("invalid specification for mtpRsAlarmSeverityAssignment");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongLevel, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
	if (StorageTmp->mtpRsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpRsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsStatus, &tmpint);

	mtpRsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsTable", "done.\n"));
}

/*
 * store_mtpRsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsTable", "storing data...  "));

	refresh_mtpRsTable();

	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsRtDefault, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAlarmSeverityAssignment, &StorageTmp->mtpRsAlarmSeverityAssignmentLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongLevel, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpRsCurrentTable_add(struct mtpRsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsIndex, sizeof(thedata->mtpRsIndex));

	header_complex_add_data(&mtpRsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsCurrentTable_data);

	DEBUGMSGTL(("mtpRsCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpint);

	mtpRsCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
}

/*
 * store_mtpRsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsCurrentTable", "storing data...  "));

	refresh_mtpRsCurrentTable();

	for (hcindex = mtpRsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpRsInt5minTable_add(struct mtpRsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsIndex, sizeof(thedata->mtpRsIndex));
	/* mtpRsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsInt5minInterval, sizeof(thedata->mtpRsInt5minInterval));

	header_complex_add_data(&mtpRsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt5minTable_data);

	DEBUGMSGTL(("mtpRsInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpint);

	mtpRsInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
}

/*
 * store_mtpRsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt5minTable", "storing data...  "));

	refresh_mtpRsInt5minTable();

	for (hcindex = mtpRsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpRsInt15minTable_add(struct mtpRsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsIndex, sizeof(thedata->mtpRsIndex));
	/* mtpRsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsInt15minInterval, sizeof(thedata->mtpRsInt15minInterval));

	header_complex_add_data(&mtpRsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt15minTable_data);

	DEBUGMSGTL(("mtpRsInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpint);

	mtpRsInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
}

/*
 * store_mtpRsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt15minTable", "storing data...  "));

	refresh_mtpRsInt15minTable();

	for (hcindex = mtpRsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsSiTable_add(): adds a structure node to our data set 
 */
int
mtpRsSiTable_add(struct mtpRsSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));

	header_complex_add_data(&mtpRsSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);

	DEBUGMSGTL(("mtpRsSiTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiStatus, &tmpint);

	mtpRsSiTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
}

/*
 * store_mtpRsSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiTable", "storing data...  "));

	refresh_mtpRsSiTable();

	for (hcindex = mtpRsSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsSiTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsSiInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpRsSiInt5minTable_add(struct mtpRsSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiInt5minInterval, sizeof(thedata->mtpRsSiInt5minInterval));

	header_complex_add_data(&mtpRsSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpRsSiInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpint);

	mtpRsSiInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "storing data...  "));

	refresh_mtpRsSiInt5minTable();

	for (hcindex = mtpRsSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsSiInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRsSiInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpRsSiInt15minTable_add(struct mtpRsSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsSiInt15minInterval, sizeof(thedata->mtpRsSiInt15minInterval));

	header_complex_add_data(&mtpRsSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpRsSiInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpint);

	mtpRsSiInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "storing data...  "));

	refresh_mtpRsSiInt15minTable();

	for (hcindex = mtpRsSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRsSiInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRlTable_add(): adds a structure node to our data set 
 */
int
mtpRlTable_add(struct mtpRlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRlIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRlIndex, sizeof(thedata->mtpRlIndex));

	header_complex_add_data(&mtpRlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRlTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRlTable_data);

	DEBUGMSGTL(("mtpRlTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRlIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRlProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRlRtDefault, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRlRsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRlLsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRlRsCost, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRlAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRlOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRlCongState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRlCongLevel, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRlStatus, &tmpint);

	mtpRlTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRlTable", "done.\n"));
}

/*
 * store_mtpRlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRlTable", "storing data...  "));

	refresh_mtpRlTable();

	for (hcindex = mtpRlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRlTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRlTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRlTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRlIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRlProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRlRtDefault, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRlRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRlLsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRlRsCost, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRlAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRlOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRlCongState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRlCongLevel, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRlStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRtProfileTable_add(): adds a structure node to our data set 
 */
int
mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpRtProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtProfileIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfileName, &StorageTmp->mtpRtProfileNameLen);
	if (StorageTmp->mtpRtProfileName == NULL) {
		config_perror("invalid specification for mtpRtProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT10, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileStatus, &tmpint);

	mtpRtProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
}

/*
 * store_mtpRtProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtProfileTable", "storing data...  "));

	refresh_mtpRtProfileTable();

	for (hcindex = mtpRtProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRtProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfileName, &StorageTmp->mtpRtProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT10, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpRtTable_add(): adds a structure node to our data set 
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpRtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtIndex, sizeof(thedata->mtpRtIndex));

	header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLkIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlSlot, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtStatus, &tmpint);

	mtpRtTable_add(StorageTmp);

	DEBUGMSGTL(("mtpRtTable", "done.\n"));
}

/*
 * store_mtpRtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtTable", "storing data...  "));

	refresh_mtpRtTable();

	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpRtTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLkIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlSlot, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLsTable_add(): adds a structure node to our data set 
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsIndex, sizeof(thedata->mtpLsIndex));

	header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsLkDefault, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsCurrentCapacity, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumNormActSls, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAlarmSeverityAssignment, &StorageTmp->mtpLsAlarmSeverityAssignmentLen);
	if (StorageTmp->mtpLsAlarmSeverityAssignment == NULL) {
		config_perror("invalid specification for mtpLsAlarmSeverityAssignment");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
	if (StorageTmp->mtpLsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsStatus, &tmpint);

	mtpLsTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLsTable", "done.\n"));
}

/*
 * store_mtpLsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsTable", "storing data...  "));

	refresh_mtpLsTable();

	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLsTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsLkDefault, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumNormActSls, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAlarmSeverityAssignment, &StorageTmp->mtpLsAlarmSeverityAssignmentLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLkProfileTable_add(): adds a structure node to our data set 
 */
int
mtpLkProfileTable_add(struct mtpLkProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLkProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	header_complex_add_data(&mtpLkProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLkProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLkProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLkProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLkProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLkProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLkProfileTable_data);

	DEBUGMSGTL(("mtpLkProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkProfileIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT7, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT19, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT21, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT25A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT28A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT29A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileTimerT30A, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkProfileSlDefault, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkProfileStatus, &tmpint);

	mtpLkProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLkProfileTable", "done.\n"));
}

/*
 * store_mtpLkProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLkProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLkProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLkProfileTable", "storing data...  "));

	refresh_mtpLkProfileTable();

	for (hcindex = mtpLkProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLkProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLkProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLkProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT7, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT19, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT21, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT25A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT28A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT29A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileTimerT30A, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkProfileSlDefault, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLkProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLkTable_add(): adds a structure node to our data set 
 */
int
mtpLkTable_add(struct mtpLkTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLkTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLkIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkIndex, sizeof(thedata->mtpLkIndex));

	header_complex_add_data(&mtpLkTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLkTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLkTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLkTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLkTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLkTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLkTable_data);

	DEBUGMSGTL(("mtpLkTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLkName, &StorageTmp->mtpLkNameLen);
	if (StorageTmp->mtpLkName == NULL) {
		config_perror("invalid specification for mtpLkName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkSlDefault, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkLsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkRsIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLkAdjPc, &StorageTmp->mtpLkAdjPcLen);
	if (StorageTmp->mtpLkAdjPc == NULL) {
		config_perror("invalid specification for mtpLkAdjPc");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkMaxCapacity, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkCurrentCapacity, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkCongestionControlMethod, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkUsageState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLkAvailabilityStatus, &StorageTmp->mtpLkAvailabilityStatusLen);
	if (StorageTmp->mtpLkAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLkAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkPeriodicLinkTestFlag, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkPeriodicLinkTestFail, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLkInLsLoadSharingAlgorithm, &StorageTmp->mtpLkInLsLoadSharingAlgorithmLen);
	if (StorageTmp->mtpLkInLsLoadSharingAlgorithm == NULL) {
		config_perror("invalid specification for mtpLkInLsLoadSharingAlgorithm");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkNumberOfNormallyActiveSignLinks, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLkAlarmStatus, &StorageTmp->mtpLkAlarmStatusLen);
	if (StorageTmp->mtpLkAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLkAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLkAlarmSeverityAssignemnt, &StorageTmp->mtpLkAlarmSeverityAssignemntLen);
	if (StorageTmp->mtpLkAlarmSeverityAssignemnt == NULL) {
		config_perror("invalid specification for mtpLkAlarmSeverityAssignemnt");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkStatus, &tmpint);

	mtpLkTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLkTable", "done.\n"));
}

/*
 * store_mtpLkTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLkTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLkTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLkTable", "storing data...  "));

	refresh_mtpLkTable();

	for (hcindex = mtpLkTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLkTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLkTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLkTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLkName, &StorageTmp->mtpLkNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkSlDefault, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkLsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkRsIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLkAdjPc, &StorageTmp->mtpLkAdjPcLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkMaxCapacity, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkCurrentCapacity, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkCongestionControlMethod, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkUsageState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLkAvailabilityStatus, &StorageTmp->mtpLkAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkPeriodicLinkTestFlag, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkPeriodicLinkTestFail, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLkInLsLoadSharingAlgorithm, &StorageTmp->mtpLkInLsLoadSharingAlgorithmLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkNumberOfNormallyActiveSignLinks, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLkAlarmStatus, &StorageTmp->mtpLkAlarmStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLkAlarmSeverityAssignemnt, &StorageTmp->mtpLkAlarmSeverityAssignemntLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLkTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLkCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpLkCurrentTable_add(struct mtpLkCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLkCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLkIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkIndex, sizeof(thedata->mtpLkIndex));

	header_complex_add_data(&mtpLkCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLkCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLkCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLkCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLkCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLkCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLkCurrentTable_data);

	DEBUGMSGTL(("mtpLkCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLkCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLkCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLkCurrentSlsUnavailable, &tmpint);

	mtpLkCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLkCurrentTable", "done.\n"));
}

/*
 * store_mtpLkCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLkCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLkCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLkCurrentTable", "storing data...  "));

	refresh_mtpLkCurrentTable();

	for (hcindex = mtpLkCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLkCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLkCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLkCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLkCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLkCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLkCurrentSlsUnavailable, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLkCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLkInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpLkInt5minTable_add(struct mtpLkInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLkInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLkIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkIndex, sizeof(thedata->mtpLkIndex));
	/* mtpLkInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkInt5minInterval, sizeof(thedata->mtpLkInt5minInterval));
	/* mtpLkInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkInt5minInterval, sizeof(thedata->mtpLkInt5minInterval));
	/* mtpLkInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkInt5minInterval, sizeof(thedata->mtpLkInt5minInterval));
	/* mtpLkInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkInt5minInterval, sizeof(thedata->mtpLkInt5minInterval));
	/* mtpLkInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkInt5minInterval, sizeof(thedata->mtpLkInt5minInterval));

	header_complex_add_data(&mtpLkInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLkInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLkInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLkInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLkInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLkInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLkInt5minTable_data);

	DEBUGMSGTL(("mtpLkInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkInt5minInterval, &tmpint);

	mtpLkInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLkInt5minTable", "done.\n"));
}

/*
 * store_mtpLkInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLkInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLkInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLkInt5minTable", "storing data...  "));

	refresh_mtpLkInt5minTable();

	for (hcindex = mtpLkInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLkInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLkInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLkInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkInt5minInterval, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLkInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpLkInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpLkInt15minTable_add(struct mtpLkInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLkInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpLkIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkIndex, sizeof(thedata->mtpLkIndex));
	/* mtpLkInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLkInt15minInterval, sizeof(thedata->mtpLkInt15minInterval));

	header_complex_add_data(&mtpLkInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLkInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpLkInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLkInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLkInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLkInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLkInt15minTable_data);

	DEBUGMSGTL(("mtpLkInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLkInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLkInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLkInt15minAdjacentInaccessibleEvents, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLkInt15minAdjacentInaccessibleDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLkInt15minSlsUnavailable, &tmpint);

	mtpLkInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpLkInt15minTable", "done.\n"));
}

/*
 * store_mtpLkInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLkInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLkInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLkInt15minTable", "storing data...  "));

	refresh_mtpLkInt15minTable();

	for (hcindex = mtpLkInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLkInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpLkInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpLkInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLkInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLkInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLkInt15minAdjacentInaccessibleEvents, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLkInt15minAdjacentInaccessibleDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLkInt15minSlsUnavailable, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLkInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlProfileTable_add(): adds a structure node to our data set 
 */
int
mtpSlProfileTable_add(struct mtpSlProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlProfileIndex, sizeof(thedata->mtpSlProfileIndex));

	header_complex_add_data(&mtpSlProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlProfileTable_data);

	DEBUGMSGTL(("mtpSlProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlProfileIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlProfileName, &StorageTmp->mtpSlProfileNameLen);
	if (StorageTmp->mtpSlProfileName == NULL) {
		config_perror("invalid specification for mtpSlProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT17, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT19A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT22, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT23, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT24, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT31A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT32A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT33A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT34A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT2T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileTimerT1S, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlProfileL2Default, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlProfileStatus, &tmpint);

	mtpSlProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlProfileTable", "done.\n"));
}

/*
 * store_mtpSlProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlProfileTable", "storing data...  "));

	refresh_mtpSlProfileTable();

	for (hcindex = mtpSlProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlProfileName, &StorageTmp->mtpSlProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT17, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT19A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT22, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT23, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT24, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT31A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT32A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT33A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT34A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT2T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileTimerT1S, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlProfileL2Default, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlTable_add(): adds a structure node to our data set 
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlIndex, sizeof(thedata->mtpSlIndex));

	header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlProfile, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2Default, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlLkIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacity, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCurrentCapacity, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlLinkStatus, &StorageTmp->mtpSlLinkStatusLen);
	if (StorageTmp->mtpSlLinkStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAlarmSeverityAssignment, &StorageTmp->mtpSlAlarmSeverityAssignmentLen);
	if (StorageTmp->mtpSlAlarmSeverityAssignment == NULL) {
		config_perror("invalid specification for mtpSlAlarmSeverityAssignment");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
	if (StorageTmp->mtpSlAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSlAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlStatus, &tmpint);

	mtpSlTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlTable", "done.\n"));
}

/*
 * store_mtpSlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlTable", "storing data...  "));

	refresh_mtpSlTable();

	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlProfile, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2Default, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlLkIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacity, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCurrentCapacity, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlLinkStatus, &StorageTmp->mtpSlLinkStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAlarmSeverityAssignment, &StorageTmp->mtpSlAlarmSeverityAssignmentLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlSdlListTable_add(): adds a structure node to our data set 
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdlListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpLsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsIndex, sizeof(thedata->mtpLsIndex));
	/* mtpSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlCode, sizeof(thedata->mtpSlCode));
	/* mtpSlSdlListIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdlListIndex, sizeof(thedata->mtpSlSdlListIndex));

	header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdlListTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdlListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlSdlListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListIndex, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListStatus, &tmpint);

	mtpSlSdlListTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
}

/*
 * store_mtpSlSdlListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdlListTable", "storing data...  "));

	refresh_mtpSlSdlListTable();

	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlSdlListTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlSdlListTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListIndex, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlSdtListTable_add(): adds a structure node to our data set 
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdtListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpIndex, sizeof(thedata->mtpSpIndex));
	/* mtpLsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsIndex, sizeof(thedata->mtpLsIndex));
	/* mtpSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlCode, sizeof(thedata->mtpSlCode));
	/* mtpSlSdtListIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdtListIndex, sizeof(thedata->mtpSlSdtListIndex));

	header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdtListTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdtListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlSdtListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListIndex, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListStatus, &tmpint);

	mtpSlSdtListTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
}

/*
 * store_mtpSlSdtListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdtListTable", "storing data...  "));

	refresh_mtpSlSdtListTable();

	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlSdtListTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlSdtListTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListIndex, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlCurrentTable_add(): adds a structure node to our data set 
 */
int
mtpSlCurrentTable_add(struct mtpSlCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlIndex, sizeof(thedata->mtpSlIndex));

	header_complex_add_data(&mtpSlCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlCurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlCurrentTable_data);

	DEBUGMSGTL(("mtpSlCurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlCurrentRestorations, &tmpint);

	mtpSlCurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlCurrentTable", "done.\n"));
}

/*
 * store_mtpSlCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlCurrentTable", "storing data...  "));

	refresh_mtpSlCurrentTable();

	for (hcindex = mtpSlCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlCurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlCurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlCurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlCurrentRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlInt5minTable_add(): adds a structure node to our data set 
 */
int
mtpSlInt5minTable_add(struct mtpSlInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlIndex, sizeof(thedata->mtpSlIndex));
	/* mtpSlInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlInt5minInterval, sizeof(thedata->mtpSlInt5minInterval));

	header_complex_add_data(&mtpSlInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlInt5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlInt5minTable_data);

	DEBUGMSGTL(("mtpSlInt5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt5minRestorations, &tmpint);

	mtpSlInt5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlInt5minTable", "done.\n"));
}

/*
 * store_mtpSlInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlInt5minTable", "storing data...  "));

	refresh_mtpSlInt5minTable();

	for (hcindex = mtpSlInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlInt5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlInt5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlInt5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt5minRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSlInt15minTable_add(): adds a structure node to our data set 
 */
int
mtpSlInt15minTable_add(struct mtpSlInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSlIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlIndex, sizeof(thedata->mtpSlIndex));
	/* mtpSlInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlInt15minInterval, sizeof(thedata->mtpSlInt15minInterval));

	header_complex_add_data(&mtpSlInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlInt15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSlInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlInt15minTable_data);

	DEBUGMSGTL(("mtpSlInt15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlInt15minRestorations, &tmpint);

	mtpSlInt15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSlInt15minTable", "done.\n"));
}

/*
 * store_mtpSlInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlInt15minTable", "storing data...  "));

	refresh_mtpSlInt15minTable();

	for (hcindex = mtpSlInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlInt15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSlInt15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlInt15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlInt15minRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL2ProfileTable_add(): adds a structure node to our data set 
 */
int
mtpL2ProfileTable_add(struct mtpL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL2ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2ProfileIndex, sizeof(thedata->mtpL2ProfileIndex));
	/* mtpL2ProfileTransmissionRate */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpL2ProfileTransmissionRate, sizeof(thedata->mtpL2ProfileTransmissionRate));

	header_complex_add_data(&mtpL2ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL2ProfileTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL2ProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL2ProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL2ProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL2ProfileTable_data);

	DEBUGMSGTL(("mtpL2ProfileTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2ProfileName, &StorageTmp->mtpL2ProfileNameLen);
	if (StorageTmp->mtpL2ProfileName == NULL) {
		config_perror("invalid specification for mtpL2ProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT2L, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT2H, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT4N, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT4E, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileTimerT7, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileM, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileN1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileN2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileRbAccept, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileRbDiscard, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileRbAbate, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbAbate0, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbOnset0, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbDiscard0, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbAbate1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbOnset1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbDiscard1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbAbate2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbOnset2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileTbDiscard2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2ProfileStatus, &tmpint);

	mtpL2ProfileTable_add(StorageTmp);

	DEBUGMSGTL(("mtpL2ProfileTable", "done.\n"));
}

/*
 * store_mtpL2ProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL2ProfileTable", "storing data...  "));

	refresh_mtpL2ProfileTable();

	for (hcindex = mtpL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL2ProfileTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL2ProfileTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL2ProfileTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2ProfileName, &StorageTmp->mtpL2ProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT2L, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT2H, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT4N, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT4E, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileTimerT7, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileM, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileN1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileN2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileRbAccept, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileRbDiscard, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileRbAbate, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbAbate0, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbOnset0, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbDiscard0, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbAbate1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbOnset1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbDiscard1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbAbate2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbOnset2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileTbDiscard2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2ProfileStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpNbandTable_add(): adds a structure node to our data set 
 */
int
mtpNbandTable_add(struct mtpNbandTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNbandTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2ProfileIndex, sizeof(thedata->mtpL2ProfileIndex));

	header_complex_add_data(&mtpNbandTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNbandTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpNbandTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNbandTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNbandTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNbandTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNbandTable_data);

	DEBUGMSGTL(("mtpNbandTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbandTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbandStatus, &tmpint);

	mtpNbandTable_add(StorageTmp);

	DEBUGMSGTL(("mtpNbandTable", "done.\n"));
}

/*
 * store_mtpNbandTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbandTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNbandTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNbandTable", "storing data...  "));

	refresh_mtpNbandTable();

	for (hcindex = mtpNbandTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbandTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpNbandTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpNbandTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbandTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbandStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNbandTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSaalTable_add(): adds a structure node to our data set 
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSaalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2ProfileIndex, sizeof(thedata->mtpL2ProfileIndex));

	header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSaalTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSaalTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSaalTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalStatus, &tmpint);

	mtpSaalTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
}

/*
 * store_mtpSaalTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSaalTable", "storing data...  "));

	refresh_mtpSaalTable();

	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSaalTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSaalTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpM2paTable_add(): adds a structure node to our data set 
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2paTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2ProfileIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2ProfileIndex, sizeof(thedata->mtpL2ProfileIndex));

	header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2paTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpM2paTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpM2paTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2ProfileIndex, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paStatus, &tmpint);

	mtpM2paTable_add(StorageTmp);

	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
}

/*
 * store_mtpM2paTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2paTable", "storing data...  "));

	refresh_mtpM2paTable();

	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpM2paTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpM2paTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2ProfileIndex, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL2Table_add(): adds a structure node to our data set 
 */
int
mtpL2Table_add(struct mtpL2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL2Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2Index */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2Index, sizeof(thedata->mtpL2Index));

	header_complex_add_data(&mtpL2TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL2Table", "registered an entry\n"));

	DEBUGMSGTL(("mtpL2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL2Table():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL2Table(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL2Table_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL2Table_data);

	DEBUGMSGTL(("mtpL2Table", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2Index, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL2Name, &StorageTmp->mtpL2NameLen);
	if (StorageTmp->mtpL2Name == NULL) {
		config_perror("invalid specification for mtpL2Name");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2Profile, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2Status, &tmpint);

	mtpL2Table_add(StorageTmp);

	DEBUGMSGTL(("mtpL2Table", "done.\n"));
}

/*
 * store_mtpL2Table():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL2Table", "storing data...  "));

	refresh_mtpL2Table();

	for (hcindex = mtpL2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL2Table_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL2TableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL2Table ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2Index, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL2Name, &StorageTmp->mtpL2NameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2Profile, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2Status, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL2Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL2CurrentTable_add(): adds a structure node to our data set 
 */
int
mtpL2CurrentTable_add(struct mtpL2CurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL2CurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2Index */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2Index, sizeof(thedata->mtpL2Index));

	header_complex_add_data(&mtpL2CurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL2CurrentTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpL2CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL2CurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL2CurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL2CurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL2CurrentTable_data);

	DEBUGMSGTL(("mtpL2CurrentTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2Index, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL2CurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpL2CurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentSlInServiceDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentSlAlignment, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentSignUnitsReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentNegAckReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentTransmittedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentRetransmittedOctets, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentTransmittedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentReceivedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2CurrentReceivedMSUs, &tmpint);

	mtpL2CurrentTable_add(StorageTmp);

	DEBUGMSGTL(("mtpL2CurrentTable", "done.\n"));
}

/*
 * store_mtpL2CurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL2CurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL2CurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL2CurrentTable", "storing data...  "));

	refresh_mtpL2CurrentTable();

	for (hcindex = mtpL2CurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL2CurrentTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL2CurrentTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL2CurrentTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2Index, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL2CurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpL2CurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentSlInServiceDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentSlAlignment, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentSignUnitsReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentNegAckReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentTransmittedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentRetransmittedOctets, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentTransmittedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentReceivedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2CurrentReceivedMSUs, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL2CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL2Int5minTable_add(): adds a structure node to our data set 
 */
int
mtpL2Int5minTable_add(struct mtpL2Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL2Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2Int5minInterval, sizeof(thedata->mtpL2Int5minInterval));

	header_complex_add_data(&mtpL2Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL2Int5minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL2Int5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL2Int5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL2Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL2Int5minTable_data);

	DEBUGMSGTL(("mtpL2Int5minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2Int5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpL2Int5minTimestamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minSlInServiceDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minSlAlignment, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minSignUnitsReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minNegAckReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minTransmittedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minRetransmittedOctets, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minTransmittedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minReceivedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int5minReceivedMSUs, &tmpint);

	mtpL2Int5minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpL2Int5minTable", "done.\n"));
}

/*
 * store_mtpL2Int5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL2Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL2Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL2Int5minTable", "storing data...  "));

	refresh_mtpL2Int5minTable();

	for (hcindex = mtpL2Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL2Int5minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL2Int5minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL2Int5minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2Int5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpL2Int5minTimestamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minSlInServiceDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minSlAlignment, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minSignUnitsReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minNegAckReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minTransmittedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minRetransmittedOctets, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minTransmittedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minReceivedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int5minReceivedMSUs, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpL2Int15minTable_add(): adds a structure node to our data set 
 */
int
mtpL2Int15minTable_add(struct mtpL2Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL2Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpL2Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL2Int15minInterval, sizeof(thedata->mtpL2Int15minInterval));

	header_complex_add_data(&mtpL2Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL2Int15minTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL2Int15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL2Int15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL2Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL2Int15minTable_data);

	DEBUGMSGTL(("mtpL2Int15minTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL2Int15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpL2Int15minTimestamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minSlInServiceDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minSlAlignment, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minSignUnitsReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minNegAckReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minTransmittedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minRetransmittedOctets, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minTransmittedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minReceivedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpL2Int15minReceivedMSUs, &tmpint);

	mtpL2Int15minTable_add(StorageTmp);

	DEBUGMSGTL(("mtpL2Int15minTable", "done.\n"));
}

/*
 * store_mtpL2Int15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL2Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL2Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL2Int15minTable", "storing data...  "));

	refresh_mtpL2Int15minTable();

	for (hcindex = mtpL2Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL2Int15minTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpL2Int15minTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpL2Int15minTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL2Int15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpL2Int15minTimestamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minSlInServiceDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minSlAlignment, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minSignUnitsReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minNegAckReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minTransmittedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minRetransmittedOctets, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minTransmittedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minReceivedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpL2Int15minReceivedMSUs, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSdtTable_add(): adds a structure node to our data set 
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSdtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtIndex, sizeof(thedata->mtpSdtIndex));

	header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtIndex, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
	if (StorageTmp->mtpSdtProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSdtProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
	if (StorageTmp->mtpSdtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtStatus, &tmpint);

	mtpSdtTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
}

/*
 * store_mtpSdtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtTable", "storing data...  "));

	refresh_mtpSdtTable();

	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSdtTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdtTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtIndex, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/* 
 * mtpSdlTable_add(): adds a structure node to our data set 
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */

	/* mtpSdlIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdlIndex, sizeof(thedata->mtpSdlIndex));

	header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlTable", "registered an entry\n"));

	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "parsing config...  "));

	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlIndex, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperationalState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlCIC, &StorageTmp->mtpSdlCICLen);
	if (StorageTmp->mtpSdlCIC == NULL) {
		config_perror("invalid specification for mtpSdlCIC");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlStmChannel, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpint);

	mtpSdlTable_add(StorageTmp);

	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
}

/*
 * store_mtpSdlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlTable", "storing data...  "));

	refresh_mtpSdlTable();

	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;

/*   XXX:  if (StorageTmp->mtpSdlTableStorageType == ST_NONVOLATILE) { */

		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdlTable ");
		cptr = line + strlen(line);

		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlIndex, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlCIC, &StorageTmp->mtpSdlCICLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlStmChannel, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpMtTable(): refresh mtpMtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpMtTable(void)
{
	if (mtpMtTable_refresh == 0)
		return;
	mtpMtTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpMtTable_row(): refresh mtpMtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpMtTable_row(struct mtpMtTable_data *StorageTmp)
{
	if (StorageTmp->mtpMtTable_request == sa_request)
		return;
	StorageTmp->mtpMtTable_request = sa_request;
}

/*
 * var_mtpMtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpMtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpMtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpMtTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpMtTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpMtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpMtTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPMTNAME:
		*write_method = write_mtpMtName;
		*var_len = StorageTmp->mtpMtNameLen;
		return (u_char *) StorageTmp->mtpMtName;

	case MTPMTSPINDEX:
		*write_method = write_mtpMtSpIndex;
		*var_len = sizeof(StorageTmp->mtpMtSpIndex);
		return (u_char *) &StorageTmp->mtpMtSpIndex;

	case MTPMTUSERPART:
		*write_method = write_mtpMtUserPart;
		*var_len = sizeof(StorageTmp->mtpMtUserPart);
		return (u_char *) &StorageTmp->mtpMtUserPart;

	case MTPMTUSERPARTSTATUS:
		*write_method = write_mtpMtUserPartStatus;
		*var_len = sizeof(StorageTmp->mtpMtUserPartStatus);
		return (u_char *) &StorageTmp->mtpMtUserPartStatus;

	case MTPMTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMtUsageState);
		return (u_char *) &StorageTmp->mtpMtUsageState;

	case MTPMTALARMSEVERITYASSIGNMENT:
		*write_method = write_mtpMtAlarmSeverityAssignment;
		*var_len = StorageTmp->mtpMtAlarmSeverityAssignmentLen;
		return (u_char *) StorageTmp->mtpMtAlarmSeverityAssignment;

	case MTPMTLONGMESSAGESUPPORTED:
		*write_method = write_mtpMtLongMessageSupported;
		*var_len = sizeof(StorageTmp->mtpMtLongMessageSupported);
		return (u_char *) &StorageTmp->mtpMtLongMessageSupported;

	case MTPMTSTATUS:
		*write_method = write_mtpMtStatus;
		*var_len = sizeof(StorageTmp->mtpMtStatus);
		return (u_char *) &StorageTmp->mtpMtStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpMsTable(): refresh mtpMsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpMsTable(void)
{
	if (mtpMsTable_refresh == 0)
		return;
	mtpMsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpMsTable_row(): refresh mtpMsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	if (StorageTmp->mtpMsTable_request == sa_request)
		return;
	StorageTmp->mtpMsTable_request = sa_request;
}

/*
 * var_mtpMsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpMsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpMsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpMsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpMsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpMsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPMSNAME:
		*write_method = write_mtpMsName;
		*var_len = StorageTmp->mtpMsNameLen;
		return (u_char *) StorageTmp->mtpMsName;

	case MTPMSALARMSTATUS:
		*write_method = write_mtpMsAlarmStatus;
		*var_len = StorageTmp->mtpMsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpMsAlarmStatus;

	case MTPMSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsOperationalState);
		return (u_char *) &StorageTmp->mtpMsOperationalState;

	case MTPMSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsUsageState);
		return (u_char *) &StorageTmp->mtpMsUsageState;

	case MTPMSMANAGEDELEMENTTYPE:
		*write_method = write_mtpMsManagedElementType;
		*var_len = StorageTmp->mtpMsManagedElementTypeLen;
		return (u_char *) StorageTmp->mtpMsManagedElementType;

	case MTPMSMODELCODE:
		*write_method = write_mtpMsModelCode;
		*var_len = StorageTmp->mtpMsModelCodeLen;
		return (u_char *) StorageTmp->mtpMsModelCode;

	case MTPMSVENDORNAME:
		*write_method = write_mtpMsVendorName;
		*var_len = StorageTmp->mtpMsVendorNameLen;
		return (u_char *) StorageTmp->mtpMsVendorName;

	case MTPMSUSERLABEL:
		*write_method = write_mtpMsUserLabel;
		*var_len = StorageTmp->mtpMsUserLabelLen;
		return (u_char *) StorageTmp->mtpMsUserLabel;

	case MTPMSVERSION:
		*write_method = write_mtpMsVersion;
		*var_len = StorageTmp->mtpMsVersionLen;
		return (u_char *) StorageTmp->mtpMsVersion;

	case MTPMSALARMSEVERITYASSIGNMENT:
		*write_method = write_mtpMsAlarmSeverityAssignment;
		*var_len = StorageTmp->mtpMsAlarmSeverityAssignmentLen;
		return (u_char *) StorageTmp->mtpMsAlarmSeverityAssignment;

	case MTPMSNETWORKELEMENTALIASES:
		*write_method = write_mtpMsNetworkElementAliases;
		*var_len = StorageTmp->mtpMsNetworkElementAliasesLen;
		return (u_char *) StorageTmp->mtpMsNetworkElementAliases;

	case MTPMSSTATUS:
		*write_method = write_mtpMsStatus;
		*var_len = sizeof(StorageTmp->mtpMsStatus);
		return (u_char *) &StorageTmp->mtpMsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNaProfileTable(): refresh mtpNaProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNaProfileTable(void)
{
	if (mtpNaProfileTable_refresh == 0)
		return;
	mtpNaProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpNaProfileTable_row(): refresh mtpNaProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNaProfileTable_row(struct mtpNaProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpNaProfileTable_request == sa_request)
		return;
	StorageTmp->mtpNaProfileTable_request = sa_request;
}

/*
 * var_mtpNaProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpNaProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpNaProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpNaProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNaProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpNaProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPNAPROFILENAME:
		*write_method = write_mtpNaProfileName;
		*var_len = StorageTmp->mtpNaProfileNameLen;
		return (u_char *) StorageTmp->mtpNaProfileName;

	case MTPNAPROTOCOLVARIANT:
		*write_method = write_mtpNaProtocolVariant;
		*var_len = StorageTmp->mtpNaProtocolVariantLen;
		return (u_char *) StorageTmp->mtpNaProtocolVariant;

	case MTPNAPROTOCOLYEAR:
		*write_method = write_mtpNaProtocolYear;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		return (u_char *) &StorageTmp->mtpNaProtocolYear;

	case MTPNAPROTOCOLOPTIONS:
		*write_method = write_mtpNaProtocolOptions;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		return (u_char *) StorageTmp->mtpNaProtocolOptions;

	case MTPNANETWORKINDICATOR:
		*write_method = write_mtpNaNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		return (u_char *) &StorageTmp->mtpNaNetworkIndicator;

	case MTPNAPOINTCODEFORMAT:
		*write_method = write_mtpNaPointCodeFormat;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		return (u_char *) StorageTmp->mtpNaPointCodeFormat;

	case MTPNAPOINTCODEFORMAT:
		*write_method = write_mtpNaPointCodeFormat;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		return (u_char *) StorageTmp->mtpNaPointCodeFormat;

	case MTPNAPROFILESTATUS:
		*write_method = write_mtpNaProfileStatus;
		*var_len = sizeof(StorageTmp->mtpNaProfileStatus);
		return (u_char *) &StorageTmp->mtpNaProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNaTable(): refresh mtpNaTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(void)
{
	if (mtpNaTable_refresh == 0)
		return;
	mtpNaTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpNaTable_row(): refresh mtpNaTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	if (StorageTmp->mtpNaTable_request == sa_request)
		return;
	StorageTmp->mtpNaTable_request = sa_request;
}

/*
 * var_mtpNaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpNaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpNaTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNaTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpNaTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPNANAME:
		*write_method = write_mtpNaName;
		*var_len = StorageTmp->mtpNaNameLen;
		return (u_char *) StorageTmp->mtpNaName;

	case MTPNAPROFILE:
		*write_method = write_mtpNaProfile;
		*var_len = sizeof(StorageTmp->mtpNaProfile);
		return (u_char *) &StorageTmp->mtpNaProfile;

	case MTPNASPDEFAULT:
		*write_method = write_mtpNaSpDefault;
		*var_len = sizeof(StorageTmp->mtpNaSpDefault);
		return (u_char *) &StorageTmp->mtpNaSpDefault;

	case MTPNASTATUS:
		*write_method = write_mtpNaStatus;
		*var_len = sizeof(StorageTmp->mtpNaStatus);
		return (u_char *) &StorageTmp->mtpNaStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsTable(): refresh mtpGsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(void)
{
	if (mtpGsTable_refresh == 0)
		return;
	mtpGsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpGsTable_row(): refresh mtpGsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsTable_request == sa_request)
		return;
	StorageTmp->mtpGsTable_request = sa_request;
}

/*
 * var_mtpGsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpGsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpGsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpGsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPGSNAME:
		*write_method = write_mtpGsName;
		*var_len = StorageTmp->mtpGsNameLen;
		return (u_char *) StorageTmp->mtpGsName;

	case MTPGSADMINISTRATIVESTATE:
		*write_method = write_mtpGsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		return (u_char *) &StorageTmp->mtpGsAdministrativeState;

	case MTPGSTREATMENTOFOUTSIDERANGES:
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		return (u_char *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;

	case MTPGSLISTMODE:
		*write_method = write_mtpGsListMode;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		return (u_char *) &StorageTmp->mtpGsListMode;

	case MTPGSSCREENINGBYLINKSETORBYOPC:
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		return (u_char *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;

	case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		return (u_char *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;

	case MTPGSSTATUS:
		*write_method = write_mtpGsStatus;
		*var_len = sizeof(StorageTmp->mtpGsStatus);
		return (u_char *) &StorageTmp->mtpGsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsListTable(): refresh mtpGsListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsListTable(void)
{
	if (mtpGsListTable_refresh == 0)
		return;
	mtpGsListTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpGsListTable_row(): refresh mtpGsListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsListTable_row(struct mtpGsListTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsListTable_request == sa_request)
		return;
	StorageTmp->mtpGsListTable_request = sa_request;
}

/*
 * var_mtpGsListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpGsListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpGsListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpGsListTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsListTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpGsListTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPGSLISTOBJECT:
		*write_method = write_mtpGsListObject;
		*var_len = StorageTmp->mtpGsListObjectLen;
		return (u_char *) StorageTmp->mtpGsListObject;

	case MTPGSLISTCONTENT:
		*write_method = write_mtpGsListContent;
		*var_len = sizeof(StorageTmp->mtpGsListContent);
		return (u_char *) &StorageTmp->mtpGsListContent;

	case MTPGSLISTSTATUS:
		*write_method = write_mtpGsListStatus;
		*var_len = sizeof(StorageTmp->mtpGsListStatus);
		return (u_char *) &StorageTmp->mtpGsListStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsRuleTable(): refresh mtpGsRuleTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsRuleTable(void)
{
	if (mtpGsRuleTable_refresh == 0)
		return;
	mtpGsRuleTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpGsRuleTable_row(): refresh mtpGsRuleTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsRuleTable_row(struct mtpGsRuleTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsRuleTable_request == sa_request)
		return;
	StorageTmp->mtpGsRuleTable_request = sa_request;
}

/*
 * var_mtpGsRuleTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpGsRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpGsRuleTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpGsRuleTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsRuleTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsRuleTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpGsRuleTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPGSRULEDESIGNATEDDPCFIRST:
		*write_method = write_mtpGsRuleDesignatedDPCFirst;
		*var_len = StorageTmp->mtpGsRuleDesignatedDPCFirstLen;
		return (u_char *) StorageTmp->mtpGsRuleDesignatedDPCFirst;

	case MTPGSRULEDESIGNATEDDPCLAST:
		*write_method = write_mtpGsRuleDesignatedDPCLast;
		*var_len = StorageTmp->mtpGsRuleDesignatedDPCLastLen;
		return (u_char *) StorageTmp->mtpGsRuleDesignatedDPCLast;

	case MTPGSRULESIMASK:
		*write_method = write_mtpGsRuleSiMask;
		*var_len = StorageTmp->mtpGsRuleSiMaskLen;
		return (u_char *) StorageTmp->mtpGsRuleSiMask;

	case MTPGSRULEMESSAGETREATMENT:
		*write_method = write_mtpGsRuleMessageTreatment;
		*var_len = sizeof(StorageTmp->mtpGsRuleMessageTreatment);
		return (u_char *) &StorageTmp->mtpGsRuleMessageTreatment;

	case MTPGSRULECOMMENT:
		*write_method = write_mtpGsRuleComment;
		*var_len = StorageTmp->mtpGsRuleCommentLen;
		return (u_char *) StorageTmp->mtpGsRuleComment;

	case MTPGSRULESTATUS:
		*write_method = write_mtpGsRuleStatus;
		*var_len = sizeof(StorageTmp->mtpGsRuleStatus);
		return (u_char *) &StorageTmp->mtpGsRuleStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpProfileTable(): refresh mtpSpProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(void)
{
	if (mtpSpProfileTable_refresh == 0)
		return;
	mtpSpProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpProfileTable_row(): refresh mtpSpProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSpProfileTable_request = sa_request;
}

/*
 * var_mtpSpProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPPROFILENAME:
		*write_method = write_mtpSpProfileName;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		return (u_char *) StorageTmp->mtpSpProfileName;

	case MTPSPPROFILETIMERT1R:
		*write_method = write_mtpSpProfileTimerT1R;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1R);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT1R;

	case MTPSPPROFILETIMERT18:
		*write_method = write_mtpSpProfileTimerT18;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT18);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT18;

	case MTPSPPROFILETIMERT20:
		*write_method = write_mtpSpProfileTimerT20;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT20;

	case MTPSPPROFILETIMERT22A:
		*write_method = write_mtpSpProfileTimerT22A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT22A;

	case MTPSPPROFILETIMERT23A:
		*write_method = write_mtpSpProfileTimerT23A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT23A;

	case MTPSPPROFILETIMERT24A:
		*write_method = write_mtpSpProfileTimerT24A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT24A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT24A;

	case MTPSPPROFILETIMERT26A:
		*write_method = write_mtpSpProfileTimerT26A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT26A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT26A;

	case MTPSPPROFILETIMERT27A:
		*write_method = write_mtpSpProfileTimerT27A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT27A);
		return (u_char *) &StorageTmp->mtpSpProfileTimerT27A;

	case MTPSPPROFILERSDEFAULT:
		*write_method = write_mtpSpProfileRsDefault;
		*var_len = sizeof(StorageTmp->mtpSpProfileRsDefault);
		return (u_char *) &StorageTmp->mtpSpProfileRsDefault;

	case MTPSPPROFILELKDEFAULT:
		*write_method = write_mtpSpProfileLkDefault;
		*var_len = sizeof(StorageTmp->mtpSpProfileLkDefault);
		return (u_char *) &StorageTmp->mtpSpProfileLkDefault;

	case MTPSPPROFILESTATUS:
		*write_method = write_mtpSpProfileStatus;
		*var_len = sizeof(StorageTmp->mtpSpProfileStatus);
		return (u_char *) &StorageTmp->mtpSpProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpTable(): refresh mtpSpTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(void)
{
	if (mtpSpTable_refresh == 0)
		return;
	mtpSpTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpTable_row(): refresh mtpSpTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpTable_request == sa_request)
		return;
	StorageTmp->mtpSpTable_request = sa_request;
}

/*
 * var_mtpSpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPNAME:
		*write_method = write_mtpSpName;
		*var_len = StorageTmp->mtpSpNameLen;
		return (u_char *) StorageTmp->mtpSpName;

	case MTPSPMSINDEX:
		*write_method = write_mtpSpMsIndex;
		*var_len = sizeof(StorageTmp->mtpSpMsIndex);
		return (u_char *) &StorageTmp->mtpSpMsIndex;

	case MTPSPNAINDEX:
		*write_method = write_mtpSpNaIndex;
		*var_len = sizeof(StorageTmp->mtpSpNaIndex);
		return (u_char *) &StorageTmp->mtpSpNaIndex;

	case MTPSPPROFILE:
		*write_method = write_mtpSpProfile;
		*var_len = sizeof(StorageTmp->mtpSpProfile);
		return (u_char *) &StorageTmp->mtpSpProfile;

	case MTPSPRSDEFAULT:
		*write_method = write_mtpSpRsDefault;
		*var_len = sizeof(StorageTmp->mtpSpRsDefault);
		return (u_char *) &StorageTmp->mtpSpRsDefault;

	case MTPSPLKDEFAULT:
		*write_method = write_mtpSpLkDefault;
		*var_len = sizeof(StorageTmp->mtpSpLkDefault);
		return (u_char *) &StorageTmp->mtpSpLkDefault;

	case MTPSPPOINTCODE:
		*write_method = write_mtpSpPointCode;
		*var_len = StorageTmp->mtpSpPointCodeLen;
		return (u_char *) StorageTmp->mtpSpPointCode;

	case MTPSPTYPE:
		*write_method = write_mtpSpType;
		*var_len = sizeof(StorageTmp->mtpSpType);
		return (u_char *) &StorageTmp->mtpSpType;

	case MTPSPFLAGS:
		*write_method = write_mtpSpFlags;
		*var_len = StorageTmp->mtpSpFlagsLen;
		return (u_char *) StorageTmp->mtpSpFlags;

	case MTPSPUSERS:
		*write_method = write_mtpSpUsers;
		*var_len = StorageTmp->mtpSpUsersLen;
		return (u_char *) StorageTmp->mtpSpUsers;

	case MTPSPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		return (u_char *) &StorageTmp->mtpSpOperationalState;

	case MTPSPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSpProceduralStatus;

	case MTPSPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSpAvailabilityStatus;

	case MTPSPALARMSTATUS:
		*write_method = write_mtpSpAlarmStatus;
		*var_len = StorageTmp->mtpSpAlarmStatusLen;
		return (u_char *) StorageTmp->mtpSpAlarmStatus;

	case MTPSPSTATUS:
		*write_method = write_mtpSpStatus;
		*var_len = sizeof(StorageTmp->mtpSpStatus);
		return (u_char *) &StorageTmp->mtpSpStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpCurrentTable(): refresh mtpSpCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpCurrentTable(void)
{
	if (mtpSpCurrentTable_refresh == 0)
		return;
	mtpSpCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpCurrentTable_row(): refresh mtpSpCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpCurrentTable_row(struct mtpSpCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSpCurrentTable_request = sa_request;
}

/*
 * var_mtpSpCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpSpCurrentValidIntervals;

	case MTPSPCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSpCurrentTimeDiscontinuity;

	case MTPSPCURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSpCurrentDiscardedMSUs;

	case MTPSPCURRENTRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpSpCurrentReceivedTFCstatus0;

	case MTPSPCURRENTRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpSpCurrentReceivedTFCstatus1;

	case MTPSPCURRENTRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpSpCurrentReceivedTFCstatus2;

	case MTPSPCURRENTOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentOctetsXferred);
		return (u_char *) &StorageTmp->mtpSpCurrentOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt5minTable(): refresh mtpSpInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt5minTable(void)
{
	if (mtpSpInt5minTable_refresh == 0)
		return;
	mtpSpInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpInt5minTable_row(): refresh mtpSpInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt5minTable_row(struct mtpSpInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt5minTable_request = sa_request;
}

/*
 * var_mtpSpInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpInt5minTimeStamp;

	case MTPSPINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSpInt5minDiscardedMSUs;

	case MTPSPINT5MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpSpInt5minReceivedTFCstatus0;

	case MTPSPINT5MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpSpInt5minReceivedTFCstatus1;

	case MTPSPINT5MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpSpInt5minReceivedTFCstatus2;

	case MTPSPINT5MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minOctetsXferred);
		return (u_char *) &StorageTmp->mtpSpInt5minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt15minTable(): refresh mtpSpInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt15minTable(void)
{
	if (mtpSpInt15minTable_refresh == 0)
		return;
	mtpSpInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpInt15minTable_row(): refresh mtpSpInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt15minTable_row(struct mtpSpInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt15minTable_request = sa_request;
}

/*
 * var_mtpSpInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpInt15minTimeStamp;

	case MTPSPINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSpInt15minDiscardedMSUs;

	case MTPSPINT15MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus0);
		return (u_char *) &StorageTmp->mtpSpInt15minReceivedTFCstatus0;

	case MTPSPINT15MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus1);
		return (u_char *) &StorageTmp->mtpSpInt15minReceivedTFCstatus1;

	case MTPSPINT15MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus2);
		return (u_char *) &StorageTmp->mtpSpInt15minReceivedTFCstatus2;

	case MTPSPINT15MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minOctetsXferred);
		return (u_char *) &StorageTmp->mtpSpInt15minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiTable(): refresh mtpSpSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiTable(void)
{
	if (mtpSpSiTable_refresh == 0)
		return;
	mtpSpSiTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpSiTable_row(): refresh mtpSpSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiTable_row(struct mtpSpSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiTable_request = sa_request;
}

/*
 * var_mtpSpSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpSiTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpSiTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSIVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiValidIntervals);
		return (u_char *) &StorageTmp->mtpSpSiValidIntervals;

	case MTPSPSITIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSpSiTimeDiscontinuity;

	case MTPSPSITRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiTransmittedUPUnavailable;

	case MTPSPSIRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiReceivedUPUnavailable;

	case MTPSPSIHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpSpSiHandledOctetsSIO;

	case MTPSPSISTATUS:
		*write_method = write_mtpSpSiStatus;
		*var_len = sizeof(StorageTmp->mtpSpSiStatus);
		return (u_char *) &StorageTmp->mtpSpSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt5minTable(): refresh mtpSpSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt5minTable(void)
{
	if (mtpSpSiInt5minTable_refresh == 0)
		return;
	mtpSpSiInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpSiInt5minTable_row(): refresh mtpSpSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt5minTable_row(struct mtpSpSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt5minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpSiInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpSiInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpSiInt5minTimeStamp;

	case MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable;

	case MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable;

	case MTPSPSIINT5MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpSpSiInt5minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt15minTable(): refresh mtpSpSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt15minTable(void)
{
	if (mtpSpSiInt15minTable_refresh == 0)
		return;
	mtpSpSiInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpSiInt15minTable_row(): refresh mtpSpSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt15minTable_row(struct mtpSpSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt15minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpSiInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpSiInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpSiInt15minTimeStamp;

	case MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable;

	case MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minReceivedUPUnavailable);
		return (u_char *) &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable;

	case MTPSPSIINT15MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minHandledOctetsSIO);
		return (u_char *) &StorageTmp->mtpSpSiInt15minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyTable(): refresh mtpSpStudyTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyTable(void)
{
	if (mtpSpStudyTable_refresh == 0)
		return;
	mtpSpStudyTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyTable_row(): refresh mtpSpStudyTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyTable_row(struct mtpSpStudyTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyTable_request = sa_request;
}

/*
 * var_mtpSpStudyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpStudyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyValidIntervals);
		return (u_char *) &StorageTmp->mtpSpStudyValidIntervals;

	case MTPSPSTUDYTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSpStudyTimeDiscontinuity;

	case MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio;

	case MTPSPSTUDYHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio;

	case MTPSPSTUDYSTATUS:
		*write_method = write_mtpSpStudyStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyStatus);
		return (u_char *) &StorageTmp->mtpSpStudyStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt5minTable(): refresh mtpSpStudyInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt5minTable(void)
{
	if (mtpSpStudyInt5minTable_refresh == 0)
		return;
	mtpSpStudyInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyInt5minTable_row(): refresh mtpSpStudyInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt5minTable_row(struct mtpSpStudyInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt5minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpStudyInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSpStudyInt5minTimeStamp;

	case MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio;

	case MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt15minTable(): refresh mtpSpStudyInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt15minTable(void)
{
	if (mtpSpStudyInt15minTable_refresh == 0)
		return;
	mtpSpStudyInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyInt15minTable_row(): refresh mtpSpStudyInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt15minTable_row(struct mtpSpStudyInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt15minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpStudyInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYINT15MININTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minInterval);
		return (u_char *) &StorageTmp->mtpSpStudyInt15minInterval;

	case MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio;

	case MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio);
		return (u_char *) &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyMapTable(): refresh mtpSpStudyMapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyMapTable(void)
{
	if (mtpSpStudyMapTable_refresh == 0)
		return;
	mtpSpStudyMapTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSpStudyMapTable_row(): refresh mtpSpStudyMapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyMapTable_row(struct mtpSpStudyMapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyMapTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyMapTable_request = sa_request;
}

/*
 * var_mtpSpStudyMapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSpStudyMapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSpStudyMapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyMapTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyMapTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyMapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSpStudyMapTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSPSTUDYMAPSTATUS:
		*write_method = write_mtpSpStudyMapStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyMapStatus);
		return (u_char *) &StorageTmp->mtpSpStudyMapStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsProfileTable(): refresh mtpRsProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsProfileTable(void)
{
	if (mtpRsProfileTable_refresh == 0)
		return;
	mtpRsProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsProfileTable_row(): refresh mtpRsProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRsProfileTable_request = sa_request;
}

/*
 * var_mtpRsProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSPROFILENAME:
		*write_method = write_mtpRsProfileName;
		*var_len = StorageTmp->mtpRsProfileNameLen;
		return (u_char *) StorageTmp->mtpRsProfileName;

	case MTPRSPROFILETIMERT8:
		*write_method = write_mtpRsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT8);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT8;

	case MTPRSPROFILETIMERT11:
		*write_method = write_mtpRsProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT11);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT11;

	case MTPRSPROFILETIMERT15:
		*write_method = write_mtpRsProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT15);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT15;

	case MTPRSPROFILETIMERT16:
		*write_method = write_mtpRsProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT16);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT16;

	case MTPRSPROFILETIMERT18A:
		*write_method = write_mtpRsProfileTimerT18A;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT18A);
		return (u_char *) &StorageTmp->mtpRsProfileTimerT18A;

	case MTPRSPROFILERTDEFAULT:
		*write_method = write_mtpRsProfileRtDefault;
		*var_len = sizeof(StorageTmp->mtpRsProfileRtDefault);
		return (u_char *) &StorageTmp->mtpRsProfileRtDefault;

	case MTPRSPROFILESTATUS:
		*write_method = write_mtpRsProfileStatus;
		*var_len = sizeof(StorageTmp->mtpRsProfileStatus);
		return (u_char *) &StorageTmp->mtpRsProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsTable(): refresh mtpRsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(void)
{
	if (mtpRsTable_refresh == 0)
		return;
	mtpRsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsTable_row(): refresh mtpRsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsTable_request == sa_request)
		return;
	StorageTmp->mtpRsTable_request = sa_request;
}

/*
 * var_mtpRsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSNAME:
		*write_method = write_mtpRsName;
		*var_len = StorageTmp->mtpRsNameLen;
		return (u_char *) StorageTmp->mtpRsName;

	case MTPRSPROFILE:
		*write_method = write_mtpRsProfile;
		*var_len = sizeof(StorageTmp->mtpRsProfile);
		return (u_char *) &StorageTmp->mtpRsProfile;

	case MTPRSRTDEFAULT:
		*write_method = write_mtpRsRtDefault;
		*var_len = sizeof(StorageTmp->mtpRsRtDefault);
		return (u_char *) &StorageTmp->mtpRsRtDefault;

	case MTPRSADMINISTRATIVESTATE:
		*write_method = write_mtpRsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		return (u_char *) &StorageTmp->mtpRsAdministrativeState;

	case MTPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		return (u_char *) &StorageTmp->mtpRsOperationalState;

	case MTPRSALARMSEVERITYASSIGNMENT:
		*write_method = write_mtpRsAlarmSeverityAssignment;
		*var_len = StorageTmp->mtpRsAlarmSeverityAssignmentLen;
		return (u_char *) StorageTmp->mtpRsAlarmSeverityAssignment;

	case MTPRSCONGSTATE:
		*write_method = write_mtpRsCongState;
		*var_len = sizeof(StorageTmp->mtpRsCongState);
		return (u_char *) &StorageTmp->mtpRsCongState;

	case MTPRSCONGLEVEL:
		*write_method = write_mtpRsCongLevel;
		*var_len = sizeof(StorageTmp->mtpRsCongLevel);
		return (u_char *) &StorageTmp->mtpRsCongLevel;

	case MTPRSLOADSHARINGINFORMATION:
		*write_method = write_mtpRsLoadsharingInformation;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingInformation;

	case MTPRSLOADSHARINGOBJECT:
		*write_method = write_mtpRsLoadsharingObject;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRsLoadsharingObject;

	case MTPRSREMOTEEXCHANGELABEL:
		*write_method = write_mtpRsRemoteExchangeLabel;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		return (u_char *) StorageTmp->mtpRsRemoteExchangeLabel;

	case MTPRSALARMSTATUS:
		*write_method = write_mtpRsAlarmStatus;
		*var_len = StorageTmp->mtpRsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpRsAlarmStatus;

	case MTPRSSTATUS:
		*write_method = write_mtpRsStatus;
		*var_len = sizeof(StorageTmp->mtpRsStatus);
		return (u_char *) &StorageTmp->mtpRsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsCurrentTable(): refresh mtpRsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsCurrentTable(void)
{
	if (mtpRsCurrentTable_refresh == 0)
		return;
	mtpRsCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsCurrentTable_row(): refresh mtpRsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsCurrentTable_row(struct mtpRsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpRsCurrentTable_request = sa_request;
}

/*
 * var_mtpRsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSCURRENTVALIDINTERVALS:
		*write_method = write_mtpRsCurrentValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpRsCurrentValidIntervals;

	case MTPRSCURRENTTIMEDISCONTINUITY:
		*write_method = write_mtpRsCurrentTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpRsCurrentTimeDiscontinuity;

	case MTPRSCURRENTRECEIVEDOCTETSOPC:
		*write_method = write_mtpRsCurrentReceivedOctetsOPC;
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpRsCurrentReceivedOctetsOPC;

	case MTPRSCURRENTTRANSMITTEDOCTETSDPC:
		*write_method = write_mtpRsCurrentTransmittedOctetsDPC;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpRsCurrentTransmittedOctetsDPC;

	case MTPRSCURRENTRECEIVEDMSUSOPC:
		*write_method = write_mtpRsCurrentReceivedMSUsOpc;
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpRsCurrentReceivedMSUsOpc;

	case MTPRSCURRENTTRANSMITTEDMSUSDPC:
		*write_method = write_mtpRsCurrentTransmittedMSUsDpc;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpRsCurrentTransmittedMSUsDpc;

	case MTPRSCURRENTROUTESETUNAVAILABLE:
		*write_method = write_mtpRsCurrentRouteSetUnavailable;
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpRsCurrentRouteSetUnavailable;

	case MTPRSCURRENTROUTESETUNAVAILABLEDURATION:
		*write_method = write_mtpRsCurrentRouteSetUnavailableDuration;
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt5minTable(): refresh mtpRsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt5minTable(void)
{
	if (mtpRsInt5minTable_refresh == 0)
		return;
	mtpRsInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsInt5minTable_row(): refresh mtpRsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt5minTable_row(struct mtpRsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt5minTable_request = sa_request;
}

/*
 * var_mtpRsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsInt5minTimeStamp;

	case MTPRSINT5MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpRsInt5minReceivedOctetsOPC;

	case MTPRSINT5MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpRsInt5minTransmittedOctetsDPC;

	case MTPRSINT5MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpRsInt5minReceivedMSUsOpc;

	case MTPRSINT5MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpRsInt5minTransmittedMSUsDpc;

	case MTPRSINT5MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpRsInt5minRouteSetUnavailable;

	case MTPRSINT5MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt15minTable(): refresh mtpRsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt15minTable(void)
{
	if (mtpRsInt15minTable_refresh == 0)
		return;
	mtpRsInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsInt15minTable_row(): refresh mtpRsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt15minTable_row(struct mtpRsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt15minTable_request = sa_request;
}

/*
 * var_mtpRsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsInt15minTimeStamp;

	case MTPRSINT15MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedOctetsOPC);
		return (u_char *) &StorageTmp->mtpRsInt15minReceivedOctetsOPC;

	case MTPRSINT15MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedOctetsDPC);
		return (u_char *) &StorageTmp->mtpRsInt15minTransmittedOctetsDPC;

	case MTPRSINT15MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedMSUsOpc);
		return (u_char *) &StorageTmp->mtpRsInt15minReceivedMSUsOpc;

	case MTPRSINT15MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedMSUsDpc);
		return (u_char *) &StorageTmp->mtpRsInt15minTransmittedMSUsDpc;

	case MTPRSINT15MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailable);
		return (u_char *) &StorageTmp->mtpRsInt15minRouteSetUnavailable;

	case MTPRSINT15MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailableDuration);
		return (u_char *) &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiTable(): refresh mtpRsSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiTable(void)
{
	if (mtpRsSiTable_refresh == 0)
		return;
	mtpRsSiTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsSiTable_row(): refresh mtpRsSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiTable_row(struct mtpRsSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiTable_request = sa_request;
}

/*
 * var_mtpRsSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsSiTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsSiTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSSIVALIDINTERVALS:
		*write_method = write_mtpRsSiValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsSiValidIntervals);
		return (u_char *) &StorageTmp->mtpRsSiValidIntervals;

	case MTPRSSITIMEDISCONTINUITY:
		*write_method = write_mtpRsSiTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsSiTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpRsSiTimeDiscontinuity;

	case MTPRSSIRECEIVEDOCTETSOPCSIO:
		*write_method = write_mtpRsSiReceivedOctetsOpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiReceivedOctetsOpcSio;

	case MTPRSSITRANSMITTEDOCTETSDPCSIO:
		*write_method = write_mtpRsSiTransmittedOctetsDpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiTransmittedOctetsDpcSio;

	case MTPRSSIRECEIVEDMSUSOPCSIO:
		*write_method = write_mtpRsSiReceivedMSUsOpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiReceivedMSUsOpcSio;

	case MTPRSSITRANSMITTEDMSUSDPCSIO:
		*write_method = write_mtpRsSiTransmittedMSUsDpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiTransmittedMSUsDpcSio;

	case MTPRSSISTATUS:
		*write_method = write_mtpRsSiStatus;
		*var_len = sizeof(StorageTmp->mtpRsSiStatus);
		return (u_char *) &StorageTmp->mtpRsSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt5minTable(): refresh mtpRsSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt5minTable(void)
{
	if (mtpRsSiInt5minTable_refresh == 0)
		return;
	mtpRsSiInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsSiInt5minTable_row(): refresh mtpRsSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt5minTable_row(struct mtpRsSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt5minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsSiInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsSiInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTimeStamp;

	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTimeStamp;

	case MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio;

	case MTPRSSIINT5MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio;

	case MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt15minTable(): refresh mtpRsSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt15minTable(void)
{
	if (mtpRsSiInt15minTable_refresh == 0)
		return;
	mtpRsSiInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRsSiInt15minTable_row(): refresh mtpRsSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt15minTable_row(struct mtpRsSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt15minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRsSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRsSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsSiInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRsSiInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRSSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpRsSiInt15minTimeStamp;

	case MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio;

	case MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio;

	case MTPRSSIINT15MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio;

	case MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio);
		return (u_char *) &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRlTable(): refresh mtpRlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRlTable(void)
{
	if (mtpRlTable_refresh == 0)
		return;
	mtpRlTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRlTable_row(): refresh mtpRlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRlTable_row(struct mtpRlTable_data *StorageTmp)
{
	if (StorageTmp->mtpRlTable_request == sa_request)
		return;
	StorageTmp->mtpRlTable_request = sa_request;
}

/*
 * var_mtpRlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRlTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRlTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRlTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRLPROFILE:
		*write_method = write_mtpRlProfile;
		*var_len = sizeof(StorageTmp->mtpRlProfile);
		return (u_char *) &StorageTmp->mtpRlProfile;

	case MTPRLRTDEFAULT:
		*write_method = write_mtpRlRtDefault;
		*var_len = sizeof(StorageTmp->mtpRlRtDefault);
		return (u_char *) &StorageTmp->mtpRlRtDefault;

	case MTPRLRSINDEX:
		*write_method = write_mtpRlRsIndex;
		*var_len = sizeof(StorageTmp->mtpRlRsIndex);
		return (u_char *) &StorageTmp->mtpRlRsIndex;

	case MTPRLLSINDEX:
		*write_method = write_mtpRlLsIndex;
		*var_len = sizeof(StorageTmp->mtpRlLsIndex);
		return (u_char *) &StorageTmp->mtpRlLsIndex;

	case MTPRLRSCOST:
		*write_method = write_mtpRlRsCost;
		*var_len = sizeof(StorageTmp->mtpRlRsCost);
		return (u_char *) &StorageTmp->mtpRlRsCost;

	case MTPRLADMINISTRATIVESTATE:
		*write_method = write_mtpRlAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRlAdministrativeState);
		return (u_char *) &StorageTmp->mtpRlAdministrativeState;

	case MTPRLOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRlOperationalState);
		return (u_char *) &StorageTmp->mtpRlOperationalState;

	case MTPRLCONGSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRlCongState);
		return (u_char *) &StorageTmp->mtpRlCongState;

	case MTPRLCONGLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRlCongLevel);
		return (u_char *) &StorageTmp->mtpRlCongLevel;

	case MTPRLSTATUS:
		*write_method = write_mtpRlStatus;
		*var_len = sizeof(StorageTmp->mtpRlStatus);
		return (u_char *) &StorageTmp->mtpRlStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtProfileTable(): refresh mtpRtProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtProfileTable(void)
{
	if (mtpRtProfileTable_refresh == 0)
		return;
	mtpRtProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRtProfileTable_row(): refresh mtpRtProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRtProfileTable_request = sa_request;
}

/*
 * var_mtpRtProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRtProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRtProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRtProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRtProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRTPROFILENAME:
		*write_method = write_mtpRtProfileName;
		*var_len = StorageTmp->mtpRtProfileNameLen;
		return (u_char *) StorageTmp->mtpRtProfileName;

	case MTPRTPROFILETIMERT6:
		*write_method = write_mtpRtProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT6);
		return (u_char *) &StorageTmp->mtpRtProfileTimerT6;

	case MTPRTPROFILETIMERT10:
		*write_method = write_mtpRtProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT10);
		return (u_char *) &StorageTmp->mtpRtProfileTimerT10;

	case MTPRTPROFILESTATUS:
		*write_method = write_mtpRtProfileStatus;
		*var_len = sizeof(StorageTmp->mtpRtProfileStatus);
		return (u_char *) &StorageTmp->mtpRtProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtTable(): refresh mtpRtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(void)
{
	if (mtpRtTable_refresh == 0)
		return;
	mtpRtTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpRtTable_row(): refresh mtpRtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtTable_request == sa_request)
		return;
	StorageTmp->mtpRtTable_request = sa_request;
}

/*
 * var_mtpRtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRtTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpRtTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPRTNAME:
		*write_method = write_mtpRtName;
		*var_len = StorageTmp->mtpRtNameLen;
		return (u_char *) StorageTmp->mtpRtName;

	case MTPRTPROFILE:
		*write_method = write_mtpRtProfile;
		*var_len = sizeof(StorageTmp->mtpRtProfile);
		return (u_char *) &StorageTmp->mtpRtProfile;

	case MTPRTRLINDEX:
		*write_method = write_mtpRtRlIndex;
		*var_len = sizeof(StorageTmp->mtpRtRlIndex);
		return (u_char *) &StorageTmp->mtpRtRlIndex;

	case MTPRTLKINDEX:
		*write_method = write_mtpRtLkIndex;
		*var_len = sizeof(StorageTmp->mtpRtLkIndex);
		return (u_char *) &StorageTmp->mtpRtLkIndex;

	case MTPRTRLSLOT:
		*write_method = write_mtpRtRlSlot;
		*var_len = sizeof(StorageTmp->mtpRtRlSlot);
		return (u_char *) &StorageTmp->mtpRtRlSlot;

	case MTPRTADMINISTRATIVESTATE:
		*write_method = write_mtpRtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		return (u_char *) &StorageTmp->mtpRtAdministrativeState;

	case MTPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		return (u_char *) &StorageTmp->mtpRtOperationalState;

	case MTPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpRtAvailabilityStatus;

	case MTPRTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		return (u_char *) &StorageTmp->mtpRtUsageState;

	case MTPRTINCLSLOADSHARINGALGORITHM:
		*write_method = write_mtpRtInClsLoadsharingAlgorithm;
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		return (u_char *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;

	case MTPRTFIXEDPRIORITY:
		*write_method = write_mtpRtFixedPriority;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		return (u_char *) &StorageTmp->mtpRtFixedPriority;

	case MTPRTFLEXIBLEPRIORITY:
		*write_method = write_mtpRtFlexiblePriority;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		return (u_char *) &StorageTmp->mtpRtFlexiblePriority;

	case MTPRTPRIORITYMODE:
		*write_method = write_mtpRtPriorityMode;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		return (u_char *) &StorageTmp->mtpRtPriorityMode;

	case MTPRTLOADSHARINGINFORMATION:
		*write_method = write_mtpRtLoadsharingInformation;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingInformation;

	case MTPRTLOADSHARINGOBJECT:
		*write_method = write_mtpRtLoadsharingObject;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen;
		return (u_char *) StorageTmp->mtpRtLoadsharingObject;

	case MTPRTSLSLIST:
		*write_method = write_mtpRtSlsList;
		*var_len = StorageTmp->mtpRtSlsListLen;
		return (u_char *) StorageTmp->mtpRtSlsList;

	case MTPRTSTATUS:
		*write_method = write_mtpRtStatus;
		*var_len = sizeof(StorageTmp->mtpRtStatus);
		return (u_char *) &StorageTmp->mtpRtStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsTable(): refresh mtpLsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(void)
{
	if (mtpLsTable_refresh == 0)
		return;
	mtpLsTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLsTable_row(): refresh mtpLsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsTable_request == sa_request)
		return;
	StorageTmp->mtpLsTable_request = sa_request;
}

/*
 * var_mtpLsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLsTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLSNAME:
		*write_method = write_mtpLsName;
		*var_len = StorageTmp->mtpLsNameLen;
		return (u_char *) StorageTmp->mtpLsName;

	case MTPLSLKDEFAULT:
		*write_method = write_mtpLsLkDefault;
		*var_len = sizeof(StorageTmp->mtpLsLkDefault);
		return (u_char *) &StorageTmp->mtpLsLkDefault;

	case MTPLSADMINISTRATIVESTATE:
		*write_method = write_mtpLsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		return (u_char *) &StorageTmp->mtpLsAdministrativeState;

	case MTPLSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		return (u_char *) &StorageTmp->mtpLsOperationalState;

	case MTPLSAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpLsAvailabilityStatus;

	case MTPLSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		return (u_char *) &StorageTmp->mtpLsUsageState;

	case MTPLSADJPC:
		*write_method = write_mtpLsAdjPc;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		return (u_char *) StorageTmp->mtpLsAdjPc;

	case MTPLSMAXCAPACITY:
		*write_method = write_mtpLsMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		return (u_char *) &StorageTmp->mtpLsMaxCapacity;

	case MTPLSCURRENTCAPACITY:
		*write_method = write_mtpLsCurrentCapacity;
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		return (u_char *) &StorageTmp->mtpLsCurrentCapacity;

	case MTPLSCONGESTIONCONTROLMETHOD:
		*write_method = write_mtpLsCongestionControlMethod;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		return (u_char *) &StorageTmp->mtpLsCongestionControlMethod;

	case MTPLSPERIODICLINKTESTFLAG:
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		return (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFlag;

	case MTPLSINLSLOADSHAREALGORITHM:
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		return (u_char *) StorageTmp->mtpLsInLsLoadShareAlgorithm;

	case MTPLSNUMNORMACTSLS:
		*write_method = write_mtpLsNumNormActSls;
		*var_len = sizeof(StorageTmp->mtpLsNumNormActSls);
		return (u_char *) &StorageTmp->mtpLsNumNormActSls;

	case MTPLSALARMSEVERITYASSIGNMENT:
		*write_method = write_mtpLsAlarmSeverityAssignment;
		*var_len = StorageTmp->mtpLsAlarmSeverityAssignmentLen;
		return (u_char *) StorageTmp->mtpLsAlarmSeverityAssignment;

	case MTPLSALARMSTATUS:
		*write_method = write_mtpLsAlarmStatus;
		*var_len = StorageTmp->mtpLsAlarmStatusLen;
		return (u_char *) StorageTmp->mtpLsAlarmStatus;

	case MTPLSSTATUS:
		*write_method = write_mtpLsStatus;
		*var_len = sizeof(StorageTmp->mtpLsStatus);
		return (u_char *) &StorageTmp->mtpLsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLkProfileTable(): refresh mtpLkProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLkProfileTable(void)
{
	if (mtpLkProfileTable_refresh == 0)
		return;
	mtpLkProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLkProfileTable_row(): refresh mtpLkProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLkProfileTable_row(struct mtpLkProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpLkProfileTable_request == sa_request)
		return;
	StorageTmp->mtpLkProfileTable_request = sa_request;
}

/*
 * var_mtpLkProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpLkProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLkProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLkProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLkProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLkProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLKPROFILETIMERT7:
		*write_method = write_mtpLkProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT7);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT7;

	case MTPLKPROFILETIMERT19:
		*write_method = write_mtpLkProfileTimerT19;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT19);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT19;

	case MTPLKPROFILETIMERT21:
		*write_method = write_mtpLkProfileTimerT21;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT21);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT21;

	case MTPLKPROFILETIMERT25A:
		*write_method = write_mtpLkProfileTimerT25A;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT25A);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT25A;

	case MTPLKPROFILETIMERT28A:
		*write_method = write_mtpLkProfileTimerT28A;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT28A);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT28A;

	case MTPLKPROFILETIMERT29A:
		*write_method = write_mtpLkProfileTimerT29A;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT29A);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT29A;

	case MTPLKPROFILETIMERT30A:
		*write_method = write_mtpLkProfileTimerT30A;
		*var_len = sizeof(StorageTmp->mtpLkProfileTimerT30A);
		return (u_char *) &StorageTmp->mtpLkProfileTimerT30A;

	case MTPLKPROFILESLDEFAULT:
		*write_method = write_mtpLkProfileSlDefault;
		*var_len = sizeof(StorageTmp->mtpLkProfileSlDefault);
		return (u_char *) &StorageTmp->mtpLkProfileSlDefault;

	case MTPLKPROFILESTATUS:
		*write_method = write_mtpLkProfileStatus;
		*var_len = sizeof(StorageTmp->mtpLkProfileStatus);
		return (u_char *) &StorageTmp->mtpLkProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLkTable(): refresh mtpLkTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLkTable(void)
{
	if (mtpLkTable_refresh == 0)
		return;
	mtpLkTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLkTable_row(): refresh mtpLkTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLkTable_row(struct mtpLkTable_data *StorageTmp)
{
	if (StorageTmp->mtpLkTable_request == sa_request)
		return;
	StorageTmp->mtpLkTable_request = sa_request;
}

/*
 * var_mtpLkTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpLkTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLkTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLkTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLkTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLkTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLkTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLKNAME:
		*write_method = write_mtpLkName;
		*var_len = StorageTmp->mtpLkNameLen;
		return (u_char *) StorageTmp->mtpLkName;

	case MTPLKPROFILE:
		*write_method = write_mtpLkProfile;
		*var_len = sizeof(StorageTmp->mtpLkProfile);
		return (u_char *) &StorageTmp->mtpLkProfile;

	case MTPLKSLDEFAULT:
		*write_method = write_mtpLkSlDefault;
		*var_len = sizeof(StorageTmp->mtpLkSlDefault);
		return (u_char *) &StorageTmp->mtpLkSlDefault;

	case MTPLKLSINDEX:
		*write_method = write_mtpLkLsIndex;
		*var_len = sizeof(StorageTmp->mtpLkLsIndex);
		return (u_char *) &StorageTmp->mtpLkLsIndex;

	case MTPLKRSINDEX:
		*write_method = write_mtpLkRsIndex;
		*var_len = sizeof(StorageTmp->mtpLkRsIndex);
		return (u_char *) &StorageTmp->mtpLkRsIndex;

	case MTPLKADJPC:
		*write_method = write_mtpLkAdjPc;
		*var_len = StorageTmp->mtpLkAdjPcLen;
		return (u_char *) StorageTmp->mtpLkAdjPc;

	case MTPLKMAXCAPACITY:
		*write_method = write_mtpLkMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpLkMaxCapacity);
		return (u_char *) &StorageTmp->mtpLkMaxCapacity;

	case MTPLKCURRENTCAPACITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkCurrentCapacity);
		return (u_char *) &StorageTmp->mtpLkCurrentCapacity;

	case MTPLKCONGESTIONCONTROLMETHOD:
		*write_method = write_mtpLkCongestionControlMethod;
		*var_len = sizeof(StorageTmp->mtpLkCongestionControlMethod);
		return (u_char *) &StorageTmp->mtpLkCongestionControlMethod;

	case MTPLKUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkUsageState);
		return (u_char *) &StorageTmp->mtpLkUsageState;

	case MTPLKOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkOperationalState);
		return (u_char *) &StorageTmp->mtpLkOperationalState;

	case MTPLKAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpLkAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpLkAvailabilityStatus;

	case MTPLKPERIODICLINKTESTFLAG:
		*write_method = write_mtpLkPeriodicLinkTestFlag;
		*var_len = sizeof(StorageTmp->mtpLkPeriodicLinkTestFlag);
		return (u_char *) &StorageTmp->mtpLkPeriodicLinkTestFlag;

	case MTPLKPERIODICLINKTESTFAIL:
		*write_method = write_mtpLkPeriodicLinkTestFail;
		*var_len = sizeof(StorageTmp->mtpLkPeriodicLinkTestFail);
		return (u_char *) &StorageTmp->mtpLkPeriodicLinkTestFail;

	case MTPLKADMINISTRATIVESTATE:
		*write_method = write_mtpLkAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpLkAdministrativeState);
		return (u_char *) &StorageTmp->mtpLkAdministrativeState;

	case MTPLKINLSLOADSHARINGALGORITHM:
		*write_method = write_mtpLkInLsLoadSharingAlgorithm;
		*var_len = StorageTmp->mtpLkInLsLoadSharingAlgorithmLen;
		return (u_char *) StorageTmp->mtpLkInLsLoadSharingAlgorithm;

	case MTPLKNUMBEROFNORMALLYACTIVESIGNLINKS:
		*write_method = write_mtpLkNumberOfNormallyActiveSignLinks;
		*var_len = sizeof(StorageTmp->mtpLkNumberOfNormallyActiveSignLinks);
		return (u_char *) &StorageTmp->mtpLkNumberOfNormallyActiveSignLinks;

	case MTPLKALARMSTATUS:
		*write_method = write_mtpLkAlarmStatus;
		*var_len = StorageTmp->mtpLkAlarmStatusLen;
		return (u_char *) StorageTmp->mtpLkAlarmStatus;

	case MTPLKALARMSEVERITYASSIGNEMNT:
		*write_method = write_mtpLkAlarmSeverityAssignemnt;
		*var_len = StorageTmp->mtpLkAlarmSeverityAssignemntLen;
		return (u_char *) StorageTmp->mtpLkAlarmSeverityAssignemnt;

	case MTPLKSTATUS:
		*write_method = write_mtpLkStatus;
		*var_len = sizeof(StorageTmp->mtpLkStatus);
		return (u_char *) &StorageTmp->mtpLkStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLkCurrentTable(): refresh mtpLkCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLkCurrentTable(void)
{
	if (mtpLkCurrentTable_refresh == 0)
		return;
	mtpLkCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLkCurrentTable_row(): refresh mtpLkCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLkCurrentTable_row(struct mtpLkCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpLkCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpLkCurrentTable_request = sa_request;
}

/*
 * var_mtpLkCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpLkCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLkCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLkCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLkCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLkCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLkCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLKCURRENTVALIDINTERVALS:
		*write_method = write_mtpLkCurrentValidIntervals;
		*var_len = sizeof(StorageTmp->mtpLkCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpLkCurrentValidIntervals;

	case MTPLKCURRENTTIMEDISCONTINUITY:
		*write_method = write_mtpLkCurrentTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpLkCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpLkCurrentTimeDiscontinuity;

	case MTPLKCURRENTADJACENTINACCESSIBLEEVENTS:
		*write_method = write_mtpLkCurrentAdjacentInaccessibleEvents;
		*var_len = sizeof(StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents;

	case MTPLKCURRENTADJACENTINACCESSIBLEDURATION:
		*write_method = write_mtpLkCurrentAdjacentInaccessibleDuration;
		*var_len = sizeof(StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration;

	case MTPLKCURRENTSLSUNAVAILABLE:
		*write_method = write_mtpLkCurrentSlsUnavailable;
		*var_len = sizeof(StorageTmp->mtpLkCurrentSlsUnavailable);
		return (u_char *) &StorageTmp->mtpLkCurrentSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLkInt5minTable(): refresh mtpLkInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLkInt5minTable(void)
{
	if (mtpLkInt5minTable_refresh == 0)
		return;
	mtpLkInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLkInt5minTable_row(): refresh mtpLkInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLkInt5minTable_row(struct mtpLkInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLkInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpLkInt5minTable_request = sa_request;
}

/*
 * var_mtpLkInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpLkInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLkInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLkInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLkInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLkInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLkInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLkInt15minTable(): refresh mtpLkInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLkInt15minTable(void)
{
	if (mtpLkInt15minTable_refresh == 0)
		return;
	mtpLkInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpLkInt15minTable_row(): refresh mtpLkInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLkInt15minTable_row(struct mtpLkInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLkInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpLkInt15minTable_request = sa_request;
}

/*
 * var_mtpLkInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpLkInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpLkInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLkInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLkInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLkInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpLkInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPLKINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpLkInt15minTimeStamp;

	case MTPLKINT15MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkInt15minAdjacentInaccessibleEvents);
		return (u_char *) &StorageTmp->mtpLkInt15minAdjacentInaccessibleEvents;

	case MTPLKINT15MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkInt15minAdjacentInaccessibleDuration);
		return (u_char *) &StorageTmp->mtpLkInt15minAdjacentInaccessibleDuration;

	case MTPLKINT15MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLkInt15minSlsUnavailable);
		return (u_char *) &StorageTmp->mtpLkInt15minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlProfileTable(): refresh mtpSlProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlProfileTable(void)
{
	if (mtpSlProfileTable_refresh == 0)
		return;
	mtpSlProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlProfileTable_row(): refresh mtpSlProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlProfileTable_row(struct mtpSlProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlProfileTable_request = sa_request;
}

/*
 * var_mtpSlProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLPROFILENAME:
		*write_method = write_mtpSlProfileName;
		*var_len = StorageTmp->mtpSlProfileNameLen;
		return (u_char *) StorageTmp->mtpSlProfileName;

	case MTPSLPROFILETIMERT1:
		*write_method = write_mtpSlProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT1);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT1;

	case MTPSLPROFILETIMERT2:
		*write_method = write_mtpSlProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT2);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT2;

	case MTPSLPROFILETIMERT3:
		*write_method = write_mtpSlProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT3);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT3;

	case MTPSLPROFILETIMERT4:
		*write_method = write_mtpSlProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT4);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT4;

	case MTPSLPROFILETIMERT5:
		*write_method = write_mtpSlProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT5);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT5;

	case MTPSLPROFILETIMERT12:
		*write_method = write_mtpSlProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT12);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT12;

	case MTPSLPROFILETIMERT13:
		*write_method = write_mtpSlProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT13);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT13;

	case MTPSLPROFILETIMERT14:
		*write_method = write_mtpSlProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT14);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT14;

	case MTPSLPROFILETIMERT17:
		*write_method = write_mtpSlProfileTimerT17;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT17);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT17;

	case MTPSLPROFILETIMERT19A:
		*write_method = write_mtpSlProfileTimerT19A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT19A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT19A;

	case MTPSLPROFILETIMERT20A:
		*write_method = write_mtpSlProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT20A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT20A;

	case MTPSLPROFILETIMERT21A:
		*write_method = write_mtpSlProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT21A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT21A;

	case MTPSLPROFILETIMERT22:
		*write_method = write_mtpSlProfileTimerT22;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT22);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT22;

	case MTPSLPROFILETIMERT23:
		*write_method = write_mtpSlProfileTimerT23;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT23);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT23;

	case MTPSLPROFILETIMERT24:
		*write_method = write_mtpSlProfileTimerT24;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT24);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT24;

	case MTPSLPROFILETIMERT31A:
		*write_method = write_mtpSlProfileTimerT31A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT31A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT31A;

	case MTPSLPROFILETIMERT32A:
		*write_method = write_mtpSlProfileTimerT32A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT32A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT32A;

	case MTPSLPROFILETIMERT33A:
		*write_method = write_mtpSlProfileTimerT33A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT33A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT33A;

	case MTPSLPROFILETIMERT34A:
		*write_method = write_mtpSlProfileTimerT34A;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT34A);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT34A;

	case MTPSLPROFILETIMERT1T:
		*write_method = write_mtpSlProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT1T);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT1T;

	case MTPSLPROFILETIMERT2T:
		*write_method = write_mtpSlProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT2T);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT2T;

	case MTPSLPROFILETIMERT1S:
		*write_method = write_mtpSlProfileTimerT1S;
		*var_len = sizeof(StorageTmp->mtpSlProfileTimerT1S);
		return (u_char *) &StorageTmp->mtpSlProfileTimerT1S;

	case MTPSLPROFILEL2DEFAULT:
		*write_method = write_mtpSlProfileL2Default;
		*var_len = sizeof(StorageTmp->mtpSlProfileL2Default);
		return (u_char *) &StorageTmp->mtpSlProfileL2Default;

	case MTPSLPROFILESTATUS:
		*write_method = write_mtpSlProfileStatus;
		*var_len = sizeof(StorageTmp->mtpSlProfileStatus);
		return (u_char *) &StorageTmp->mtpSlProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlTable(): refresh mtpSlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(void)
{
	if (mtpSlTable_refresh == 0)
		return;
	mtpSlTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlTable_row(): refresh mtpSlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlTable_request == sa_request)
		return;
	StorageTmp->mtpSlTable_request = sa_request;
}

/*
 * var_mtpSlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLNAME:
		*write_method = write_mtpSlName;
		*var_len = StorageTmp->mtpSlNameLen;
		return (u_char *) StorageTmp->mtpSlName;

	case MTPSLPROFILE:
		*write_method = write_mtpSlProfile;
		*var_len = sizeof(StorageTmp->mtpSlProfile);
		return (u_char *) &StorageTmp->mtpSlProfile;

	case MTPSLL2DEFAULT:
		*write_method = write_mtpSlL2Default;
		*var_len = sizeof(StorageTmp->mtpSlL2Default);
		return (u_char *) &StorageTmp->mtpSlL2Default;

	case MTPSLLKINDEX:
		*write_method = write_mtpSlLkIndex;
		*var_len = sizeof(StorageTmp->mtpSlLkIndex);
		return (u_char *) &StorageTmp->mtpSlLkIndex;

	case MTPSLCODE:
		*write_method = write_mtpSlCode;
		*var_len = sizeof(StorageTmp->mtpSlCode);
		return (u_char *) &StorageTmp->mtpSlCode;

	case MTPSLSLSCODECURRENTLIST:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeCurrentList;

	case MTPSLMAXCAPACITY:
		*write_method = write_mtpSlMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacity);
		return (u_char *) &StorageTmp->mtpSlMaxCapacity;

	case MTPSLCURRENTCAPACITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacity);
		return (u_char *) &StorageTmp->mtpSlCurrentCapacity;

	case MTPSLLINKSTATUS:
		*write_method = write_mtpSlLinkStatus;
		*var_len = StorageTmp->mtpSlLinkStatusLen;
		return (u_char *) StorageTmp->mtpSlLinkStatus;

	case MTPSLADMINISTRATIVESTATE:
		*write_method = write_mtpSlAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		return (u_char *) &StorageTmp->mtpSlAdministrativeState;

	case MTPSLOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		return (u_char *) &StorageTmp->mtpSlOperationalState;

	case MTPSLUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		return (u_char *) &StorageTmp->mtpSlUsageState;

	case MTPSLPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSlProceduralStatus;

	case MTPSLLOCALINHIBIT:
		*write_method = write_mtpSlLocalInhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		return (u_char *) &StorageTmp->mtpSlLocalInhibit;

	case MTPSLLOCALUNINHIBIT:
		*write_method = write_mtpSlLocalUninhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		return (u_char *) &StorageTmp->mtpSlLocalUninhibit;

	case MTPSLREPLACEST:
		*write_method = write_mtpSlReplaceSt;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		return (u_char *) &StorageTmp->mtpSlReplaceSt;

	case MTPSLALARMSEVERITYASSIGNMENT:
		*write_method = write_mtpSlAlarmSeverityAssignment;
		*var_len = StorageTmp->mtpSlAlarmSeverityAssignmentLen;
		return (u_char *) StorageTmp->mtpSlAlarmSeverityAssignment;

	case MTPSLCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		return (u_char *) &StorageTmp->mtpSlCongestionLevel;

	case MTPSLRELATEDLINKGROUPNUMBER:
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		return (u_char *) &StorageTmp->mtpSlRelatedLinkGroupNumber;

	case MTPSLSDLLIST:
		*write_method = write_mtpSlSdlList;
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		return (u_char *) &StorageTmp->mtpSlSdlList;

	case MTPSLSDTLIST:
		*write_method = write_mtpSlSdtList;
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		return (u_char *) &StorageTmp->mtpSlSdtList;

	case MTPSLTEST:
		*write_method = write_mtpSlTest;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		return (u_char *) &StorageTmp->mtpSlTest;

	case MTPSLSLSCODENORMALLIST:
		*write_method = write_mtpSlSlsCodeNormalList;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		return (u_char *) StorageTmp->mtpSlSlsCodeNormalList;

	case MTPSLALARMSTATUS:
		*write_method = write_mtpSlAlarmStatus;
		*var_len = StorageTmp->mtpSlAlarmStatusLen;
		return (u_char *) StorageTmp->mtpSlAlarmStatus;

	case MTPSLSTATUS:
		*write_method = write_mtpSlStatus;
		*var_len = sizeof(StorageTmp->mtpSlStatus);
		return (u_char *) &StorageTmp->mtpSlStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdlListTable(): refresh mtpSlSdlListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(void)
{
	if (mtpSlSdlListTable_refresh == 0)
		return;
	mtpSlSdlListTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlSdlListTable_row(): refresh mtpSlSdlListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdlListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdlListTable_request = sa_request;
}

/*
 * var_mtpSlSdlListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlSdlListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlSdlListTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdlListTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlSdlListTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLSDLLISTPOINTER:
		*write_method = write_mtpSlSdlListPointer;
		*var_len = StorageTmp->mtpSlSdlListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdlListPointer;

	case MTPSLSDLLISTSTATUS:
		*write_method = write_mtpSlSdlListStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdlListStatus);
		return (u_char *) &StorageTmp->mtpSlSdlListStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdtListTable(): refresh mtpSlSdtListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(void)
{
	if (mtpSlSdtListTable_refresh == 0)
		return;
	mtpSlSdtListTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlSdtListTable_row(): refresh mtpSlSdtListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdtListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdtListTable_request = sa_request;
}

/*
 * var_mtpSlSdtListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlSdtListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlSdtListTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdtListTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlSdtListTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLSDTLISTPOINTER:
		*write_method = write_mtpSlSdtListPointer;
		*var_len = StorageTmp->mtpSlSdtListPointerLen;
		return (u_char *) StorageTmp->mtpSlSdtListPointer;

	case MTPSLSDTLISTSTATUS:
		*write_method = write_mtpSlSdtListStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdtListStatus);
		return (u_char *) &StorageTmp->mtpSlSdtListStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlCurrentTable(): refresh mtpSlCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlCurrentTable(void)
{
	if (mtpSlCurrentTable_refresh == 0)
		return;
	mtpSlCurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlCurrentTable_row(): refresh mtpSlCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlCurrentTable_row(struct mtpSlCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSlCurrentTable_request = sa_request;
}

/*
 * var_mtpSlCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlCurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlCurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlCurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpSlCurrentValidIntervals;

	case MTPSLCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpSlCurrentTimeDiscontinuity;

	case MTPSLCURRENTSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpSlCurrentSlUnavailabilityDuration;

	case MTPSLCURRENTSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpSlCurrentSlLocalInhibition;

	case MTPSLCURRENTSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpSlCurrentSlRemoteInhibition;

	case MTPSLCURRENTSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlFailed);
		return (u_char *) &StorageTmp->mtpSlCurrentSlFailed;

	case MTPSLCURRENTSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpSlCurrentSlRemoteProcOutage;

	case MTPSLCURRENTLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpSlCurrentLocalMgmtInhibit;

	case MTPSLCURRENTLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpSlCurrentLocalMgmtUninhibit;

	case MTPSLCURRENTLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentLocalBusy);
		return (u_char *) &StorageTmp->mtpSlCurrentLocalBusy;

	case MTPSLCURRENTSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpSlCurrentSlCongestedStarts;

	case MTPSLCURRENTSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpSlCurrentSlCongestedDuration;

	case MTPSLCURRENTSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentSlCongestionStops);
		return (u_char *) &StorageTmp->mtpSlCurrentSlCongestionStops;

	case MTPSLCURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSlCurrentDiscardedMSUs;

	case MTPSLCURRENTCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpSlCurrentCongestionEventsMSULoss;

	case MTPSLCURRENTCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentChangeovers);
		return (u_char *) &StorageTmp->mtpSlCurrentChangeovers;

	case MTPSLCURRENTCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentChangebacks);
		return (u_char *) &StorageTmp->mtpSlCurrentChangebacks;

	case MTPSLCURRENTRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentRestorations);
		return (u_char *) &StorageTmp->mtpSlCurrentRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlInt5minTable(): refresh mtpSlInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlInt5minTable(void)
{
	if (mtpSlInt5minTable_refresh == 0)
		return;
	mtpSlInt5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlInt5minTable_row(): refresh mtpSlInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlInt5minTable_row(struct mtpSlInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSlInt5minTable_request = sa_request;
}

/*
 * var_mtpSlInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlInt5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlInt5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlInt5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minTimeStamp);
		return (u_char *) &StorageTmp->mtpSlInt5minTimeStamp;

	case MTPSLINT5MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpSlInt5minSlUnavailabilityDuration;

	case MTPSLINT5MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpSlInt5minSlLocalInhibition;

	case MTPSLINT5MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpSlInt5minSlRemoteInhibition;

	case MTPSLINT5MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlFailed);
		return (u_char *) &StorageTmp->mtpSlInt5minSlFailed;

	case MTPSLINT5MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpSlInt5minSlRemoteProcOutage;

	case MTPSLINT5MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpSlInt5minLocalMgmtInhibit;

	case MTPSLINT5MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpSlInt5minLocalMgmtUninhibit;

	case MTPSLINT5MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minLocalBusy);
		return (u_char *) &StorageTmp->mtpSlInt5minLocalBusy;

	case MTPSLINT5MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpSlInt5minSlCongestedStarts;

	case MTPSLINT5MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpSlInt5minSlCongestedDuration;

	case MTPSLINT5MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minSlCongestionStops);
		return (u_char *) &StorageTmp->mtpSlInt5minSlCongestionStops;

	case MTPSLINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSlInt5minDiscardedMSUs;

	case MTPSLINT5MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpSlInt5minCongestionEventsMSULoss;

	case MTPSLINT5MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minChangeovers);
		return (u_char *) &StorageTmp->mtpSlInt5minChangeovers;

	case MTPSLINT5MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minChangebacks);
		return (u_char *) &StorageTmp->mtpSlInt5minChangebacks;

	case MTPSLINT5MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt5minRestorations);
		return (u_char *) &StorageTmp->mtpSlInt5minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlInt15minTable(): refresh mtpSlInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlInt15minTable(void)
{
	if (mtpSlInt15minTable_refresh == 0)
		return;
	mtpSlInt15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSlInt15minTable_row(): refresh mtpSlInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlInt15minTable_row(struct mtpSlInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSlInt15minTable_request = sa_request;
}

/*
 * var_mtpSlInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSlInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSlInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlInt15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlInt15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSlInt15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSLINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minTimeStamp);
		return (u_char *) &StorageTmp->mtpSlInt15minTimeStamp;

	case MTPSLINT15MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlUnavailabilityDuration);
		return (u_char *) &StorageTmp->mtpSlInt15minSlUnavailabilityDuration;

	case MTPSLINT15MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlLocalInhibition);
		return (u_char *) &StorageTmp->mtpSlInt15minSlLocalInhibition;

	case MTPSLINT15MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlRemoteInhibition);
		return (u_char *) &StorageTmp->mtpSlInt15minSlRemoteInhibition;

	case MTPSLINT15MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlFailed);
		return (u_char *) &StorageTmp->mtpSlInt15minSlFailed;

	case MTPSLINT15MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlRemoteProcOutage);
		return (u_char *) &StorageTmp->mtpSlInt15minSlRemoteProcOutage;

	case MTPSLINT15MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minLocalMgmtInhibit);
		return (u_char *) &StorageTmp->mtpSlInt15minLocalMgmtInhibit;

	case MTPSLINT15MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minLocalMgmtUninhibit);
		return (u_char *) &StorageTmp->mtpSlInt15minLocalMgmtUninhibit;

	case MTPSLINT15MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minLocalBusy);
		return (u_char *) &StorageTmp->mtpSlInt15minLocalBusy;

	case MTPSLINT15MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlCongestedStarts);
		return (u_char *) &StorageTmp->mtpSlInt15minSlCongestedStarts;

	case MTPSLINT15MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlCongestedDuration);
		return (u_char *) &StorageTmp->mtpSlInt15minSlCongestedDuration;

	case MTPSLINT15MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minSlCongestionStops);
		return (u_char *) &StorageTmp->mtpSlInt15minSlCongestionStops;

	case MTPSLINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minDiscardedMSUs);
		return (u_char *) &StorageTmp->mtpSlInt15minDiscardedMSUs;

	case MTPSLINT15MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minCongestionEventsMSULoss);
		return (u_char *) &StorageTmp->mtpSlInt15minCongestionEventsMSULoss;

	case MTPSLINT15MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minChangeovers);
		return (u_char *) &StorageTmp->mtpSlInt15minChangeovers;

	case MTPSLINT15MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minChangebacks);
		return (u_char *) &StorageTmp->mtpSlInt15minChangebacks;

	case MTPSLINT15MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlInt15minRestorations);
		return (u_char *) &StorageTmp->mtpSlInt15minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL2ProfileTable(): refresh mtpL2ProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL2ProfileTable(void)
{
	if (mtpL2ProfileTable_refresh == 0)
		return;
	mtpL2ProfileTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL2ProfileTable_row(): refresh mtpL2ProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL2ProfileTable_row(struct mtpL2ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpL2ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpL2ProfileTable_request = sa_request;
}

/*
 * var_mtpL2ProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL2ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpL2ProfileTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL2ProfileTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL2ProfileTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL2PROFILETRANSMISSIONRATE:
		*write_method = write_mtpL2ProfileTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTransmissionRate);
		return (u_char *) &StorageTmp->mtpL2ProfileTransmissionRate;

	case MTPL2PROFILENAME:
		*write_method = write_mtpL2ProfileName;
		*var_len = StorageTmp->mtpL2ProfileNameLen;
		return (u_char *) StorageTmp->mtpL2ProfileName;

	case MTPL2PROFILETIMERT1:
		*write_method = write_mtpL2ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT1);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT1;

	case MTPL2PROFILETIMERT2:
		*write_method = write_mtpL2ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT2);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT2;

	case MTPL2PROFILETIMERT2L:
		*write_method = write_mtpL2ProfileTimerT2L;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT2L);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT2L;

	case MTPL2PROFILETIMERT2H:
		*write_method = write_mtpL2ProfileTimerT2H;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT2H);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT2H;

	case MTPL2PROFILETIMERT3:
		*write_method = write_mtpL2ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT3);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT3;

	case MTPL2PROFILETIMERT4N:
		*write_method = write_mtpL2ProfileTimerT4N;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT4N);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT4N;

	case MTPL2PROFILETIMERT4E:
		*write_method = write_mtpL2ProfileTimerT4E;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT4E);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT4E;

	case MTPL2PROFILETIMERT5:
		*write_method = write_mtpL2ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT5);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT5;

	case MTPL2PROFILETIMERT6:
		*write_method = write_mtpL2ProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT6);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT6;

	case MTPL2PROFILETIMERT7:
		*write_method = write_mtpL2ProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTimerT7);
		return (u_char *) &StorageTmp->mtpL2ProfileTimerT7;

	case MTPL2PROFILEM:
		*write_method = write_mtpL2ProfileM;
		*var_len = sizeof(StorageTmp->mtpL2ProfileM);
		return (u_char *) &StorageTmp->mtpL2ProfileM;

	case MTPL2PROFILEN1:
		*write_method = write_mtpL2ProfileN1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileN1);
		return (u_char *) &StorageTmp->mtpL2ProfileN1;

	case MTPL2PROFILEN2:
		*write_method = write_mtpL2ProfileN2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileN2);
		return (u_char *) &StorageTmp->mtpL2ProfileN2;

	case MTPL2PROFILERBACCEPT:
		*write_method = write_mtpL2ProfileRbAccept;
		*var_len = sizeof(StorageTmp->mtpL2ProfileRbAccept);
		return (u_char *) &StorageTmp->mtpL2ProfileRbAccept;

	case MTPL2PROFILERBDISCARD:
		*write_method = write_mtpL2ProfileRbDiscard;
		*var_len = sizeof(StorageTmp->mtpL2ProfileRbDiscard);
		return (u_char *) &StorageTmp->mtpL2ProfileRbDiscard;

	case MTPL2PROFILERBABATE:
		*write_method = write_mtpL2ProfileRbAbate;
		*var_len = sizeof(StorageTmp->mtpL2ProfileRbAbate);
		return (u_char *) &StorageTmp->mtpL2ProfileRbAbate;

	case MTPL2PROFILETBABATE0:
		*write_method = write_mtpL2ProfileTbAbate0;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbAbate0);
		return (u_char *) &StorageTmp->mtpL2ProfileTbAbate0;

	case MTPL2PROFILETBONSET0:
		*write_method = write_mtpL2ProfileTbOnset0;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbOnset0);
		return (u_char *) &StorageTmp->mtpL2ProfileTbOnset0;

	case MTPL2PROFILETBDISCARD0:
		*write_method = write_mtpL2ProfileTbDiscard0;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbDiscard0);
		return (u_char *) &StorageTmp->mtpL2ProfileTbDiscard0;

	case MTPL2PROFILETBABATE1:
		*write_method = write_mtpL2ProfileTbAbate1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbAbate1);
		return (u_char *) &StorageTmp->mtpL2ProfileTbAbate1;

	case MTPL2PROFILETBONSET1:
		*write_method = write_mtpL2ProfileTbOnset1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbOnset1);
		return (u_char *) &StorageTmp->mtpL2ProfileTbOnset1;

	case MTPL2PROFILETBDISCARD1:
		*write_method = write_mtpL2ProfileTbDiscard1;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbDiscard1);
		return (u_char *) &StorageTmp->mtpL2ProfileTbDiscard1;

	case MTPL2PROFILETBABATE2:
		*write_method = write_mtpL2ProfileTbAbate2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbAbate2);
		return (u_char *) &StorageTmp->mtpL2ProfileTbAbate2;

	case MTPL2PROFILETBONSET2:
		*write_method = write_mtpL2ProfileTbOnset2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbOnset2);
		return (u_char *) &StorageTmp->mtpL2ProfileTbOnset2;

	case MTPL2PROFILETBDISCARD2:
		*write_method = write_mtpL2ProfileTbDiscard2;
		*var_len = sizeof(StorageTmp->mtpL2ProfileTbDiscard2);
		return (u_char *) &StorageTmp->mtpL2ProfileTbDiscard2;

	case MTPL2PROFILESTATUS:
		*write_method = write_mtpL2ProfileStatus;
		*var_len = sizeof(StorageTmp->mtpL2ProfileStatus);
		return (u_char *) &StorageTmp->mtpL2ProfileStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNbandTable(): refresh mtpNbandTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNbandTable(void)
{
	if (mtpNbandTable_refresh == 0)
		return;
	mtpNbandTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpNbandTable_row(): refresh mtpNbandTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNbandTable_row(struct mtpNbandTable_data *StorageTmp)
{
	if (StorageTmp->mtpNbandTable_request == sa_request)
		return;
	StorageTmp->mtpNbandTable_request = sa_request;
}

/*
 * var_mtpNbandTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpNbandTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpNbandTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpNbandTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNbandTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNbandTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpNbandTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPNBANDTRANSMISSIONRATE:
		*write_method = write_mtpNbandTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpNbandTransmissionRate);
		return (u_char *) &StorageTmp->mtpNbandTransmissionRate;

	case MTPNBANDSTATUS:
		*write_method = write_mtpNbandStatus;
		*var_len = sizeof(StorageTmp->mtpNbandStatus);
		return (u_char *) &StorageTmp->mtpNbandStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSaalTable(): refresh mtpSaalTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(void)
{
	if (mtpSaalTable_refresh == 0)
		return;
	mtpSaalTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSaalTable_row(): refresh mtpSaalTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	if (StorageTmp->mtpSaalTable_request == sa_request)
		return;
	StorageTmp->mtpSaalTable_request = sa_request;
}

/*
 * var_mtpSaalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSaalTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSaalTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSaalTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSaalTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSAALBUFFERRELEASE:
		*write_method = write_mtpSaalBufferRelease;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		return (u_char *) &StorageTmp->mtpSaalBufferRelease;

	case MTPSAALMAXCC:
		*write_method = write_mtpSaalMaxCc;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		return (u_char *) &StorageTmp->mtpSaalMaxCc;

	case MTPSAALMAXNRP:
		*write_method = write_mtpSaalMaxNrp;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		return (u_char *) &StorageTmp->mtpSaalMaxNrp;

	case MTPSAALMAXINFORMATIONFIELDLENGTH:
		*write_method = write_mtpSaalMaxInformationFieldLength;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		return (u_char *) &StorageTmp->mtpSaalMaxInformationFieldLength;

	case MTPSAALMAXLENGTHSSCOPUUFIELD:
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		return (u_char *) &StorageTmp->mtpSaalMaxLengthSscopUuField;

	case MTPSAALMAXPD:
		*write_method = write_mtpSaalMaxPd;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		return (u_char *) &StorageTmp->mtpSaalMaxPd;

	case MTPSAALMAXSSCOPCREDITTOPEER:
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		return (u_char *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;

	case MTPSAALMAXSTAT:
		*write_method = write_mtpSaalMaxStat;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		return (u_char *) &StorageTmp->mtpSaalMaxStat;

	case MTPSAALN1:
		*write_method = write_mtpSaalN1;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		return (u_char *) &StorageTmp->mtpSaalN1;

	case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementProvingState;

	case MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;

	case MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		return (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;

	case MTPSAALNNITIMERT1:
		*write_method = write_mtpSaalNniTimerT1;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT1;

	case MTPSAALNNITIMERT2:
		*write_method = write_mtpSaalNniTimerT2;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT2;

	case MTPSAALNNITIMERT3:
		*write_method = write_mtpSaalNniTimerT3;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		return (u_char *) &StorageTmp->mtpSaalNniTimerT3;

	case MTPSAALSSCOPTIMERCC:
		*write_method = write_mtpSaalSscopTimerCc;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerCc;

	case MTPSAALSSCOPTIMERIDLE:
		*write_method = write_mtpSaalSscopTimerIdle;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerIdle;

	case MTPSAALSSCOPTIMERKEEPALIVE:
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerKeepAlive;

	case MTPSAALSSCOPTIMERNORESPONSE:
		*write_method = write_mtpSaalSscopTimerNoResponse;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerNoResponse;

	case MTPSAALSSCOPTIMERPOLL:
		*write_method = write_mtpSaalSscopTimerPoll;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		return (u_char *) &StorageTmp->mtpSaalSscopTimerPoll;

	case MTPSAALTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;

	case MTPSAALTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;

	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;

	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;

	case MTPSAALPOLLAFTERRETRANSMISSION:
		*write_method = write_mtpSaalPollAfterRetransmission;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		return (u_char *) &StorageTmp->mtpSaalPollAfterRetransmission;

	case MTPSAALSTATUS:
		*write_method = write_mtpSaalStatus;
		*var_len = sizeof(StorageTmp->mtpSaalStatus);
		return (u_char *) &StorageTmp->mtpSaalStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpM2paTable(): refresh mtpM2paTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(void)
{
	if (mtpM2paTable_refresh == 0)
		return;
	mtpM2paTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpM2paTable_row(): refresh mtpM2paTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	if (StorageTmp->mtpM2paTable_request == sa_request)
		return;
	StorageTmp->mtpM2paTable_request = sa_request;
}

/*
 * var_mtpM2paTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpM2paTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpM2paTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpM2paTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpM2paTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPM2PAN1:
		*write_method = write_mtpM2paN1;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		return (u_char *) &StorageTmp->mtpM2paN1;

	case MTPM2PAPROVING:
		*write_method = write_mtpM2paProving;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		return (u_char *) &StorageTmp->mtpM2paProving;

	case MTPM2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpM2paManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		return (u_char *) &StorageTmp->mtpM2paManagementProvingState;

	case MTPM2PALOOPDELAYLOWER:
		*write_method = write_mtpM2paLoopDelayLower;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayLower;

	case MTPM2PALOOPDELAYUPPER:
		*write_method = write_mtpM2paLoopDelayUpper;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		return (u_char *) &StorageTmp->mtpM2paLoopDelayUpper;

	case MTPM2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;

	case MTPM2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		return (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;

	case MTPM2PASCTPNODELAY:
		*write_method = write_mtpM2paSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpNoDelay;

	case MTPM2PASCTPMAXSEG:
		*write_method = write_mtpM2paSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxseg;

	case MTPM2PASCTPHEARTBEATITVL:
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeatItvl;

	case MTPM2PASCTPHEARTBEAT:
		*write_method = write_mtpM2paSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		return (u_char *) &StorageTmp->mtpM2paSctpHeartbeat;

	case MTPM2PASCTPRTOINITIAL:
		*write_method = write_mtpM2paSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoInitial;

	case MTPM2PASCTPRTOMIN:
		*write_method = write_mtpM2paSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMin;

	case MTPM2PASCTPRTOMAX:
		*write_method = write_mtpM2paSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		return (u_char *) &StorageTmp->mtpM2paSctpRtoMax;

	case MTPM2PASCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpPathMaxRetrans;

	case MTPM2PASCTPCOOKIELIFE:
		*write_method = write_mtpM2paSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieLife;

	case MTPM2PASCTPCOOKIEINC:
		*write_method = write_mtpM2paSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		return (u_char *) &StorageTmp->mtpM2paSctpCookieInc;

	case MTPM2PASCTPMAXINITRETRIES:
		*write_method = write_mtpM2paSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxInitRetries;

	case MTPM2PASCTPMAXBURST:
		*write_method = write_mtpM2paSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		return (u_char *) &StorageTmp->mtpM2paSctpMaxBurst;

	case MTPM2PASCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		return (u_char *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;

	case MTPM2PASCTPSACKDELAY:
		*write_method = write_mtpM2paSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		return (u_char *) &StorageTmp->mtpM2paSctpSackDelay;

	case MTPM2PASCTPLIFETIME:
		*write_method = write_mtpM2paSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		return (u_char *) &StorageTmp->mtpM2paSctpLifetime;

	case MTPM2PAPROVINGATTEMPTS:
		*write_method = write_mtpM2paProvingAttempts;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		return (u_char *) &StorageTmp->mtpM2paProvingAttempts;

	case MTPM2PASTATUS:
		*write_method = write_mtpM2paStatus;
		*var_len = sizeof(StorageTmp->mtpM2paStatus);
		return (u_char *) &StorageTmp->mtpM2paStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL2Table(): refresh mtpL2Table
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL2Table(void)
{
	if (mtpL2Table_refresh == 0)
		return;
	mtpL2Table_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL2Table_row(): refresh mtpL2Table row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL2Table_row(struct mtpL2Table_data *StorageTmp)
{
	if (StorageTmp->mtpL2Table_request == sa_request)
		return;
	StorageTmp->mtpL2Table_request = sa_request;
}

/*
 * var_mtpL2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpL2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL2Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpL2Table: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL2Table();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL2TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL2Table_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL2NAME:
		*write_method = write_mtpL2Name;
		*var_len = StorageTmp->mtpL2NameLen;
		return (u_char *) StorageTmp->mtpL2Name;

	case MTPL2PROFILE:
		*write_method = write_mtpL2Profile;
		*var_len = sizeof(StorageTmp->mtpL2Profile);
		return (u_char *) &StorageTmp->mtpL2Profile;

	case MTPL2STATUS:
		*write_method = write_mtpL2Status;
		*var_len = sizeof(StorageTmp->mtpL2Status);
		return (u_char *) &StorageTmp->mtpL2Status;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL2CurrentTable(): refresh mtpL2CurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL2CurrentTable(void)
{
	if (mtpL2CurrentTable_refresh == 0)
		return;
	mtpL2CurrentTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL2CurrentTable_row(): refresh mtpL2CurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL2CurrentTable_row(struct mtpL2CurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpL2CurrentTable_request == sa_request)
		return;
	StorageTmp->mtpL2CurrentTable_request = sa_request;
}

/*
 * var_mtpL2CurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpL2CurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL2CurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpL2CurrentTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL2CurrentTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL2CurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL2CurrentTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL2CURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentValidIntervals);
		return (u_char *) &StorageTmp->mtpL2CurrentValidIntervals;

	case MTPL2CURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentTimeDiscontinuity);
		return (u_char *) &StorageTmp->mtpL2CurrentTimeDiscontinuity;

	case MTPL2CURRENTSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentSlInServiceDuration);
		return (u_char *) &StorageTmp->mtpL2CurrentSlInServiceDuration;

	case MTPL2CURRENTSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentSlAlignment);
		return (u_char *) &StorageTmp->mtpL2CurrentSlAlignment;

	case MTPL2CURRENTSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentSignUnitsReceived);
		return (u_char *) &StorageTmp->mtpL2CurrentSignUnitsReceived;

	case MTPL2CURRENTNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentNegAckReceived);
		return (u_char *) &StorageTmp->mtpL2CurrentNegAckReceived;

	case MTPL2CURRENTTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentTransmittedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpL2CurrentTransmittedOctetsSIFSIO;

	case MTPL2CURRENTRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentRetransmittedOctets);
		return (u_char *) &StorageTmp->mtpL2CurrentRetransmittedOctets;

	case MTPL2CURRENTTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentTransmittedMSUs);
		return (u_char *) &StorageTmp->mtpL2CurrentTransmittedMSUs;

	case MTPL2CURRENTRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentReceivedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpL2CurrentReceivedOctetsSIFSIO;

	case MTPL2CURRENTRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2CurrentReceivedMSUs);
		return (u_char *) &StorageTmp->mtpL2CurrentReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL2Int5minTable(): refresh mtpL2Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL2Int5minTable(void)
{
	if (mtpL2Int5minTable_refresh == 0)
		return;
	mtpL2Int5minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL2Int5minTable_row(): refresh mtpL2Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL2Int5minTable_row(struct mtpL2Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpL2Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpL2Int5minTable_request = sa_request;
}

/*
 * var_mtpL2Int5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpL2Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL2Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpL2Int5minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL2Int5minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL2Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL2Int5minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL2INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minTimestamp);
		return (u_char *) &StorageTmp->mtpL2Int5minTimestamp;

	case MTPL2INT5MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minSlInServiceDuration);
		return (u_char *) &StorageTmp->mtpL2Int5minSlInServiceDuration;

	case MTPL2INT5MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minSlAlignment);
		return (u_char *) &StorageTmp->mtpL2Int5minSlAlignment;

	case MTPL2INT5MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minSignUnitsReceived);
		return (u_char *) &StorageTmp->mtpL2Int5minSignUnitsReceived;

	case MTPL2INT5MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minNegAckReceived);
		return (u_char *) &StorageTmp->mtpL2Int5minNegAckReceived;

	case MTPL2INT5MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minTransmittedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpL2Int5minTransmittedOctetsSIFSIO;

	case MTPL2INT5MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minRetransmittedOctets);
		return (u_char *) &StorageTmp->mtpL2Int5minRetransmittedOctets;

	case MTPL2INT5MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minTransmittedMSUs);
		return (u_char *) &StorageTmp->mtpL2Int5minTransmittedMSUs;

	case MTPL2INT5MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minReceivedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpL2Int5minReceivedOctetsSIFSIO;

	case MTPL2INT5MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int5minReceivedMSUs);
		return (u_char *) &StorageTmp->mtpL2Int5minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL2Int15minTable(): refresh mtpL2Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL2Int15minTable(void)
{
	if (mtpL2Int15minTable_refresh == 0)
		return;
	mtpL2Int15minTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpL2Int15minTable_row(): refresh mtpL2Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL2Int15minTable_row(struct mtpL2Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpL2Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpL2Int15minTable_request = sa_request;
}

/*
 * var_mtpL2Int15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpL2Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpL2Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpL2Int15minTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL2Int15minTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL2Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpL2Int15minTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPL2INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minTimestamp);
		return (u_char *) &StorageTmp->mtpL2Int15minTimestamp;

	case MTPL2INT15MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minSlInServiceDuration);
		return (u_char *) &StorageTmp->mtpL2Int15minSlInServiceDuration;

	case MTPL2INT15MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minSlAlignment);
		return (u_char *) &StorageTmp->mtpL2Int15minSlAlignment;

	case MTPL2INT15MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minSignUnitsReceived);
		return (u_char *) &StorageTmp->mtpL2Int15minSignUnitsReceived;

	case MTPL2INT15MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minNegAckReceived);
		return (u_char *) &StorageTmp->mtpL2Int15minNegAckReceived;

	case MTPL2INT15MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minTransmittedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpL2Int15minTransmittedOctetsSIFSIO;

	case MTPL2INT15MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minRetransmittedOctets);
		return (u_char *) &StorageTmp->mtpL2Int15minRetransmittedOctets;

	case MTPL2INT15MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minTransmittedMSUs);
		return (u_char *) &StorageTmp->mtpL2Int15minTransmittedMSUs;

	case MTPL2INT15MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minReceivedOctetsSIFSIO);
		return (u_char *) &StorageTmp->mtpL2Int15minReceivedOctetsSIFSIO;

	case MTPL2INT15MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL2Int15minReceivedMSUs);
		return (u_char *) &StorageTmp->mtpL2Int15minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdtTable(): refresh mtpSdtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(void)
{
	if (mtpSdtTable_refresh == 0)
		return;
	mtpSdtTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSdtTable_row(): refresh mtpSdtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtTable_request == sa_request)
		return;
	StorageTmp->mtpSdtTable_request = sa_request;
}

/*
 * var_mtpSdtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSdtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSdtTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdtTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSdtTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSDTADMINISTRATIVESTATE:
		*write_method = write_mtpSdtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSdtAdministrativeState);
		return (u_char *) &StorageTmp->mtpSdtAdministrativeState;

	case MTPSDTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtOperationalState);
		return (u_char *) &StorageTmp->mtpSdtOperationalState;

	case MTPSDTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		return (u_char *) &StorageTmp->mtpSdtUsageState;

	case MTPSDTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtProceduralStatusLen;
		return (u_char *) StorageTmp->mtpSdtProceduralStatus;

	case MTPSDTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtAvailabilityStatusLen;
		return (u_char *) StorageTmp->mtpSdtAvailabilityStatus;

	case MTPSDTEQUIPMENTPOINTER:
		*write_method = write_mtpSdtEquipmentPointer;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdtEquipmentPointer;

	case MTPSDTNAME:
		*write_method = write_mtpSdtName;
		*var_len = StorageTmp->mtpSdtNameLen;
		return (u_char *) StorageTmp->mtpSdtName;

	case MTPSDTSTATUS:
		*write_method = write_mtpSdtStatus;
		*var_len = sizeof(StorageTmp->mtpSdtStatus);
		return (u_char *) &StorageTmp->mtpSdtStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdlTable(): refresh mtpSdlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(void)
{
	if (mtpSdlTable_refresh == 0)
		return;
	mtpSdlTable_refresh = 0;

	/* Here, update the table as required... */

}

/**
 * refresh_mtpSdlTable_row(): refresh mtpSdlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlTable_request == sa_request)
		return;
	StorageTmp->mtpSdlTable_request = sa_request;
}

/*
 * var_mtpSdlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
u_char *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	struct mtpSdlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSdlTable: Entering...  \n"));

	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdlTable();

	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;

	refresh_mtpSdlTable_row(StorageTmp);

	/* This is where we do the value assignments for the mib results. */

	switch (vp->magic) {

	case MTPSDLADJPC:
		*write_method = write_mtpSdlAdjPc;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		return (u_char *) StorageTmp->mtpSdlAdjPc;

	case MTPSDLTRANSMISSIONRATE:
		*write_method = write_mtpSdlTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		return (u_char *) &StorageTmp->mtpSdlTransmissionRate;

	case MTPSDLLOOPDELAY:
		*write_method = write_mtpSdlLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		return (u_char *) &StorageTmp->mtpSdlLoopDelay;

	case MTPSDLOPERATIONALSTATE:
		*write_method = write_mtpSdlOperationalState;
		*var_len = sizeof(StorageTmp->mtpSdlOperationalState);
		return (u_char *) &StorageTmp->mtpSdlOperationalState;

	case MTPSDLEQUIPMENTPOINTER:
		*write_method = write_mtpSdlEquipmentPointer;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen;
		return (u_char *) StorageTmp->mtpSdlEquipmentPointer;

	case MTPSDLCIC:
		*write_method = write_mtpSdlCIC;
		*var_len = StorageTmp->mtpSdlCICLen;
		return (u_char *) StorageTmp->mtpSdlCIC;

	case MTPSDLNAME:
		*write_method = write_mtpSdlName;
		*var_len = StorageTmp->mtpSdlNameLen;
		return (u_char *) StorageTmp->mtpSdlName;

	case MTPSDLSTMCHANNEL:
		*write_method = write_mtpSdlStmChannel;
		*var_len = sizeof(StorageTmp->mtpSdlStmChannel);
		return (u_char *) &StorageTmp->mtpSdlStmChannel;

	case MTPSDLVCTTPPOINTER:
		*write_method = write_mtpSdlVcTTpPointer;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen;
		return (u_char *) StorageTmp->mtpSdlVcTTpPointer;

	case MTPSDLROWSTATUS:
		*write_method = write_mtpSdlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		return (u_char *) &StorageTmp->mtpSdlRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mtpMtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMtName;
		tmplen = StorageTmp->mtpMtNameLen;
		memdup((void *) &StorageTmp->mtpMtName, var_val, var_val_len);
		StorageTmp->mtpMtNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMtName);
		StorageTmp->mtpMtName = tmpvar;
		StorageTmp->mtpMtNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMtSpIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMtSpIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtSpIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMtSpIndex;
		StorageTmp->mtpMtSpIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMtSpIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMtUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMtUserPart entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMtUserPart;
		StorageTmp->mtpMtUserPart = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMtUserPart = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMtUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMtUserPartStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMtUserPartStatus;
		StorageTmp->mtpMtUserPartStatus = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMtUserPartStatus = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMtAlarmSeverityAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMtAlarmSeverityAssignment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtAlarmSeverityAssignment not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMtAlarmSeverityAssignment;
		tmplen = StorageTmp->mtpMtAlarmSeverityAssignmentLen;
		memdup((void *) &StorageTmp->mtpMtAlarmSeverityAssignment, var_val, var_val_len);
		StorageTmp->mtpMtAlarmSeverityAssignmentLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMtAlarmSeverityAssignment);
		StorageTmp->mtpMtAlarmSeverityAssignment = tmpvar;
		StorageTmp->mtpMtAlarmSeverityAssignmentLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMtLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMtLongMessageSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMtLongMessageSupported;
		StorageTmp->mtpMtLongMessageSupported = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpMtLongMessageSupported = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsName;
		tmplen = StorageTmp->mtpMsNameLen;
		memdup((void *) &StorageTmp->mtpMsName, var_val, var_val_len);
		StorageTmp->mtpMsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsName);
		StorageTmp->mtpMsName = tmpvar;
		StorageTmp->mtpMsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsAlarmStatus;
		tmplen = StorageTmp->mtpMsAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpMsAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpMsAlarmStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsAlarmStatus);
		StorageTmp->mtpMsAlarmStatus = tmpvar;
		StorageTmp->mtpMsAlarmStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsManagedElementType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsManagedElementType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsManagedElementType;
		tmplen = StorageTmp->mtpMsManagedElementTypeLen;
		memdup((void *) &StorageTmp->mtpMsManagedElementType, var_val, var_val_len);
		StorageTmp->mtpMsManagedElementTypeLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsManagedElementType);
		StorageTmp->mtpMsManagedElementType = tmpvar;
		StorageTmp->mtpMsManagedElementTypeLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsModelCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsModelCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsModelCode;
		tmplen = StorageTmp->mtpMsModelCodeLen;
		memdup((void *) &StorageTmp->mtpMsModelCode, var_val, var_val_len);
		StorageTmp->mtpMsModelCodeLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsModelCode);
		StorageTmp->mtpMsModelCode = tmpvar;
		StorageTmp->mtpMsModelCodeLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsVendorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsVendorName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsVendorName;
		tmplen = StorageTmp->mtpMsVendorNameLen;
		memdup((void *) &StorageTmp->mtpMsVendorName, var_val, var_val_len);
		StorageTmp->mtpMsVendorNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsVendorName);
		StorageTmp->mtpMsVendorName = tmpvar;
		StorageTmp->mtpMsVendorNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsUserLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsUserLabel;
		tmplen = StorageTmp->mtpMsUserLabelLen;
		memdup((void *) &StorageTmp->mtpMsUserLabel, var_val, var_val_len);
		StorageTmp->mtpMsUserLabelLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsUserLabel);
		StorageTmp->mtpMsUserLabel = tmpvar;
		StorageTmp->mtpMsUserLabelLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsVersion;
		tmplen = StorageTmp->mtpMsVersionLen;
		memdup((void *) &StorageTmp->mtpMsVersion, var_val, var_val_len);
		StorageTmp->mtpMsVersionLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsVersion);
		StorageTmp->mtpMsVersion = tmpvar;
		StorageTmp->mtpMsVersionLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsAlarmSeverityAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsAlarmSeverityAssignment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmSeverityAssignment not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsAlarmSeverityAssignment;
		tmplen = StorageTmp->mtpMsAlarmSeverityAssignmentLen;
		memdup((void *) &StorageTmp->mtpMsAlarmSeverityAssignment, var_val, var_val_len);
		StorageTmp->mtpMsAlarmSeverityAssignmentLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsAlarmSeverityAssignment);
		StorageTmp->mtpMsAlarmSeverityAssignment = tmpvar;
		StorageTmp->mtpMsAlarmSeverityAssignmentLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsNetworkElementAliases entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpMsNetworkElementAliases;
		tmplen = StorageTmp->mtpMsNetworkElementAliasesLen;
		memdup((void *) &StorageTmp->mtpMsNetworkElementAliases, var_val, var_val_len);
		StorageTmp->mtpMsNetworkElementAliasesLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsNetworkElementAliases);
		StorageTmp->mtpMsNetworkElementAliases = tmpvar;
		StorageTmp->mtpMsNetworkElementAliasesLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProfileName;
		tmplen = StorageTmp->mtpNaProfileNameLen;
		memdup((void *) &StorageTmp->mtpNaProfileName, var_val, var_val_len);
		StorageTmp->mtpNaProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProfileName);
		StorageTmp->mtpNaProfileName = tmpvar;
		StorageTmp->mtpNaProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolVariant;
		tmplen = StorageTmp->mtpNaProtocolVariantLen;
		memdup((void *) &StorageTmp->mtpNaProtocolVariant, var_val, var_val_len);
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
		StorageTmp->mtpNaProtocolVariant = tmpvar;
		StorageTmp->mtpNaProtocolVariantLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolYear;
		StorageTmp->mtpNaProtocolYear = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolYear = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolOptions;
		tmplen = StorageTmp->mtpNaProtocolOptionsLen;
		memdup((void *) &StorageTmp->mtpNaProtocolOptions, var_val, var_val_len);
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
		StorageTmp->mtpNaProtocolOptions = tmpvar;
		StorageTmp->mtpNaProtocolOptionsLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaNetworkIndicator;
		StorageTmp->mtpNaNetworkIndicator = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaNetworkIndicator = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaPointCodeFormat;
		tmplen = StorageTmp->mtpNaPointCodeFormatLen;
		memdup((void *) &StorageTmp->mtpNaPointCodeFormat, var_val, var_val_len);
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
		StorageTmp->mtpNaPointCodeFormat = tmpvar;
		StorageTmp->mtpNaPointCodeFormatLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaPointCodeFormat;
		tmplen = StorageTmp->mtpNaPointCodeFormatLen;
		memdup((void *) &StorageTmp->mtpNaPointCodeFormat, var_val, var_val_len);
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
		StorageTmp->mtpNaPointCodeFormat = tmpvar;
		StorageTmp->mtpNaPointCodeFormatLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaName;
		tmplen = StorageTmp->mtpNaNameLen;
		memdup((void *) &StorageTmp->mtpNaName, var_val, var_val_len);
		StorageTmp->mtpNaNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaName);
		StorageTmp->mtpNaName = tmpvar;
		StorageTmp->mtpNaNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaProfile;
		StorageTmp->mtpNaProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaSpDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNaSpDefault;
		StorageTmp->mtpNaSpDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSpDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsName;
		tmplen = StorageTmp->mtpGsNameLen;
		memdup((void *) &StorageTmp->mtpGsName, var_val, var_val_len);
		StorageTmp->mtpGsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsName);
		StorageTmp->mtpGsName = tmpvar;
		StorageTmp->mtpGsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsAdministrativeState;
		StorageTmp->mtpGsAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsTreatmentOfOutsideRanges;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsTreatmentOfOutsideRanges = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsListMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsListMode;
		StorageTmp->mtpGsListMode = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListMode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpGsListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsListObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsListObject;
		tmplen = StorageTmp->mtpGsListObjectLen;
		memdup((void *) &StorageTmp->mtpGsListObject, var_val, var_val_len);
		StorageTmp->mtpGsListObjectLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsListObject);
		StorageTmp->mtpGsListObject = tmpvar;
		StorageTmp->mtpGsListObjectLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpGsListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsListContent entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListContent not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsListContent;
		StorageTmp->mtpGsListContent = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListContent = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRuleDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsRuleDesignatedDPCFirst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsRuleTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRuleDesignatedDPCFirst not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsRuleDesignatedDPCFirst;
		tmplen = StorageTmp->mtpGsRuleDesignatedDPCFirstLen;
		memdup((void *) &StorageTmp->mtpGsRuleDesignatedDPCFirst, var_val, var_val_len);
		StorageTmp->mtpGsRuleDesignatedDPCFirstLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsRuleDesignatedDPCFirst);
		StorageTmp->mtpGsRuleDesignatedDPCFirst = tmpvar;
		StorageTmp->mtpGsRuleDesignatedDPCFirstLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRuleDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsRuleDesignatedDPCLast entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsRuleTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRuleDesignatedDPCLast not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsRuleDesignatedDPCLast;
		tmplen = StorageTmp->mtpGsRuleDesignatedDPCLastLen;
		memdup((void *) &StorageTmp->mtpGsRuleDesignatedDPCLast, var_val, var_val_len);
		StorageTmp->mtpGsRuleDesignatedDPCLastLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsRuleDesignatedDPCLast);
		StorageTmp->mtpGsRuleDesignatedDPCLast = tmpvar;
		StorageTmp->mtpGsRuleDesignatedDPCLastLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRuleSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsRuleSiMask entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsRuleTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRuleSiMask not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsRuleSiMask;
		tmplen = StorageTmp->mtpGsRuleSiMaskLen;
		memdup((void *) &StorageTmp->mtpGsRuleSiMask, var_val, var_val_len);
		StorageTmp->mtpGsRuleSiMaskLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsRuleSiMask);
		StorageTmp->mtpGsRuleSiMask = tmpvar;
		StorageTmp->mtpGsRuleSiMaskLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRuleMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsRuleMessageTreatment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsRuleTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRuleMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsRuleMessageTreatment;
		StorageTmp->mtpGsRuleMessageTreatment = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsRuleMessageTreatment = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRuleComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsRuleComment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsRuleTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRuleComment not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpGsRuleComment;
		tmplen = StorageTmp->mtpGsRuleCommentLen;
		memdup((void *) &StorageTmp->mtpGsRuleComment, var_val, var_val_len);
		StorageTmp->mtpGsRuleCommentLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsRuleComment);
		StorageTmp->mtpGsRuleComment = tmpvar;
		StorageTmp->mtpGsRuleCommentLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileName;
		tmplen = StorageTmp->mtpSpProfileNameLen;
		memdup((void *) &StorageTmp->mtpSpProfileName, var_val, var_val_len);
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpProfileName);
		StorageTmp->mtpSpProfileName = tmpvar;
		StorageTmp->mtpSpProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT1R entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT1R;
		StorageTmp->mtpSpProfileTimerT1R = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1R = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT18(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT18 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT18;
		StorageTmp->mtpSpProfileTimerT18 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT18 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT20(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT20 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT20;
		StorageTmp->mtpSpProfileTimerT20 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT22A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT22A;
		StorageTmp->mtpSpProfileTimerT22A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT23A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT23A;
		StorageTmp->mtpSpProfileTimerT23A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT24A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT24A;
		StorageTmp->mtpSpProfileTimerT24A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT24A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT26A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT26A;
		StorageTmp->mtpSpProfileTimerT26A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT26A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT27A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT27A;
		StorageTmp->mtpSpProfileTimerT27A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT27A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileRsDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileRsDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRsDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileRsDefault;
		StorageTmp->mtpSpProfileRsDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileRsDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileLkDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileLkDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileLkDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileLkDefault;
		StorageTmp->mtpSpProfileLkDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileLkDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpName;
		tmplen = StorageTmp->mtpSpNameLen;
		memdup((void *) &StorageTmp->mtpSpName, var_val, var_val_len);
		StorageTmp->mtpSpNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpName);
		StorageTmp->mtpSpName = tmpvar;
		StorageTmp->mtpSpNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMsIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMsIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpMsIndex;
		StorageTmp->mtpSpMsIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMsIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNaIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpNaIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpNaIndex;
		StorageTmp->mtpSpNaIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNaIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfile;
		StorageTmp->mtpSpProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpRsDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpRsDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRsDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpRsDefault;
		StorageTmp->mtpSpRsDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpRsDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpLkDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpLkDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpLkDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpLkDefault;
		StorageTmp->mtpSpLkDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpLkDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpPointCode;
		tmplen = StorageTmp->mtpSpPointCodeLen;
		memdup((void *) &StorageTmp->mtpSpPointCode, var_val, var_val_len);
		StorageTmp->mtpSpPointCodeLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpPointCode);
		StorageTmp->mtpSpPointCode = tmpvar;
		StorageTmp->mtpSpPointCodeLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpType;
		StorageTmp->mtpSpType = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpType = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpFlags;
		tmplen = StorageTmp->mtpSpFlagsLen;
		memdup((void *) &StorageTmp->mtpSpFlags, var_val, var_val_len);
		StorageTmp->mtpSpFlagsLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpFlags);
		StorageTmp->mtpSpFlags = tmpvar;
		StorageTmp->mtpSpFlagsLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpUsers entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpUsers;
		tmplen = StorageTmp->mtpSpUsersLen;
		memdup((void *) &StorageTmp->mtpSpUsers, var_val, var_val_len);
		StorageTmp->mtpSpUsersLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpUsers);
		StorageTmp->mtpSpUsers = tmpvar;
		StorageTmp->mtpSpUsersLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSpAlarmStatus;
		tmplen = StorageTmp->mtpSpAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpSpAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpSpAlarmStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpAlarmStatus);
		StorageTmp->mtpSpAlarmStatus = tmpvar;
		StorageTmp->mtpSpAlarmStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileName;
		tmplen = StorageTmp->mtpRsProfileNameLen;
		memdup((void *) &StorageTmp->mtpRsProfileName, var_val, var_val_len);
		StorageTmp->mtpRsProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsProfileName);
		StorageTmp->mtpRsProfileName = tmpvar;
		StorageTmp->mtpRsProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT8;
		StorageTmp->mtpRsProfileTimerT8 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT8 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT11;
		StorageTmp->mtpRsProfileTimerT11 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT11 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT15;
		StorageTmp->mtpRsProfileTimerT15 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT15 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT16;
		StorageTmp->mtpRsProfileTimerT16 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT16 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT18A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT18A;
		StorageTmp->mtpRsProfileTimerT18A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT18A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileRtDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileRtDefault;
		StorageTmp->mtpRsProfileRtDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileRtDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsName;
		tmplen = StorageTmp->mtpRsNameLen;
		memdup((void *) &StorageTmp->mtpRsName, var_val, var_val_len);
		StorageTmp->mtpRsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsName);
		StorageTmp->mtpRsName = tmpvar;
		StorageTmp->mtpRsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfile;
		StorageTmp->mtpRsProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsRtDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRtDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsRtDefault;
		StorageTmp->mtpRsRtDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsRtDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsAdministrativeState;
		StorageTmp->mtpRsAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAlarmSeverityAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsAlarmSeverityAssignment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmSeverityAssignment not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsAlarmSeverityAssignment;
		tmplen = StorageTmp->mtpRsAlarmSeverityAssignmentLen;
		memdup((void *) &StorageTmp->mtpRsAlarmSeverityAssignment, var_val, var_val_len);
		StorageTmp->mtpRsAlarmSeverityAssignmentLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsAlarmSeverityAssignment);
		StorageTmp->mtpRsAlarmSeverityAssignment = tmpvar;
		StorageTmp->mtpRsAlarmSeverityAssignmentLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCongState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCongState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCongState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCongState;
		StorageTmp->mtpRsCongState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCongState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCongLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCongLevel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCongLevel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCongLevel;
		StorageTmp->mtpRsCongLevel = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCongLevel = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsLoadsharingInformation;
		tmplen = StorageTmp->mtpRsLoadsharingInformationLen;
		memdup((void *) &StorageTmp->mtpRsLoadsharingInformation, var_val, var_val_len);
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
		StorageTmp->mtpRsLoadsharingInformation = tmpvar;
		StorageTmp->mtpRsLoadsharingInformationLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsLoadsharingObject;
		tmplen = StorageTmp->mtpRsLoadsharingObjectLen;
		memdup((void *) &StorageTmp->mtpRsLoadsharingObject, var_val, var_val_len);
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
		StorageTmp->mtpRsLoadsharingObject = tmpvar;
		StorageTmp->mtpRsLoadsharingObjectLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsRemoteExchangeLabel;
		tmplen = StorageTmp->mtpRsRemoteExchangeLabelLen;
		memdup((void *) &StorageTmp->mtpRsRemoteExchangeLabel, var_val, var_val_len);
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
		StorageTmp->mtpRsRemoteExchangeLabel = tmpvar;
		StorageTmp->mtpRsRemoteExchangeLabelLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsAlarmStatus;
		tmplen = StorageTmp->mtpRsAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpRsAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpRsAlarmStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsAlarmStatus);
		StorageTmp->mtpRsAlarmStatus = tmpvar;
		StorageTmp->mtpRsAlarmStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentValidIntervals;
		StorageTmp->mtpRsCurrentValidIntervals = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentValidIntervals = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTimeDiscontinuity;
		StorageTmp->mtpRsCurrentTimeDiscontinuity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTimeDiscontinuity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentReceivedOctetsOPC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentReceivedOctetsOPC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentReceivedOctetsOPC not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentReceivedOctetsOPC;
		StorageTmp->mtpRsCurrentReceivedOctetsOPC = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentReceivedOctetsOPC = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTransmittedOctetsDPC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentTransmittedOctetsDPC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTransmittedOctetsDPC not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTransmittedOctetsDPC;
		StorageTmp->mtpRsCurrentTransmittedOctetsDPC = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTransmittedOctetsDPC = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentReceivedMSUsOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentReceivedMSUsOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentReceivedMSUsOpc not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentReceivedMSUsOpc;
		StorageTmp->mtpRsCurrentReceivedMSUsOpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentReceivedMSUsOpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTransmittedMSUsDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentTransmittedMSUsDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTransmittedMSUsDpc not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTransmittedMSUsDpc;
		StorageTmp->mtpRsCurrentTransmittedMSUsDpc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTransmittedMSUsDpc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentRouteSetUnavailable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentRouteSetUnavailable entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentRouteSetUnavailable not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentRouteSetUnavailable;
		StorageTmp->mtpRsCurrentRouteSetUnavailable = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentRouteSetUnavailable = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentRouteSetUnavailableDuration(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentRouteSetUnavailableDuration entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentRouteSetUnavailableDuration not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;
		StorageTmp->mtpRsCurrentRouteSetUnavailableDuration = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentRouteSetUnavailableDuration = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiValidIntervals;
		StorageTmp->mtpRsSiValidIntervals = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiValidIntervals = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTimeDiscontinuity;
		StorageTmp->mtpRsSiTimeDiscontinuity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTimeDiscontinuity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiReceivedOctetsOpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiReceivedOctetsOpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiReceivedOctetsOpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiReceivedOctetsOpcSio;
		StorageTmp->mtpRsSiReceivedOctetsOpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiReceivedOctetsOpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTransmittedOctetsDpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiTransmittedOctetsDpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTransmittedOctetsDpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTransmittedOctetsDpcSio;
		StorageTmp->mtpRsSiTransmittedOctetsDpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTransmittedOctetsDpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiReceivedMSUsOpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiReceivedMSUsOpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiReceivedMSUsOpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiReceivedMSUsOpcSio;
		StorageTmp->mtpRsSiReceivedMSUsOpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiReceivedMSUsOpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTransmittedMSUsDpcSio(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiTransmittedMSUsDpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTransmittedMSUsDpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTransmittedMSUsDpcSio;
		StorageTmp->mtpRsSiTransmittedMSUsDpcSio = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTransmittedMSUsDpcSio = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRlProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRlProfile;
		StorageTmp->mtpRlProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRlProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRlRtDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlRtDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRlRtDefault;
		StorageTmp->mtpRlRtDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRlRtDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlRsIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRlRsIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlRsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRlRsIndex;
		StorageTmp->mtpRlRsIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRlRsIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlLsIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRlLsIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlLsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRlLsIndex;
		StorageTmp->mtpRlLsIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRlLsIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlRsCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRlRsCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlRsCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRlRsCost;
		StorageTmp->mtpRlRsCost = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRlRsCost = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRlAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRlAdministrativeState;
		StorageTmp->mtpRlAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRlAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfileName;
		tmplen = StorageTmp->mtpRtProfileNameLen;
		memdup((void *) &StorageTmp->mtpRtProfileName, var_val, var_val_len);
		StorageTmp->mtpRtProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtProfileName);
		StorageTmp->mtpRtProfileName = tmpvar;
		StorageTmp->mtpRtProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfileTimerT6;
		StorageTmp->mtpRtProfileTimerT6 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT6 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfileTimerT10;
		StorageTmp->mtpRtProfileTimerT10 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT10 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtName;
		tmplen = StorageTmp->mtpRtNameLen;
		memdup((void *) &StorageTmp->mtpRtName, var_val, var_val_len);
		StorageTmp->mtpRtNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtName);
		StorageTmp->mtpRtName = tmpvar;
		StorageTmp->mtpRtNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfile;
		StorageTmp->mtpRtProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRlIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtRlIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtRlIndex;
		StorageTmp->mtpRtRlIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtRlIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLkIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLkIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLkIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLkIndex;
		StorageTmp->mtpRtLkIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLkIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtRlSlot entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtRlSlot;
		StorageTmp->mtpRtRlSlot = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtRlSlot = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtAdministrativeState;
		StorageTmp->mtpRtAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtInClsLoadsharingAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtFixedPriority;
		StorageTmp->mtpRtFixedPriority = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFixedPriority = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtFlexiblePriority;
		StorageTmp->mtpRtFlexiblePriority = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFlexiblePriority = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtPriorityMode;
		StorageTmp->mtpRtPriorityMode = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtPriorityMode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLoadsharingInformation;
		tmplen = StorageTmp->mtpRtLoadsharingInformationLen;
		memdup((void *) &StorageTmp->mtpRtLoadsharingInformation, var_val, var_val_len);
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
		StorageTmp->mtpRtLoadsharingInformation = tmpvar;
		StorageTmp->mtpRtLoadsharingInformationLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtLoadsharingObject;
		tmplen = StorageTmp->mtpRtLoadsharingObjectLen;
		memdup((void *) &StorageTmp->mtpRtLoadsharingObject, var_val, var_val_len);
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
		StorageTmp->mtpRtLoadsharingObject = tmpvar;
		StorageTmp->mtpRtLoadsharingObjectLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtSlsList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpRtSlsList;
		tmplen = StorageTmp->mtpRtSlsListLen;
		memdup((void *) &StorageTmp->mtpRtSlsList, var_val, var_val_len);
		StorageTmp->mtpRtSlsListLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtSlsList);
		StorageTmp->mtpRtSlsList = tmpvar;
		StorageTmp->mtpRtSlsListLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsName;
		tmplen = StorageTmp->mtpLsNameLen;
		memdup((void *) &StorageTmp->mtpLsName, var_val, var_val_len);
		StorageTmp->mtpLsNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsName);
		StorageTmp->mtpLsName = tmpvar;
		StorageTmp->mtpLsNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsLkDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsLkDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsLkDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsLkDefault;
		StorageTmp->mtpLsLkDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsLkDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAdministrativeState;
		StorageTmp->mtpLsAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAdjPc;
		tmplen = StorageTmp->mtpLsAdjPcLen;
		memdup((void *) &StorageTmp->mtpLsAdjPc, var_val, var_val_len);
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAdjPc);
		StorageTmp->mtpLsAdjPc = tmpvar;
		StorageTmp->mtpLsAdjPcLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsMaxCapacity;
		StorageTmp->mtpLsMaxCapacity = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsMaxCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCurrentCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentCapacity;
		StorageTmp->mtpLsCurrentCapacity = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsCongestionControlMethod;
		StorageTmp->mtpLsCongestionControlMethod = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCongestionControlMethod = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsPeriodicLinkTestFlag;
		StorageTmp->mtpLsPeriodicLinkTestFlag = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFlag = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsInLsLoadShareAlgorithm;
		tmplen = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		memdup((void *) &StorageTmp->mtpLsInLsLoadShareAlgorithm, var_val, var_val_len);
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
		StorageTmp->mtpLsInLsLoadShareAlgorithm = tmpvar;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsNumNormActSls(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsNumNormActSls entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumNormActSls not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsNumNormActSls;
		StorageTmp->mtpLsNumNormActSls = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsNumNormActSls = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAlarmSeverityAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAlarmSeverityAssignment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmSeverityAssignment not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAlarmSeverityAssignment;
		tmplen = StorageTmp->mtpLsAlarmSeverityAssignmentLen;
		memdup((void *) &StorageTmp->mtpLsAlarmSeverityAssignment, var_val, var_val_len);
		StorageTmp->mtpLsAlarmSeverityAssignmentLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAlarmSeverityAssignment);
		StorageTmp->mtpLsAlarmSeverityAssignment = tmpvar;
		StorageTmp->mtpLsAlarmSeverityAssignmentLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLsAlarmStatus;
		tmplen = StorageTmp->mtpLsAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpLsAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpLsAlarmStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAlarmStatus);
		StorageTmp->mtpLsAlarmStatus = tmpvar;
		StorageTmp->mtpLsAlarmStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT7;
		StorageTmp->mtpLkProfileTimerT7 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT7 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT19(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT19 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT19 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT19;
		StorageTmp->mtpLkProfileTimerT19 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT19 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT21(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT21 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT21 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT21;
		StorageTmp->mtpLkProfileTimerT21 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT21 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT25A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT25A;
		StorageTmp->mtpLkProfileTimerT25A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT25A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT28A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT28A;
		StorageTmp->mtpLkProfileTimerT28A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT28A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT29A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT29A;
		StorageTmp->mtpLkProfileTimerT29A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT29A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileTimerT30A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileTimerT30A;
		StorageTmp->mtpLkProfileTimerT30A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileTimerT30A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfileSlDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileSlDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfileSlDefault;
		StorageTmp->mtpLkProfileSlDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfileSlDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkName;
		tmplen = StorageTmp->mtpLkNameLen;
		memdup((void *) &StorageTmp->mtpLkName, var_val, var_val_len);
		StorageTmp->mtpLkNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLkName);
		StorageTmp->mtpLkName = tmpvar;
		StorageTmp->mtpLkNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkProfile;
		StorageTmp->mtpLkProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkSlDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkSlDefault not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkSlDefault;
		StorageTmp->mtpLkSlDefault = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkSlDefault = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkLsIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkLsIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkLsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkLsIndex;
		StorageTmp->mtpLkLsIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkLsIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkRsIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkRsIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkRsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkRsIndex;
		StorageTmp->mtpLkRsIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkRsIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkAdjPc;
		tmplen = StorageTmp->mtpLkAdjPcLen;
		memdup((void *) &StorageTmp->mtpLkAdjPc, var_val, var_val_len);
		StorageTmp->mtpLkAdjPcLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLkAdjPc);
		StorageTmp->mtpLkAdjPc = tmpvar;
		StorageTmp->mtpLkAdjPcLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkMaxCapacity;
		StorageTmp->mtpLkMaxCapacity = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkMaxCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkCongestionControlMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkCongestionControlMethod;
		StorageTmp->mtpLkCongestionControlMethod = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkCongestionControlMethod = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkPeriodicLinkTestFlag entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkPeriodicLinkTestFlag;
		StorageTmp->mtpLkPeriodicLinkTestFlag = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkPeriodicLinkTestFlag = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkPeriodicLinkTestFail entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkPeriodicLinkTestFail not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkPeriodicLinkTestFail;
		StorageTmp->mtpLkPeriodicLinkTestFail = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkPeriodicLinkTestFail = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkAdministrativeState;
		StorageTmp->mtpLkAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkInLsLoadSharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkInLsLoadSharingAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkInLsLoadSharingAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkInLsLoadSharingAlgorithm;
		tmplen = StorageTmp->mtpLkInLsLoadSharingAlgorithmLen;
		memdup((void *) &StorageTmp->mtpLkInLsLoadSharingAlgorithm, var_val, var_val_len);
		StorageTmp->mtpLkInLsLoadSharingAlgorithmLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLkInLsLoadSharingAlgorithm);
		StorageTmp->mtpLkInLsLoadSharingAlgorithm = tmpvar;
		StorageTmp->mtpLkInLsLoadSharingAlgorithmLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkNumberOfNormallyActiveSignLinks entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkNumberOfNormallyActiveSignLinks not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkNumberOfNormallyActiveSignLinks;
		StorageTmp->mtpLkNumberOfNormallyActiveSignLinks = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkNumberOfNormallyActiveSignLinks = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkAlarmStatus;
		tmplen = StorageTmp->mtpLkAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpLkAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpLkAlarmStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLkAlarmStatus);
		StorageTmp->mtpLkAlarmStatus = tmpvar;
		StorageTmp->mtpLkAlarmStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkAlarmSeverityAssignemnt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkAlarmSeverityAssignemnt entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkAlarmSeverityAssignemnt not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkAlarmSeverityAssignemnt;
		tmplen = StorageTmp->mtpLkAlarmSeverityAssignemntLen;
		memdup((void *) &StorageTmp->mtpLkAlarmSeverityAssignemnt, var_val, var_val_len);
		StorageTmp->mtpLkAlarmSeverityAssignemntLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLkAlarmSeverityAssignemnt);
		StorageTmp->mtpLkAlarmSeverityAssignemnt = tmpvar;
		StorageTmp->mtpLkAlarmSeverityAssignemntLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkCurrentValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkCurrentValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkCurrentValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkCurrentValidIntervals;
		StorageTmp->mtpLkCurrentValidIntervals = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkCurrentValidIntervals = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkCurrentTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkCurrentTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkCurrentTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkCurrentTimeDiscontinuity;
		StorageTmp->mtpLkCurrentTimeDiscontinuity = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkCurrentTimeDiscontinuity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkCurrentAdjacentInaccessibleEvents(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkCurrentAdjacentInaccessibleEvents entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkCurrentAdjacentInaccessibleEvents not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents;
		StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkCurrentAdjacentInaccessibleEvents = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkCurrentAdjacentInaccessibleDuration(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkCurrentAdjacentInaccessibleDuration entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkCurrentAdjacentInaccessibleDuration not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration;
		StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkCurrentAdjacentInaccessibleDuration = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkCurrentSlsUnavailable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLkCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLkCurrentSlsUnavailable entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLkCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkCurrentSlsUnavailable not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpLkCurrentSlsUnavailable;
		StorageTmp->mtpLkCurrentSlsUnavailable = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLkCurrentSlsUnavailable = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileName;
		tmplen = StorageTmp->mtpSlProfileNameLen;
		memdup((void *) &StorageTmp->mtpSlProfileName, var_val, var_val_len);
		StorageTmp->mtpSlProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlProfileName);
		StorageTmp->mtpSlProfileName = tmpvar;
		StorageTmp->mtpSlProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT1;
		StorageTmp->mtpSlProfileTimerT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT2;
		StorageTmp->mtpSlProfileTimerT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT3;
		StorageTmp->mtpSlProfileTimerT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT4;
		StorageTmp->mtpSlProfileTimerT4 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT4 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT5;
		StorageTmp->mtpSlProfileTimerT5 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT5 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT12;
		StorageTmp->mtpSlProfileTimerT12 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT12 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT13;
		StorageTmp->mtpSlProfileTimerT13 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT13 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT14;
		StorageTmp->mtpSlProfileTimerT14 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT14 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT17;
		StorageTmp->mtpSlProfileTimerT17 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT17 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT19A;
		StorageTmp->mtpSlProfileTimerT19A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT19A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT20A;
		StorageTmp->mtpSlProfileTimerT20A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT20A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT21A;
		StorageTmp->mtpSlProfileTimerT21A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT21A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT22(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT22 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT22 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT22;
		StorageTmp->mtpSlProfileTimerT22 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT22 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT23(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT23 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT23 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT23;
		StorageTmp->mtpSlProfileTimerT23 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT23 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT24(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT24 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT24 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT24;
		StorageTmp->mtpSlProfileTimerT24 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT24 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT31A;
		StorageTmp->mtpSlProfileTimerT31A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT31A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT32A;
		StorageTmp->mtpSlProfileTimerT32A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT32A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT33A;
		StorageTmp->mtpSlProfileTimerT33A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT33A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT34A;
		StorageTmp->mtpSlProfileTimerT34A = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT34A = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT1T;
		StorageTmp->mtpSlProfileTimerT1T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT1T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT2T;
		StorageTmp->mtpSlProfileTimerT2T = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT2T = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileTimerT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileTimerT1S;
		StorageTmp->mtpSlProfileTimerT1S = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileTimerT1S = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfileL2Default entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileL2Default not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfileL2Default;
		StorageTmp->mtpSlProfileL2Default = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfileL2Default = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlName;
		tmplen = StorageTmp->mtpSlNameLen;
		memdup((void *) &StorageTmp->mtpSlName, var_val, var_val_len);
		StorageTmp->mtpSlNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlName);
		StorageTmp->mtpSlName = tmpvar;
		StorageTmp->mtpSlNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlProfile;
		StorageTmp->mtpSlProfile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlProfile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2Default entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2Default not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2Default;
		StorageTmp->mtpSlL2Default = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2Default = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLkIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlLkIndex entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLkIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlLkIndex;
		StorageTmp->mtpSlLkIndex = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLkIndex = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlCode;
		StorageTmp->mtpSlCode = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlCode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlMaxCapacity;
		StorageTmp->mtpSlMaxCapacity = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMaxCapacity = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLinkStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlLinkStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLinkStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlLinkStatus;
		tmplen = StorageTmp->mtpSlLinkStatusLen;
		memdup((void *) &StorageTmp->mtpSlLinkStatus, var_val, var_val_len);
		StorageTmp->mtpSlLinkStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlLinkStatus);
		StorageTmp->mtpSlLinkStatus = tmpvar;
		StorageTmp->mtpSlLinkStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlAdministrativeState;
		StorageTmp->mtpSlAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlLocalInhibit;
		StorageTmp->mtpSlLocalInhibit = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalInhibit = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlLocalUninhibit;
		StorageTmp->mtpSlLocalUninhibit = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalUninhibit = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlReplaceSt;
		StorageTmp->mtpSlReplaceSt = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlReplaceSt = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAlarmSeverityAssignment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlAlarmSeverityAssignment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmSeverityAssignment not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlAlarmSeverityAssignment;
		tmplen = StorageTmp->mtpSlAlarmSeverityAssignmentLen;
		memdup((void *) &StorageTmp->mtpSlAlarmSeverityAssignment, var_val, var_val_len);
		StorageTmp->mtpSlAlarmSeverityAssignmentLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlAlarmSeverityAssignment);
		StorageTmp->mtpSlAlarmSeverityAssignment = tmpvar;
		StorageTmp->mtpSlAlarmSeverityAssignmentLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlRelatedLinkGroupNumber;
		StorageTmp->mtpSlRelatedLinkGroupNumber = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlRelatedLinkGroupNumber = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdlList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdlList;
		StorageTmp->mtpSlSdlList = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlList = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdtList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdtList;
		StorageTmp->mtpSlSdtList = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtList = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlTest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlTest;
		StorageTmp->mtpSlTest = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlTest = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSlsCodeNormalList;
		tmplen = StorageTmp->mtpSlSlsCodeNormalListLen;
		memdup((void *) &StorageTmp->mtpSlSlsCodeNormalList, var_val, var_val_len);
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
		StorageTmp->mtpSlSlsCodeNormalList = tmpvar;
		StorageTmp->mtpSlSlsCodeNormalListLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlAlarmStatus;
		tmplen = StorageTmp->mtpSlAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpSlAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpSlAlarmStatusLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlAlarmStatus);
		StorageTmp->mtpSlAlarmStatus = tmpvar;
		StorageTmp->mtpSlAlarmStatusLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlCode;
		StorageTmp->mtpSlCode = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlCode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdlListPointer;
		tmplen = StorageTmp->mtpSlSdlListPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdlListPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
		StorageTmp->mtpSlSdlListPointer = tmpvar;
		StorageTmp->mtpSlSdlListPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlCode;
		StorageTmp->mtpSlCode = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlCode = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdtListPointer;
		tmplen = StorageTmp->mtpSlSdtListPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdtListPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
		StorageTmp->mtpSlSdtListPointer = tmpvar;
		StorageTmp->mtpSlSdtListPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTransmissionRate;
		StorageTmp->mtpL2ProfileTransmissionRate = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTransmissionRate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileName;
		tmplen = StorageTmp->mtpL2ProfileNameLen;
		memdup((void *) &StorageTmp->mtpL2ProfileName, var_val, var_val_len);
		StorageTmp->mtpL2ProfileNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL2ProfileName);
		StorageTmp->mtpL2ProfileName = tmpvar;
		StorageTmp->mtpL2ProfileNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT1;
		StorageTmp->mtpL2ProfileTimerT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT2;
		StorageTmp->mtpL2ProfileTimerT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT2L entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT2L;
		StorageTmp->mtpL2ProfileTimerT2L = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT2L = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT2H entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT2H;
		StorageTmp->mtpL2ProfileTimerT2H = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT2H = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT3;
		StorageTmp->mtpL2ProfileTimerT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT4N entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT4N;
		StorageTmp->mtpL2ProfileTimerT4N = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT4N = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT4E entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT4E;
		StorageTmp->mtpL2ProfileTimerT4E = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT4E = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT5;
		StorageTmp->mtpL2ProfileTimerT5 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT5 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT6;
		StorageTmp->mtpL2ProfileTimerT6 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT6 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTimerT7;
		StorageTmp->mtpL2ProfileTimerT7 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTimerT7 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileM;
		StorageTmp->mtpL2ProfileM = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileM = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileN1;
		StorageTmp->mtpL2ProfileN1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileN1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileN2;
		StorageTmp->mtpL2ProfileN2 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileN2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileRbAccept(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileRbAccept entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileRbAccept not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileRbAccept;
		StorageTmp->mtpL2ProfileRbAccept = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileRbAccept = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileRbDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileRbDiscard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileRbDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileRbDiscard;
		StorageTmp->mtpL2ProfileRbDiscard = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileRbDiscard = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileRbAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileRbAbate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileRbAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileRbAbate;
		StorageTmp->mtpL2ProfileRbAbate = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileRbAbate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbAbate0(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbAbate0 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbAbate0 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbAbate0;
		StorageTmp->mtpL2ProfileTbAbate0 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbAbate0 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbOnset0(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbOnset0 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbOnset0 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbOnset0;
		StorageTmp->mtpL2ProfileTbOnset0 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbOnset0 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbDiscard0(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbDiscard0 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbDiscard0 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbDiscard0;
		StorageTmp->mtpL2ProfileTbDiscard0 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbDiscard0 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbAbate1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbAbate1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbAbate1;
		StorageTmp->mtpL2ProfileTbAbate1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbAbate1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbOnset1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbOnset1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbOnset1;
		StorageTmp->mtpL2ProfileTbOnset1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbOnset1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbDiscard1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbDiscard1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbDiscard1;
		StorageTmp->mtpL2ProfileTbDiscard1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbDiscard1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbAbate2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbAbate2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbAbate2;
		StorageTmp->mtpL2ProfileTbAbate2 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbAbate2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbOnset2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbOnset2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbOnset2;
		StorageTmp->mtpL2ProfileTbOnset2 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbOnset2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2ProfileTbDiscard2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileTbDiscard2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2ProfileTbDiscard2;
		StorageTmp->mtpL2ProfileTbDiscard2 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2ProfileTbDiscard2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbandTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNbandTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbandTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbandTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbandTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpNbandTransmissionRate;
		StorageTmp->mtpNbandTransmissionRate = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbandTransmissionRate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalBufferRelease;
		StorageTmp->mtpSaalBufferRelease = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalBufferRelease = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxCc;
		StorageTmp->mtpSaalMaxCc = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxCc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxNrp;
		StorageTmp->mtpSaalMaxNrp = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxNrp = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxInformationFieldLength;
		StorageTmp->mtpSaalMaxInformationFieldLength = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxInformationFieldLength = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxLengthSscopUuField;
		StorageTmp->mtpSaalMaxLengthSscopUuField = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxLengthSscopUuField = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxPd;
		StorageTmp->mtpSaalMaxPd = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxPd = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxSscopCreditToPeer;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxSscopCreditToPeer = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxStat;
		StorageTmp->mtpSaalMaxStat = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxStat = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalN1;
		StorageTmp->mtpSaalN1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalN1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementProvingState;
		StorageTmp->mtpSaalNniLayerManagementProvingState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementProvingState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT1;
		StorageTmp->mtpSaalNniTimerT1 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT2;
		StorageTmp->mtpSaalNniTimerT2 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT2 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT3;
		StorageTmp->mtpSaalNniTimerT3 = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT3 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerCc;
		StorageTmp->mtpSaalSscopTimerCc = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerCc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerIdle;
		StorageTmp->mtpSaalSscopTimerIdle = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerIdle = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerKeepAlive;
		StorageTmp->mtpSaalSscopTimerKeepAlive = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerKeepAlive = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerNoResponse;
		StorageTmp->mtpSaalSscopTimerNoResponse = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerNoResponse = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerPoll;
		StorageTmp->mtpSaalSscopTimerPoll = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerPoll = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalTransmissionRateIntervalLower;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSaalPollAfterRetransmission;
		StorageTmp->mtpSaalPollAfterRetransmission = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalPollAfterRetransmission = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paN1;
		StorageTmp->mtpM2paN1 = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paN1 = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paProving entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paProving;
		StorageTmp->mtpM2paProving = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProving = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paManagementProvingState;
		StorageTmp->mtpM2paManagementProvingState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paManagementProvingState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paLoopDelayLower;
		StorageTmp->mtpM2paLoopDelayLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paLoopDelayUpper;
		StorageTmp->mtpM2paLoopDelayUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paTransmissionRateIntervalLower;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalLower = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpNoDelay;
		StorageTmp->mtpM2paSctpNoDelay = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpNoDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxseg;
		StorageTmp->mtpM2paSctpMaxseg = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxseg = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpHeartbeatItvl;
		StorageTmp->mtpM2paSctpHeartbeatItvl = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeatItvl = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpHeartbeat;
		StorageTmp->mtpM2paSctpHeartbeat = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeat = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoInitial;
		StorageTmp->mtpM2paSctpRtoInitial = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoInitial = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoMin;
		StorageTmp->mtpM2paSctpRtoMin = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMin = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoMax;
		StorageTmp->mtpM2paSctpRtoMax = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMax = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpPathMaxRetrans;
		StorageTmp->mtpM2paSctpPathMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpPathMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpCookieLife;
		StorageTmp->mtpM2paSctpCookieLife = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieLife = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpCookieInc;
		StorageTmp->mtpM2paSctpCookieInc = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieInc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxInitRetries;
		StorageTmp->mtpM2paSctpMaxInitRetries = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxInitRetries = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxBurst;
		StorageTmp->mtpM2paSctpMaxBurst = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxBurst = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpAssocMaxRetrans;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpAssocMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpSackDelay;
		StorageTmp->mtpM2paSctpSackDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpSackDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpLifetime;
		StorageTmp->mtpM2paSctpLifetime = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpLifetime = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paProvingAttempts;
		StorageTmp->mtpM2paProvingAttempts = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProvingAttempts = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpL2Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2TableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2Name;
		tmplen = StorageTmp->mtpL2NameLen;
		memdup((void *) &StorageTmp->mtpL2Name, var_val, var_val_len);
		StorageTmp->mtpL2NameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL2Name);
		StorageTmp->mtpL2Name = tmpvar;
		StorageTmp->mtpL2NameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2Profile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpL2Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL2Profile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL2TableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2Profile not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpL2Profile;
		StorageTmp->mtpL2Profile = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL2Profile = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdtAdministrativeState;
		StorageTmp->mtpSdtAdministrativeState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtAdministrativeState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdtEquipmentPointer;
		tmplen = StorageTmp->mtpSdtEquipmentPointerLen;
		memdup((void *) &StorageTmp->mtpSdtEquipmentPointer, var_val, var_val_len);
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
		StorageTmp->mtpSdtEquipmentPointer = tmpvar;
		StorageTmp->mtpSdtEquipmentPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdtName;
		tmplen = StorageTmp->mtpSdtNameLen;
		memdup((void *) &StorageTmp->mtpSdtName, var_val, var_val_len);
		StorageTmp->mtpSdtNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtName);
		StorageTmp->mtpSdtName = tmpvar;
		StorageTmp->mtpSdtNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlAdjPc;
		tmplen = StorageTmp->mtpSdlAdjPcLen;
		memdup((void *) &StorageTmp->mtpSdlAdjPc, var_val, var_val_len);
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlAdjPc);
		StorageTmp->mtpSdlAdjPc = tmpvar;
		StorageTmp->mtpSdlAdjPcLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlTransmissionRate;
		StorageTmp->mtpSdlTransmissionRate = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlTransmissionRate = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlLoopDelay;
		StorageTmp->mtpSdlLoopDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlLoopDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlOperationalState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlOperationalState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlOperationalState;
		StorageTmp->mtpSdlOperationalState = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlOperationalState = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlEquipmentPointer;
		tmplen = StorageTmp->mtpSdlEquipmentPointerLen;
		memdup((void *) &StorageTmp->mtpSdlEquipmentPointer, var_val, var_val_len);
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
		StorageTmp->mtpSdlEquipmentPointer = tmpvar;
		StorageTmp->mtpSdlEquipmentPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlCIC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlCIC;
		tmplen = StorageTmp->mtpSdlCICLen;
		memdup((void *) &StorageTmp->mtpSdlCIC, var_val, var_val_len);
		StorageTmp->mtpSdlCICLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlCIC);
		StorageTmp->mtpSdlCIC = tmpvar;
		StorageTmp->mtpSdlCICLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlName;
		tmplen = StorageTmp->mtpSdlNameLen;
		memdup((void *) &StorageTmp->mtpSdlName, var_val, var_val_len);
		StorageTmp->mtpSdlNameLen = var_val_len;
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlName);
		StorageTmp->mtpSdlName = tmpvar;
		StorageTmp->mtpSdlNameLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlStmChannel;
		StorageTmp->mtpSdlStmChannel = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlStmChannel = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpSdlVcTTpPointer;
		tmplen = StorageTmp->mtpSdlVcTTpPointerLen;
		memdup((void *) &StorageTmp->mtpSdlVcTTpPointer, var_val, var_val_len);
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
		StorageTmp->mtpSdlVcTTpPointer = tmpvar;
		StorageTmp->mtpSdlVcTTpPointerLen = tmplen;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpNoDelay;
		StorageTmp->mtpM2paDefaultSctpNoDelay = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpNoDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxseg;
		StorageTmp->mtpM2paDefaultSctpMaxseg = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxseg = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpHeartbeat;
		StorageTmp->mtpM2paDefaultSctpHeartbeat = *((long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeat = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoInitial;
		StorageTmp->mtpM2paDefaultSctpRtoInitial = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoInitial = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoMin;
		StorageTmp->mtpM2paDefaultSctpRtoMin = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMin = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoMax;
		StorageTmp->mtpM2paDefaultSctpRtoMax = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMax = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpCookieLife;
		StorageTmp->mtpM2paDefaultSctpCookieLife = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieLife = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpCookieInc;
		StorageTmp->mtpM2paDefaultSctpCookieInc = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieInc = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxBurst;
		StorageTmp->mtpM2paDefaultSctpMaxBurst = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxBurst = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..50 */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpSackDelay;
		StorageTmp->mtpM2paDefaultSctpSackDelay = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpSackDelay = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static u_long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(u_long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges (none) */
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpLifetime;
		StorageTmp->mtpM2paDefaultSctpLifetime = *((u_long *) var_val);
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpLifetime = tmpvar;
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */

		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMtTable_data *StorageTmp = NULL;
	static struct mtpMtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpMtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpMtTableStorage, NULL, &name[sizeof(mtpMtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);	/* mtpMtUserPart 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpMtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpMtTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpMtUserPart = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			/* StorageNew->mtpMtAlarmSeverityAssignment = zeroDotZero; */

			StorageNew->mtpMtStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpMtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpMtStatus;
			StorageTmp->mtpMtStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpMtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpMtTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpMtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpMtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpMtTable_add(StorageDel);
		} else {
			StorageTmp->mtpMtStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpMtStatus == RS_CREATEANDGO) {
				StorageTmp->mtpMtStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpMtStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpMtStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	static struct mtpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpMsIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);
			StorageNew->mtpMsIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			/* StorageNew->mtpMsAlarmSeverityAssignment = zeroDotZero; */

			StorageNew->mtpMsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpMsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpMsStatus;
			StorageTmp->mtpMsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpMsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpMsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpMsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpMsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpMsTable_add(StorageDel);
		} else {
			StorageTmp->mtpMsStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpMsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpMsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpMsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpMsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaProfileTable_data *StorageTmp = NULL;
	static struct mtpNaProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNaProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNaProfileTableStorage, NULL, &name[sizeof(mtpNaProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpNaProfileIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNaProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpNaProfileTable_data);
			StorageNew->mtpNaProfileIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpNaProtocolYear = 2000;

			StorageNew->mtpNaProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNaProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNaProfileStatus;
			StorageTmp->mtpNaProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNaProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNaProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNaProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpNaProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNaProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNaProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNaProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNaProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpNaIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);
			StorageNew->mtpNaIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpNaStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNaTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNaStatus;
			StorageTmp->mtpNaStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNaTable_add(StorageDel);
		} else {
			StorageTmp->mtpNaStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNaStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNaStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNaStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNaStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsAdministrativeState = 1;

			StorageNew->mtpGsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsStatus;
			StorageTmp->mtpGsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsListTable_data *StorageTmp = NULL;
	static struct mtpGsListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsListTableStorage, NULL, &name[sizeof(mtpGsListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsListIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpGsListTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsListIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			/* StorageNew->mtpGsListObject = zeroDotZero; */

			StorageNew->mtpGsListStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsListStatus;
			StorageTmp->mtpGsListStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsListTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsListTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsListStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsListStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsListStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsListStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsListStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRuleStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsRuleTable_data *StorageTmp = NULL;
	static struct mtpGsRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsRuleTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsRuleTableStorage, NULL, &name[sizeof(mtpGsRuleTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRuleStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsListIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsRuleIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsRuleTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpGsRuleTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsListIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsRuleIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsRuleStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsRuleTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsRuleStatus;
			StorageTmp->mtpGsRuleStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsRuleTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsRuleTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsRuleTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsRuleTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsRuleTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsRuleStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsRuleStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsRuleStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsRuleStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsRuleStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpProfileIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);
			StorageNew->mtpSpProfileIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpProfileTimerT1R = 80;
			StorageNew->mtpSpProfileTimerT18 = 60000;
			StorageNew->mtpSpProfileTimerT20 = 6000;
			StorageNew->mtpSpProfileTimerT22A = 60000;
			StorageNew->mtpSpProfileTimerT23A = 60000;
			StorageNew->mtpSpProfileTimerT24A = 60000;
			StorageNew->mtpSpProfileTimerT26A = 1350;
			StorageNew->mtpSpProfileTimerT27A = 300;

			StorageNew->mtpSpProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpProfileStatus;
			StorageTmp->mtpSpProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStatus;
			StorageTmp->mtpSpStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpSiTable_data *StorageTmp = NULL;
	static struct mtpSpSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpSiTableStorage, NULL, &name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpSiStatus;
			StorageTmp->mtpSpSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpSiStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyTable_data *StorageTmp = NULL;
	static struct mtpSpStudyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyTableStorage, NULL, &name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);
			StorageNew->mtpSpStudyIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyStatus;
			StorageTmp->mtpSpStudyStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyMapStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyMapTable_data *StorageTmp = NULL;
	static struct mtpSpStudyMapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyMapTableStorage, NULL, &name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyMapStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpStudyIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyMapStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyMapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyMapStatus;
			StorageTmp->mtpSpStudyMapStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyMapTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyMapStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyMapStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyMapStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static struct mtpRsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			if (header_complex_parse_oid(&(name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsProfileTimerT8 = 100;
			StorageNew->mtpRsProfileTimerT11 = 6000;
			StorageNew->mtpRsProfileTimerT15 = 250;
			StorageNew->mtpRsProfileTimerT16 = 175;
			StorageNew->mtpRsProfileTimerT18A = 1200;

			StorageNew->mtpRsProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsProfileStatus;
			StorageTmp->mtpRsProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);
			StorageNew->mtpRsIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsAdministrativeState = 1;
			/* StorageNew->mtpRsAlarmSeverityAssignment = zeroDotZero; */

			StorageNew->mtpRsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsStatus;
			StorageTmp->mtpRsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static struct mtpRsSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);
			StorageNew->mtpRsSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsSiStatus;
			StorageTmp->mtpRsSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsSiStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRlStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRlTable_data *StorageTmp = NULL;
	static struct mtpRlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRlTableStorage, NULL, &name[sizeof(mtpRlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRlStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRlIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRlTable_data);
			StorageNew->mtpRlIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRlAdministrativeState = 1;

			StorageNew->mtpRlStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRlStatus;
			StorageTmp->mtpRlStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRlTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRlTable_add(StorageDel);
		} else {
			StorageTmp->mtpRlStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRlStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRlStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRlStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRlStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static struct mtpRtProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			if (header_complex_parse_oid(&(name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRtProfileTimerT6 = 80;
			StorageNew->mtpRtProfileTimerT10 = 4500;

			StorageNew->mtpRtProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRtProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRtProfileStatus;
			StorageTmp->mtpRtProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRtProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpRtProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRtProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRtProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRtProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRtProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRtIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);
			StorageNew->mtpRtIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRtAdministrativeState = 1;

			StorageNew->mtpRtStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRtStatus;
			StorageTmp->mtpRtStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRtTable_add(StorageDel);
		} else {
			StorageTmp->mtpRtStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRtStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRtStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRtStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRtStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);
			StorageNew->mtpLsIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpLsAdministrativeState = 1;
			/* StorageNew->mtpLsAlarmSeverityAssignment = zeroDotZero; */

			StorageNew->mtpLsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLsStatus;
			StorageTmp->mtpLsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLsTable_add(StorageDel);
		} else {
			StorageTmp->mtpLsStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLkProfileTable_data *StorageTmp = NULL;
	static struct mtpLkProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLkProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLkProfileTableStorage, NULL, &name[sizeof(mtpLkProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			if (header_complex_parse_oid(&(name[sizeof(mtpLkProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpLkProfileTable_data);

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpLkProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLkProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLkProfileStatus;
			StorageTmp->mtpLkProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLkProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLkProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLkProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLkProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLkProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpLkProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLkProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLkProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLkProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLkProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLkStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLkTable_data *StorageTmp = NULL;
	static struct mtpLkTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLkTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLkTableStorage, NULL, &name[sizeof(mtpLkTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLkStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLkIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpLkTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpLkTable_data);
			StorageNew->mtpLkIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpLkOperationalState = disabled;
			StorageNew->mtpLkPeriodicLinkTestFlag = true;
			StorageNew->mtpLkPeriodicLinkTestFail = true;
			StorageNew->mtpLkAdministrativeState = 1;
			/* StorageNew->mtpLkAlarmSeverityAssignemnt = zeroDotZero; */

			StorageNew->mtpLkStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLkTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLkStatus;
			StorageTmp->mtpLkStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLkTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLkTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLkTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLkTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLkTable_add(StorageDel);
		} else {
			StorageTmp->mtpLkStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLkStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLkStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLkStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLkStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlProfileTable_data *StorageTmp = NULL;
	static struct mtpSlProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlProfileTableStorage, NULL, &name[sizeof(mtpSlProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlProfileIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlProfileTable_data);
			StorageNew->mtpSlProfileIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlProfileTimerT20A = 10000;
			StorageNew->mtpSlProfileTimerT21A = 10000;
			StorageNew->mtpSlProfileTimerT22 = 27000;
			StorageNew->mtpSlProfileTimerT24 = 50;
			StorageNew->mtpSlProfileTimerT31A = 6000;
			StorageNew->mtpSlProfileTimerT32A = 6000;
			StorageNew->mtpSlProfileTimerT33A = 36000;
			StorageNew->mtpSlProfileTimerT34A = 6000;

			StorageNew->mtpSlProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlProfileStatus;
			StorageTmp->mtpSlProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);
			StorageNew->mtpSlIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlAdministrativeState = 1;
			StorageNew->mtpSlOperationalState = disabled;
			/* StorageNew->mtpSlAlarmSeverityAssignment = zeroDotZero; */

			StorageNew->mtpSlStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlStatus;
			StorageTmp->mtpSlStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSdlListIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlSdlListStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlSdlListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdlListStatus;
			StorageTmp->mtpSlSdlListStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlSdlListTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlSdlListStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlSdlListStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlSdlListStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlSdlListStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlSdlListStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSdtListIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);
			StorageNew->mtpSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSlSdtListStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlSdtListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdtListStatus;
			StorageTmp->mtpSlSdtListStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlSdtListTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlSdtListStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlSdtListStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlSdtListStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlSdtListStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlSdtListStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2ProfileStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL2ProfileTable_data *StorageTmp = NULL;
	static struct mtpL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpL2ProfileTableStorage, NULL, &name[sizeof(mtpL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2ProfileStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpL2ProfileIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);	/* mtpL2ProfileTransmissionRate 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpL2ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpL2ProfileTable_data);
			StorageNew->mtpL2ProfileIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpL2ProfileTransmissionRate = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpL2ProfileStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpL2ProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpL2ProfileStatus;
			StorageTmp->mtpL2ProfileStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpL2ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL2ProfileTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpL2ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL2ProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpL2ProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpL2ProfileStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpL2ProfileStatus == RS_CREATEANDGO) {
				StorageTmp->mtpL2ProfileStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpL2ProfileStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpL2ProfileStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbandStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbandTable_data *StorageTmp = NULL;
	static struct mtpNbandTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNbandTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNbandTableStorage, NULL, &name[sizeof(mtpNbandTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbandStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpL2ProfileIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNbandTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpNbandTable_data);
			StorageNew->mtpL2ProfileIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpNbandStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNbandTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNbandStatus;
			StorageTmp->mtpNbandStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNbandTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNbandTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNbandTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNbandTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNbandTable_add(StorageDel);
		} else {
			StorageTmp->mtpNbandStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNbandStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNbandStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNbandStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNbandStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpL2ProfileIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);
			StorageNew->mtpL2ProfileIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSaalMaxCc = 4;
			StorageNew->mtpSaalMaxInformationFieldLength = 4096;
			StorageNew->mtpSaalMaxLengthSscopUuField = 4;
			StorageNew->mtpSaalMaxPd = 500;
			StorageNew->mtpSaalN1 = 67;
			StorageNew->mtpSaalNniLayerManagementProvingState = 1000;
			StorageNew->mtpSaalNniTimerT1 = 500;
			StorageNew->mtpSaalNniTimerT2 = 3000;
			StorageNew->mtpSaalSscopTimerCc = 20;
			StorageNew->mtpSaalSscopTimerIdle = 10;
			StorageNew->mtpSaalSscopTimerKeepAlive = 10;
			StorageNew->mtpSaalSscopTimerNoResponse = 150;
			StorageNew->mtpSaalSscopTimerPoll = 10;
			StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
			StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;

			StorageNew->mtpSaalStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSaalTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSaalStatus;
			StorageTmp->mtpSaalStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSaalTable_add(StorageDel);
		} else {
			StorageTmp->mtpSaalStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSaalStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSaalStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSaalStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSaalStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpL2ProfileIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);
			StorageNew->mtpL2ProfileIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpM2paN1 = 1000;
			StorageNew->mtpM2paProving = true;
			StorageNew->mtpM2paSctpAssocMaxRetrans = 20;

			StorageNew->mtpM2paStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpM2paTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpM2paStatus;
			StorageTmp->mtpM2paStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpM2paTable_add(StorageDel);
		} else {
			StorageTmp->mtpM2paStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpM2paStatus == RS_CREATEANDGO) {
				StorageTmp->mtpM2paStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpM2paStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpM2paStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL2Status(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL2Table_data *StorageTmp = NULL;
	static struct mtpL2Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL2Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpL2TableStorage, NULL, &name[sizeof(mtpL2Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL2Status not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpL2Index 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpL2Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpL2Table_data);
			StorageNew->mtpL2Index = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpL2Status = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpL2Table_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpL2Status;
			StorageTmp->mtpL2Status = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpL2TableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL2TableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpL2TableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL2TableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpL2Table_add(StorageDel);
		} else {
			StorageTmp->mtpL2Status = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpL2Status == RS_CREATEANDGO) {
				StorageTmp->mtpL2Status = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpL2Status == RS_CREATEANDWAIT) {
				StorageTmp->mtpL2Status = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSdtIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);
			StorageNew->mtpSdtIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSdtAdministrativeState = 1;

			StorageNew->mtpSdtStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSdtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSdtStatus;
			StorageTmp->mtpSdtStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSdtTable_add(StorageDel);
		} else {
			StorageTmp->mtpSdtStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSdtStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSdtStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSdtStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSdtStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);

	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);

	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;

	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */

			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;

			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}

			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;

	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;

			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSdlIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;

			StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);
			StorageNew->mtpSdlIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSdlRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}

		break;

	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */

		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSdlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
		}
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSdlTable_add(StorageDel);
		} else {
			StorageTmp->mtpSdlRowStatus = old_value;
		}
		break;

	case COMMIT:
	{
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSdlRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSdlRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSdlRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSdlRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	}
	return SNMP_ERR_NOERROR;
}

#if !defined MODULE
static void
sa_version(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
%2$s\n\
Copyright (c) 2001-2008  OpenSS7 Corporation.  All Rights Reserved.\n\
Distributed under Affero GPL Version 3, included here by reference.\n\
See `%1$s --copying' for copying permissions.\n\
", argv[0], ident);
}

static void
sa_usage(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-H|--help-directives}\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
", argv[0]);
}

static void
sa_help(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
Arguments:\n\
    None.\n\
Options:\n\
    -a, --log-addresses\n\
        log addresses of connecting management stations.\n\
    -A, --append\n\
        append to logfiles without truncating.\n\
    -c, --config-file CONFIGFILE\n\
        use configuration file CONFIGFILE.\n\
    -C, --config-only\n\
        only load configuration given by -c option.\n\
    -d, --dump\n\
        dump sent and received PDUs.\n\
    -D, --debug [LEVEL]\n\
        set debugging verbosity to LEVEL.\n\
    -D, --debug-tokens [TOKEN[,TOKEN]*]\n\
        debug specified TOKEN's.\n\
    -f, --dont-fork\n\
        run in the foreground.\n\
    -g, --gid, --groupid GID\n\
        become group GID after listening.\n\
    -h, --help, -?, --?\n\
        print usage information and exit.\n\
    -H, --help-directives\n\
        print config directives and exit.\n\
    -I, --initialize [-]MODULE[,MODULE]*\n\
        initialize (or not, '-') these MODULE's.\n\
    -k, --keep-open\n\
        keep system files open between requests.\n\
    -l, --log-file [LOGFILE]\n\
        log to log file name LOGFILE.  [default: /var/log/mtpmib2.log]\n\
    -L, --log-stderr\n\
        log to controlling terminal standard error.\n\
    -m, --mibs [+]MIB[,MIB]*\n\
        load these (additional '+') MIBs.\n\
    -M, --master\n\
        run as SNMP master instead of AgentX sub-agent.\n\
    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\n\
        search these (additional, '+') colon separated directories for MIBs.\n\
    -n, --nodaemon\n\
        run in the foreground.\n\
    -n, --name NAME\n\
        use NAME for configuration file base.  [default: mtpmib2]\n\
    -p, --port PORTNUM\n\
        listen on port number PORTNUM.  [default: 161]\n\
    -p, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/mtpmib2.pid]\n\
    -P, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/mtpmib2.pid]\n\
    -q, --quiet\n\
        suppress normal output.\n\
    -q, --quick\n\
        abbreviate output for machine readability.\n\
    -r, --noroot\n\
        do not require root privilege.\n\
    -s, --log-syslog\n\
        log to system logs.\n\
    -S, --sysctl-file FILENAME\n\
        write sysctl config file FILENAME.  [default: /etc/streams.conf]\n\
    -t, --agent-alarms\n\
        agent blocks {SIGALARM}.\n\
    -T, --transport [TRANSPORT]\n\
        default transport TRANSPORT.  [default: udp]\n\
    -u, --uid, --userid UID\n\
        become user UID after listening.\n\
    -U, --dont-remove-pidfile\n\
        do not remove PIDFILE when shutting down.\n\
    -v, --version\n\
        print version information and exit.\n\
    -V, --verbose [LEVEL]\n\
        be verbose to LEVEL.  [default: 1]\n\
    -x, --agentx-socket [SOCKET]\n\
        master AgentX on SOCKET.  [default: /var/agentx/master]\n\
    -X, --agentx\n\
        run as AgentX sub-agent instead of master (the default).\n\
    -y, --copying\n\
        print copying information and exit.\n\
", argv[0]);
}

static void
sa_copying(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
--------------------------------------------------------------------------------\n\
%1$s\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\n\
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms of the GNU Affero General Public License as published by the Free\n\
Software Foundation; Version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the GNU  Affero  General Public License along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\n\
", ident);
}

void
sa_help_directives(int argc, char *argv[])
{
	ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
	init_agent("mtpMIB2");
	// init_mib_modules();
	init_mib();
	init_snmp("mtpMIB2");
	snmp_log(MY_FACILITY(LOG_INFO), "Configuration directives understood:\n");
	/* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be
	   writen to standard error and not standard output. */
	read_config_print_usage("    ");
}

static int
sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = handler ? handler : SIG_DFL;
	act.sa_flags = handler ? SA_RESTART : 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(signum, &act, NULL))
		return (-1);
	sigemptyset(&mask);
	sigaddset(&mask, signum);
	sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
	return (0);
}

static int sa_alm_signal = 0;
static int sa_pol_signal = 0;
static int sa_hup_signal = 0;
static int sa_int_signal = 0;
static int sa_trm_signal = 0;

static int sa_alm_handle = 0;

void
sa_alm_callback(unsigned int req, void *arg)
{
	if (req == sa_alm_handle)
		sa_alm_handle = 0;
	sa_alm_signal = 1;
	return;
}

static RETSIGTYPE
sa_alm_handler(int signum)
{
	sa_alm_signal = 1;
	return (RETSIGTYPE) (0);
}

static void
sa_snmp_alm_handler(unsigned int reg, void *clientarg)
{
	sa_alm_signal = 1;
	return;
}

static int
sa_alm_catch(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, &sa_alm_handler);
	return (-1);
}

static int
sa_alm_block(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, NULL);
	if (sa_alm_handle) {
		unsigned int handle = sa_alm_handle;

		sa_alm_handle = 0;
		snmp_alarm_unregister(handle);
	}
	return (0);
}

static int
sa_alm_action(void)
{
	sa_alm_signal = 0;
	return (0);
}

static RETSIGTYPE
sa_pol_handler(int signum)
{
	sa_pol_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_pol_catch(void)
{
	return sa_sig_register(SIGPOLL, &sa_pol_handler);
}

static int
sa_pol_block(void)
{
	return sa_sig_register(SIGPOLL, NULL);
}

/*
 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
 * configuration changes, indicating to the agent which has the sc(4) or
 * sad(4) Stream open that it is necessary to reread information from the
 * kernel.  This fact is merely recorded, as this information is not read each
 * time that a configuration change occurs, but only after a request from some
 * portion of that information occurs. This condition is also set when the
 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
 * siginfo the file descriptor issuing the signal, so we could distiguish
 * between sc(4) and sad(4) signals, but since one can be pushed over the
 * other, there is little point in distinguishing.
 *
 * sc(4) or sad(4) also should be modified to provide the general streams
 * statistics supported here; even though they are available through the /proc
 * filesystem on Linux Fast-STREAMS.
 */
static int
sa_pol_action(void)
{
	sa_pol_signal = 0;
	snmp_log(MY_FACILITY(LOG_INFO), "%s: Caught SIGPOLL, will re-read data structures", sa_program);
	sa_changed = 1;
	return (0);
}

static RETSIGTYPE
sa_hup_handler(int signum)
{
	sa_hup_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_hup_catch(void)
{
	if (sa_agentx)
		return sa_sig_register(SIGHUP, &sa_hup_handler);
	return (-1);
}

static int
sa_hup_block(void)
{
	return sa_sig_register(SIGHUP, NULL);
}

static int
sa_hup_action(void)
{
	/* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by
	   logrotate asking us to close and reopen our log files. */
	sa_hup_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "Caught SIGHUP, reopening files.");
	if (sa_output > 1)
		snmp_log(MY_FACILITY(LOG_NOTICE), "Reopening output file %s", sa_logfile);
	if (sa_logfillog != 0) {
		fflush(stdlog);
		fclose(stdlog);
		snmp_disable_filelog();
		if ((stdlog = freopen(sa_logfile, sa_appendlog ? "a" : "w", stdlog)) == NULL) {
			/* I hope we have another log sink. */
			snmp_log(MY_FACILITY(LOG_ERR), "%s", strerror(errno));
			snmp_log(MY_FACILITY(LOG_ERR), "Could not reopen log file %s", sa_logfile);
		}
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	return (0);
}

static RETSIGTYPE
sa_int_handler(int signum)
{
	sa_int_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_int_catch(void)
{
	return sa_sig_register(SIGINT, &sa_int_handler);
}

static int
sa_int_block(void)
{
	return sa_sig_register(SIGINT, NULL);
}

static void sa_exit(int retval);

static int
sa_int_action(void)
{
	sa_int_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGINT, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static RETSIGTYPE
sa_trm_handler(int signum)
{
	sa_trm_signal = 1;
	return (RETSIGTYPE) (0);
}

static int
sa_trm_catch(void)
{
	return sa_sig_register(SIGTERM, &sa_trm_handler);
}

static int
sa_trm_block(void)
{
	return sa_sig_register(SIGTERM, NULL);
}

static void sa_exit(int retval);

static int
sa_trm_action(void)
{
	sa_trm_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGTERM, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static void
sa_sig_catch(void)
{
	sa_alm_catch();
	sa_pol_catch();
	sa_hup_catch();
	sa_int_catch();
	sa_trm_catch();
}

static void
sa_sig_block(void)
{
	sa_alm_block();
	sa_pol_block();
	sa_hup_block();
	sa_int_block();
	sa_trm_block();
}

int
sa_start_timer(long duration)
{
	if (sa_alarms) {
		struct itimerval setting = {
			{0, 0},
			{duration / 1000, (duration % 1000) * 1000}
		};

		if (sa_alm_catch())
			return (-1);
		if (setitimer(ITIMER_REAL, &setting, NULL))
			return (-1);
		sa_alm_signal = 0;
		return (0);
	} else {
#if defined NETSNMP_DS_APPLICATION_ID
		struct timeval setting = {
			duration / 1000, (duration % 1000) * 1000
		};

		sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
#else
		sa_alm_handle = snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
#endif
		return (sa_alm_handle ? 0 : -1);
	}
}

static void
sa_exit(int retval)
{
	if (retval)
		snmp_log(MY_FACILITY(LOG_ERR), "%s: Exiting %d", sa_program, retval);
	else
		snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Exiting %d", sa_program, retval);
	fflush(stdout);
	fflush(stderr);
	sa_sig_block();
	closelog();
	exit(retval);
}

static void
sa_init_logging(int argc, char *argv[])
{
	static char progname[256];

	/* The purpose of this function is to bring logging up before forking (and while still in
	   the foreground) so that we can use the snmp_log() function before and during forking if
	   necessary.  Note that the default configuration for snmp_log() is to send all logs to
	   standard error. */
	strncpy(progname, basename(argv[0]), sizeof(progname));

	snmp_disable_log();
	if (sa_logfillog) {
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	if (sa_logstderr | sa_logstdout) {
#if defined LOG_PERROR
		/* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr,
		   it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as
		   the former is better formated. */
		if (!sa_logsyslog)
			snmp_enable_stderrlog();
#else				/* defined LOG_PERROR */
		snmp_enable_stderrlog();
#endif				/* defined LOG_PERROR */
	}
	if (sa_logsyslog) {
#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
		snmp_enable_syslog();
#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		snmp_enable_syslog_ident("mtpMIB2", LOG_DAEMON);
#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		/* Note that the way that snmp sets up the logger is not really the way we want it,
		   so close the log and reopen it the way we want. */
		closelog();
#if defined LOG_PERROR
		openlog("mtpMIB2", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0), MY_FACILITY(0));
#else				/* defined LOG_PERROR */
		openlog("mtpMIB2", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
#endif				/* defined LOG_PERROR */
	}
	if (sa_logcallog) {
		snmp_enable_calllog();
	}
}

static void
sa_enter(int argc, char *argv[])
{
	if (sa_nomead) {
		pid_t pid;

		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent exits */
			exit(0);
		}
		setsid();	/* become a session leader */
		/* fork once more for SVR4 */
		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent responsible for writing pid file */
			if (sa_nomead || sa_pidfile[0] != '\0') {
				FILE *pidf;

				/* initialize default filename */
				if (sa_pidfile[0] == '\0')
					snprintf(sa_pidfile, sizeof(sa_pidfile), "/var/run/%s.pid", sa_program);
				if (sa_output > 1) {
					snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Writing daemon pid to file %s", sa_program, sa_pidfile);
				}
				if ((pidf = fopen(sa_pidfile, "w+"))) {
					fprintf(pidf, "%d", (int) pid);
					fflush(pidf);
					fclose(pidf);
				} else {
					snmp_log(MY_FACILITY(LOG_ERR), "%s: %m", sa_program);
					snmp_log(MY_FACILITY(LOG_ERR), "%s: Could not write pid to file %s", sa_program, sa_pidfile);
					sa_exit(2);
					/* no return */
				}
			}
			/* parent exits */
			exit(0);
		}
		/* child continues */
		/* release current directory */
		if (chdir("/") < 0) {
			perror(argv[0]);
			exit(2);
		}
		umask(0);	/* clear file creation mask */
		/* rearrange file streams */
		fclose(stdin);
	}
	/* continue as foreground or background */
	sa_init_logging(argc, argv);
	sa_sig_catch();
	snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Startup complete.", sa_program);
}

static void
sa_mloop(int argc, char *argv[])
{
	if (sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as AgentX client\n", argv[0]);
		/* run as an AgentX client */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
	} else {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master agent\n", argv[0]);
		/* run as SNMP master */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
	}

	if (sa_alarms) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using application alarms\n", argv[0]);
		/* use application alarms */
		ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
	}

	/* initialize agent */
	init_agent("mtpMIB2");

	/* initialize MIB */
	init_mtpMIB2();

	/* initialize SNMP */
	init_snmp("mtpMIB2");

	if (!sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master\n", argv[0]);
#if !defined NETSNMP_DS_APPLICATION_ID
		init_master_agent(710, NULL, NULL);
#else
		init_master_agent();
#endif
	}

	for (;;) {
		int retval;

		/* to use select or poll you need to use the snmp_select_info() to obtain the fd of 
		   the agentx socket and add it to the fdset. */
		/* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */

#if 0
		if (snmp_select() == 0) {
			if (sa_alarms == 0)
				run_alarms();
		}
#endif
		retval = agent_check_and_process(1);	/* 0 == don't block */

		if (retval == 0) {
			/* alarm occurred, alarm conditions checked */
		} else if (retval == -1) {
			/* error (or signal) ocurred */
			if (sa_alm_signal) {
				sa_alm_action();
			}
			if (sa_pol_signal) {
				sa_pol_action();
			}
			if (sa_hup_signal) {
				sa_hup_action();
			}
			if (sa_int_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("mtpMIB2");
				sa_int_action();	/* no return */
			}
			if (sa_trm_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("mtpMIB2");
				sa_trm_action();	/* no return */
			}
		} else if (retval > 0) {
			/* processed packets */
			if (sa_fclose) {
				/* close files after each request */
				if (sa_fd != 0) {
					int fd = sa_fd;

					sa_fd = 0;
					close(fd);
				}
			}
			sa_stats_refresh = 1;
			sa_request++;
		}
	}

	if (sa_debug)
		snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
	snmp_shutdown("mtpMIB2");
}

int
main(int argc, char *argv[])
{
	for (;;) {
		int c, val, fd;
		char *cptr;
		struct passwd *pw;
		struct group *gr;
		struct stat st;

#if defined _GNU_SOURCE
		int option_index = 0;
                /* *INDENT-OFF* */
                static struct option long_options[] = {
                        {"log-addresses",	no_argument,		NULL, 'a'},
                        {"append",		no_argument,		NULL, 'A'},
                        {"config-file",		required_argument,	NULL, 'c'},
                        {"no-configs",		no_argument,		NULL, 'C'},
                        {"dump",		no_argument,		NULL, 'd'},
                        {"debug",		optional_argument,	NULL, 'D'},
                        {"debug-tokens",	optional_argument,	NULL, 'D'},
                        {"dont-fork",		no_argument,		NULL, 'f'},
                        {"gid",			required_argument,	NULL, 'g'},
                        {"groupid",		required_argument,	NULL, 'g'},
                        {"help",		no_argument,		NULL, 'h'},
                        {"?",			no_argument,		NULL, 'h'},
                        {"help-directives",	no_argument,		NULL, 'H'},
                        {"initialize",		required_argument,	NULL, 'I'},
                        {"init-modules",	required_argument,	NULL, 'I'},
                        {"keep-open",		no_argument,		NULL, 'k'},
                        {"log-file",		optional_argument,	NULL, 'l'},
                        {"logfile",		optional_argument,	NULL, 'l'},
                        {"Lf",			optional_argument,	NULL, 'l'},
                        {"LF",			required_argument,	NULL, 'l'},
                        {"log-stderr",		no_argument,		NULL, 'L'},
                        {"Le",			no_argument,		NULL, 'L'},
                        {"LE",			required_argument,	NULL, 'L'},
                        {"mibs",		required_argument,	NULL, 'm'},
                        {"master",		no_argument,		NULL, 'M'},
                        {"mibdirs",		required_argument,	NULL, 'M'},
                        {"nodaemon",		no_argument,		NULL, 'n'},
                        {"name",		required_argument,	NULL, 'n'},
                        {"dry-run",		no_argument,		NULL, 'N'},
                        {"log-stdout",		no_argument,		NULL, 'o'},
                        {"Lo",			no_argument,		NULL, 'o'},
                        {"LO",			required_argument,	NULL, 'o'},
                        {"port",		required_argument,	NULL, 'p'},
                        {"pidfile",		required_argument,	NULL, 'P'},
                        {"quiet",		no_argument,		NULL, 'q'},
                        {"quick",		no_argument,		NULL, 'q'},
                        {"noroot",		no_argument,		NULL, 'r'},
                        {"log-syslog",		no_argument,		NULL, 's'},
                        {"Ls",			no_argument,		NULL, 's'},
                        {"LS",			required_argument,	NULL, 's'},
                        {"syslog",		no_argument,		NULL, 's'},
                        {"sysctl-file",		required_argument,	NULL, 'S'},
                        {"agent-alarms",	no_argument,		NULL, 't'},
                        {"transport",		optional_argument,	NULL, 'T'},
                        {"uid",			required_argument,	NULL, 'u'},
                        {"userid",		required_argument,	NULL, 'u'},
                        {"dont-remove-pidfile",	no_argument,		NULL, 'U'},
                        {"leave-pidfile",	no_argument,		NULL, 'U'},
                        {"version",		no_argument,		NULL, 'v'},
                        {"verbose",		optional_argument,	NULL, 'V'},
                        {"agentx-socket",	required_argument,	NULL, 'x'},
                        {"agentx",		no_argument,		NULL, 'X'},
                        {"copying",		no_argument,		NULL, 'y'},
#if 0
                        {"directory",		required_argument,	NULL, 'd'},
                        {"basename",		required_argument,	NULL, 'b'},
                        {"outfile",		required_argument,	NULL, 'o'},
                        {"errfile",		required_argument,	NULL, 'e'},
#endif
                        { 0, }
                };
                /* *INDENT-ON* */

		c = getopt_long_only(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy");
#endif				/* defined _GNU_SOURCE */
		if (c == -1) {
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: done options processing\n", argv[0]);
			break;
		}
		switch (c) {
		case 0:
			goto bad_usage;
		case 'a':	/* -a, --log-addresses */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging addresses\n", argv[0]);
			sa_logaddr++;
			break;
		case 'A':	/* -A, --append */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will not truncate logfile\n", argv[0]);
#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
			ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
			sa_appendlog = 1;
			break;
		case 'c':	/* -c, --config-file CONFIGFILE */
			if (optarg == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using configuration file %s\n", argv[0], optarg);
			ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
			break;
		case 'C':	/* -C, --no-configs */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: not reading default config files\n", argv[0]);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
			break;
		case 'd':	/* -d, --dump */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting packet dump\n", argv[0]);
			sa_dump = 1;
			// snmp_set_dump_packet(sa_dump);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
			break;
		case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing debug verbosity\n", argv[0]);
			if (optarg == NULL) {
				/* no option: must be -D, --debug */
				sa_debug++;
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging all tokens\n", argv[0]);
				if (sa_debug)
					debug_register_tokens("ALL");
			} else {
				cptr = optarg;
				if ((val = strtol(optarg, &cptr, 0)) < 0)
					goto bad_option;
				if (*cptr == '\0') {
					/* it is just a number, must be -D, --debug [LEVEL] */
					sa_debug = val;
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				} else {
					/* not a number, must be -D, --debug-tokens TOKENS */
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging tokens %s\n", argv[0], optarg);
					debug_register_tokens(optarg);
				}
			}
			break;
		case 'f':	/* -f, --dont-fork */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing daemon mode\n", argv[0]);
			sa_nomead = 0;
			break;
		case 'u':	/* -u, --uid, --userid UID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* UID can be name or number */
			if ((pw = (*cptr == '\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as uid %s(%d)\n", argv[0], pw->pw_name, pw->pw_uid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
			break;
		case 'g':	/* -g, --gid, --groupdid GID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* GID can be name or number */
			if ((gr = (*cptr == '\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as gid %s(%d)\n", argv[0], gr->gr_name, gr->gr_gid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
			break;
		case 'h':	/* -h, --help, -?, --? */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing help message\n", argv[0]);
			sa_help(argc, argv);
			exit(0);
		case 'H':	/* -H, --help-directives */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing config directives\n", argv[0]);
			sa_help_directives(argc, argv);
			exit(0);
		case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will initialize modules: %s\n", argv[0], optarg);
			add_to_init_list(optarg);
			break;
		case 'k':	/* -k, --keep-open */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: keeping files open\n", argv[0]);
			sa_fclose = 0;
			break;
		case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
			if (optarg != NULL)
				strncpy(sa_logfile, optarg, sizeof(sa_logfile));
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will log to file %s\n", argv[0], sa_logfile);
			sa_logfillog = 1;
			break;
		case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
			/* Note that the recent NET-SNMP version of this option is far more
			   complicated: -Le is the same as the old version of the option; -Lf
			   LOGFILE is like the -l option; -Ls is like the -s option; -Lo logs
			   messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or 
			   O, logs priority p1 and above to X, or p1 thru p2 to X. */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to standard error\n", argv[0]);
			sa_logstderr = 1;
			break;
		case 'm':	/* -m, --mibs MIBS */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBS %s\n", argv[0], optarg);
			break;
		case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
			if (optarg) {
				/* -M, --mibdirs MIBDIRS */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBDIRS %s\n", argv[0], optarg);
			} else {
				/* -M, --master */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting SNMP master\n", argv[0]);
				sa_agentx = 0;
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
			}
			break;
		case 'n':	/* -n, --nodaemon or -n, --name NAME */
			if (optarg) {
				/* -n, --name NAME */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using name %s\n", argv[0], optarg);
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
			} else {
				/* -n, --nodaemon */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing deamon mode\n", argv[0]);
				sa_nomead = 0;
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, basename(argv[0]));
			}
			break;
		case 'N':	/* -N, --dry-run */
#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for dry-runs startup\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
			break;
#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -N option not supported\n", argv[0]);
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
		case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to stdout\n", argv[0]);
			sa_logstdout = 1;
			break;
		case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
				goto bad_option;
			if (*cptr == '\0') {
				char buf[4096];

				/* -p, --port PORTNUM */
				if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
					snprintf(buf, sizeof(buf), "%s,%s", cptr, optarg);
				else
					strncpy(buf, optarg, sizeof(buf));
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
				break;
			}
			/* fall through */
		case 'P':	/* -p, -P, --pidfile PIDFILE */
			if (optarg) {
				/* either it exists */
				if (stat(optarg, &st) == -1) {
					/* or we can create it */
					if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
						perror(argv[0]);
						goto bad_option;
					}
					close(fd);
				}
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting pid file to %s\n", argv[0], optarg);
				strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
			}
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using pidfile %s\n", argv[0], sa_pidfile);
			break;
		case 'q':	/* -q, --quiet, --quick */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing normal output\n", argv[0]);
			sa_debug = 0;
			sa_output = 0;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			// snmp_set_quick_print();
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
			break;
		case 'r':	/* -r, --noroot */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for non-root access\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
			break;
		case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to system logs\n", argv[0]);
			sa_logsyslog = 1;
			break;
		case 'S':	/* -S, -sysctl-file FILENAME */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using %s for backing\n", argv[0], optarg);
			strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
			break;
		case 't':	/* -t, --agent-alarms */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting agent alarms\n", argv[0]);
			sa_alarms = 0;
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
			break;
		case 'T':	/* -T, --transport [TRANSPORT] */
			if (optarg == NULL)
				goto udp_transport;
			if (!strcasecmp("TCP", optarg)) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to TCP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val |= SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else if (!strcasecmp("UDP", optarg)) {
			      udp_transport:
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to UDP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val &= ~SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else
				goto bad_option;
			break;
		case 'U':
#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will leave pidfile after shutdown\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
#else
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -U option not supported\n");
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
			break;
		case 'v':	/* -v, --version */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing version message\n", argv[0]);
			sa_version(argc, argv);
			exit(0);
		case 'V':	/* -V, --verbose [LEVEL] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing output verbosity\n", argv[0]);
			if (optarg == NULL) {
				sa_output++;
			} else {
				if ((val = strtol(optarg, NULL, 0)) < 0)
					goto bad_option;
				sa_output = val;
			}
			if (sa_output > 1)
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
			else
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			break;
		case 'x':	/* -x, --agentx-socket SOCKET */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX socket to %s\n", argv[0], optarg);
			ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
			// ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
			break;
		case 'X':	/* -X, --agentx */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX sub-agent\n", argv[0]);
			sa_agentx = 1;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
			break;
		case 'y':	/* -y, --copying */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing copying message\n", argv[0]);
			sa_copying(argc, argv);
			exit(0);
		case '?':
		case ':':
		default:
		      bad_option:
			optind--;
			goto bad_nonopt;
		      bad_nonopt:
			if (sa_output || sa_debug) {
				if (optind < argc) {
					fprintf(stderr, "%s: syntax error near '", argv[0]);
					while (optind < argc)
						fprintf(stderr, "%s ", argv[optind++]);
					fprintf(stderr, "'\n");
				} else {
					fprintf(stderr, "%s: missing option or argument", argv[0]);
					fprintf(stderr, "\n");
				}
				fflush(stderr);
			      bad_usage:
				sa_usage(argc, argv);
			}
			exit(2);
		}
	}
	if (optind < argc) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: excess non-option arguments\n", argv[0]);
		goto bad_nonopt;
	}
	sa_enter(argc, argv);	/* daemonize if necessary */
	sa_mloop(argc, argv);	/* execute main loop */
	exit(0);
}
#endif				/* !defined MODULE */

