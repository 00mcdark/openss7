/*****************************************************************************

 @(#) $RCSfile: mtpMIB2.c,v $ $Name:  $($Revision: 0.9.2.2 $) $Date: 2008-12-24 13:08:23 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-24 13:08:23 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpMIB2.c,v $
 Revision 0.9.2.2  2008-12-24 13:08:23  brian
 - building ss7confd

 *****************************************************************************/

#ident "@(#) $RCSfile: mtpMIB2.c,v $ $Name:  $($Revision: 0.9.2.2 $) $Date: 2008-12-24 13:08:23 $"

static char const ident[] = "$RCSfile: mtpMIB2.c,v $ $Name:  $($Revision: 0.9.2.2 $) $Date: 2008-12-24 13:08:23 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include "mtpMIB2_storage.h"
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];
int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int mtpMIB2_refresh = 1;
volatile int mtpSapTable_refresh = 1;
volatile int ss7NetworkTable_refresh = 1;
volatile int mtpMsTable_refresh = 1;
volatile int mtpNaTable_refresh = 1;
volatile int mtpGsTable_refresh = 1;
volatile int mtpGsLineTable_refresh = 1;
volatile int mtpGsLineContentTable_refresh = 1;
volatile int mtpSpProfileTable_refresh = 1;
volatile int mtpSpTable_refresh = 1;
volatile int mtpSpStatsTable_refresh = 1;
volatile int mtpSpCurrentTable_refresh = 1;
volatile int mtpSpInt5minTable_refresh = 1;
volatile int mtpSpInt15minTable_refresh = 1;
volatile int mtpSpSiTable_refresh = 1;
volatile int mtpSpSiInt5minTable_refresh = 1;
volatile int mtpSpSiInt15minTable_refresh = 1;
volatile int mtpSpStudyTable_refresh = 1;
volatile int mtpSpStudyInt5minTable_refresh = 1;
volatile int mtpSpStudyInt15minTable_refresh = 1;
volatile int mtpSpStudyMapTable_refresh = 1;
volatile int mtpL3Table_refresh = 1;
volatile int mtpRsProfileTable_refresh = 1;
volatile int mtpRsTable_refresh = 1;
volatile int mtpRsStatsTable_refresh = 1;
volatile int mtpRsCurrentTable_refresh = 1;
volatile int mtpRsInt5minTable_refresh = 1;
volatile int mtpRsInt15minTable_refresh = 1;
volatile int mtpRsSiTable_refresh = 1;
volatile int mtpRsSiInt5minTable_refresh = 1;
volatile int mtpRsSiInt15minTable_refresh = 1;
volatile int mtpRtProfileTable_refresh = 1;
volatile int mtpRtTable_refresh = 1;
volatile int mtpRtLsaTable_refresh = 1;
volatile int mtpLsProfileTable_refresh = 1;
volatile int mtpLsTable_refresh = 1;
volatile int mtpLsStatsTable_refresh = 1;
volatile int mtpLsCurrentTable_refresh = 1;
volatile int mtpLsInt5minTable_refresh = 1;
volatile int mtpLsInt15minTable_refresh = 1;
volatile int mtpSlL3ProfileTable_refresh = 1;
volatile int mtpSlL2ProfileTable_refresh = 1;
volatile int mtpSlTable_refresh = 1;
volatile int mtpSlSdlListTable_refresh = 1;
volatile int mtpSlSdtListTable_refresh = 1;
volatile int mtpSlStatsTable_refresh = 1;
volatile int mtpSlL3CurrentTable_refresh = 1;
volatile int mtpSlL3Int5minTable_refresh = 1;
volatile int mtpSlL3Int15minTable_refresh = 1;
volatile int mtpSlL2CurrentTable_refresh = 1;
volatile int mtpSlL2Int5minTable_refresh = 1;
volatile int mtpSlL2Int15minTable_refresh = 1;
volatile int mtpNbTable_refresh = 1;
volatile int mtpSaalTable_refresh = 1;
volatile int mtpM2paTable_refresh = 1;
volatile int mtpSdtTable_refresh = 1;
volatile int mtpSdtStatsTable_refresh = 1;
volatile int mtpSdlTable_refresh = 1;
volatile int mtpSdlStatsTable_refresh = 1;

/*
 * mtpMIB2_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid mtpMIB2_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1 };
oid mtpSapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 1, 1, 1 };
oid ss7NetworkTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 2, 1, 1 };
oid mtpMsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 1, 1 };
oid mtpNaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 1, 1 };
oid mtpGsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 1, 1 };
oid mtpGsLineTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 2, 1 };
oid mtpGsLineContentTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 3, 1 };
oid mtpSpProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 1, 1 };
oid mtpSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 2, 1 };
oid mtpSpStatsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 3, 1 };
oid mtpSpSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 7, 1 };
oid mtpSpStudyTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 10, 1 };
oid mtpSpStudyMapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 13, 1 };
oid mtpL3Table_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 7, 1, 1 };
oid mtpRsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 1, 1 };
oid mtpRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 2, 1 };
oid mtpRsStatsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 3, 1 };
oid mtpRsSiTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 7, 1 };
oid mtpRtProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 1, 1 };
oid mtpRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 2, 1 };
oid mtpLsProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 1, 1 };
oid mtpLsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 2, 1 };
oid mtpLsStatsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 3, 1 };
oid mtpSlL3ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 1, 1 };
oid mtpSlL2ProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 2, 1 };
oid mtpSlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 3, 1 };
oid mtpSlSdlListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 4, 1 };
oid mtpSlSdtListTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 5, 1 };
oid mtpNbTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 1, 1 };
oid mtpSaalTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 2, 1 };
oid mtpM2paTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 3, 1 };
oid mtpSdtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 4, 1 };
oid mtpSdlTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 1, 1 };

/*
 * variable7 mtpMIB2_variables:
 *   this variable defines function callbacks and type return information
 *   for the mtpMIB2 mib section
 */
struct variable7 mtpMIB2_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   MTPSAP2ADDRESS        4
	{MTPSAP2ADDRESS, ASN_UNSIGNED, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSAPUSERPART        5
	{MTPSAPUSERPART, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSAPUSERPARTSTATUS  6
	{MTPSAPUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSAPUSERENTITYNAMES  7
	{MTPSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSAPPROVIDERENTITYNAMES  8
	{MTPSAPPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSAPUSAGESTATE      9
	{MTPSAPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSAPASAPROFILEPOINTER  10
	{MTPSAPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPSAPNAME            11
	{MTPSAPNAME, ASN_OCTET_STR, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 9}},
#define   MTPSAPLONGMESSAGESUPPORTED  12
	{MTPSAPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 10}},
#define   MTPSAPROWSTATUS       13
	{MTPSAPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 11}},
#define   SS7NETWORKPROTOCOLSTANDARD  17
	{SS7NETWORKPROTOCOLSTANDARD, ASN_INTEGER, RWRITE, var_ss7NetworkTable, 6, {1, 1, 2, 1, 1, 2}},
#define   SS7NETWORKPROTOCOLYEAR  18
	{SS7NETWORKPROTOCOLYEAR, ASN_UNSIGNED, RWRITE, var_ss7NetworkTable, 6, {1, 1, 2, 1, 1, 3}},
#define   SS7NETWORKINDICATOR   19
	{SS7NETWORKINDICATOR, ASN_INTEGER, RWRITE, var_ss7NetworkTable, 6, {1, 1, 2, 1, 1, 4}},
#define   SS7NETWORKPOINTCODEFORMAT  20
	{SS7NETWORKPOINTCODEFORMAT, ASN_INTEGER, RONLY, var_ss7NetworkTable, 6, {1, 1, 2, 1, 1, 5}},
#define   SS7NETWORKSTATUS      21
	{SS7NETWORKSTATUS, ASN_INTEGER, RWRITE, var_ss7NetworkTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPMSNAME             25
	{MTPMSNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPMSALARMSTATUS      26
	{MTPMSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPMSOPERATIONALSTATE  27
	{MTPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPMSUSAGESTATE       28
	{MTPMSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPMSMANAGEDELEMENTTYPE  29
	{MTPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 6}},
#define   MTPMSMODELCODE        30
	{MTPMSMODELCODE, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 7}},
#define   MTPMSVENDORNAME       31
	{MTPMSVENDORNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 8}},
#define   MTPMSUSERLABEL        32
	{MTPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 9}},
#define   MTPMSVERSION          33
	{MTPMSVERSION, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 10}},
#define   MTPMSASAPROFILEPOINTER  34
	{MTPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 11}},
#define   MTPMSNETWORKELEMENTALIASES  35
	{MTPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 12}},
#define   MTPMSSTATUS           36
	{MTPMSSTATUS, ASN_INTEGER, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 13}},
#define   MTPNAPROTOCOLVARIANT  40
	{MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPNAPROTOCOLYEAR     41
	{MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPNAPROTOCOLOPTIONS  42
	{MTPNAPROTOCOLOPTIONS, ASN_BIT_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPNANETWORKINDICATOR  43
	{MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPNAPOINTCODEFORMAT  44
	{MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPNASLSLENGTH        45
	{MTPNASLSLENGTH, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPNASPDEFAULT        46
	{MTPNASPDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPNANAME             47
	{MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPNAROWSTATUS        48
	{MTPNAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPGSADMINISTRATIVESTATE  53
	{MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  54
	{MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPGSLISTMODE         55
	{MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  56
	{MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  57
	{MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPGSNAME             58
	{MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPGSROWSTATUS        59
	{MTPGSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPGSLINEOBJECT       65
	{MTPGSLINEOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpGsLineTable, 6, {1, 1, 5, 2, 1, 2}},
#define   MTPGSLINECONTENT      66
	{MTPGSLINECONTENT, ASN_UNSIGNED, RWRITE, var_mtpGsLineTable, 6, {1, 1, 5, 2, 1, 3}},
#define   MTPGSLINEROWSTATUS    67
	{MTPGSLINEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineTable, 6, {1, 1, 5, 2, 1, 4}},
#define   MTPGSLINECONTENTDESIGNATEDDPCFIRST  74
	{MTPGSLINECONTENTDESIGNATEDDPCFIRST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 5, 3, 1, 2}},
#define   MTPGSLINECONTENTDESIGNATEDDPCLAST  75
	{MTPGSLINECONTENTDESIGNATEDDPCLAST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 5, 3, 1, 3}},
#define   MTPGSLINECONTENTSIMASK  76
	{MTPGSLINECONTENTSIMASK, ASN_BIT_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 5, 3, 1, 4}},
#define   MTPGSLINECONTENTMESSAGETREATMENT  77
	{MTPGSLINECONTENTMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 5, 3, 1, 5}},
#define   MTPGSLINECONTENTCOMMENT  78
	{MTPGSLINECONTENTCOMMENT, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 5, 3, 1, 6}},
#define   MTPGSLINECONTENTROWSTATUS  79
	{MTPGSLINECONTENTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 5, 3, 1, 7}},
#define   MTPSPPROFILETIMERT1R  83
	{MTPSPPROFILETIMERT1R, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPSPPROFILETIMERT2   84
	{MTPSPPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPSPPROFILETIMERT4   85
	{MTPSPPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPSPPROFILETIMERT5   86
	{MTPSPPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPSPPROFILETIMERT7   87
	{MTPSPPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPSPPROFILETIMERT11  88
	{MTPSPPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPSPPROFILETIMERT12  89
	{MTPSPPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPSPPROFILETIMERT13  90
	{MTPSPPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 9}},
#define   MTPSPPROFILETIMERT14  91
	{MTPSPPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 10}},
#define   MTPSPPROFILETIMERT15  92
	{MTPSPPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 11}},
#define   MTPSPPROFILETIMERT16  93
	{MTPSPPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 12}},
#define   MTPSPPROFILETIMERT18I  94
	{MTPSPPROFILETIMERT18I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 13}},
#define   MTPSPPROFILETIMERT19I  95
	{MTPSPPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 14}},
#define   MTPSPPROFILETIMERT20I  96
	{MTPSPPROFILETIMERT20I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 15}},
#define   MTPSPPROFILETIMERT21I  97
	{MTPSPPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 16}},
#define   MTPSPPROFILETIMERT22I  98
	{MTPSPPROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 17}},
#define   MTPSPPROFILETIMERT23I  99
	{MTPSPPROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 18}},
#define   MTPSPPROFILETIMERT20A  100
	{MTPSPPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 19}},
#define   MTPSPPROFILETIMERT21A  101
	{MTPSPPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 20}},
#define   MTPSPPROFILETIMERT22A  102
	{MTPSPPROFILETIMERT22A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 21}},
#define   MTPSPPROFILETIMERT23A  103
	{MTPSPPROFILETIMERT23A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 22}},
#define   MTPSPPROFILETIMERT24A  104
	{MTPSPPROFILETIMERT24A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 23}},
#define   MTPSPPROFILETIMERT26A  105
	{MTPSPPROFILETIMERT26A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 24}},
#define   MTPSPPROFILETIMERT27A  106
	{MTPSPPROFILETIMERT27A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 25}},
#define   MTPSPPROFILETIMERT1T  107
	{MTPSPPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 26}},
#define   MTPSPPROFILETIMERT2T  108
	{MTPSPPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 27}},
#define   MTPSPPROFILENAME      109
	{MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 28}},
#define   MTPSPPROFILEROWSTATUS  112
	{MTPSPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 6, 1, 1, 31}},
#define   MTPSPPOINTCODE        117
	{MTPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 2}},
#define   MTPSPTYPE             118
	{MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 3}},
#define   MTPSPOPERATIONALSTATE  119
	{MTPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 4}},
#define   MTPSPPROCEDURALSTATUS  120
	{MTPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 5}},
#define   MTPSPAVAILABILITYSTATUS  121
	{MTPSPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 6}},
#define   MTPSPVERSION          122
	{MTPSPVERSION, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 7}},
#define   MTPSPNETWORKINDICATOR  123
	{MTPSPNETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 8}},
#define   MTPSPNAME             124
	{MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 9}},
#define   MTPSPMTPT1            125
	{MTPSPMTPT1, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 10}},
#define   MTPSPMTPT2            126
	{MTPSPMTPT2, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 11}},
#define   MTPSPMTPT3            127
	{MTPSPMTPT3, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 12}},
#define   MTPSPMTPT4            128
	{MTPSPMTPT4, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 13}},
#define   MTPSPMTPT5            129
	{MTPSPMTPT5, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 14}},
#define   MTPSPMTPT6            130
	{MTPSPMTPT6, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 15}},
#define   MTPSPMTPT7            131
	{MTPSPMTPT7, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 16}},
#define   MTPSPMTPT8            132
	{MTPSPMTPT8, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 17}},
#define   MTPSPMTPT10           133
	{MTPSPMTPT10, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 18}},
#define   MTPSPMTPT11           134
	{MTPSPMTPT11, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 19}},
#define   MTPSPMTPT12           135
	{MTPSPMTPT12, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 20}},
#define   MTPSPMTPT13           136
	{MTPSPMTPT13, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 21}},
#define   MTPSPMTPT14           137
	{MTPSPMTPT14, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 22}},
#define   MTPSPMTPT15           138
	{MTPSPMTPT15, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 23}},
#define   MTPSPMTPT16           139
	{MTPSPMTPT16, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 24}},
#define   MTPSPMTPT17           140
	{MTPSPMTPT17, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 25}},
#define   MTPSPMTPT19A          141
	{MTPSPMTPT19A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 26}},
#define   MTPSPMTPT31A          142
	{MTPSPMTPT31A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 27}},
#define   MTPSPMTPT32A          143
	{MTPSPMTPT32A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 28}},
#define   MTPSPMTPT33A          144
	{MTPSPMTPT33A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 29}},
#define   MTPSPMTPT34A          145
	{MTPSPMTPT34A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 30}},
#define   MTPSPMTPT18I          146
	{MTPSPMTPT18I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 31}},
#define   MTPSPMTPT19I          147
	{MTPSPMTPT19I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 32}},
#define   MTPSPMTPT20I          148
	{MTPSPMTPT20I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 33}},
#define   MTPSPMTPT21I          149
	{MTPSPMTPT21I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 34}},
#define   MTPSPMTPT22I          150
	{MTPSPMTPT22I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 35}},
#define   MTPSPMTPT23I          151
	{MTPSPMTPT23I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 36}},
#define   MTPSPMTPT20A          152
	{MTPSPMTPT20A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 37}},
#define   MTPSPMTPT21A          153
	{MTPSPMTPT21A, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 38}},
#define   MTPSPMTPT24I          154
	{MTPSPMTPT24I, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 39}},
#define   MTPSPMTPT1T           155
	{MTPSPMTPT1T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 40}},
#define   MTPSPMTPT2T           156
	{MTPSPMTPT2T, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 41}},
#define   MTPSPMTPT1S           157
	{MTPSPMTPT1S, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 42}},
#define   MTPSPPROFILEPOINTER   158
	{MTPSPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 43}},
#define   MTPSPNAPOINTER        159
	{MTPSPNAPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 44}},
#define   MTPSPFLAGS            160
	{MTPSPFLAGS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 45}},
#define   MTPSPUSERS            161
	{MTPSPUSERS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 46}},
#define   MTPSPALARMSTATUS      162
	{MTPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 47}},
#define   MTPSPROWSTATUS        163
	{MTPSPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 6, 2, 1, 48}},
#define   MTPSPSTATSROWSTATUS   168
	{MTPSPSTATSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStatsTable, 6, {1, 1, 6, 3, 1, 1}},
#define   MTPSPCURRENTVALIDINTERVALS  172
	{MTPSPCURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 1}},
#define   MTPSPCURRENTTIMEDISCONTINUITY  173
	{MTPSPCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 2}},
#define   MTPSPCURRENTDISCARDEDMSUS  174
	{MTPSPCURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 3}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS0  175
	{MTPSPCURRENTRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 4}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS1  176
	{MTPSPCURRENTRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 5}},
#define   MTPSPCURRENTRECEIVEDTFCSTATUS2  177
	{MTPSPCURRENTRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 6}},
#define   MTPSPCURRENTOCTETSXFERRED  178
	{MTPSPCURRENTOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpCurrentTable, 6, {1, 1, 6, 4, 1, 7}},
#define   MTPSPINT5MINTIMESTAMP  183
	{MTPSPINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 6, 5, 1, 2}},
#define   MTPSPINT5MINDISCARDEDMSUS  184
	{MTPSPINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 6, 5, 1, 3}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS0  185
	{MTPSPINT5MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 6, 5, 1, 4}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS1  186
	{MTPSPINT5MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 6, 5, 1, 5}},
#define   MTPSPINT5MINRECEIVEDTFCSTATUS2  187
	{MTPSPINT5MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 6, 5, 1, 6}},
#define   MTPSPINT5MINOCTETSXFERRED  188
	{MTPSPINT5MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt5minTable, 6, {1, 1, 6, 5, 1, 7}},
#define   MTPSPINT15MINTIMESTAMP  193
	{MTPSPINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 6, 6, 1, 2}},
#define   MTPSPINT15MINDISCARDEDMSUS  194
	{MTPSPINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 6, 6, 1, 3}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS0  195
	{MTPSPINT15MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 6, 6, 1, 4}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS1  196
	{MTPSPINT15MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 6, 6, 1, 5}},
#define   MTPSPINT15MINRECEIVEDTFCSTATUS2  197
	{MTPSPINT15MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 6, 6, 1, 6}},
#define   MTPSPINT15MINOCTETSXFERRED  198
	{MTPSPINT15MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpSpInt15minTable, 6, {1, 1, 6, 6, 1, 7}},
#define   MTPSPSIVALIDINTERVALS  203
	{MTPSPSIVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpSiTable, 6, {1, 1, 6, 7, 1, 2}},
#define   MTPSPSITIMEDISCONTINUITY  204
	{MTPSPSITIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpSiTable, 6, {1, 1, 6, 7, 1, 3}},
#define   MTPSPSITRANSMITTEDUPUNAVAILABLE  205
	{MTPSPSITRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 6, 7, 1, 4}},
#define   MTPSPSIRECEIVEDUPUNAVAILABLE  206
	{MTPSPSIRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 6, 7, 1, 5}},
#define   MTPSPSIHANDLEDOCTETSSIO  207
	{MTPSPSIHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiTable, 6, {1, 1, 6, 7, 1, 6}},
#define   MTPSPSISTATUS         208
	{MTPSPSISTATUS, ASN_INTEGER, RWRITE, var_mtpSpSiTable, 6, {1, 1, 6, 7, 1, 7}},
#define   MTPSPSIINT5MINTIMESTAMP  214
	{MTPSPSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 6, 8, 1, 2}},
#define   MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE  215
	{MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 6, 8, 1, 3}},
#define   MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE  216
	{MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 6, 8, 1, 4}},
#define   MTPSPSIINT5MINHANDLEDOCTETSSIO  217
	{MTPSPSIINT5MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt5minTable, 6, {1, 1, 6, 8, 1, 5}},
#define   MTPSPSIINT15MINTIMESTAMP  223
	{MTPSPSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 6, 9, 1, 2}},
#define   MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE  224
	{MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 6, 9, 1, 3}},
#define   MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE  225
	{MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 6, 9, 1, 4}},
#define   MTPSPSIINT15MINHANDLEDOCTETSSIO  226
	{MTPSPSIINT15MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpSpSiInt15minTable, 6, {1, 1, 6, 9, 1, 5}},
#define   MTPSPSTUDYVALIDINTERVALS  230
	{MTPSPSTUDYVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSpStudyTable, 6, {1, 1, 6, 10, 1, 2}},
#define   MTPSPSTUDYTIMEDISCONTINUITY  231
	{MTPSPSTUDYTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSpStudyTable, 6, {1, 1, 6, 10, 1, 3}},
#define   MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO  232
	{MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 6, 10, 1, 4}},
#define   MTPSPSTUDYHANDLEDMSUSOPCDPCSIO  233
	{MTPSPSTUDYHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyTable, 6, {1, 1, 6, 10, 1, 5}},
#define   MTPSPSTUDYSTATUS      234
	{MTPSPSTUDYSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyTable, 6, {1, 1, 6, 10, 1, 6}},
#define   MTPSPSTUDYINT5MINTIMESTAMP  239
	{MTPSPSTUDYINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 6, 11, 1, 2}},
#define   MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO  240
	{MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 6, 11, 1, 3}},
#define   MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO  241
	{MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt5minTable, 6, {1, 1, 6, 11, 1, 4}},
#define   MTPSPSTUDYINT15MININTERVAL  246
	{MTPSPSTUDYINT15MININTERVAL, ASN_TIMETICKS, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 6, 12, 1, 2}},
#define   MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO  247
	{MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 6, 12, 1, 3}},
#define   MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO  248
	{MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpSpStudyInt15minTable, 6, {1, 1, 6, 12, 1, 4}},
#define   MTPSPSTUDYMAPSTATUS   256
	{MTPSPSTUDYMAPSTATUS, ASN_INTEGER, RWRITE, var_mtpSpStudyMapTable, 6, {1, 1, 6, 13, 1, 1}},
#define   MTPL3ADMINISTRATIVESTATE  260
	{MTPL3ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPL3OPERATIONALSTATE  261
	{MTPL3OPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPL3USAGESTATE       262
	{MTPL3USAGESTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPL3PROCEDURALSTATUS  263
	{MTPL3PROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPL3ASAPROFILEPOINTER  264
	{MTPL3ASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPL3NAME             265
	{MTPL3NAME, ASN_OCTET_STR, RWRITE, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPL3ROWSTATUS        266
	{MTPL3ROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRSPROFILENAME      270
	{MTPRSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 2}},
#define   MTPRSPROFILETIMERT8   271
	{MTPRSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 3}},
#define   MTPRSPROFILETIMERT11  272
	{MTPRSPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 4}},
#define   MTPRSPROFILETIMERT15  273
	{MTPRSPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 5}},
#define   MTPRSPROFILETIMERT16  274
	{MTPRSPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 6}},
#define   MTPRSPROFILETIMERT18A  275
	{MTPRSPROFILETIMERT18A, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 7}},
#define   MTPRSPROFILERTDEFAULT  276
	{MTPRSPROFILERTDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 8}},
#define   MTPRSPROFILEROWSTATUS  277
	{MTPRSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 8, 1, 1, 9}},
#define   MTPRSDEST             282
	{MTPRSDEST, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPRSFLAGS            283
	{MTPRSFLAGS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPRSADMINISTRATIVESTATE  284
	{MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPRSOPERATIONALSTATE  285
	{MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPRSASAPROFILEPOINTER  286
	{MTPRSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 6}},
#define   MTPRSCONGESTEDSTATE   287
	{MTPRSCONGESTEDSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 7}},
#define   MTPRSCONGESTIONLEVEL  288
	{MTPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 8}},
#define   MTPRSLOADSHARINGINFORMATION  289
	{MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 9}},
#define   MTPRSLOADSHARINGOBJECT  290
	{MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 10}},
#define   MTPRSREMOTEEXCHANGELABEL  291
	{MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 11}},
#define   MTPRSNAME             292
	{MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 12}},
#define   MTPRSPROFILE          293
	{MTPRSPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 13}},
#define   MTPRSALARMSTATUS      294
	{MTPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 14}},
#define   MTPRSROWSTATUS        295
	{MTPRSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 8, 2, 1, 15}},
#define   MTPRSSTATSSTATUS      300
	{MTPRSSTATSSTATUS, ASN_INTEGER, RWRITE, var_mtpRsStatsTable, 6, {1, 1, 8, 3, 1, 1}},
#define   MTPRSCURRENTVALIDINTERVALS  304
	{MTPRSCURRENTVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 1}},
#define   MTPRSCURRENTTIMEDISCONTINUITY  305
	{MTPRSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 2}},
#define   MTPRSCURRENTRECEIVEDOCTETSOPC  306
	{MTPRSCURRENTRECEIVEDOCTETSOPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 3}},
#define   MTPRSCURRENTTRANSMITTEDOCTETSDPC  307
	{MTPRSCURRENTTRANSMITTEDOCTETSDPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 4}},
#define   MTPRSCURRENTRECEIVEDMSUSOPC  308
	{MTPRSCURRENTRECEIVEDMSUSOPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 5}},
#define   MTPRSCURRENTTRANSMITTEDMSUSDPC  309
	{MTPRSCURRENTTRANSMITTEDMSUSDPC, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 6}},
#define   MTPRSCURRENTROUTESETUNAVAILABLE  310
	{MTPRSCURRENTROUTESETUNAVAILABLE, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 7}},
#define   MTPRSCURRENTROUTESETUNAVAILABLEDURATION  311
	{MTPRSCURRENTROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RWRITE, var_mtpRsCurrentTable, 6, {1, 1, 8, 4, 1, 8}},
#define   MTPRSINT5MINTIMESTAMP  316
	{MTPRSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 2}},
#define   MTPRSINT5MINRECEIVEDOCTETSOPC  317
	{MTPRSINT5MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 3}},
#define   MTPRSINT5MINTRANSMITTEDOCTETSDPC  318
	{MTPRSINT5MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 4}},
#define   MTPRSINT5MINRECEIVEDMSUSOPC  319
	{MTPRSINT5MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 5}},
#define   MTPRSINT5MINTRANSMITTEDMSUSDPC  320
	{MTPRSINT5MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 6}},
#define   MTPRSINT5MINROUTESETUNAVAILABLE  321
	{MTPRSINT5MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 7}},
#define   MTPRSINT5MINROUTESETUNAVAILABLEDURATION  322
	{MTPRSINT5MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt5minTable, 6, {1, 1, 8, 5, 1, 8}},
#define   MTPRSINT15MINTIMESTAMP  327
	{MTPRSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 2}},
#define   MTPRSINT15MINRECEIVEDOCTETSOPC  328
	{MTPRSINT15MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 3}},
#define   MTPRSINT15MINTRANSMITTEDOCTETSDPC  329
	{MTPRSINT15MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 4}},
#define   MTPRSINT15MINRECEIVEDMSUSOPC  330
	{MTPRSINT15MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 5}},
#define   MTPRSINT15MINTRANSMITTEDMSUSDPC  331
	{MTPRSINT15MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 6}},
#define   MTPRSINT15MINROUTESETUNAVAILABLE  332
	{MTPRSINT15MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 7}},
#define   MTPRSINT15MINROUTESETUNAVAILABLEDURATION  333
	{MTPRSINT15MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpRsInt15minTable, 6, {1, 1, 8, 6, 1, 8}},
#define   MTPRSSIVALIDINTERVALS  337
	{MTPRSSIVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 2}},
#define   MTPRSSITIMEDISCONTINUITY  338
	{MTPRSSITIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 3}},
#define   MTPRSSIRECEIVEDOCTETSOPCSIO  339
	{MTPRSSIRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 4}},
#define   MTPRSSITRANSMITTEDOCTETSDPCSIO  340
	{MTPRSSITRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 5}},
#define   MTPRSSIRECEIVEDMSUSOPCSIO  341
	{MTPRSSIRECEIVEDMSUSOPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 6}},
#define   MTPRSSITRANSMITTEDMSUSDPCSIO  342
	{MTPRSSITRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 7}},
#define   MTPRSSISTATUS         343
	{MTPRSSISTATUS, ASN_INTEGER, RWRITE, var_mtpRsSiTable, 6, {1, 1, 8, 7, 1, 8}},
#define   MTPRSSIINT5MINTIMESTAMP  348
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 8, 8, 1, 3}},
#define   MTPRSSIINT5MINTIMESTAMP  349
	{MTPRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 8, 8, 1, 3}},
#define   MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO  350
	{MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 8, 8, 1, 4}},
#define   MTPRSSIINT5MINRECEIVEDMSUSOPCSIO  351
	{MTPRSSIINT5MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 8, 8, 1, 5}},
#define   MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO  352
	{MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt5minTable, 6, {1, 1, 8, 8, 1, 6}},
#define   MTPRSSIINT15MINTIMESTAMP  357
	{MTPRSSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 8, 9, 1, 2}},
#define   MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO  358
	{MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 8, 9, 1, 3}},
#define   MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO  359
	{MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 8, 9, 1, 4}},
#define   MTPRSSIINT15MINRECEIVEDMSUSOPCSIO  360
	{MTPRSSIINT15MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 8, 9, 1, 5}},
#define   MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO  361
	{MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpRsSiInt15minTable, 6, {1, 1, 8, 9, 1, 6}},
#define   MTPRTPROFILETIMERT6   365
	{MTPRTPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPRTPROFILETIMERT10  366
	{MTPRTPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPRTPROFILEROWSTATUS  367
	{MTPRTPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPRTLSPOINTER        373
	{MTPRTLSPOINTER, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 2}},
#define   MTPRTADMINISTRATIVESTATE  374
	{MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 3}},
#define   MTPRTOPERATIONALSTATE  375
	{MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 4}},
#define   MTPRTAVAILABILITYSTATUS  376
	{MTPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 5}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  377
	{MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 6}},
#define   MTPRTFIXEDPRIORITY    378
	{MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 7}},
#define   MTPRTFLEXIBLEPRIORITY  379
	{MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 8}},
#define   MTPRTPRIORITYMODE     380
	{MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 9}},
#define   MTPRTLOADSHARINGINFORMATION  381
	{MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 10}},
#define   MTPRTLOADSHARINGOBJECT  382
	{MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 11}},
#define   MTPRTNAME             383
	{MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 12}},
#define   MTPRTSLSLIST          384
	{MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 13}},
#define   MTPRTUSAGESTATE       385
	{MTPRTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 14}},
#define   MTPRTRLSLOT           386
	{MTPRTRLSLOT, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 15}},
#define   MTPRTPROFILE          387
	{MTPRTPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 16}},
#define   MTPRTROWSTATUS        388
	{MTPRTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 9, 2, 1, 17}},
#define   MTPRTLSANORMALSLCODE  395
	{MTPRTLSANORMALSLCODE, ASN_UNSIGNED, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 9, 3, 1, 2}},
#define   MTPRTLSAALTERNATIVESLCODELIST  396
	{MTPRTLSAALTERNATIVESLCODELIST, ASN_OCTET_STR, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 9, 3, 1, 3}},
#define   MTPLSPROFILETIMERT6   400
	{MTPLSPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 2}},
#define   MTPLSPROFILETIMERT8   401
	{MTPLSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 3}},
#define   MTPLSPROFILETIMERT10  402
	{MTPLSPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 4}},
#define   MTPLSPROFILETIMERT7   403
	{MTPLSPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 5}},
#define   MTPLSPROFILETIMERT19I  404
	{MTPLSPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 6}},
#define   MTPLSPROFILETIMERT21I  405
	{MTPLSPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 7}},
#define   MTPLSPROFILETIMERT25A  406
	{MTPLSPROFILETIMERT25A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 8}},
#define   MTPLSPROFILETIMERT28A  407
	{MTPLSPROFILETIMERT28A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 9}},
#define   MTPLSPROFILETIMERT29A  408
	{MTPLSPROFILETIMERT29A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 10}},
#define   MTPLSPROFILETIMERT30A  409
	{MTPLSPROFILETIMERT30A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 11}},
#define   MTPLSPROFILENAME      410
	{MTPLSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 12}},
#define   MTPLSPROFILESLDEFAULT  411
	{MTPLSPROFILESLDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 13}},
#define   MTPLSPROFILEROWSTATUS  412
	{MTPLSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 10, 1, 1, 14}},
#define   MTPLSADJPC            417
	{MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 2}},
#define   MTPLSRSID             418
	{MTPLSRSID, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 3}},
#define   MTPLSMAXCAPACITY      419
	{MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 4}},
#define   MTPLSCURRENTCAPACITY  420
	{MTPLSCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 5}},
#define   MTPLSCONGESTIONCONTROLMETHOD  421
	{MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 6}},
#define   MTPLSUSAGESTATE       422
	{MTPLSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 7}},
#define   MTPLSOPERATIONALSTATE  423
	{MTPLSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 8}},
#define   MTPLSAVAILABILITYSTATUS  424
	{MTPLSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 9}},
#define   MTPLSPERIODICLINKTESTFLAG  425
	{MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 10}},
#define   MTPLSPERIODICLINKTESTFAIL  426
	{MTPLSPERIODICLINKTESTFAIL, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 11}},
#define   MTPLSADMINISTRATIVESTATE  427
	{MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 12}},
#define   MTPLSINLSLOADSHAREALGORITHM  428
	{MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 13}},
#define   MTPLSPROFILEPOINTER   429
	{MTPLSPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 14}},
#define   MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS  430
	{MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 15}},
#define   MTPLSNAME             431
	{MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 16}},
#define   MTPLSASAPROFILEPOINTER  432
	{MTPLSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 17}},
#define   MTPLSALARMSTATUS      433
	{MTPLSALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 18}},
#define   MTPLSROWSTATUS        434
	{MTPLSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 10, 2, 1, 19}},
#define   MTPLSSTATSSTATUS      439
	{MTPLSSTATSSTATUS, ASN_INTEGER, RWRITE, var_mtpLsStatsTable, 6, {1, 1, 10, 3, 1, 1}},
#define   MTPLSCURRENTVALIDINTERVALS  443
	{MTPLSCURRENTVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 10, 4, 1, 1}},
#define   MTPLSCURRENTTIMEDISCONTINUITY  444
	{MTPLSCURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPLSCURRENTADJACENTINACCESSIBLEEVENTS  445
	{MTPLSCURRENTADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPLSCURRENTADJACENTINACCESSIBLEDURATION  446
	{MTPLSCURRENTADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 10, 4, 1, 4}},
#define   MTPLSCURRENTSLSUNAVAILABLE  447
	{MTPLSCURRENTSLSUNAVAILABLE, ASN_GAUGE, RWRITE, var_mtpLsCurrentTable, 6, {1, 1, 10, 4, 1, 5}},
#define   MTPLSINT15MINTIMESTAMP  460
	{MTPLSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 10, 6, 1, 2}},
#define   MTPLSINT15MINADJACENTINACCESSIBLEEVENTS  461
	{MTPLSINT15MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 10, 6, 1, 3}},
#define   MTPLSINT15MINADJACENTINACCESSIBLEDURATION  462
	{MTPLSINT15MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 10, 6, 1, 4}},
#define   MTPLSINT15MINSLSUNAVAILABLE  463
	{MTPLSINT15MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpLsInt15minTable, 6, {1, 1, 10, 6, 1, 5}},
#define   MTPSLL3PROFILETIMERT1  467
	{MTPSLL3PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 2}},
#define   MTPSLL3PROFILETIMERT3  468
	{MTPSLL3PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 3}},
#define   MTPSLL3PROFILETIMERT17  469
	{MTPSLL3PROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 4}},
#define   MTPSLL3PROFILETIMERT24I  470
	{MTPSLL3PROFILETIMERT24I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 5}},
#define   MTPSLL3PROFILENAME    471
	{MTPSLL3PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 6}},
#define   MTPSLL3PROFILETIMERT2  472
	{MTPSLL3PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 7}},
#define   MTPSLL3PROFILETIMERT4  473
	{MTPSLL3PROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 8}},
#define   MTPSLL3PROFILETIMERT5  474
	{MTPSLL3PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 9}},
#define   MTPSLL3PROFILETIMERT12  475
	{MTPSLL3PROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 10}},
#define   MTPSLL3PROFILETIMERT13  476
	{MTPSLL3PROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 11}},
#define   MTPSLL3PROFILETIMERT14  477
	{MTPSLL3PROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 12}},
#define   MTPSLL3PROFILETIMERT19A  478
	{MTPSLL3PROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 13}},
#define   MTPSLL3PROFILETIMERT20A  479
	{MTPSLL3PROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 14}},
#define   MTPSLL3PROFILETIMERT21A  480
	{MTPSLL3PROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 15}},
#define   MTPSLL3PROFILETIMERT22I  481
	{MTPSLL3PROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 16}},
#define   MTPSLL3PROFILETIMERT23I  482
	{MTPSLL3PROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 17}},
#define   MTPSLL3PROFILETIMERT31A  483
	{MTPSLL3PROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 18}},
#define   MTPSLL3PROFILETIMERT32A  484
	{MTPSLL3PROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 19}},
#define   MTPSLL3PROFILETIMERT33A  485
	{MTPSLL3PROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 20}},
#define   MTPSLL3PROFILETIMERT34A  486
	{MTPSLL3PROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 21}},
#define   MTPSLL3PROFILETIMERT1T  487
	{MTPSLL3PROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 22}},
#define   MTPSLL3PROFILETIMERT2T  488
	{MTPSLL3PROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 23}},
#define   MTPSLL3PROFILETIMERT1S  489
	{MTPSLL3PROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 24}},
#define   MTPSLL3PROFILEL2DEFAULT  490
	{MTPSLL3PROFILEL2DEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 25}},
#define   MTPSLL3PROFILEROWSTATUS  491
	{MTPSLL3PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 11, 1, 1, 26}},
#define   MTPSLL2PROFILEERRORCORRECTIONMETHOD  495
	{MTPSLL2PROFILEERRORCORRECTIONMETHOD, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 2}},
#define   MTPSLL2PROFILETRANSMISSIONRATE  496
	{MTPSLL2PROFILETRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 3}},
#define   MTPSLL2PROFILETIMERT1  497
	{MTPSLL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 4}},
#define   MTPSLL2PROFILETIMERT2  498
	{MTPSLL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 5}},
#define   MTPSLL2PROFILETIMERT2L  499
	{MTPSLL2PROFILETIMERT2L, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 6}},
#define   MTPSLL2PROFILETIMERT2H  500
	{MTPSLL2PROFILETIMERT2H, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 7}},
#define   MTPSLL2PROFILETIMERT3  501
	{MTPSLL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 8}},
#define   MTPSLL2PROFILETIMERT4N  502
	{MTPSLL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 9}},
#define   MTPSLL2PROFILETIMERT4E  503
	{MTPSLL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 10}},
#define   MTPSLL2PROFILETIMERT5  504
	{MTPSLL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 11}},
#define   MTPSLL2PROFILETIMERT6  505
	{MTPSLL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 12}},
#define   MTPSLL2PROFILETIMERT7  506
	{MTPSLL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 13}},
#define   MTPSLL2PROFILETBONSET1  507
	{MTPSLL2PROFILETBONSET1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 14}},
#define   MTPSLL2PROFILETBABATE1  508
	{MTPSLL2PROFILETBABATE1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 15}},
#define   MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS  509
	{MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 16}},
#define   MTPSLL2PROFILECONGESTIONCOUNTING  510
	{MTPSLL2PROFILECONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 17}},
#define   MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT  511
	{MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 18}},
#define   MTPSLL2PROFILELOOPDELAY  512
	{MTPSLL2PROFILELOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 19}},
#define   MTPSLL2PROFILENAME    513
	{MTPSLL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 20}},
#define   MTPSLL2PROFILETBONSET2  514
	{MTPSLL2PROFILETBONSET2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 21}},
#define   MTPSLL2PROFILETBABATE2  515
	{MTPSLL2PROFILETBABATE2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 22}},
#define   MTPSLL2PROFILETBONSET3  516
	{MTPSLL2PROFILETBONSET3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 23}},
#define   MTPSLL2PROFILETBABATE3  517
	{MTPSLL2PROFILETBABATE3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 24}},
#define   MTPSLL2PROFILETBDISCARD1  518
	{MTPSLL2PROFILETBDISCARD1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 25}},
#define   MTPSLL2PROFILETBDISCARD2  519
	{MTPSLL2PROFILETBDISCARD2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 26}},
#define   MTPSLL2PROFILETBDISCARD3  520
	{MTPSLL2PROFILETBDISCARD3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 27}},
#define   MTPSLL2PROFILETIMERTX  521
	{MTPSLL2PROFILETIMERTX, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 28}},
#define   MTPSLL2PROFILETIMERTY  522
	{MTPSLL2PROFILETIMERTY, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 29}},
#define   MTPSLL2PROFILENUMBEROFCONGESTIONSTATES  523
	{MTPSLL2PROFILENUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 30}},
#define   MTPSLL2PROFILEINITIALLEVELOFCONGESTION  524
	{MTPSLL2PROFILEINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 31}},
#define   MTPSLL2PROFILEMAXMSUSRETRANSN1  525
	{MTPSLL2PROFILEMAXMSUSRETRANSN1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 32}},
#define   MTPSLL2PROFILEMAXOCTRETRANSN2  526
	{MTPSLL2PROFILEMAXOCTRETRANSN2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 33}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET  527
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 34}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE  528
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 35}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD  529
	{MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 36}},
#define   MTPSLL2PROFILEM       530
	{MTPSLL2PROFILEM, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 37}},
#define   MTPSLL2PROFILEROWSTATUS  531
	{MTPSLL2PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 11, 2, 1, 38}},
#define   MTPSLSLSCODECURRENTLIST  537
	{MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 2}},
#define   MTPSLMAXCAPACITYSL    538
	{MTPSLMAXCAPACITYSL, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 3}},
#define   MTPSLCURRENTCAPACITYSL  539
	{MTPSLCURRENTCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 4}},
#define   MTPSLLINKTPSTATUS     540
	{MTPSLLINKTPSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 5}},
#define   MTPSLADMINISTRATIVESTATE  541
	{MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPSLOPERATIONALSTATE  542
	{MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 7}},
#define   MTPSLUSAGESTATE       543
	{MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 8}},
#define   MTPSLPROCEDURALSTATUS  544
	{MTPSLPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 9}},
#define   MTPSLMTPL2PROTOCOLPROFILEPOINTER  545
	{MTPSLMTPL2PROTOCOLPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 10}},
#define   MTPSLSIGNTERMPOINTER  546
	{MTPSLSIGNTERMPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 11}},
#define   MTPSLSIGNDATALINKTPPOINTER  547
	{MTPSLSIGNDATALINKTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 12}},
#define   MTPSLLOCALINHIBIT     548
	{MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 13}},
#define   MTPSLLOCALUNINHIBIT   549
	{MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 14}},
#define   MTPSLREPLACEST        550
	{MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 15}},
#define   MTPSLASAPROFILEPOINTER  551
	{MTPSLASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 16}},
#define   MTPSLCONGESTIONLEVEL  552
	{MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 17}},
#define   MTPSLRELATEDLINKGROUPNUMBER  553
	{MTPSLRELATEDLINKGROUPNUMBER, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 18}},
#define   MTPSLSDLLIST          554
	{MTPSLSDLLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 19}},
#define   MTPSLTEST             555
	{MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 20}},
#define   MTPSLNAME             556
	{MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 21}},
#define   MTPSLSDTLIST          557
	{MTPSLSDTLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 22}},
#define   MTPSLSLSCODENORMALLIST  558
	{MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 23}},
#define   MTPSLL3PROFILEPOINTER  559
	{MTPSLL3PROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 24}},
#define   MTPSLALARMSTATUS      560
	{MTPSLALARMSTATUS, ASN_BIT_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 25}},
#define   MTPSLROWSTATUS        561
	{MTPSLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 11, 3, 1, 26}},
#define   MTPSLSDLLISTPOINTER   568
	{MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 11, 4, 1, 2}},
#define   MTPSLSDLLISTROWSTATUS  569
	{MTPSLSDLLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 11, 4, 1, 3}},
#define   MTPSLSDTLISTPOINTER   576
	{MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 11, 5, 1, 2}},
#define   MTPSLSDTLISTROWSTATUS  577
	{MTPSLSDTLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 11, 5, 1, 3}},
#define   MTPSLSTATSDURINSERVICE  583
	{MTPSLSTATSDURINSERVICE, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 1}},
#define   MTPSLSTATSFAILALIGNORPROVING  584
	{MTPSLSTATSFAILALIGNORPROVING, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 2}},
#define   MTPSLSTATSNACKSRECEIVED  585
	{MTPSLSTATSNACKSRECEIVED, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 3}},
#define   MTPSLSTATSDURUNAVAIL  586
	{MTPSLSTATSDURUNAVAIL, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 4}},
#define   MTPSLSTATSDURUNAVAILFAILED  587
	{MTPSLSTATSDURUNAVAILFAILED, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 5}},
#define   MTPSLSTATSDURUNAVAILRPO  588
	{MTPSLSTATSDURUNAVAILRPO, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 6}},
#define   MTPSLSTATSSIBSSENT    589
	{MTPSLSTATSSIBSSENT, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 7}},
#define   MTPSLSTATSTRANSIOSIFOCTETS  590
	{MTPSLSTATSTRANSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 8}},
#define   MTPSLSTATSRETRANSOCTETS  591
	{MTPSLSTATSRETRANSOCTETS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 9}},
#define   MTPSLSTATSTRANMSUS    592
	{MTPSLSTATSTRANMSUS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 10}},
#define   MTPSLSTATSRECVSIOSIFOCTETS  593
	{MTPSLSTATSRECVSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 11}},
#define   MTPSLSTATSRECVMSUS    594
	{MTPSLSTATSRECVMSUS, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 12}},
#define   MTPSLSTATSCONGONSETIND0  595
	{MTPSLSTATSCONGONSETIND0, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 13}},
#define   MTPSLSTATSCONGONSETIND1  596
	{MTPSLSTATSCONGONSETIND1, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 14}},
#define   MTPSLSTATSCONGONSETIND2  597
	{MTPSLSTATSCONGONSETIND2, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 15}},
#define   MTPSLSTATSCONGONSETIND3  598
	{MTPSLSTATSCONGONSETIND3, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 16}},
#define   MTPSLSTATSDURCONGSTATUS0  599
	{MTPSLSTATSDURCONGSTATUS0, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 17}},
#define   MTPSLSTATSDURCONGSTATUS1  600
	{MTPSLSTATSDURCONGSTATUS1, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 18}},
#define   MTPSLSTATSDURCONGSTATUS2  601
	{MTPSLSTATSDURCONGSTATUS2, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 19}},
#define   MTPSLSTATSDURCONGSTATUS3  602
	{MTPSLSTATSDURCONGSTATUS3, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 20}},
#define   MTPSLSTATSCONGDISCDIND0  603
	{MTPSLSTATSCONGDISCDIND0, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 21}},
#define   MTPSLSTATSCONGDISCDIND1  604
	{MTPSLSTATSCONGDISCDIND1, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 22}},
#define   MTPSLSTATSCONGDISCDIND2  605
	{MTPSLSTATSCONGDISCDIND2, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 23}},
#define   MTPSLSTATSCONGDISCDIND3  606
	{MTPSLSTATSCONGDISCDIND3, ASN_COUNTER, RONLY, var_mtpSlStatsTable, 6, {1, 1, 11, 6, 1, 24}},
#define   MTPSLL3CURRENTVALIDINTERVALS  612
	{MTPSLL3CURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 1}},
#define   MTPSLL3CURRENTTIMEDISCONTINUITY  613
	{MTPSLL3CURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 2}},
#define   MTPSLL3CURRENTSLUNAVAILABILITYDURATION  614
	{MTPSLL3CURRENTSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 3}},
#define   MTPSLL3CURRENTSLLOCALINHIBITION  615
	{MTPSLL3CURRENTSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 4}},
#define   MTPSLL3CURRENTSLREMOTEINHIBITION  616
	{MTPSLL3CURRENTSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 5}},
#define   MTPSLL3CURRENTSLFAILED  617
	{MTPSLL3CURRENTSLFAILED, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 6}},
#define   MTPSLL3CURRENTSLREMOTEPROCOUTAGE  618
	{MTPSLL3CURRENTSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 7}},
#define   MTPSLL3CURRENTLOCALMGMTINHIBIT  619
	{MTPSLL3CURRENTLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 8}},
#define   MTPSLL3CURRENTLOCALMGMTUNINHIBIT  620
	{MTPSLL3CURRENTLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 9}},
#define   MTPSLL3CURRENTLOCALBUSY  621
	{MTPSLL3CURRENTLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 10}},
#define   MTPSLL3CURRENTSLCONGESTEDSTARTS  622
	{MTPSLL3CURRENTSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 11}},
#define   MTPSLL3CURRENTSLCONGESTEDDURATION  623
	{MTPSLL3CURRENTSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 12}},
#define   MTPSLL3CURRENTSLCONGESTIONSTOPS  624
	{MTPSLL3CURRENTSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 13}},
#define   MTPSLL3CURRENTDISCARDEDMSUS  625
	{MTPSLL3CURRENTDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 14}},
#define   MTPSLL3CURRENTCONGESTIONEVENTSMSULOSS  626
	{MTPSLL3CURRENTCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 15}},
#define   MTPSLL3CURRENTCHANGEOVERS  627
	{MTPSLL3CURRENTCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 16}},
#define   MTPSLL3CURRENTCHANGEBACKS  628
	{MTPSLL3CURRENTCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 17}},
#define   MTPSLL3CURRENTRESTORATIONS  629
	{MTPSLL3CURRENTRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlL3CurrentTable, 6, {1, 1, 11, 7, 1, 18}},
#define   MTPSLL3INT5MINTIMESTAMP  636
	{MTPSLL3INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 2}},
#define   MTPSLL3INT5MINSLUNAVAILABILITYDURATION  637
	{MTPSLL3INT5MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 3}},
#define   MTPSLL3INT5MINSLLOCALINHIBITION  638
	{MTPSLL3INT5MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 4}},
#define   MTPSLL3INT5MINSLREMOTEINHIBITION  639
	{MTPSLL3INT5MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 5}},
#define   MTPSLL3INT5MINSLFAILED  640
	{MTPSLL3INT5MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 6}},
#define   MTPSLL3INT5MINSLREMOTEPROCOUTAGE  641
	{MTPSLL3INT5MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 7}},
#define   MTPSLL3INT5MINLOCALMGMTINHIBIT  642
	{MTPSLL3INT5MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 8}},
#define   MTPSLL3INT5MINLOCALMGMTUNINHIBIT  643
	{MTPSLL3INT5MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 9}},
#define   MTPSLL3INT5MINLOCALBUSY  644
	{MTPSLL3INT5MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 10}},
#define   MTPSLL3INT5MINSLCONGESTEDSTARTS  645
	{MTPSLL3INT5MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 11}},
#define   MTPSLL3INT5MINSLCONGESTEDDURATION  646
	{MTPSLL3INT5MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 12}},
#define   MTPSLL3INT5MINSLCONGESTIONSTOPS  647
	{MTPSLL3INT5MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 13}},
#define   MTPSLL3INT5MINDISCARDEDMSUS  648
	{MTPSLL3INT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 14}},
#define   MTPSLL3INT5MINCONGESTIONEVENTSMSULOSS  649
	{MTPSLL3INT5MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 15}},
#define   MTPSLL3INT5MINCHANGEOVERS  650
	{MTPSLL3INT5MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 16}},
#define   MTPSLL3INT5MINCHANGEBACKS  651
	{MTPSLL3INT5MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 17}},
#define   MTPSLL3INT5MINRESTORATIONS  652
	{MTPSLL3INT5MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlL3Int5minTable, 6, {1, 1, 11, 8, 1, 18}},
#define   MTPSLL3INT15MINTIMESTAMP  659
	{MTPSLL3INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 2}},
#define   MTPSLL3INT15MINSLUNAVAILABILITYDURATION  660
	{MTPSLL3INT15MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 3}},
#define   MTPSLL3INT15MINSLLOCALINHIBITION  661
	{MTPSLL3INT15MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 4}},
#define   MTPSLL3INT15MINSLREMOTEINHIBITION  662
	{MTPSLL3INT15MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 5}},
#define   MTPSLL3INT15MINSLFAILED  663
	{MTPSLL3INT15MINSLFAILED, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 6}},
#define   MTPSLL3INT15MINSLREMOTEPROCOUTAGE  664
	{MTPSLL3INT15MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 7}},
#define   MTPSLL3INT15MINLOCALMGMTINHIBIT  665
	{MTPSLL3INT15MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 8}},
#define   MTPSLL3INT15MINLOCALMGMTUNINHIBIT  666
	{MTPSLL3INT15MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 9}},
#define   MTPSLL3INT15MINLOCALBUSY  667
	{MTPSLL3INT15MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 10}},
#define   MTPSLL3INT15MINSLCONGESTEDSTARTS  668
	{MTPSLL3INT15MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 11}},
#define   MTPSLL3INT15MINSLCONGESTEDDURATION  669
	{MTPSLL3INT15MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 12}},
#define   MTPSLL3INT15MINSLCONGESTIONSTOPS  670
	{MTPSLL3INT15MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 13}},
#define   MTPSLL3INT15MINDISCARDEDMSUS  671
	{MTPSLL3INT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 14}},
#define   MTPSLL3INT15MINCONGESTIONEVENTSMSULOSS  672
	{MTPSLL3INT15MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 15}},
#define   MTPSLL3INT15MINCHANGEOVERS  673
	{MTPSLL3INT15MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 16}},
#define   MTPSLL3INT15MINCHANGEBACKS  674
	{MTPSLL3INT15MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 17}},
#define   MTPSLL3INT15MINRESTORATIONS  675
	{MTPSLL3INT15MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpSlL3Int15minTable, 6, {1, 1, 11, 9, 1, 18}},
#define   MTPSLL2CURRENTVALIDINTERVALS  681
	{MTPSLL2CURRENTVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 1}},
#define   MTPSLL2CURRENTTIMEDISCONTINUITY  682
	{MTPSLL2CURRENTTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 2}},
#define   MTPSLL2CURRENTSLINSERVICEDURATION  683
	{MTPSLL2CURRENTSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 3}},
#define   MTPSLL2CURRENTSLALIGNMENT  684
	{MTPSLL2CURRENTSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 4}},
#define   MTPSLL2CURRENTSIGNUNITSRECEIVED  685
	{MTPSLL2CURRENTSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 5}},
#define   MTPSLL2CURRENTNEGACKRECEIVED  686
	{MTPSLL2CURRENTNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 6}},
#define   MTPSLL2CURRENTTRANSMITTEDOCTETSSIFSIO  687
	{MTPSLL2CURRENTTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 7}},
#define   MTPSLL2CURRENTRETRANSMITTEDOCTETS  688
	{MTPSLL2CURRENTRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 8}},
#define   MTPSLL2CURRENTTRANSMITTEDMSUS  689
	{MTPSLL2CURRENTTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 9}},
#define   MTPSLL2CURRENTRECEIVEDOCTETSSIFSIO  690
	{MTPSLL2CURRENTRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 10}},
#define   MTPSLL2CURRENTRECEIVEDMSUS  691
	{MTPSLL2CURRENTRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2CurrentTable, 6, {1, 1, 11, 10, 1, 11}},
#define   MTPSLL2INT5MINTIMESTAMP  698
	{MTPSLL2INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 2}},
#define   MTPSLL2INT5MINSLINSERVICEDURATION  699
	{MTPSLL2INT5MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 3}},
#define   MTPSLL2INT5MINSLALIGNMENT  700
	{MTPSLL2INT5MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 4}},
#define   MTPSLL2INT5MINSIGNUNITSRECEIVED  701
	{MTPSLL2INT5MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 5}},
#define   MTPSLL2INT5MINNEGACKRECEIVED  702
	{MTPSLL2INT5MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 6}},
#define   MTPSLL2INT5MINTRANSMITTEDOCTETSSIFSIO  703
	{MTPSLL2INT5MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 7}},
#define   MTPSLL2INT5MINRETRANSMITTEDOCTETS  704
	{MTPSLL2INT5MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 8}},
#define   MTPSLL2INT5MINTRANSMITTEDMSUS  705
	{MTPSLL2INT5MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 9}},
#define   MTPSLL2INT5MINRECEIVEDOCTETSSIFSIO  706
	{MTPSLL2INT5MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 10}},
#define   MTPSLL2INT5MINRECEIVEDMSUS  707
	{MTPSLL2INT5MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int5minTable, 6, {1, 1, 11, 11, 1, 11}},
#define   MTPSLL2INT15MINTIMESTAMP  714
	{MTPSLL2INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 2}},
#define   MTPSLL2INT15MINSLINSERVICEDURATION  715
	{MTPSLL2INT15MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 3}},
#define   MTPSLL2INT15MINSLALIGNMENT  716
	{MTPSLL2INT15MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 4}},
#define   MTPSLL2INT15MINSIGNUNITSRECEIVED  717
	{MTPSLL2INT15MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 5}},
#define   MTPSLL2INT15MINNEGACKRECEIVED  718
	{MTPSLL2INT15MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 6}},
#define   MTPSLL2INT15MINTRANSMITTEDOCTETSSIFSIO  719
	{MTPSLL2INT15MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 7}},
#define   MTPSLL2INT15MINRETRANSMITTEDOCTETS  720
	{MTPSLL2INT15MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 8}},
#define   MTPSLL2INT15MINTRANSMITTEDMSUS  721
	{MTPSLL2INT15MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 9}},
#define   MTPSLL2INT15MINRECEIVEDOCTETSSIFSIO  722
	{MTPSLL2INT15MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 10}},
#define   MTPSLL2INT15MINRECEIVEDMSUS  723
	{MTPSLL2INT15MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpSlL2Int15minTable, 6, {1, 1, 11, 12, 1, 11}},
#define   MTPNBTRANSMISSIONRATE  727
	{MTPNBTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 2}},
#define   MTPNBTIMERT8          728
	{MTPNBTIMERT8, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 3}},
#define   MTPNBTIN              729
	{MTPNBTIN, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 4}},
#define   MTPNBTIE              730
	{MTPNBTIE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 5}},
#define   MTPNBT                731
	{MTPNBT, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 6}},
#define   MTPNBD                732
	{MTPNBD, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 7}},
#define   MTPNBTE               733
	{MTPNBTE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 8}},
#define   MTPNBDE               734
	{MTPNBDE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 9}},
#define   MTPNBUE               735
	{MTPNBUE, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 10}},
#define   MTPNBN                736
	{MTPNBN, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 11}},
#define   MTPNBM                737
	{MTPNBM, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 12}},
#define   MTPNBB                738
	{MTPNBB, ASN_UNSIGNED, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 13}},
#define   MTPNBF                739
	{MTPNBF, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 14}},
#define   MTPNBROWSTATUS        740
	{MTPNBROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 12, 1, 1, 15}},
#define   MTPSAALBUFFERRELEASE  744
	{MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 1}},
#define   MTPSAALMAXCC          745
	{MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 2}},
#define   MTPSAALMAXNRP         746
	{MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  747
	{MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  748
	{MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 5}},
#define   MTPSAALMAXPD          749
	{MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  750
	{MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 7}},
#define   MTPSAALMAXSTAT        751
	{MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 8}},
#define   MTPSAALN1             752
	{MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  753
	{MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  754
	{MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  755
	{MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 12}},
#define   MTPSAALNNITIMERT1     756
	{MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 13}},
#define   MTPSAALNNITIMERT2     757
	{MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 14}},
#define   MTPSAALNNITIMERT3     758
	{MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   759
	{MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  760
	{MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  761
	{MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  762
	{MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  763
	{MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  764
	{MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  765
	{MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  766
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  767
	{MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  768
	{MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 25}},
#define   MTPSAALROWSTATUS      769
	{MTPSAALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 12, 2, 1, 26}},
#define   MTPM2PAN1             773
	{MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 1}},
#define   MTPM2PAPROVING        774
	{MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  775
	{MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 3}},
#define   MTPM2PALOOPDELAYLOWER  776
	{MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 4}},
#define   MTPM2PALOOPDELAYUPPER  777
	{MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 5}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  778
	{MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 6}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  779
	{MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 7}},
#define   MTPM2PASCTPNODELAY    780
	{MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 8}},
#define   MTPM2PASCTPMAXSEG     781
	{MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 9}},
#define   MTPM2PASCTPHEARTBEATITVL  782
	{MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 10}},
#define   MTPM2PASCTPHEARTBEAT  783
	{MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 11}},
#define   MTPM2PASCTPRTOINITIAL  784
	{MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 12}},
#define   MTPM2PASCTPRTOMIN     785
	{MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 13}},
#define   MTPM2PASCTPRTOMAX     786
	{MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 14}},
#define   MTPM2PASCTPPATHMAXRETRANS  787
	{MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 15}},
#define   MTPM2PASCTPCOOKIELIFE  788
	{MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 16}},
#define   MTPM2PASCTPCOOKIEINC  789
	{MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 17}},
#define   MTPM2PASCTPMAXINITRETRIES  790
	{MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 18}},
#define   MTPM2PASCTPMAXBURST   791
	{MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 19}},
#define   MTPM2PASCTPASSOCMAXRETRANS  792
	{MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 20}},
#define   MTPM2PASCTPSACKDELAY  793
	{MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 21}},
#define   MTPM2PASCTPLIFETIME   794
	{MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 22}},
#define   MTPM2PAPROVINGATTEMPTS  795
	{MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 23}},
#define   MTPM2PAROWSTATUS      796
	{MTPM2PAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 12, 3, 1, 24}},
#define   MTPSDTADMINISTRATIVESTATE  800
	{MTPSDTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 2}},
#define   MTPSDTOPERATIONALSTATE  801
	{MTPSDTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 3}},
#define   MTPSDTUSAGESTATE      802
	{MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 4}},
#define   MTPSDTPROCEDURALSTATUS  803
	{MTPSDTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 5}},
#define   MTPSDTAVAILABILITYSTATUS  804
	{MTPSDTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 6}},
#define   MTPSDTEQUIPMENTPOINTER  805
	{MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 7}},
#define   MTPSDTNAME            806
	{MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 8}},
#define   MTPSDTPROFILEPOINTER  807
	{MTPSDTPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 9}},
#define   MTPSDTROWSTATUS       808
	{MTPSDTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 12, 4, 1, 10}},
#define   MTPSDTSTATSTXBYTES    812
	{MTPSDTSTATSTXBYTES, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 1}},
#define   MTPSDTSTATSTXSUS      813
	{MTPSDTSTATSTXSUS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 2}},
#define   MTPSDTSTATSTXSUSREPEATED  814
	{MTPSDTSTATSTXSUSREPEATED, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 3}},
#define   MTPSDTSTATSTXUNDERRUNS  815
	{MTPSDTSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 4}},
#define   MTPSDTSTATSTXABORTS   816
	{MTPSDTSTATSTXABORTS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 5}},
#define   MTPSDTSTATSTXBUFFEROVERFLOWS  817
	{MTPSDTSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 6}},
#define   MTPSDTSTATSTXSUSINERROR  818
	{MTPSDTSTATSTXSUSINERROR, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 7}},
#define   MTPSDTSTATSRXBYTES    819
	{MTPSDTSTATSRXBYTES, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 8}},
#define   MTPSDTSTATSRXSUSCOMPRESSED  820
	{MTPSDTSTATSRXSUSCOMPRESSED, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 9}},
#define   MTPSDTSTATSRXOVERRUNS  821
	{MTPSDTSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 10}},
#define   MTPSDTSTATSRXABORTS   822
	{MTPSDTSTATSRXABORTS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 11}},
#define   MTPSDTSTATSRXBUFFEROVERFLOWS  823
	{MTPSDTSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 12}},
#define   MTPSDTSTATSRXSUSINERROR  824
	{MTPSDTSTATSRXSUSINERROR, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 13}},
#define   MTPSDTSTATSRXSYNCTRANSITIONS  825
	{MTPSDTSTATSRXSYNCTRANSITIONS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 14}},
#define   MTPSDTSTATSRXBITSOCTETCOUNTED  826
	{MTPSDTSTATSRXBITSOCTETCOUNTED, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 15}},
#define   MTPSDTSTATSRXCRCERRORS  827
	{MTPSDTSTATSRXCRCERRORS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 16}},
#define   MTPSDTSTATSRXFRAMEERRORS  828
	{MTPSDTSTATSRXFRAMEERRORS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 17}},
#define   MTPSDTSTATSRXFRAMEOVERFLOWS  829
	{MTPSDTSTATSRXFRAMEOVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 18}},
#define   MTPSDTSTATSRXFRAMETOOLONG  830
	{MTPSDTSTATSRXFRAMETOOLONG, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 19}},
#define   MTPSDTSTATSRXFRAMETOOSHORT  831
	{MTPSDTSTATSRXFRAMETOOSHORT, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 20}},
#define   MTPSDTSTATSRXRESIDUEERRORS  832
	{MTPSDTSTATSRXRESIDUEERRORS, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 21}},
#define   MTPSDTSTATSCARRIERCTSLOST  833
	{MTPSDTSTATSCARRIERCTSLOST, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 22}},
#define   MTPSDTSTATSCARRIERDCDLOST  834
	{MTPSDTSTATSCARRIERDCDLOST, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 23}},
#define   MTPSDTSTATSCARRIERLOST  835
	{MTPSDTSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpSdtStatsTable, 6, {1, 1, 12, 5, 1, 24}},
#define   MTPSDLADJPC           839
	{MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 2}},
#define   MTPSDLTRANSMISSIONRATE  840
	{MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       841
	{MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 4}},
#define   MTPSDLOPERATIONALSTATE  842
	{MTPSDLOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  843
	{MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 6}},
#define   MTPSDLCIC             844
	{MTPSDLCIC, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 7}},
#define   MTPSDLNAME            845
	{MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      846
	{MTPSDLSTMCHANNEL, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    847
	{MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 10}},
#define   MTPSDLROWSTATUS       848
	{MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 13, 1, 1, 11}},
#define   MTPSDLSTATSRXOCTETS   852
	{MTPSDLSTATSRXOCTETS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 1}},
#define   MTPSDLSTATSTXOCTETS   853
	{MTPSDLSTATSTXOCTETS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 2}},
#define   MTPSDLSTATSRXOVERRUNS  854
	{MTPSDLSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 3}},
#define   MTPSDLSTATSTXUNDERRUNS  855
	{MTPSDLSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 4}},
#define   MTPSDLSTATSRXBUFFEROVERFLOWS  856
	{MTPSDLSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 5}},
#define   MTPSDLSTATSTXBUFFEROVERFLOWS  857
	{MTPSDLSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 6}},
#define   MTPSDLSTATSLEADCTSLOST  858
	{MTPSDLSTATSLEADCTSLOST, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 7}},
#define   MTPSDLSTATSLEADDCDLOST  859
	{MTPSDLSTATSLEADDCDLOST, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 8}},
#define   MTPSDLSTATSCARRIERLOST  860
	{MTPSDLSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 9}},
#define   MTPSDLSTATSBIPOLARVIOLATIONS  861
	{MTPSDLSTATSBIPOLARVIOLATIONS, ASN_COUNTER, RONLY, var_mtpSdlStatsTable, 6, {1, 1, 13, 2, 1, 10}},
#define   MTPM2PADEFAULTSCTPNODELAY  862
	{MTPM2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 1}},
#define   MTPM2PADEFAULTSCTPMAXSEG  863
	{MTPM2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 2}},
#define   MTPM2PADEFAULTSCTPHEARTBEATITVL  864
	{MTPM2PADEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 3}},
#define   MTPM2PADEFAULTSCTPHEARTBEAT  865
	{MTPM2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 4}},
#define   MTPM2PADEFAULTSCTPRTOINITIAL  866
	{MTPM2PADEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 5}},
#define   MTPM2PADEFAULTSCTPRTOMIN  867
	{MTPM2PADEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 6}},
#define   MTPM2PADEFAULTSCTPRTOMAX  868
	{MTPM2PADEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 7}},
#define   MTPM2PADEFAULTSCTPPATHMAXRETRANS  869
	{MTPM2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 8}},
#define   MTPM2PADEFAULTSCTPCOOKIELIFE  870
	{MTPM2PADEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 9}},
#define   MTPM2PADEFAULTSCTPCOOKIEINC  871
	{MTPM2PADEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 10}},
#define   MTPM2PADEFAULTSCTPMAXINITRETRIES  872
	{MTPM2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 11}},
#define   MTPM2PADEFAULTSCTPMAXBURST  873
	{MTPM2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 12}},
#define   MTPM2PADEFAULTSCTPASSOCMAXRETRANS  874
	{MTPM2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 13}},
#define   MTPM2PADEFAULTSCTPSACKDELAY  875
	{MTPM2PADEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 14}},
#define   MTPM2PADEFAULTSCTPLIFETIME  876
	{MTPM2PADEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB2, 4, {1, 2, 1, 15}},

};

/*    (L = length of the oidsuffix) */
struct mtpMIB2_data *mtpMIB2Storage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpSapTableStorage = NULL;
struct header_complex_index *ss7NetworkTableStorage = NULL;
struct header_complex_index *mtpMsTableStorage = NULL;
struct header_complex_index *mtpNaTableStorage = NULL;
struct header_complex_index *mtpGsTableStorage = NULL;
struct header_complex_index *mtpGsLineTableStorage = NULL;
struct header_complex_index *mtpGsLineContentTableStorage = NULL;
struct header_complex_index *mtpSpProfileTableStorage = NULL;
struct header_complex_index *mtpSpTableStorage = NULL;
struct header_complex_index *mtpSpStatsTableStorage = NULL;
struct header_complex_index *mtpSpCurrentTableStorage = NULL;
struct header_complex_index *mtpSpInt5minTableStorage = NULL;
struct header_complex_index *mtpSpInt15minTableStorage = NULL;
struct header_complex_index *mtpSpSiTableStorage = NULL;
struct header_complex_index *mtpSpSiInt5minTableStorage = NULL;
struct header_complex_index *mtpSpSiInt15minTableStorage = NULL;
struct header_complex_index *mtpSpStudyTableStorage = NULL;
struct header_complex_index *mtpSpStudyInt5minTableStorage = NULL;
struct header_complex_index *mtpSpStudyInt15minTableStorage = NULL;
struct header_complex_index *mtpSpStudyMapTableStorage = NULL;
struct header_complex_index *mtpL3TableStorage = NULL;
struct header_complex_index *mtpRsProfileTableStorage = NULL;
struct header_complex_index *mtpRsTableStorage = NULL;
struct header_complex_index *mtpRsStatsTableStorage = NULL;
struct header_complex_index *mtpRsCurrentTableStorage = NULL;
struct header_complex_index *mtpRsInt5minTableStorage = NULL;
struct header_complex_index *mtpRsInt15minTableStorage = NULL;
struct header_complex_index *mtpRsSiTableStorage = NULL;
struct header_complex_index *mtpRsSiInt5minTableStorage = NULL;
struct header_complex_index *mtpRsSiInt15minTableStorage = NULL;
struct header_complex_index *mtpRtProfileTableStorage = NULL;
struct header_complex_index *mtpRtTableStorage = NULL;
struct header_complex_index *mtpRtLsaTableStorage = NULL;
struct header_complex_index *mtpLsProfileTableStorage = NULL;
struct header_complex_index *mtpLsTableStorage = NULL;
struct header_complex_index *mtpLsStatsTableStorage = NULL;
struct header_complex_index *mtpLsCurrentTableStorage = NULL;
struct header_complex_index *mtpLsInt5minTableStorage = NULL;
struct header_complex_index *mtpLsInt15minTableStorage = NULL;
struct header_complex_index *mtpSlL3ProfileTableStorage = NULL;
struct header_complex_index *mtpSlL2ProfileTableStorage = NULL;
struct header_complex_index *mtpSlTableStorage = NULL;
struct header_complex_index *mtpSlSdlListTableStorage = NULL;
struct header_complex_index *mtpSlSdtListTableStorage = NULL;
struct header_complex_index *mtpSlStatsTableStorage = NULL;
struct header_complex_index *mtpSlL3CurrentTableStorage = NULL;
struct header_complex_index *mtpSlL3Int5minTableStorage = NULL;
struct header_complex_index *mtpSlL3Int15minTableStorage = NULL;
struct header_complex_index *mtpSlL2CurrentTableStorage = NULL;
struct header_complex_index *mtpSlL2Int5minTableStorage = NULL;
struct header_complex_index *mtpSlL2Int15minTableStorage = NULL;
struct header_complex_index *mtpNbTableStorage = NULL;
struct header_complex_index *mtpSaalTableStorage = NULL;
struct header_complex_index *mtpM2paTableStorage = NULL;
struct header_complex_index *mtpSdtTableStorage = NULL;
struct header_complex_index *mtpSdtStatsTableStorage = NULL;
struct header_complex_index *mtpSdlTableStorage = NULL;
struct header_complex_index *mtpSdlStatsTableStorage = NULL;

/*
 * init_mtpMIB2():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_mtpMIB2(void)
{
	DEBUGMSGTL(("mtpMIB2", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB2", mtpMIB2_variables, variable7, mtpMIB2_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB2, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB2", parse_mtpMIB2, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapTable", parse_mtpSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("ss7NetworkTable", parse_ss7NetworkTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMsTable", parse_mtpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineTable", parse_mtpGsLineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineContentTable", parse_mtpGsLineContentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStatsTable", parse_mtpSpStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpCurrentTable", parse_mtpSpCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt5minTable", parse_mtpSpInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpInt15minTable", parse_mtpSpInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiTable", parse_mtpSpSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt5minTable", parse_mtpSpSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpSiInt15minTable", parse_mtpSpSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyTable", parse_mtpSpStudyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt5minTable", parse_mtpSpStudyInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyInt15minTable", parse_mtpSpStudyInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpStudyMapTable", parse_mtpSpStudyMapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL3Table", parse_mtpL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsProfileTable", parse_mtpRsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsStatsTable", parse_mtpRsStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsCurrentTable", parse_mtpRsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt5minTable", parse_mtpRsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsInt15minTable", parse_mtpRsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiTable", parse_mtpRsSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt5minTable", parse_mtpRsSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsSiInt15minTable", parse_mtpRsSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtProfileTable", parse_mtpRtProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtLsaTable", parse_mtpRtLsaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsProfileTable", parse_mtpLsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsStatsTable", parse_mtpLsStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsCurrentTable", parse_mtpLsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsInt5minTable", parse_mtpLsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsInt15minTable", parse_mtpLsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3ProfileTable", parse_mtpSlL3ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2ProfileTable", parse_mtpSlL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlStatsTable", parse_mtpSlStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3CurrentTable", parse_mtpSlL3CurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3Int5minTable", parse_mtpSlL3Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3Int15minTable", parse_mtpSlL3Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2CurrentTable", parse_mtpSlL2CurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2Int5minTable", parse_mtpSlL2Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2Int15minTable", parse_mtpSlL2Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbTable", parse_mtpNbTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtStatsTable", parse_mtpSdtStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlStatsTable", parse_mtpSdlStatsTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB2, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_ss7NetworkTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineContentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpStudyMapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtLsaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3CurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2CurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlStatsTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("mtpMIB2", "done.\n"));
}

/*
 * deinit_mtpMIB2():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_mtpMIB2(void)
{
	DEBUGMSGTL(("mtpMIB2", "deinitializating...  "));
	unregister_mib(mtpMIB2_variables_oid, sizeof(mtpMIB2_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB2");
	snmpd_unregister_config_handler("mtpSapTable");
	snmpd_unregister_config_handler("ss7NetworkTable");
	snmpd_unregister_config_handler("mtpMsTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsLineTable");
	snmpd_unregister_config_handler("mtpGsLineContentTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpSpStatsTable");
	snmpd_unregister_config_handler("mtpSpCurrentTable");
	snmpd_unregister_config_handler("mtpSpInt5minTable");
	snmpd_unregister_config_handler("mtpSpInt15minTable");
	snmpd_unregister_config_handler("mtpSpSiTable");
	snmpd_unregister_config_handler("mtpSpSiInt5minTable");
	snmpd_unregister_config_handler("mtpSpSiInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyTable");
	snmpd_unregister_config_handler("mtpSpStudyInt5minTable");
	snmpd_unregister_config_handler("mtpSpStudyInt15minTable");
	snmpd_unregister_config_handler("mtpSpStudyMapTable");
	snmpd_unregister_config_handler("mtpL3Table");
	snmpd_unregister_config_handler("mtpRsProfileTable");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRsStatsTable");
	snmpd_unregister_config_handler("mtpRsCurrentTable");
	snmpd_unregister_config_handler("mtpRsInt5minTable");
	snmpd_unregister_config_handler("mtpRsInt15minTable");
	snmpd_unregister_config_handler("mtpRsSiTable");
	snmpd_unregister_config_handler("mtpRsSiInt5minTable");
	snmpd_unregister_config_handler("mtpRsSiInt15minTable");
	snmpd_unregister_config_handler("mtpRtProfileTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpRtLsaTable");
	snmpd_unregister_config_handler("mtpLsProfileTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpLsStatsTable");
	snmpd_unregister_config_handler("mtpLsCurrentTable");
	snmpd_unregister_config_handler("mtpLsInt5minTable");
	snmpd_unregister_config_handler("mtpLsInt15minTable");
	snmpd_unregister_config_handler("mtpSlL3ProfileTable");
	snmpd_unregister_config_handler("mtpSlL2ProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpSlStatsTable");
	snmpd_unregister_config_handler("mtpSlL3CurrentTable");
	snmpd_unregister_config_handler("mtpSlL3Int5minTable");
	snmpd_unregister_config_handler("mtpSlL3Int15minTable");
	snmpd_unregister_config_handler("mtpSlL2CurrentTable");
	snmpd_unregister_config_handler("mtpSlL2Int5minTable");
	snmpd_unregister_config_handler("mtpSlL2Int15minTable");
	snmpd_unregister_config_handler("mtpNbTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdtStatsTable");
	snmpd_unregister_config_handler("mtpSdlTable");
	snmpd_unregister_config_handler("mtpSdlStatsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpMIB2", "done.\n"));
}

int
term_mtpMIB2(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_mtpMIB2();
	return 0;
}

/*
 * mtpMIB2_add(): adds a structure node for scalars
 */
int
mtpMIB2_add(struct mtpMIB2_data *thedata)
{
	DEBUGMSGTL(("mtpMIB2", "adding data...  "));
	mtpMIB2Storage = thedata;
	DEBUGMSGTL(("mtpMIB2", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMIB2():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMIB2(const char *token, char *line)
{
	size_t tmpint;
	struct mtpMIB2_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMIB2_data);

	DEBUGMSGTL(("mtpMIB2", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpint);

	mtpMIB2_add(StorageTmp);
	(void) tmpint;
	DEBUGMSGTL(("mtpMIB2", "done.\n"));
}

/*
 * store_mtpMIB2():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB2(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpMIB2_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB2", "storing data...  "));
	refresh_mtpMIB2();
	if ((StorageTmp = mtpMIB2Storage) == NULL) {
		DEBUGMSGTL(("mtpMIB2", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpint;
	/* XXX: if (StorageTmp->mtpMIB2StorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "mtpMIB2 ");
	cptr = line + strlen(line);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpNoDelay, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxseg, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl, &tmpint);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paDefaultSctpHeartbeat, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoInitial, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMin, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpRtoMax, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieLife, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpCookieInc, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxInitRetries, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpMaxBurst, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpSackDelay, &tmpint);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paDefaultSctpLifetime, &tmpint);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("mtpMIB2", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpMIB2: refresh mtpMIB2 scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB2(void)
{
	if (mtpMIB2Storage == NULL) {
		if ((mtpMIB2Storage = SNMP_MALLOC_STRUCT(mtpMIB2_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		mtpMIB2_refresh = 1;
	}
	if (mtpMIB2_refresh == 0)
		return;
	mtpMIB2_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_mtpMIB2():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_mtpMIB2(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB2_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpMIB2();
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPM2PADEFAULTSCTPNODELAY:
		*write_method = write_mtpM2paDefaultSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpNoDelay);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpNoDelay;
	case MTPM2PADEFAULTSCTPMAXSEG:
		*write_method = write_mtpM2paDefaultSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxseg);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpMaxseg;
	case MTPM2PADEFAULTSCTPHEARTBEATITVL:
		*write_method = write_mtpM2paDefaultSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeatItvl);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
	case MTPM2PADEFAULTSCTPHEARTBEAT:
		*write_method = write_mtpM2paDefaultSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpHeartbeat);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpHeartbeat;
	case MTPM2PADEFAULTSCTPRTOINITIAL:
		*write_method = write_mtpM2paDefaultSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoInitial);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpRtoInitial;
	case MTPM2PADEFAULTSCTPRTOMIN:
		*write_method = write_mtpM2paDefaultSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMin);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpRtoMin;
	case MTPM2PADEFAULTSCTPRTOMAX:
		*write_method = write_mtpM2paDefaultSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpRtoMax);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpRtoMax;
	case MTPM2PADEFAULTSCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpPathMaxRetrans);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
	case MTPM2PADEFAULTSCTPCOOKIELIFE:
		*write_method = write_mtpM2paDefaultSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieLife);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpCookieLife;
	case MTPM2PADEFAULTSCTPCOOKIEINC:
		*write_method = write_mtpM2paDefaultSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpCookieInc);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpCookieInc;
	case MTPM2PADEFAULTSCTPMAXINITRETRIES:
		*write_method = write_mtpM2paDefaultSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxInitRetries);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
	case MTPM2PADEFAULTSCTPMAXBURST:
		*write_method = write_mtpM2paDefaultSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpMaxBurst);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpMaxBurst;
	case MTPM2PADEFAULTSCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paDefaultSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
	case MTPM2PADEFAULTSCTPSACKDELAY:
		*write_method = write_mtpM2paDefaultSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpSackDelay);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpSackDelay;
	case MTPM2PADEFAULTSCTPLIFETIME:
		*write_method = write_mtpM2paDefaultSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paDefaultSctpLifetime);
		return (uint8_t *) &StorageTmp->mtpM2paDefaultSctpLifetime;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * mtpSapTable_add(): adds a structure node to our data set
 */
int
mtpSapTable_add(struct mtpSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSapId, sizeof(thedata->mtpSapId));

	header_complex_add_data(&mtpSapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSapTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSap2Address, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPart, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPartStatus, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
	if (StorageTmp->mtpSapUserEntityNames == NULL) {
		config_perror("invalid specification for mtpSapUserEntityNames");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
	if (StorageTmp->mtpSapProviderEntityNames == NULL) {
		config_perror("invalid specification for mtpSapProviderEntityNames");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUsageState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
	if (StorageTmp->mtpSapAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSapAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
	if (StorageTmp->mtpSapName == NULL) {
		config_perror("invalid specification for mtpSapName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapLongMessageSupported, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapRowStatus, &tmpint);

	mtpSapTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
}

/*
 * store_mtpSapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSapTable", "storing data...  "));
	refresh_mtpSapTable();
	for (hcindex = mtpSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSapTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSapTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSap2Address, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPart, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPartStatus, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUsageState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapLongMessageSupported, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * ss7NetworkTable_add(): adds a structure node to our data set
 */
int
ss7NetworkTable_add(struct ss7NetworkTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ss7NetworkTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* ss7NetworkId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->ss7NetworkId, sizeof(thedata->ss7NetworkId));

	header_complex_add_data(&ss7NetworkTableStorage, vars, thedata);
	DEBUGMSGTL(("ss7NetworkTable", "registered an entry\n"));
	DEBUGMSGTL(("ss7NetworkTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_ss7NetworkTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_ss7NetworkTable(const char *token, char *line)
{
	size_t tmpint;
	struct ss7NetworkTable_data *StorageTmp = SNMP_MALLOC_STRUCT(ss7NetworkTable_data);

	DEBUGMSGTL(("ss7NetworkTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->ss7NetworkId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->ss7NetworkProtocolStandard, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->ss7NetworkProtocolYear, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->ss7NetworkIndicator, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->ss7NetworkPointCodeFormat, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->ss7NetworkStatus, &tmpint);

	ss7NetworkTable_add(StorageTmp);
	DEBUGMSGTL(("ss7NetworkTable", "done.\n"));
}

/*
 * store_ss7NetworkTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_ss7NetworkTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct ss7NetworkTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ss7NetworkTable", "storing data...  "));
	refresh_ss7NetworkTable();
	for (hcindex = ss7NetworkTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct ss7NetworkTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->ss7NetworkTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "ss7NetworkTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->ss7NetworkId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->ss7NetworkProtocolStandard, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->ss7NetworkProtocolYear, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->ss7NetworkIndicator, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->ss7NetworkPointCodeFormat, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->ss7NetworkStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("ss7NetworkTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpMsTable_add(): adds a structure node to our data set
 */
int
mtpMsTable_add(struct mtpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));

	header_complex_add_data(&mtpMsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpMsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpMsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpMsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpMsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
	if (StorageTmp->mtpMsName == NULL) {
		config_perror("invalid specification for mtpMsName");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
	if (StorageTmp->mtpMsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpMsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsUsageState, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
	if (StorageTmp->mtpMsManagedElementType == NULL) {
		config_perror("invalid specification for mtpMsManagedElementType");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
	if (StorageTmp->mtpMsModelCode == NULL) {
		config_perror("invalid specification for mtpMsModelCode");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
	if (StorageTmp->mtpMsVendorName == NULL) {
		config_perror("invalid specification for mtpMsVendorName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
	if (StorageTmp->mtpMsUserLabel == NULL) {
		config_perror("invalid specification for mtpMsUserLabel");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
	if (StorageTmp->mtpMsVersion == NULL) {
		config_perror("invalid specification for mtpMsVersion");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
	if (StorageTmp->mtpMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpMsAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
	if (StorageTmp->mtpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for mtpMsNetworkElementAliases");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsStatus, &tmpint);

	mtpMsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
}

/*
 * store_mtpMsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMsTable", "storing data...  "));
	refresh_mtpMsTable();
	for (hcindex = mtpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpMsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpMsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsUsageState, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpMsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpNaTable_add(): adds a structure node to our data set
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpNaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (uint8_t *) &thedata->mtpNaId, sizeof(thedata->mtpNaId));

	header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNaTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpNaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaSlsLength, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
	if (StorageTmp->mtpNaSpDefault == NULL) {
		config_perror("invalid specification for mtpNaSpDefault");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaRowStatus, &tmpint);

	mtpNaTable_add(StorageTmp);
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
}

/*
 * store_mtpNaTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNaTable", "storing data...  "));
	refresh_mtpNaTable();
	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpNaTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpNaTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaSlsLength, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsTable_add(): adds a structure node to our data set
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));

	header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpGsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRowStatus, &tmpint);

	mtpGsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
}

/*
 * store_mtpGsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsTable", "storing data...  "));
	refresh_mtpGsTable();
	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpGsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsLineTable_add(): adds a structure node to our data set
 */
int
mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));

	header_complex_add_data(&mtpGsLineTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsLineTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsLineTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsLineTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpGsLineTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
	if (StorageTmp->mtpGsLineObject == NULL) {
		config_perror("invalid specification for mtpGsLineObject");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContent, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineRowStatus, &tmpint);

	mtpGsLineTable_add(StorageTmp);
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
}

/*
 * store_mtpGsLineTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsLineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineTable", "storing data...  "));
	refresh_mtpGsLineTable();
	for (hcindex = mtpGsLineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpGsLineTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsLineTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContent, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsLineTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpGsLineContentTable_add(): adds a structure node to our data set
 */
int
mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpGsLineContentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpGsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
	/* mtpGsLineId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
	/* mtpGsLineContentId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpGsLineContentId, sizeof(thedata->mtpGsLineContentId));

	header_complex_add_data(&mtpGsLineContentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpGsLineContentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpGsLineContentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpGsLineContentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpGsLineContentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpGsLineContentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCFirst == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCFirst");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCLast == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCLast");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
	if (StorageTmp->mtpGsLineContentSiMask == NULL) {
		config_perror("invalid specification for mtpGsLineContentSiMask");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
	if (StorageTmp->mtpGsLineContentComment == NULL) {
		config_perror("invalid specification for mtpGsLineContentComment");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentRowStatus, &tmpint);

	mtpGsLineContentTable_add(StorageTmp);
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
}

/*
 * store_mtpGsLineContentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineContentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpGsLineContentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpGsLineContentTable", "storing data...  "));
	refresh_mtpGsLineContentTable();
	for (hcindex = mtpGsLineContentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineContentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpGsLineContentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpGsLineContentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpGsLineContentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpProfileTable_add(): adds a structure node to our data set
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);

	header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpSpProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
	if (StorageTmp->mtpSpProfileId == NULL) {
		config_perror("invalid specification for mtpSpProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1R, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT7, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT11, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT15, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT16, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT18I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT19I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT24A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT26A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT27A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2T, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
	if (StorageTmp->mtpSpRsDefault == NULL) {
		config_perror("invalid specification for mtpSpRsDefault");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
	if (StorageTmp->mtpSpLsDefault == NULL) {
		config_perror("invalid specification for mtpSpLsDefault");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileRowStatus, &tmpint);

	mtpSpProfileTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
}

/*
 * store_mtpSpProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpProfileTable", "storing data...  "));
	refresh_mtpSpProfileTable();
	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpProfileTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1R, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT7, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT11, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT15, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT16, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT18I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT19I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT24A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT26A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT27A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2T, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpTable_add(): adds a structure node to our data set
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));

	header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
	if (StorageTmp->mtpSpPointCode == NULL) {
		config_perror("invalid specification for mtpSpPointCode");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
	if (StorageTmp->mtpSpVersion == NULL) {
		config_perror("invalid specification for mtpSpVersion");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpNetworkIndicator, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT7, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT8, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT10, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT11, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT15, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT16, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT17, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT31A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT32A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT33A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT34A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT18I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT19I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT22I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT23I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT24I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT2T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpMtpT1S, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
	if (StorageTmp->mtpSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpSpProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
	if (StorageTmp->mtpSpNaPointer == NULL) {
		config_perror("invalid specification for mtpSpNaPointer");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpFlags, &StorageTmp->mtpSpFlagsLen);
	if (StorageTmp->mtpSpFlags == NULL) {
		config_perror("invalid specification for mtpSpFlags");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
	if (StorageTmp->mtpSpUsers == NULL) {
		config_perror("invalid specification for mtpSpUsers");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
	if (StorageTmp->mtpSpAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSpAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpRowStatus, &tmpint);

	mtpSpTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
}

/*
 * store_mtpSpTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpTable", "storing data...  "));
	refresh_mtpSpTable();
	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpNetworkIndicator, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT7, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT8, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT10, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT11, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT15, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT16, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT17, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT31A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT32A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT33A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT34A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT18I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT19I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT22I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT23I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT24I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT2T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpMtpT1S, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpFlags, &StorageTmp->mtpSpFlagsLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStatsTable_add(): adds a structure node to our data set
 */
int
mtpSpStatsTable_add(struct mtpSpStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpMsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));

	header_complex_add_data(&mtpSpStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStatsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStatsTable_data);

	DEBUGMSGTL(("mtpSpStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStatsRowStatus, &tmpint);

	mtpSpStatsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpStatsTable", "done.\n"));
}

/*
 * store_mtpSpStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStatsTable", "storing data...  "));
	refresh_mtpSpStatsTable();
	for (hcindex = mtpSpStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStatsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpCurrentTable_add(): adds a structure node to our data set
 */
int
mtpSpCurrentTable_add(struct mtpSpCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));

	header_complex_add_data(&mtpSpCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpCurrentTable_data);

	DEBUGMSGTL(("mtpSpCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpint);

	mtpSpCurrentTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
}

/*
 * store_mtpSpCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpCurrentTable", "storing data...  "));
	refresh_mtpSpCurrentTable();
	for (hcindex = mtpSpCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpCurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpCurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpCurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpCurrentOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpInt5minTable_add(): adds a structure node to our data set
 */
int
mtpSpInt5minTable_add(struct mtpSpInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpInt5minInterval, sizeof(thedata->mtpSpInt5minInterval));

	header_complex_add_data(&mtpSpInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt5minTable_data);

	DEBUGMSGTL(("mtpSpInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpint);

	mtpSpInt5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
}

/*
 * store_mtpSpInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt5minTable", "storing data...  "));
	refresh_mtpSpInt5minTable();
	for (hcindex = mtpSpInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt5minOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpInt15minTable_add(): adds a structure node to our data set
 */
int
mtpSpInt15minTable_add(struct mtpSpInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpInt15minInterval, sizeof(thedata->mtpSpInt15minInterval));

	header_complex_add_data(&mtpSpInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpInt15minTable_data);

	DEBUGMSGTL(("mtpSpInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpint);

	mtpSpInt15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
}

/*
 * store_mtpSpInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpInt15minTable", "storing data...  "));
	refresh_mtpSpInt15minTable();
	for (hcindex = mtpSpInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus0, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus1, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minReceivedTFCstatus2, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpInt15minOctetsXferred, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpSiTable_add(): adds a structure node to our data set
 */
int
mtpSpSiTable_add(struct mtpSpSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));

	header_complex_add_data(&mtpSpSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);

	DEBUGMSGTL(("mtpSpSiTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpSiStatus, &tmpint);

	mtpSpSiTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
}

/*
 * store_mtpSpSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiTable", "storing data...  "));
	refresh_mtpSpSiTable();
	for (hcindex = mtpSpSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpSiTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiHandledOctetsSIO, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpSiStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpSiInt5minTable_add(): adds a structure node to our data set
 */
int
mtpSpSiInt5minTable_add(struct mtpSpSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiInt5minInterval, sizeof(thedata->mtpSpSiInt5minInterval));

	header_complex_add_data(&mtpSpSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpSpSiInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpint);

	mtpSpSiInt5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt5minTable", "storing data...  "));
	refresh_mtpSpSiInt5minTable();
	for (hcindex = mtpSpSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpSiInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt5minHandledOctetsSIO, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpSiInt15minTable_add(): adds a structure node to our data set
 */
int
mtpSpSiInt15minTable_add(struct mtpSpSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiInt15minInterval, sizeof(thedata->mtpSpSiInt15minInterval));

	header_complex_add_data(&mtpSpSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpSiInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpSiInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpSpSiInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpint);

	mtpSpSiInt15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
}

/*
 * store_mtpSpSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpSiInt15minTable", "storing data...  "));
	refresh_mtpSpSiInt15minTable();
	for (hcindex = mtpSpSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpSiInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpSiInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpSiInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpSiInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpSiInt15minHandledOctetsSIO, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyTable_add(struct mtpSpStudyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));

	header_complex_add_data(&mtpSpStudyTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);

	DEBUGMSGTL(("mtpSpStudyTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyStatus, &tmpint);

	mtpSpStudyTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
}

/*
 * store_mtpSpStudyTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyTable", "storing data...  "));
	refresh_mtpSpStudyTable();
	for (hcindex = mtpSpStudyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyInt5minTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyInt5minTable_add(struct mtpSpStudyInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));
	/* mtpSpStudyInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyInt5minInterval, sizeof(thedata->mtpSpStudyInt5minInterval));

	header_complex_add_data(&mtpSpStudyInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpint);

	mtpSpStudyInt5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt5minTable", "storing data...  "));
	refresh_mtpSpStudyInt5minTable();
	for (hcindex = mtpSpStudyInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyInt15minTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyInt15minTable_add(struct mtpSpStudyInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));
	/* mtpSpStudyInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (uint8_t *) &thedata->mtpSpStudyInt15minInterval, sizeof(thedata->mtpSpStudyInt15minInterval));

	header_complex_add_data(&mtpSpStudyInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpint);

	mtpSpStudyInt15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
}

/*
 * store_mtpSpStudyInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyInt15minTable", "storing data...  "));
	refresh_mtpSpStudyInt15minTable();
	for (hcindex = mtpSpStudyInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSpStudyInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSpStudyMapTable_add(): adds a structure node to our data set
 */
int
mtpSpStudyMapTable_add(struct mtpSpStudyMapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSpStudyMapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpSpSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpSiCode, sizeof(thedata->mtpSpSiCode));
	/* mtpSpStudyId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpStudyId, sizeof(thedata->mtpSpStudyId));

	header_complex_add_data(&mtpSpStudyMapTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSpStudyMapTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSpStudyMapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSpStudyMapTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSpStudyMapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);

	DEBUGMSGTL(("mtpSpStudyMapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpStudyId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpStudyMapStatus, &tmpint);

	mtpSpStudyMapTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
}

/*
 * store_mtpSpStudyMapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpStudyMapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSpStudyMapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSpStudyMapTable", "storing data...  "));
	refresh_mtpSpStudyMapTable();
	for (hcindex = mtpSpStudyMapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpStudyMapTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSpStudyMapTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSpStudyMapTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpStudyId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpStudyMapStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSpStudyMapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpL3Table_add(): adds a structure node to our data set
 */
int
mtpL3Table_add(struct mtpL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpL3Table", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpL3Id */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpL3Id, thedata->mtpL3IdLen);

	header_complex_add_data(&mtpL3TableStorage, vars, thedata);
	DEBUGMSGTL(("mtpL3Table", "registered an entry\n"));
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpL3Table():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpL3Table(const char *token, char *line)
{
	size_t tmpint;
	struct mtpL3Table_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpL3Table", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
	if (StorageTmp->mtpL3Id == NULL) {
		config_perror("invalid specification for mtpL3Id");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3AdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3OperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3UsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
	if (StorageTmp->mtpL3ProceduralStatus == NULL) {
		config_perror("invalid specification for mtpL3ProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
	if (StorageTmp->mtpL3AsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpL3AsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
	if (StorageTmp->mtpL3Name == NULL) {
		config_perror("invalid specification for mtpL3Name");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3RowStatus, &tmpint);

	mtpL3Table_add(StorageTmp);
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
}

/*
 * store_mtpL3Table():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpL3Table", "storing data...  "));
	refresh_mtpL3Table();
	for (hcindex = mtpL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL3Table_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpL3TableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpL3Table ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Id, &StorageTmp->mtpL3IdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3AdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3OperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3UsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3RowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpL3Table", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsProfileTable_add(): adds a structure node to our data set
 */
int
mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpRsProfileId, thedata->mtpRsProfileIdLen);

	header_complex_add_data(&mtpRsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpRsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
	if (StorageTmp->mtpRsProfileId == NULL) {
		config_perror("invalid specification for mtpRsProfileId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
	if (StorageTmp->mtpRsProfileName == NULL) {
		config_perror("invalid specification for mtpRsProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT8, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT11, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT15, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT16, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT18A, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
	if (StorageTmp->mtpRsProfileRtDefault == NULL) {
		config_perror("invalid specification for mtpRsProfileRtDefault");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileRowStatus, &tmpint);

	mtpRsProfileTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
}

/*
 * store_mtpRsProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsProfileTable", "storing data...  "));
	refresh_mtpRsProfileTable();
	for (hcindex = mtpRsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsProfileTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT8, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT11, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT15, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT16, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT18A, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsTable_add(): adds a structure node to our data set
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));

	header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
	if (StorageTmp->mtpRsDest == NULL) {
		config_perror("invalid specification for mtpRsDest");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsFlags, &StorageTmp->mtpRsFlagsLen);
	if (StorageTmp->mtpRsFlags == NULL) {
		config_perror("invalid specification for mtpRsFlags");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
	if (StorageTmp->mtpRsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpRsAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestedState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestionLevel, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
	if (StorageTmp->mtpRsProfile == NULL) {
		config_perror("invalid specification for mtpRsProfile");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
	if (StorageTmp->mtpRsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpRsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsRowStatus, &tmpint);

	mtpRsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
}

/*
 * store_mtpRsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsTable", "storing data...  "));
	refresh_mtpRsTable();
	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsFlags, &StorageTmp->mtpRsFlagsLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestedState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestionLevel, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsStatsTable_add(): adds a structure node to our data set
 */
int
mtpRsStatsTable_add(struct mtpRsStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));

	header_complex_add_data(&mtpRsStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsStatsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsStatsTable_data);

	DEBUGMSGTL(("mtpRsStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsStatsStatus, &tmpint);

	mtpRsStatsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsStatsTable", "done.\n"));
}

/*
 * store_mtpRsStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsStatsTable", "storing data...  "));
	refresh_mtpRsStatsTable();
	for (hcindex = mtpRsStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsStatsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsCurrentTable_add(): adds a structure node to our data set
 */
int
mtpRsCurrentTable_add(struct mtpRsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));

	header_complex_add_data(&mtpRsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsCurrentTable_data);

	DEBUGMSGTL(("mtpRsCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpint);

	mtpRsCurrentTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
}

/*
 * store_mtpRsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsCurrentTable", "storing data...  "));
	refresh_mtpRsCurrentTable();
	for (hcindex = mtpRsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsCurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsCurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsCurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsInt5minTable_add(): adds a structure node to our data set
 */
int
mtpRsInt5minTable_add(struct mtpRsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsInt5minInterval, sizeof(thedata->mtpRsInt5minInterval));

	header_complex_add_data(&mtpRsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt5minTable_data);

	DEBUGMSGTL(("mtpRsInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpint);

	mtpRsInt5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
}

/*
 * store_mtpRsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt5minTable", "storing data...  "));
	refresh_mtpRsInt5minTable();
	for (hcindex = mtpRsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsInt15minTable_add(): adds a structure node to our data set
 */
int
mtpRsInt15minTable_add(struct mtpRsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsInt15minInterval, sizeof(thedata->mtpRsInt15minInterval));

	header_complex_add_data(&mtpRsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsInt15minTable_data);

	DEBUGMSGTL(("mtpRsInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpint);

	mtpRsInt15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
}

/*
 * store_mtpRsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsInt15minTable", "storing data...  "));
	refresh_mtpRsInt15minTable();
	for (hcindex = mtpRsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedOctetsOPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedOctetsDPC, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minReceivedMSUsOpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minTransmittedMSUsDpc, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailable, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsSiTable_add(): adds a structure node to our data set
 */
int
mtpRsSiTable_add(struct mtpRsSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));

	header_complex_add_data(&mtpRsSiTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);

	DEBUGMSGTL(("mtpRsSiTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsSiStatus, &tmpint);

	mtpRsSiTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
}

/*
 * store_mtpRsSiTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiTable", "storing data...  "));
	refresh_mtpRsSiTable();
	for (hcindex = mtpRsSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsSiTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedOctetsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiTransmittedMSUsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsSiStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsSiInt5minTable_add(): adds a structure node to our data set
 */
int
mtpRsSiInt5minTable_add(struct mtpRsSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiInt5minInterval, sizeof(thedata->mtpRsSiInt5minInterval));

	header_complex_add_data(&mtpRsSiInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpRsSiInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpint);

	mtpRsSiInt5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt5minTable", "storing data...  "));
	refresh_mtpRsSiInt5minTable();
	for (hcindex = mtpRsSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsSiInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRsSiInt15minTable_add(): adds a structure node to our data set
 */
int
mtpRsSiInt15minTable_add(struct mtpRsSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRsSiCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiCode, sizeof(thedata->mtpRsSiCode));
	/* mtpRsSiInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsSiInt15minInterval, sizeof(thedata->mtpRsSiInt15minInterval));

	header_complex_add_data(&mtpRsSiInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRsSiInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRsSiInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRsSiInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRsSiInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpRsSiInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsSiInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpint);

	mtpRsSiInt15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
}

/*
 * store_mtpRsSiInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRsSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRsSiInt15minTable", "storing data...  "));
	refresh_mtpRsSiInt15minTable();
	for (hcindex = mtpRsSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsSiInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRsSiInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRsSiInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsSiInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpRsSiInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRsSiInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtProfileTable_add(): adds a structure node to our data set
 */
int
mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpRtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpRtProfileId, thedata->mtpRtProfileIdLen);

	header_complex_add_data(&mtpRtProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpRtProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
	if (StorageTmp->mtpRtProfileId == NULL) {
		config_perror("invalid specification for mtpRtProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT10, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileRowStatus, &tmpint);

	mtpRtProfileTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
}

/*
 * store_mtpRtProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtProfileTable", "storing data...  "));
	refresh_mtpRtProfileTable();
	for (hcindex = mtpRtProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRtProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtProfileTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT10, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtTable_add(): adds a structure node to our data set
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));

	header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpRtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
	if (StorageTmp->mtpRtLsPointer == NULL) {
		config_perror("invalid specification for mtpRtLsPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlSlot, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
	if (StorageTmp->mtpRtProfile == NULL) {
		config_perror("invalid specification for mtpRtProfile");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtRowStatus, &tmpint);

	mtpRtTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
}

/*
 * store_mtpRtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtTable", "storing data...  "));
	refresh_mtpRtTable();
	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRtTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlSlot, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpRtLsaTable_add(): adds a structure node to our data set
 */
int
mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpRtLsaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpRsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
	/* mtpRtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
	/* mtpRtLsaSlsCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpRtLsaSlsCode, sizeof(thedata->mtpRtLsaSlsCode));

	header_complex_add_data(&mtpRtLsaTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpRtLsaTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpRtLsaTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpRtLsaTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpRtLsaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpRtLsaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaSlsCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtLsaNormalSlCode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
	if (StorageTmp->mtpRtLsaAlternativeSlCodeList == NULL) {
		config_perror("invalid specification for mtpRtLsaAlternativeSlCodeList");
		return;
	}

	mtpRtLsaTable_add(StorageTmp);
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
}

/*
 * store_mtpRtLsaTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtLsaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpRtLsaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpRtLsaTable", "storing data...  "));
	refresh_mtpRtLsaTable();
	for (hcindex = mtpRtLsaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtLsaTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpRtLsaTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpRtLsaTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaSlsCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtLsaNormalSlCode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpRtLsaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsProfileTable_add(): adds a structure node to our data set
 */
int
mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpLsProfileId, thedata->mtpLsProfileIdLen);

	header_complex_add_data(&mtpLsProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpLsProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
	if (StorageTmp->mtpLsProfileId == NULL) {
		config_perror("invalid specification for mtpLsProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT8, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT10, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT7, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT19I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT21I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT25A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT28A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT29A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT30A, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
	if (StorageTmp->mtpLsProfileName == NULL) {
		config_perror("invalid specification for mtpLsProfileName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
	if (StorageTmp->mtpLsProfileSlDefault == NULL) {
		config_perror("invalid specification for mtpLsProfileSlDefault");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileRowStatus, &tmpint);

	mtpLsProfileTable_add(StorageTmp);
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
}

/*
 * store_mtpLsProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsProfileTable", "storing data...  "));
	refresh_mtpLsProfileTable();
	for (hcindex = mtpLsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsProfileTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT8, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT10, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT7, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT19I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT21I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT25A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT28A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT29A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT30A, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsTable_add(): adds a structure node to our data set
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));

	header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpLsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
	if (StorageTmp->mtpLsRsId == NULL) {
		config_perror("invalid specification for mtpLsRsId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsCurrentCapacity, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
	if (StorageTmp->mtpLsProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
	if (StorageTmp->mtpLsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
	if (StorageTmp->mtpLsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsRowStatus, &tmpint);

	mtpLsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
}

/*
 * store_mtpLsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsTable", "storing data...  "));
	refresh_mtpLsTable();
	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsStatsTable_add(): adds a structure node to our data set
 */
int
mtpLsStatsTable_add(struct mtpLsStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));

	header_complex_add_data(&mtpLsStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsStatsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsStatsTable_data);

	DEBUGMSGTL(("mtpLsStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsStatsStatus, &tmpint);

	mtpLsStatsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpLsStatsTable", "done.\n"));
}

/*
 * store_mtpLsStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsStatsTable", "storing data...  "));
	refresh_mtpLsStatsTable();
	for (hcindex = mtpLsStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsStatsStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsCurrentTable_add(): adds a structure node to our data set
 */
int
mtpLsCurrentTable_add(struct mtpLsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));

	header_complex_add_data(&mtpLsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsCurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsCurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsCurrentTable_data);

	DEBUGMSGTL(("mtpLsCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsCurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsCurrentSlsUnavailable, &tmpint);

	mtpLsCurrentTable_add(StorageTmp);
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
}

/*
 * store_mtpLsCurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsCurrentTable", "storing data...  "));
	refresh_mtpLsCurrentTable();
	for (hcindex = mtpLsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsCurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsCurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsCurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsCurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsCurrentSlsUnavailable, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsInt5minTable_add(): adds a structure node to our data set
 */
int
mtpLsInt5minTable_add(struct mtpLsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsInt5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));
	/* mtpLsInt5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt5minInterval, sizeof(thedata->mtpLsInt5minInterval));

	header_complex_add_data(&mtpLsInt5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsInt5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsInt5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsInt5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsInt5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsInt5minTable_data);

	DEBUGMSGTL(("mtpLsInt5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt5minInterval, &tmpint);

	mtpLsInt5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
}

/*
 * store_mtpLsInt5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsInt5minTable", "storing data...  "));
	refresh_mtpLsInt5minTable();
	for (hcindex = mtpLsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsInt5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsInt5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsInt5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt5minInterval, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsInt5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpLsInt15minTable_add(): adds a structure node to our data set
 */
int
mtpLsInt15minTable_add(struct mtpLsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpLsInt15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpLsInt15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsInt15minInterval, sizeof(thedata->mtpLsInt15minInterval));

	header_complex_add_data(&mtpLsInt15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpLsInt15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpLsInt15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpLsInt15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpLsInt15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpLsInt15minTable_data);

	DEBUGMSGTL(("mtpLsInt15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsInt15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpLsInt15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpLsInt15minSlsUnavailable, &tmpint);

	mtpLsInt15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
}

/*
 * store_mtpLsInt15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpLsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpLsInt15minTable", "storing data...  "));
	refresh_mtpLsInt15minTable();
	for (hcindex = mtpLsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsInt15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpLsInt15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpLsInt15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsInt15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpLsInt15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpLsInt15minSlsUnavailable, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpLsInt15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3ProfileTable_add(): adds a structure node to our data set
 */
int
mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSlL3ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpSlL3ProfileId, thedata->mtpSlL3ProfileIdLen);

	header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3ProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3ProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL3ProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpSlL3ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
	if (StorageTmp->mtpSlL3ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
	if (StorageTmp->mtpSlL3ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
	if (StorageTmp->mtpSlL3ProfileL2Default == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileL2Default");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpint);

	mtpSlL3ProfileTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL3ProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL3ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3ProfileTable", "storing data...  "));
	refresh_mtpSlL3ProfileTable();
	for (hcindex = mtpSlL3ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3ProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3ProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3ProfileTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2ProfileTable_add(): adds a structure node to our data set
 */
int
mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSlL2ProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpSlL2ProfileId, thedata->mtpSlL2ProfileIdLen);
	/* mtpSlL2ProfileTransmissionRate */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (uint8_t *) &thedata->mtpSlL2ProfileTransmissionRate, sizeof(thedata->mtpSlL2ProfileTransmissionRate));

	header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2ProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2ProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2ProfileTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL2ProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpSlL2ProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
	if (StorageTmp->mtpSlL2ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
	if (StorageTmp->mtpSlL2ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileM, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpint);

	mtpSlL2ProfileTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
}

/*
 * store_mtpSlL2ProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2ProfileTable", "storing data...  "));
	refresh_mtpSlL2ProfileTable();
	for (hcindex = mtpSlL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2ProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2ProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2ProfileTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileM, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2ProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlTable_add(): adds a structure node to our data set
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpSlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacitySL, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCurrentCapacitySL, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
	if (StorageTmp->mtpSlLinkTpStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkTpStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
	if (StorageTmp->mtpSlMtpL2ProtocolProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlMtpL2ProtocolProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
	if (StorageTmp->mtpSlSignTermPointer == NULL) {
		config_perror("invalid specification for mtpSlSignTermPointer");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
	if (StorageTmp->mtpSlSignDataLinkTpPointer == NULL) {
		config_perror("invalid specification for mtpSlSignDataLinkTpPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
	if (StorageTmp->mtpSlAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlAsaProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
	if (StorageTmp->mtpSlL3ProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlL3ProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
	if (StorageTmp->mtpSlAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSlAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRowStatus, &tmpint);

	mtpSlTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
}

/*
 * store_mtpSlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlTable", "storing data...  "));
	refresh_mtpSlTable();
	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacitySL, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCurrentCapacitySL, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlSdlListTable_add(): adds a structure node to our data set
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdlListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlSdlListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSdlListId, sizeof(thedata->mtpSlSdlListId));

	header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdlListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdlListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlSdlListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpSlSdlListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListRowStatus, &tmpint);

	mtpSlSdlListTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
}

/*
 * store_mtpSlSdlListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdlListTable", "storing data...  "));
	refresh_mtpSlSdlListTable();
	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlSdlListTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlSdlListTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlSdlListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlSdtListTable_add(): adds a structure node to our data set
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlSdtListTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlSdtListId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSdtListId, sizeof(thedata->mtpSlSdtListId));

	header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlSdtListTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlSdtListTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlSdtListTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpSlSdtListTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListId, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListRowStatus, &tmpint);

	mtpSlSdtListTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
}

/*
 * store_mtpSlSdtListTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlSdtListTable", "storing data...  "));
	refresh_mtpSlSdtListTable();
	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlSdtListTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlSdtListTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListId, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlSdtListTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlStatsTable_add(): adds a structure node to our data set
 */
int
mtpSlStatsTable_add(struct mtpSlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlStatsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlStatsTable_data);

	DEBUGMSGTL(("mtpSlStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurInService, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsFailAlignOrProving, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsNacksReceived, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurUnavail, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurUnavailFailed, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurUnavailRpo, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsSibsSent, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsTranSioSifOctets, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsRetransOctets, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsTranMsus, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsRecvSioSifOctets, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsRecvMsus, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd0, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd1, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd2, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongOnsetInd3, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus0, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus1, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus2, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsDurCongStatus3, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd0, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd1, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd2, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSlStatsCongDiscdInd3, &tmpint);

	mtpSlStatsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlStatsTable", "done.\n"));
}

/*
 * store_mtpSlStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlStatsTable", "storing data...  "));
	refresh_mtpSlStatsTable();
	for (hcindex = mtpSlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurInService, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsFailAlignOrProving, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsNacksReceived, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurUnavail, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurUnavailFailed, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurUnavailRpo, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsSibsSent, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsTranSioSifOctets, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsRetransOctets, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsTranMsus, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsRecvSioSifOctets, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsRecvMsus, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd0, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd1, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd2, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongOnsetInd3, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus0, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus1, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus2, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsDurCongStatus3, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd0, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd1, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd2, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSlStatsCongDiscdInd3, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3CurrentTable_add(): adds a structure node to our data set
 */
int
mtpSlL3CurrentTable_add(struct mtpSlL3CurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3CurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlL3CurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3CurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3CurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3CurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL3CurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3CurrentTable_data);

	DEBUGMSGTL(("mtpSlL3CurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3CurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL3CurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3CurrentRestorations, &tmpint);

	mtpSlL3CurrentTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL3CurrentTable", "done.\n"));
}

/*
 * store_mtpSlL3CurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3CurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL3CurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3CurrentTable", "storing data...  "));
	refresh_mtpSlL3CurrentTable();
	for (hcindex = mtpSlL3CurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3CurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3CurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3CurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3CurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL3CurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3CurrentRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3Int5minTable_add(): adds a structure node to our data set
 */
int
mtpSlL3Int5minTable_add(struct mtpSlL3Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL3Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL3Int5minInterval, sizeof(thedata->mtpSlL3Int5minInterval));

	header_complex_add_data(&mtpSlL3Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3Int5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3Int5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3Int5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL3Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3Int5minTable_data);

	DEBUGMSGTL(("mtpSlL3Int5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL3Int5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL3Int5minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int5minRestorations, &tmpint);

	mtpSlL3Int5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL3Int5minTable", "done.\n"));
}

/*
 * store_mtpSlL3Int5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL3Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3Int5minTable", "storing data...  "));
	refresh_mtpSlL3Int5minTable();
	for (hcindex = mtpSlL3Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3Int5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3Int5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3Int5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL3Int5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL3Int5minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int5minRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL3Int15minTable_add(): adds a structure node to our data set
 */
int
mtpSlL3Int15minTable_add(struct mtpSlL3Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL3Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL3Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL3Int15minInterval, sizeof(thedata->mtpSlL3Int15minInterval));

	header_complex_add_data(&mtpSlL3Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL3Int15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL3Int15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL3Int15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL3Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL3Int15minTable_data);

	DEBUGMSGTL(("mtpSlL3Int15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL3Int15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL3Int15minTimeStamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlLocalInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlRemoteInhibition, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlFailed, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlRemoteProcOutage, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minLocalMgmtInhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minLocalBusy, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlCongestedStarts, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlCongestedDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minSlCongestionStops, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minDiscardedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minChangeovers, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minChangebacks, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL3Int15minRestorations, &tmpint);

	mtpSlL3Int15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL3Int15minTable", "done.\n"));
}

/*
 * store_mtpSlL3Int15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL3Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL3Int15minTable", "storing data...  "));
	refresh_mtpSlL3Int15minTable();
	for (hcindex = mtpSlL3Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3Int15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL3Int15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL3Int15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL3Int15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL3Int15minTimeStamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlLocalInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlRemoteInhibition, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlFailed, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlRemoteProcOutage, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minLocalMgmtInhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minLocalBusy, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlCongestedStarts, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlCongestedDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minSlCongestionStops, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minDiscardedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minChangeovers, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minChangebacks, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL3Int15minRestorations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL3Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2CurrentTable_add(): adds a structure node to our data set
 */
int
mtpSlL2CurrentTable_add(struct mtpSlL2CurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2CurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));

	header_complex_add_data(&mtpSlL2CurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2CurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2CurrentTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2CurrentTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL2CurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2CurrentTable_data);

	DEBUGMSGTL(("mtpSlL2CurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2CurrentValidIntervals, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL2CurrentTimeDiscontinuity, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentSlInServiceDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentSlAlignment, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentSignUnitsReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentNegAckReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentRetransmittedOctets, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentTransmittedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2CurrentReceivedMSUs, &tmpint);

	mtpSlL2CurrentTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL2CurrentTable", "done.\n"));
}

/*
 * store_mtpSlL2CurrentTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2CurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL2CurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2CurrentTable", "storing data...  "));
	refresh_mtpSlL2CurrentTable();
	for (hcindex = mtpSlL2CurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2CurrentTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2CurrentTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2CurrentTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2CurrentValidIntervals, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL2CurrentTimeDiscontinuity, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentSlInServiceDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentSlAlignment, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentSignUnitsReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentNegAckReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentRetransmittedOctets, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentTransmittedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2CurrentReceivedMSUs, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2CurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2Int5minTable_add(): adds a structure node to our data set
 */
int
mtpSlL2Int5minTable_add(struct mtpSlL2Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2Int5minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL2Int5minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL2Int5minInterval, sizeof(thedata->mtpSlL2Int5minInterval));

	header_complex_add_data(&mtpSlL2Int5minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2Int5minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2Int5minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2Int5minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL2Int5minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2Int5minTable_data);

	DEBUGMSGTL(("mtpSlL2Int5minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2Int5minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL2Int5minTimestamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minSlInServiceDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minSlAlignment, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minSignUnitsReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minNegAckReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minRetransmittedOctets, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minTransmittedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int5minReceivedMSUs, &tmpint);

	mtpSlL2Int5minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL2Int5minTable", "done.\n"));
}

/*
 * store_mtpSlL2Int5minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL2Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2Int5minTable", "storing data...  "));
	refresh_mtpSlL2Int5minTable();
	for (hcindex = mtpSlL2Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2Int5minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2Int5minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2Int5minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2Int5minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL2Int5minTimestamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minSlInServiceDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minSlAlignment, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minSignUnitsReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minNegAckReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minRetransmittedOctets, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minTransmittedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int5minReceivedMSUs, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2Int5minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSlL2Int15minTable_add(): adds a structure node to our data set
 */
int
mtpSlL2Int15minTable_add(struct mtpSlL2Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSlL2Int15minTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSpId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
	/* mtpLsId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
	/* mtpSlSlCode */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
	/* mtpSlL2Int15minInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSlL2Int15minInterval, sizeof(thedata->mtpSlL2Int15minInterval));

	header_complex_add_data(&mtpSlL2Int15minTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSlL2Int15minTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSlL2Int15minTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSlL2Int15minTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSlL2Int15minTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSlL2Int15minTable_data);

	DEBUGMSGTL(("mtpSlL2Int15minTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSlCode, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2Int15minInterval, &tmpint);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpSlL2Int15minTimestamp, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minSlInServiceDuration, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minSlAlignment, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minSignUnitsReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minNegAckReceived, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minRetransmittedOctets, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minTransmittedMSUs, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO, &tmpint);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpSlL2Int15minReceivedMSUs, &tmpint);

	mtpSlL2Int15minTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSlL2Int15minTable", "done.\n"));
}

/*
 * store_mtpSlL2Int15minTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSlL2Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSlL2Int15minTable", "storing data...  "));
	refresh_mtpSlL2Int15minTable();
	for (hcindex = mtpSlL2Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2Int15minTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSlL2Int15minTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSlL2Int15minTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSlCode, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2Int15minInterval, &tmpint);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpSlL2Int15minTimestamp, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minSlInServiceDuration, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minSlAlignment, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minSignUnitsReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minNegAckReceived, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minRetransmittedOctets, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minTransmittedMSUs, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO, &tmpint);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpSlL2Int15minReceivedMSUs, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSlL2Int15minTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpNbTable_add(): adds a structure node to our data set
 */
int
mtpNbTable_add(struct mtpNbTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpNbTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);

	header_complex_add_data(&mtpNbTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpNbTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpNbTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpNbTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpNbTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpNbTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTimerT8, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTie, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbT, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbD, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTe, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbDe, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbUe, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbN, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbm, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbb, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbf, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbRowStatus, &tmpint);

	mtpNbTable_add(StorageTmp);
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
}

/*
 * store_mtpNbTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpNbTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpNbTable", "storing data...  "));
	refresh_mtpNbTable();
	for (hcindex = mtpNbTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpNbTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpNbTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTimerT8, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTin, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTie, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbT, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbD, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTe, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbDe, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbUe, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbN, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbm, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbb, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbf, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpNbTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSaalTable_add(): adds a structure node to our data set
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSaalTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);

	header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSaalTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSaalTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSaalTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpSaalTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalRowStatus, &tmpint);

	mtpSaalTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
}

/*
 * store_mtpSaalTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSaalTable", "storing data...  "));
	refresh_mtpSaalTable();
	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSaalTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSaalTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSaalTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpM2paTable_add(): adds a structure node to our data set
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpM2paTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);

	header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpM2paTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpM2paTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpM2paTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpM2paTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paRowStatus, &tmpint);

	mtpM2paTable_add(StorageTmp);
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
}

/*
 * store_mtpM2paTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpM2paTable", "storing data...  "));
	refresh_mtpM2paTable();
	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpM2paTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpM2paTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpM2paTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdtTable_add(): adds a structure node to our data set
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));

	header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpSdtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdministrativeState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperationalState, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpint);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
	if (StorageTmp->mtpSdtProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSdtProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
	if (StorageTmp->mtpSdtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
	if (StorageTmp->mtpSdtProfilePointer == NULL) {
		config_perror("invalid specification for mtpSdtProfilePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtRowStatus, &tmpint);

	mtpSdtTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
}

/*
 * store_mtpSdtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtTable", "storing data...  "));
	refresh_mtpSdtTable();
	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSdtTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdtTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdministrativeState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpint);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdtStatsTable_add(): adds a structure node to our data set
 */
int
mtpSdtStatsTable_add(struct mtpSdtStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdtStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdtId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));

	header_complex_add_data(&mtpSdtStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdtStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdtStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdtStatsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdtStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdtStatsTable_data);

	DEBUGMSGTL(("mtpSdtStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxBytes, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxSus, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxSusRepeated, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxUnderruns, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxAborts, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxBufferOverflows, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsTxSusInError, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxBytes, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxSusCompressed, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxOverruns, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxAborts, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxBufferOverflows, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxSusInError, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxSyncTransitions, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxBitsOctetCounted, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxCrcErrors, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameErrors, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameOverflows, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameTooLong, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxFrameTooShort, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsRxResidueErrors, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsCarrierCtsLost, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsCarrierDcdLost, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdtStatsCarrierLost, &tmpint);

	mtpSdtStatsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSdtStatsTable", "done.\n"));
}

/*
 * store_mtpSdtStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdtStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdtStatsTable", "storing data...  "));
	refresh_mtpSdtStatsTable();
	for (hcindex = mtpSdtStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSdtStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdtStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxBytes, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxSus, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxSusRepeated, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxUnderruns, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxAborts, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxBufferOverflows, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsTxSusInError, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxBytes, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxSusCompressed, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxOverruns, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxAborts, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxBufferOverflows, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxSusInError, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxSyncTransitions, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxBitsOctetCounted, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxCrcErrors, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameErrors, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameOverflows, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameTooLong, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxFrameTooShort, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsRxResidueErrors, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsCarrierCtsLost, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsCarrierDcdLost, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdtStatsCarrierLost, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdtStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdlTable_add(): adds a structure node to our data set
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSdlId, sizeof(thedata->mtpSdlId));

	header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpSdlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlId, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpint);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpint);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperationalState, &tmpint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlCIC, &tmpint);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
	if (StorageTmp->mtpSdlStmChannel == NULL) {
		config_perror("invalid specification for mtpSdlStmChannel");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpint);

	mtpSdlTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
}

/*
 * store_mtpSdlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlTable", "storing data...  "));
	refresh_mtpSdlTable();
	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSdlTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdlTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlId, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpint);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpint);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperationalState, &tmpint);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlCIC, &tmpint);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * mtpSdlStatsTable_add(): adds a structure node to our data set
 */
int
mtpSdlStatsTable_add(struct mtpSdlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpSdlStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* mtpSdlId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->mtpSdlId, sizeof(thedata->mtpSdlId));

	header_complex_add_data(&mtpSdlStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("mtpSdlStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("mtpSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_mtpSdlStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_mtpSdlStatsTable(const char *token, char *line)
{
	size_t tmpint;
	struct mtpSdlStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(mtpSdlStatsTable_data);

	DEBUGMSGTL(("mtpSdlStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlId, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsRxOctets, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsTxOctets, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsRXOverruns, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsTxUnderruns, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsRxBufferOverflows, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsTxBufferOverflows, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsLeadCtsLost, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsLeadDcdLost, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsCarrierLost, &tmpint);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpSdlStatsBipolarViolations, &tmpint);

	mtpSdlStatsTable_add(StorageTmp);
	DEBUGMSGTL(("mtpSdlStatsTable", "done.\n"));
}

/*
 * store_mtpSdlStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpint;
	struct mtpSdlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpSdlStatsTable", "storing data...  "));
	refresh_mtpSdlStatsTable();
	for (hcindex = mtpSdlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->mtpSdlStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "mtpSdlStatsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlId, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsRxOctets, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsTxOctets, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsRXOverruns, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsTxUnderruns, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsRxBufferOverflows, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsTxBufferOverflows, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsLeadCtsLost, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsLeadDcdLost, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsCarrierLost, &tmpint);
		cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpSdlStatsBipolarViolations, &tmpint);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("mtpSdlStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_mtpSapTable(): refresh mtpSapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSapTable(void)
{
	if (mtpSapTable_refresh == 0)
		return;
	mtpSapTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSapTable_row(): refresh mtpSapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSapTable_request == sa_request)
		return;
	StorageTmp->mtpSapTable_request = sa_request;
}

/*
 * var_mtpSapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSapTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSAP2ADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSap2Address);
		return (uint8_t *) &StorageTmp->mtpSap2Address;
	case MTPSAPUSERPART:
		*write_method = write_mtpSapUserPart;
		*var_len = sizeof(StorageTmp->mtpSapUserPart);
		return (uint8_t *) &StorageTmp->mtpSapUserPart;
	case MTPSAPUSERPARTSTATUS:
		*write_method = write_mtpSapUserPartStatus;
		*var_len = sizeof(StorageTmp->mtpSapUserPartStatus);
		return (uint8_t *) &StorageTmp->mtpSapUserPartStatus;
	case MTPSAPUSERENTITYNAMES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSapUserEntityNamesLen;
		return (uint8_t *) StorageTmp->mtpSapUserEntityNames;
	case MTPSAPPROVIDERENTITYNAMES:
		*write_method = write_mtpSapProviderEntityNames;
		*var_len = StorageTmp->mtpSapProviderEntityNamesLen;
		return (uint8_t *) StorageTmp->mtpSapProviderEntityNames;
	case MTPSAPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSapUsageState);
		return (uint8_t *) &StorageTmp->mtpSapUsageState;
	case MTPSAPASAPROFILEPOINTER:
		*write_method = write_mtpSapAsaProfilePointer;
		*var_len = StorageTmp->mtpSapAsaProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpSapAsaProfilePointer;
	case MTPSAPNAME:
		*write_method = write_mtpSapName;
		*var_len = StorageTmp->mtpSapNameLen;
		return (uint8_t *) StorageTmp->mtpSapName;
	case MTPSAPLONGMESSAGESUPPORTED:
		*write_method = write_mtpSapLongMessageSupported;
		*var_len = sizeof(StorageTmp->mtpSapLongMessageSupported);
		return (uint8_t *) &StorageTmp->mtpSapLongMessageSupported;
	case MTPSAPROWSTATUS:
		*write_method = write_mtpSapRowStatus;
		*var_len = sizeof(StorageTmp->mtpSapRowStatus);
		return (uint8_t *) &StorageTmp->mtpSapRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_ss7NetworkTable(): refresh ss7NetworkTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_ss7NetworkTable(void)
{
	if (ss7NetworkTable_refresh == 0)
		return;
	ss7NetworkTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_ss7NetworkTable_row(): refresh ss7NetworkTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_ss7NetworkTable_row(struct ss7NetworkTable_data *StorageTmp)
{
	if (StorageTmp->ss7NetworkTable_request == sa_request)
		return;
	StorageTmp->ss7NetworkTable_request = sa_request;
}

/*
 * var_ss7NetworkTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_ss7NetworkTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct ss7NetworkTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_ss7NetworkTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_ss7NetworkTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(ss7NetworkTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_ss7NetworkTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SS7NETWORKPROTOCOLSTANDARD:
		*write_method = write_ss7NetworkProtocolStandard;
		*var_len = sizeof(StorageTmp->ss7NetworkProtocolStandard);
		return (uint8_t *) &StorageTmp->ss7NetworkProtocolStandard;
	case SS7NETWORKPROTOCOLYEAR:
		*write_method = write_ss7NetworkProtocolYear;
		*var_len = sizeof(StorageTmp->ss7NetworkProtocolYear);
		return (uint8_t *) &StorageTmp->ss7NetworkProtocolYear;
	case SS7NETWORKINDICATOR:
		*write_method = write_ss7NetworkIndicator;
		*var_len = sizeof(StorageTmp->ss7NetworkIndicator);
		return (uint8_t *) &StorageTmp->ss7NetworkIndicator;
	case SS7NETWORKPOINTCODEFORMAT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->ss7NetworkPointCodeFormat);
		return (uint8_t *) &StorageTmp->ss7NetworkPointCodeFormat;
	case SS7NETWORKSTATUS:
		*write_method = write_ss7NetworkStatus;
		*var_len = sizeof(StorageTmp->ss7NetworkStatus);
		return (uint8_t *) &StorageTmp->ss7NetworkStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpMsTable(): refresh mtpMsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpMsTable(void)
{
	if (mtpMsTable_refresh == 0)
		return;
	mtpMsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpMsTable_row(): refresh mtpMsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	if (StorageTmp->mtpMsTable_request == sa_request)
		return;
	StorageTmp->mtpMsTable_request = sa_request;
}

/*
 * var_mtpMsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpMsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpMsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpMsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPMSNAME:
		*write_method = write_mtpMsName;
		*var_len = StorageTmp->mtpMsNameLen;
		return (uint8_t *) StorageTmp->mtpMsName;
	case MTPMSALARMSTATUS:
		*write_method = write_mtpMsAlarmStatus;
		*var_len = StorageTmp->mtpMsAlarmStatusLen;
		return (uint8_t *) StorageTmp->mtpMsAlarmStatus;
	case MTPMSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsOperationalState);
		return (uint8_t *) &StorageTmp->mtpMsOperationalState;
	case MTPMSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpMsUsageState);
		return (uint8_t *) &StorageTmp->mtpMsUsageState;
	case MTPMSMANAGEDELEMENTTYPE:
		*write_method = write_mtpMsManagedElementType;
		*var_len = StorageTmp->mtpMsManagedElementTypeLen;
		return (uint8_t *) StorageTmp->mtpMsManagedElementType;
	case MTPMSMODELCODE:
		*write_method = write_mtpMsModelCode;
		*var_len = StorageTmp->mtpMsModelCodeLen;
		return (uint8_t *) StorageTmp->mtpMsModelCode;
	case MTPMSVENDORNAME:
		*write_method = write_mtpMsVendorName;
		*var_len = StorageTmp->mtpMsVendorNameLen;
		return (uint8_t *) StorageTmp->mtpMsVendorName;
	case MTPMSUSERLABEL:
		*write_method = write_mtpMsUserLabel;
		*var_len = StorageTmp->mtpMsUserLabelLen;
		return (uint8_t *) StorageTmp->mtpMsUserLabel;
	case MTPMSVERSION:
		*write_method = write_mtpMsVersion;
		*var_len = StorageTmp->mtpMsVersionLen;
		return (uint8_t *) StorageTmp->mtpMsVersion;
	case MTPMSASAPROFILEPOINTER:
		*write_method = write_mtpMsAsaProfilePointer;
		*var_len = StorageTmp->mtpMsAsaProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpMsAsaProfilePointer;
	case MTPMSNETWORKELEMENTALIASES:
		*write_method = write_mtpMsNetworkElementAliases;
		*var_len = StorageTmp->mtpMsNetworkElementAliasesLen;
		return (uint8_t *) StorageTmp->mtpMsNetworkElementAliases;
	case MTPMSSTATUS:
		*write_method = write_mtpMsStatus;
		*var_len = sizeof(StorageTmp->mtpMsStatus);
		return (uint8_t *) &StorageTmp->mtpMsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNaTable(): refresh mtpNaTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(void)
{
	if (mtpNaTable_refresh == 0)
		return;
	mtpNaTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpNaTable_row(): refresh mtpNaTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	if (StorageTmp->mtpNaTable_request == sa_request)
		return;
	StorageTmp->mtpNaTable_request = sa_request;
}

/*
 * var_mtpNaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpNaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpNaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPNAPROTOCOLVARIANT:
		*write_method = write_mtpNaProtocolVariant;
		*var_len = StorageTmp->mtpNaProtocolVariantLen;
		return (uint8_t *) StorageTmp->mtpNaProtocolVariant;
	case MTPNAPROTOCOLYEAR:
		*write_method = write_mtpNaProtocolYear;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		return (uint8_t *) &StorageTmp->mtpNaProtocolYear;
	case MTPNAPROTOCOLOPTIONS:
		*write_method = write_mtpNaProtocolOptions;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		return (uint8_t *) StorageTmp->mtpNaProtocolOptions;
	case MTPNANETWORKINDICATOR:
		*write_method = write_mtpNaNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		return (uint8_t *) &StorageTmp->mtpNaNetworkIndicator;
	case MTPNAPOINTCODEFORMAT:
		*write_method = write_mtpNaPointCodeFormat;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		return (uint8_t *) StorageTmp->mtpNaPointCodeFormat;
	case MTPNASLSLENGTH:
		*write_method = write_mtpNaSlsLength;
		*var_len = sizeof(StorageTmp->mtpNaSlsLength);
		return (uint8_t *) &StorageTmp->mtpNaSlsLength;
	case MTPNASPDEFAULT:
		*write_method = write_mtpNaSpDefault;
		*var_len = StorageTmp->mtpNaSpDefaultLen;
		return (uint8_t *) StorageTmp->mtpNaSpDefault;
	case MTPNANAME:
		*write_method = write_mtpNaName;
		*var_len = StorageTmp->mtpNaNameLen;
		return (uint8_t *) StorageTmp->mtpNaName;
	case MTPNAROWSTATUS:
		*write_method = write_mtpNaRowStatus;
		*var_len = sizeof(StorageTmp->mtpNaRowStatus);
		return (uint8_t *) &StorageTmp->mtpNaRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsTable(): refresh mtpGsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(void)
{
	if (mtpGsTable_refresh == 0)
		return;
	mtpGsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpGsTable_row(): refresh mtpGsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsTable_request == sa_request)
		return;
	StorageTmp->mtpGsTable_request = sa_request;
}

/*
 * var_mtpGsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpGsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPGSADMINISTRATIVESTATE:
		*write_method = write_mtpGsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		return (uint8_t *) &StorageTmp->mtpGsAdministrativeState;
	case MTPGSTREATMENTOFOUTSIDERANGES:
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		return (uint8_t *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;
	case MTPGSLISTMODE:
		*write_method = write_mtpGsListMode;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		return (uint8_t *) &StorageTmp->mtpGsListMode;
	case MTPGSSCREENINGBYLINKSETORBYOPC:
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		return (uint8_t *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
	case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		return (uint8_t *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
	case MTPGSNAME:
		*write_method = write_mtpGsName;
		*var_len = StorageTmp->mtpGsNameLen;
		return (uint8_t *) StorageTmp->mtpGsName;
	case MTPGSROWSTATUS:
		*write_method = write_mtpGsRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsRowStatus);
		return (uint8_t *) &StorageTmp->mtpGsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsLineTable(): refresh mtpGsLineTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsLineTable(void)
{
	if (mtpGsLineTable_refresh == 0)
		return;
	mtpGsLineTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpGsLineTable_row(): refresh mtpGsLineTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineTable_request = sa_request;
}

/*
 * var_mtpGsLineTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpGsLineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpGsLineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsLineTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsLineTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPGSLINEOBJECT:
		*write_method = write_mtpGsLineObject;
		*var_len = StorageTmp->mtpGsLineObjectLen;
		return (uint8_t *) StorageTmp->mtpGsLineObject;
	case MTPGSLINECONTENT:
		*write_method = write_mtpGsLineContent;
		*var_len = sizeof(StorageTmp->mtpGsLineContent);
		return (uint8_t *) &StorageTmp->mtpGsLineContent;
	case MTPGSLINEROWSTATUS:
		*write_method = write_mtpGsLineRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineRowStatus);
		return (uint8_t *) &StorageTmp->mtpGsLineRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpGsLineContentTable(): refresh mtpGsLineContentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpGsLineContentTable(void)
{
	if (mtpGsLineContentTable_refresh == 0)
		return;
	mtpGsLineContentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpGsLineContentTable_row(): refresh mtpGsLineContentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	if (StorageTmp->mtpGsLineContentTable_request == sa_request)
		return;
	StorageTmp->mtpGsLineContentTable_request = sa_request;
}

/*
 * var_mtpGsLineContentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpGsLineContentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpGsLineContentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpGsLineContentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpGsLineContentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPGSLINECONTENTDESIGNATEDDPCFIRST:
		*write_method = write_mtpGsLineContentDesignatedDPCFirst;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		return (uint8_t *) StorageTmp->mtpGsLineContentDesignatedDPCFirst;
	case MTPGSLINECONTENTDESIGNATEDDPCLAST:
		*write_method = write_mtpGsLineContentDesignatedDPCLast;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		return (uint8_t *) StorageTmp->mtpGsLineContentDesignatedDPCLast;
	case MTPGSLINECONTENTSIMASK:
		*write_method = write_mtpGsLineContentSiMask;
		*var_len = StorageTmp->mtpGsLineContentSiMaskLen;
		return (uint8_t *) StorageTmp->mtpGsLineContentSiMask;
	case MTPGSLINECONTENTMESSAGETREATMENT:
		*write_method = write_mtpGsLineContentMessageTreatment;
		*var_len = sizeof(StorageTmp->mtpGsLineContentMessageTreatment);
		return (uint8_t *) &StorageTmp->mtpGsLineContentMessageTreatment;
	case MTPGSLINECONTENTCOMMENT:
		*write_method = write_mtpGsLineContentComment;
		*var_len = StorageTmp->mtpGsLineContentCommentLen;
		return (uint8_t *) StorageTmp->mtpGsLineContentComment;
	case MTPGSLINECONTENTROWSTATUS:
		*write_method = write_mtpGsLineContentRowStatus;
		*var_len = sizeof(StorageTmp->mtpGsLineContentRowStatus);
		return (uint8_t *) &StorageTmp->mtpGsLineContentRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpProfileTable(): refresh mtpSpProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(void)
{
	if (mtpSpProfileTable_refresh == 0)
		return;
	mtpSpProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpProfileTable_row(): refresh mtpSpProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSpProfileTable_request = sa_request;
}

/*
 * var_mtpSpProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPPROFILETIMERT1R:
		*write_method = write_mtpSpProfileTimerT1R;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1R);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT1R;
	case MTPSPPROFILETIMERT2:
		*write_method = write_mtpSpProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT2;
	case MTPSPPROFILETIMERT4:
		*write_method = write_mtpSpProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT4);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT4;
	case MTPSPPROFILETIMERT5:
		*write_method = write_mtpSpProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT5);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT5;
	case MTPSPPROFILETIMERT7:
		*write_method = write_mtpSpProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT7);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT7;
	case MTPSPPROFILETIMERT11:
		*write_method = write_mtpSpProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT11);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT11;
	case MTPSPPROFILETIMERT12:
		*write_method = write_mtpSpProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT12);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT12;
	case MTPSPPROFILETIMERT13:
		*write_method = write_mtpSpProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT13);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT13;
	case MTPSPPROFILETIMERT14:
		*write_method = write_mtpSpProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT14);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT14;
	case MTPSPPROFILETIMERT15:
		*write_method = write_mtpSpProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT15);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT15;
	case MTPSPPROFILETIMERT16:
		*write_method = write_mtpSpProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT16);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT16;
	case MTPSPPROFILETIMERT18I:
		*write_method = write_mtpSpProfileTimerT18I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT18I);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT18I;
	case MTPSPPROFILETIMERT19I:
		*write_method = write_mtpSpProfileTimerT19I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT19I);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT19I;
	case MTPSPPROFILETIMERT20I:
		*write_method = write_mtpSpProfileTimerT20I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20I);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT20I;
	case MTPSPPROFILETIMERT21I:
		*write_method = write_mtpSpProfileTimerT21I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21I);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT21I;
	case MTPSPPROFILETIMERT22I:
		*write_method = write_mtpSpProfileTimerT22I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22I);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT22I;
	case MTPSPPROFILETIMERT23I:
		*write_method = write_mtpSpProfileTimerT23I;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23I);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT23I;
	case MTPSPPROFILETIMERT20A:
		*write_method = write_mtpSpProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT20A;
	case MTPSPPROFILETIMERT21A:
		*write_method = write_mtpSpProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT21A;
	case MTPSPPROFILETIMERT22A:
		*write_method = write_mtpSpProfileTimerT22A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT22A;
	case MTPSPPROFILETIMERT23A:
		*write_method = write_mtpSpProfileTimerT23A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT23A;
	case MTPSPPROFILETIMERT24A:
		*write_method = write_mtpSpProfileTimerT24A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT24A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT24A;
	case MTPSPPROFILETIMERT26A:
		*write_method = write_mtpSpProfileTimerT26A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT26A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT26A;
	case MTPSPPROFILETIMERT27A:
		*write_method = write_mtpSpProfileTimerT27A;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT27A);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT27A;
	case MTPSPPROFILETIMERT1T:
		*write_method = write_mtpSpProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1T);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT1T;
	case MTPSPPROFILETIMERT2T:
		*write_method = write_mtpSpProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2T);
		return (uint8_t *) &StorageTmp->mtpSpProfileTimerT2T;
	case MTPSPPROFILENAME:
		*write_method = write_mtpSpProfileName;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		return (uint8_t *) StorageTmp->mtpSpProfileName;
	case MTPSPPROFILEROWSTATUS:
		*write_method = write_mtpSpProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpProfileRowStatus);
		return (uint8_t *) &StorageTmp->mtpSpProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpTable(): refresh mtpSpTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(void)
{
	if (mtpSpTable_refresh == 0)
		return;
	mtpSpTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpTable_row(): refresh mtpSpTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpTable_request == sa_request)
		return;
	StorageTmp->mtpSpTable_request = sa_request;
}

/*
 * var_mtpSpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPPOINTCODE:
		*write_method = write_mtpSpPointCode;
		*var_len = StorageTmp->mtpSpPointCodeLen;
		return (uint8_t *) StorageTmp->mtpSpPointCode;
	case MTPSPTYPE:
		*write_method = write_mtpSpType;
		*var_len = sizeof(StorageTmp->mtpSpType);
		return (uint8_t *) &StorageTmp->mtpSpType;
	case MTPSPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		return (uint8_t *) &StorageTmp->mtpSpOperationalState;
	case MTPSPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		return (uint8_t *) StorageTmp->mtpSpProceduralStatus;
	case MTPSPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->mtpSpAvailabilityStatus;
	case MTPSPVERSION:
		*write_method = write_mtpSpVersion;
		*var_len = StorageTmp->mtpSpVersionLen;
		return (uint8_t *) StorageTmp->mtpSpVersion;
	case MTPSPNETWORKINDICATOR:
		*write_method = write_mtpSpNetworkIndicator;
		*var_len = sizeof(StorageTmp->mtpSpNetworkIndicator);
		return (uint8_t *) &StorageTmp->mtpSpNetworkIndicator;
	case MTPSPNAME:
		*write_method = write_mtpSpName;
		*var_len = StorageTmp->mtpSpNameLen;
		return (uint8_t *) StorageTmp->mtpSpName;
	case MTPSPMTPT1:
		*write_method = write_mtpSpMtpT1;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1);
		return (uint8_t *) &StorageTmp->mtpSpMtpT1;
	case MTPSPMTPT2:
		*write_method = write_mtpSpMtpT2;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2);
		return (uint8_t *) &StorageTmp->mtpSpMtpT2;
	case MTPSPMTPT3:
		*write_method = write_mtpSpMtpT3;
		*var_len = sizeof(StorageTmp->mtpSpMtpT3);
		return (uint8_t *) &StorageTmp->mtpSpMtpT3;
	case MTPSPMTPT4:
		*write_method = write_mtpSpMtpT4;
		*var_len = sizeof(StorageTmp->mtpSpMtpT4);
		return (uint8_t *) &StorageTmp->mtpSpMtpT4;
	case MTPSPMTPT5:
		*write_method = write_mtpSpMtpT5;
		*var_len = sizeof(StorageTmp->mtpSpMtpT5);
		return (uint8_t *) &StorageTmp->mtpSpMtpT5;
	case MTPSPMTPT6:
		*write_method = write_mtpSpMtpT6;
		*var_len = sizeof(StorageTmp->mtpSpMtpT6);
		return (uint8_t *) &StorageTmp->mtpSpMtpT6;
	case MTPSPMTPT7:
		*write_method = write_mtpSpMtpT7;
		*var_len = sizeof(StorageTmp->mtpSpMtpT7);
		return (uint8_t *) &StorageTmp->mtpSpMtpT7;
	case MTPSPMTPT8:
		*write_method = write_mtpSpMtpT8;
		*var_len = sizeof(StorageTmp->mtpSpMtpT8);
		return (uint8_t *) &StorageTmp->mtpSpMtpT8;
	case MTPSPMTPT10:
		*write_method = write_mtpSpMtpT10;
		*var_len = sizeof(StorageTmp->mtpSpMtpT10);
		return (uint8_t *) &StorageTmp->mtpSpMtpT10;
	case MTPSPMTPT11:
		*write_method = write_mtpSpMtpT11;
		*var_len = sizeof(StorageTmp->mtpSpMtpT11);
		return (uint8_t *) &StorageTmp->mtpSpMtpT11;
	case MTPSPMTPT12:
		*write_method = write_mtpSpMtpT12;
		*var_len = sizeof(StorageTmp->mtpSpMtpT12);
		return (uint8_t *) &StorageTmp->mtpSpMtpT12;
	case MTPSPMTPT13:
		*write_method = write_mtpSpMtpT13;
		*var_len = sizeof(StorageTmp->mtpSpMtpT13);
		return (uint8_t *) &StorageTmp->mtpSpMtpT13;
	case MTPSPMTPT14:
		*write_method = write_mtpSpMtpT14;
		*var_len = sizeof(StorageTmp->mtpSpMtpT14);
		return (uint8_t *) &StorageTmp->mtpSpMtpT14;
	case MTPSPMTPT15:
		*write_method = write_mtpSpMtpT15;
		*var_len = sizeof(StorageTmp->mtpSpMtpT15);
		return (uint8_t *) &StorageTmp->mtpSpMtpT15;
	case MTPSPMTPT16:
		*write_method = write_mtpSpMtpT16;
		*var_len = sizeof(StorageTmp->mtpSpMtpT16);
		return (uint8_t *) &StorageTmp->mtpSpMtpT16;
	case MTPSPMTPT17:
		*write_method = write_mtpSpMtpT17;
		*var_len = sizeof(StorageTmp->mtpSpMtpT17);
		return (uint8_t *) &StorageTmp->mtpSpMtpT17;
	case MTPSPMTPT19A:
		*write_method = write_mtpSpMtpT19A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT19A;
	case MTPSPMTPT31A:
		*write_method = write_mtpSpMtpT31A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT31A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT31A;
	case MTPSPMTPT32A:
		*write_method = write_mtpSpMtpT32A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT32A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT32A;
	case MTPSPMTPT33A:
		*write_method = write_mtpSpMtpT33A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT33A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT33A;
	case MTPSPMTPT34A:
		*write_method = write_mtpSpMtpT34A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT34A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT34A;
	case MTPSPMTPT18I:
		*write_method = write_mtpSpMtpT18I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT18I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT18I;
	case MTPSPMTPT19I:
		*write_method = write_mtpSpMtpT19I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT19I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT19I;
	case MTPSPMTPT20I:
		*write_method = write_mtpSpMtpT20I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT20I;
	case MTPSPMTPT21I:
		*write_method = write_mtpSpMtpT21I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT21I;
	case MTPSPMTPT22I:
		*write_method = write_mtpSpMtpT22I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT22I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT22I;
	case MTPSPMTPT23I:
		*write_method = write_mtpSpMtpT23I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT23I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT23I;
	case MTPSPMTPT20A:
		*write_method = write_mtpSpMtpT20A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT20A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT20A;
	case MTPSPMTPT21A:
		*write_method = write_mtpSpMtpT21A;
		*var_len = sizeof(StorageTmp->mtpSpMtpT21A);
		return (uint8_t *) &StorageTmp->mtpSpMtpT21A;
	case MTPSPMTPT24I:
		*write_method = write_mtpSpMtpT24I;
		*var_len = sizeof(StorageTmp->mtpSpMtpT24I);
		return (uint8_t *) &StorageTmp->mtpSpMtpT24I;
	case MTPSPMTPT1T:
		*write_method = write_mtpSpMtpT1T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1T);
		return (uint8_t *) &StorageTmp->mtpSpMtpT1T;
	case MTPSPMTPT2T:
		*write_method = write_mtpSpMtpT2T;
		*var_len = sizeof(StorageTmp->mtpSpMtpT2T);
		return (uint8_t *) &StorageTmp->mtpSpMtpT2T;
	case MTPSPMTPT1S:
		*write_method = write_mtpSpMtpT1S;
		*var_len = sizeof(StorageTmp->mtpSpMtpT1S);
		return (uint8_t *) &StorageTmp->mtpSpMtpT1S;
	case MTPSPPROFILEPOINTER:
		*write_method = write_mtpSpProfilePointer;
		*var_len = StorageTmp->mtpSpProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpSpProfilePointer;
	case MTPSPNAPOINTER:
		*write_method = write_mtpSpNaPointer;
		*var_len = StorageTmp->mtpSpNaPointerLen;
		return (uint8_t *) StorageTmp->mtpSpNaPointer;
	case MTPSPFLAGS:
		*write_method = write_mtpSpFlags;
		*var_len = StorageTmp->mtpSpFlagsLen;
		return (uint8_t *) StorageTmp->mtpSpFlags;
	case MTPSPUSERS:
		*write_method = write_mtpSpUsers;
		*var_len = StorageTmp->mtpSpUsersLen;
		return (uint8_t *) StorageTmp->mtpSpUsers;
	case MTPSPALARMSTATUS:
		*write_method = write_mtpSpAlarmStatus;
		*var_len = StorageTmp->mtpSpAlarmStatusLen;
		return (uint8_t *) StorageTmp->mtpSpAlarmStatus;
	case MTPSPROWSTATUS:
		*write_method = write_mtpSpRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpRowStatus);
		return (uint8_t *) &StorageTmp->mtpSpRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStatsTable(): refresh mtpSpStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStatsTable(void)
{
	if (mtpSpStatsTable_refresh == 0)
		return;
	mtpSpStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStatsTable_row(): refresh mtpSpStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStatsTable_row(struct mtpSpStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSpStatsTable_request = sa_request;
}

/*
 * var_mtpSpStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTATSROWSTATUS:
		*write_method = write_mtpSpStatsRowStatus;
		*var_len = sizeof(StorageTmp->mtpSpStatsRowStatus);
		return (uint8_t *) &StorageTmp->mtpSpStatsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpCurrentTable(): refresh mtpSpCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpCurrentTable(void)
{
	if (mtpSpCurrentTable_refresh == 0)
		return;
	mtpSpCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpCurrentTable_row(): refresh mtpSpCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpCurrentTable_row(struct mtpSpCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSpCurrentTable_request = sa_request;
}

/*
 * var_mtpSpCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPCURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSpCurrentValidIntervals;
	case MTPSPCURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSpCurrentTimeDiscontinuity;
	case MTPSPCURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSpCurrentDiscardedMSUs;
	case MTPSPCURRENTRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus0);
		return (uint8_t *) &StorageTmp->mtpSpCurrentReceivedTFCstatus0;
	case MTPSPCURRENTRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus1);
		return (uint8_t *) &StorageTmp->mtpSpCurrentReceivedTFCstatus1;
	case MTPSPCURRENTRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentReceivedTFCstatus2);
		return (uint8_t *) &StorageTmp->mtpSpCurrentReceivedTFCstatus2;
	case MTPSPCURRENTOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpCurrentOctetsXferred);
		return (uint8_t *) &StorageTmp->mtpSpCurrentOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt5minTable(): refresh mtpSpInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt5minTable(void)
{
	if (mtpSpInt5minTable_refresh == 0)
		return;
	mtpSpInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpInt5minTable_row(): refresh mtpSpInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt5minTable_row(struct mtpSpInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt5minTable_request = sa_request;
}

/*
 * var_mtpSpInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpInt5minTimeStamp;
	case MTPSPINT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSpInt5minDiscardedMSUs;
	case MTPSPINT5MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus0);
		return (uint8_t *) &StorageTmp->mtpSpInt5minReceivedTFCstatus0;
	case MTPSPINT5MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus1);
		return (uint8_t *) &StorageTmp->mtpSpInt5minReceivedTFCstatus1;
	case MTPSPINT5MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minReceivedTFCstatus2);
		return (uint8_t *) &StorageTmp->mtpSpInt5minReceivedTFCstatus2;
	case MTPSPINT5MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt5minOctetsXferred);
		return (uint8_t *) &StorageTmp->mtpSpInt5minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpInt15minTable(): refresh mtpSpInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpInt15minTable(void)
{
	if (mtpSpInt15minTable_refresh == 0)
		return;
	mtpSpInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpInt15minTable_row(): refresh mtpSpInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpInt15minTable_row(struct mtpSpInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpInt15minTable_request = sa_request;
}

/*
 * var_mtpSpInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpInt15minTimeStamp;
	case MTPSPINT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSpInt15minDiscardedMSUs;
	case MTPSPINT15MINRECEIVEDTFCSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus0);
		return (uint8_t *) &StorageTmp->mtpSpInt15minReceivedTFCstatus0;
	case MTPSPINT15MINRECEIVEDTFCSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus1);
		return (uint8_t *) &StorageTmp->mtpSpInt15minReceivedTFCstatus1;
	case MTPSPINT15MINRECEIVEDTFCSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minReceivedTFCstatus2);
		return (uint8_t *) &StorageTmp->mtpSpInt15minReceivedTFCstatus2;
	case MTPSPINT15MINOCTETSXFERRED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpInt15minOctetsXferred);
		return (uint8_t *) &StorageTmp->mtpSpInt15minOctetsXferred;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiTable(): refresh mtpSpSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiTable(void)
{
	if (mtpSpSiTable_refresh == 0)
		return;
	mtpSpSiTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpSiTable_row(): refresh mtpSpSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiTable_row(struct mtpSpSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiTable_request = sa_request;
}

/*
 * var_mtpSpSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpSiTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSIVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSpSiValidIntervals;
	case MTPSPSITIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSpSiTimeDiscontinuity;
	case MTPSPSITRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiTransmittedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiTransmittedUPUnavailable;
	case MTPSPSIRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiReceivedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiReceivedUPUnavailable;
	case MTPSPSIHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiHandledOctetsSIO);
		return (uint8_t *) &StorageTmp->mtpSpSiHandledOctetsSIO;
	case MTPSPSISTATUS:
		*write_method = write_mtpSpSiStatus;
		*var_len = sizeof(StorageTmp->mtpSpSiStatus);
		return (uint8_t *) &StorageTmp->mtpSpSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt5minTable(): refresh mtpSpSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt5minTable(void)
{
	if (mtpSpSiInt5minTable_refresh == 0)
		return;
	mtpSpSiInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpSiInt5minTable_row(): refresh mtpSpSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt5minTable_row(struct mtpSpSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt5minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpSiInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minTimeStamp;
	case MTPSPSIINT5MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minTransmittedUPUnavailable;
	case MTPSPSIINT5MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minReceivedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minReceivedUPUnavailable;
	case MTPSPSIINT5MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt5minHandledOctetsSIO);
		return (uint8_t *) &StorageTmp->mtpSpSiInt5minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpSiInt15minTable(): refresh mtpSpSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpSiInt15minTable(void)
{
	if (mtpSpSiInt15minTable_refresh == 0)
		return;
	mtpSpSiInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpSiInt15minTable_row(): refresh mtpSpSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpSiInt15minTable_row(struct mtpSpSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpSiInt15minTable_request = sa_request;
}

/*
 * var_mtpSpSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpSiInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpSiInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minTimeStamp;
	case MTPSPSIINT15MINTRANSMITTEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minTransmittedUPUnavailable;
	case MTPSPSIINT15MINRECEIVEDUPUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minReceivedUPUnavailable);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minReceivedUPUnavailable;
	case MTPSPSIINT15MINHANDLEDOCTETSSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpSiInt15minHandledOctetsSIO);
		return (uint8_t *) &StorageTmp->mtpSpSiInt15minHandledOctetsSIO;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyTable(): refresh mtpSpStudyTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyTable(void)
{
	if (mtpSpStudyTable_refresh == 0)
		return;
	mtpSpStudyTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyTable_row(): refresh mtpSpStudyTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyTable_row(struct mtpSpStudyTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyTable_request = sa_request;
}

/*
 * var_mtpSpStudyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpStudyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSpStudyValidIntervals;
	case MTPSPSTUDYTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSpStudyTimeDiscontinuity;
	case MTPSPSTUDYHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyHandledOctetsOpcDpcSio;
	case MTPSPSTUDYHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyHandledMSUsOpcDpcSio;
	case MTPSPSTUDYSTATUS:
		*write_method = write_mtpSpStudyStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyStatus);
		return (uint8_t *) &StorageTmp->mtpSpStudyStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt5minTable(): refresh mtpSpStudyInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt5minTable(void)
{
	if (mtpSpStudyInt5minTable_refresh == 0)
		return;
	mtpSpStudyInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyInt5minTable_row(): refresh mtpSpStudyInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt5minTable_row(struct mtpSpStudyInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt5minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpStudyInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt5minTimeStamp;
	case MTPSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt5minHandledOctetsOpcDpcSio;
	case MTPSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt5minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyInt15minTable(): refresh mtpSpStudyInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyInt15minTable(void)
{
	if (mtpSpStudyInt15minTable_refresh == 0)
		return;
	mtpSpStudyInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyInt15minTable_row(): refresh mtpSpStudyInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyInt15minTable_row(struct mtpSpStudyInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyInt15minTable_request = sa_request;
}

/*
 * var_mtpSpStudyInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpStudyInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYINT15MININTERVAL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minInterval);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt15minInterval;
	case MTPSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt15minHandledOctetsOpcDpcSio;
	case MTPSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio);
		return (uint8_t *) &StorageTmp->mtpSpStudyInt15minHandledMSUsOpcDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSpStudyMapTable(): refresh mtpSpStudyMapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSpStudyMapTable(void)
{
	if (mtpSpStudyMapTable_refresh == 0)
		return;
	mtpSpStudyMapTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSpStudyMapTable_row(): refresh mtpSpStudyMapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSpStudyMapTable_row(struct mtpSpStudyMapTable_data *StorageTmp)
{
	if (StorageTmp->mtpSpStudyMapTable_request == sa_request)
		return;
	StorageTmp->mtpSpStudyMapTable_request = sa_request;
}

/*
 * var_mtpSpStudyMapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSpStudyMapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpStudyMapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSpStudyMapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSpStudyMapTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSpStudyMapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSpStudyMapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSPSTUDYMAPSTATUS:
		*write_method = write_mtpSpStudyMapStatus;
		*var_len = sizeof(StorageTmp->mtpSpStudyMapStatus);
		return (uint8_t *) &StorageTmp->mtpSpStudyMapStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpL3Table(): refresh mtpL3Table
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpL3Table(void)
{
	if (mtpL3Table_refresh == 0)
		return;
	mtpL3Table_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpL3Table_row(): refresh mtpL3Table row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	if (StorageTmp->mtpL3Table_request == sa_request)
		return;
	StorageTmp->mtpL3Table_request = sa_request;
}

/*
 * var_mtpL3Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpL3Table_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpL3Table();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpL3TableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpL3Table_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPL3ADMINISTRATIVESTATE:
		*write_method = write_mtpL3AdministrativeState;
		*var_len = sizeof(StorageTmp->mtpL3AdministrativeState);
		return (uint8_t *) &StorageTmp->mtpL3AdministrativeState;
	case MTPL3OPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3OperationalState);
		return (uint8_t *) &StorageTmp->mtpL3OperationalState;
	case MTPL3USAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpL3UsageState);
		return (uint8_t *) &StorageTmp->mtpL3UsageState;
	case MTPL3PROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpL3ProceduralStatusLen;
		return (uint8_t *) StorageTmp->mtpL3ProceduralStatus;
	case MTPL3ASAPROFILEPOINTER:
		*write_method = write_mtpL3AsaProfilePointer;
		*var_len = StorageTmp->mtpL3AsaProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpL3AsaProfilePointer;
	case MTPL3NAME:
		*write_method = write_mtpL3Name;
		*var_len = StorageTmp->mtpL3NameLen;
		return (uint8_t *) StorageTmp->mtpL3Name;
	case MTPL3ROWSTATUS:
		*write_method = write_mtpL3RowStatus;
		*var_len = sizeof(StorageTmp->mtpL3RowStatus);
		return (uint8_t *) &StorageTmp->mtpL3RowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsProfileTable(): refresh mtpRsProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsProfileTable(void)
{
	if (mtpRsProfileTable_refresh == 0)
		return;
	mtpRsProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsProfileTable_row(): refresh mtpRsProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRsProfileTable_request = sa_request;
}

/*
 * var_mtpRsProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSPROFILENAME:
		*write_method = write_mtpRsProfileName;
		*var_len = StorageTmp->mtpRsProfileNameLen;
		return (uint8_t *) StorageTmp->mtpRsProfileName;
	case MTPRSPROFILETIMERT8:
		*write_method = write_mtpRsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT8);
		return (uint8_t *) &StorageTmp->mtpRsProfileTimerT8;
	case MTPRSPROFILETIMERT11:
		*write_method = write_mtpRsProfileTimerT11;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT11);
		return (uint8_t *) &StorageTmp->mtpRsProfileTimerT11;
	case MTPRSPROFILETIMERT15:
		*write_method = write_mtpRsProfileTimerT15;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT15);
		return (uint8_t *) &StorageTmp->mtpRsProfileTimerT15;
	case MTPRSPROFILETIMERT16:
		*write_method = write_mtpRsProfileTimerT16;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT16);
		return (uint8_t *) &StorageTmp->mtpRsProfileTimerT16;
	case MTPRSPROFILETIMERT18A:
		*write_method = write_mtpRsProfileTimerT18A;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT18A);
		return (uint8_t *) &StorageTmp->mtpRsProfileTimerT18A;
	case MTPRSPROFILERTDEFAULT:
		*write_method = write_mtpRsProfileRtDefault;
		*var_len = StorageTmp->mtpRsProfileRtDefaultLen;
		return (uint8_t *) StorageTmp->mtpRsProfileRtDefault;
	case MTPRSPROFILEROWSTATUS:
		*write_method = write_mtpRsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsProfileRowStatus);
		return (uint8_t *) &StorageTmp->mtpRsProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsTable(): refresh mtpRsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(void)
{
	if (mtpRsTable_refresh == 0)
		return;
	mtpRsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsTable_row(): refresh mtpRsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsTable_request == sa_request)
		return;
	StorageTmp->mtpRsTable_request = sa_request;
}

/*
 * var_mtpRsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSDEST:
		*write_method = write_mtpRsDest;
		*var_len = StorageTmp->mtpRsDestLen;
		return (uint8_t *) StorageTmp->mtpRsDest;
	case MTPRSFLAGS:
		*write_method = write_mtpRsFlags;
		*var_len = StorageTmp->mtpRsFlagsLen;
		return (uint8_t *) StorageTmp->mtpRsFlags;
	case MTPRSADMINISTRATIVESTATE:
		*write_method = write_mtpRsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		return (uint8_t *) &StorageTmp->mtpRsAdministrativeState;
	case MTPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		return (uint8_t *) &StorageTmp->mtpRsOperationalState;
	case MTPRSASAPROFILEPOINTER:
		*write_method = write_mtpRsAsaProfilePointer;
		*var_len = StorageTmp->mtpRsAsaProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpRsAsaProfilePointer;
	case MTPRSCONGESTEDSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestedState);
		return (uint8_t *) &StorageTmp->mtpRsCongestedState;
	case MTPRSCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsCongestionLevel);
		return (uint8_t *) &StorageTmp->mtpRsCongestionLevel;
	case MTPRSLOADSHARINGINFORMATION:
		*write_method = write_mtpRsLoadsharingInformation;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		return (uint8_t *) StorageTmp->mtpRsLoadsharingInformation;
	case MTPRSLOADSHARINGOBJECT:
		*write_method = write_mtpRsLoadsharingObject;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen;
		return (uint8_t *) StorageTmp->mtpRsLoadsharingObject;
	case MTPRSREMOTEEXCHANGELABEL:
		*write_method = write_mtpRsRemoteExchangeLabel;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		return (uint8_t *) StorageTmp->mtpRsRemoteExchangeLabel;
	case MTPRSNAME:
		*write_method = write_mtpRsName;
		*var_len = StorageTmp->mtpRsNameLen;
		return (uint8_t *) StorageTmp->mtpRsName;
	case MTPRSPROFILE:
		*write_method = write_mtpRsProfile;
		*var_len = StorageTmp->mtpRsProfileLen;
		return (uint8_t *) StorageTmp->mtpRsProfile;
	case MTPRSALARMSTATUS:
		*write_method = write_mtpRsAlarmStatus;
		*var_len = StorageTmp->mtpRsAlarmStatusLen;
		return (uint8_t *) StorageTmp->mtpRsAlarmStatus;
	case MTPRSROWSTATUS:
		*write_method = write_mtpRsRowStatus;
		*var_len = sizeof(StorageTmp->mtpRsRowStatus);
		return (uint8_t *) &StorageTmp->mtpRsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsStatsTable(): refresh mtpRsStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsStatsTable(void)
{
	if (mtpRsStatsTable_refresh == 0)
		return;
	mtpRsStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsStatsTable_row(): refresh mtpRsStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsStatsTable_row(struct mtpRsStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsStatsTable_request == sa_request)
		return;
	StorageTmp->mtpRsStatsTable_request = sa_request;
}

/*
 * var_mtpRsStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSTATSSTATUS:
		*write_method = write_mtpRsStatsStatus;
		*var_len = sizeof(StorageTmp->mtpRsStatsStatus);
		return (uint8_t *) &StorageTmp->mtpRsStatsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsCurrentTable(): refresh mtpRsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsCurrentTable(void)
{
	if (mtpRsCurrentTable_refresh == 0)
		return;
	mtpRsCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsCurrentTable_row(): refresh mtpRsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsCurrentTable_row(struct mtpRsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpRsCurrentTable_request = sa_request;
}

/*
 * var_mtpRsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSCURRENTVALIDINTERVALS:
		*write_method = write_mtpRsCurrentValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsCurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpRsCurrentValidIntervals;
	case MTPRSCURRENTTIMEDISCONTINUITY:
		*write_method = write_mtpRsCurrentTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpRsCurrentTimeDiscontinuity;
	case MTPRSCURRENTRECEIVEDOCTETSOPC:
		*write_method = write_mtpRsCurrentReceivedOctetsOPC;
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedOctetsOPC);
		return (uint8_t *) &StorageTmp->mtpRsCurrentReceivedOctetsOPC;
	case MTPRSCURRENTTRANSMITTEDOCTETSDPC:
		*write_method = write_mtpRsCurrentTransmittedOctetsDPC;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedOctetsDPC);
		return (uint8_t *) &StorageTmp->mtpRsCurrentTransmittedOctetsDPC;
	case MTPRSCURRENTRECEIVEDMSUSOPC:
		*write_method = write_mtpRsCurrentReceivedMSUsOpc;
		*var_len = sizeof(StorageTmp->mtpRsCurrentReceivedMSUsOpc);
		return (uint8_t *) &StorageTmp->mtpRsCurrentReceivedMSUsOpc;
	case MTPRSCURRENTTRANSMITTEDMSUSDPC:
		*write_method = write_mtpRsCurrentTransmittedMSUsDpc;
		*var_len = sizeof(StorageTmp->mtpRsCurrentTransmittedMSUsDpc);
		return (uint8_t *) &StorageTmp->mtpRsCurrentTransmittedMSUsDpc;
	case MTPRSCURRENTROUTESETUNAVAILABLE:
		*write_method = write_mtpRsCurrentRouteSetUnavailable;
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailable);
		return (uint8_t *) &StorageTmp->mtpRsCurrentRouteSetUnavailable;
	case MTPRSCURRENTROUTESETUNAVAILABLEDURATION:
		*write_method = write_mtpRsCurrentRouteSetUnavailableDuration;
		*var_len = sizeof(StorageTmp->mtpRsCurrentRouteSetUnavailableDuration);
		return (uint8_t *) &StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt5minTable(): refresh mtpRsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt5minTable(void)
{
	if (mtpRsInt5minTable_refresh == 0)
		return;
	mtpRsInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsInt5minTable_row(): refresh mtpRsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt5minTable_row(struct mtpRsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt5minTable_request = sa_request;
}

/*
 * var_mtpRsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsInt5minTimeStamp;
	case MTPRSINT5MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedOctetsOPC);
		return (uint8_t *) &StorageTmp->mtpRsInt5minReceivedOctetsOPC;
	case MTPRSINT5MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedOctetsDPC);
		return (uint8_t *) &StorageTmp->mtpRsInt5minTransmittedOctetsDPC;
	case MTPRSINT5MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minReceivedMSUsOpc);
		return (uint8_t *) &StorageTmp->mtpRsInt5minReceivedMSUsOpc;
	case MTPRSINT5MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minTransmittedMSUsDpc);
		return (uint8_t *) &StorageTmp->mtpRsInt5minTransmittedMSUsDpc;
	case MTPRSINT5MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailable);
		return (uint8_t *) &StorageTmp->mtpRsInt5minRouteSetUnavailable;
	case MTPRSINT5MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt5minRouteSetUnavailableDuration);
		return (uint8_t *) &StorageTmp->mtpRsInt5minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsInt15minTable(): refresh mtpRsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsInt15minTable(void)
{
	if (mtpRsInt15minTable_refresh == 0)
		return;
	mtpRsInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsInt15minTable_row(): refresh mtpRsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsInt15minTable_row(struct mtpRsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsInt15minTable_request = sa_request;
}

/*
 * var_mtpRsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsInt15minTimeStamp;
	case MTPRSINT15MINRECEIVEDOCTETSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedOctetsOPC);
		return (uint8_t *) &StorageTmp->mtpRsInt15minReceivedOctetsOPC;
	case MTPRSINT15MINTRANSMITTEDOCTETSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedOctetsDPC);
		return (uint8_t *) &StorageTmp->mtpRsInt15minTransmittedOctetsDPC;
	case MTPRSINT15MINRECEIVEDMSUSOPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minReceivedMSUsOpc);
		return (uint8_t *) &StorageTmp->mtpRsInt15minReceivedMSUsOpc;
	case MTPRSINT15MINTRANSMITTEDMSUSDPC:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minTransmittedMSUsDpc);
		return (uint8_t *) &StorageTmp->mtpRsInt15minTransmittedMSUsDpc;
	case MTPRSINT15MINROUTESETUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailable);
		return (uint8_t *) &StorageTmp->mtpRsInt15minRouteSetUnavailable;
	case MTPRSINT15MINROUTESETUNAVAILABLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsInt15minRouteSetUnavailableDuration);
		return (uint8_t *) &StorageTmp->mtpRsInt15minRouteSetUnavailableDuration;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiTable(): refresh mtpRsSiTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiTable(void)
{
	if (mtpRsSiTable_refresh == 0)
		return;
	mtpRsSiTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsSiTable_row(): refresh mtpRsSiTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiTable_row(struct mtpRsSiTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiTable_request = sa_request;
}

/*
 * var_mtpRsSiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsSiTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsSiTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSIVALIDINTERVALS:
		*write_method = write_mtpRsSiValidIntervals;
		*var_len = sizeof(StorageTmp->mtpRsSiValidIntervals);
		return (uint8_t *) &StorageTmp->mtpRsSiValidIntervals;
	case MTPRSSITIMEDISCONTINUITY:
		*write_method = write_mtpRsSiTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpRsSiTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpRsSiTimeDiscontinuity;
	case MTPRSSIRECEIVEDOCTETSOPCSIO:
		*write_method = write_mtpRsSiReceivedOctetsOpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedOctetsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiReceivedOctetsOpcSio;
	case MTPRSSITRANSMITTEDOCTETSDPCSIO:
		*write_method = write_mtpRsSiTransmittedOctetsDpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedOctetsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiTransmittedOctetsDpcSio;
	case MTPRSSIRECEIVEDMSUSOPCSIO:
		*write_method = write_mtpRsSiReceivedMSUsOpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiReceivedMSUsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiReceivedMSUsOpcSio;
	case MTPRSSITRANSMITTEDMSUSDPCSIO:
		*write_method = write_mtpRsSiTransmittedMSUsDpcSio;
		*var_len = sizeof(StorageTmp->mtpRsSiTransmittedMSUsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiTransmittedMSUsDpcSio;
	case MTPRSSISTATUS:
		*write_method = write_mtpRsSiStatus;
		*var_len = sizeof(StorageTmp->mtpRsSiStatus);
		return (uint8_t *) &StorageTmp->mtpRsSiStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt5minTable(): refresh mtpRsSiInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt5minTable(void)
{
	if (mtpRsSiInt5minTable_refresh == 0)
		return;
	mtpRsSiInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsSiInt5minTable_row(): refresh mtpRsSiInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt5minTable_row(struct mtpRsSiInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt5minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsSiInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsSiInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTimeStamp;
	case MTPRSSIINT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTimeStamp;
	case MTPRSSIINT5MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTransmittedOctetsDpcSio;
	case MTPRSSIINT5MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minReceivedMSUsOpcSio;
	case MTPRSSIINT5MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt5minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRsSiInt15minTable(): refresh mtpRsSiInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRsSiInt15minTable(void)
{
	if (mtpRsSiInt15minTable_refresh == 0)
		return;
	mtpRsSiInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRsSiInt15minTable_row(): refresh mtpRsSiInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRsSiInt15minTable_row(struct mtpRsSiInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpRsSiInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpRsSiInt15minTable_request = sa_request;
}

/*
 * var_mtpRsSiInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRsSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsSiInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRsSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRsSiInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRsSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRsSiInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRSSIINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minTimeStamp;
	case MTPRSSIINT15MINRECEIVEDOCTETSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minReceivedOctetsOpcSio;
	case MTPRSSIINT15MINTRANSMITTEDOCTETSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minTransmittedOctetsDpcSio;
	case MTPRSSIINT15MINRECEIVEDMSUSOPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minReceivedMSUsOpcSio;
	case MTPRSSIINT15MINTRANSMITTEDMSUSDPCSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio);
		return (uint8_t *) &StorageTmp->mtpRsSiInt15minTransmittedMSUsDpcSio;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtProfileTable(): refresh mtpRtProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtProfileTable(void)
{
	if (mtpRtProfileTable_refresh == 0)
		return;
	mtpRtProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRtProfileTable_row(): refresh mtpRtProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtProfileTable_request == sa_request)
		return;
	StorageTmp->mtpRtProfileTable_request = sa_request;
}

/*
 * var_mtpRtProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRtProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRtProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRTPROFILETIMERT6:
		*write_method = write_mtpRtProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT6);
		return (uint8_t *) &StorageTmp->mtpRtProfileTimerT6;
	case MTPRTPROFILETIMERT10:
		*write_method = write_mtpRtProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT10);
		return (uint8_t *) &StorageTmp->mtpRtProfileTimerT10;
	case MTPRTPROFILEROWSTATUS:
		*write_method = write_mtpRtProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtProfileRowStatus);
		return (uint8_t *) &StorageTmp->mtpRtProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtTable(): refresh mtpRtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(void)
{
	if (mtpRtTable_refresh == 0)
		return;
	mtpRtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRtTable_row(): refresh mtpRtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtTable_request == sa_request)
		return;
	StorageTmp->mtpRtTable_request = sa_request;
}

/*
 * var_mtpRtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRTLSPOINTER:
		*write_method = write_mtpRtLsPointer;
		*var_len = StorageTmp->mtpRtLsPointerLen;
		return (uint8_t *) StorageTmp->mtpRtLsPointer;
	case MTPRTADMINISTRATIVESTATE:
		*write_method = write_mtpRtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		return (uint8_t *) &StorageTmp->mtpRtAdministrativeState;
	case MTPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		return (uint8_t *) &StorageTmp->mtpRtOperationalState;
	case MTPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->mtpRtAvailabilityStatus;
	case MTPRTINCLSLOADSHARINGALGORITHM:
		*write_method = write_mtpRtInClsLoadsharingAlgorithm;
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		return (uint8_t *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;
	case MTPRTFIXEDPRIORITY:
		*write_method = write_mtpRtFixedPriority;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		return (uint8_t *) &StorageTmp->mtpRtFixedPriority;
	case MTPRTFLEXIBLEPRIORITY:
		*write_method = write_mtpRtFlexiblePriority;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		return (uint8_t *) &StorageTmp->mtpRtFlexiblePriority;
	case MTPRTPRIORITYMODE:
		*write_method = write_mtpRtPriorityMode;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		return (uint8_t *) &StorageTmp->mtpRtPriorityMode;
	case MTPRTLOADSHARINGINFORMATION:
		*write_method = write_mtpRtLoadsharingInformation;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		return (uint8_t *) StorageTmp->mtpRtLoadsharingInformation;
	case MTPRTLOADSHARINGOBJECT:
		*write_method = write_mtpRtLoadsharingObject;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen;
		return (uint8_t *) StorageTmp->mtpRtLoadsharingObject;
	case MTPRTNAME:
		*write_method = write_mtpRtName;
		*var_len = StorageTmp->mtpRtNameLen;
		return (uint8_t *) StorageTmp->mtpRtName;
	case MTPRTSLSLIST:
		*write_method = write_mtpRtSlsList;
		*var_len = StorageTmp->mtpRtSlsListLen;
		return (uint8_t *) StorageTmp->mtpRtSlsList;
	case MTPRTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		return (uint8_t *) &StorageTmp->mtpRtUsageState;
	case MTPRTRLSLOT:
		*write_method = write_mtpRtRlSlot;
		*var_len = sizeof(StorageTmp->mtpRtRlSlot);
		return (uint8_t *) &StorageTmp->mtpRtRlSlot;
	case MTPRTPROFILE:
		*write_method = write_mtpRtProfile;
		*var_len = StorageTmp->mtpRtProfileLen;
		return (uint8_t *) StorageTmp->mtpRtProfile;
	case MTPRTROWSTATUS:
		*write_method = write_mtpRtRowStatus;
		*var_len = sizeof(StorageTmp->mtpRtRowStatus);
		return (uint8_t *) &StorageTmp->mtpRtRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpRtLsaTable(): refresh mtpRtLsaTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpRtLsaTable(void)
{
	if (mtpRtLsaTable_refresh == 0)
		return;
	mtpRtLsaTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpRtLsaTable_row(): refresh mtpRtLsaTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp)
{
	if (StorageTmp->mtpRtLsaTable_request == sa_request)
		return;
	StorageTmp->mtpRtLsaTable_request = sa_request;
}

/*
 * var_mtpRtLsaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpRtLsaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpRtLsaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpRtLsaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpRtLsaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPRTLSANORMALSLCODE:
		*write_method = write_mtpRtLsaNormalSlCode;
		*var_len = sizeof(StorageTmp->mtpRtLsaNormalSlCode);
		return (uint8_t *) &StorageTmp->mtpRtLsaNormalSlCode;
	case MTPRTLSAALTERNATIVESLCODELIST:
		*write_method = write_mtpRtLsaAlternativeSlCodeList;
		*var_len = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		return (uint8_t *) StorageTmp->mtpRtLsaAlternativeSlCodeList;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsProfileTable(): refresh mtpLsProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsProfileTable(void)
{
	if (mtpLsProfileTable_refresh == 0)
		return;
	mtpLsProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsProfileTable_row(): refresh mtpLsProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsProfileTable_request == sa_request)
		return;
	StorageTmp->mtpLsProfileTable_request = sa_request;
}

/*
 * var_mtpLsProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpLsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSPROFILETIMERT6:
		*write_method = write_mtpLsProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT6);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT6;
	case MTPLSPROFILETIMERT8:
		*write_method = write_mtpLsProfileTimerT8;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT8);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT8;
	case MTPLSPROFILETIMERT10:
		*write_method = write_mtpLsProfileTimerT10;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT10);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT10;
	case MTPLSPROFILETIMERT7:
		*write_method = write_mtpLsProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT7);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT7;
	case MTPLSPROFILETIMERT19I:
		*write_method = write_mtpLsProfileTimerT19I;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT19I);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT19I;
	case MTPLSPROFILETIMERT21I:
		*write_method = write_mtpLsProfileTimerT21I;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT21I);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT21I;
	case MTPLSPROFILETIMERT25A:
		*write_method = write_mtpLsProfileTimerT25A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT25A);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT25A;
	case MTPLSPROFILETIMERT28A:
		*write_method = write_mtpLsProfileTimerT28A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT28A);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT28A;
	case MTPLSPROFILETIMERT29A:
		*write_method = write_mtpLsProfileTimerT29A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT29A);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT29A;
	case MTPLSPROFILETIMERT30A:
		*write_method = write_mtpLsProfileTimerT30A;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT30A);
		return (uint8_t *) &StorageTmp->mtpLsProfileTimerT30A;
	case MTPLSPROFILENAME:
		*write_method = write_mtpLsProfileName;
		*var_len = StorageTmp->mtpLsProfileNameLen;
		return (uint8_t *) StorageTmp->mtpLsProfileName;
	case MTPLSPROFILESLDEFAULT:
		*write_method = write_mtpLsProfileSlDefault;
		*var_len = StorageTmp->mtpLsProfileSlDefaultLen;
		return (uint8_t *) StorageTmp->mtpLsProfileSlDefault;
	case MTPLSPROFILEROWSTATUS:
		*write_method = write_mtpLsProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsProfileRowStatus);
		return (uint8_t *) &StorageTmp->mtpLsProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsTable(): refresh mtpLsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(void)
{
	if (mtpLsTable_refresh == 0)
		return;
	mtpLsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsTable_row(): refresh mtpLsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsTable_request == sa_request)
		return;
	StorageTmp->mtpLsTable_request = sa_request;
}

/*
 * var_mtpLsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSADJPC:
		*write_method = write_mtpLsAdjPc;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		return (uint8_t *) StorageTmp->mtpLsAdjPc;
	case MTPLSRSID:
		*write_method = write_mtpLsRsId;
		*var_len = StorageTmp->mtpLsRsIdLen;
		return (uint8_t *) StorageTmp->mtpLsRsId;
	case MTPLSMAXCAPACITY:
		*write_method = write_mtpLsMaxCapacity;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		return (uint8_t *) &StorageTmp->mtpLsMaxCapacity;
	case MTPLSCURRENTCAPACITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		return (uint8_t *) &StorageTmp->mtpLsCurrentCapacity;
	case MTPLSCONGESTIONCONTROLMETHOD:
		*write_method = write_mtpLsCongestionControlMethod;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		return (uint8_t *) &StorageTmp->mtpLsCongestionControlMethod;
	case MTPLSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		return (uint8_t *) &StorageTmp->mtpLsUsageState;
	case MTPLSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		return (uint8_t *) &StorageTmp->mtpLsOperationalState;
	case MTPLSAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->mtpLsAvailabilityStatus;
	case MTPLSPERIODICLINKTESTFLAG:
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		return (uint8_t *) &StorageTmp->mtpLsPeriodicLinkTestFlag;
	case MTPLSPERIODICLINKTESTFAIL:
		*write_method = write_mtpLsPeriodicLinkTestFail;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFail);
		return (uint8_t *) &StorageTmp->mtpLsPeriodicLinkTestFail;
	case MTPLSADMINISTRATIVESTATE:
		*write_method = write_mtpLsAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		return (uint8_t *) &StorageTmp->mtpLsAdministrativeState;
	case MTPLSINLSLOADSHAREALGORITHM:
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		return (uint8_t *) StorageTmp->mtpLsInLsLoadShareAlgorithm;
	case MTPLSPROFILEPOINTER:
		*write_method = write_mtpLsProfilePointer;
		*var_len = StorageTmp->mtpLsProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpLsProfilePointer;
	case MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS:
		*write_method = write_mtpLsNumberOfNormallyActiveSignLinks;
		*var_len = sizeof(StorageTmp->mtpLsNumberOfNormallyActiveSignLinks);
		return (uint8_t *) &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
	case MTPLSNAME:
		*write_method = write_mtpLsName;
		*var_len = StorageTmp->mtpLsNameLen;
		return (uint8_t *) StorageTmp->mtpLsName;
	case MTPLSASAPROFILEPOINTER:
		*write_method = write_mtpLsAsaProfilePointer;
		*var_len = StorageTmp->mtpLsAsaProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpLsAsaProfilePointer;
	case MTPLSALARMSTATUS:
		*write_method = write_mtpLsAlarmStatus;
		*var_len = StorageTmp->mtpLsAlarmStatusLen;
		return (uint8_t *) StorageTmp->mtpLsAlarmStatus;
	case MTPLSROWSTATUS:
		*write_method = write_mtpLsRowStatus;
		*var_len = sizeof(StorageTmp->mtpLsRowStatus);
		return (uint8_t *) &StorageTmp->mtpLsRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsStatsTable(): refresh mtpLsStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsStatsTable(void)
{
	if (mtpLsStatsTable_refresh == 0)
		return;
	mtpLsStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsStatsTable_row(): refresh mtpLsStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsStatsTable_row(struct mtpLsStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsStatsTable_request == sa_request)
		return;
	StorageTmp->mtpLsStatsTable_request = sa_request;
}

/*
 * var_mtpLsStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpLsStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSSTATSSTATUS:
		*write_method = write_mtpLsStatsStatus;
		*var_len = sizeof(StorageTmp->mtpLsStatsStatus);
		return (uint8_t *) &StorageTmp->mtpLsStatsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsCurrentTable(): refresh mtpLsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsCurrentTable(void)
{
	if (mtpLsCurrentTable_refresh == 0)
		return;
	mtpLsCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsCurrentTable_row(): refresh mtpLsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsCurrentTable_row(struct mtpLsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsCurrentTable_request == sa_request)
		return;
	StorageTmp->mtpLsCurrentTable_request = sa_request;
}

/*
 * var_mtpLsCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpLsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSCURRENTVALIDINTERVALS:
		*write_method = write_mtpLsCurrentValidIntervals;
		*var_len = sizeof(StorageTmp->mtpLsCurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpLsCurrentValidIntervals;
	case MTPLSCURRENTTIMEDISCONTINUITY:
		*write_method = write_mtpLsCurrentTimeDiscontinuity;
		*var_len = sizeof(StorageTmp->mtpLsCurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpLsCurrentTimeDiscontinuity;
	case MTPLSCURRENTADJACENTINACCESSIBLEEVENTS:
		*write_method = write_mtpLsCurrentAdjacentInaccessibleEvents;
		*var_len = sizeof(StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents);
		return (uint8_t *) &StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents;
	case MTPLSCURRENTADJACENTINACCESSIBLEDURATION:
		*write_method = write_mtpLsCurrentAdjacentInaccessibleDuration;
		*var_len = sizeof(StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration);
		return (uint8_t *) &StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration;
	case MTPLSCURRENTSLSUNAVAILABLE:
		*write_method = write_mtpLsCurrentSlsUnavailable;
		*var_len = sizeof(StorageTmp->mtpLsCurrentSlsUnavailable);
		return (uint8_t *) &StorageTmp->mtpLsCurrentSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsInt5minTable(): refresh mtpLsInt5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsInt5minTable(void)
{
	if (mtpLsInt5minTable_refresh == 0)
		return;
	mtpLsInt5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsInt5minTable_row(): refresh mtpLsInt5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsInt5minTable_row(struct mtpLsInt5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsInt5minTable_request == sa_request)
		return;
	StorageTmp->mtpLsInt5minTable_request = sa_request;
}

/*
 * var_mtpLsInt5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpLsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsInt5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsInt5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsInt5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsInt5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpLsInt15minTable(): refresh mtpLsInt15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpLsInt15minTable(void)
{
	if (mtpLsInt15minTable_refresh == 0)
		return;
	mtpLsInt15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpLsInt15minTable_row(): refresh mtpLsInt15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpLsInt15minTable_row(struct mtpLsInt15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpLsInt15minTable_request == sa_request)
		return;
	StorageTmp->mtpLsInt15minTable_request = sa_request;
}

/*
 * var_mtpLsInt15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpLsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsInt15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpLsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpLsInt15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpLsInt15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpLsInt15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPLSINT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpLsInt15minTimeStamp;
	case MTPLSINT15MINADJACENTINACCESSIBLEEVENTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents);
		return (uint8_t *) &StorageTmp->mtpLsInt15minAdjacentInaccessibleEvents;
	case MTPLSINT15MINADJACENTINACCESSIBLEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration);
		return (uint8_t *) &StorageTmp->mtpLsInt15minAdjacentInaccessibleDuration;
	case MTPLSINT15MINSLSUNAVAILABLE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpLsInt15minSlsUnavailable);
		return (uint8_t *) &StorageTmp->mtpLsInt15minSlsUnavailable;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3ProfileTable(): refresh mtpSlL3ProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3ProfileTable(void)
{
	if (mtpSlL3ProfileTable_refresh == 0)
		return;
	mtpSlL3ProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3ProfileTable_row(): refresh mtpSlL3ProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3ProfileTable_request = sa_request;
}

/*
 * var_mtpSlL3ProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL3ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL3ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3ProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3ProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3PROFILETIMERT1:
		*write_method = write_mtpSlL3ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT1;
	case MTPSLL3PROFILETIMERT3:
		*write_method = write_mtpSlL3ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT3);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT3;
	case MTPSLL3PROFILETIMERT17:
		*write_method = write_mtpSlL3ProfileTimerT17;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT17);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT17;
	case MTPSLL3PROFILETIMERT24I:
		*write_method = write_mtpSlL3ProfileTimerT24I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT24I);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT24I;
	case MTPSLL3PROFILENAME:
		*write_method = write_mtpSlL3ProfileName;
		*var_len = StorageTmp->mtpSlL3ProfileNameLen;
		return (uint8_t *) StorageTmp->mtpSlL3ProfileName;
	case MTPSLL3PROFILETIMERT2:
		*write_method = write_mtpSlL3ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT2;
	case MTPSLL3PROFILETIMERT4:
		*write_method = write_mtpSlL3ProfileTimerT4;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT4);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT4;
	case MTPSLL3PROFILETIMERT5:
		*write_method = write_mtpSlL3ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT5);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT5;
	case MTPSLL3PROFILETIMERT12:
		*write_method = write_mtpSlL3ProfileTimerT12;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT12);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT12;
	case MTPSLL3PROFILETIMERT13:
		*write_method = write_mtpSlL3ProfileTimerT13;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT13);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT13;
	case MTPSLL3PROFILETIMERT14:
		*write_method = write_mtpSlL3ProfileTimerT14;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT14);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT14;
	case MTPSLL3PROFILETIMERT19A:
		*write_method = write_mtpSlL3ProfileTimerT19A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT19A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT19A;
	case MTPSLL3PROFILETIMERT20A:
		*write_method = write_mtpSlL3ProfileTimerT20A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT20A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT20A;
	case MTPSLL3PROFILETIMERT21A:
		*write_method = write_mtpSlL3ProfileTimerT21A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT21A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT21A;
	case MTPSLL3PROFILETIMERT22I:
		*write_method = write_mtpSlL3ProfileTimerT22I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT22I);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT22I;
	case MTPSLL3PROFILETIMERT23I:
		*write_method = write_mtpSlL3ProfileTimerT23I;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT23I);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT23I;
	case MTPSLL3PROFILETIMERT31A:
		*write_method = write_mtpSlL3ProfileTimerT31A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT31A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT31A;
	case MTPSLL3PROFILETIMERT32A:
		*write_method = write_mtpSlL3ProfileTimerT32A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT32A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT32A;
	case MTPSLL3PROFILETIMERT33A:
		*write_method = write_mtpSlL3ProfileTimerT33A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT33A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT33A;
	case MTPSLL3PROFILETIMERT34A:
		*write_method = write_mtpSlL3ProfileTimerT34A;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT34A);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT34A;
	case MTPSLL3PROFILETIMERT1T:
		*write_method = write_mtpSlL3ProfileTimerT1T;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1T);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT1T;
	case MTPSLL3PROFILETIMERT2T:
		*write_method = write_mtpSlL3ProfileTimerT2T;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2T);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT2T;
	case MTPSLL3PROFILETIMERT1S:
		*write_method = write_mtpSlL3ProfileTimerT1S;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1S);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileTimerT1S;
	case MTPSLL3PROFILEL2DEFAULT:
		*write_method = write_mtpSlL3ProfileL2Default;
		*var_len = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		return (uint8_t *) StorageTmp->mtpSlL3ProfileL2Default;
	case MTPSLL3PROFILEROWSTATUS:
		*write_method = write_mtpSlL3ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileRowStatus);
		return (uint8_t *) &StorageTmp->mtpSlL3ProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2ProfileTable(): refresh mtpSlL2ProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2ProfileTable(void)
{
	if (mtpSlL2ProfileTable_refresh == 0)
		return;
	mtpSlL2ProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2ProfileTable_row(): refresh mtpSlL2ProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2ProfileTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2ProfileTable_request = sa_request;
}

/*
 * var_mtpSlL2ProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL2ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2ProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2ProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2PROFILEERRORCORRECTIONMETHOD:
		*write_method = write_mtpSlL2ProfileErrorCorrectionMethod;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileErrorCorrectionMethod);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
	case MTPSLL2PROFILETRANSMISSIONRATE:
		*write_method = write_mtpSlL2ProfileTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTransmissionRate);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTransmissionRate;
	case MTPSLL2PROFILETIMERT1:
		*write_method = write_mtpSlL2ProfileTimerT1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT1);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT1;
	case MTPSLL2PROFILETIMERT2:
		*write_method = write_mtpSlL2ProfileTimerT2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT2;
	case MTPSLL2PROFILETIMERT2L:
		*write_method = write_mtpSlL2ProfileTimerT2L;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2L);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT2L;
	case MTPSLL2PROFILETIMERT2H:
		*write_method = write_mtpSlL2ProfileTimerT2H;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2H);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT2H;
	case MTPSLL2PROFILETIMERT3:
		*write_method = write_mtpSlL2ProfileTimerT3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT3);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT3;
	case MTPSLL2PROFILETIMERT4N:
		*write_method = write_mtpSlL2ProfileTimerT4N;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4N);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT4N;
	case MTPSLL2PROFILETIMERT4E:
		*write_method = write_mtpSlL2ProfileTimerT4E;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4E);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT4E;
	case MTPSLL2PROFILETIMERT5:
		*write_method = write_mtpSlL2ProfileTimerT5;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT5);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT5;
	case MTPSLL2PROFILETIMERT6:
		*write_method = write_mtpSlL2ProfileTimerT6;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT6);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT6;
	case MTPSLL2PROFILETIMERT7:
		*write_method = write_mtpSlL2ProfileTimerT7;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT7);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerT7;
	case MTPSLL2PROFILETBONSET1:
		*write_method = write_mtpSlL2ProfileTbOnset1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset1);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbOnset1;
	case MTPSLL2PROFILETBABATE1:
		*write_method = write_mtpSlL2ProfileTbAbate1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate1);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbAbate1;
	case MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS:
		*write_method = write_mtpSlL2ProfileNumberOfThresholdLevels;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
	case MTPSLL2PROFILECONGESTIONCOUNTING:
		*write_method = write_mtpSlL2ProfileCongestionCounting;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionCounting);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileCongestionCounting;
	case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT:
		*write_method = write_mtpSlL2ProfileCongestionReportingBaseObject;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
	case MTPSLL2PROFILELOOPDELAY:
		*write_method = write_mtpSlL2ProfileLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileLoopDelay);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileLoopDelay;
	case MTPSLL2PROFILENAME:
		*write_method = write_mtpSlL2ProfileName;
		*var_len = StorageTmp->mtpSlL2ProfileNameLen;
		return (uint8_t *) StorageTmp->mtpSlL2ProfileName;
	case MTPSLL2PROFILETBONSET2:
		*write_method = write_mtpSlL2ProfileTbOnset2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset2);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbOnset2;
	case MTPSLL2PROFILETBABATE2:
		*write_method = write_mtpSlL2ProfileTbAbate2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate2);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbAbate2;
	case MTPSLL2PROFILETBONSET3:
		*write_method = write_mtpSlL2ProfileTbOnset3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset3);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbOnset3;
	case MTPSLL2PROFILETBABATE3:
		*write_method = write_mtpSlL2ProfileTbAbate3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate3);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbAbate3;
	case MTPSLL2PROFILETBDISCARD1:
		*write_method = write_mtpSlL2ProfileTbDiscard1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard1);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbDiscard1;
	case MTPSLL2PROFILETBDISCARD2:
		*write_method = write_mtpSlL2ProfileTbDiscard2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard2);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbDiscard2;
	case MTPSLL2PROFILETBDISCARD3:
		*write_method = write_mtpSlL2ProfileTbDiscard3;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard3);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTbDiscard3;
	case MTPSLL2PROFILETIMERTX:
		*write_method = write_mtpSlL2ProfileTimerTx;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTx);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerTx;
	case MTPSLL2PROFILETIMERTY:
		*write_method = write_mtpSlL2ProfileTimerTy;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTy);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileTimerTy;
	case MTPSLL2PROFILENUMBEROFCONGESTIONSTATES:
		*write_method = write_mtpSlL2ProfileNumberOfCongestionStates;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfCongestionStates);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
	case MTPSLL2PROFILEINITIALLEVELOFCONGESTION:
		*write_method = write_mtpSlL2ProfileInitialLevelOfCongestion;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
	case MTPSLL2PROFILEMAXMSUSRETRANSN1:
		*write_method = write_mtpSlL2ProfileMaxMSUsRetransN1;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
	case MTPSLL2PROFILEMAXOCTRETRANSN2:
		*write_method = write_mtpSlL2ProfileMaxOctRetransN2;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxOctRetransN2);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdOnset;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdAbate;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
	case MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD:
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
	case MTPSLL2PROFILEM:
		*write_method = write_mtpSlL2ProfileM;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileM);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileM;
	case MTPSLL2PROFILEROWSTATUS:
		*write_method = write_mtpSlL2ProfileRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileRowStatus);
		return (uint8_t *) &StorageTmp->mtpSlL2ProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlTable(): refresh mtpSlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(void)
{
	if (mtpSlTable_refresh == 0)
		return;
	mtpSlTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlTable_row(): refresh mtpSlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlTable_request == sa_request)
		return;
	StorageTmp->mtpSlTable_request = sa_request;
}

/*
 * var_mtpSlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLSLSCODECURRENTLIST:
		*write_method = write_mtpSlSlsCodeCurrentList;
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		return (uint8_t *) StorageTmp->mtpSlSlsCodeCurrentList;
	case MTPSLMAXCAPACITYSL:
		*write_method = write_mtpSlMaxCapacitySL;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacitySL);
		return (uint8_t *) &StorageTmp->mtpSlMaxCapacitySL;
	case MTPSLCURRENTCAPACITYSL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacitySL);
		return (uint8_t *) &StorageTmp->mtpSlCurrentCapacitySL;
	case MTPSLLINKTPSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlLinkTpStatusLen;
		return (uint8_t *) StorageTmp->mtpSlLinkTpStatus;
	case MTPSLADMINISTRATIVESTATE:
		*write_method = write_mtpSlAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		return (uint8_t *) &StorageTmp->mtpSlAdministrativeState;
	case MTPSLOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		return (uint8_t *) &StorageTmp->mtpSlOperationalState;
	case MTPSLUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		return (uint8_t *) &StorageTmp->mtpSlUsageState;
	case MTPSLPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		return (uint8_t *) StorageTmp->mtpSlProceduralStatus;
	case MTPSLMTPL2PROTOCOLPROFILEPOINTER:
		*write_method = write_mtpSlMtpL2ProtocolProfilePointer;
		*var_len = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
	case MTPSLSIGNTERMPOINTER:
		*write_method = write_mtpSlSignTermPointer;
		*var_len = StorageTmp->mtpSlSignTermPointerLen;
		return (uint8_t *) StorageTmp->mtpSlSignTermPointer;
	case MTPSLSIGNDATALINKTPPOINTER:
		*write_method = write_mtpSlSignDataLinkTpPointer;
		*var_len = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		return (uint8_t *) StorageTmp->mtpSlSignDataLinkTpPointer;
	case MTPSLLOCALINHIBIT:
		*write_method = write_mtpSlLocalInhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		return (uint8_t *) &StorageTmp->mtpSlLocalInhibit;
	case MTPSLLOCALUNINHIBIT:
		*write_method = write_mtpSlLocalUninhibit;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlLocalUninhibit;
	case MTPSLREPLACEST:
		*write_method = write_mtpSlReplaceSt;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		return (uint8_t *) &StorageTmp->mtpSlReplaceSt;
	case MTPSLASAPROFILEPOINTER:
		*write_method = write_mtpSlAsaProfilePointer;
		*var_len = StorageTmp->mtpSlAsaProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpSlAsaProfilePointer;
	case MTPSLCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		return (uint8_t *) &StorageTmp->mtpSlCongestionLevel;
	case MTPSLRELATEDLINKGROUPNUMBER:
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		return (uint8_t *) &StorageTmp->mtpSlRelatedLinkGroupNumber;
	case MTPSLSDLLIST:
		*write_method = write_mtpSlSdlList;
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		return (uint8_t *) &StorageTmp->mtpSlSdlList;
	case MTPSLTEST:
		*write_method = write_mtpSlTest;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		return (uint8_t *) &StorageTmp->mtpSlTest;
	case MTPSLNAME:
		*write_method = write_mtpSlName;
		*var_len = StorageTmp->mtpSlNameLen;
		return (uint8_t *) StorageTmp->mtpSlName;
	case MTPSLSDTLIST:
		*write_method = write_mtpSlSdtList;
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		return (uint8_t *) &StorageTmp->mtpSlSdtList;
	case MTPSLSLSCODENORMALLIST:
		*write_method = write_mtpSlSlsCodeNormalList;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		return (uint8_t *) StorageTmp->mtpSlSlsCodeNormalList;
	case MTPSLL3PROFILEPOINTER:
		*write_method = write_mtpSlL3ProfilePointer;
		*var_len = StorageTmp->mtpSlL3ProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpSlL3ProfilePointer;
	case MTPSLALARMSTATUS:
		*write_method = write_mtpSlAlarmStatus;
		*var_len = StorageTmp->mtpSlAlarmStatusLen;
		return (uint8_t *) StorageTmp->mtpSlAlarmStatus;
	case MTPSLROWSTATUS:
		*write_method = write_mtpSlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlRowStatus);
		return (uint8_t *) &StorageTmp->mtpSlRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdlListTable(): refresh mtpSlSdlListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(void)
{
	if (mtpSlSdlListTable_refresh == 0)
		return;
	mtpSlSdlListTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlSdlListTable_row(): refresh mtpSlSdlListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdlListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdlListTable_request = sa_request;
}

/*
 * var_mtpSlSdlListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlSdlListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdlListTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlSdlListTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLSDLLISTPOINTER:
		*write_method = write_mtpSlSdlListPointer;
		*var_len = StorageTmp->mtpSlSdlListPointerLen;
		return (uint8_t *) StorageTmp->mtpSlSdlListPointer;
	case MTPSLSDLLISTROWSTATUS:
		*write_method = write_mtpSlSdlListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdlListRowStatus);
		return (uint8_t *) &StorageTmp->mtpSlSdlListRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlSdtListTable(): refresh mtpSlSdtListTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(void)
{
	if (mtpSlSdtListTable_refresh == 0)
		return;
	mtpSlSdtListTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlSdtListTable_row(): refresh mtpSlSdtListTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlSdtListTable_request == sa_request)
		return;
	StorageTmp->mtpSlSdtListTable_request = sa_request;
}

/*
 * var_mtpSlSdtListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlSdtListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlSdtListTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlSdtListTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLSDTLISTPOINTER:
		*write_method = write_mtpSlSdtListPointer;
		*var_len = StorageTmp->mtpSlSdtListPointerLen;
		return (uint8_t *) StorageTmp->mtpSlSdtListPointer;
	case MTPSLSDTLISTROWSTATUS:
		*write_method = write_mtpSlSdtListRowStatus;
		*var_len = sizeof(StorageTmp->mtpSlSdtListRowStatus);
		return (uint8_t *) &StorageTmp->mtpSlSdtListRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlStatsTable(): refresh mtpSlStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlStatsTable(void)
{
	if (mtpSlStatsTable_refresh == 0)
		return;
	mtpSlStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlStatsTable_row(): refresh mtpSlStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlStatsTable_row(struct mtpSlStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSlStatsTable_request = sa_request;
}

/*
 * var_mtpSlStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLSTATSDURINSERVICE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurInService);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurInService;
	case MTPSLSTATSFAILALIGNORPROVING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsFailAlignOrProving);
		return (uint8_t *) &StorageTmp->mtpSlStatsFailAlignOrProving;
	case MTPSLSTATSNACKSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsNacksReceived);
		return (uint8_t *) &StorageTmp->mtpSlStatsNacksReceived;
	case MTPSLSTATSDURUNAVAIL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurUnavail);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurUnavail;
	case MTPSLSTATSDURUNAVAILFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurUnavailFailed);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurUnavailFailed;
	case MTPSLSTATSDURUNAVAILRPO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurUnavailRpo);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurUnavailRpo;
	case MTPSLSTATSSIBSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsSibsSent);
		return (uint8_t *) &StorageTmp->mtpSlStatsSibsSent;
	case MTPSLSTATSTRANSIOSIFOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsTranSioSifOctets);
		return (uint8_t *) &StorageTmp->mtpSlStatsTranSioSifOctets;
	case MTPSLSTATSRETRANSOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsRetransOctets);
		return (uint8_t *) &StorageTmp->mtpSlStatsRetransOctets;
	case MTPSLSTATSTRANMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsTranMsus);
		return (uint8_t *) &StorageTmp->mtpSlStatsTranMsus;
	case MTPSLSTATSRECVSIOSIFOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsRecvSioSifOctets);
		return (uint8_t *) &StorageTmp->mtpSlStatsRecvSioSifOctets;
	case MTPSLSTATSRECVMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsRecvMsus);
		return (uint8_t *) &StorageTmp->mtpSlStatsRecvMsus;
	case MTPSLSTATSCONGONSETIND0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd0);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd0;
	case MTPSLSTATSCONGONSETIND1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd1);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd1;
	case MTPSLSTATSCONGONSETIND2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd2);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd2;
	case MTPSLSTATSCONGONSETIND3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongOnsetInd3);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongOnsetInd3;
	case MTPSLSTATSDURCONGSTATUS0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus0);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus0;
	case MTPSLSTATSDURCONGSTATUS1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus1);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus1;
	case MTPSLSTATSDURCONGSTATUS2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus2);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus2;
	case MTPSLSTATSDURCONGSTATUS3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsDurCongStatus3);
		return (uint8_t *) &StorageTmp->mtpSlStatsDurCongStatus3;
	case MTPSLSTATSCONGDISCDIND0:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd0);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd0;
	case MTPSLSTATSCONGDISCDIND1:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd1);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd1;
	case MTPSLSTATSCONGDISCDIND2:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd2);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd2;
	case MTPSLSTATSCONGDISCDIND3:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlStatsCongDiscdInd3);
		return (uint8_t *) &StorageTmp->mtpSlStatsCongDiscdInd3;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3CurrentTable(): refresh mtpSlL3CurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3CurrentTable(void)
{
	if (mtpSlL3CurrentTable_refresh == 0)
		return;
	mtpSlL3CurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3CurrentTable_row(): refresh mtpSlL3CurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3CurrentTable_row(struct mtpSlL3CurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3CurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3CurrentTable_request = sa_request;
}

/*
 * var_mtpSlL3CurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL3CurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3CurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL3CurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3CurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3CurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3CurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3CURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentValidIntervals;
	case MTPSLL3CURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentTimeDiscontinuity;
	case MTPSLL3CURRENTSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlUnavailabilityDuration;
	case MTPSLL3CURRENTSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlLocalInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlLocalInhibition;
	case MTPSLL3CURRENTSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlRemoteInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlRemoteInhibition;
	case MTPSLL3CURRENTSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlFailed);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlFailed;
	case MTPSLL3CURRENTSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlRemoteProcOutage);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlRemoteProcOutage;
	case MTPSLL3CURRENTLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentLocalMgmtInhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentLocalMgmtInhibit;
	case MTPSLL3CURRENTLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentLocalMgmtUninhibit;
	case MTPSLL3CURRENTLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentLocalBusy);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentLocalBusy;
	case MTPSLL3CURRENTSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlCongestedStarts);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlCongestedStarts;
	case MTPSLL3CURRENTSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlCongestedDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlCongestedDuration;
	case MTPSLL3CURRENTSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentSlCongestionStops);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentSlCongestionStops;
	case MTPSLL3CURRENTDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentDiscardedMSUs;
	case MTPSLL3CURRENTCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentCongestionEventsMSULoss;
	case MTPSLL3CURRENTCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentChangeovers);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentChangeovers;
	case MTPSLL3CURRENTCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentChangebacks);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentChangebacks;
	case MTPSLL3CURRENTRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3CurrentRestorations);
		return (uint8_t *) &StorageTmp->mtpSlL3CurrentRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3Int5minTable(): refresh mtpSlL3Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3Int5minTable(void)
{
	if (mtpSlL3Int5minTable_refresh == 0)
		return;
	mtpSlL3Int5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3Int5minTable_row(): refresh mtpSlL3Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3Int5minTable_row(struct mtpSlL3Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3Int5minTable_request = sa_request;
}

/*
 * var_mtpSlL3Int5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL3Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL3Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3Int5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3Int5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minTimeStamp;
	case MTPSLL3INT5MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlUnavailabilityDuration;
	case MTPSLL3INT5MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlLocalInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlLocalInhibition;
	case MTPSLL3INT5MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlRemoteInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlRemoteInhibition;
	case MTPSLL3INT5MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlFailed);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlFailed;
	case MTPSLL3INT5MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlRemoteProcOutage);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlRemoteProcOutage;
	case MTPSLL3INT5MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minLocalMgmtInhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minLocalMgmtInhibit;
	case MTPSLL3INT5MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minLocalMgmtUninhibit;
	case MTPSLL3INT5MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minLocalBusy);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minLocalBusy;
	case MTPSLL3INT5MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlCongestedStarts);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlCongestedStarts;
	case MTPSLL3INT5MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlCongestedDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlCongestedDuration;
	case MTPSLL3INT5MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minSlCongestionStops);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minSlCongestionStops;
	case MTPSLL3INT5MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minDiscardedMSUs;
	case MTPSLL3INT5MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minCongestionEventsMSULoss;
	case MTPSLL3INT5MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minChangeovers);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minChangeovers;
	case MTPSLL3INT5MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minChangebacks);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minChangebacks;
	case MTPSLL3INT5MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int5minRestorations);
		return (uint8_t *) &StorageTmp->mtpSlL3Int5minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL3Int15minTable(): refresh mtpSlL3Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL3Int15minTable(void)
{
	if (mtpSlL3Int15minTable_refresh == 0)
		return;
	mtpSlL3Int15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL3Int15minTable_row(): refresh mtpSlL3Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL3Int15minTable_row(struct mtpSlL3Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL3Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL3Int15minTable_request = sa_request;
}

/*
 * var_mtpSlL3Int15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL3Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL3Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL3Int15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL3Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL3Int15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL3INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minTimeStamp);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minTimeStamp;
	case MTPSLL3INT15MINSLUNAVAILABILITYDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlUnavailabilityDuration;
	case MTPSLL3INT15MINSLLOCALINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlLocalInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlLocalInhibition;
	case MTPSLL3INT15MINSLREMOTEINHIBITION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlRemoteInhibition);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlRemoteInhibition;
	case MTPSLL3INT15MINSLFAILED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlFailed);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlFailed;
	case MTPSLL3INT15MINSLREMOTEPROCOUTAGE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlRemoteProcOutage);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlRemoteProcOutage;
	case MTPSLL3INT15MINLOCALMGMTINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minLocalMgmtInhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minLocalMgmtInhibit;
	case MTPSLL3INT15MINLOCALMGMTUNINHIBIT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minLocalMgmtUninhibit;
	case MTPSLL3INT15MINLOCALBUSY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minLocalBusy);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minLocalBusy;
	case MTPSLL3INT15MINSLCONGESTEDSTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlCongestedStarts);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlCongestedStarts;
	case MTPSLL3INT15MINSLCONGESTEDDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlCongestedDuration);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlCongestedDuration;
	case MTPSLL3INT15MINSLCONGESTIONSTOPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minSlCongestionStops);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minSlCongestionStops;
	case MTPSLL3INT15MINDISCARDEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minDiscardedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minDiscardedMSUs;
	case MTPSLL3INT15MINCONGESTIONEVENTSMSULOSS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minCongestionEventsMSULoss;
	case MTPSLL3INT15MINCHANGEOVERS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minChangeovers);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minChangeovers;
	case MTPSLL3INT15MINCHANGEBACKS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minChangebacks);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minChangebacks;
	case MTPSLL3INT15MINRESTORATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL3Int15minRestorations);
		return (uint8_t *) &StorageTmp->mtpSlL3Int15minRestorations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2CurrentTable(): refresh mtpSlL2CurrentTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2CurrentTable(void)
{
	if (mtpSlL2CurrentTable_refresh == 0)
		return;
	mtpSlL2CurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2CurrentTable_row(): refresh mtpSlL2CurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2CurrentTable_row(struct mtpSlL2CurrentTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2CurrentTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2CurrentTable_request = sa_request;
}

/*
 * var_mtpSlL2CurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL2CurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2CurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL2CurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2CurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2CurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2CurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2CURRENTVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentValidIntervals);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentValidIntervals;
	case MTPSLL2CURRENTTIMEDISCONTINUITY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentTimeDiscontinuity);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentTimeDiscontinuity;
	case MTPSLL2CURRENTSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentSlInServiceDuration);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentSlInServiceDuration;
	case MTPSLL2CURRENTSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentSlAlignment);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentSlAlignment;
	case MTPSLL2CURRENTSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentSignUnitsReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentSignUnitsReceived;
	case MTPSLL2CURRENTNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentNegAckReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentNegAckReceived;
	case MTPSLL2CURRENTTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentTransmittedOctetsSIFSIO;
	case MTPSLL2CURRENTRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentRetransmittedOctets);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentRetransmittedOctets;
	case MTPSLL2CURRENTTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentTransmittedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentTransmittedMSUs;
	case MTPSLL2CURRENTRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentReceivedOctetsSIFSIO;
	case MTPSLL2CURRENTRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2CurrentReceivedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2CurrentReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2Int5minTable(): refresh mtpSlL2Int5minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2Int5minTable(void)
{
	if (mtpSlL2Int5minTable_refresh == 0)
		return;
	mtpSlL2Int5minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2Int5minTable_row(): refresh mtpSlL2Int5minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2Int5minTable_row(struct mtpSlL2Int5minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2Int5minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2Int5minTable_request = sa_request;
}

/*
 * var_mtpSlL2Int5minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL2Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2Int5minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL2Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2Int5minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2Int5minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2Int5minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2INT5MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minTimestamp);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minTimestamp;
	case MTPSLL2INT5MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minSlInServiceDuration);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minSlInServiceDuration;
	case MTPSLL2INT5MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minSlAlignment);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minSlAlignment;
	case MTPSLL2INT5MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minSignUnitsReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minSignUnitsReceived;
	case MTPSLL2INT5MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minNegAckReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minNegAckReceived;
	case MTPSLL2INT5MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minTransmittedOctetsSIFSIO;
	case MTPSLL2INT5MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minRetransmittedOctets);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minRetransmittedOctets;
	case MTPSLL2INT5MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minTransmittedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minTransmittedMSUs;
	case MTPSLL2INT5MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minReceivedOctetsSIFSIO;
	case MTPSLL2INT5MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int5minReceivedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int5minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSlL2Int15minTable(): refresh mtpSlL2Int15minTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSlL2Int15minTable(void)
{
	if (mtpSlL2Int15minTable_refresh == 0)
		return;
	mtpSlL2Int15minTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSlL2Int15minTable_row(): refresh mtpSlL2Int15minTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSlL2Int15minTable_row(struct mtpSlL2Int15minTable_data *StorageTmp)
{
	if (StorageTmp->mtpSlL2Int15minTable_request == sa_request)
		return;
	StorageTmp->mtpSlL2Int15minTable_request = sa_request;
}

/*
 * var_mtpSlL2Int15minTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSlL2Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2Int15minTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSlL2Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSlL2Int15minTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSlL2Int15minTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSlL2Int15minTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSLL2INT15MINTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minTimestamp);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minTimestamp;
	case MTPSLL2INT15MINSLINSERVICEDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minSlInServiceDuration);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minSlInServiceDuration;
	case MTPSLL2INT15MINSLALIGNMENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minSlAlignment);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minSlAlignment;
	case MTPSLL2INT15MINSIGNUNITSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minSignUnitsReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minSignUnitsReceived;
	case MTPSLL2INT15MINNEGACKRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minNegAckReceived);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minNegAckReceived;
	case MTPSLL2INT15MINTRANSMITTEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minTransmittedOctetsSIFSIO;
	case MTPSLL2INT15MINRETRANSMITTEDOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minRetransmittedOctets);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minRetransmittedOctets;
	case MTPSLL2INT15MINTRANSMITTEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minTransmittedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minTransmittedMSUs;
	case MTPSLL2INT15MINRECEIVEDOCTETSSIFSIO:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minReceivedOctetsSIFSIO;
	case MTPSLL2INT15MINRECEIVEDMSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSlL2Int15minReceivedMSUs);
		return (uint8_t *) &StorageTmp->mtpSlL2Int15minReceivedMSUs;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpNbTable(): refresh mtpNbTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpNbTable(void)
{
	if (mtpNbTable_refresh == 0)
		return;
	mtpNbTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpNbTable_row(): refresh mtpNbTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	if (StorageTmp->mtpNbTable_request == sa_request)
		return;
	StorageTmp->mtpNbTable_request = sa_request;
}

/*
 * var_mtpNbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpNbTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNbTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpNbTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpNbTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpNbTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpNbTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPNBTRANSMISSIONRATE:
		*write_method = write_mtpNbTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpNbTransmissionRate);
		return (uint8_t *) &StorageTmp->mtpNbTransmissionRate;
	case MTPNBTIMERT8:
		*write_method = write_mtpNbTimerT8;
		*var_len = sizeof(StorageTmp->mtpNbTimerT8);
		return (uint8_t *) &StorageTmp->mtpNbTimerT8;
	case MTPNBTIN:
		*write_method = write_mtpNbTin;
		*var_len = sizeof(StorageTmp->mtpNbTin);
		return (uint8_t *) &StorageTmp->mtpNbTin;
	case MTPNBTIE:
		*write_method = write_mtpNbTie;
		*var_len = sizeof(StorageTmp->mtpNbTie);
		return (uint8_t *) &StorageTmp->mtpNbTie;
	case MTPNBT:
		*write_method = write_mtpNbT;
		*var_len = sizeof(StorageTmp->mtpNbT);
		return (uint8_t *) &StorageTmp->mtpNbT;
	case MTPNBD:
		*write_method = write_mtpNbD;
		*var_len = sizeof(StorageTmp->mtpNbD);
		return (uint8_t *) &StorageTmp->mtpNbD;
	case MTPNBTE:
		*write_method = write_mtpNbTe;
		*var_len = sizeof(StorageTmp->mtpNbTe);
		return (uint8_t *) &StorageTmp->mtpNbTe;
	case MTPNBDE:
		*write_method = write_mtpNbDe;
		*var_len = sizeof(StorageTmp->mtpNbDe);
		return (uint8_t *) &StorageTmp->mtpNbDe;
	case MTPNBUE:
		*write_method = write_mtpNbUe;
		*var_len = sizeof(StorageTmp->mtpNbUe);
		return (uint8_t *) &StorageTmp->mtpNbUe;
	case MTPNBN:
		*write_method = write_mtpNbN;
		*var_len = sizeof(StorageTmp->mtpNbN);
		return (uint8_t *) &StorageTmp->mtpNbN;
	case MTPNBM:
		*write_method = write_mtpNbm;
		*var_len = sizeof(StorageTmp->mtpNbm);
		return (uint8_t *) &StorageTmp->mtpNbm;
	case MTPNBB:
		*write_method = write_mtpNbb;
		*var_len = sizeof(StorageTmp->mtpNbb);
		return (uint8_t *) &StorageTmp->mtpNbb;
	case MTPNBF:
		*write_method = write_mtpNbf;
		*var_len = sizeof(StorageTmp->mtpNbf);
		return (uint8_t *) &StorageTmp->mtpNbf;
	case MTPNBROWSTATUS:
		*write_method = write_mtpNbRowStatus;
		*var_len = sizeof(StorageTmp->mtpNbRowStatus);
		return (uint8_t *) &StorageTmp->mtpNbRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSaalTable(): refresh mtpSaalTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(void)
{
	if (mtpSaalTable_refresh == 0)
		return;
	mtpSaalTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSaalTable_row(): refresh mtpSaalTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	if (StorageTmp->mtpSaalTable_request == sa_request)
		return;
	StorageTmp->mtpSaalTable_request = sa_request;
}

/*
 * var_mtpSaalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSaalTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSaalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSaalTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSaalTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSAALBUFFERRELEASE:
		*write_method = write_mtpSaalBufferRelease;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		return (uint8_t *) &StorageTmp->mtpSaalBufferRelease;
	case MTPSAALMAXCC:
		*write_method = write_mtpSaalMaxCc;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		return (uint8_t *) &StorageTmp->mtpSaalMaxCc;
	case MTPSAALMAXNRP:
		*write_method = write_mtpSaalMaxNrp;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		return (uint8_t *) &StorageTmp->mtpSaalMaxNrp;
	case MTPSAALMAXINFORMATIONFIELDLENGTH:
		*write_method = write_mtpSaalMaxInformationFieldLength;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		return (uint8_t *) &StorageTmp->mtpSaalMaxInformationFieldLength;
	case MTPSAALMAXLENGTHSSCOPUUFIELD:
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		return (uint8_t *) &StorageTmp->mtpSaalMaxLengthSscopUuField;
	case MTPSAALMAXPD:
		*write_method = write_mtpSaalMaxPd;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		return (uint8_t *) &StorageTmp->mtpSaalMaxPd;
	case MTPSAALMAXSSCOPCREDITTOPEER:
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		return (uint8_t *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;
	case MTPSAALMAXSTAT:
		*write_method = write_mtpSaalMaxStat;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		return (uint8_t *) &StorageTmp->mtpSaalMaxStat;
	case MTPSAALN1:
		*write_method = write_mtpSaalN1;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		return (uint8_t *) &StorageTmp->mtpSaalN1;
	case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		return (uint8_t *) &StorageTmp->mtpSaalNniLayerManagementProvingState;
	case MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		return (uint8_t *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
	case MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		return (uint8_t *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
	case MTPSAALNNITIMERT1:
		*write_method = write_mtpSaalNniTimerT1;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		return (uint8_t *) &StorageTmp->mtpSaalNniTimerT1;
	case MTPSAALNNITIMERT2:
		*write_method = write_mtpSaalNniTimerT2;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		return (uint8_t *) &StorageTmp->mtpSaalNniTimerT2;
	case MTPSAALNNITIMERT3:
		*write_method = write_mtpSaalNniTimerT3;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		return (uint8_t *) &StorageTmp->mtpSaalNniTimerT3;
	case MTPSAALSSCOPTIMERCC:
		*write_method = write_mtpSaalSscopTimerCc;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		return (uint8_t *) &StorageTmp->mtpSaalSscopTimerCc;
	case MTPSAALSSCOPTIMERIDLE:
		*write_method = write_mtpSaalSscopTimerIdle;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		return (uint8_t *) &StorageTmp->mtpSaalSscopTimerIdle;
	case MTPSAALSSCOPTIMERKEEPALIVE:
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		return (uint8_t *) &StorageTmp->mtpSaalSscopTimerKeepAlive;
	case MTPSAALSSCOPTIMERNORESPONSE:
		*write_method = write_mtpSaalSscopTimerNoResponse;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		return (uint8_t *) &StorageTmp->mtpSaalSscopTimerNoResponse;
	case MTPSAALSSCOPTIMERPOLL:
		*write_method = write_mtpSaalSscopTimerPoll;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		return (uint8_t *) &StorageTmp->mtpSaalSscopTimerPoll;
	case MTPSAALTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		return (uint8_t *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;
	case MTPSAALTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		return (uint8_t *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;
	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		return (uint8_t *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
	case MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		return (uint8_t *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
	case MTPSAALPOLLAFTERRETRANSMISSION:
		*write_method = write_mtpSaalPollAfterRetransmission;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		return (uint8_t *) &StorageTmp->mtpSaalPollAfterRetransmission;
	case MTPSAALROWSTATUS:
		*write_method = write_mtpSaalRowStatus;
		*var_len = sizeof(StorageTmp->mtpSaalRowStatus);
		return (uint8_t *) &StorageTmp->mtpSaalRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpM2paTable(): refresh mtpM2paTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(void)
{
	if (mtpM2paTable_refresh == 0)
		return;
	mtpM2paTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpM2paTable_row(): refresh mtpM2paTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	if (StorageTmp->mtpM2paTable_request == sa_request)
		return;
	StorageTmp->mtpM2paTable_request = sa_request;
}

/*
 * var_mtpM2paTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2paTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpM2paTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpM2paTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpM2paTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPM2PAN1:
		*write_method = write_mtpM2paN1;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		return (uint8_t *) &StorageTmp->mtpM2paN1;
	case MTPM2PAPROVING:
		*write_method = write_mtpM2paProving;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		return (uint8_t *) &StorageTmp->mtpM2paProving;
	case MTPM2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_mtpM2paManagementProvingState;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		return (uint8_t *) &StorageTmp->mtpM2paManagementProvingState;
	case MTPM2PALOOPDELAYLOWER:
		*write_method = write_mtpM2paLoopDelayLower;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		return (uint8_t *) &StorageTmp->mtpM2paLoopDelayLower;
	case MTPM2PALOOPDELAYUPPER:
		*write_method = write_mtpM2paLoopDelayUpper;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		return (uint8_t *) &StorageTmp->mtpM2paLoopDelayUpper;
	case MTPM2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		return (uint8_t *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;
	case MTPM2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		return (uint8_t *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;
	case MTPM2PASCTPNODELAY:
		*write_method = write_mtpM2paSctpNoDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		return (uint8_t *) &StorageTmp->mtpM2paSctpNoDelay;
	case MTPM2PASCTPMAXSEG:
		*write_method = write_mtpM2paSctpMaxseg;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		return (uint8_t *) &StorageTmp->mtpM2paSctpMaxseg;
	case MTPM2PASCTPHEARTBEATITVL:
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		return (uint8_t *) &StorageTmp->mtpM2paSctpHeartbeatItvl;
	case MTPM2PASCTPHEARTBEAT:
		*write_method = write_mtpM2paSctpHeartbeat;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		return (uint8_t *) &StorageTmp->mtpM2paSctpHeartbeat;
	case MTPM2PASCTPRTOINITIAL:
		*write_method = write_mtpM2paSctpRtoInitial;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		return (uint8_t *) &StorageTmp->mtpM2paSctpRtoInitial;
	case MTPM2PASCTPRTOMIN:
		*write_method = write_mtpM2paSctpRtoMin;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		return (uint8_t *) &StorageTmp->mtpM2paSctpRtoMin;
	case MTPM2PASCTPRTOMAX:
		*write_method = write_mtpM2paSctpRtoMax;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		return (uint8_t *) &StorageTmp->mtpM2paSctpRtoMax;
	case MTPM2PASCTPPATHMAXRETRANS:
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		return (uint8_t *) &StorageTmp->mtpM2paSctpPathMaxRetrans;
	case MTPM2PASCTPCOOKIELIFE:
		*write_method = write_mtpM2paSctpCookieLife;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		return (uint8_t *) &StorageTmp->mtpM2paSctpCookieLife;
	case MTPM2PASCTPCOOKIEINC:
		*write_method = write_mtpM2paSctpCookieInc;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		return (uint8_t *) &StorageTmp->mtpM2paSctpCookieInc;
	case MTPM2PASCTPMAXINITRETRIES:
		*write_method = write_mtpM2paSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		return (uint8_t *) &StorageTmp->mtpM2paSctpMaxInitRetries;
	case MTPM2PASCTPMAXBURST:
		*write_method = write_mtpM2paSctpMaxBurst;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		return (uint8_t *) &StorageTmp->mtpM2paSctpMaxBurst;
	case MTPM2PASCTPASSOCMAXRETRANS:
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		return (uint8_t *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;
	case MTPM2PASCTPSACKDELAY:
		*write_method = write_mtpM2paSctpSackDelay;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		return (uint8_t *) &StorageTmp->mtpM2paSctpSackDelay;
	case MTPM2PASCTPLIFETIME:
		*write_method = write_mtpM2paSctpLifetime;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		return (uint8_t *) &StorageTmp->mtpM2paSctpLifetime;
	case MTPM2PAPROVINGATTEMPTS:
		*write_method = write_mtpM2paProvingAttempts;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		return (uint8_t *) &StorageTmp->mtpM2paProvingAttempts;
	case MTPM2PAROWSTATUS:
		*write_method = write_mtpM2paRowStatus;
		*var_len = sizeof(StorageTmp->mtpM2paRowStatus);
		return (uint8_t *) &StorageTmp->mtpM2paRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdtTable(): refresh mtpSdtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(void)
{
	if (mtpSdtTable_refresh == 0)
		return;
	mtpSdtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdtTable_row(): refresh mtpSdtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtTable_request == sa_request)
		return;
	StorageTmp->mtpSdtTable_request = sa_request;
}

/*
 * var_mtpSdtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSdtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSDTADMINISTRATIVESTATE:
		*write_method = write_mtpSdtAdministrativeState;
		*var_len = sizeof(StorageTmp->mtpSdtAdministrativeState);
		return (uint8_t *) &StorageTmp->mtpSdtAdministrativeState;
	case MTPSDTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtOperationalState);
		return (uint8_t *) &StorageTmp->mtpSdtOperationalState;
	case MTPSDTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		return (uint8_t *) &StorageTmp->mtpSdtUsageState;
	case MTPSDTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtProceduralStatusLen;
		return (uint8_t *) StorageTmp->mtpSdtProceduralStatus;
	case MTPSDTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->mtpSdtAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->mtpSdtAvailabilityStatus;
	case MTPSDTEQUIPMENTPOINTER:
		*write_method = write_mtpSdtEquipmentPointer;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen;
		return (uint8_t *) StorageTmp->mtpSdtEquipmentPointer;
	case MTPSDTNAME:
		*write_method = write_mtpSdtName;
		*var_len = StorageTmp->mtpSdtNameLen;
		return (uint8_t *) StorageTmp->mtpSdtName;
	case MTPSDTPROFILEPOINTER:
		*write_method = write_mtpSdtProfilePointer;
		*var_len = StorageTmp->mtpSdtProfilePointerLen;
		return (uint8_t *) StorageTmp->mtpSdtProfilePointer;
	case MTPSDTROWSTATUS:
		*write_method = write_mtpSdtRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdtRowStatus);
		return (uint8_t *) &StorageTmp->mtpSdtRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdtStatsTable(): refresh mtpSdtStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdtStatsTable(void)
{
	if (mtpSdtStatsTable_refresh == 0)
		return;
	mtpSdtStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdtStatsTable_row(): refresh mtpSdtStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdtStatsTable_row(struct mtpSdtStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdtStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSdtStatsTable_request = sa_request;
}

/*
 * var_mtpSdtStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSdtStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSdtStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdtStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdtStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdtStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSDTSTATSTXBYTES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxBytes);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxBytes;
	case MTPSDTSTATSTXSUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxSus);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxSus;
	case MTPSDTSTATSTXSUSREPEATED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxSusRepeated);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxSusRepeated;
	case MTPSDTSTATSTXUNDERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxUnderruns);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxUnderruns;
	case MTPSDTSTATSTXABORTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxAborts);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxAborts;
	case MTPSDTSTATSTXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxBufferOverflows;
	case MTPSDTSTATSTXSUSINERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsTxSusInError);
		return (uint8_t *) &StorageTmp->mtpSdtStatsTxSusInError;
	case MTPSDTSTATSRXBYTES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxBytes);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxBytes;
	case MTPSDTSTATSRXSUSCOMPRESSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxSusCompressed);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxSusCompressed;
	case MTPSDTSTATSRXOVERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxOverruns);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxOverruns;
	case MTPSDTSTATSRXABORTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxAborts);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxAborts;
	case MTPSDTSTATSRXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxBufferOverflows;
	case MTPSDTSTATSRXSUSINERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxSusInError);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxSusInError;
	case MTPSDTSTATSRXSYNCTRANSITIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxSyncTransitions);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxSyncTransitions;
	case MTPSDTSTATSRXBITSOCTETCOUNTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxBitsOctetCounted);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxBitsOctetCounted;
	case MTPSDTSTATSRXCRCERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxCrcErrors);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxCrcErrors;
	case MTPSDTSTATSRXFRAMEERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameErrors);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameErrors;
	case MTPSDTSTATSRXFRAMEOVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameOverflows);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameOverflows;
	case MTPSDTSTATSRXFRAMETOOLONG:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameTooLong);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameTooLong;
	case MTPSDTSTATSRXFRAMETOOSHORT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxFrameTooShort);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxFrameTooShort;
	case MTPSDTSTATSRXRESIDUEERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsRxResidueErrors);
		return (uint8_t *) &StorageTmp->mtpSdtStatsRxResidueErrors;
	case MTPSDTSTATSCARRIERCTSLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsCarrierCtsLost);
		return (uint8_t *) &StorageTmp->mtpSdtStatsCarrierCtsLost;
	case MTPSDTSTATSCARRIERDCDLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsCarrierDcdLost);
		return (uint8_t *) &StorageTmp->mtpSdtStatsCarrierDcdLost;
	case MTPSDTSTATSCARRIERLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdtStatsCarrierLost);
		return (uint8_t *) &StorageTmp->mtpSdtStatsCarrierLost;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdlTable(): refresh mtpSdlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(void)
{
	if (mtpSdlTable_refresh == 0)
		return;
	mtpSdlTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdlTable_row(): refresh mtpSdlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlTable_request == sa_request)
		return;
	StorageTmp->mtpSdlTable_request = sa_request;
}

/*
 * var_mtpSdlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSdlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdlTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSDLADJPC:
		*write_method = write_mtpSdlAdjPc;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		return (uint8_t *) StorageTmp->mtpSdlAdjPc;
	case MTPSDLTRANSMISSIONRATE:
		*write_method = write_mtpSdlTransmissionRate;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		return (uint8_t *) &StorageTmp->mtpSdlTransmissionRate;
	case MTPSDLLOOPDELAY:
		*write_method = write_mtpSdlLoopDelay;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		return (uint8_t *) &StorageTmp->mtpSdlLoopDelay;
	case MTPSDLOPERATIONALSTATE:
		*write_method = write_mtpSdlOperationalState;
		*var_len = sizeof(StorageTmp->mtpSdlOperationalState);
		return (uint8_t *) &StorageTmp->mtpSdlOperationalState;
	case MTPSDLEQUIPMENTPOINTER:
		*write_method = write_mtpSdlEquipmentPointer;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen;
		return (uint8_t *) StorageTmp->mtpSdlEquipmentPointer;
	case MTPSDLCIC:
		*write_method = write_mtpSdlCIC;
		*var_len = sizeof(StorageTmp->mtpSdlCIC);
		return (uint8_t *) &StorageTmp->mtpSdlCIC;
	case MTPSDLNAME:
		*write_method = write_mtpSdlName;
		*var_len = StorageTmp->mtpSdlNameLen;
		return (uint8_t *) StorageTmp->mtpSdlName;
	case MTPSDLSTMCHANNEL:
		*write_method = write_mtpSdlStmChannel;
		*var_len = StorageTmp->mtpSdlStmChannelLen;
		return (uint8_t *) StorageTmp->mtpSdlStmChannel;
	case MTPSDLVCTTPPOINTER:
		*write_method = write_mtpSdlVcTTpPointer;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen;
		return (uint8_t *) StorageTmp->mtpSdlVcTTpPointer;
	case MTPSDLROWSTATUS:
		*write_method = write_mtpSdlRowStatus;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		return (uint8_t *) &StorageTmp->mtpSdlRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_mtpSdlStatsTable(): refresh mtpSdlStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_mtpSdlStatsTable(void)
{
	if (mtpSdlStatsTable_refresh == 0)
		return;
	mtpSdlStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_mtpSdlStatsTable_row(): refresh mtpSdlStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_mtpSdlStatsTable_row(struct mtpSdlStatsTable_data *StorageTmp)
{
	if (StorageTmp->mtpSdlStatsTable_request == sa_request)
		return;
	StorageTmp->mtpSdlStatsTable_request = sa_request;
}

/*
 * var_mtpSdlStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_mtpMIB2 above.
 */
uint8_t *
var_mtpSdlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "var_mtpSdlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_mtpSdlStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(mtpSdlStatsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_mtpSdlStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case MTPSDLSTATSRXOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsRxOctets);
		return (uint8_t *) &StorageTmp->mtpSdlStatsRxOctets;
	case MTPSDLSTATSTXOCTETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsTxOctets);
		return (uint8_t *) &StorageTmp->mtpSdlStatsTxOctets;
	case MTPSDLSTATSRXOVERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsRXOverruns);
		return (uint8_t *) &StorageTmp->mtpSdlStatsRXOverruns;
	case MTPSDLSTATSTXUNDERRUNS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsTxUnderruns);
		return (uint8_t *) &StorageTmp->mtpSdlStatsTxUnderruns;
	case MTPSDLSTATSRXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsRxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdlStatsRxBufferOverflows;
	case MTPSDLSTATSTXBUFFEROVERFLOWS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsTxBufferOverflows);
		return (uint8_t *) &StorageTmp->mtpSdlStatsTxBufferOverflows;
	case MTPSDLSTATSLEADCTSLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsLeadCtsLost);
		return (uint8_t *) &StorageTmp->mtpSdlStatsLeadCtsLost;
	case MTPSDLSTATSLEADDCDLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsLeadDcdLost);
		return (uint8_t *) &StorageTmp->mtpSdlStatsLeadDcdLost;
	case MTPSDLSTATSCARRIERLOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsCarrierLost);
		return (uint8_t *) &StorageTmp->mtpSdlStatsCarrierLost;
	case MTPSDLSTATSBIPOLARVIOLATIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->mtpSdlStatsBipolarViolations);
		return (uint8_t *) &StorageTmp->mtpSdlStatsBipolarViolations;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_mtpSapUserPart(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSapUserPart entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSapUserPart;
		StorageTmp->mtpSapUserPart = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPart = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapUserPartStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSapUserPartStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSapUserPartStatus;
		StorageTmp->mtpSapUserPartStatus = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapUserPartStatus = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapProviderEntityNames(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSapProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSapProviderEntityNames;
		tmplen = StorageTmp->mtpSapProviderEntityNamesLen;
		memdup((void *) &StorageTmp->mtpSapProviderEntityNames, var_val, var_val_len);
		StorageTmp->mtpSapProviderEntityNamesLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSapProviderEntityNames);
		StorageTmp->mtpSapProviderEntityNames = tmpvar;
		StorageTmp->mtpSapProviderEntityNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapAsaProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSapAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSapAsaProfilePointer;
		tmplen = StorageTmp->mtpSapAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSapAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSapAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSapAsaProfilePointer);
		StorageTmp->mtpSapAsaProfilePointer = tmpvar;
		StorageTmp->mtpSapAsaProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSapName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSapName;
		tmplen = StorageTmp->mtpSapNameLen;
		memdup((void *) &StorageTmp->mtpSapName, var_val, var_val_len);
		StorageTmp->mtpSapNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSapName);
		StorageTmp->mtpSapName = tmpvar;
		StorageTmp->mtpSapNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapLongMessageSupported(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSapLongMessageSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSapLongMessageSupported;
		StorageTmp->mtpSapLongMessageSupported = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSapLongMessageSupported = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_ss7NetworkProtocolStandard(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct ss7NetworkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_ss7NetworkProtocolStandard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(ss7NetworkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to ss7NetworkProtocolStandard not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->ss7NetworkProtocolStandard;
		StorageTmp->ss7NetworkProtocolStandard = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->ss7NetworkProtocolStandard = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_ss7NetworkProtocolYear(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct ss7NetworkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_ss7NetworkProtocolYear entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(ss7NetworkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to ss7NetworkProtocolYear not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->ss7NetworkProtocolYear;
		StorageTmp->ss7NetworkProtocolYear = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->ss7NetworkProtocolYear = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_ss7NetworkIndicator(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct ss7NetworkTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_ss7NetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(ss7NetworkTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to ss7NetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->ss7NetworkIndicator;
		StorageTmp->ss7NetworkIndicator = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->ss7NetworkIndicator = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsName;
		tmplen = StorageTmp->mtpMsNameLen;
		memdup((void *) &StorageTmp->mtpMsName, var_val, var_val_len);
		StorageTmp->mtpMsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsName);
		StorageTmp->mtpMsName = tmpvar;
		StorageTmp->mtpMsNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsAlarmStatus;
		tmplen = StorageTmp->mtpMsAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpMsAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpMsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsAlarmStatus);
		StorageTmp->mtpMsAlarmStatus = tmpvar;
		StorageTmp->mtpMsAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsManagedElementType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsManagedElementType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsManagedElementType not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsManagedElementType;
		tmplen = StorageTmp->mtpMsManagedElementTypeLen;
		memdup((void *) &StorageTmp->mtpMsManagedElementType, var_val, var_val_len);
		StorageTmp->mtpMsManagedElementTypeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsManagedElementType);
		StorageTmp->mtpMsManagedElementType = tmpvar;
		StorageTmp->mtpMsManagedElementTypeLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsModelCode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsModelCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsModelCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsModelCode;
		tmplen = StorageTmp->mtpMsModelCodeLen;
		memdup((void *) &StorageTmp->mtpMsModelCode, var_val, var_val_len);
		StorageTmp->mtpMsModelCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsModelCode);
		StorageTmp->mtpMsModelCode = tmpvar;
		StorageTmp->mtpMsModelCodeLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsVendorName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsVendorName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVendorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsVendorName;
		tmplen = StorageTmp->mtpMsVendorNameLen;
		memdup((void *) &StorageTmp->mtpMsVendorName, var_val, var_val_len);
		StorageTmp->mtpMsVendorNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsVendorName);
		StorageTmp->mtpMsVendorName = tmpvar;
		StorageTmp->mtpMsVendorNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsUserLabel(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsUserLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsUserLabel;
		tmplen = StorageTmp->mtpMsUserLabelLen;
		memdup((void *) &StorageTmp->mtpMsUserLabel, var_val, var_val_len);
		StorageTmp->mtpMsUserLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsUserLabel);
		StorageTmp->mtpMsUserLabel = tmpvar;
		StorageTmp->mtpMsUserLabelLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsVersion(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsVersion;
		tmplen = StorageTmp->mtpMsVersionLen;
		memdup((void *) &StorageTmp->mtpMsVersion, var_val, var_val_len);
		StorageTmp->mtpMsVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsVersion);
		StorageTmp->mtpMsVersion = tmpvar;
		StorageTmp->mtpMsVersionLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsAsaProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsAsaProfilePointer;
		tmplen = StorageTmp->mtpMsAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpMsAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsAsaProfilePointer);
		StorageTmp->mtpMsAsaProfilePointer = tmpvar;
		StorageTmp->mtpMsAsaProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsNetworkElementAliases(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpMsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpMsNetworkElementAliases entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpMsNetworkElementAliases;
		tmplen = StorageTmp->mtpMsNetworkElementAliasesLen;
		memdup((void *) &StorageTmp->mtpMsNetworkElementAliases, var_val, var_val_len);
		StorageTmp->mtpMsNetworkElementAliasesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpMsNetworkElementAliases);
		StorageTmp->mtpMsNetworkElementAliases = tmpvar;
		StorageTmp->mtpMsNetworkElementAliasesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolVariant(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolVariant;
		tmplen = StorageTmp->mtpNaProtocolVariantLen;
		memdup((void *) &StorageTmp->mtpNaProtocolVariant, var_val, var_val_len);
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
		StorageTmp->mtpNaProtocolVariant = tmpvar;
		StorageTmp->mtpNaProtocolVariantLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolYear(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolYear;
		StorageTmp->mtpNaProtocolYear = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaProtocolYear = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaProtocolOptions(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaProtocolOptions;
		tmplen = StorageTmp->mtpNaProtocolOptionsLen;
		memdup((void *) &StorageTmp->mtpNaProtocolOptions, var_val, var_val_len);
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
		StorageTmp->mtpNaProtocolOptions = tmpvar;
		StorageTmp->mtpNaProtocolOptionsLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaNetworkIndicator(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaNetworkIndicator;
		StorageTmp->mtpNaNetworkIndicator = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaNetworkIndicator = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaPointCodeFormat(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaPointCodeFormat;
		tmplen = StorageTmp->mtpNaPointCodeFormatLen;
		memdup((void *) &StorageTmp->mtpNaPointCodeFormat, var_val, var_val_len);
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
		StorageTmp->mtpNaPointCodeFormat = tmpvar;
		StorageTmp->mtpNaPointCodeFormatLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSlsLength(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaSlsLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaSlsLength;
		StorageTmp->mtpNaSlsLength = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNaSlsLength = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaSpDefault(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaSpDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaSpDefault;
		tmplen = StorageTmp->mtpNaSpDefaultLen;
		memdup((void *) &StorageTmp->mtpNaSpDefault, var_val, var_val_len);
		StorageTmp->mtpNaSpDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaSpDefault);
		StorageTmp->mtpNaSpDefault = tmpvar;
		StorageTmp->mtpNaSpDefaultLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpNaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNaName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNaName;
		tmplen = StorageTmp->mtpNaNameLen;
		memdup((void *) &StorageTmp->mtpNaName, var_val, var_val_len);
		StorageTmp->mtpNaNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpNaName);
		StorageTmp->mtpNaName = tmpvar;
		StorageTmp->mtpNaNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsAdministrativeState;
		StorageTmp->mtpGsAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsTreatmentOfOutsideRanges(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsTreatmentOfOutsideRanges;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsTreatmentOfOutsideRanges = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsListMode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsListMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsListMode;
		StorageTmp->mtpGsListMode = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsListMode = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsScreeningByLinkSetOrByOpc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsName;
		tmplen = StorageTmp->mtpGsNameLen;
		memdup((void *) &StorageTmp->mtpGsName, var_val, var_val_len);
		StorageTmp->mtpGsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsName);
		StorageTmp->mtpGsName = tmpvar;
		StorageTmp->mtpGsNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineObject(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineObject;
		tmplen = StorageTmp->mtpGsLineObjectLen;
		memdup((void *) &StorageTmp->mtpGsLineObject, var_val, var_val_len);
		StorageTmp->mtpGsLineObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsLineObject);
		StorageTmp->mtpGsLineObject = tmpvar;
		StorageTmp->mtpGsLineObjectLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContent(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineContent entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContent;
		StorageTmp->mtpGsLineContent = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContent = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentDesignatedDPCFirst(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineContentDesignatedDPCFirst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentDesignatedDPCFirst;
		tmplen = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		memdup((void *) &StorageTmp->mtpGsLineContentDesignatedDPCFirst, var_val, var_val_len);
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCFirst);
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = tmpvar;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentDesignatedDPCLast(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineContentDesignatedDPCLast entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentDesignatedDPCLast;
		tmplen = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		memdup((void *) &StorageTmp->mtpGsLineContentDesignatedDPCLast, var_val, var_val_len);
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCLast);
		StorageTmp->mtpGsLineContentDesignatedDPCLast = tmpvar;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentSiMask(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineContentSiMask entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentSiMask;
		tmplen = StorageTmp->mtpGsLineContentSiMaskLen;
		memdup((void *) &StorageTmp->mtpGsLineContentSiMask, var_val, var_val_len);
		StorageTmp->mtpGsLineContentSiMaskLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsLineContentSiMask);
		StorageTmp->mtpGsLineContentSiMask = tmpvar;
		StorageTmp->mtpGsLineContentSiMaskLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentMessageTreatment(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineContentMessageTreatment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentMessageTreatment;
		StorageTmp->mtpGsLineContentMessageTreatment = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpGsLineContentMessageTreatment = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentComment(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpGsLineContentComment entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpGsLineContentComment;
		tmplen = StorageTmp->mtpGsLineContentCommentLen;
		memdup((void *) &StorageTmp->mtpGsLineContentComment, var_val, var_val_len);
		StorageTmp->mtpGsLineContentCommentLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpGsLineContentComment);
		StorageTmp->mtpGsLineContentComment = tmpvar;
		StorageTmp->mtpGsLineContentCommentLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT1R(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT1R entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT1R;
		StorageTmp->mtpSpProfileTimerT1R = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1R = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT2;
		StorageTmp->mtpSpProfileTimerT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT4(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT4;
		StorageTmp->mtpSpProfileTimerT4 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT4 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT5(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT5;
		StorageTmp->mtpSpProfileTimerT5 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT5 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT7(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT7;
		StorageTmp->mtpSpProfileTimerT7 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT7 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT11(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT11;
		StorageTmp->mtpSpProfileTimerT11 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT11 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT12(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT12;
		StorageTmp->mtpSpProfileTimerT12 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT12 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT13(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT13;
		StorageTmp->mtpSpProfileTimerT13 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT13 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT14(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT14;
		StorageTmp->mtpSpProfileTimerT14 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT14 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT15(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT15;
		StorageTmp->mtpSpProfileTimerT15 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT15 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT16(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT16;
		StorageTmp->mtpSpProfileTimerT16 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT16 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT18I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT18I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT18I;
		StorageTmp->mtpSpProfileTimerT18I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT18I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT19I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT19I;
		StorageTmp->mtpSpProfileTimerT19I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT19I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT20I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT20I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT20I;
		StorageTmp->mtpSpProfileTimerT20I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT21I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT21I;
		StorageTmp->mtpSpProfileTimerT21I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT22I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT22I;
		StorageTmp->mtpSpProfileTimerT22I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT23I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT23I;
		StorageTmp->mtpSpProfileTimerT23I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT20A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT20A;
		StorageTmp->mtpSpProfileTimerT20A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT20A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT21A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT21A;
		StorageTmp->mtpSpProfileTimerT21A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT21A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT22A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT22A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT22A;
		StorageTmp->mtpSpProfileTimerT22A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT22A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT23A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT23A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT23A;
		StorageTmp->mtpSpProfileTimerT23A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT23A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT24A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT24A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT24A;
		StorageTmp->mtpSpProfileTimerT24A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT24A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT26A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT26A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT26A;
		StorageTmp->mtpSpProfileTimerT26A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT26A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT27A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT27A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT27A;
		StorageTmp->mtpSpProfileTimerT27A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT27A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT1T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT1T;
		StorageTmp->mtpSpProfileTimerT1T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT1T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileTimerT2T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileTimerT2T;
		StorageTmp->mtpSpProfileTimerT2T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpProfileTimerT2T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfileName;
		tmplen = StorageTmp->mtpSpProfileNameLen;
		memdup((void *) &StorageTmp->mtpSpProfileName, var_val, var_val_len);
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpProfileName);
		StorageTmp->mtpSpProfileName = tmpvar;
		StorageTmp->mtpSpProfileNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpPointCode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpPointCode;
		tmplen = StorageTmp->mtpSpPointCodeLen;
		memdup((void *) &StorageTmp->mtpSpPointCode, var_val, var_val_len);
		StorageTmp->mtpSpPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpPointCode);
		StorageTmp->mtpSpPointCode = tmpvar;
		StorageTmp->mtpSpPointCodeLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpType;
		StorageTmp->mtpSpType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpVersion(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpVersion;
		tmplen = StorageTmp->mtpSpVersionLen;
		memdup((void *) &StorageTmp->mtpSpVersion, var_val, var_val_len);
		StorageTmp->mtpSpVersionLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpVersion);
		StorageTmp->mtpSpVersion = tmpvar;
		StorageTmp->mtpSpVersionLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNetworkIndicator(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpNetworkIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpNetworkIndicator;
		StorageTmp->mtpSpNetworkIndicator = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpNetworkIndicator = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpName;
		tmplen = StorageTmp->mtpSpNameLen;
		memdup((void *) &StorageTmp->mtpSpName, var_val, var_val_len);
		StorageTmp->mtpSpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpName);
		StorageTmp->mtpSpName = tmpvar;
		StorageTmp->mtpSpNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT1;
		StorageTmp->mtpSpMtpT1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT2;
		StorageTmp->mtpSpMtpT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT3;
		StorageTmp->mtpSpMtpT3 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT4(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT4;
		StorageTmp->mtpSpMtpT4 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT4 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT5(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT5;
		StorageTmp->mtpSpMtpT5 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT5 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT6(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT6;
		StorageTmp->mtpSpMtpT6 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT6 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT7(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT7;
		StorageTmp->mtpSpMtpT7 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT7 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT8(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT8;
		StorageTmp->mtpSpMtpT8 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT8 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT10(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT10;
		StorageTmp->mtpSpMtpT10 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT10 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT11(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT11;
		StorageTmp->mtpSpMtpT11 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT11 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT12(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT12;
		StorageTmp->mtpSpMtpT12 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT12 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT13(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT13;
		StorageTmp->mtpSpMtpT13 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT13 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT14(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT14;
		StorageTmp->mtpSpMtpT14 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT14 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT15(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT15;
		StorageTmp->mtpSpMtpT15 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT15 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT16(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT16;
		StorageTmp->mtpSpMtpT16 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT16 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT17(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT17;
		StorageTmp->mtpSpMtpT17 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT17 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT19A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT19A;
		StorageTmp->mtpSpMtpT19A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT31A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT31A;
		StorageTmp->mtpSpMtpT31A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT31A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT32A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT32A;
		StorageTmp->mtpSpMtpT32A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT32A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT33A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT33A;
		StorageTmp->mtpSpMtpT33A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT33A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT34A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT34A;
		StorageTmp->mtpSpMtpT34A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT34A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT18I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT18I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT18I;
		StorageTmp->mtpSpMtpT18I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT18I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT19I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT19I;
		StorageTmp->mtpSpMtpT19I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT19I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT20I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT20I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT20I;
		StorageTmp->mtpSpMtpT20I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT21I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT21I;
		StorageTmp->mtpSpMtpT21I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT22I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT22I;
		StorageTmp->mtpSpMtpT22I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT22I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT23I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT23I;
		StorageTmp->mtpSpMtpT23I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT23I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT20A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT20A;
		StorageTmp->mtpSpMtpT20A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT20A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT21A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT21A;
		StorageTmp->mtpSpMtpT21A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT21A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT24I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT24I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT24I;
		StorageTmp->mtpSpMtpT24I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT24I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT1T;
		StorageTmp->mtpSpMtpT1T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT2T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT2T;
		StorageTmp->mtpSpMtpT2T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT2T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpMtpT1S(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpMtpT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpMtpT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpMtpT1S;
		StorageTmp->mtpSpMtpT1S = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSpMtpT1S = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpProfilePointer;
		tmplen = StorageTmp->mtpSpProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSpProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSpProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpProfilePointer);
		StorageTmp->mtpSpProfilePointer = tmpvar;
		StorageTmp->mtpSpProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpNaPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpNaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpNaPointer;
		tmplen = StorageTmp->mtpSpNaPointerLen;
		memdup((void *) &StorageTmp->mtpSpNaPointer, var_val, var_val_len);
		StorageTmp->mtpSpNaPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpNaPointer);
		StorageTmp->mtpSpNaPointer = tmpvar;
		StorageTmp->mtpSpNaPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpFlags(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpFlags;
		tmplen = StorageTmp->mtpSpFlagsLen;
		memdup((void *) &StorageTmp->mtpSpFlags, var_val, var_val_len);
		StorageTmp->mtpSpFlagsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpFlags);
		StorageTmp->mtpSpFlags = tmpvar;
		StorageTmp->mtpSpFlagsLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpUsers(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpUsers entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpUsers;
		tmplen = StorageTmp->mtpSpUsersLen;
		memdup((void *) &StorageTmp->mtpSpUsers, var_val, var_val_len);
		StorageTmp->mtpSpUsersLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpUsers);
		StorageTmp->mtpSpUsers = tmpvar;
		StorageTmp->mtpSpUsersLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSpAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSpAlarmStatus;
		tmplen = StorageTmp->mtpSpAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpSpAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpSpAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSpAlarmStatus);
		StorageTmp->mtpSpAlarmStatus = tmpvar;
		StorageTmp->mtpSpAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3AdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpL3Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL3AdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpL3AdministrativeState;
		StorageTmp->mtpL3AdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpL3AdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3AsaProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpL3Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL3AsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpL3AsaProfilePointer;
		tmplen = StorageTmp->mtpL3AsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpL3AsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpL3AsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL3AsaProfilePointer);
		StorageTmp->mtpL3AsaProfilePointer = tmpvar;
		StorageTmp->mtpL3AsaProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3Name(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpL3Table_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpL3Name entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpL3Name;
		tmplen = StorageTmp->mtpL3NameLen;
		memdup((void *) &StorageTmp->mtpL3Name, var_val, var_val_len);
		StorageTmp->mtpL3NameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpL3Name);
		StorageTmp->mtpL3Name = tmpvar;
		StorageTmp->mtpL3NameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileName;
		tmplen = StorageTmp->mtpRsProfileNameLen;
		memdup((void *) &StorageTmp->mtpRsProfileName, var_val, var_val_len);
		StorageTmp->mtpRsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsProfileName);
		StorageTmp->mtpRsProfileName = tmpvar;
		StorageTmp->mtpRsProfileNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT8(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT8;
		StorageTmp->mtpRsProfileTimerT8 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT8 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT11(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT11 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT11;
		StorageTmp->mtpRsProfileTimerT11 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT11 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT15(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT15 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT15;
		StorageTmp->mtpRsProfileTimerT15 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT15 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT16(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT16 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT16;
		StorageTmp->mtpRsProfileTimerT16 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT16 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileTimerT18A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileTimerT18A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileTimerT18A;
		StorageTmp->mtpRsProfileTimerT18A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsProfileTimerT18A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileRtDefault(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfileRtDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfileRtDefault;
		tmplen = StorageTmp->mtpRsProfileRtDefaultLen;
		memdup((void *) &StorageTmp->mtpRsProfileRtDefault, var_val, var_val_len);
		StorageTmp->mtpRsProfileRtDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsProfileRtDefault);
		StorageTmp->mtpRsProfileRtDefault = tmpvar;
		StorageTmp->mtpRsProfileRtDefaultLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsDest(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsDest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsDest;
		tmplen = StorageTmp->mtpRsDestLen;
		memdup((void *) &StorageTmp->mtpRsDest, var_val, var_val_len);
		StorageTmp->mtpRsDestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsDest);
		StorageTmp->mtpRsDest = tmpvar;
		StorageTmp->mtpRsDestLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsFlags(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsFlags entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsFlags not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsFlags;
		tmplen = StorageTmp->mtpRsFlagsLen;
		memdup((void *) &StorageTmp->mtpRsFlags, var_val, var_val_len);
		StorageTmp->mtpRsFlagsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsFlags);
		StorageTmp->mtpRsFlags = tmpvar;
		StorageTmp->mtpRsFlagsLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsAdministrativeState;
		StorageTmp->mtpRsAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAsaProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsAsaProfilePointer;
		tmplen = StorageTmp->mtpRsAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpRsAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpRsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsAsaProfilePointer);
		StorageTmp->mtpRsAsaProfilePointer = tmpvar;
		StorageTmp->mtpRsAsaProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingInformation(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsLoadsharingInformation;
		tmplen = StorageTmp->mtpRsLoadsharingInformationLen;
		memdup((void *) &StorageTmp->mtpRsLoadsharingInformation, var_val, var_val_len);
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
		StorageTmp->mtpRsLoadsharingInformation = tmpvar;
		StorageTmp->mtpRsLoadsharingInformationLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsLoadsharingObject(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsLoadsharingObject;
		tmplen = StorageTmp->mtpRsLoadsharingObjectLen;
		memdup((void *) &StorageTmp->mtpRsLoadsharingObject, var_val, var_val_len);
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
		StorageTmp->mtpRsLoadsharingObject = tmpvar;
		StorageTmp->mtpRsLoadsharingObjectLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRemoteExchangeLabel(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsRemoteExchangeLabel;
		tmplen = StorageTmp->mtpRsRemoteExchangeLabelLen;
		memdup((void *) &StorageTmp->mtpRsRemoteExchangeLabel, var_val, var_val_len);
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
		StorageTmp->mtpRsRemoteExchangeLabel = tmpvar;
		StorageTmp->mtpRsRemoteExchangeLabelLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsName;
		tmplen = StorageTmp->mtpRsNameLen;
		memdup((void *) &StorageTmp->mtpRsName, var_val, var_val_len);
		StorageTmp->mtpRsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsName);
		StorageTmp->mtpRsName = tmpvar;
		StorageTmp->mtpRsNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfile(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsProfile;
		tmplen = StorageTmp->mtpRsProfileLen;
		memdup((void *) &StorageTmp->mtpRsProfile, var_val, var_val_len);
		StorageTmp->mtpRsProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsProfile);
		StorageTmp->mtpRsProfile = tmpvar;
		StorageTmp->mtpRsProfileLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsAlarmStatus;
		tmplen = StorageTmp->mtpRsAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpRsAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpRsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRsAlarmStatus);
		StorageTmp->mtpRsAlarmStatus = tmpvar;
		StorageTmp->mtpRsAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentValidIntervals(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentValidIntervals;
		StorageTmp->mtpRsCurrentValidIntervals = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentValidIntervals = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTimeDiscontinuity(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTimeDiscontinuity;
		StorageTmp->mtpRsCurrentTimeDiscontinuity = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTimeDiscontinuity = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentReceivedOctetsOPC(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentReceivedOctetsOPC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentReceivedOctetsOPC not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentReceivedOctetsOPC;
		StorageTmp->mtpRsCurrentReceivedOctetsOPC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentReceivedOctetsOPC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTransmittedOctetsDPC(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentTransmittedOctetsDPC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTransmittedOctetsDPC not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTransmittedOctetsDPC;
		StorageTmp->mtpRsCurrentTransmittedOctetsDPC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTransmittedOctetsDPC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentReceivedMSUsOpc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentReceivedMSUsOpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentReceivedMSUsOpc not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentReceivedMSUsOpc;
		StorageTmp->mtpRsCurrentReceivedMSUsOpc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentReceivedMSUsOpc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentTransmittedMSUsDpc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentTransmittedMSUsDpc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentTransmittedMSUsDpc not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentTransmittedMSUsDpc;
		StorageTmp->mtpRsCurrentTransmittedMSUsDpc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentTransmittedMSUsDpc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentRouteSetUnavailable(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentRouteSetUnavailable entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentRouteSetUnavailable not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentRouteSetUnavailable;
		StorageTmp->mtpRsCurrentRouteSetUnavailable = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentRouteSetUnavailable = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsCurrentRouteSetUnavailableDuration(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsCurrentRouteSetUnavailableDuration entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsCurrentRouteSetUnavailableDuration not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsCurrentRouteSetUnavailableDuration;
		StorageTmp->mtpRsCurrentRouteSetUnavailableDuration = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsCurrentRouteSetUnavailableDuration = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiValidIntervals(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiValidIntervals;
		StorageTmp->mtpRsSiValidIntervals = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiValidIntervals = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTimeDiscontinuity(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTimeDiscontinuity;
		StorageTmp->mtpRsSiTimeDiscontinuity = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTimeDiscontinuity = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiReceivedOctetsOpcSio(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiReceivedOctetsOpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiReceivedOctetsOpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiReceivedOctetsOpcSio;
		StorageTmp->mtpRsSiReceivedOctetsOpcSio = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiReceivedOctetsOpcSio = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTransmittedOctetsDpcSio(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiTransmittedOctetsDpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTransmittedOctetsDpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTransmittedOctetsDpcSio;
		StorageTmp->mtpRsSiTransmittedOctetsDpcSio = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTransmittedOctetsDpcSio = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiReceivedMSUsOpcSio(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiReceivedMSUsOpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiReceivedMSUsOpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiReceivedMSUsOpcSio;
		StorageTmp->mtpRsSiReceivedMSUsOpcSio = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiReceivedMSUsOpcSio = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiTransmittedMSUsDpcSio(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRsSiTransmittedMSUsDpcSio entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiTransmittedMSUsDpcSio not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRsSiTransmittedMSUsDpcSio;
		StorageTmp->mtpRsSiTransmittedMSUsDpcSio = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRsSiTransmittedMSUsDpcSio = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileTimerT6(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfileTimerT6;
		StorageTmp->mtpRtProfileTimerT6 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT6 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileTimerT10(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfileTimerT10;
		StorageTmp->mtpRtProfileTimerT10 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtProfileTimerT10 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLsPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtLsPointer;
		tmplen = StorageTmp->mtpRtLsPointerLen;
		memdup((void *) &StorageTmp->mtpRtLsPointer, var_val, var_val_len);
		StorageTmp->mtpRtLsPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLsPointer);
		StorageTmp->mtpRtLsPointer = tmpvar;
		StorageTmp->mtpRtLsPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtAdministrativeState;
		StorageTmp->mtpRtAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtInClsLoadsharingAlgorithm(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtInClsLoadsharingAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFixedPriority(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtFixedPriority;
		StorageTmp->mtpRtFixedPriority = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFixedPriority = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtFlexiblePriority(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtFlexiblePriority;
		StorageTmp->mtpRtFlexiblePriority = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtFlexiblePriority = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtPriorityMode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtPriorityMode;
		StorageTmp->mtpRtPriorityMode = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtPriorityMode = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingInformation(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtLoadsharingInformation;
		tmplen = StorageTmp->mtpRtLoadsharingInformationLen;
		memdup((void *) &StorageTmp->mtpRtLoadsharingInformation, var_val, var_val_len);
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
		StorageTmp->mtpRtLoadsharingInformation = tmpvar;
		StorageTmp->mtpRtLoadsharingInformationLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLoadsharingObject(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtLoadsharingObject;
		tmplen = StorageTmp->mtpRtLoadsharingObjectLen;
		memdup((void *) &StorageTmp->mtpRtLoadsharingObject, var_val, var_val_len);
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
		StorageTmp->mtpRtLoadsharingObject = tmpvar;
		StorageTmp->mtpRtLoadsharingObjectLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtName;
		tmplen = StorageTmp->mtpRtNameLen;
		memdup((void *) &StorageTmp->mtpRtName, var_val, var_val_len);
		StorageTmp->mtpRtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtName);
		StorageTmp->mtpRtName = tmpvar;
		StorageTmp->mtpRtNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtSlsList(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtSlsList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtSlsList;
		tmplen = StorageTmp->mtpRtSlsListLen;
		memdup((void *) &StorageTmp->mtpRtSlsList, var_val, var_val_len);
		StorageTmp->mtpRtSlsListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtSlsList);
		StorageTmp->mtpRtSlsList = tmpvar;
		StorageTmp->mtpRtSlsListLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRlSlot(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtRlSlot entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtRlSlot;
		StorageTmp->mtpRtRlSlot = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtRlSlot = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfile(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtProfile;
		tmplen = StorageTmp->mtpRtProfileLen;
		memdup((void *) &StorageTmp->mtpRtProfile, var_val, var_val_len);
		StorageTmp->mtpRtProfileLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtProfile);
		StorageTmp->mtpRtProfile = tmpvar;
		StorageTmp->mtpRtProfileLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsaNormalSlCode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLsaNormalSlCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtLsaNormalSlCode;
		StorageTmp->mtpRtLsaNormalSlCode = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpRtLsaNormalSlCode = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtLsaAlternativeSlCodeList(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpRtLsaAlternativeSlCodeList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpRtLsaAlternativeSlCodeList;
		tmplen = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		memdup((void *) &StorageTmp->mtpRtLsaAlternativeSlCodeList, var_val, var_val_len);
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpRtLsaAlternativeSlCodeList);
		StorageTmp->mtpRtLsaAlternativeSlCodeList = tmpvar;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT6(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT6;
		StorageTmp->mtpLsProfileTimerT6 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT6 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT8(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT8;
		StorageTmp->mtpLsProfileTimerT8 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT8 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT10(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT10 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT10;
		StorageTmp->mtpLsProfileTimerT10 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT10 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT7(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT7;
		StorageTmp->mtpLsProfileTimerT7 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT7 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT19I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT19I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT19I;
		StorageTmp->mtpLsProfileTimerT19I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT19I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT21I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT21I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT21I;
		StorageTmp->mtpLsProfileTimerT21I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT21I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT25A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT25A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT25A;
		StorageTmp->mtpLsProfileTimerT25A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT25A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT28A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT28A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT28A;
		StorageTmp->mtpLsProfileTimerT28A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT28A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT29A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT29A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT29A;
		StorageTmp->mtpLsProfileTimerT29A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT29A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileTimerT30A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileTimerT30A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileTimerT30A;
		StorageTmp->mtpLsProfileTimerT30A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsProfileTimerT30A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileName;
		tmplen = StorageTmp->mtpLsProfileNameLen;
		memdup((void *) &StorageTmp->mtpLsProfileName, var_val, var_val_len);
		StorageTmp->mtpLsProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsProfileName);
		StorageTmp->mtpLsProfileName = tmpvar;
		StorageTmp->mtpLsProfileNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileSlDefault(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfileSlDefault entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfileSlDefault;
		tmplen = StorageTmp->mtpLsProfileSlDefaultLen;
		memdup((void *) &StorageTmp->mtpLsProfileSlDefault, var_val, var_val_len);
		StorageTmp->mtpLsProfileSlDefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsProfileSlDefault);
		StorageTmp->mtpLsProfileSlDefault = tmpvar;
		StorageTmp->mtpLsProfileSlDefaultLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdjPc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsAdjPc;
		tmplen = StorageTmp->mtpLsAdjPcLen;
		memdup((void *) &StorageTmp->mtpLsAdjPc, var_val, var_val_len);
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAdjPc);
		StorageTmp->mtpLsAdjPc = tmpvar;
		StorageTmp->mtpLsAdjPcLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsRsId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsRsId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsRsId;
		tmplen = StorageTmp->mtpLsRsIdLen;
		memdup((void *) &StorageTmp->mtpLsRsId, var_val, var_val_len);
		StorageTmp->mtpLsRsIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsRsId);
		StorageTmp->mtpLsRsId = tmpvar;
		StorageTmp->mtpLsRsIdLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsMaxCapacity(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsMaxCapacity;
		StorageTmp->mtpLsMaxCapacity = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsMaxCapacity = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCongestionControlMethod(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsCongestionControlMethod;
		StorageTmp->mtpLsCongestionControlMethod = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCongestionControlMethod = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsPeriodicLinkTestFlag(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsPeriodicLinkTestFlag;
		StorageTmp->mtpLsPeriodicLinkTestFlag = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFlag = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsPeriodicLinkTestFail(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsPeriodicLinkTestFail entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsPeriodicLinkTestFail;
		StorageTmp->mtpLsPeriodicLinkTestFail = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsPeriodicLinkTestFail = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsAdministrativeState;
		StorageTmp->mtpLsAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsInLsLoadShareAlgorithm(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsInLsLoadShareAlgorithm;
		tmplen = StorageTmp->mtpLsInLsLoadShareAlgorithmLen;
		memdup((void *) &StorageTmp->mtpLsInLsLoadShareAlgorithm, var_val, var_val_len);
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
		StorageTmp->mtpLsInLsLoadShareAlgorithm = tmpvar;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsProfilePointer;
		tmplen = StorageTmp->mtpLsProfilePointerLen;
		memdup((void *) &StorageTmp->mtpLsProfilePointer, var_val, var_val_len);
		StorageTmp->mtpLsProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsProfilePointer);
		StorageTmp->mtpLsProfilePointer = tmpvar;
		StorageTmp->mtpLsProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsNumberOfNormallyActiveSignLinks(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsNumberOfNormallyActiveSignLinks entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsName;
		tmplen = StorageTmp->mtpLsNameLen;
		memdup((void *) &StorageTmp->mtpLsName, var_val, var_val_len);
		StorageTmp->mtpLsNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsName);
		StorageTmp->mtpLsName = tmpvar;
		StorageTmp->mtpLsNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAsaProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsAsaProfilePointer;
		tmplen = StorageTmp->mtpLsAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpLsAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpLsAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAsaProfilePointer);
		StorageTmp->mtpLsAsaProfilePointer = tmpvar;
		StorageTmp->mtpLsAsaProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpLsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsAlarmStatus;
		tmplen = StorageTmp->mtpLsAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpLsAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpLsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpLsAlarmStatus);
		StorageTmp->mtpLsAlarmStatus = tmpvar;
		StorageTmp->mtpLsAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentValidIntervals(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCurrentValidIntervals entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentValidIntervals;
		StorageTmp->mtpLsCurrentValidIntervals = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentValidIntervals = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentTimeDiscontinuity(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCurrentTimeDiscontinuity entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentTimeDiscontinuity;
		StorageTmp->mtpLsCurrentTimeDiscontinuity = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentTimeDiscontinuity = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentAdjacentInaccessibleEvents(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCurrentAdjacentInaccessibleEvents entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentAdjacentInaccessibleEvents not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents;
		StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentAdjacentInaccessibleEvents = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentAdjacentInaccessibleDuration(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCurrentAdjacentInaccessibleDuration entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentAdjacentInaccessibleDuration not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration;
		StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentAdjacentInaccessibleDuration = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsCurrentSlsUnavailable(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpLsCurrentTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpLsCurrentSlsUnavailable entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpLsCurrentTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_GAUGE) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCurrentSlsUnavailable not ASN_GAUGE\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpLsCurrentSlsUnavailable;
		StorageTmp->mtpLsCurrentSlsUnavailable = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpLsCurrentSlsUnavailable = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT1;
		StorageTmp->mtpSlL3ProfileTimerT1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT3;
		StorageTmp->mtpSlL3ProfileTimerT3 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT17(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT17 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT17;
		StorageTmp->mtpSlL3ProfileTimerT17 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT17 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT24I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT24I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT24I;
		StorageTmp->mtpSlL3ProfileTimerT24I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT24I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileName;
		tmplen = StorageTmp->mtpSlL3ProfileNameLen;
		memdup((void *) &StorageTmp->mtpSlL3ProfileName, var_val, var_val_len);
		StorageTmp->mtpSlL3ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlL3ProfileName);
		StorageTmp->mtpSlL3ProfileName = tmpvar;
		StorageTmp->mtpSlL3ProfileNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT2;
		StorageTmp->mtpSlL3ProfileTimerT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT4(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT4;
		StorageTmp->mtpSlL3ProfileTimerT4 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT4 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT5(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT5;
		StorageTmp->mtpSlL3ProfileTimerT5 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT5 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT12(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT12 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT12;
		StorageTmp->mtpSlL3ProfileTimerT12 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT12 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT13(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT13 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT13;
		StorageTmp->mtpSlL3ProfileTimerT13 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT13 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT14(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT14 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT14;
		StorageTmp->mtpSlL3ProfileTimerT14 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT14 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT19A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT19A;
		StorageTmp->mtpSlL3ProfileTimerT19A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT19A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT20A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT20A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT20A;
		StorageTmp->mtpSlL3ProfileTimerT20A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT20A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT21A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT21A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT21A;
		StorageTmp->mtpSlL3ProfileTimerT21A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT21A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT22I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT22I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT22I;
		StorageTmp->mtpSlL3ProfileTimerT22I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT22I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT23I(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT23I entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT23I;
		StorageTmp->mtpSlL3ProfileTimerT23I = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT23I = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT31A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT31A;
		StorageTmp->mtpSlL3ProfileTimerT31A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT31A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT32A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT32A;
		StorageTmp->mtpSlL3ProfileTimerT32A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT32A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT33A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT33A;
		StorageTmp->mtpSlL3ProfileTimerT33A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT33A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT34A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT34A;
		StorageTmp->mtpSlL3ProfileTimerT34A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT34A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT1T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT1T;
		StorageTmp->mtpSlL3ProfileTimerT1T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT2T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT2T;
		StorageTmp->mtpSlL3ProfileTimerT2T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT2T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileTimerT1S(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileTimerT1S entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileTimerT1S;
		StorageTmp->mtpSlL3ProfileTimerT1S = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL3ProfileTimerT1S = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileL2Default(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfileL2Default entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfileL2Default;
		tmplen = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		memdup((void *) &StorageTmp->mtpSlL3ProfileL2Default, var_val, var_val_len);
		StorageTmp->mtpSlL3ProfileL2DefaultLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlL3ProfileL2Default);
		StorageTmp->mtpSlL3ProfileL2Default = tmpvar;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileErrorCorrectionMethod(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileErrorCorrectionMethod entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTransmissionRate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTransmissionRate;
		StorageTmp->mtpSlL2ProfileTransmissionRate = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTransmissionRate = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT1;
		StorageTmp->mtpSlL2ProfileTimerT1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT2;
		StorageTmp->mtpSlL2ProfileTimerT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT2L(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT2L entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT2L;
		StorageTmp->mtpSlL2ProfileTimerT2L = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2L = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT2H(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT2H entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT2H;
		StorageTmp->mtpSlL2ProfileTimerT2H = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT2H = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT3;
		StorageTmp->mtpSlL2ProfileTimerT3 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT4N(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT4N entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT4N;
		StorageTmp->mtpSlL2ProfileTimerT4N = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4N = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT4E(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT4E entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT4E;
		StorageTmp->mtpSlL2ProfileTimerT4E = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT4E = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT5(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT5;
		StorageTmp->mtpSlL2ProfileTimerT5 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT5 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT6(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT6;
		StorageTmp->mtpSlL2ProfileTimerT6 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT6 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerT7(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerT7;
		StorageTmp->mtpSlL2ProfileTimerT7 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerT7 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbOnset1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbOnset1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbOnset1;
		StorageTmp->mtpSlL2ProfileTbOnset1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbAbate1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbAbate1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbAbate1;
		StorageTmp->mtpSlL2ProfileTbAbate1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileNumberOfThresholdLevels(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileNumberOfThresholdLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileCongestionCounting(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileCongestionCounting entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileCongestionCounting;
		StorageTmp->mtpSlL2ProfileCongestionCounting = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionCounting = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileCongestionReportingBaseObject(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileCongestionReportingBaseObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileLoopDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileLoopDelay;
		StorageTmp->mtpSlL2ProfileLoopDelay = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileLoopDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileName;
		tmplen = StorageTmp->mtpSlL2ProfileNameLen;
		memdup((void *) &StorageTmp->mtpSlL2ProfileName, var_val, var_val_len);
		StorageTmp->mtpSlL2ProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlL2ProfileName);
		StorageTmp->mtpSlL2ProfileName = tmpvar;
		StorageTmp->mtpSlL2ProfileNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbOnset2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbOnset2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbOnset2;
		StorageTmp->mtpSlL2ProfileTbOnset2 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbAbate2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbAbate2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbAbate2;
		StorageTmp->mtpSlL2ProfileTbAbate2 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbOnset3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbOnset3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbOnset3;
		StorageTmp->mtpSlL2ProfileTbOnset3 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbOnset3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbAbate3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbAbate3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbAbate3;
		StorageTmp->mtpSlL2ProfileTbAbate3 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbAbate3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbDiscard1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbDiscard1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbDiscard1;
		StorageTmp->mtpSlL2ProfileTbDiscard1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbDiscard2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbDiscard2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbDiscard2;
		StorageTmp->mtpSlL2ProfileTbDiscard2 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTbDiscard3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTbDiscard3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTbDiscard3;
		StorageTmp->mtpSlL2ProfileTbDiscard3 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTbDiscard3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerTx(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerTx entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerTx;
		StorageTmp->mtpSlL2ProfileTimerTx = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTx = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileTimerTy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileTimerTy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileTimerTy;
		StorageTmp->mtpSlL2ProfileTimerTy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileTimerTy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileNumberOfCongestionStates(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileNumberOfCongestionStates entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileInitialLevelOfCongestion(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileInitialLevelOfCongestion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileMaxMSUsRetransN1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileMaxMSUsRetransN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileMaxOctRetransN2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileMaxOctRetransN2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileReceiveCongestionThresholdOnset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileReceiveCongestionThresholdAbate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileReceiveCongestionThresholdDiscard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileM(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL2ProfileM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL2ProfileM;
		StorageTmp->mtpSlL2ProfileM = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlL2ProfileM = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeCurrentList(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSlsCodeCurrentList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeCurrentList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSlsCodeCurrentList;
		tmplen = StorageTmp->mtpSlSlsCodeCurrentListLen;
		memdup((void *) &StorageTmp->mtpSlSlsCodeCurrentList, var_val, var_val_len);
		StorageTmp->mtpSlSlsCodeCurrentListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSlsCodeCurrentList);
		StorageTmp->mtpSlSlsCodeCurrentList = tmpvar;
		StorageTmp->mtpSlSlsCodeCurrentListLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlMaxCapacitySL(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlMaxCapacitySL entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMaxCapacitySL not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlMaxCapacitySL;
		StorageTmp->mtpSlMaxCapacitySL = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlMaxCapacitySL = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlAdministrativeState;
		StorageTmp->mtpSlAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlMtpL2ProtocolProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlMtpL2ProtocolProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
		tmplen = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlMtpL2ProtocolProfilePointer);
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = tmpvar;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSignTermPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSignTermPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSignTermPointer;
		tmplen = StorageTmp->mtpSlSignTermPointerLen;
		memdup((void *) &StorageTmp->mtpSlSignTermPointer, var_val, var_val_len);
		StorageTmp->mtpSlSignTermPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSignTermPointer);
		StorageTmp->mtpSlSignTermPointer = tmpvar;
		StorageTmp->mtpSlSignTermPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSignDataLinkTpPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSignDataLinkTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSignDataLinkTpPointer;
		tmplen = StorageTmp->mtpSlSignDataLinkTpPointerLen;
		memdup((void *) &StorageTmp->mtpSlSignDataLinkTpPointer, var_val, var_val_len);
		StorageTmp->mtpSlSignDataLinkTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSignDataLinkTpPointer);
		StorageTmp->mtpSlSignDataLinkTpPointer = tmpvar;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalInhibit(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlLocalInhibit;
		StorageTmp->mtpSlLocalInhibit = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalInhibit = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlLocalUninhibit(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlLocalUninhibit;
		StorageTmp->mtpSlLocalUninhibit = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlLocalUninhibit = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlReplaceSt(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlReplaceSt;
		StorageTmp->mtpSlReplaceSt = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlReplaceSt = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAsaProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlAsaProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlAsaProfilePointer;
		tmplen = StorageTmp->mtpSlAsaProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSlAsaProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSlAsaProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlAsaProfilePointer);
		StorageTmp->mtpSlAsaProfilePointer = tmpvar;
		StorageTmp->mtpSlAsaProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRelatedLinkGroupNumber(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlRelatedLinkGroupNumber;
		StorageTmp->mtpSlRelatedLinkGroupNumber = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlRelatedLinkGroupNumber = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlList(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdlList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdlList;
		StorageTmp->mtpSlSdlList = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdlList = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlTest(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlTest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlTest;
		StorageTmp->mtpSlTest = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlTest = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlName;
		tmplen = StorageTmp->mtpSlNameLen;
		memdup((void *) &StorageTmp->mtpSlName, var_val, var_val_len);
		StorageTmp->mtpSlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlName);
		StorageTmp->mtpSlName = tmpvar;
		StorageTmp->mtpSlNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtList(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdtList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdtList;
		StorageTmp->mtpSlSdtList = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSlSdtList = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSlsCodeNormalList(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSlsCodeNormalList;
		tmplen = StorageTmp->mtpSlSlsCodeNormalListLen;
		memdup((void *) &StorageTmp->mtpSlSlsCodeNormalList, var_val, var_val_len);
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
		StorageTmp->mtpSlSlsCodeNormalList = tmpvar;
		StorageTmp->mtpSlSlsCodeNormalListLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlL3ProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlL3ProfilePointer;
		tmplen = StorageTmp->mtpSlL3ProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSlL3ProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSlL3ProfilePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlL3ProfilePointer);
		StorageTmp->mtpSlL3ProfilePointer = tmpvar;
		StorageTmp->mtpSlL3ProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlAlarmStatus;
		tmplen = StorageTmp->mtpSlAlarmStatusLen;
		memdup((void *) &StorageTmp->mtpSlAlarmStatus, var_val, var_val_len);
		StorageTmp->mtpSlAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlAlarmStatus);
		StorageTmp->mtpSlAlarmStatus = tmpvar;
		StorageTmp->mtpSlAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdlListPointer;
		tmplen = StorageTmp->mtpSlSdlListPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdlListPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
		StorageTmp->mtpSlSdlListPointer = tmpvar;
		StorageTmp->mtpSlSdlListPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSlSdtListPointer;
		tmplen = StorageTmp->mtpSlSdtListPointerLen;
		memdup((void *) &StorageTmp->mtpSlSdtListPointer, var_val, var_val_len);
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
		StorageTmp->mtpSlSdtListPointer = tmpvar;
		StorageTmp->mtpSlSdtListPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTransmissionRate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbTransmissionRate;
		StorageTmp->mtpNbTransmissionRate = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTransmissionRate = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTimerT8(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbTimerT8 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTimerT8 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbTimerT8;
		StorageTmp->mtpNbTimerT8 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTimerT8 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTin(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbTin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbTin;
		StorageTmp->mtpNbTin = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTin = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTie(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbTie entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTie not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbTie;
		StorageTmp->mtpNbTie = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTie = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbT not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbT;
		StorageTmp->mtpNbT = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbT = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbD(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbD entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbD not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbD;
		StorageTmp->mtpNbD = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbD = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbTe(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbTe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbTe;
		StorageTmp->mtpNbTe = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbTe = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbDe(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbDe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbDe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbDe;
		StorageTmp->mtpNbDe = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbDe = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbUe(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbUe entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbUe not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbUe;
		StorageTmp->mtpNbUe = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbUe = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbN(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbN entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbN not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbN;
		StorageTmp->mtpNbN = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbN = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbm(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbm entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbm;
		StorageTmp->mtpNbm = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbm = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbb(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbb entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbb not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbb;
		StorageTmp->mtpNbb = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbb = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbf(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpNbTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpNbf entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpNbf;
		StorageTmp->mtpNbf = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpNbf = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalBufferRelease(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalBufferRelease;
		StorageTmp->mtpSaalBufferRelease = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalBufferRelease = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxCc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxCc;
		StorageTmp->mtpSaalMaxCc = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxCc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxNrp(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxNrp;
		StorageTmp->mtpSaalMaxNrp = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxNrp = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxInformationFieldLength(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxInformationFieldLength;
		StorageTmp->mtpSaalMaxInformationFieldLength = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxInformationFieldLength = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxLengthSscopUuField(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxLengthSscopUuField;
		StorageTmp->mtpSaalMaxLengthSscopUuField = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxLengthSscopUuField = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxPd(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxPd;
		StorageTmp->mtpSaalMaxPd = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxPd = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxSscopCreditToPeer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxSscopCreditToPeer;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxSscopCreditToPeer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalMaxStat(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalMaxStat;
		StorageTmp->mtpSaalMaxStat = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalMaxStat = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalN1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalN1;
		StorageTmp->mtpSaalN1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalN1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementProvingState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementProvingState;
		StorageTmp->mtpSaalNniLayerManagementProvingState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementProvingState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT1;
		StorageTmp->mtpSaalNniTimerT1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT2;
		StorageTmp->mtpSaalNniTimerT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalNniTimerT3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalNniTimerT3;
		StorageTmp->mtpSaalNniTimerT3 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalNniTimerT3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerCc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerCc;
		StorageTmp->mtpSaalSscopTimerCc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerCc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerIdle(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerIdle;
		StorageTmp->mtpSaalSscopTimerIdle = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerIdle = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerKeepAlive(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerKeepAlive;
		StorageTmp->mtpSaalSscopTimerKeepAlive = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerKeepAlive = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerNoResponse(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerNoResponse;
		StorageTmp->mtpSaalSscopTimerNoResponse = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerNoResponse = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalSscopTimerPoll(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalSscopTimerPoll;
		StorageTmp->mtpSaalSscopTimerPoll = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalSscopTimerPoll = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalLower(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalTransmissionRateIntervalLower;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalLower = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalTransmissionRateIntervalUpper(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalPollAfterRetransmission(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSaalTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSaalPollAfterRetransmission;
		StorageTmp->mtpSaalPollAfterRetransmission = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSaalPollAfterRetransmission = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paN1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paN1;
		StorageTmp->mtpM2paN1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paN1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProving(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paProving entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paProving;
		StorageTmp->mtpM2paProving = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProving = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paManagementProvingState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paManagementProvingState;
		StorageTmp->mtpM2paManagementProvingState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paManagementProvingState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayLower(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paLoopDelayLower;
		StorageTmp->mtpM2paLoopDelayLower = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayLower = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paLoopDelayUpper(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paLoopDelayUpper;
		StorageTmp->mtpM2paLoopDelayUpper = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paLoopDelayUpper = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalLower(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paTransmissionRateIntervalLower;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalLower = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paTransmissionRateIntervalUpper(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpNoDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpNoDelay;
		StorageTmp->mtpM2paSctpNoDelay = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpNoDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxseg(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxseg;
		StorageTmp->mtpM2paSctpMaxseg = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxseg = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeatItvl(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpHeartbeatItvl;
		StorageTmp->mtpM2paSctpHeartbeatItvl = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeatItvl = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpHeartbeat(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpHeartbeat;
		StorageTmp->mtpM2paSctpHeartbeat = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpHeartbeat = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoInitial(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoInitial;
		StorageTmp->mtpM2paSctpRtoInitial = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoInitial = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMin(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoMin;
		StorageTmp->mtpM2paSctpRtoMin = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMin = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpRtoMax(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpRtoMax;
		StorageTmp->mtpM2paSctpRtoMax = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpRtoMax = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpPathMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpPathMaxRetrans;
		StorageTmp->mtpM2paSctpPathMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpPathMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieLife(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpCookieLife;
		StorageTmp->mtpM2paSctpCookieLife = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieLife = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpCookieInc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpCookieInc;
		StorageTmp->mtpM2paSctpCookieInc = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpCookieInc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxInitRetries(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxInitRetries;
		StorageTmp->mtpM2paSctpMaxInitRetries = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxInitRetries = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpMaxBurst(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpMaxBurst;
		StorageTmp->mtpM2paSctpMaxBurst = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpMaxBurst = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpAssocMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpAssocMaxRetrans;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpAssocMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpSackDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpSackDelay;
		StorageTmp->mtpM2paSctpSackDelay = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpSackDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paSctpLifetime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paSctpLifetime;
		StorageTmp->mtpM2paSctpLifetime = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paSctpLifetime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paProvingAttempts(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpM2paTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paProvingAttempts;
		StorageTmp->mtpM2paProvingAttempts = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paProvingAttempts = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdtAdministrativeState;
		StorageTmp->mtpSdtAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdtAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtEquipmentPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdtEquipmentPointer;
		tmplen = StorageTmp->mtpSdtEquipmentPointerLen;
		memdup((void *) &StorageTmp->mtpSdtEquipmentPointer, var_val, var_val_len);
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
		StorageTmp->mtpSdtEquipmentPointer = tmpvar;
		StorageTmp->mtpSdtEquipmentPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdtName;
		tmplen = StorageTmp->mtpSdtNameLen;
		memdup((void *) &StorageTmp->mtpSdtName, var_val, var_val_len);
		StorageTmp->mtpSdtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtName);
		StorageTmp->mtpSdtName = tmpvar;
		StorageTmp->mtpSdtNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtProfilePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdtProfilePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdtProfilePointer;
		tmplen = StorageTmp->mtpSdtProfilePointerLen;
		memdup((void *) &StorageTmp->mtpSdtProfilePointer, var_val, var_val_len);
		StorageTmp->mtpSdtProfilePointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdtProfilePointer);
		StorageTmp->mtpSdtProfilePointer = tmpvar;
		StorageTmp->mtpSdtProfilePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlAdjPc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlAdjPc;
		tmplen = StorageTmp->mtpSdlAdjPcLen;
		memdup((void *) &StorageTmp->mtpSdlAdjPc, var_val, var_val_len);
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlAdjPc);
		StorageTmp->mtpSdlAdjPc = tmpvar;
		StorageTmp->mtpSdlAdjPcLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlTransmissionRate(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlTransmissionRate;
		StorageTmp->mtpSdlTransmissionRate = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlTransmissionRate = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlLoopDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlLoopDelay;
		StorageTmp->mtpSdlLoopDelay = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlLoopDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlOperationalState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlOperationalState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlOperationalState;
		StorageTmp->mtpSdlOperationalState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlOperationalState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlEquipmentPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlEquipmentPointer;
		tmplen = StorageTmp->mtpSdlEquipmentPointerLen;
		memdup((void *) &StorageTmp->mtpSdlEquipmentPointer, var_val, var_val_len);
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
		StorageTmp->mtpSdlEquipmentPointer = tmpvar;
		StorageTmp->mtpSdlEquipmentPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlCIC(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlCIC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlCIC;
		StorageTmp->mtpSdlCIC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpSdlCIC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlName;
		tmplen = StorageTmp->mtpSdlNameLen;
		memdup((void *) &StorageTmp->mtpSdlName, var_val, var_val_len);
		StorageTmp->mtpSdlNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlName);
		StorageTmp->mtpSdlName = tmpvar;
		StorageTmp->mtpSdlNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlStmChannel(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlStmChannel;
		tmplen = StorageTmp->mtpSdlStmChannelLen;
		memdup((void *) &StorageTmp->mtpSdlStmChannel, var_val, var_val_len);
		StorageTmp->mtpSdlStmChannelLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlStmChannel);
		StorageTmp->mtpSdlStmChannel = tmpvar;
		StorageTmp->mtpSdlStmChannelLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlVcTTpPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct mtpSdlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("mtpMIB2", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpMIB2_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpSdlVcTTpPointer;
		tmplen = StorageTmp->mtpSdlVcTTpPointerLen;
		memdup((void *) &StorageTmp->mtpSdlVcTTpPointer, var_val, var_val_len);
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
		StorageTmp->mtpSdlVcTTpPointer = tmpvar;
		StorageTmp->mtpSdlVcTTpPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpNoDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpNoDelay;
		StorageTmp->mtpM2paDefaultSctpNoDelay = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpNoDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxseg(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxseg;
		StorageTmp->mtpM2paDefaultSctpMaxseg = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxseg = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeatItvl(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpHeartbeatItvl;
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeatItvl = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpHeartbeat(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static long tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpHeartbeat;
		StorageTmp->mtpM2paDefaultSctpHeartbeat = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpHeartbeat = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoInitial(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoInitial;
		StorageTmp->mtpM2paDefaultSctpRtoInitial = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoInitial = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMin(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoMin;
		StorageTmp->mtpM2paDefaultSctpRtoMin = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMin = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpRtoMax(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpRtoMax;
		StorageTmp->mtpM2paDefaultSctpRtoMax = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpRtoMax = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpPathMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpPathMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpPathMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieLife(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpCookieLife;
		StorageTmp->mtpM2paDefaultSctpCookieLife = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieLife = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpCookieInc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpCookieInc;
		StorageTmp->mtpM2paDefaultSctpCookieInc = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpCookieInc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxInitRetries(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxInitRetries;
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxInitRetries = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpMaxBurst(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpMaxBurst;
		StorageTmp->mtpM2paDefaultSctpMaxBurst = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpMaxBurst = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpAssocMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans;
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpAssocMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpSackDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..50 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpSackDelay;
		StorageTmp->mtpM2paDefaultSctpSackDelay = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpSackDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paDefaultSctpLifetime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static ulong tmpvar;
	struct mtpMIB2_data *StorageTmp = NULL;

	DEBUGMSGTL(("mtpMIB2", "write_mtpM2paDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIB2Storage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->mtpM2paDefaultSctpLifetime;
		StorageTmp->mtpM2paDefaultSctpLifetime = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpM2paDefaultSctpLifetime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSapRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	static struct mtpSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSapId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);
			StorageNew->mtpSapId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSapAsaProfilePointer = { zeroDotZero }; */

			StorageNew->mtpSapRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSapRowStatus;
			StorageTmp->mtpSapRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSapTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSapTable_add(StorageDel);
		} else {
			StorageTmp->mtpSapRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSapRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSapRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSapRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSapRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_ss7NetworkStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct ss7NetworkTable_data *StorageTmp = NULL;
	static struct ss7NetworkTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(ss7NetworkTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(ss7NetworkTableStorage, NULL, &name[sizeof(ss7NetworkTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to ss7NetworkStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* ss7NetworkId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(ss7NetworkTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(ss7NetworkTable_data);
			StorageNew->ss7NetworkId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->ss7NetworkProtocolStandard = ansi;
			StorageNew->ss7NetworkProtocolYear = 2000;
			StorageNew->ss7NetworkIndicator = national;
			StorageNew->ss7NetworkPointCodeFormat = pc888;

			StorageNew->ss7NetworkStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				ss7NetworkTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->ss7NetworkStatus;
			StorageTmp->ss7NetworkStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(ss7NetworkTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&ss7NetworkTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(ss7NetworkTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&ss7NetworkTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			ss7NetworkTable_add(StorageDel);
		} else {
			StorageTmp->ss7NetworkStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->ss7NetworkStatus == RS_CREATEANDGO) {
				StorageTmp->ss7NetworkStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->ss7NetworkStatus == RS_CREATEANDWAIT) {
				StorageTmp->ss7NetworkStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpMsStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	static struct mtpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpMsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpMsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpMsAsaProfilePointer = { zeroDotZero }; */

			StorageNew->mtpMsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpMsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpMsStatus;
			StorageTmp->mtpMsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpMsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpMsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpMsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpMsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpMsTable_add(StorageDel);
		} else {
			StorageTmp->mtpMsStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpMsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpMsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpMsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpMsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNaRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);	/* mtpNaId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);
			StorageNew->mtpNaId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpNaProtocolVariant = { ss7ProtocolItut 0 }; */

			StorageNew->mtpNaRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNaTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNaRowStatus;
			StorageTmp->mtpNaRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNaTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNaTable_add(StorageDel);
		} else {
			StorageTmp->mtpNaRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNaRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNaRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNaRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNaRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsRowStatus;
			StorageTmp->mtpGsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	static struct mtpGsLineTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsLineId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpGsLineObject = { zeroDotZero }; */

			StorageNew->mtpGsLineRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsLineTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineRowStatus;
			StorageTmp->mtpGsLineRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsLineTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsLineRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsLineRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsLineRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsLineRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsLineRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpGsLineContentRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	static struct mtpGsLineContentTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsLineId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpGsLineContentId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpGsLineContentTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineContentId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpGsLineContentRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpGsLineContentTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpGsLineContentRowStatus;
			StorageTmp->mtpGsLineContentRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpGsLineContentTable_add(StorageDel);
		} else {
			StorageTmp->mtpGsLineContentRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpGsLineContentRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpGsLineContentRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpGsLineContentRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpGsLineContentRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSpProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);
			memdup((void *) &StorageNew->mtpSpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSpProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSpProfileTimerT1R = 80;
			StorageNew->mtpSpProfileTimerT18I = 60000;
			StorageNew->mtpSpProfileTimerT20I = 6000;
			StorageNew->mtpSpProfileTimerT20A = 10000;
			StorageNew->mtpSpProfileTimerT21A = 10000;
			StorageNew->mtpSpProfileTimerT22A = 60000;
			StorageNew->mtpSpProfileTimerT23A = 60000;
			StorageNew->mtpSpProfileTimerT24A = 60000;
			StorageNew->mtpSpProfileTimerT26A = 1350;
			StorageNew->mtpSpProfileTimerT27A = 300;

			StorageNew->mtpSpProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpProfileRowStatus;
			StorageTmp->mtpSpProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpMsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSpMtpT31A = 6000;
			StorageNew->mtpSpMtpT32A = 6000;
			StorageNew->mtpSpMtpT33A = 36000;
			StorageNew->mtpSpMtpT34A = 6000;
			StorageNew->mtpSpMtpT20A = 10000;
			StorageNew->mtpSpMtpT21A = 10000;

			StorageNew->mtpSpRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpRowStatus;
			StorageTmp->mtpSpRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStatsRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpStatsTable_data *StorageTmp = NULL;
	static struct mtpSpStatsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStatsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStatsTableStorage, NULL, &name[sizeof(mtpSpStatsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStatsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpMsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStatsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStatsTable_data);
			StorageNew->mtpMsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStatsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStatsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStatsRowStatus;
			StorageTmp->mtpSpStatsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStatsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStatsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStatsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStatsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStatsTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStatsRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStatsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStatsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStatsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStatsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpSiStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpSiTable_data *StorageTmp = NULL;
	static struct mtpSpSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpSiTableStorage, NULL, &name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpSiTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpSiStatus;
			StorageTmp->mtpSpSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpSiStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyTable_data *StorageTmp = NULL;
	static struct mtpSpStudyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyTableStorage, NULL, &name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyTable_data);
			StorageNew->mtpSpStudyId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyStatus;
			StorageTmp->mtpSpStudyStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSpStudyMapStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSpStudyMapTable_data *StorageTmp = NULL;
	static struct mtpSpStudyMapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSpStudyMapTableStorage, NULL, &name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpStudyMapStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpSiCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpStudyId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSpStudyMapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSpStudyMapTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpSiCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpStudyId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpSpStudyMapStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSpStudyMapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSpStudyMapStatus;
			StorageTmp->mtpSpStudyMapStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSpStudyMapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSpStudyMapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSpStudyMapTable_add(StorageDel);
		} else {
			StorageTmp->mtpSpStudyMapStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSpStudyMapStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSpStudyMapStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSpStudyMapStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpL3RowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	static struct mtpL3Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpL3Id 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpL3Table_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);
			memdup((void *) &StorageNew->mtpL3Id, vp->val.string, vp->val_len);
			StorageNew->mtpL3IdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpL3AsaProfilePointer = { zeroDotZero }; */

			StorageNew->mtpL3RowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpL3Table_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpL3RowStatus;
			StorageTmp->mtpL3RowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpL3TableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL3TableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpL3TableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpL3TableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpL3Table_add(StorageDel);
		} else {
			StorageTmp->mtpL3RowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpL3RowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpL3RowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpL3RowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpL3RowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	static struct mtpRsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpRsProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);
			memdup((void *) &StorageNew->mtpRsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRsProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpRsProfileTimerT8 = 100;
			StorageNew->mtpRsProfileTimerT11 = 6000;
			StorageNew->mtpRsProfileTimerT15 = 250;
			StorageNew->mtpRsProfileTimerT16 = 175;
			StorageNew->mtpRsProfileTimerT18A = 1200;

			StorageNew->mtpRsProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsProfileRowStatus;
			StorageTmp->mtpRsProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpRsAsaProfilePointer = { zeroDotZero }; */
			/* StorageNew->mtpRsLoadsharingObject = { zeroDotZero }; */

			StorageNew->mtpRsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsRowStatus;
			StorageTmp->mtpRsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsStatsStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRsStatsTable_data *StorageTmp = NULL;
	static struct mtpRsStatsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsStatsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsStatsTableStorage, NULL, &name[sizeof(mtpRsStatsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsStatsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsStatsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRsStatsTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsStatsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsStatsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsStatsStatus;
			StorageTmp->mtpRsStatsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsStatsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsStatsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsStatsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsStatsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsStatsTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsStatsStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsStatsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsStatsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsStatsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsStatsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRsSiStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRsSiTable_data *StorageTmp = NULL;
	static struct mtpRsSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRsSiTableStorage, NULL, &name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsSiCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRsSiTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRsSiTable_data);
			StorageNew->mtpRsSiCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpRsSiStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRsSiTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRsSiStatus;
			StorageTmp->mtpRsSiStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRsSiTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRsSiTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRsSiTable_add(StorageDel);
		} else {
			StorageTmp->mtpRsSiStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRsSiStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRsSiStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRsSiStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	static struct mtpRtProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpRtProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRtProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);
			memdup((void *) &StorageNew->mtpRtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRtProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpRtProfileTimerT6 = 80;
			StorageNew->mtpRtProfileTimerT10 = 4500;

			StorageNew->mtpRtProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRtProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRtProfileRowStatus;
			StorageTmp->mtpRtProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRtProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpRtProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRtProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRtProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRtProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRtProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpRtRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpRtId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRtId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpRtLoadsharingObject = { zeroDotZero }; */

			StorageNew->mtpRtRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpRtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpRtRowStatus;
			StorageTmp->mtpRtRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpRtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpRtTable_add(StorageDel);
		} else {
			StorageTmp->mtpRtRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpRtRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpRtRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpRtRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpRtRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	static struct mtpLsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpLsProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpLsProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);
			memdup((void *) &StorageNew->mtpLsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpLsProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpLsProfileTimerT8 = 100;
			StorageNew->mtpLsProfileTimerT10 = 4500;
			StorageNew->mtpLsProfileTimerT7 = 150;
			StorageNew->mtpLsProfileName = strdup("\"\"");
			StorageNew->mtpLsProfileNameLen = strlen("\"\"");

			StorageNew->mtpLsProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLsProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLsProfileRowStatus;
			StorageTmp->mtpLsProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLsProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpLsProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLsProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLsProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLsProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLsProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpLsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpLsPeriodicLinkTestFail = true;
			/* StorageNew->mtpLsAsaProfilePointer = { zeroDotZero }; */

			StorageNew->mtpLsRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLsRowStatus;
			StorageTmp->mtpLsRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLsTable_add(StorageDel);
		} else {
			StorageTmp->mtpLsRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLsRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLsRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLsRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLsRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpLsStatsStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpLsStatsTable_data *StorageTmp = NULL;
	static struct mtpLsStatsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpLsStatsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpLsStatsTableStorage, NULL, &name[sizeof(mtpLsStatsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsStatsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpLsStatsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpLsStatsTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->mtpLsStatsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpLsStatsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpLsStatsStatus;
			StorageTmp->mtpLsStatsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpLsStatsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsStatsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpLsStatsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpLsStatsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpLsStatsTable_add(StorageDel);
		} else {
			StorageTmp->mtpLsStatsStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpLsStatsStatus == RS_CREATEANDGO) {
				StorageTmp->mtpLsStatsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpLsStatsStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpLsStatsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL3ProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL3ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSlL3ProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlL3ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);
			memdup((void *) &StorageNew->mtpSlL3ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL3ProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSlL3ProfileTimerT24I = 50;
			StorageNew->mtpSlL3ProfileTimerT20A = 10000;
			StorageNew->mtpSlL3ProfileTimerT21A = 10000;
			StorageNew->mtpSlL3ProfileTimerT22I = 27000;
			StorageNew->mtpSlL3ProfileTimerT23I = 27000;
			StorageNew->mtpSlL3ProfileTimerT31A = 6000;
			StorageNew->mtpSlL3ProfileTimerT32A = 6000;
			StorageNew->mtpSlL3ProfileTimerT33A = 36000;
			StorageNew->mtpSlL3ProfileTimerT34A = 6000;

			StorageNew->mtpSlL3ProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlL3ProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlL3ProfileRowStatus;
			StorageTmp->mtpSlL3ProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlL3ProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlL3ProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlL3ProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlL3ProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlL3ProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlL3ProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlL2ProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	static struct mtpSlL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSlL2ProfileId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0);	/* mtpSlL2ProfileTransmissionRate 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlL2ProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);
			memdup((void *) &StorageNew->mtpSlL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlL2ProfileTransmissionRate = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSlL2ProfileM = 5;

			StorageNew->mtpSlL2ProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlL2ProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlL2ProfileRowStatus;
			StorageTmp->mtpSlL2ProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlL2ProfileTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlL2ProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlL2ProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlL2ProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlL2ProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlL2ProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSlCode 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSlSignTermPointer = { zeroDotZero }; */
			/* StorageNew->mtpSlSignDataLinkTpPointer = { zeroDotZero }; */
			/* StorageNew->mtpSlAsaProfilePointer = { zeroDotZero }; */
			StorageNew->mtpSlL3ProfilePointer = strdup("{ zeroDotZero }");
			StorageNew->mtpSlL3ProfilePointerLen = strlen("{ zeroDotZero }");

			StorageNew->mtpSlRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlRowStatus;
			StorageTmp->mtpSlRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdlListRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSlCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSdlListId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdlListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSlSdlListPointer = { zeroDotZero }; */

			StorageNew->mtpSlSdlListRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlSdlListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdlListRowStatus;
			StorageTmp->mtpSlSdlListRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlSdlListTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlSdlListRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlSdlListRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlSdlListRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlSdlListRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlSdlListRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSlSdtListRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSpId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpLsId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSlCode 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSlSdtListId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSlSdtListTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);
			StorageNew->mtpSpId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSlCode = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSlSdtListPointer = { zeroDotZero }; */

			StorageNew->mtpSlSdtListRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSlSdtListTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSlSdtListRowStatus;
			StorageTmp->mtpSlSdtListRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSlSdtListTable_add(StorageDel);
		} else {
			StorageTmp->mtpSlSdtListRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSlSdtListRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSlSdtListRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSlSdtListRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSlSdtListRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpNbRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL;
	static struct mtpNbTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSdtProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpNbTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpNbTin = 4;
			StorageNew->mtpNbTie = 1;
			StorageNew->mtpNbT = 256;
			StorageNew->mtpNbD = 64;
			StorageNew->mtpNbN = 16;
			StorageNew->mtpNbm = 272;

			StorageNew->mtpNbRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpNbTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpNbRowStatus;
			StorageTmp->mtpNbRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpNbTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNbTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpNbTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpNbTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpNbTable_add(StorageDel);
		} else {
			StorageTmp->mtpNbRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpNbRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpNbRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpNbRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpNbRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSaalRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSdtProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSaalTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpSaalMaxCc = 4;
			StorageNew->mtpSaalMaxInformationFieldLength = 4096;
			StorageNew->mtpSaalMaxLengthSscopUuField = 4;
			StorageNew->mtpSaalMaxPd = 500;
			StorageNew->mtpSaalMaxStat = 67;
			StorageNew->mtpSaalN1 = 1000;
			StorageNew->mtpSaalNniTimerT1 = 500;
			StorageNew->mtpSaalNniTimerT2 = 3000;
			StorageNew->mtpSaalSscopTimerCc = 20;
			StorageNew->mtpSaalSscopTimerIdle = 10;
			StorageNew->mtpSaalSscopTimerKeepAlive = 10;
			StorageNew->mtpSaalSscopTimerNoResponse = 150;
			StorageNew->mtpSaalSscopTimerPoll = 10;
			StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
			StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;

			StorageNew->mtpSaalRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSaalTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSaalRowStatus;
			StorageTmp->mtpSaalRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSaalTable_add(StorageDel);
		} else {
			StorageTmp->mtpSaalRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSaalRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSaalRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSaalRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSaalRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpM2paRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* mtpSdtProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpM2paTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->mtpM2paN1 = 1000;
			StorageNew->mtpM2paProving = true;
			StorageNew->mtpM2paSctpAssocMaxRetrans = 20;
			StorageNew->mtpM2paSctpSackDelay = 20;

			StorageNew->mtpM2paRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpM2paTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpM2paRowStatus;
			StorageTmp->mtpM2paRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpM2paTable_add(StorageDel);
		} else {
			StorageTmp->mtpM2paRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpM2paRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpM2paRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpM2paRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpM2paRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdtRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSdtId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSdtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);
			StorageNew->mtpSdtId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSdtEquipmentPointer = { zeroDotZero }; */

			StorageNew->mtpSdtRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSdtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSdtRowStatus;
			StorageTmp->mtpSdtRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSdtTable_add(StorageDel);
		} else {
			StorageTmp->mtpSdtRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSdtRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSdtRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSdtRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSdtRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_mtpSdlRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* mtpSdlId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(mtpSdlTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);
			StorageNew->mtpSdlId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->mtpSdlEquipmentPointer = { zeroDotZero }; */

			StorageNew->mtpSdlRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				mtpSdlTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->mtpSdlRowStatus;
			StorageTmp->mtpSdlRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			mtpSdlTable_add(StorageDel);
		} else {
			StorageTmp->mtpSdlRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->mtpSdlRowStatus == RS_CREATEANDGO) {
				StorageTmp->mtpSdlRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->mtpSdlRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->mtpSdlRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
