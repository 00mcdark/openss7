/*****************************************************************************

 @(#) $RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.11 $) $Date: 2009-01-16 20:44:59 $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2009-01-16 20:44:59 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: sccpMIB.c,v $
 Revision 0.9.2.11  2009-01-16 20:44:59  brian
 - updating mibs and agents

 Revision 0.9.2.10  2009-01-14 14:30:05  brian
 - working up agents

 Revision 0.9.2.9  2009-01-10 17:09:19  brian
 - updated agents

 Revision 0.9.2.8  2009-01-04 13:16:04  brian
 - updated agents

 Revision 0.9.2.7  2009-01-03 10:51:05  brian
 - updated agent

 Revision 0.9.2.6  2009-01-02 15:46:42  brian
 - corrections

 Revision 0.9.2.5  2009-01-02 15:04:14  brian
 - updated agents

 Revision 0.9.2.4  2008-12-31 16:04:46  brian
 - updated mibs

 Revision 0.9.2.3  2008-12-27 15:29:47  brian
 - split MTP and MTP OM mib

 Revision 0.9.2.2  2008-12-24 13:08:25  brian
 - building ss7confd

 *****************************************************************************/

#ident "@(#) $RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.11 $) $Date: 2009-01-16 20:44:59 $"

static char const ident[] = "$RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.11 $) $Date: 2009-01-16 20:44:59 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "sccpMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#undef MASTER
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;
#endif				/* !defined MODULE */
extern int sa_fclose;			/* default close files between requests */
static int my_fd;			/* file descriptor for this MIB's use */
extern int sa_fd;			/* file descriptor for MIB use */
extern int sa_readfd;			/* file descriptor for autonomnous events */
extern int sa_changed;			/* indication to reread MIB configuration */
extern int sa_stats_refresh;		/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_request;			/* request number for per-request actions */
volatile int sccpMIB_refresh = 1;
volatile int sccpNetworkEntityTable_refresh = 1;
volatile int sccpSapNameTable_refresh = 1;
volatile int sccpAccessPointTable_refresh = 1;
volatile int sccpLinkageTable_refresh = 1;
volatile int sccpSclcTable_refresh = 1;
volatile int sccpScocTable_refresh = 1;
volatile int sccpScrcTable_refresh = 1;
volatile int sccpEntitySetTable_refresh = 1;
volatile int sccpEntitySetSapTable_refresh = 1;
volatile int sccpConcernedAreaTable_refresh = 1;
volatile int sccpRemoteSCCPTable_refresh = 1;
volatile int sccpGtConversionRuleTable_refresh = 1;
volatile int sccpAddressInfoTable_refresh = 1;
volatile int sccpGtTranslatorTable_refresh = 1;
volatile int sccpGtRuleTable_refresh = 1;
volatile int sccpSrvtTable_refresh = 1;

/*
 * sccpMIB_variables_oid: object identifier for sccpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid sccpMIB_variables_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2 };
oid sccpNetworkEntityTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 1, 1, 1 };
oid sccpSapNameTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 2, 1, 1 };
oid sccpAccessPointTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 3, 1, 1 };
oid sccpLinkageTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 4, 1, 1 };
oid sccpSclcTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 5, 1, 1 };
oid sccpScocTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 6, 1, 1 };
oid sccpScrcTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 7, 1, 1 };
oid sccpEntitySetTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 8, 1, 1 };
oid sccpEntitySetSapTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 9, 1, 1 };
oid sccpConcernedAreaTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 10, 1, 1 };
oid sccpRemoteSCCPTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 11, 1, 1 };
oid sccpGtConversionRuleTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 12, 1, 1 };
oid sccpAddressInfoTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 13, 1, 1 };
oid sccpGtTranslatorTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 14, 1, 1 };
oid sccpGtRuleTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 15, 1, 1 };
oid sccpSrvtTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 16, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid sccpRouteTestResult_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 0, 1 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid failureType_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 1 };
oid traceSent_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 2 };
oid pointCodeList_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 3 };
oid routePriorityList_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 4 };
oid copyData_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 5 };
oid congestionLevel_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 6 };
oid globalTitle_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3, 7 };

/*
 * Other oids defined in this MIB.
 */
oid sccpLoadSharingRoundRobin_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 4, 1 };
oid sccpLoadSharingSlsSplitting_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 4, 2 };
oid sccpMIBCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 1, 1 };
oid sccpNetworkEntityGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 1 };
oid sccpSapNameGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 2 };
oid sccpAccessPointGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 3 };
oid sccpRemoteSAPGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 4 };
oid sccpAvailableAfterSpRestartPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 5 };
oid sccpLinkageGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 6 };
oid sccpSclcGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 7 };
oid sccpScocGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 8 };
oid sccpScrcGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 9 };
oid sccpEntitySetGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 10 };
oid sccpConcernedAreaGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 11 };
oid sccpRemoteSCCPGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 12 };
oid sccpGtTranslatorGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 13 };
oid sccpSrvtGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 14 };
oid sccpLocalSccpLinkagePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 15 };
oid sccpCongestionPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 16 };
oid sccpAddressInfoConversionRulePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 17 };
oid sccpCommonLanguageNameGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2, 18 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 sccpMIB_variables: tree for sccpMIB
 * This variable defines function callbacks and type return information for the sccpMIB mib section
 */
struct variable7 sccpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   SCCPNETWORKENTITYALARMSTATUS  1
	{(u_char) SCCPNETWORKENTITYALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   SCCPSYSTEMTYPES       2
	{(u_char) SCCPSYSTEMTYPES, ASN_BIT_STR, RONLY, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 6}},
#define   SCCPVERSION           3
	{(u_char) SCCPVERSION, ASN_OBJECT_ID, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 7}},
#define   SCCPLUDTANDLUDTSSUPPORTED  4
	{(u_char) SCCPLUDTANDLUDTSSUPPORTED, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 8}},
#define   SCCPCOORDCHANGETIMER  5
	{(u_char) SCCPCOORDCHANGETIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 9}},
#define   SCCPIGNORESSTTIMER    6
	{(u_char) SCCPIGNORESSTTIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 10}},
#define   SCCPMAXSTATINFOTIMER  7
	{(u_char) SCCPMAXSTATINFOTIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 11}},
#define   SCCPNETWORKENTITYNAME  8
	{(u_char) SCCPNETWORKENTITYNAME, ASN_OCTET_STR, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 12}},
#define   SCCPROWSTATUS         9
	{(u_char) SCCPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 13}},
#define   SCCPSAPNAMEROWSTATUS  10
	{(u_char) SCCPSAPNAMEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSapNameTable, 6, {1, 1, 2, 1, 1, 1}},
#define   SCCPACCESSPOINTALARMSTATUS  11
	{(u_char) SCCPACCESSPOINTALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 2}},
#define   SCCPSAP2ADDRESS       12
	{(u_char) SCCPSAP2ADDRESS, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 3}},
#define   SCCPUSERENTITYNAMES   13
	{(u_char) SCCPUSERENTITYNAMES, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 4}},
#define   SCCPPROVIDERENTITYNAMES  14
	{(u_char) SCCPPROVIDERENTITYNAMES, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 5}},
#define   SCCPAVAILABILITYSTATUS  15
	{(u_char) SCCPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 6}},
#define   SCCPCONCERNEDAREAPOINTER  16
	{(u_char) SCCPCONCERNEDAREAPOINTER, ASN_UNSIGNED, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 7}},
#define   SCCPLINKAGEPOINTER    17
	{(u_char) SCCPLINKAGEPOINTER, ASN_UNSIGNED, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 8}},
#define   SCCPSSAVAILABLEAFTERSPRESTART  18
	{(u_char) SCCPSSAVAILABLEAFTERSPRESTART, ASN_INTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 9}},
#define   SCCPACCESSPOINTNAME   19
	{(u_char) SCCPACCESSPOINTNAME, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 10}},
#define   SCCPACCESSPOINTROWSTATUS  20
	{(u_char) SCCPACCESSPOINTROWSTATUS, ASN_INTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 11}},
#define   SCCPOPERATIONALPROTOCOLS  21
	{(u_char) SCCPOPERATIONALPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 2}},
#define   SCCPSNSAP             22
	{(u_char) SCCPSNSAP, ASN_OBJECT_ID, RONLY, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 3}},
#define   SCCPATTACKTIMERVALUE  23
	{(u_char) SCCPATTACKTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 4}},
#define   SCCPDECAYTIMERVALUE   24
	{(u_char) SCCPDECAYTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 5}},
#define   SCCPNROFRESTRICTIONLEVELS  25
	{(u_char) SCCPNROFRESTRICTIONLEVELS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 6}},
#define   SCCPNROFSUBLEVELS     26
	{(u_char) SCCPNROFSUBLEVELS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 7}},
#define   SCCPCLS               27
	{(u_char) SCCPCLS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 8}},
#define   SCCPCONGESTIONTIMERVALUE  28
	{(u_char) SCCPCONGESTIONTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 9}},
#define   SCCPP                 29
	{(u_char) SCCPP, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 10}},
#define   SCCPIMPORTANCELEVELCR  30
	{(u_char) SCCPIMPORTANCELEVELCR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 11}},
#define   SCCPIMPORTANCELEVELCC  31
	{(u_char) SCCPIMPORTANCELEVELCC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 12}},
#define   SCCPIMPORTANCELEVELCREF  32
	{(u_char) SCCPIMPORTANCELEVELCREF, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 13}},
#define   SCCPIMPORTANCELEVELDT1  33
	{(u_char) SCCPIMPORTANCELEVELDT1, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 14}},
#define   SCCPIMPORTANCELEVELDT2  34
	{(u_char) SCCPIMPORTANCELEVELDT2, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 15}},
#define   SCCPIMPORTANCELEVELAK  35
	{(u_char) SCCPIMPORTANCELEVELAK, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 16}},
#define   SCCPIMPORTANCELEVELIT  36
	{(u_char) SCCPIMPORTANCELEVELIT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 17}},
#define   SCCPIMPORTANCELEVELED  37
	{(u_char) SCCPIMPORTANCELEVELED, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 18}},
#define   SCCPIMPORTANCELEVELEA  38
	{(u_char) SCCPIMPORTANCELEVELEA, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 19}},
#define   SCCPIMPORTANCELEVELRSR  39
	{(u_char) SCCPIMPORTANCELEVELRSR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 20}},
#define   SCCPIMPORTANCELEVELRSC  40
	{(u_char) SCCPIMPORTANCELEVELRSC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 21}},
#define   SCCPIMPORTANCELEVELERR  41
	{(u_char) SCCPIMPORTANCELEVELERR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 22}},
#define   SCCPIMPORTANCELEVELRLC  42
	{(u_char) SCCPIMPORTANCELEVELRLC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 23}},
#define   SCCPIMPORTANCELEVELRLSD  43
	{(u_char) SCCPIMPORTANCELEVELRLSD, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 24}},
#define   SCCPIMPORTANCELEVELUDT  44
	{(u_char) SCCPIMPORTANCELEVELUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 25}},
#define   SCCPIMPORTANCELEVELUDTS  45
	{(u_char) SCCPIMPORTANCELEVELUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 26}},
#define   SCCPIMPORTANCELEVELXUDT  46
	{(u_char) SCCPIMPORTANCELEVELXUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 27}},
#define   SCCPIMPORTANCELEVELXUDTS  47
	{(u_char) SCCPIMPORTANCELEVELXUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 28}},
#define   SCCPIMPORTANCELEVELLUDT  48
	{(u_char) SCCPIMPORTANCELEVELLUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 29}},
#define   SCCPIMPORTANCELEVELLUDTS  49
	{(u_char) SCCPIMPORTANCELEVELLUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 30}},
#define   SCCPRLM               50
	{(u_char) SCCPRLM, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 31}},
#define   SCCPRSLM              51
	{(u_char) SCCPRSLM, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 32}},
#define   SCCPLINKAGECONCERNEDAREAPOINTER  52
	{(u_char) SCCPLINKAGECONCERNEDAREAPOINTER, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 33}},
#define   SCCPLOWERLIMITFORSEGMENTATION  53
	{(u_char) SCCPLOWERLIMITFORSEGMENTATION, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 34}},
#define   SCCPUPPERLIMITFORSEGMENTATION  54
	{(u_char) SCCPUPPERLIMITFORSEGMENTATION, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 35}},
#define   SCCPLINKAGENAME       55
	{(u_char) SCCPLINKAGENAME, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 36}},
#define   SCCPLINKAGEROWSTATUS  56
	{(u_char) SCCPLINKAGEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 37}},
#define   SCCPSCLCALARMSTATUS   57
	{(u_char) SCCPSCLCALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 1}},
#define   SCCPSCLCOPERATIONALSTATE  58
	{(u_char) SCCPSCLCOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 3}},
#define   SCCPTOTALREMOTESAPS   59
	{(u_char) SCCPTOTALREMOTESAPS, ASN_INTEGER, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 4}},
#define   SCCPSCLCADMINISTRATIVESTATE  60
	{(u_char) SCCPSCLCADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 5}},
#define   SCCPSCLCSUPPORTEDPROTOCOLS  61
	{(u_char) SCCPSCLCSUPPORTEDPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 6}},
#define   SCCPSCLCOPERATIONALSYSTEMTYPE  62
	{(u_char) SCCPSCLCOPERATIONALSYSTEMTYPE, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 7}},
#define   SCCPINITIALVALUEREASSTIMER  63
	{(u_char) SCCPINITIALVALUEREASSTIMER, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 8}},
#define   SCCPSCLCNAME          64
	{(u_char) SCCPSCLCNAME, ASN_OCTET_STR, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 9}},
#define   SCCPSCLCROWSTATUS     65
	{(u_char) SCCPSCLCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 10}},
#define   SCCPCOPROTOCOLMACHINEID  66
	{(u_char) SCCPCOPROTOCOLMACHINEID, ASN_OCTET_STR, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 1}},
#define   SCCPSCOCOPERATIONALSTATE  67
	{(u_char) SCCPSCOCOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SCCPSCOCADMINISTRATIVESTATE  68
	{(u_char) SCCPSCOCADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 3}},
#define   SCCPSCOCOPERATIONALSYSTEMTYPE  69
	{(u_char) SCCPSCOCOPERATIONALSYSTEMTYPE, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 4}},
#define   SCCPSCOCSUPPORTEDPROTOCOLS  70
	{(u_char) SCCPSCOCSUPPORTEDPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 5}},
#define   SCCPSCOCNAME          71
	{(u_char) SCCPSCOCNAME, ASN_OCTET_STR, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 6}},
#define   SCCPSCOCROWSTATUS     72
	{(u_char) SCCPSCOCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 7}},
#define   SCCPSCRCID            73
	{(u_char) SCCPSCRCID, ASN_OCTET_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 1}},
#define   SCCPSCRCALARMSTATUS   74
	{(u_char) SCCPSCRCALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 2}},
#define   SCCPSCRCNAME          75
	{(u_char) SCCPSCRCNAME, ASN_OCTET_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 3}},
#define   SCCPSCRCROWSTATUS     76
	{(u_char) SCCPSCRCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 4}},
#define   SCCPSHARINGMODE       77
	{(u_char) SCCPSHARINGMODE, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 2}},
#define   SCCPLOADSHARINGALGPOINTER  78
	{(u_char) SCCPLOADSHARINGALGPOINTER, ASN_OBJECT_ID, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 3}},
#define   SCCPENTITYSETNAME     79
	{(u_char) SCCPENTITYSETNAME, ASN_OCTET_STR, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 4}},
#define   SCCPENTITYSETTYPE     80
	{(u_char) SCCPENTITYSETTYPE, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 5}},
#define   SCCPENTITYSETSSN      81
	{(u_char) SCCPENTITYSETSSN, ASN_OCTET_STR, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 6}},
#define   SCCPENTITYSETROWSTATUS  82
	{(u_char) SCCPENTITYSETROWSTATUS, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 7}},
#define   SCCPENTITYSETSAPTYPE  83
	{(u_char) SCCPENTITYSETSAPTYPE, ASN_INTEGER, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 2}},
#define   SCCPENTITYSETSAPPOINTER  84
	{(u_char) SCCPENTITYSETSAPPOINTER, ASN_OBJECT_ID, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 3}},
#define   SCCPENTITYSETSAPROWSTATUS  85
	{(u_char) SCCPENTITYSETSAPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 4}},
#define   SCCPREMOTESCCPMTPACCESSPOINT  86
	{(u_char) SCCPREMOTESCCPMTPACCESSPOINT, ASN_OBJECT_ID, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 2}},
#define   SCCPREMOTESCCPNAME    87
	{(u_char) SCCPREMOTESCCPNAME, ASN_OCTET_STR, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 3}},
#define   SCCPREMOTESCCPROWSTATUS  88
	{(u_char) SCCPREMOTESCCPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 4}},
#define   SCCPGTNEWENCODINGSCHEME  89
	{(u_char) SCCPGTNEWENCODINGSCHEME, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 2}},
#define   SCCPGTNEWNATUREOFADDRESS  90
	{(u_char) SCCPGTNEWNATUREOFADDRESS, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 3}},
#define   SCCPGTNEWNUMBERINGPLAN  91
	{(u_char) SCCPGTNEWNUMBERINGPLAN, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 4}},
#define   SCCPGTNEWTRANSLATIONTYPE  92
	{(u_char) SCCPGTNEWTRANSLATIONTYPE, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 5}},
#define   SCCPGTCONVERSIONRULENAME  93
	{(u_char) SCCPGTCONVERSIONRULENAME, ASN_OCTET_STR, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 6}},
#define   SCCPGTCONVERSIONRULEROWSTATUS  94
	{(u_char) SCCPGTCONVERSIONRULEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 7}},
#define   SCCPADDRESSINFOOPERATION  95
	{(u_char) SCCPADDRESSINFOOPERATION, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 2}},
#define   SCCPADDRESSINFOADDRESSELEMENT  96
	{(u_char) SCCPADDRESSINFOADDRESSELEMENT, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 3}},
#define   SCCPADDRESSINFONROFADDRESSELEMENTS  97
	{(u_char) SCCPADDRESSINFONROFADDRESSELEMENTS, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 4}},
#define   SCCPADDRESSINFOROWSTATUS  98
	{(u_char) SCCPADDRESSINFOROWSTATUS, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 5}},
#define   SCCPGTINDICATOR       99
	{(u_char) SCCPGTINDICATOR, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 2}},
#define   SCCPGTNATUREOFADDRESS  100
	{(u_char) SCCPGTNATUREOFADDRESS, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SCCPGTNUMBERINGPLAN   101
	{(u_char) SCCPGTNUMBERINGPLAN, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SCCPGTTRANSLATIONTYPE  102
	{(u_char) SCCPGTTRANSLATIONTYPE, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 5}},
#define   SCCPGTTRANSLATORADMINISTRATIVESTATE  103
	{(u_char) SCCPGTTRANSLATORADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 6}},
#define   SCCPGTTRANSLATORNAME  104
	{(u_char) SCCPGTTRANSLATORNAME, ASN_OCTET_STR, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 7}},
#define   SCCPGTTRANSLATORROWSTATUS  105
	{(u_char) SCCPGTTRANSLATORROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 8}},
#define   SCCPGTRULEADMINISTRATIVESTATE  106
	{(u_char) SCCPGTRULEADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SCCPGTADDRESSINFORMATION  107
	{(u_char) SCCPGTADDRESSINFORMATION, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SCCPGTCONVRULEPOINTER  108
	{(u_char) SCCPGTCONVRULEPOINTER, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SCCPGTENCODINGSCHEME  109
	{(u_char) SCCPGTENCODINGSCHEME, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SCCPENTITYSETPOINTER  110
	{(u_char) SCCPENTITYSETPOINTER, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SCCPGTRULENAME        111
	{(u_char) SCCPGTRULENAME, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SCCPGTRULEROWSTATUS   112
	{(u_char) SCCPGTRULEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SCCPDSRVT             113
	{(u_char) SCCPDSRVT, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SCCPNSRVT             114
	{(u_char) SCCPNSRVT, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SCCPSRVTNAME          115
	{(u_char) SCCPSRVTNAME, ASN_OCTET_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SCCPADMINISTRATIVESTATE  116
	{(u_char) SCCPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SCCPOPERATIONALSTATE  117
	{(u_char) SCCPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SCCPPROCEDURALSTATUS  118
	{(u_char) SCCPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SCCPTRACEREQUESTED    119
	{(u_char) SCCPTRACEREQUESTED, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SCCPTHRESHOLD         120
	{(u_char) SCCPTHRESHOLD, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SCCPMTPBACKWARDROUTINGREQUESTED  121
	{(u_char) SCCPMTPBACKWARDROUTINGREQUESTED, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SCCPORIGINALGT        122
	{(u_char) SCCPORIGINALGT, ASN_OCTET_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 11}},
#define   SCCPINFOREQUEST       123
	{(u_char) SCCPINFOREQUEST, ASN_BIT_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 12}},
#define   SCCPRETURNUNKNOWNPARAMS  124
	{(u_char) SCCPRETURNUNKNOWNPARAMS, ASN_BIT_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 13}},
#define   SCCPROUTETESTROWSTATUS  125
	{(u_char) SCCPROUTETESTROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 14}},
};

/* (L = length of the oidsuffix) */
struct sccpMIB_data *sccpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *sccpNetworkEntityTableStorage = NULL;
struct header_complex_index *sccpSapNameTableStorage = NULL;
struct header_complex_index *sccpAccessPointTableStorage = NULL;
struct header_complex_index *sccpLinkageTableStorage = NULL;
struct header_complex_index *sccpSclcTableStorage = NULL;
struct header_complex_index *sccpScocTableStorage = NULL;
struct header_complex_index *sccpScrcTableStorage = NULL;
struct header_complex_index *sccpEntitySetTableStorage = NULL;
struct header_complex_index *sccpEntitySetSapTableStorage = NULL;
struct header_complex_index *sccpConcernedAreaTableStorage = NULL;
struct header_complex_index *sccpRemoteSCCPTableStorage = NULL;
struct header_complex_index *sccpGtConversionRuleTableStorage = NULL;
struct header_complex_index *sccpAddressInfoTableStorage = NULL;
struct header_complex_index *sccpGtTranslatorTableStorage = NULL;
struct header_complex_index *sccpGtRuleTableStorage = NULL;
struct header_complex_index *sccpSrvtTableStorage = NULL;

#if defined MODULE
void (*sccpMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void sccpMIB_loop_handler(int);
void sccpMIB_fd_handler(int, void *);
#endif				/* defined MOUDLE */
/**
 * @fn void init_sccpMIB(void)
 * @brief sccpMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (sccpMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_sccpMIB(void)
{
	(void) my_fd;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("sccpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("sccpMIB", sccpMIB_variables, variable7, sccpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_sccpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("sccpMIB", parse_sccpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpNetworkEntityTable", parse_sccpNetworkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSapNameTable", parse_sccpSapNameTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpAccessPointTable", parse_sccpAccessPointTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpLinkageTable", parse_sccpLinkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSclcTable", parse_sccpSclcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpScocTable", parse_sccpScocTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpScrcTable", parse_sccpScrcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpEntitySetTable", parse_sccpEntitySetTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpEntitySetSapTable", parse_sccpEntitySetSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpConcernedAreaTable", parse_sccpConcernedAreaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpRemoteSCCPTable", parse_sccpRemoteSCCPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtConversionRuleTable", parse_sccpGtConversionRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpAddressInfoTable", parse_sccpAddressInfoTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtTranslatorTable", parse_sccpGtTranslatorTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtRuleTable", parse_sccpGtRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSrvtTable", parse_sccpSrvtTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpNetworkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSapNameTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpAccessPointTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpLinkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSclcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpScocTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpScrcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpEntitySetTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpEntitySetSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpConcernedAreaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpRemoteSCCPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtConversionRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpAddressInfoTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtTranslatorTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSrvtTable, NULL);

	/* place any other initialization junk you need here */
#if defined MODULE
	if (sa_readfd != 0) {
		register_readfd(sa_readfd, sccpMIB_fd_handler, (void *) 0);
		register_exceptfd(sa_readfd, sccpMIB_fd_handler, (void *) 1);
	}
#if defined MASTER
	sccpMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &sccpMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
#endif				/* defined MASTER */
#endif				/* defined MODULE */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

/**
 * @fn void deinit_sccpMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (sccpMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_sccpMIB(void)
{
	DEBUGMSGTL(("sccpMIB", "deinitializating...  "));
#if defined MODULE
#if defined MASTER
	external_signal_handler[SIGCHLD] = sccpMIBold_signal_handler;
#endif				/* defined MASTER */
	if (sa_readfd != 0) {
		unregister_exceptfd(sa_readfd);
		unregister_readfd(sa_readfd);
		close(sa_readfd);
		sa_readfd = 0;
	}
#endif				/* defined MODULE */
	unregister_mib(sccpMIB_variables_oid, sizeof(sccpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("sccpMIB");
	snmpd_unregister_config_handler("sccpNetworkEntityTable");
	snmpd_unregister_config_handler("sccpSapNameTable");
	snmpd_unregister_config_handler("sccpAccessPointTable");
	snmpd_unregister_config_handler("sccpLinkageTable");
	snmpd_unregister_config_handler("sccpSclcTable");
	snmpd_unregister_config_handler("sccpScocTable");
	snmpd_unregister_config_handler("sccpScrcTable");
	snmpd_unregister_config_handler("sccpEntitySetTable");
	snmpd_unregister_config_handler("sccpEntitySetSapTable");
	snmpd_unregister_config_handler("sccpConcernedAreaTable");
	snmpd_unregister_config_handler("sccpRemoteSCCPTable");
	snmpd_unregister_config_handler("sccpGtConversionRuleTable");
	snmpd_unregister_config_handler("sccpAddressInfoTable");
	snmpd_unregister_config_handler("sccpGtTranslatorTable");
	snmpd_unregister_config_handler("sccpGtRuleTable");
	snmpd_unregister_config_handler("sccpSrvtTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

int
term_sccpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_sccpMIB();
	return 0;
}

/**
 * @fn struct sccpMIB_data *sccpMIB_create(void)
 * @brief create a fresh data structure representing scalars in sccpMIB.
 *
 * Creates a new sccpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in sccpMIB.
 */
struct sccpMIB_data *
sccpMIB_create(void)
{
	struct sccpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(sccpMIB_data);

	DEBUGMSGTL(("sccpMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sccpMIB_destroy(struct sccpMIB_data **thedata)
 * @param thedata pointer to the data structure in sccpMIB.
 * @brief delete a scalars structure from sccpMIB.
 *
 * Frees scalars that were previously removed from sccpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpMIB_destroy(struct sccpMIB_data **thedata)
{
	struct sccpMIB_data *StorageDel;

	DEBUGMSGTL(("sccpMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpMIB_add(struct sccpMIB_data *thedata)
 * @param thedata the structure representing sccpMIB scalars.
 * @brief adds node to the sccpMIB scalar data set.
 *
 * Adds a scalar structure to the sccpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
sccpMIB_add(struct sccpMIB_data *thedata)
{
	DEBUGMSGTL(("sccpMIB", "adding data...  "));
	sccpMIBStorage = thedata;
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpMIB entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_sccpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpMIB_data *StorageTmp = sccpMIB_create();

	DEBUGMSGTL(("sccpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	sccpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

/*
 * store_sccpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_sccpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpMIB_data *StorageTmp;

	DEBUGMSGTL(("sccpMIB", "storing data...  "));
	refresh_sccpMIB(1);
	if ((StorageTmp = sccpMIBStorage) == NULL) {
		DEBUGMSGTL(("sccpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	if (0) {
		memset(line, 0, sizeof(line));
		strcat(line, "sccpMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_sccpMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of sccpMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_sccpMIB(int force)
{
	if (sccpMIBStorage == NULL) {
		struct sccpMIB_data *StorageNew;

		if ((StorageNew = sccpMIB_create()) == NULL)
			return;
		sccpMIBStorage = StorageNew;
		sccpMIB_refresh = 1;
	}
	if (!force && sccpMIB_refresh == 0)
		return;
	sccpMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
 * @fn u_char * var_sccpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in sccpMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_sccpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpMIB_data *StorageTmp;
	u_char *rval;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_sccpMIB(0);
	if ((StorageTmp = sccpMIBStorage) == NULL)
		return NULL;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn struct sccpNetworkEntityTable_data *sccpNetworkEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpNetworkEntityTable table.
 *
 * Creates a new sccpNetworkEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpNetworkEntityTable_data *
sccpNetworkEntityTable_create(void)
{
	struct sccpNetworkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpNetworkEntityTable_data);

	DEBUGMSGTL(("sccpNetworkEntityTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if (memdup((u_char **) &StorageNew->sccpNetworkEntityAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpNetworkEntityAlarmStatusLen = 1;
		StorageNew->sccpCommunicationsEntityId = 0;
		if ((StorageNew->sccpLocalSapNames = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpLocalSapNamesLen = strlen("");
		if ((StorageNew->sccpNetworkEntityTitles = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpNetworkEntityTitlesLen = strlen("");
		if (memdup((u_char **) &StorageNew->sccpSystemTypes, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpSystemTypesLen = 1;
		if ((StorageNew->sccpVersion = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sccpVersionLen = 2;
		StorageNew->sccpLUDTandLUDTSSupported = 0;
		StorageNew->sccpCoordChangeTimer = 0;
		StorageNew->sccpIgnoreSSTTimer = 0;
		StorageNew->sccpMaxStatInfoTimer = 0;
		if ((StorageNew->sccpNetworkEntityName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpNetworkEntityNameLen = strlen("");
		StorageNew->sccpRowStatus = 0;
		StorageNew->sccpRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpNetworkEntityTable_data *sccpNetworkEntityTable_duplicate(struct sccpNetworkEntityTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpNetworkEntityTable_data *
sccpNetworkEntityTable_duplicate(struct sccpNetworkEntityTable_data *thedata)
{
	struct sccpNetworkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpNetworkEntityTable_data);

	DEBUGMSGTL(("sccpNetworkEntityTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpNetworkEntityTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpNetworkEntityTable_destroy(struct sccpNetworkEntityTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpNetworkEntityTable_destroy(struct sccpNetworkEntityTable_data **thedata)
{
	struct sccpNetworkEntityTable_data *StorageDel;

	DEBUGMSGTL(("sccpNetworkEntityTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpNetworkEntityAlarmStatus);
		StorageDel->sccpNetworkEntityAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpLocalSapNames);
		StorageDel->sccpLocalSapNamesLen = 0;
		SNMP_FREE(StorageDel->sccpNetworkEntityTitles);
		StorageDel->sccpNetworkEntityTitlesLen = 0;
		SNMP_FREE(StorageDel->sccpSystemTypes);
		StorageDel->sccpSystemTypesLen = 0;
		SNMP_FREE(StorageDel->sccpVersion);
		StorageDel->sccpVersionLen = 0;
		SNMP_FREE(StorageDel->sccpNetworkEntityName);
		StorageDel->sccpNetworkEntityNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpNetworkEntityTable_add(struct sccpNetworkEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpNetworkEntityTable table data set.
 *
 * Adds a table row structure to the sccpNetworkEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpNetworkEntityTable_add(struct sccpNetworkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpNetworkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpNetworkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpNetworkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpNetworkEntityTable_del(struct sccpNetworkEntityTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpNetworkEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpNetworkEntityTable_del(struct sccpNetworkEntityTable_data *thedata)
{
	struct sccpNetworkEntityTable_data *StorageDel;

	DEBUGMSGTL(("sccpNetworkEntityTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpNetworkEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpNetworkEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpNetworkEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpNetworkEntityTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpNetworkEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpNetworkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpNetworkEntityTable_data *StorageTmp = sccpNetworkEntityTable_create();

	DEBUGMSGTL(("sccpNetworkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpNetworkEntityAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpNetworkEntityAlarmStatus, &StorageTmp->sccpNetworkEntityAlarmStatusLen);
	if (StorageTmp->sccpNetworkEntityAlarmStatus == NULL) {
		config_perror("invalid specification for sccpNetworkEntityAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpCommunicationsEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpLocalSapNames);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLocalSapNames, &StorageTmp->sccpLocalSapNamesLen);
	if (StorageTmp->sccpLocalSapNames == NULL) {
		config_perror("invalid specification for sccpLocalSapNames");
		return;
	}
	SNMP_FREE(StorageTmp->sccpNetworkEntityTitles);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpNetworkEntityTitles, &StorageTmp->sccpNetworkEntityTitlesLen);
	if (StorageTmp->sccpNetworkEntityTitles == NULL) {
		config_perror("invalid specification for sccpNetworkEntityTitles");
		return;
	}
	SNMP_FREE(StorageTmp->sccpSystemTypes);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSystemTypes, &StorageTmp->sccpSystemTypesLen);
	if (StorageTmp->sccpSystemTypes == NULL) {
		config_perror("invalid specification for sccpSystemTypes");
		return;
	}
	SNMP_FREE(StorageTmp->sccpVersion);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpVersion, &StorageTmp->sccpVersionLen);
	if (StorageTmp->sccpVersion == NULL) {
		config_perror("invalid specification for sccpVersion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLUDTandLUDTSSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCoordChangeTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpIgnoreSSTTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpMaxStatInfoTimer, &tmpsize);
	SNMP_FREE(StorageTmp->sccpNetworkEntityName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpNetworkEntityName, &StorageTmp->sccpNetworkEntityNameLen);
	if (StorageTmp->sccpNetworkEntityName == NULL) {
		config_perror("invalid specification for sccpNetworkEntityName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRowStatus, &tmpsize);
	sccpNetworkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
}

/*
 * store_sccpNetworkEntityTable(): store configuraiton file for sccpNetworkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpNetworkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpNetworkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpNetworkEntityTable", "storing data...  "));
	refresh_sccpNetworkEntityTable(1);
	(void) tmpsize;
	for (hcindex = sccpNetworkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpNetworkEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpNetworkEntityTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpNetworkEntityAlarmStatus, &StorageTmp->sccpNetworkEntityAlarmStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpCommunicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLocalSapNames, &StorageTmp->sccpLocalSapNamesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpNetworkEntityTitles, &StorageTmp->sccpNetworkEntityTitlesLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSystemTypes, &StorageTmp->sccpSystemTypesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpVersion, &StorageTmp->sccpVersionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLUDTandLUDTSSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCoordChangeTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpIgnoreSSTTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpMaxStatInfoTimer, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpNetworkEntityName, &StorageTmp->sccpNetworkEntityNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpSapNameTable_data *sccpSapNameTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpSapNameTable table.
 *
 * Creates a new sccpSapNameTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpSapNameTable_data *
sccpSapNameTable_create(void)
{
	struct sccpSapNameTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSapNameTable_data);

	DEBUGMSGTL(("sccpSapNameTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		StorageNew->sccpSapId = 0;
		StorageNew->sccpSapNameRowStatus = 0;
		StorageNew->sccpSapNameRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpSapNameTable_data *sccpSapNameTable_duplicate(struct sccpSapNameTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpSapNameTable_data *
sccpSapNameTable_duplicate(struct sccpSapNameTable_data *thedata)
{
	struct sccpSapNameTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSapNameTable_data);

	DEBUGMSGTL(("sccpSapNameTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpSapNameTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpSapNameTable_destroy(struct sccpSapNameTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpSapNameTable_destroy(struct sccpSapNameTable_data **thedata)
{
	struct sccpSapNameTable_data *StorageDel;

	DEBUGMSGTL(("sccpSapNameTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSapNameTable_add(struct sccpSapNameTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpSapNameTable table data set.
 *
 * Adds a table row structure to the sccpSapNameTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpSapNameTable_add(struct sccpSapNameTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSapNameTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpSapId, sizeof(thedata->sccpSapId));
	header_complex_add_data(&sccpSapNameTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSapNameTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSapNameTable_del(struct sccpSapNameTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpSapNameTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpSapNameTable_del(struct sccpSapNameTable_data *thedata)
{
	struct sccpSapNameTable_data *StorageDel;

	DEBUGMSGTL(("sccpSapNameTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpSapNameTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpSapNameTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpSapNameTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpSapNameTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpSapNameTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpSapNameTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSapNameTable_data *StorageTmp = sccpSapNameTable_create();

	DEBUGMSGTL(("sccpSapNameTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpSapId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSapNameRowStatus, &tmpsize);
	sccpSapNameTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
}

/*
 * store_sccpSapNameTable(): store configuraiton file for sccpSapNameTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpSapNameTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSapNameTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSapNameTable", "storing data...  "));
	refresh_sccpSapNameTable(1);
	(void) tmpsize;
	for (hcindex = sccpSapNameTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSapNameTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpSapNameTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSapNameRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpAccessPointTable_data *sccpAccessPointTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpAccessPointTable table.
 *
 * Creates a new sccpAccessPointTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpAccessPointTable_data *
sccpAccessPointTable_create(void)
{
	struct sccpAccessPointTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAccessPointTable_data);

	DEBUGMSGTL(("sccpAccessPointTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if (memdup((u_char **) &StorageNew->sccpAccessPointAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpAccessPointAlarmStatusLen = 1;
		if ((StorageNew->sccpSap2Address = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpSap2AddressLen = strlen("");
		if ((StorageNew->sccpUserEntityNames = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpUserEntityNamesLen = strlen("");
		if ((StorageNew->sccpProviderEntityNames = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpProviderEntityNamesLen = strlen("");
		if (memdup((u_char **) &StorageNew->sccpAvailabilityStatus, (u_char *) "\x00\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpAvailabilityStatusLen = 2;
		StorageNew->sccpConcernedAreaPointer = 0;
		StorageNew->sccpLinkagePointer = 0;
		StorageNew->sccpSsAvailableAfterSpRestart = 2;
		if ((StorageNew->sccpAccessPointName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpAccessPointNameLen = strlen("");
		StorageNew->sccpAccessPointRowStatus = 0;
		StorageNew->sccpAccessPointRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpAccessPointTable_data *sccpAccessPointTable_duplicate(struct sccpAccessPointTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpAccessPointTable_data *
sccpAccessPointTable_duplicate(struct sccpAccessPointTable_data *thedata)
{
	struct sccpAccessPointTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAccessPointTable_data);

	DEBUGMSGTL(("sccpAccessPointTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpAccessPointTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpAccessPointTable_destroy(struct sccpAccessPointTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpAccessPointTable_destroy(struct sccpAccessPointTable_data **thedata)
{
	struct sccpAccessPointTable_data *StorageDel;

	DEBUGMSGTL(("sccpAccessPointTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpAccessPointAlarmStatus);
		StorageDel->sccpAccessPointAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpSap2Address);
		StorageDel->sccpSap2AddressLen = 0;
		SNMP_FREE(StorageDel->sccpUserEntityNames);
		StorageDel->sccpUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sccpProviderEntityNames);
		StorageDel->sccpProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sccpAvailabilityStatus);
		StorageDel->sccpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->sccpAccessPointName);
		StorageDel->sccpAccessPointNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAccessPointTable_add(struct sccpAccessPointTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpAccessPointTable table data set.
 *
 * Adds a table row structure to the sccpAccessPointTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpAccessPointTable_add(struct sccpAccessPointTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpAccessPointTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpSapId, sizeof(thedata->sccpSapId));
	header_complex_add_data(&sccpAccessPointTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpAccessPointTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAccessPointTable_del(struct sccpAccessPointTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpAccessPointTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpAccessPointTable_del(struct sccpAccessPointTable_data *thedata)
{
	struct sccpAccessPointTable_data *StorageDel;

	DEBUGMSGTL(("sccpAccessPointTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpAccessPointTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpAccessPointTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpAccessPointTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpAccessPointTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpAccessPointTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpAccessPointTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpAccessPointTable_data *StorageTmp = sccpAccessPointTable_create();

	DEBUGMSGTL(("sccpAccessPointTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpSapId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpAccessPointAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpAccessPointAlarmStatus, &StorageTmp->sccpAccessPointAlarmStatusLen);
	if (StorageTmp->sccpAccessPointAlarmStatus == NULL) {
		config_perror("invalid specification for sccpAccessPointAlarmStatus");
		return;
	}
	SNMP_FREE(StorageTmp->sccpSap2Address);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSap2Address, &StorageTmp->sccpSap2AddressLen);
	if (StorageTmp->sccpSap2Address == NULL) {
		config_perror("invalid specification for sccpSap2Address");
		return;
	}
	SNMP_FREE(StorageTmp->sccpUserEntityNames);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpUserEntityNames, &StorageTmp->sccpUserEntityNamesLen);
	if (StorageTmp->sccpUserEntityNames == NULL) {
		config_perror("invalid specification for sccpUserEntityNames");
		return;
	}
	SNMP_FREE(StorageTmp->sccpProviderEntityNames);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpProviderEntityNames, &StorageTmp->sccpProviderEntityNamesLen);
	if (StorageTmp->sccpProviderEntityNames == NULL) {
		config_perror("invalid specification for sccpProviderEntityNames");
		return;
	}
	SNMP_FREE(StorageTmp->sccpAvailabilityStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpAvailabilityStatus, &StorageTmp->sccpAvailabilityStatusLen);
	if (StorageTmp->sccpAvailabilityStatus == NULL) {
		config_perror("invalid specification for sccpAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpConcernedAreaPointer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpLinkagePointer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSsAvailableAfterSpRestart, &tmpsize);
	SNMP_FREE(StorageTmp->sccpAccessPointName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpAccessPointName, &StorageTmp->sccpAccessPointNameLen);
	if (StorageTmp->sccpAccessPointName == NULL) {
		config_perror("invalid specification for sccpAccessPointName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAccessPointRowStatus, &tmpsize);
	sccpAccessPointTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
}

/*
 * store_sccpAccessPointTable(): store configuraiton file for sccpAccessPointTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpAccessPointTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpAccessPointTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpAccessPointTable", "storing data...  "));
	refresh_sccpAccessPointTable(1);
	(void) tmpsize;
	for (hcindex = sccpAccessPointTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpAccessPointTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpAccessPointTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpAccessPointAlarmStatus, &StorageTmp->sccpAccessPointAlarmStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSap2Address, &StorageTmp->sccpSap2AddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpUserEntityNames, &StorageTmp->sccpUserEntityNamesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpProviderEntityNames, &StorageTmp->sccpProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpAvailabilityStatus, &StorageTmp->sccpAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpConcernedAreaPointer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpLinkagePointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSsAvailableAfterSpRestart, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpAccessPointName, &StorageTmp->sccpAccessPointNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAccessPointRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpLinkageTable_data *sccpLinkageTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpLinkageTable table.
 *
 * Creates a new sccpLinkageTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpLinkageTable_data *
sccpLinkageTable_create(void)
{
	struct sccpLinkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpLinkageTable_data);

	DEBUGMSGTL(("sccpLinkageTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if (memdup((u_char **) &StorageNew->sccpOperationalProtocols, (u_char *) "\xF0", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpOperationalProtocolsLen = 1;
		if ((StorageNew->sccpSnSAP = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sccpSnSAPLen = 2;
		StorageNew->sccpAttackTimerValue = 0;
		StorageNew->sccpDecayTimerValue = 0;
		StorageNew->sccpNrOfRestrictionLevels = 8;
		StorageNew->sccpNrOfSubLevels = 4;
		StorageNew->sccpCLS = 8;
		StorageNew->sccpCongestionTimerValue = 0;
		StorageNew->sccpp = 8;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelCR, (u_char *) "\x02\x04", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelCRLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelCC, (u_char *) "\x03\x04", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelCCLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelCREF, (u_char *) "\x02\x04", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelCREFLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelDT1, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelDT1Len = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelDT2, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelDT2Len = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelAK, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelAKLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelIT, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelITLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelED, (u_char *) "\x07\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelEDLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelEA, (u_char *) "\x07\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelEALen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRSR, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelRSRLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRSC, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelRSCLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelERR, (u_char *) "\x07\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelERRLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRLC, (u_char *) "\x04\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelRLCLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRLSD, (u_char *) "\x06\x06", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelRLSDLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelUDT, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelUDTLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelUDTS, (u_char *) "\x03\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelUDTSLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelXUDT, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelXUDTLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelXUDTS, (u_char *) "\x03\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelXUDTSLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelLUDT, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelLUDTLen = 2;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelLUDTS, (u_char *) "\x03\x00", 2) == SNMPERR_SUCCESS)
			StorageNew->sccpImportanceLevelLUDTSLen = 2;
		StorageNew->sccpRLM = 0;
		StorageNew->sccpRSLM = 0;
		if ((StorageNew->sccpLinkageConcernedAreaPointer = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpLinkageConcernedAreaPointerLen = strlen("");
		StorageNew->sccpLowerLimitForSegmentation = 0;
		StorageNew->sccpUpperLimitForSegmentation = 0;
		if ((StorageNew->sccpLinkageName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpLinkageNameLen = strlen("");
		StorageNew->sccpLinkageRowStatus = 0;
		StorageNew->sccpLinkageRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpLinkageTable_data *sccpLinkageTable_duplicate(struct sccpLinkageTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpLinkageTable_data *
sccpLinkageTable_duplicate(struct sccpLinkageTable_data *thedata)
{
	struct sccpLinkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpLinkageTable_data);

	DEBUGMSGTL(("sccpLinkageTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpLinkageTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpLinkageTable_destroy(struct sccpLinkageTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpLinkageTable_destroy(struct sccpLinkageTable_data **thedata)
{
	struct sccpLinkageTable_data *StorageDel;

	DEBUGMSGTL(("sccpLinkageTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpOperationalProtocols);
		StorageDel->sccpOperationalProtocolsLen = 0;
		SNMP_FREE(StorageDel->sccpSnSAP);
		StorageDel->sccpSnSAPLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelCR);
		StorageDel->sccpImportanceLevelCRLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelCC);
		StorageDel->sccpImportanceLevelCCLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelCREF);
		StorageDel->sccpImportanceLevelCREFLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelDT1);
		StorageDel->sccpImportanceLevelDT1Len = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelDT2);
		StorageDel->sccpImportanceLevelDT2Len = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelAK);
		StorageDel->sccpImportanceLevelAKLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelIT);
		StorageDel->sccpImportanceLevelITLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelED);
		StorageDel->sccpImportanceLevelEDLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelEA);
		StorageDel->sccpImportanceLevelEALen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRSR);
		StorageDel->sccpImportanceLevelRSRLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRSC);
		StorageDel->sccpImportanceLevelRSCLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelERR);
		StorageDel->sccpImportanceLevelERRLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRLC);
		StorageDel->sccpImportanceLevelRLCLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRLSD);
		StorageDel->sccpImportanceLevelRLSDLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelUDT);
		StorageDel->sccpImportanceLevelUDTLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelUDTS);
		StorageDel->sccpImportanceLevelUDTSLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelXUDT);
		StorageDel->sccpImportanceLevelXUDTLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelXUDTS);
		StorageDel->sccpImportanceLevelXUDTSLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelLUDT);
		StorageDel->sccpImportanceLevelLUDTLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelLUDTS);
		StorageDel->sccpImportanceLevelLUDTSLen = 0;
		SNMP_FREE(StorageDel->sccpLinkageConcernedAreaPointer);
		StorageDel->sccpLinkageConcernedAreaPointerLen = 0;
		SNMP_FREE(StorageDel->sccpLinkageName);
		StorageDel->sccpLinkageNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpLinkageTable_add(struct sccpLinkageTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpLinkageTable table data set.
 *
 * Adds a table row structure to the sccpLinkageTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpLinkageTable_add(struct sccpLinkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpLinkageTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpLinkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpLinkageId, sizeof(thedata->sccpLinkageId));
	header_complex_add_data(&sccpLinkageTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpLinkageTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpLinkageTable_del(struct sccpLinkageTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpLinkageTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpLinkageTable_del(struct sccpLinkageTable_data *thedata)
{
	struct sccpLinkageTable_data *StorageDel;

	DEBUGMSGTL(("sccpLinkageTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpLinkageTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpLinkageTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpLinkageTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpLinkageTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpLinkageTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpLinkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpLinkageTable_data *StorageTmp = sccpLinkageTable_create();

	DEBUGMSGTL(("sccpLinkageTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpLinkageId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpOperationalProtocols);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpOperationalProtocols, &StorageTmp->sccpOperationalProtocolsLen);
	if (StorageTmp->sccpOperationalProtocols == NULL) {
		config_perror("invalid specification for sccpOperationalProtocols");
		return;
	}
	SNMP_FREE(StorageTmp->sccpSnSAP);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpSnSAP, &StorageTmp->sccpSnSAPLen);
	if (StorageTmp->sccpSnSAP == NULL) {
		config_perror("invalid specification for sccpSnSAP");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAttackTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpDecayTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNrOfRestrictionLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNrOfSubLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCLS, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCongestionTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpp, &tmpsize);
	SNMP_FREE(StorageTmp->sccpImportanceLevelCR);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCR, &StorageTmp->sccpImportanceLevelCRLen);
	if (StorageTmp->sccpImportanceLevelCR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCR");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelCC);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCC, &StorageTmp->sccpImportanceLevelCCLen);
	if (StorageTmp->sccpImportanceLevelCC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCC");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelCREF);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCREF, &StorageTmp->sccpImportanceLevelCREFLen);
	if (StorageTmp->sccpImportanceLevelCREF == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCREF");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelDT1);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelDT1, &StorageTmp->sccpImportanceLevelDT1Len);
	if (StorageTmp->sccpImportanceLevelDT1 == NULL) {
		config_perror("invalid specification for sccpImportanceLevelDT1");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelDT2);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelDT2, &StorageTmp->sccpImportanceLevelDT2Len);
	if (StorageTmp->sccpImportanceLevelDT2 == NULL) {
		config_perror("invalid specification for sccpImportanceLevelDT2");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelAK);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelAK, &StorageTmp->sccpImportanceLevelAKLen);
	if (StorageTmp->sccpImportanceLevelAK == NULL) {
		config_perror("invalid specification for sccpImportanceLevelAK");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelIT);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelIT, &StorageTmp->sccpImportanceLevelITLen);
	if (StorageTmp->sccpImportanceLevelIT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelIT");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelED);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelED, &StorageTmp->sccpImportanceLevelEDLen);
	if (StorageTmp->sccpImportanceLevelED == NULL) {
		config_perror("invalid specification for sccpImportanceLevelED");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelEA);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelEA, &StorageTmp->sccpImportanceLevelEALen);
	if (StorageTmp->sccpImportanceLevelEA == NULL) {
		config_perror("invalid specification for sccpImportanceLevelEA");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelRSR);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRSR, &StorageTmp->sccpImportanceLevelRSRLen);
	if (StorageTmp->sccpImportanceLevelRSR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRSR");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelRSC);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRSC, &StorageTmp->sccpImportanceLevelRSCLen);
	if (StorageTmp->sccpImportanceLevelRSC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRSC");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelERR);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelERR, &StorageTmp->sccpImportanceLevelERRLen);
	if (StorageTmp->sccpImportanceLevelERR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelERR");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelRLC);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRLC, &StorageTmp->sccpImportanceLevelRLCLen);
	if (StorageTmp->sccpImportanceLevelRLC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRLC");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelRLSD);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRLSD, &StorageTmp->sccpImportanceLevelRLSDLen);
	if (StorageTmp->sccpImportanceLevelRLSD == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRLSD");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelUDT);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelUDT, &StorageTmp->sccpImportanceLevelUDTLen);
	if (StorageTmp->sccpImportanceLevelUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelUDT");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelUDTS);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelUDTS, &StorageTmp->sccpImportanceLevelUDTSLen);
	if (StorageTmp->sccpImportanceLevelUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelUDTS");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelXUDT);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelXUDT, &StorageTmp->sccpImportanceLevelXUDTLen);
	if (StorageTmp->sccpImportanceLevelXUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelXUDT");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelXUDTS);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelXUDTS, &StorageTmp->sccpImportanceLevelXUDTSLen);
	if (StorageTmp->sccpImportanceLevelXUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelXUDTS");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelLUDT);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelLUDT, &StorageTmp->sccpImportanceLevelLUDTLen);
	if (StorageTmp->sccpImportanceLevelLUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelLUDT");
		return;
	}
	SNMP_FREE(StorageTmp->sccpImportanceLevelLUDTS);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelLUDTS, &StorageTmp->sccpImportanceLevelLUDTSLen);
	if (StorageTmp->sccpImportanceLevelLUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelLUDTS");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRLM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRSLM, &tmpsize);
	SNMP_FREE(StorageTmp->sccpLinkageConcernedAreaPointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLinkageConcernedAreaPointer, &StorageTmp->sccpLinkageConcernedAreaPointerLen);
	if (StorageTmp->sccpLinkageConcernedAreaPointer == NULL) {
		config_perror("invalid specification for sccpLinkageConcernedAreaPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLowerLimitForSegmentation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpUpperLimitForSegmentation, &tmpsize);
	SNMP_FREE(StorageTmp->sccpLinkageName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLinkageName, &StorageTmp->sccpLinkageNameLen);
	if (StorageTmp->sccpLinkageName == NULL) {
		config_perror("invalid specification for sccpLinkageName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLinkageRowStatus, &tmpsize);
	sccpLinkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
}

/*
 * store_sccpLinkageTable(): store configuraiton file for sccpLinkageTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpLinkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpLinkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpLinkageTable", "storing data...  "));
	refresh_sccpLinkageTable(1);
	(void) tmpsize;
	for (hcindex = sccpLinkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpLinkageTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpLinkageTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpLinkageId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpOperationalProtocols, &StorageTmp->sccpOperationalProtocolsLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpSnSAP, &StorageTmp->sccpSnSAPLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAttackTimerValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpDecayTimerValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNrOfRestrictionLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNrOfSubLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCLS, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCongestionTimerValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpp, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCR, &StorageTmp->sccpImportanceLevelCRLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCC, &StorageTmp->sccpImportanceLevelCCLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCREF, &StorageTmp->sccpImportanceLevelCREFLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelDT1, &StorageTmp->sccpImportanceLevelDT1Len);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelDT2, &StorageTmp->sccpImportanceLevelDT2Len);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelAK, &StorageTmp->sccpImportanceLevelAKLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelIT, &StorageTmp->sccpImportanceLevelITLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelED, &StorageTmp->sccpImportanceLevelEDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelEA, &StorageTmp->sccpImportanceLevelEALen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRSR, &StorageTmp->sccpImportanceLevelRSRLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRSC, &StorageTmp->sccpImportanceLevelRSCLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelERR, &StorageTmp->sccpImportanceLevelERRLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRLC, &StorageTmp->sccpImportanceLevelRLCLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRLSD, &StorageTmp->sccpImportanceLevelRLSDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelUDT, &StorageTmp->sccpImportanceLevelUDTLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelUDTS, &StorageTmp->sccpImportanceLevelUDTSLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelXUDT, &StorageTmp->sccpImportanceLevelXUDTLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelXUDTS, &StorageTmp->sccpImportanceLevelXUDTSLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelLUDT, &StorageTmp->sccpImportanceLevelLUDTLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelLUDTS, &StorageTmp->sccpImportanceLevelLUDTSLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRLM, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRSLM, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLinkageConcernedAreaPointer, &StorageTmp->sccpLinkageConcernedAreaPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLowerLimitForSegmentation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpUpperLimitForSegmentation, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLinkageName, &StorageTmp->sccpLinkageNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLinkageRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpSclcTable_data *sccpSclcTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpSclcTable table.
 *
 * Creates a new sccpSclcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpSclcTable_data *
sccpSclcTable_create(void)
{
	struct sccpSclcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSclcTable_data);

	DEBUGMSGTL(("sccpSclcTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if (memdup((u_char **) &StorageNew->sccpSclcAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpSclcAlarmStatusLen = 1;
		if ((StorageNew->sccpClProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpClProtocolMachineIdLen = strlen("");
		StorageNew->sccpSclcOperationalState = 0;
		StorageNew->sccpTotalRemoteSAPs = 0;
		StorageNew->sccpSclcAdministrativeState = 0;
		if (memdup((u_char **) &StorageNew->sccpSclcSupportedProtocols, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpSclcSupportedProtocolsLen = 1;
		StorageNew->sccpSclcOperationalSystemType = 0;
		StorageNew->sccpInitialValueReassTimer = 0;
		if ((StorageNew->sccpSclcName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpSclcNameLen = strlen("");
		StorageNew->sccpSclcRowStatus = 0;
		StorageNew->sccpSclcRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpSclcTable_data *sccpSclcTable_duplicate(struct sccpSclcTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpSclcTable_data *
sccpSclcTable_duplicate(struct sccpSclcTable_data *thedata)
{
	struct sccpSclcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSclcTable_data);

	DEBUGMSGTL(("sccpSclcTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpSclcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpSclcTable_destroy(struct sccpSclcTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpSclcTable_destroy(struct sccpSclcTable_data **thedata)
{
	struct sccpSclcTable_data *StorageDel;

	DEBUGMSGTL(("sccpSclcTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpSclcAlarmStatus);
		StorageDel->sccpSclcAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpClProtocolMachineId);
		StorageDel->sccpClProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->sccpSclcSupportedProtocols);
		StorageDel->sccpSclcSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->sccpSclcName);
		StorageDel->sccpSclcNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSclcTable_add(struct sccpSclcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpSclcTable table data set.
 *
 * Adds a table row structure to the sccpSclcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpSclcTable_add(struct sccpSclcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSclcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpSclcTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSclcTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSclcTable_del(struct sccpSclcTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpSclcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpSclcTable_del(struct sccpSclcTable_data *thedata)
{
	struct sccpSclcTable_data *StorageDel;

	DEBUGMSGTL(("sccpSclcTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpSclcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpSclcTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpSclcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpSclcTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpSclcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpSclcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSclcTable_data *StorageTmp = sccpSclcTable_create();

	DEBUGMSGTL(("sccpSclcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpSclcAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSclcAlarmStatus, &StorageTmp->sccpSclcAlarmStatusLen);
	if (StorageTmp->sccpSclcAlarmStatus == NULL) {
		config_perror("invalid specification for sccpSclcAlarmStatus");
		return;
	}
	SNMP_FREE(StorageTmp->sccpClProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpClProtocolMachineId, &StorageTmp->sccpClProtocolMachineIdLen);
	if (StorageTmp->sccpClProtocolMachineId == NULL) {
		config_perror("invalid specification for sccpClProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpTotalRemoteSAPs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->sccpSclcSupportedProtocols);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSclcSupportedProtocols, &StorageTmp->sccpSclcSupportedProtocolsLen);
	if (StorageTmp->sccpSclcSupportedProtocols == NULL) {
		config_perror("invalid specification for sccpSclcSupportedProtocols");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcOperationalSystemType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpInitialValueReassTimer, &tmpsize);
	SNMP_FREE(StorageTmp->sccpSclcName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSclcName, &StorageTmp->sccpSclcNameLen);
	if (StorageTmp->sccpSclcName == NULL) {
		config_perror("invalid specification for sccpSclcName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcRowStatus, &tmpsize);
	sccpSclcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
}

/*
 * store_sccpSclcTable(): store configuraiton file for sccpSclcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpSclcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSclcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSclcTable", "storing data...  "));
	refresh_sccpSclcTable(1);
	(void) tmpsize;
	for (hcindex = sccpSclcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSclcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpSclcTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSclcAlarmStatus, &StorageTmp->sccpSclcAlarmStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpClProtocolMachineId, &StorageTmp->sccpClProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpTotalRemoteSAPs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSclcSupportedProtocols, &StorageTmp->sccpSclcSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpInitialValueReassTimer, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSclcName, &StorageTmp->sccpSclcNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpScocTable_data *sccpScocTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpScocTable table.
 *
 * Creates a new sccpScocTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpScocTable_data *
sccpScocTable_create(void)
{
	struct sccpScocTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScocTable_data);

	DEBUGMSGTL(("sccpScocTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if ((StorageNew->sccpCoProtocolMachineId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpCoProtocolMachineIdLen = strlen("");
		StorageNew->sccpScocOperationalState = 0;
		StorageNew->sccpScocAdministrativeState = 0;
		StorageNew->sccpScocOperationalSystemType = 0;
		if (memdup((u_char **) &StorageNew->sccpScocSupportedProtocols, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpScocSupportedProtocolsLen = 1;
		if ((StorageNew->sccpScocName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpScocNameLen = strlen("");
		StorageNew->sccpScocRowStatus = 0;
		StorageNew->sccpScocRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpScocTable_data *sccpScocTable_duplicate(struct sccpScocTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpScocTable_data *
sccpScocTable_duplicate(struct sccpScocTable_data *thedata)
{
	struct sccpScocTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScocTable_data);

	DEBUGMSGTL(("sccpScocTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpScocTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpScocTable_destroy(struct sccpScocTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpScocTable_destroy(struct sccpScocTable_data **thedata)
{
	struct sccpScocTable_data *StorageDel;

	DEBUGMSGTL(("sccpScocTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpCoProtocolMachineId);
		StorageDel->sccpCoProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->sccpScocSupportedProtocols);
		StorageDel->sccpScocSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->sccpScocName);
		StorageDel->sccpScocNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScocTable_add(struct sccpScocTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpScocTable table data set.
 *
 * Adds a table row structure to the sccpScocTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpScocTable_add(struct sccpScocTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpScocTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpScocTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpScocTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScocTable_del(struct sccpScocTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpScocTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpScocTable_del(struct sccpScocTable_data *thedata)
{
	struct sccpScocTable_data *StorageDel;

	DEBUGMSGTL(("sccpScocTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpScocTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpScocTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpScocTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpScocTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpScocTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpScocTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpScocTable_data *StorageTmp = sccpScocTable_create();

	DEBUGMSGTL(("sccpScocTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpCoProtocolMachineId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpCoProtocolMachineId, &StorageTmp->sccpCoProtocolMachineIdLen);
	if (StorageTmp->sccpCoProtocolMachineId == NULL) {
		config_perror("invalid specification for sccpCoProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocOperationalSystemType, &tmpsize);
	SNMP_FREE(StorageTmp->sccpScocSupportedProtocols);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpScocSupportedProtocols, &StorageTmp->sccpScocSupportedProtocolsLen);
	if (StorageTmp->sccpScocSupportedProtocols == NULL) {
		config_perror("invalid specification for sccpScocSupportedProtocols");
		return;
	}
	SNMP_FREE(StorageTmp->sccpScocName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScocName, &StorageTmp->sccpScocNameLen);
	if (StorageTmp->sccpScocName == NULL) {
		config_perror("invalid specification for sccpScocName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocRowStatus, &tmpsize);
	sccpScocTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
}

/*
 * store_sccpScocTable(): store configuraiton file for sccpScocTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpScocTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpScocTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpScocTable", "storing data...  "));
	refresh_sccpScocTable(1);
	(void) tmpsize;
	for (hcindex = sccpScocTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpScocTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpScocTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpCoProtocolMachineId, &StorageTmp->sccpCoProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpScocSupportedProtocols, &StorageTmp->sccpScocSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScocName, &StorageTmp->sccpScocNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpScrcTable_data *sccpScrcTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpScrcTable table.
 *
 * Creates a new sccpScrcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpScrcTable_data *
sccpScrcTable_create(void)
{
	struct sccpScrcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScrcTable_data);

	DEBUGMSGTL(("sccpScrcTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if ((StorageNew->sccpScrcId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpScrcIdLen = strlen("");
		if (memdup((u_char **) &StorageNew->sccpScrcAlarmStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpScrcAlarmStatusLen = 1;
		if ((StorageNew->sccpScrcName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpScrcNameLen = strlen("");
		StorageNew->sccpScrcRowStatus = 0;
		StorageNew->sccpScrcRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpScrcTable_data *sccpScrcTable_duplicate(struct sccpScrcTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpScrcTable_data *
sccpScrcTable_duplicate(struct sccpScrcTable_data *thedata)
{
	struct sccpScrcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScrcTable_data);

	DEBUGMSGTL(("sccpScrcTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpScrcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpScrcTable_destroy(struct sccpScrcTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpScrcTable_destroy(struct sccpScrcTable_data **thedata)
{
	struct sccpScrcTable_data *StorageDel;

	DEBUGMSGTL(("sccpScrcTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpScrcId);
		StorageDel->sccpScrcIdLen = 0;
		SNMP_FREE(StorageDel->sccpScrcAlarmStatus);
		StorageDel->sccpScrcAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpScrcName);
		StorageDel->sccpScrcNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScrcTable_add(struct sccpScrcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpScrcTable table data set.
 *
 * Adds a table row structure to the sccpScrcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpScrcTable_add(struct sccpScrcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpScrcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpScrcTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpScrcTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScrcTable_del(struct sccpScrcTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpScrcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpScrcTable_del(struct sccpScrcTable_data *thedata)
{
	struct sccpScrcTable_data *StorageDel;

	DEBUGMSGTL(("sccpScrcTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpScrcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpScrcTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpScrcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpScrcTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpScrcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpScrcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpScrcTable_data *StorageTmp = sccpScrcTable_create();

	DEBUGMSGTL(("sccpScrcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpScrcId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScrcId, &StorageTmp->sccpScrcIdLen);
	if (StorageTmp->sccpScrcId == NULL) {
		config_perror("invalid specification for sccpScrcId");
		return;
	}
	SNMP_FREE(StorageTmp->sccpScrcAlarmStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpScrcAlarmStatus, &StorageTmp->sccpScrcAlarmStatusLen);
	if (StorageTmp->sccpScrcAlarmStatus == NULL) {
		config_perror("invalid specification for sccpScrcAlarmStatus");
		return;
	}
	SNMP_FREE(StorageTmp->sccpScrcName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScrcName, &StorageTmp->sccpScrcNameLen);
	if (StorageTmp->sccpScrcName == NULL) {
		config_perror("invalid specification for sccpScrcName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScrcRowStatus, &tmpsize);
	sccpScrcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
}

/*
 * store_sccpScrcTable(): store configuraiton file for sccpScrcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpScrcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpScrcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpScrcTable", "storing data...  "));
	refresh_sccpScrcTable(1);
	(void) tmpsize;
	for (hcindex = sccpScrcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpScrcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpScrcTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScrcId, &StorageTmp->sccpScrcIdLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpScrcAlarmStatus, &StorageTmp->sccpScrcAlarmStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScrcName, &StorageTmp->sccpScrcNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScrcRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpEntitySetTable_data *sccpEntitySetTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpEntitySetTable table.
 *
 * Creates a new sccpEntitySetTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpEntitySetTable_data *
sccpEntitySetTable_create(void)
{
	struct sccpEntitySetTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetTable_data);

	DEBUGMSGTL(("sccpEntitySetTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		StorageNew->sccpSharingMode = 0;
		if ((StorageNew->sccpLoadSharingAlgPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sccpLoadSharingAlgPointerLen = 2;
		if ((StorageNew->sccpEntitySetName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpEntitySetNameLen = strlen("");
		StorageNew->sccpEntitySetType = 0;
		/* StorageNew->sccpEntitySetSsn = (uint8_t *) strdup(0); *//* DEFVAL 0 */
		/* StorageNew->sccpEntitySetSsnLen = strlen(0); *//* DEFVAL 0 */
		StorageNew->sccpEntitySetRowStatus = 0;
		StorageNew->sccpEntitySetRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpEntitySetTable_data *sccpEntitySetTable_duplicate(struct sccpEntitySetTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpEntitySetTable_data *
sccpEntitySetTable_duplicate(struct sccpEntitySetTable_data *thedata)
{
	struct sccpEntitySetTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetTable_data);

	DEBUGMSGTL(("sccpEntitySetTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpEntitySetTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpEntitySetTable_destroy(struct sccpEntitySetTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpEntitySetTable_destroy(struct sccpEntitySetTable_data **thedata)
{
	struct sccpEntitySetTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpEntitySetId);
		StorageDel->sccpEntitySetIdLen = 0;
		SNMP_FREE(StorageDel->sccpLoadSharingAlgPointer);
		StorageDel->sccpLoadSharingAlgPointerLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetName);
		StorageDel->sccpEntitySetNameLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetSsn);
		StorageDel->sccpEntitySetSsnLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetTable_add(struct sccpEntitySetTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpEntitySetTable table data set.
 *
 * Adds a table row structure to the sccpEntitySetTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpEntitySetTable_add(struct sccpEntitySetTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpEntitySetTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpEntitySetId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpEntitySetId, thedata->sccpEntitySetIdLen);
	header_complex_add_data(&sccpEntitySetTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpEntitySetTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetTable_del(struct sccpEntitySetTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpEntitySetTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpEntitySetTable_del(struct sccpEntitySetTable_data *thedata)
{
	struct sccpEntitySetTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpEntitySetTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpEntitySetTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpEntitySetTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpEntitySetTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpEntitySetTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpEntitySetTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpEntitySetTable_data *StorageTmp = sccpEntitySetTable_create();

	DEBUGMSGTL(("sccpEntitySetTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpEntitySetId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
	if (StorageTmp->sccpEntitySetId == NULL) {
		config_perror("invalid specification for sccpEntitySetId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSharingMode, &tmpsize);
	SNMP_FREE(StorageTmp->sccpLoadSharingAlgPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpLoadSharingAlgPointer, &StorageTmp->sccpLoadSharingAlgPointerLen);
	if (StorageTmp->sccpLoadSharingAlgPointer == NULL) {
		config_perror("invalid specification for sccpLoadSharingAlgPointer");
		return;
	}
	SNMP_FREE(StorageTmp->sccpEntitySetName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetName, &StorageTmp->sccpEntitySetNameLen);
	if (StorageTmp->sccpEntitySetName == NULL) {
		config_perror("invalid specification for sccpEntitySetName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetType, &tmpsize);
	SNMP_FREE(StorageTmp->sccpEntitySetSsn);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetSsn, &StorageTmp->sccpEntitySetSsnLen);
	if (StorageTmp->sccpEntitySetSsn == NULL) {
		config_perror("invalid specification for sccpEntitySetSsn");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetRowStatus, &tmpsize);
	sccpEntitySetTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
}

/*
 * store_sccpEntitySetTable(): store configuraiton file for sccpEntitySetTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpEntitySetTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpEntitySetTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpEntitySetTable", "storing data...  "));
	refresh_sccpEntitySetTable(1);
	(void) tmpsize;
	for (hcindex = sccpEntitySetTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpEntitySetTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpEntitySetTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSharingMode, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpLoadSharingAlgPointer, &StorageTmp->sccpLoadSharingAlgPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetName, &StorageTmp->sccpEntitySetNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetSsn, &StorageTmp->sccpEntitySetSsnLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpEntitySetSapTable_data *sccpEntitySetSapTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpEntitySetSapTable table.
 *
 * Creates a new sccpEntitySetSapTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpEntitySetSapTable_data *
sccpEntitySetSapTable_create(void)
{
	struct sccpEntitySetSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetSapTable_data);

	DEBUGMSGTL(("sccpEntitySetSapTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if ((StorageNew->sccpEntitySetId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpEntitySetIdLen = strlen("");
		StorageNew->sccpEntitySetSapType = 0;
		if ((StorageNew->sccpEntitySetSapPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sccpEntitySetSapPointerLen = 2;
		StorageNew->sccpEntitySetSapRowStatus = 0;
		StorageNew->sccpEntitySetSapRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpEntitySetSapTable_data *sccpEntitySetSapTable_duplicate(struct sccpEntitySetSapTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpEntitySetSapTable_data *
sccpEntitySetSapTable_duplicate(struct sccpEntitySetSapTable_data *thedata)
{
	struct sccpEntitySetSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetSapTable_data);

	DEBUGMSGTL(("sccpEntitySetSapTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpEntitySetSapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpEntitySetSapTable_destroy(struct sccpEntitySetSapTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpEntitySetSapTable_destroy(struct sccpEntitySetSapTable_data **thedata)
{
	struct sccpEntitySetSapTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetSapTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpEntitySetId);
		StorageDel->sccpEntitySetIdLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetSapId);
		StorageDel->sccpEntitySetSapIdLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetSapPointer);
		StorageDel->sccpEntitySetSapPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetSapTable_add(struct sccpEntitySetSapTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpEntitySetSapTable table data set.
 *
 * Adds a table row structure to the sccpEntitySetSapTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpEntitySetSapTable_add(struct sccpEntitySetSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpEntitySetSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpEntitySetId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpEntitySetId, thedata->sccpEntitySetIdLen);
	/* sccpEntitySetSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpEntitySetSapId, thedata->sccpEntitySetSapIdLen);
	header_complex_add_data(&sccpEntitySetSapTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpEntitySetSapTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetSapTable_del(struct sccpEntitySetSapTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpEntitySetSapTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpEntitySetSapTable_del(struct sccpEntitySetSapTable_data *thedata)
{
	struct sccpEntitySetSapTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetSapTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpEntitySetSapTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpEntitySetSapTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpEntitySetSapTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpEntitySetSapTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpEntitySetSapTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpEntitySetSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpEntitySetSapTable_data *StorageTmp = sccpEntitySetSapTable_create();

	DEBUGMSGTL(("sccpEntitySetSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpEntitySetId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
	if (StorageTmp->sccpEntitySetId == NULL) {
		config_perror("invalid specification for sccpEntitySetId");
		return;
	}
	SNMP_FREE(StorageTmp->sccpEntitySetSapId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetSapId, &StorageTmp->sccpEntitySetSapIdLen);
	if (StorageTmp->sccpEntitySetSapId == NULL) {
		config_perror("invalid specification for sccpEntitySetSapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetSapType, &tmpsize);
	SNMP_FREE(StorageTmp->sccpEntitySetSapPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpEntitySetSapPointer, &StorageTmp->sccpEntitySetSapPointerLen);
	if (StorageTmp->sccpEntitySetSapPointer == NULL) {
		config_perror("invalid specification for sccpEntitySetSapPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetSapRowStatus, &tmpsize);
	sccpEntitySetSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
}

/*
 * store_sccpEntitySetSapTable(): store configuraiton file for sccpEntitySetSapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpEntitySetSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpEntitySetSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpEntitySetSapTable", "storing data...  "));
	refresh_sccpEntitySetSapTable(1);
	(void) tmpsize;
	for (hcindex = sccpEntitySetSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpEntitySetSapTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpEntitySetSapTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetSapId, &StorageTmp->sccpEntitySetSapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetSapType, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpEntitySetSapPointer, &StorageTmp->sccpEntitySetSapPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetSapRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpConcernedAreaTable_data *sccpConcernedAreaTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpConcernedAreaTable table.
 *
 * Creates a new sccpConcernedAreaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpConcernedAreaTable_data *
sccpConcernedAreaTable_create(void)
{
	struct sccpConcernedAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpConcernedAreaTable_data);

	DEBUGMSGTL(("sccpConcernedAreaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		StorageNew->sccpConcernedAreaRowStatus = 0;
		StorageNew->sccpConcernedAreaRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpConcernedAreaTable_data *sccpConcernedAreaTable_duplicate(struct sccpConcernedAreaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpConcernedAreaTable_data *
sccpConcernedAreaTable_duplicate(struct sccpConcernedAreaTable_data *thedata)
{
	struct sccpConcernedAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpConcernedAreaTable_data);

	DEBUGMSGTL(("sccpConcernedAreaTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpConcernedAreaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpConcernedAreaTable_destroy(struct sccpConcernedAreaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpConcernedAreaTable_destroy(struct sccpConcernedAreaTable_data **thedata)
{
	struct sccpConcernedAreaTable_data *StorageDel;

	DEBUGMSGTL(("sccpConcernedAreaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpConcernedAreaId);
		StorageDel->sccpConcernedAreaIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpConcernedAreaTable_add(struct sccpConcernedAreaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpConcernedAreaTable table data set.
 *
 * Adds a table row structure to the sccpConcernedAreaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpConcernedAreaTable_add(struct sccpConcernedAreaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpConcernedAreaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpConcernedAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpConcernedAreaId, thedata->sccpConcernedAreaIdLen);
	header_complex_add_data(&sccpConcernedAreaTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpConcernedAreaTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpConcernedAreaTable_del(struct sccpConcernedAreaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpConcernedAreaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpConcernedAreaTable_del(struct sccpConcernedAreaTable_data *thedata)
{
	struct sccpConcernedAreaTable_data *StorageDel;

	DEBUGMSGTL(("sccpConcernedAreaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpConcernedAreaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpConcernedAreaTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpConcernedAreaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpConcernedAreaTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpConcernedAreaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpConcernedAreaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpConcernedAreaTable_data *StorageTmp = sccpConcernedAreaTable_create();

	DEBUGMSGTL(("sccpConcernedAreaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpConcernedAreaId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
	if (StorageTmp->sccpConcernedAreaId == NULL) {
		config_perror("invalid specification for sccpConcernedAreaId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpConcernedAreaRowStatus, &tmpsize);
	sccpConcernedAreaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
}

/*
 * store_sccpConcernedAreaTable(): store configuraiton file for sccpConcernedAreaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpConcernedAreaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpConcernedAreaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpConcernedAreaTable", "storing data...  "));
	refresh_sccpConcernedAreaTable(1);
	(void) tmpsize;
	for (hcindex = sccpConcernedAreaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpConcernedAreaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpConcernedAreaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpConcernedAreaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpRemoteSCCPTable_data *sccpRemoteSCCPTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpRemoteSCCPTable table.
 *
 * Creates a new sccpRemoteSCCPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpRemoteSCCPTable_data *
sccpRemoteSCCPTable_create(void)
{
	struct sccpRemoteSCCPTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpRemoteSCCPTable_data);

	DEBUGMSGTL(("sccpRemoteSCCPTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if ((StorageNew->sccpConcernedAreaId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpConcernedAreaIdLen = strlen("");
		if ((StorageNew->sccpRemoteSCCPMTPAccessPoint = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->sccpRemoteSCCPMTPAccessPointLen = 2;
		if ((StorageNew->sccpRemoteSCCPName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpRemoteSCCPNameLen = strlen("");
		StorageNew->sccpRemoteSCCPRowStatus = 0;
		StorageNew->sccpRemoteSCCPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpRemoteSCCPTable_data *sccpRemoteSCCPTable_duplicate(struct sccpRemoteSCCPTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpRemoteSCCPTable_data *
sccpRemoteSCCPTable_duplicate(struct sccpRemoteSCCPTable_data *thedata)
{
	struct sccpRemoteSCCPTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpRemoteSCCPTable_data);

	DEBUGMSGTL(("sccpRemoteSCCPTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpRemoteSCCPTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpRemoteSCCPTable_destroy(struct sccpRemoteSCCPTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpRemoteSCCPTable_destroy(struct sccpRemoteSCCPTable_data **thedata)
{
	struct sccpRemoteSCCPTable_data *StorageDel;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpConcernedAreaId);
		StorageDel->sccpConcernedAreaIdLen = 0;
		SNMP_FREE(StorageDel->sccpRemoteSCCPId);
		StorageDel->sccpRemoteSCCPIdLen = 0;
		SNMP_FREE(StorageDel->sccpRemoteSCCPMTPAccessPoint);
		StorageDel->sccpRemoteSCCPMTPAccessPointLen = 0;
		SNMP_FREE(StorageDel->sccpRemoteSCCPName);
		StorageDel->sccpRemoteSCCPNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpRemoteSCCPTable_add(struct sccpRemoteSCCPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpRemoteSCCPTable table data set.
 *
 * Adds a table row structure to the sccpRemoteSCCPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpRemoteSCCPTable_add(struct sccpRemoteSCCPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpConcernedAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpConcernedAreaId, thedata->sccpConcernedAreaIdLen);
	/* sccpRemoteSCCPId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpRemoteSCCPId, thedata->sccpRemoteSCCPIdLen);
	header_complex_add_data(&sccpRemoteSCCPTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpRemoteSCCPTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpRemoteSCCPTable_del(struct sccpRemoteSCCPTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpRemoteSCCPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpRemoteSCCPTable_del(struct sccpRemoteSCCPTable_data *thedata)
{
	struct sccpRemoteSCCPTable_data *StorageDel;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpRemoteSCCPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpRemoteSCCPTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpRemoteSCCPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpRemoteSCCPTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpRemoteSCCPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpRemoteSCCPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpRemoteSCCPTable_data *StorageTmp = sccpRemoteSCCPTable_create();

	DEBUGMSGTL(("sccpRemoteSCCPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpConcernedAreaId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
	if (StorageTmp->sccpConcernedAreaId == NULL) {
		config_perror("invalid specification for sccpConcernedAreaId");
		return;
	}
	SNMP_FREE(StorageTmp->sccpRemoteSCCPId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRemoteSCCPId, &StorageTmp->sccpRemoteSCCPIdLen);
	if (StorageTmp->sccpRemoteSCCPId == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPId");
		return;
	}
	SNMP_FREE(StorageTmp->sccpRemoteSCCPMTPAccessPoint);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpRemoteSCCPMTPAccessPoint, &StorageTmp->sccpRemoteSCCPMTPAccessPointLen);
	if (StorageTmp->sccpRemoteSCCPMTPAccessPoint == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPMTPAccessPoint");
		return;
	}
	SNMP_FREE(StorageTmp->sccpRemoteSCCPName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRemoteSCCPName, &StorageTmp->sccpRemoteSCCPNameLen);
	if (StorageTmp->sccpRemoteSCCPName == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRemoteSCCPRowStatus, &tmpsize);
	sccpRemoteSCCPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
}

/*
 * store_sccpRemoteSCCPTable(): store configuraiton file for sccpRemoteSCCPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpRemoteSCCPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpRemoteSCCPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "storing data...  "));
	refresh_sccpRemoteSCCPTable(1);
	(void) tmpsize;
	for (hcindex = sccpRemoteSCCPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpRemoteSCCPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpRemoteSCCPTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRemoteSCCPId, &StorageTmp->sccpRemoteSCCPIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpRemoteSCCPMTPAccessPoint, &StorageTmp->sccpRemoteSCCPMTPAccessPointLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRemoteSCCPName, &StorageTmp->sccpRemoteSCCPNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRemoteSCCPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpGtConversionRuleTable_data *sccpGtConversionRuleTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpGtConversionRuleTable table.
 *
 * Creates a new sccpGtConversionRuleTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpGtConversionRuleTable_data *
sccpGtConversionRuleTable_create(void)
{
	struct sccpGtConversionRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtConversionRuleTable_data);

	DEBUGMSGTL(("sccpGtConversionRuleTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		StorageNew->sccpGtNewEncodingScheme = 256;
		StorageNew->sccpGtNewNatureOfAddress = 256;
		StorageNew->sccpGtNewNumberingPlan = 256;
		StorageNew->sccpGtNewTranslationType = 256;
		if ((StorageNew->sccpGtConversionRuleName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtConversionRuleNameLen = strlen("");
		StorageNew->sccpGtConversionRuleRowStatus = 0;
		StorageNew->sccpGtConversionRuleRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpGtConversionRuleTable_data *sccpGtConversionRuleTable_duplicate(struct sccpGtConversionRuleTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpGtConversionRuleTable_data *
sccpGtConversionRuleTable_duplicate(struct sccpGtConversionRuleTable_data *thedata)
{
	struct sccpGtConversionRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtConversionRuleTable_data);

	DEBUGMSGTL(("sccpGtConversionRuleTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpGtConversionRuleTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpGtConversionRuleTable_destroy(struct sccpGtConversionRuleTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpGtConversionRuleTable_destroy(struct sccpGtConversionRuleTable_data **thedata)
{
	struct sccpGtConversionRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtConversionRuleId);
		StorageDel->sccpGtConversionRuleIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtConversionRuleName);
		StorageDel->sccpGtConversionRuleNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtConversionRuleTable_add(struct sccpGtConversionRuleTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpGtConversionRuleTable table data set.
 *
 * Adds a table row structure to the sccpGtConversionRuleTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpGtConversionRuleTable_add(struct sccpGtConversionRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtConversionRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtConversionRuleId, thedata->sccpGtConversionRuleIdLen);
	header_complex_add_data(&sccpGtConversionRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtConversionRuleTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtConversionRuleTable_del(struct sccpGtConversionRuleTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpGtConversionRuleTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpGtConversionRuleTable_del(struct sccpGtConversionRuleTable_data *thedata)
{
	struct sccpGtConversionRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpGtConversionRuleTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpGtConversionRuleTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpGtConversionRuleTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpGtConversionRuleTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpGtConversionRuleTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpGtConversionRuleTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtConversionRuleTable_data *StorageTmp = sccpGtConversionRuleTable_create();

	DEBUGMSGTL(("sccpGtConversionRuleTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtConversionRuleId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
	if (StorageTmp->sccpGtConversionRuleId == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewEncodingScheme, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewNatureOfAddress, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewNumberingPlan, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewTranslationType, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtConversionRuleName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleName, &StorageTmp->sccpGtConversionRuleNameLen);
	if (StorageTmp->sccpGtConversionRuleName == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtConversionRuleRowStatus, &tmpsize);
	sccpGtConversionRuleTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
}

/*
 * store_sccpGtConversionRuleTable(): store configuraiton file for sccpGtConversionRuleTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtConversionRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtConversionRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "storing data...  "));
	refresh_sccpGtConversionRuleTable(1);
	(void) tmpsize;
	for (hcindex = sccpGtConversionRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtConversionRuleTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpGtConversionRuleTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewEncodingScheme, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewNatureOfAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewNumberingPlan, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewTranslationType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleName, &StorageTmp->sccpGtConversionRuleNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtConversionRuleRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpAddressInfoTable_data *sccpAddressInfoTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpAddressInfoTable table.
 *
 * Creates a new sccpAddressInfoTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpAddressInfoTable_data *
sccpAddressInfoTable_create(void)
{
	struct sccpAddressInfoTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAddressInfoTable_data);

	DEBUGMSGTL(("sccpAddressInfoTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if ((StorageNew->sccpGtConversionRuleId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtConversionRuleIdLen = strlen("");
		StorageNew->sccpAddressInfoOperation = 0;
		StorageNew->sccpAddressInfoAddressElement = 0;
		StorageNew->sccpAddressInfoNrOfAddressElements = 0;
		StorageNew->sccpAddressInfoRowStatus = 0;
		StorageNew->sccpAddressInfoRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpAddressInfoTable_data *sccpAddressInfoTable_duplicate(struct sccpAddressInfoTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpAddressInfoTable_data *
sccpAddressInfoTable_duplicate(struct sccpAddressInfoTable_data *thedata)
{
	struct sccpAddressInfoTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAddressInfoTable_data);

	DEBUGMSGTL(("sccpAddressInfoTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpAddressInfoTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpAddressInfoTable_destroy(struct sccpAddressInfoTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpAddressInfoTable_destroy(struct sccpAddressInfoTable_data **thedata)
{
	struct sccpAddressInfoTable_data *StorageDel;

	DEBUGMSGTL(("sccpAddressInfoTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtConversionRuleId);
		StorageDel->sccpGtConversionRuleIdLen = 0;
		SNMP_FREE(StorageDel->sccpAddressInfoOperationId);
		StorageDel->sccpAddressInfoOperationIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAddressInfoTable_add(struct sccpAddressInfoTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpAddressInfoTable table data set.
 *
 * Adds a table row structure to the sccpAddressInfoTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpAddressInfoTable_add(struct sccpAddressInfoTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpAddressInfoTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtConversionRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtConversionRuleId, thedata->sccpGtConversionRuleIdLen);
	/* sccpAddressInfoOperationId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpAddressInfoOperationId, thedata->sccpAddressInfoOperationIdLen);
	header_complex_add_data(&sccpAddressInfoTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpAddressInfoTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAddressInfoTable_del(struct sccpAddressInfoTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpAddressInfoTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpAddressInfoTable_del(struct sccpAddressInfoTable_data *thedata)
{
	struct sccpAddressInfoTable_data *StorageDel;

	DEBUGMSGTL(("sccpAddressInfoTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpAddressInfoTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpAddressInfoTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpAddressInfoTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpAddressInfoTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpAddressInfoTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpAddressInfoTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpAddressInfoTable_data *StorageTmp = sccpAddressInfoTable_create();

	DEBUGMSGTL(("sccpAddressInfoTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtConversionRuleId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
	if (StorageTmp->sccpGtConversionRuleId == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleId");
		return;
	}
	SNMP_FREE(StorageTmp->sccpAddressInfoOperationId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpAddressInfoOperationId, &StorageTmp->sccpAddressInfoOperationIdLen);
	if (StorageTmp->sccpAddressInfoOperationId == NULL) {
		config_perror("invalid specification for sccpAddressInfoOperationId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoOperation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoAddressElement, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoNrOfAddressElements, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoRowStatus, &tmpsize);
	sccpAddressInfoTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
}

/*
 * store_sccpAddressInfoTable(): store configuraiton file for sccpAddressInfoTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpAddressInfoTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpAddressInfoTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpAddressInfoTable", "storing data...  "));
	refresh_sccpAddressInfoTable(1);
	(void) tmpsize;
	for (hcindex = sccpAddressInfoTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpAddressInfoTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpAddressInfoTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpAddressInfoOperationId, &StorageTmp->sccpAddressInfoOperationIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoOperation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoAddressElement, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoNrOfAddressElements, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpGtTranslatorTable_data *sccpGtTranslatorTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpGtTranslatorTable table.
 *
 * Creates a new sccpGtTranslatorTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpGtTranslatorTable_data *
sccpGtTranslatorTable_create(void)
{
	struct sccpGtTranslatorTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtTranslatorTable_data);

	DEBUGMSGTL(("sccpGtTranslatorTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		StorageNew->sccpGtIndicator = 0;
		StorageNew->sccpGtNatureOfAddress = 0;
		StorageNew->sccpGtNumberingPlan = 0;
		StorageNew->sccpGtTranslationType = 0;
		StorageNew->sccpGtTranslatorAdministrativeState = 0;
		if ((StorageNew->sccpGtTranslatorName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtTranslatorNameLen = strlen("");
		StorageNew->sccpGtTranslatorRowStatus = 0;
		StorageNew->sccpGtTranslatorRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpGtTranslatorTable_data *sccpGtTranslatorTable_duplicate(struct sccpGtTranslatorTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpGtTranslatorTable_data *
sccpGtTranslatorTable_duplicate(struct sccpGtTranslatorTable_data *thedata)
{
	struct sccpGtTranslatorTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtTranslatorTable_data);

	DEBUGMSGTL(("sccpGtTranslatorTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpGtTranslatorTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpGtTranslatorTable_destroy(struct sccpGtTranslatorTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpGtTranslatorTable_destroy(struct sccpGtTranslatorTable_data **thedata)
{
	struct sccpGtTranslatorTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtTranslatorTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtTranslatorId);
		StorageDel->sccpGtTranslatorIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtTranslatorName);
		StorageDel->sccpGtTranslatorNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtTranslatorTable_add(struct sccpGtTranslatorTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpGtTranslatorTable table data set.
 *
 * Adds a table row structure to the sccpGtTranslatorTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpGtTranslatorTable_add(struct sccpGtTranslatorTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtTranslatorTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtTranslatorId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtTranslatorId, thedata->sccpGtTranslatorIdLen);
	header_complex_add_data(&sccpGtTranslatorTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtTranslatorTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtTranslatorTable_del(struct sccpGtTranslatorTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpGtTranslatorTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpGtTranslatorTable_del(struct sccpGtTranslatorTable_data *thedata)
{
	struct sccpGtTranslatorTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtTranslatorTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpGtTranslatorTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpGtTranslatorTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpGtTranslatorTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpGtTranslatorTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpGtTranslatorTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpGtTranslatorTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtTranslatorTable_data *StorageTmp = sccpGtTranslatorTable_create();

	DEBUGMSGTL(("sccpGtTranslatorTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtTranslatorId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
	if (StorageTmp->sccpGtTranslatorId == NULL) {
		config_perror("invalid specification for sccpGtTranslatorId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtIndicator, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNatureOfAddress, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNumberingPlan, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslationType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslatorAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtTranslatorName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorName, &StorageTmp->sccpGtTranslatorNameLen);
	if (StorageTmp->sccpGtTranslatorName == NULL) {
		config_perror("invalid specification for sccpGtTranslatorName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslatorRowStatus, &tmpsize);
	sccpGtTranslatorTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
}

/*
 * store_sccpGtTranslatorTable(): store configuraiton file for sccpGtTranslatorTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtTranslatorTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtTranslatorTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtTranslatorTable", "storing data...  "));
	refresh_sccpGtTranslatorTable(1);
	(void) tmpsize;
	for (hcindex = sccpGtTranslatorTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtTranslatorTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpGtTranslatorTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNatureOfAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNumberingPlan, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslationType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslatorAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorName, &StorageTmp->sccpGtTranslatorNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslatorRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpGtRuleTable_data *sccpGtRuleTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpGtRuleTable table.
 *
 * Creates a new sccpGtRuleTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpGtRuleTable_data *
sccpGtRuleTable_create(void)
{
	struct sccpGtRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtRuleTable_data);

	DEBUGMSGTL(("sccpGtRuleTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		if ((StorageNew->sccpGtTranslatorId = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtTranslatorIdLen = strlen("");
		StorageNew->sccpGtRuleAdministrativeState = 0;
		if ((StorageNew->sccpGtAddressInformation = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtAddressInformationLen = strlen("");
		if ((StorageNew->sccpGtConvRulePointer = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtConvRulePointerLen = strlen("");
		StorageNew->sccpGtEncodingScheme = 0;
		if ((StorageNew->sccpEntitySetPointer = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpEntitySetPointerLen = strlen("");
		if ((StorageNew->sccpGtRuleName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpGtRuleNameLen = strlen("");
		StorageNew->sccpGtRuleRowStatus = 0;
		StorageNew->sccpGtRuleRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpGtRuleTable_data *sccpGtRuleTable_duplicate(struct sccpGtRuleTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpGtRuleTable_data *
sccpGtRuleTable_duplicate(struct sccpGtRuleTable_data *thedata)
{
	struct sccpGtRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtRuleTable_data);

	DEBUGMSGTL(("sccpGtRuleTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpGtRuleTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpGtRuleTable_destroy(struct sccpGtRuleTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpGtRuleTable_destroy(struct sccpGtRuleTable_data **thedata)
{
	struct sccpGtRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtRuleTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtTranslatorId);
		StorageDel->sccpGtTranslatorIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtRuleId);
		StorageDel->sccpGtRuleIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtAddressInformation);
		StorageDel->sccpGtAddressInformationLen = 0;
		SNMP_FREE(StorageDel->sccpGtConvRulePointer);
		StorageDel->sccpGtConvRulePointerLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetPointer);
		StorageDel->sccpEntitySetPointerLen = 0;
		SNMP_FREE(StorageDel->sccpGtRuleName);
		StorageDel->sccpGtRuleNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtRuleTable_add(struct sccpGtRuleTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpGtRuleTable table data set.
 *
 * Adds a table row structure to the sccpGtRuleTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpGtRuleTable_add(struct sccpGtRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtTranslatorId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtTranslatorId, thedata->sccpGtTranslatorIdLen);
	/* sccpGtRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtRuleId, thedata->sccpGtRuleIdLen);
	header_complex_add_data(&sccpGtRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtRuleTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtRuleTable_del(struct sccpGtRuleTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpGtRuleTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpGtRuleTable_del(struct sccpGtRuleTable_data *thedata)
{
	struct sccpGtRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtRuleTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpGtRuleTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpGtRuleTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpGtRuleTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpGtRuleTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpGtRuleTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpGtRuleTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtRuleTable_data *StorageTmp = sccpGtRuleTable_create();

	DEBUGMSGTL(("sccpGtRuleTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtTranslatorId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
	if (StorageTmp->sccpGtTranslatorId == NULL) {
		config_perror("invalid specification for sccpGtTranslatorId");
		return;
	}
	SNMP_FREE(StorageTmp->sccpGtRuleId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtRuleId, &StorageTmp->sccpGtRuleIdLen);
	if (StorageTmp->sccpGtRuleId == NULL) {
		config_perror("invalid specification for sccpGtRuleId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtRuleAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->sccpGtAddressInformation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtAddressInformation, &StorageTmp->sccpGtAddressInformationLen);
	if (StorageTmp->sccpGtAddressInformation == NULL) {
		config_perror("invalid specification for sccpGtAddressInformation");
		return;
	}
	SNMP_FREE(StorageTmp->sccpGtConvRulePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConvRulePointer, &StorageTmp->sccpGtConvRulePointerLen);
	if (StorageTmp->sccpGtConvRulePointer == NULL) {
		config_perror("invalid specification for sccpGtConvRulePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtEncodingScheme, &tmpsize);
	SNMP_FREE(StorageTmp->sccpEntitySetPointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetPointer, &StorageTmp->sccpEntitySetPointerLen);
	if (StorageTmp->sccpEntitySetPointer == NULL) {
		config_perror("invalid specification for sccpEntitySetPointer");
		return;
	}
	SNMP_FREE(StorageTmp->sccpGtRuleName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtRuleName, &StorageTmp->sccpGtRuleNameLen);
	if (StorageTmp->sccpGtRuleName == NULL) {
		config_perror("invalid specification for sccpGtRuleName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtRuleRowStatus, &tmpsize);
	sccpGtRuleTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
}

/*
 * store_sccpGtRuleTable(): store configuraiton file for sccpGtRuleTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtRuleTable", "storing data...  "));
	refresh_sccpGtRuleTable(1);
	(void) tmpsize;
	for (hcindex = sccpGtRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtRuleTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpGtRuleTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtRuleId, &StorageTmp->sccpGtRuleIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtRuleAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtAddressInformation, &StorageTmp->sccpGtAddressInformationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConvRulePointer, &StorageTmp->sccpGtConvRulePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtEncodingScheme, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetPointer, &StorageTmp->sccpEntitySetPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtRuleName, &StorageTmp->sccpGtRuleNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtRuleRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpSrvtTable_data *sccpSrvtTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpSrvtTable table.
 *
 * Creates a new sccpSrvtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpSrvtTable_data *
sccpSrvtTable_create(void)
{
	struct sccpSrvtTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSrvtTable_data);

	DEBUGMSGTL(("sccpSrvtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpNetworkEntityId = 0;
		StorageNew->sccpDSRVT = 0;
		StorageNew->sccpNSRVT = 0;
		if ((StorageNew->sccpSrvtName = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpSrvtNameLen = strlen("");
		StorageNew->sccpAdministrativeState = 0;
		StorageNew->sccpOperationalState = 0;
		if (memdup((u_char **) &StorageNew->sccpProceduralStatus, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpProceduralStatusLen = 1;
		StorageNew->sccpTraceRequested = 0;
		StorageNew->sccpThreshold = 0;
		StorageNew->sccpMtpBackwardRoutingRequested = 2;
		if ((StorageNew->sccpOriginalGT = (uint8_t *) strdup("")) != NULL)
			StorageNew->sccpOriginalGTLen = strlen("");
		if (memdup((u_char **) &StorageNew->sccpInfoRequest, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpInfoRequestLen = 1;
		if (memdup((u_char **) &StorageNew->sccpReturnUnknownParams, (u_char *) "\x00", 1) == SNMPERR_SUCCESS)
			StorageNew->sccpReturnUnknownParamsLen = 1;
		StorageNew->sccpRouteTestRowStatus = 0;
		StorageNew->sccpRouteTestRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpSrvtTable_data *sccpSrvtTable_duplicate(struct sccpSrvtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpSrvtTable_data *
sccpSrvtTable_duplicate(struct sccpSrvtTable_data *thedata)
{
	struct sccpSrvtTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSrvtTable_data);

	DEBUGMSGTL(("sccpSrvtTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpSrvtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpSrvtTable_destroy(struct sccpSrvtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpSrvtTable_destroy(struct sccpSrvtTable_data **thedata)
{
	struct sccpSrvtTable_data *StorageDel;

	DEBUGMSGTL(("sccpSrvtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpRouteTestId);
		StorageDel->sccpRouteTestIdLen = 0;
		SNMP_FREE(StorageDel->sccpSrvtName);
		StorageDel->sccpSrvtNameLen = 0;
		SNMP_FREE(StorageDel->sccpProceduralStatus);
		StorageDel->sccpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->sccpOriginalGT);
		StorageDel->sccpOriginalGTLen = 0;
		SNMP_FREE(StorageDel->sccpInfoRequest);
		StorageDel->sccpInfoRequestLen = 0;
		SNMP_FREE(StorageDel->sccpReturnUnknownParams);
		StorageDel->sccpReturnUnknownParamsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSrvtTable_add(struct sccpSrvtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpSrvtTable table data set.
 *
 * Adds a table row structure to the sccpSrvtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpSrvtTable_add(struct sccpSrvtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSrvtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpRouteTestId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpRouteTestId, thedata->sccpRouteTestIdLen);
	header_complex_add_data(&sccpSrvtTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSrvtTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSrvtTable_del(struct sccpSrvtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the sccpSrvtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpSrvtTable_del(struct sccpSrvtTable_data *thedata)
{
	struct sccpSrvtTable_data *StorageDel;

	DEBUGMSGTL(("sccpSrvtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpSrvtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpSrvtTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpSrvtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpSrvtTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpSrvtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpSrvtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSrvtTable_data *StorageTmp = sccpSrvtTable_create();

	DEBUGMSGTL(("sccpSrvtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	SNMP_FREE(StorageTmp->sccpRouteTestId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRouteTestId, &StorageTmp->sccpRouteTestIdLen);
	if (StorageTmp->sccpRouteTestId == NULL) {
		config_perror("invalid specification for sccpRouteTestId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpDSRVT, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNSRVT, &tmpsize);
	SNMP_FREE(StorageTmp->sccpSrvtName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSrvtName, &StorageTmp->sccpSrvtNameLen);
	if (StorageTmp->sccpSrvtName == NULL) {
		config_perror("invalid specification for sccpSrvtName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->sccpProceduralStatus);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpProceduralStatus, &StorageTmp->sccpProceduralStatusLen);
	if (StorageTmp->sccpProceduralStatus == NULL) {
		config_perror("invalid specification for sccpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpTraceRequested, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpThreshold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpMtpBackwardRoutingRequested, &tmpsize);
	SNMP_FREE(StorageTmp->sccpOriginalGT);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpOriginalGT, &StorageTmp->sccpOriginalGTLen);
	if (StorageTmp->sccpOriginalGT == NULL) {
		config_perror("invalid specification for sccpOriginalGT");
		return;
	}
	SNMP_FREE(StorageTmp->sccpInfoRequest);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpInfoRequest, &StorageTmp->sccpInfoRequestLen);
	if (StorageTmp->sccpInfoRequest == NULL) {
		config_perror("invalid specification for sccpInfoRequest");
		return;
	}
	SNMP_FREE(StorageTmp->sccpReturnUnknownParams);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpReturnUnknownParams, &StorageTmp->sccpReturnUnknownParamsLen);
	if (StorageTmp->sccpReturnUnknownParams == NULL) {
		config_perror("invalid specification for sccpReturnUnknownParams");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRouteTestRowStatus, &tmpsize);
	sccpSrvtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
}

/*
 * store_sccpSrvtTable(): store configuraiton file for sccpSrvtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpSrvtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSrvtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSrvtTable", "storing data...  "));
	refresh_sccpSrvtTable(1);
	(void) tmpsize;
	for (hcindex = sccpSrvtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSrvtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpSrvtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRouteTestId, &StorageTmp->sccpRouteTestIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpDSRVT, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNSRVT, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSrvtName, &StorageTmp->sccpSrvtNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpProceduralStatus, &StorageTmp->sccpProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpTraceRequested, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpThreshold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpMtpBackwardRoutingRequested, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpOriginalGT, &StorageTmp->sccpOriginalGTLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpInfoRequest, &StorageTmp->sccpInfoRequestLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpReturnUnknownParams, &StorageTmp->sccpReturnUnknownParamsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRouteTestRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_sccpNetworkEntityTable_row(struct sccpNetworkEntityTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpNetworkEntityTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpNetworkEntityTable_row(struct sccpNetworkEntityTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpNetworkEntityTable_request == sa_request))
		return;
	StorageTmp->sccpNetworkEntityTable_request = sa_request;
}

/**
 * @fn void refresh_sccpNetworkEntityTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpNetworkEntityTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpNetworkEntityTable(int force)
{
	if (!force && sccpNetworkEntityTable_refresh == 0)
		return;
	sccpNetworkEntityTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpNetworkEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpNetworkEntityTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpNetworkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpNetworkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpNetworkEntityTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpNetworkEntityTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPNETWORKENTITYALARMSTATUS:	/* Create */
		*write_method = write_sccpNetworkEntityAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		rval = (u_char *) StorageTmp->sccpNetworkEntityAlarmStatus;
		break;
	case (u_char) SCCPSYSTEMTYPES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSystemTypesLen;
		rval = (u_char *) StorageTmp->sccpSystemTypes;
		break;
	case (u_char) SCCPVERSION:	/* Create */
		*write_method = write_sccpVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpVersionLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sccpVersion;
		break;
	case (u_char) SCCPLUDTANDLUDTSSUPPORTED:	/* Create */
		*write_method = write_sccpLUDTandLUDTSSupported;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpLUDTandLUDTSSupported);
		rval = (u_char *) &StorageTmp->sccpLUDTandLUDTSSupported;
		break;
	case (u_char) SCCPCOORDCHANGETIMER:	/* Create */
		*write_method = write_sccpCoordChangeTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpCoordChangeTimer);
		rval = (u_char *) &StorageTmp->sccpCoordChangeTimer;
		break;
	case (u_char) SCCPIGNORESSTTIMER:	/* Create */
		*write_method = write_sccpIgnoreSSTTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpIgnoreSSTTimer);
		rval = (u_char *) &StorageTmp->sccpIgnoreSSTTimer;
		break;
	case (u_char) SCCPMAXSTATINFOTIMER:	/* Create */
		*write_method = write_sccpMaxStatInfoTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpMaxStatInfoTimer);
		rval = (u_char *) &StorageTmp->sccpMaxStatInfoTimer;
		break;
	case (u_char) SCCPNETWORKENTITYNAME:	/* Create */
		*write_method = write_sccpNetworkEntityName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpNetworkEntityNameLen;
		rval = (u_char *) StorageTmp->sccpNetworkEntityName;
		break;
	case (u_char) SCCPROWSTATUS:	/* Create */
		*write_method = write_sccpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpRowStatus);
		rval = (u_char *) &StorageTmp->sccpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpSapNameTable_row(struct sccpSapNameTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpSapNameTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpSapNameTable_row(struct sccpSapNameTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpSapNameTable_request == sa_request))
		return;
	StorageTmp->sccpSapNameTable_request = sa_request;
}

/**
 * @fn void refresh_sccpSapNameTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpSapNameTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpSapNameTable(int force)
{
	if (!force && sccpSapNameTable_refresh == 0)
		return;
	sccpSapNameTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpSapNameTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpSapNameTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpSapNameTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSapNameTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpSapNameTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpSapNameTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpSapNameTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpSapNameTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPSAPNAMEROWSTATUS:	/* Create */
		*write_method = write_sccpSapNameRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSapNameRowStatus);
		rval = (u_char *) &StorageTmp->sccpSapNameRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpAccessPointTable_row(struct sccpAccessPointTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpAccessPointTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpAccessPointTable_row(struct sccpAccessPointTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpAccessPointTable_request == sa_request))
		return;
	StorageTmp->sccpAccessPointTable_request = sa_request;
}

/**
 * @fn void refresh_sccpAccessPointTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpAccessPointTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpAccessPointTable(int force)
{
	if (!force && sccpAccessPointTable_refresh == 0)
		return;
	sccpAccessPointTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpAccessPointTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpAccessPointTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpAccessPointTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpAccessPointTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpAccessPointTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpAccessPointTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpAccessPointTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPACCESSPOINTALARMSTATUS:	/* Create */
		*write_method = write_sccpAccessPointAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpAccessPointAlarmStatusLen;
		rval = (u_char *) StorageTmp->sccpAccessPointAlarmStatus;
		break;
	case (u_char) SCCPSAP2ADDRESS:	/* Create */
		*write_method = write_sccpSap2Address;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSap2AddressLen;
		rval = (u_char *) StorageTmp->sccpSap2Address;
		break;
	case (u_char) SCCPUSERENTITYNAMES:	/* Create */
		*write_method = write_sccpUserEntityNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpUserEntityNamesLen;
		rval = (u_char *) StorageTmp->sccpUserEntityNames;
		break;
	case (u_char) SCCPPROVIDERENTITYNAMES:	/* Create */
		*write_method = write_sccpProviderEntityNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpProviderEntityNamesLen;
		rval = (u_char *) StorageTmp->sccpProviderEntityNames;
		break;
	case (u_char) SCCPAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->sccpAvailabilityStatus;
		break;
	case (u_char) SCCPCONCERNEDAREAPOINTER:	/* Create */
		*write_method = write_sccpConcernedAreaPointer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpConcernedAreaPointer);
		rval = (u_char *) &StorageTmp->sccpConcernedAreaPointer;
		break;
	case (u_char) SCCPLINKAGEPOINTER:	/* Create */
		*write_method = write_sccpLinkagePointer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpLinkagePointer);
		rval = (u_char *) &StorageTmp->sccpLinkagePointer;
		break;
	case (u_char) SCCPSSAVAILABLEAFTERSPRESTART:	/* Create */
		*write_method = write_sccpSsAvailableAfterSpRestart;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSsAvailableAfterSpRestart);
		rval = (u_char *) &StorageTmp->sccpSsAvailableAfterSpRestart;
		break;
	case (u_char) SCCPACCESSPOINTNAME:	/* Create */
		*write_method = write_sccpAccessPointName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpAccessPointNameLen;
		rval = (u_char *) StorageTmp->sccpAccessPointName;
		break;
	case (u_char) SCCPACCESSPOINTROWSTATUS:	/* Create */
		*write_method = write_sccpAccessPointRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAccessPointRowStatus);
		rval = (u_char *) &StorageTmp->sccpAccessPointRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpLinkageTable_row(struct sccpLinkageTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpLinkageTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpLinkageTable_row(struct sccpLinkageTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpLinkageTable_request == sa_request))
		return;
	StorageTmp->sccpLinkageTable_request = sa_request;
}

/**
 * @fn void refresh_sccpLinkageTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpLinkageTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpLinkageTable(int force)
{
	if (!force && sccpLinkageTable_refresh == 0)
		return;
	sccpLinkageTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpLinkageTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpLinkageTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpLinkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpLinkageTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpLinkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpLinkageTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpLinkageTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpLinkageTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPOPERATIONALPROTOCOLS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpOperationalProtocolsLen;
		rval = (u_char *) StorageTmp->sccpOperationalProtocols;
		break;
	case (u_char) SCCPSNSAP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSnSAPLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sccpSnSAP;
		break;
	case (u_char) SCCPATTACKTIMERVALUE:	/* Create */
		*write_method = write_sccpAttackTimerValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAttackTimerValue);
		rval = (u_char *) &StorageTmp->sccpAttackTimerValue;
		break;
	case (u_char) SCCPDECAYTIMERVALUE:	/* Create */
		*write_method = write_sccpDecayTimerValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpDecayTimerValue);
		rval = (u_char *) &StorageTmp->sccpDecayTimerValue;
		break;
	case (u_char) SCCPNROFRESTRICTIONLEVELS:	/* Create */
		*write_method = write_sccpNrOfRestrictionLevels;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpNrOfRestrictionLevels);
		rval = (u_char *) &StorageTmp->sccpNrOfRestrictionLevels;
		break;
	case (u_char) SCCPNROFSUBLEVELS:	/* Create */
		*write_method = write_sccpNrOfSubLevels;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpNrOfSubLevels);
		rval = (u_char *) &StorageTmp->sccpNrOfSubLevels;
		break;
	case (u_char) SCCPCLS:	/* Create */
		*write_method = write_sccpCLS;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpCLS);
		rval = (u_char *) &StorageTmp->sccpCLS;
		break;
	case (u_char) SCCPCONGESTIONTIMERVALUE:	/* Create */
		*write_method = write_sccpCongestionTimerValue;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpCongestionTimerValue);
		rval = (u_char *) &StorageTmp->sccpCongestionTimerValue;
		break;
	case (u_char) SCCPP:	/* Create */
		*write_method = write_sccpp;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpp);
		rval = (u_char *) &StorageTmp->sccpp;
		break;
	case (u_char) SCCPIMPORTANCELEVELCR:	/* Create */
		*write_method = write_sccpImportanceLevelCR;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelCRLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelCR;
		break;
	case (u_char) SCCPIMPORTANCELEVELCC:	/* Create */
		*write_method = write_sccpImportanceLevelCC;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelCCLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelCC;
		break;
	case (u_char) SCCPIMPORTANCELEVELCREF:	/* Create */
		*write_method = write_sccpImportanceLevelCREF;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelCREFLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelCREF;
		break;
	case (u_char) SCCPIMPORTANCELEVELDT1:	/* Create */
		*write_method = write_sccpImportanceLevelDT1;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelDT1Len;
		rval = (u_char *) StorageTmp->sccpImportanceLevelDT1;
		break;
	case (u_char) SCCPIMPORTANCELEVELDT2:	/* Create */
		*write_method = write_sccpImportanceLevelDT2;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelDT2Len;
		rval = (u_char *) StorageTmp->sccpImportanceLevelDT2;
		break;
	case (u_char) SCCPIMPORTANCELEVELAK:	/* Create */
		*write_method = write_sccpImportanceLevelAK;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelAKLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelAK;
		break;
	case (u_char) SCCPIMPORTANCELEVELIT:	/* Create */
		*write_method = write_sccpImportanceLevelIT;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelITLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelIT;
		break;
	case (u_char) SCCPIMPORTANCELEVELED:	/* Create */
		*write_method = write_sccpImportanceLevelED;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelEDLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelED;
		break;
	case (u_char) SCCPIMPORTANCELEVELEA:	/* Create */
		*write_method = write_sccpImportanceLevelEA;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelEALen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelEA;
		break;
	case (u_char) SCCPIMPORTANCELEVELRSR:	/* Create */
		*write_method = write_sccpImportanceLevelRSR;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelRSRLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelRSR;
		break;
	case (u_char) SCCPIMPORTANCELEVELRSC:	/* Create */
		*write_method = write_sccpImportanceLevelRSC;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelRSCLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelRSC;
		break;
	case (u_char) SCCPIMPORTANCELEVELERR:	/* Create */
		*write_method = write_sccpImportanceLevelERR;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelERRLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelERR;
		break;
	case (u_char) SCCPIMPORTANCELEVELRLC:	/* Create */
		*write_method = write_sccpImportanceLevelRLC;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelRLCLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelRLC;
		break;
	case (u_char) SCCPIMPORTANCELEVELRLSD:	/* Create */
		*write_method = write_sccpImportanceLevelRLSD;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelRLSDLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelRLSD;
		break;
	case (u_char) SCCPIMPORTANCELEVELUDT:	/* Create */
		*write_method = write_sccpImportanceLevelUDT;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelUDTLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelUDT;
		break;
	case (u_char) SCCPIMPORTANCELEVELUDTS:	/* Create */
		*write_method = write_sccpImportanceLevelUDTS;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelUDTSLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelUDTS;
		break;
	case (u_char) SCCPIMPORTANCELEVELXUDT:	/* Create */
		*write_method = write_sccpImportanceLevelXUDT;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelXUDTLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelXUDT;
		break;
	case (u_char) SCCPIMPORTANCELEVELXUDTS:	/* Create */
		*write_method = write_sccpImportanceLevelXUDTS;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelXUDTSLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelXUDTS;
		break;
	case (u_char) SCCPIMPORTANCELEVELLUDT:	/* Create */
		*write_method = write_sccpImportanceLevelLUDT;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelLUDTLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelLUDT;
		break;
	case (u_char) SCCPIMPORTANCELEVELLUDTS:	/* Create */
		*write_method = write_sccpImportanceLevelLUDTS;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpImportanceLevelLUDTSLen;
		rval = (u_char *) StorageTmp->sccpImportanceLevelLUDTS;
		break;
	case (u_char) SCCPRLM:	/* Create */
		*write_method = write_sccpRLM;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpRLM);
		rval = (u_char *) &StorageTmp->sccpRLM;
		break;
	case (u_char) SCCPRSLM:	/* Create */
		*write_method = write_sccpRSLM;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpRSLM);
		rval = (u_char *) &StorageTmp->sccpRSLM;
		break;
	case (u_char) SCCPLINKAGECONCERNEDAREAPOINTER:	/* Create */
		*write_method = write_sccpLinkageConcernedAreaPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		rval = (u_char *) StorageTmp->sccpLinkageConcernedAreaPointer;
		break;
	case (u_char) SCCPLOWERLIMITFORSEGMENTATION:	/* Create */
		*write_method = write_sccpLowerLimitForSegmentation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpLowerLimitForSegmentation);
		rval = (u_char *) &StorageTmp->sccpLowerLimitForSegmentation;
		break;
	case (u_char) SCCPUPPERLIMITFORSEGMENTATION:	/* Create */
		*write_method = write_sccpUpperLimitForSegmentation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpUpperLimitForSegmentation);
		rval = (u_char *) &StorageTmp->sccpUpperLimitForSegmentation;
		break;
	case (u_char) SCCPLINKAGENAME:	/* Create */
		*write_method = write_sccpLinkageName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpLinkageNameLen;
		rval = (u_char *) StorageTmp->sccpLinkageName;
		break;
	case (u_char) SCCPLINKAGEROWSTATUS:	/* Create */
		*write_method = write_sccpLinkageRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpLinkageRowStatus);
		rval = (u_char *) &StorageTmp->sccpLinkageRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpSclcTable_row(struct sccpSclcTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpSclcTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpSclcTable_row(struct sccpSclcTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpSclcTable_request == sa_request))
		return;
	StorageTmp->sccpSclcTable_request = sa_request;
}

/**
 * @fn void refresh_sccpSclcTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpSclcTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpSclcTable(int force)
{
	if (!force && sccpSclcTable_refresh == 0)
		return;
	sccpSclcTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpSclcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpSclcTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpSclcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSclcTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpSclcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpSclcTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpSclcTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpSclcTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPSCLCALARMSTATUS:	/* Create */
		*write_method = write_sccpSclcAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSclcAlarmStatusLen;
		rval = (u_char *) StorageTmp->sccpSclcAlarmStatus;
		break;
	case (u_char) SCCPSCLCOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSclcOperationalState);
		rval = (u_char *) &StorageTmp->sccpSclcOperationalState;
		break;
	case (u_char) SCCPTOTALREMOTESAPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpTotalRemoteSAPs);
		rval = (u_char *) &StorageTmp->sccpTotalRemoteSAPs;
		break;
	case (u_char) SCCPSCLCADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sccpSclcAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSclcAdministrativeState);
		rval = (u_char *) &StorageTmp->sccpSclcAdministrativeState;
		break;
	case (u_char) SCCPSCLCSUPPORTEDPROTOCOLS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSclcSupportedProtocolsLen;
		rval = (u_char *) StorageTmp->sccpSclcSupportedProtocols;
		break;
	case (u_char) SCCPSCLCOPERATIONALSYSTEMTYPE:	/* Create */
		*write_method = write_sccpSclcOperationalSystemType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSclcOperationalSystemType);
		rval = (u_char *) &StorageTmp->sccpSclcOperationalSystemType;
		break;
	case (u_char) SCCPINITIALVALUEREASSTIMER:	/* Create */
		*write_method = write_sccpInitialValueReassTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpInitialValueReassTimer);
		rval = (u_char *) &StorageTmp->sccpInitialValueReassTimer;
		break;
	case (u_char) SCCPSCLCNAME:	/* Create */
		*write_method = write_sccpSclcName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSclcNameLen;
		rval = (u_char *) StorageTmp->sccpSclcName;
		break;
	case (u_char) SCCPSCLCROWSTATUS:	/* Create */
		*write_method = write_sccpSclcRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSclcRowStatus);
		rval = (u_char *) &StorageTmp->sccpSclcRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpScocTable_row(struct sccpScocTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpScocTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpScocTable_row(struct sccpScocTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpScocTable_request == sa_request))
		return;
	StorageTmp->sccpScocTable_request = sa_request;
}

/**
 * @fn void refresh_sccpScocTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpScocTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpScocTable(int force)
{
	if (!force && sccpScocTable_refresh == 0)
		return;
	sccpScocTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpScocTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpScocTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpScocTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpScocTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpScocTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpScocTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpScocTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpScocTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPCOPROTOCOLMACHINEID:	/* Create */
		*write_method = write_sccpCoProtocolMachineId;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpCoProtocolMachineIdLen;
		rval = (u_char *) StorageTmp->sccpCoProtocolMachineId;
		break;
	case (u_char) SCCPSCOCOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpScocOperationalState);
		rval = (u_char *) &StorageTmp->sccpScocOperationalState;
		break;
	case (u_char) SCCPSCOCADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sccpScocAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpScocAdministrativeState);
		rval = (u_char *) &StorageTmp->sccpScocAdministrativeState;
		break;
	case (u_char) SCCPSCOCOPERATIONALSYSTEMTYPE:	/* Create */
		*write_method = write_sccpScocOperationalSystemType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpScocOperationalSystemType);
		rval = (u_char *) &StorageTmp->sccpScocOperationalSystemType;
		break;
	case (u_char) SCCPSCOCSUPPORTEDPROTOCOLS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpScocSupportedProtocolsLen;
		rval = (u_char *) StorageTmp->sccpScocSupportedProtocols;
		break;
	case (u_char) SCCPSCOCNAME:	/* Create */
		*write_method = write_sccpScocName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpScocNameLen;
		rval = (u_char *) StorageTmp->sccpScocName;
		break;
	case (u_char) SCCPSCOCROWSTATUS:	/* Create */
		*write_method = write_sccpScocRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpScocRowStatus);
		rval = (u_char *) &StorageTmp->sccpScocRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpScrcTable_row(struct sccpScrcTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpScrcTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpScrcTable_row(struct sccpScrcTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpScrcTable_request == sa_request))
		return;
	StorageTmp->sccpScrcTable_request = sa_request;
}

/**
 * @fn void refresh_sccpScrcTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpScrcTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpScrcTable(int force)
{
	if (!force && sccpScrcTable_refresh == 0)
		return;
	sccpScrcTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpScrcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpScrcTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpScrcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpScrcTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpScrcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpScrcTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpScrcTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpScrcTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPSCRCID:	/* Create */
		*write_method = write_sccpScrcId;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpScrcIdLen;
		rval = (u_char *) StorageTmp->sccpScrcId;
		break;
	case (u_char) SCCPSCRCALARMSTATUS:	/* Create */
		*write_method = write_sccpScrcAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpScrcAlarmStatusLen;
		rval = (u_char *) StorageTmp->sccpScrcAlarmStatus;
		break;
	case (u_char) SCCPSCRCNAME:	/* Create */
		*write_method = write_sccpScrcName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpScrcNameLen;
		rval = (u_char *) StorageTmp->sccpScrcName;
		break;
	case (u_char) SCCPSCRCROWSTATUS:	/* Create */
		*write_method = write_sccpScrcRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpScrcRowStatus);
		rval = (u_char *) &StorageTmp->sccpScrcRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpEntitySetTable_row(struct sccpEntitySetTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpEntitySetTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpEntitySetTable_row(struct sccpEntitySetTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpEntitySetTable_request == sa_request))
		return;
	StorageTmp->sccpEntitySetTable_request = sa_request;
}

/**
 * @fn void refresh_sccpEntitySetTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpEntitySetTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpEntitySetTable(int force)
{
	if (!force && sccpEntitySetTable_refresh == 0)
		return;
	sccpEntitySetTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpEntitySetTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpEntitySetTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpEntitySetTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpEntitySetTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpEntitySetTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpEntitySetTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpEntitySetTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPSHARINGMODE:	/* Create */
		*write_method = write_sccpSharingMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpSharingMode);
		rval = (u_char *) &StorageTmp->sccpSharingMode;
		break;
	case (u_char) SCCPLOADSHARINGALGPOINTER:	/* Create */
		*write_method = write_sccpLoadSharingAlgPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpLoadSharingAlgPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sccpLoadSharingAlgPointer;
		break;
	case (u_char) SCCPENTITYSETNAME:	/* Create */
		*write_method = write_sccpEntitySetName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpEntitySetNameLen;
		rval = (u_char *) StorageTmp->sccpEntitySetName;
		break;
	case (u_char) SCCPENTITYSETTYPE:	/* Create */
		*write_method = write_sccpEntitySetType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpEntitySetType);
		rval = (u_char *) &StorageTmp->sccpEntitySetType;
		break;
	case (u_char) SCCPENTITYSETSSN:	/* Create */
		*write_method = write_sccpEntitySetSsn;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpEntitySetSsnLen;
		rval = (u_char *) StorageTmp->sccpEntitySetSsn;
		break;
	case (u_char) SCCPENTITYSETROWSTATUS:	/* Create */
		*write_method = write_sccpEntitySetRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpEntitySetRowStatus);
		rval = (u_char *) &StorageTmp->sccpEntitySetRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpEntitySetSapTable_row(struct sccpEntitySetSapTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpEntitySetSapTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpEntitySetSapTable_row(struct sccpEntitySetSapTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpEntitySetSapTable_request == sa_request))
		return;
	StorageTmp->sccpEntitySetSapTable_request = sa_request;
}

/**
 * @fn void refresh_sccpEntitySetSapTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpEntitySetSapTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpEntitySetSapTable(int force)
{
	if (!force && sccpEntitySetSapTable_refresh == 0)
		return;
	sccpEntitySetSapTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpEntitySetSapTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpEntitySetSapTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpEntitySetSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpEntitySetSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpEntitySetSapTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpEntitySetSapTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpEntitySetSapTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPENTITYSETSAPTYPE:	/* Create */
		*write_method = write_sccpEntitySetSapType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpEntitySetSapType);
		rval = (u_char *) &StorageTmp->sccpEntitySetSapType;
		break;
	case (u_char) SCCPENTITYSETSAPPOINTER:	/* Create */
		*write_method = write_sccpEntitySetSapPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpEntitySetSapPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sccpEntitySetSapPointer;
		break;
	case (u_char) SCCPENTITYSETSAPROWSTATUS:	/* Create */
		*write_method = write_sccpEntitySetSapRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpEntitySetSapRowStatus);
		rval = (u_char *) &StorageTmp->sccpEntitySetSapRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpConcernedAreaTable_row(struct sccpConcernedAreaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpConcernedAreaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpConcernedAreaTable_row(struct sccpConcernedAreaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpConcernedAreaTable_request == sa_request))
		return;
	StorageTmp->sccpConcernedAreaTable_request = sa_request;
}

/**
 * @fn void refresh_sccpConcernedAreaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpConcernedAreaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpConcernedAreaTable(int force)
{
	if (!force && sccpConcernedAreaTable_refresh == 0)
		return;
	sccpConcernedAreaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpConcernedAreaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpConcernedAreaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpConcernedAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpConcernedAreaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpConcernedAreaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpConcernedAreaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpConcernedAreaTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpConcernedAreaTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpRemoteSCCPTable_row(struct sccpRemoteSCCPTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpRemoteSCCPTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpRemoteSCCPTable_row(struct sccpRemoteSCCPTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpRemoteSCCPTable_request == sa_request))
		return;
	StorageTmp->sccpRemoteSCCPTable_request = sa_request;
}

/**
 * @fn void refresh_sccpRemoteSCCPTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpRemoteSCCPTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpRemoteSCCPTable(int force)
{
	if (!force && sccpRemoteSCCPTable_refresh == 0)
		return;
	sccpRemoteSCCPTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpRemoteSCCPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpRemoteSCCPTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpRemoteSCCPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpRemoteSCCPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpRemoteSCCPTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpRemoteSCCPTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpRemoteSCCPTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPREMOTESCCPMTPACCESSPOINT:	/* Create */
		*write_method = write_sccpRemoteSCCPMTPAccessPoint;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpRemoteSCCPMTPAccessPointLen * sizeof(oid);
		rval = (u_char *) StorageTmp->sccpRemoteSCCPMTPAccessPoint;
		break;
	case (u_char) SCCPREMOTESCCPNAME:	/* Create */
		*write_method = write_sccpRemoteSCCPName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpRemoteSCCPNameLen;
		rval = (u_char *) StorageTmp->sccpRemoteSCCPName;
		break;
	case (u_char) SCCPREMOTESCCPROWSTATUS:	/* Create */
		*write_method = write_sccpRemoteSCCPRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpRemoteSCCPRowStatus);
		rval = (u_char *) &StorageTmp->sccpRemoteSCCPRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpGtConversionRuleTable_row(struct sccpGtConversionRuleTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpGtConversionRuleTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpGtConversionRuleTable_row(struct sccpGtConversionRuleTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpGtConversionRuleTable_request == sa_request))
		return;
	StorageTmp->sccpGtConversionRuleTable_request = sa_request;
}

/**
 * @fn void refresh_sccpGtConversionRuleTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpGtConversionRuleTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpGtConversionRuleTable(int force)
{
	if (!force && sccpGtConversionRuleTable_refresh == 0)
		return;
	sccpGtConversionRuleTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpGtConversionRuleTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpGtConversionRuleTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpGtConversionRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtConversionRuleTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpGtConversionRuleTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpGtConversionRuleTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPGTNEWENCODINGSCHEME:	/* Create */
		*write_method = write_sccpGtNewEncodingScheme;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtNewEncodingScheme);
		rval = (u_char *) &StorageTmp->sccpGtNewEncodingScheme;
		break;
	case (u_char) SCCPGTNEWNATUREOFADDRESS:	/* Create */
		*write_method = write_sccpGtNewNatureOfAddress;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtNewNatureOfAddress);
		rval = (u_char *) &StorageTmp->sccpGtNewNatureOfAddress;
		break;
	case (u_char) SCCPGTNEWNUMBERINGPLAN:	/* Create */
		*write_method = write_sccpGtNewNumberingPlan;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtNewNumberingPlan);
		rval = (u_char *) &StorageTmp->sccpGtNewNumberingPlan;
		break;
	case (u_char) SCCPGTNEWTRANSLATIONTYPE:	/* Create */
		*write_method = write_sccpGtNewTranslationType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtNewTranslationType);
		rval = (u_char *) &StorageTmp->sccpGtNewTranslationType;
		break;
	case (u_char) SCCPGTCONVERSIONRULENAME:	/* Create */
		*write_method = write_sccpGtConversionRuleName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpGtConversionRuleNameLen;
		rval = (u_char *) StorageTmp->sccpGtConversionRuleName;
		break;
	case (u_char) SCCPGTCONVERSIONRULEROWSTATUS:	/* Create */
		*write_method = write_sccpGtConversionRuleRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtConversionRuleRowStatus);
		rval = (u_char *) &StorageTmp->sccpGtConversionRuleRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpAddressInfoTable_row(struct sccpAddressInfoTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpAddressInfoTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpAddressInfoTable_row(struct sccpAddressInfoTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpAddressInfoTable_request == sa_request))
		return;
	StorageTmp->sccpAddressInfoTable_request = sa_request;
}

/**
 * @fn void refresh_sccpAddressInfoTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpAddressInfoTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpAddressInfoTable(int force)
{
	if (!force && sccpAddressInfoTable_refresh == 0)
		return;
	sccpAddressInfoTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpAddressInfoTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpAddressInfoTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpAddressInfoTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpAddressInfoTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpAddressInfoTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpAddressInfoTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpAddressInfoTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPADDRESSINFOOPERATION:	/* Create */
		*write_method = write_sccpAddressInfoOperation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAddressInfoOperation);
		rval = (u_char *) &StorageTmp->sccpAddressInfoOperation;
		break;
	case (u_char) SCCPADDRESSINFOADDRESSELEMENT:	/* Create */
		*write_method = write_sccpAddressInfoAddressElement;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAddressInfoAddressElement);
		rval = (u_char *) &StorageTmp->sccpAddressInfoAddressElement;
		break;
	case (u_char) SCCPADDRESSINFONROFADDRESSELEMENTS:	/* Create */
		*write_method = write_sccpAddressInfoNrOfAddressElements;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAddressInfoNrOfAddressElements);
		rval = (u_char *) &StorageTmp->sccpAddressInfoNrOfAddressElements;
		break;
	case (u_char) SCCPADDRESSINFOROWSTATUS:	/* Create */
		*write_method = write_sccpAddressInfoRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAddressInfoRowStatus);
		rval = (u_char *) &StorageTmp->sccpAddressInfoRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpGtTranslatorTable_row(struct sccpGtTranslatorTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpGtTranslatorTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpGtTranslatorTable_row(struct sccpGtTranslatorTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpGtTranslatorTable_request == sa_request))
		return;
	StorageTmp->sccpGtTranslatorTable_request = sa_request;
}

/**
 * @fn void refresh_sccpGtTranslatorTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpGtTranslatorTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpGtTranslatorTable(int force)
{
	if (!force && sccpGtTranslatorTable_refresh == 0)
		return;
	sccpGtTranslatorTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpGtTranslatorTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpGtTranslatorTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpGtTranslatorTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtTranslatorTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpGtTranslatorTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpGtTranslatorTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPGTINDICATOR:	/* Create */
		*write_method = write_sccpGtIndicator;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtIndicator);
		rval = (u_char *) &StorageTmp->sccpGtIndicator;
		break;
	case (u_char) SCCPGTNATUREOFADDRESS:	/* Create */
		*write_method = write_sccpGtNatureOfAddress;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtNatureOfAddress);
		rval = (u_char *) &StorageTmp->sccpGtNatureOfAddress;
		break;
	case (u_char) SCCPGTNUMBERINGPLAN:	/* Create */
		*write_method = write_sccpGtNumberingPlan;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtNumberingPlan);
		rval = (u_char *) &StorageTmp->sccpGtNumberingPlan;
		break;
	case (u_char) SCCPGTTRANSLATIONTYPE:	/* Create */
		*write_method = write_sccpGtTranslationType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtTranslationType);
		rval = (u_char *) &StorageTmp->sccpGtTranslationType;
		break;
	case (u_char) SCCPGTTRANSLATORADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sccpGtTranslatorAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtTranslatorAdministrativeState);
		rval = (u_char *) &StorageTmp->sccpGtTranslatorAdministrativeState;
		break;
	case (u_char) SCCPGTTRANSLATORNAME:	/* Create */
		*write_method = write_sccpGtTranslatorName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpGtTranslatorNameLen;
		rval = (u_char *) StorageTmp->sccpGtTranslatorName;
		break;
	case (u_char) SCCPGTTRANSLATORROWSTATUS:	/* Create */
		*write_method = write_sccpGtTranslatorRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtTranslatorRowStatus);
		rval = (u_char *) &StorageTmp->sccpGtTranslatorRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpGtRuleTable_row(struct sccpGtRuleTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpGtRuleTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpGtRuleTable_row(struct sccpGtRuleTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpGtRuleTable_request == sa_request))
		return;
	StorageTmp->sccpGtRuleTable_request = sa_request;
}

/**
 * @fn void refresh_sccpGtRuleTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpGtRuleTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpGtRuleTable(int force)
{
	if (!force && sccpGtRuleTable_refresh == 0)
		return;
	sccpGtRuleTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpGtRuleTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpGtRuleTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpGtRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtRuleTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpGtRuleTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpGtRuleTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpGtRuleTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPGTRULEADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sccpGtRuleAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtRuleAdministrativeState);
		rval = (u_char *) &StorageTmp->sccpGtRuleAdministrativeState;
		break;
	case (u_char) SCCPGTADDRESSINFORMATION:	/* Create */
		*write_method = write_sccpGtAddressInformation;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpGtAddressInformationLen;
		rval = (u_char *) StorageTmp->sccpGtAddressInformation;
		break;
	case (u_char) SCCPGTCONVRULEPOINTER:	/* Create */
		*write_method = write_sccpGtConvRulePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpGtConvRulePointerLen;
		rval = (u_char *) StorageTmp->sccpGtConvRulePointer;
		break;
	case (u_char) SCCPGTENCODINGSCHEME:	/* Create */
		*write_method = write_sccpGtEncodingScheme;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtEncodingScheme);
		rval = (u_char *) &StorageTmp->sccpGtEncodingScheme;
		break;
	case (u_char) SCCPENTITYSETPOINTER:	/* Create */
		*write_method = write_sccpEntitySetPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpEntitySetPointerLen;
		rval = (u_char *) StorageTmp->sccpEntitySetPointer;
		break;
	case (u_char) SCCPGTRULENAME:	/* Create */
		*write_method = write_sccpGtRuleName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpGtRuleNameLen;
		rval = (u_char *) StorageTmp->sccpGtRuleName;
		break;
	case (u_char) SCCPGTRULEROWSTATUS:	/* Create */
		*write_method = write_sccpGtRuleRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpGtRuleRowStatus);
		rval = (u_char *) &StorageTmp->sccpGtRuleRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_sccpSrvtTable_row(struct sccpSrvtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the sccpSrvtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpSrvtTable_row(struct sccpSrvtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->sccpSrvtTable_request == sa_request))
		return;
	StorageTmp->sccpSrvtTable_request = sa_request;
}

/**
 * @fn void refresh_sccpSrvtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the sccpSrvtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpSrvtTable(int force)
{
	if (!force && sccpSrvtTable_refresh == 0)
		return;
	sccpSrvtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn u_char *var_sccpSrvtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpSrvtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpSrvtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSrvtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("sccpMIB", "var_sccpSrvtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpSrvtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	StorageTmp = header_complex(sccpSrvtTableStorage, vp, name, length, exact, var_len, write_method);
	refresh_sccpSrvtTable_row(StorageTmp, 0);
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) SCCPDSRVT:	/* Create */
		*write_method = write_sccpDSRVT;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpDSRVT);
		rval = (u_char *) &StorageTmp->sccpDSRVT;
		break;
	case (u_char) SCCPNSRVT:	/* Create */
		*write_method = write_sccpNSRVT;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpNSRVT);
		rval = (u_char *) &StorageTmp->sccpNSRVT;
		break;
	case (u_char) SCCPSRVTNAME:	/* Create */
		*write_method = write_sccpSrvtName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpSrvtNameLen;
		rval = (u_char *) StorageTmp->sccpSrvtName;
		break;
	case (u_char) SCCPADMINISTRATIVESTATE:	/* Create */
		*write_method = write_sccpAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpAdministrativeState);
		rval = (u_char *) &StorageTmp->sccpAdministrativeState;
		break;
	case (u_char) SCCPOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpOperationalState);
		rval = (u_char *) &StorageTmp->sccpOperationalState;
		break;
	case (u_char) SCCPPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpProceduralStatusLen;
		rval = (u_char *) StorageTmp->sccpProceduralStatus;
		break;
	case (u_char) SCCPTRACEREQUESTED:	/* Create */
		*write_method = write_sccpTraceRequested;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpTraceRequested);
		rval = (u_char *) &StorageTmp->sccpTraceRequested;
		break;
	case (u_char) SCCPTHRESHOLD:	/* Create */
		*write_method = write_sccpThreshold;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpThreshold);
		rval = (u_char *) &StorageTmp->sccpThreshold;
		break;
	case (u_char) SCCPMTPBACKWARDROUTINGREQUESTED:	/* Create */
		*write_method = write_sccpMtpBackwardRoutingRequested;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpMtpBackwardRoutingRequested);
		rval = (u_char *) &StorageTmp->sccpMtpBackwardRoutingRequested;
		break;
	case (u_char) SCCPORIGINALGT:	/* Create */
		*write_method = write_sccpOriginalGT;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpOriginalGTLen;
		rval = (u_char *) StorageTmp->sccpOriginalGT;
		break;
	case (u_char) SCCPINFOREQUEST:	/* Create */
		*write_method = write_sccpInfoRequest;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpInfoRequestLen;
		rval = (u_char *) StorageTmp->sccpInfoRequest;
		break;
	case (u_char) SCCPRETURNUNKNOWNPARAMS:	/* Create */
		*write_method = write_sccpReturnUnknownParams;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->sccpReturnUnknownParamsLen;
		rval = (u_char *) StorageTmp->sccpReturnUnknownParams;
		break;
	case (u_char) SCCPROUTETESTROWSTATUS:	/* Create */
		*write_method = write_sccpRouteTestRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->sccpRouteTestRowStatus);
		rval = (u_char *) &StorageTmp->sccpRouteTestRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_sccpNetworkEntityAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNetworkEntityAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpNetworkEntityAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpNetworkEntityAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpNetworkEntityAlarmStatus;
		old_length = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		StorageTmp->sccpNetworkEntityAlarmStatus = string;
		StorageTmp->sccpNetworkEntityAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNetworkEntityAlarmStatus = old_value;
		StorageTmp->sccpNetworkEntityAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpVersion entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 14..15 */
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid) || ((14 * sizeof(oid) > var_val_len || var_val_len > 15 * sizeof(oid)))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpVersion for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpVersion;
		old_length = StorageTmp->sccpVersionLen;
		StorageTmp->sccpVersion = objid;
		StorageTmp->sccpVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpVersion = old_value;
		StorageTmp->sccpVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLUDTandLUDTSSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLUDTandLUDTSSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpLUDTandLUDTSSupported entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpLUDTandLUDTSSupported for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpLUDTandLUDTSSupported;
		StorageTmp->sccpLUDTandLUDTSSupported = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLUDTandLUDTSSupported = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCoordChangeTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCoordChangeTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpCoordChangeTimer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpCoordChangeTimer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpCoordChangeTimer;
		StorageTmp->sccpCoordChangeTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCoordChangeTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpIgnoreSSTTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpIgnoreSSTTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpIgnoreSSTTimer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpIgnoreSSTTimer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpIgnoreSSTTimer;
		StorageTmp->sccpIgnoreSSTTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpIgnoreSSTTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpMaxStatInfoTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpMaxStatInfoTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpMaxStatInfoTimer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpMaxStatInfoTimer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpMaxStatInfoTimer;
		StorageTmp->sccpMaxStatInfoTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpMaxStatInfoTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNetworkEntityName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNetworkEntityName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpNetworkEntityName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpNetworkEntityName for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpNetworkEntityName;
		old_length = StorageTmp->sccpNetworkEntityNameLen;
		StorageTmp->sccpNetworkEntityName = string;
		StorageTmp->sccpNetworkEntityNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNetworkEntityName = old_value;
		StorageTmp->sccpNetworkEntityNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAccessPointAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAccessPointAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpAccessPointAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAccessPointAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAccessPointAlarmStatus;
		old_length = StorageTmp->sccpAccessPointAlarmStatusLen;
		StorageTmp->sccpAccessPointAlarmStatus = string;
		StorageTmp->sccpAccessPointAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAccessPointAlarmStatus = old_value;
		StorageTmp->sccpAccessPointAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSap2Address(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSap2Address(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSap2Address entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..1 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 1))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSap2Address for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpSap2Address;
		old_length = StorageTmp->sccpSap2AddressLen;
		StorageTmp->sccpSap2Address = string;
		StorageTmp->sccpSap2AddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSap2Address = old_value;
		StorageTmp->sccpSap2AddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpUserEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpUserEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpUserEntityNames entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpUserEntityNames for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpUserEntityNames;
		old_length = StorageTmp->sccpUserEntityNamesLen;
		StorageTmp->sccpUserEntityNames = string;
		StorageTmp->sccpUserEntityNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpUserEntityNames = old_value;
		StorageTmp->sccpUserEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpProviderEntityNames entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpProviderEntityNames for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpProviderEntityNames;
		old_length = StorageTmp->sccpProviderEntityNamesLen;
		StorageTmp->sccpProviderEntityNames = string;
		StorageTmp->sccpProviderEntityNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpProviderEntityNames = old_value;
		StorageTmp->sccpProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpConcernedAreaPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpConcernedAreaPointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpConcernedAreaPointer;
		StorageTmp->sccpConcernedAreaPointer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpConcernedAreaPointer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkagePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLinkagePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpLinkagePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpLinkagePointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpLinkagePointer;
		StorageTmp->sccpLinkagePointer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkagePointer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSsAvailableAfterSpRestart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSsAvailableAfterSpRestart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSsAvailableAfterSpRestart entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSsAvailableAfterSpRestart for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpSsAvailableAfterSpRestart;
		StorageTmp->sccpSsAvailableAfterSpRestart = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSsAvailableAfterSpRestart = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAccessPointName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAccessPointName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpAccessPointName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAccessPointName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAccessPointName;
		old_length = StorageTmp->sccpAccessPointNameLen;
		StorageTmp->sccpAccessPointName = string;
		StorageTmp->sccpAccessPointNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAccessPointName = old_value;
		StorageTmp->sccpAccessPointNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAttackTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAttackTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAttackTimerValue entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAttackTimerValue for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAttackTimerValue;
		StorageTmp->sccpAttackTimerValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAttackTimerValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpDecayTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpDecayTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpDecayTimerValue entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpDecayTimerValue for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpDecayTimerValue;
		StorageTmp->sccpDecayTimerValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpDecayTimerValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNrOfRestrictionLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNrOfRestrictionLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpNrOfRestrictionLevels entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpNrOfRestrictionLevels for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpNrOfRestrictionLevels;
		StorageTmp->sccpNrOfRestrictionLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNrOfRestrictionLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNrOfSubLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNrOfSubLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpNrOfSubLevels entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpNrOfSubLevels for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpNrOfSubLevels;
		StorageTmp->sccpNrOfSubLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNrOfSubLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCLS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCLS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpCLS entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpCLS for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpCLS;
		StorageTmp->sccpCLS = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCLS = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCongestionTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCongestionTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpCongestionTimerValue entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpCongestionTimerValue for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpCongestionTimerValue;
		StorageTmp->sccpCongestionTimerValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCongestionTimerValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpp entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpp for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpp;
		StorageTmp->sccpp = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpp = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelCR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelCR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCR entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0204'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelCR for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelCR;
		old_length = StorageTmp->sccpImportanceLevelCRLen;
		StorageTmp->sccpImportanceLevelCR = string;
		StorageTmp->sccpImportanceLevelCRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelCR = old_value;
		StorageTmp->sccpImportanceLevelCRLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelCC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelCC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCC entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0304'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelCC for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelCC;
		old_length = StorageTmp->sccpImportanceLevelCCLen;
		StorageTmp->sccpImportanceLevelCC = string;
		StorageTmp->sccpImportanceLevelCCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelCC = old_value;
		StorageTmp->sccpImportanceLevelCCLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelCREF(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelCREF(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCREF entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0204'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelCREF for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelCREF;
		old_length = StorageTmp->sccpImportanceLevelCREFLen;
		StorageTmp->sccpImportanceLevelCREF = string;
		StorageTmp->sccpImportanceLevelCREFLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelCREF = old_value;
		StorageTmp->sccpImportanceLevelCREFLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelDT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelDT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelDT1 entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1 not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelDT1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelDT1;
		old_length = StorageTmp->sccpImportanceLevelDT1Len;
		StorageTmp->sccpImportanceLevelDT1 = string;
		StorageTmp->sccpImportanceLevelDT1Len = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelDT1 = old_value;
		StorageTmp->sccpImportanceLevelDT1Len = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelDT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelDT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelDT2 entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2 not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelDT2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelDT2;
		old_length = StorageTmp->sccpImportanceLevelDT2Len;
		StorageTmp->sccpImportanceLevelDT2 = string;
		StorageTmp->sccpImportanceLevelDT2Len = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelDT2 = old_value;
		StorageTmp->sccpImportanceLevelDT2Len = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelAK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelAK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelAK entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelAK for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelAK;
		old_length = StorageTmp->sccpImportanceLevelAKLen;
		StorageTmp->sccpImportanceLevelAK = string;
		StorageTmp->sccpImportanceLevelAKLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelAK = old_value;
		StorageTmp->sccpImportanceLevelAKLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelIT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelIT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelIT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelIT for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelIT;
		old_length = StorageTmp->sccpImportanceLevelITLen;
		StorageTmp->sccpImportanceLevelIT = string;
		StorageTmp->sccpImportanceLevelITLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelIT = old_value;
		StorageTmp->sccpImportanceLevelITLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelED(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelED(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelED entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0700'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelED for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelED;
		old_length = StorageTmp->sccpImportanceLevelEDLen;
		StorageTmp->sccpImportanceLevelED = string;
		StorageTmp->sccpImportanceLevelEDLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelED = old_value;
		StorageTmp->sccpImportanceLevelEDLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelEA(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelEA(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelEA entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0700'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelEA for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelEA;
		old_length = StorageTmp->sccpImportanceLevelEALen;
		StorageTmp->sccpImportanceLevelEA = string;
		StorageTmp->sccpImportanceLevelEALen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelEA = old_value;
		StorageTmp->sccpImportanceLevelEALen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRSR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRSR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRSR entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelRSR for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRSR;
		old_length = StorageTmp->sccpImportanceLevelRSRLen;
		StorageTmp->sccpImportanceLevelRSR = string;
		StorageTmp->sccpImportanceLevelRSRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRSR = old_value;
		StorageTmp->sccpImportanceLevelRSRLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRSC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRSC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRSC entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelRSC for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRSC;
		old_length = StorageTmp->sccpImportanceLevelRSCLen;
		StorageTmp->sccpImportanceLevelRSC = string;
		StorageTmp->sccpImportanceLevelRSCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRSC = old_value;
		StorageTmp->sccpImportanceLevelRSCLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelERR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelERR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelERR entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0700'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelERR for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelERR;
		old_length = StorageTmp->sccpImportanceLevelERRLen;
		StorageTmp->sccpImportanceLevelERR = string;
		StorageTmp->sccpImportanceLevelERRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelERR = old_value;
		StorageTmp->sccpImportanceLevelERRLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRLC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRLC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRLC entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0400'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelRLC for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRLC;
		old_length = StorageTmp->sccpImportanceLevelRLCLen;
		StorageTmp->sccpImportanceLevelRLC = string;
		StorageTmp->sccpImportanceLevelRLCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRLC = old_value;
		StorageTmp->sccpImportanceLevelRLCLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRLSD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRLSD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRLSD entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0606'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelRLSD for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRLSD;
		old_length = StorageTmp->sccpImportanceLevelRLSDLen;
		StorageTmp->sccpImportanceLevelRLSD = string;
		StorageTmp->sccpImportanceLevelRLSDLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRLSD = old_value;
		StorageTmp->sccpImportanceLevelRLSDLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelUDT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelUDT for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelUDT;
		old_length = StorageTmp->sccpImportanceLevelUDTLen;
		StorageTmp->sccpImportanceLevelUDT = string;
		StorageTmp->sccpImportanceLevelUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelUDT = old_value;
		StorageTmp->sccpImportanceLevelUDTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelUDTS entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0300'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelUDTS for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelUDTS;
		old_length = StorageTmp->sccpImportanceLevelUDTSLen;
		StorageTmp->sccpImportanceLevelUDTS = string;
		StorageTmp->sccpImportanceLevelUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelUDTS = old_value;
		StorageTmp->sccpImportanceLevelUDTSLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelXUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelXUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelXUDT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelXUDT for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelXUDT;
		old_length = StorageTmp->sccpImportanceLevelXUDTLen;
		StorageTmp->sccpImportanceLevelXUDT = string;
		StorageTmp->sccpImportanceLevelXUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelXUDT = old_value;
		StorageTmp->sccpImportanceLevelXUDTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelXUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelXUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelXUDTS entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0300'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelXUDTS for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelXUDTS;
		old_length = StorageTmp->sccpImportanceLevelXUDTSLen;
		StorageTmp->sccpImportanceLevelXUDTS = string;
		StorageTmp->sccpImportanceLevelXUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelXUDTS = old_value;
		StorageTmp->sccpImportanceLevelXUDTSLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelLUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelLUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelLUDT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelLUDT for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelLUDT;
		old_length = StorageTmp->sccpImportanceLevelLUDTLen;
		StorageTmp->sccpImportanceLevelLUDT = string;
		StorageTmp->sccpImportanceLevelLUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelLUDT = old_value;
		StorageTmp->sccpImportanceLevelLUDTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelLUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelLUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelLUDTS entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0300'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpImportanceLevelLUDTS for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpImportanceLevelLUDTS;
		old_length = StorageTmp->sccpImportanceLevelLUDTSLen;
		StorageTmp->sccpImportanceLevelLUDTS = string;
		StorageTmp->sccpImportanceLevelLUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelLUDTS = old_value;
		StorageTmp->sccpImportanceLevelLUDTSLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpRLM entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpRLM for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpRLM;
		StorageTmp->sccpRLM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRLM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRSLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRSLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpRSLM entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpRSLM for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpRSLM;
		StorageTmp->sccpRSLM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRSLM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkageConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLinkageConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpLinkageConcernedAreaPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpLinkageConcernedAreaPointer for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpLinkageConcernedAreaPointer;
		old_length = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		StorageTmp->sccpLinkageConcernedAreaPointer = string;
		StorageTmp->sccpLinkageConcernedAreaPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkageConcernedAreaPointer = old_value;
		StorageTmp->sccpLinkageConcernedAreaPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLowerLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLowerLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpLowerLimitForSegmentation entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 150..3592 */
		if ((150 > set_value || set_value > 3592)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpLowerLimitForSegmentation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpLowerLimitForSegmentation;
		StorageTmp->sccpLowerLimitForSegmentation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLowerLimitForSegmentation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpUpperLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpUpperLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpUpperLimitForSegmentation entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 150..3592 */
		if ((150 > set_value || set_value > 3592)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpUpperLimitForSegmentation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpUpperLimitForSegmentation;
		StorageTmp->sccpUpperLimitForSegmentation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpUpperLimitForSegmentation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkageName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLinkageName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpLinkageName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpLinkageName for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpLinkageName;
		old_length = StorageTmp->sccpLinkageNameLen;
		StorageTmp->sccpLinkageName = string;
		StorageTmp->sccpLinkageNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkageName = old_value;
		StorageTmp->sccpLinkageNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSclcAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpSclcAlarmStatus;
		old_length = StorageTmp->sccpSclcAlarmStatusLen;
		StorageTmp->sccpSclcAlarmStatus = string;
		StorageTmp->sccpSclcAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcAlarmStatus = old_value;
		StorageTmp->sccpSclcAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCLCADMINISTRATIVESTATE_LOCKED:
		case SCCPSCLCADMINISTRATIVESTATE_UNLOCKED:
		case SCCPSCLCADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSclcAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpSclcAdministrativeState;
		StorageTmp->sccpSclcAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcOperationalSystemType entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCLCOPERATIONALSYSTEMTYPE_ES:
		case SCCPSCLCOPERATIONALSYSTEMTYPE_IS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSclcOperationalSystemType for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpSclcOperationalSystemType;
		StorageTmp->sccpSclcOperationalSystemType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcOperationalSystemType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpInitialValueReassTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpInitialValueReassTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpInitialValueReassTimer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpInitialValueReassTimer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpInitialValueReassTimer;
		StorageTmp->sccpInitialValueReassTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpInitialValueReassTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSclcName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpSclcName;
		old_length = StorageTmp->sccpSclcNameLen;
		StorageTmp->sccpSclcName = string;
		StorageTmp->sccpSclcNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcName = old_value;
		StorageTmp->sccpSclcNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCoProtocolMachineId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCoProtocolMachineId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpCoProtocolMachineId entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpCoProtocolMachineId for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpCoProtocolMachineId;
		old_length = StorageTmp->sccpCoProtocolMachineIdLen;
		StorageTmp->sccpCoProtocolMachineId = string;
		StorageTmp->sccpCoProtocolMachineIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCoProtocolMachineId = old_value;
		StorageTmp->sccpCoProtocolMachineIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScocAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpScocAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCOCADMINISTRATIVESTATE_LOCKED:
		case SCCPSCOCADMINISTRATIVESTATE_UNLOCKED:
		case SCCPSCOCADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpScocAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpScocAdministrativeState;
		StorageTmp->sccpScocAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScocOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpScocOperationalSystemType entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCOCOPERATIONALSYSTEMTYPE_ES:
		case SCCPSCOCOPERATIONALSYSTEMTYPE_IS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpScocOperationalSystemType for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpScocOperationalSystemType;
		StorageTmp->sccpScocOperationalSystemType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocOperationalSystemType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScocName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScocName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpScocName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpScocName;
		old_length = StorageTmp->sccpScocNameLen;
		StorageTmp->sccpScocName = string;
		StorageTmp->sccpScocNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocName = old_value;
		StorageTmp->sccpScocNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScrcId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScrcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScrcId entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScrcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpScrcId for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpScrcId;
		old_length = StorageTmp->sccpScrcIdLen;
		StorageTmp->sccpScrcId = string;
		StorageTmp->sccpScrcIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScrcId = old_value;
		StorageTmp->sccpScrcIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScrcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScrcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScrcAlarmStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScrcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpScrcAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpScrcAlarmStatus;
		old_length = StorageTmp->sccpScrcAlarmStatusLen;
		StorageTmp->sccpScrcAlarmStatus = string;
		StorageTmp->sccpScrcAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScrcAlarmStatus = old_value;
		StorageTmp->sccpScrcAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScrcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScrcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScrcName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScrcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpScrcName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpScrcName;
		old_length = StorageTmp->sccpScrcNameLen;
		StorageTmp->sccpScrcName = string;
		StorageTmp->sccpScrcNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScrcName = old_value;
		StorageTmp->sccpScrcNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSharingMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSharingMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSharingMode entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSHARINGMODE_SOLITARY:
		case SCCPSHARINGMODE_DUPLIDOMINANT:
		case SCCPSHARINGMODE_DUPLIREPLACEMENT:
		case SCCPSHARINGMODE_DUPLILOADSHARED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSharingMode for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpSharingMode;
		StorageTmp->sccpSharingMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSharingMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLoadSharingAlgPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLoadSharingAlgPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpLoadSharingAlgPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpLoadSharingAlgPointer for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpLoadSharingAlgPointer;
		old_length = StorageTmp->sccpLoadSharingAlgPointerLen;
		StorageTmp->sccpLoadSharingAlgPointer = objid;
		StorageTmp->sccpLoadSharingAlgPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLoadSharingAlgPointer = old_value;
		StorageTmp->sccpLoadSharingAlgPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpEntitySetName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpEntitySetName;
		old_length = StorageTmp->sccpEntitySetNameLen;
		StorageTmp->sccpEntitySetName = string;
		StorageTmp->sccpEntitySetNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetName = old_value;
		StorageTmp->sccpEntitySetNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetType entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPENTITYSETTYPE_ENDNODEENTITYSETWITHOUTSSN:
		case SCCPENTITYSETTYPE_ENDNODEENTITYSETWITHSSN:
		case SCCPENTITYSETTYPE_RELAYNODEENTITYSET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpEntitySetType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpEntitySetType;
		StorageTmp->sccpEntitySetType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSsn(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetSsn(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSsn entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..1 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 1))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpEntitySetSsn for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpEntitySetSsn;
		old_length = StorageTmp->sccpEntitySetSsnLen;
		StorageTmp->sccpEntitySetSsn = string;
		StorageTmp->sccpEntitySetSsnLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSsn = old_value;
		StorageTmp->sccpEntitySetSsnLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSapType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetSapType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSapType entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPENTITYSETSAPTYPE_EQUAL:
		case SCCPENTITYSETSAPTYPE_PRIMARY:
		case SCCPENTITYSETSAPTYPE_BACKUP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpEntitySetSapType for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpEntitySetSapType;
		StorageTmp->sccpEntitySetSapType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSapType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSapPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetSapPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSapPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpEntitySetSapPointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpEntitySetSapPointer;
		old_length = StorageTmp->sccpEntitySetSapPointerLen;
		StorageTmp->sccpEntitySetSapPointer = objid;
		StorageTmp->sccpEntitySetSapPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSapPointer = old_value;
		StorageTmp->sccpEntitySetSapPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRemoteSCCPMTPAccessPoint(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRemoteSCCPMTPAccessPoint(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpRemoteSCCPMTPAccessPoint entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRemoteSCCPRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpRemoteSCCPMTPAccessPoint for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpRemoteSCCPMTPAccessPoint;
		old_length = StorageTmp->sccpRemoteSCCPMTPAccessPointLen;
		StorageTmp->sccpRemoteSCCPMTPAccessPoint = objid;
		StorageTmp->sccpRemoteSCCPMTPAccessPointLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRemoteSCCPMTPAccessPoint = old_value;
		StorageTmp->sccpRemoteSCCPMTPAccessPointLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRemoteSCCPName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRemoteSCCPName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpRemoteSCCPName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRemoteSCCPRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpRemoteSCCPName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpRemoteSCCPName;
		old_length = StorageTmp->sccpRemoteSCCPNameLen;
		StorageTmp->sccpRemoteSCCPName = string;
		StorageTmp->sccpRemoteSCCPNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRemoteSCCPName = old_value;
		StorageTmp->sccpRemoteSCCPNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewEncodingScheme entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWENCODINGSCHEME_UNKNOWN:
		case SCCPGTNEWENCODINGSCHEME_BCDODD:
		case SCCPGTNEWENCODINGSCHEME_BCDEVEN:
		case SCCPGTNEWENCODINGSCHEME_NATIONALSPECIFIC:
		case SCCPGTNEWENCODINGSCHEME_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtNewEncodingScheme for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtNewEncodingScheme;
		StorageTmp->sccpGtNewEncodingScheme = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewEncodingScheme = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewNatureOfAddress entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWNATUREOFADDRESS_UNKNOWN:
		case SCCPGTNEWNATUREOFADDRESS_ISDNTNP:
		case SCCPGTNEWNATUREOFADDRESS_GENERICNUMBERINGPLAN:
		case SCCPGTNEWNATUREOFADDRESS_DNP:
		case SCCPGTNEWNATUREOFADDRESS_TNP:
		case SCCPGTNEWNATUREOFADDRESS_MMNP:
		case SCCPGTNEWNATUREOFADDRESS_LMNP:
		case SCCPGTNEWNATUREOFADDRESS_ISDNMNP:
		case SCCPGTNEWNATUREOFADDRESS_PRIVATENUMBERINGPLAN:
		case SCCPGTNEWNATUREOFADDRESS_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtNewNatureOfAddress for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtNewNatureOfAddress;
		StorageTmp->sccpGtNewNatureOfAddress = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewNatureOfAddress = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewNumberingPlan entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWNUMBERINGPLAN_UNKNOWN:
		case SCCPGTNEWNUMBERINGPLAN_SUBSCRIBER:
		case SCCPGTNEWNUMBERINGPLAN_NATIONAL:
		case SCCPGTNEWNUMBERINGPLAN_INTERNATIONAL:
		case SCCPGTNEWNUMBERINGPLAN_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtNewNumberingPlan for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtNewNumberingPlan;
		StorageTmp->sccpGtNewNumberingPlan = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewNumberingPlan = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewTranslationType entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWTRANSLATIONTYPE_UNKNOWN:
		case SCCPGTNEWTRANSLATIONTYPE_ITCC:
		case SCCPGTNEWTRANSLATIONTYPE_GENERICNUMBERINGPLAN:
		case SCCPGTNEWTRANSLATIONTYPE_IEESS:
		case SCCPGTNEWTRANSLATIONTYPE_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtNewTranslationType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtNewTranslationType;
		StorageTmp->sccpGtNewTranslationType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewTranslationType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtConversionRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtConversionRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtConversionRuleName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtConversionRuleName for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtConversionRuleName;
		old_length = StorageTmp->sccpGtConversionRuleNameLen;
		StorageTmp->sccpGtConversionRuleName = string;
		StorageTmp->sccpGtConversionRuleNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtConversionRuleName = old_value;
		StorageTmp->sccpGtConversionRuleNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoOperation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAddressInfoOperation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoOperation entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAddressInfoRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPADDRESSINFOOPERATION_INSERT:
		case SCCPADDRESSINFOOPERATION_REPLACE:
		case SCCPADDRESSINFOOPERATION_PASSTRANSPARENTLY:
		case SCCPADDRESSINFOOPERATION_DELETE:
		case SCCPADDRESSINFOOPERATION_STOP:
		case SCCPADDRESSINFOOPERATION_COPYREMAIN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAddressInfoOperation for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAddressInfoOperation;
		StorageTmp->sccpAddressInfoOperation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoOperation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoAddressElement(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAddressInfoAddressElement(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoAddressElement entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAddressInfoRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAddressInfoAddressElement for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAddressInfoAddressElement;
		StorageTmp->sccpAddressInfoAddressElement = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoAddressElement = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoNrOfAddressElements(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAddressInfoNrOfAddressElements(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoNrOfAddressElements entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAddressInfoRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAddressInfoNrOfAddressElements for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAddressInfoNrOfAddressElements;
		StorageTmp->sccpAddressInfoNrOfAddressElements = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoNrOfAddressElements = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtIndicator entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTINDICATOR_NOGLOBALTITLE:
		case SCCPGTINDICATOR_NOAONLY:
		case SCCPGTINDICATOR_TTONLY:
		case SCCPGTINDICATOR_TT_NP_ES:
		case SCCPGTINDICATOR_TT_NP_ES_NOA:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtIndicator for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtIndicator;
		StorageTmp->sccpGtIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNatureOfAddress entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTNATUREOFADDRESS_UNKNOWN:
		case SCCPGTNATUREOFADDRESS_ISDNTNP:
		case SCCPGTNATUREOFADDRESS_GENERICNUMBERINGPLAN:
		case SCCPGTNATUREOFADDRESS_DNP:
		case SCCPGTNATUREOFADDRESS_TNP:
		case SCCPGTNATUREOFADDRESS_MMNP:
		case SCCPGTNATUREOFADDRESS_LMNP:
		case SCCPGTNATUREOFADDRESS_ISDNMNP:
		case SCCPGTNATUREOFADDRESS_PRIVATENUMBERINGPLAN:
		case SCCPGTNATUREOFADDRESS_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtNatureOfAddress for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtNatureOfAddress;
		StorageTmp->sccpGtNatureOfAddress = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNatureOfAddress = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNumberingPlan entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTNUMBERINGPLAN_UNKNOWN:
		case SCCPGTNUMBERINGPLAN_SUBSCRIBER:
		case SCCPGTNUMBERINGPLAN_NATIONAL:
		case SCCPGTNUMBERINGPLAN_INTERNATIONAL:
		case SCCPGTNUMBERINGPLAN_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtNumberingPlan for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtNumberingPlan;
		StorageTmp->sccpGtNumberingPlan = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNumberingPlan = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslationType entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTTRANSLATIONTYPE_UNKNOWN:
		case SCCPGTTRANSLATIONTYPE_ITCC:
		case SCCPGTTRANSLATIONTYPE_GENERICNUMBERINGPLAN:
		case SCCPGTTRANSLATIONTYPE_IEESS:
		case SCCPGTTRANSLATIONTYPE_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtTranslationType for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtTranslationType;
		StorageTmp->sccpGtTranslationType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslationType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslatorAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtTranslatorAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslatorAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTTRANSLATORADMINISTRATIVESTATE_LOCKED:
		case SCCPGTTRANSLATORADMINISTRATIVESTATE_UNLOCKED:
		case SCCPGTTRANSLATORADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtTranslatorAdministrativeState for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtTranslatorAdministrativeState;
		StorageTmp->sccpGtTranslatorAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslatorAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslatorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtTranslatorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslatorName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtTranslatorName for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtTranslatorName;
		old_length = StorageTmp->sccpGtTranslatorNameLen;
		StorageTmp->sccpGtTranslatorName = string;
		StorageTmp->sccpGtTranslatorNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslatorName = old_value;
		StorageTmp->sccpGtTranslatorNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtRuleAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtRuleAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtRuleAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTRULEADMINISTRATIVESTATE_LOCKED:
		case SCCPGTRULEADMINISTRATIVESTATE_UNLOCKED:
		case SCCPGTRULEADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtRuleAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtRuleAdministrativeState;
		StorageTmp->sccpGtRuleAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtRuleAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtAddressInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtAddressInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtAddressInformation entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtAddressInformation for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtAddressInformation;
		old_length = StorageTmp->sccpGtAddressInformationLen;
		StorageTmp->sccpGtAddressInformation = string;
		StorageTmp->sccpGtAddressInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtAddressInformation = old_value;
		StorageTmp->sccpGtAddressInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtConvRulePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtConvRulePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtConvRulePointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtConvRulePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtConvRulePointer;
		old_length = StorageTmp->sccpGtConvRulePointerLen;
		StorageTmp->sccpGtConvRulePointer = string;
		StorageTmp->sccpGtConvRulePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtConvRulePointer = old_value;
		StorageTmp->sccpGtConvRulePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtEncodingScheme entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTENCODINGSCHEME_UNKNOWN:
		case SCCPGTENCODINGSCHEME_BCDODD:
		case SCCPGTENCODINGSCHEME_BCDEVEN:
		case SCCPGTENCODINGSCHEME_NATIONALSPECIFIC:
		case SCCPGTENCODINGSCHEME_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtEncodingScheme for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtEncodingScheme;
		StorageTmp->sccpGtEncodingScheme = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtEncodingScheme = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetPointer entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpEntitySetPointer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpEntitySetPointer;
		old_length = StorageTmp->sccpEntitySetPointerLen;
		StorageTmp->sccpEntitySetPointer = string;
		StorageTmp->sccpEntitySetPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetPointer = old_value;
		StorageTmp->sccpEntitySetPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtRuleName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpGtRuleName for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpGtRuleName;
		old_length = StorageTmp->sccpGtRuleNameLen;
		StorageTmp->sccpGtRuleName = string;
		StorageTmp->sccpGtRuleNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtRuleName = old_value;
		StorageTmp->sccpGtRuleNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpDSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpDSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpDSRVT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpDSRVT for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpDSRVT;
		StorageTmp->sccpDSRVT = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpDSRVT = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpNSRVT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpNSRVT for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpNSRVT;
		StorageTmp->sccpNSRVT = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNSRVT = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSrvtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSrvtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSrvtName entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpSrvtName for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		old_value = StorageTmp->sccpSrvtName;
		old_length = StorageTmp->sccpSrvtNameLen;
		StorageTmp->sccpSrvtName = string;
		StorageTmp->sccpSrvtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSrvtName = old_value;
		StorageTmp->sccpSrvtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAdministrativeState entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case SCCPADMINISTRATIVESTATE_LOCKED:
		case SCCPADMINISTRATIVESTATE_UNLOCKED:
		case SCCPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpAdministrativeState;
		StorageTmp->sccpAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpTraceRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpTraceRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpTraceRequested entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpTraceRequested for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		old_value = StorageTmp->sccpTraceRequested;
		StorageTmp->sccpTraceRequested = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpTraceRequested = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpThreshold entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpThreshold for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpThreshold;
		StorageTmp->sccpThreshold = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpThreshold = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpMtpBackwardRoutingRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpMtpBackwardRoutingRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpMtpBackwardRoutingRequested entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpMtpBackwardRoutingRequested for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpMtpBackwardRoutingRequested;
		StorageTmp->sccpMtpBackwardRoutingRequested = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpMtpBackwardRoutingRequested = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpOriginalGT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpOriginalGT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpOriginalGT entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpOriginalGT for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpOriginalGT;
		old_length = StorageTmp->sccpOriginalGTLen;
		StorageTmp->sccpOriginalGT = string;
		StorageTmp->sccpOriginalGTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpOriginalGT = old_value;
		StorageTmp->sccpOriginalGTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpInfoRequest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpInfoRequest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpInfoRequest entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpInfoRequest for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		old_value = StorageTmp->sccpInfoRequest;
		old_length = StorageTmp->sccpInfoRequestLen;
		StorageTmp->sccpInfoRequest = string;
		StorageTmp->sccpInfoRequestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpInfoRequest = old_value;
		StorageTmp->sccpInfoRequestLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpReturnUnknownParams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpReturnUnknownParams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpReturnUnknownParams entering action=%d...  \n", action));
	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);

	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->sccpReturnUnknownParams for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		old_value = StorageTmp->sccpReturnUnknownParams;
		old_length = StorageTmp->sccpReturnUnknownParamsLen;
		StorageTmp->sccpReturnUnknownParams = string;
		StorageTmp->sccpReturnUnknownParamsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpReturnUnknownParams = old_value;
		StorageTmp->sccpReturnUnknownParamsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int sccpNetworkEntityTable_consistent(struct sccpNetworkEntityTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpNetworkEntityTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpNetworkEntityTable_consistent(struct sccpNetworkEntityTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpSapNameTable_consistent(struct sccpSapNameTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpSapNameTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpSapNameTable_consistent(struct sccpSapNameTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpAccessPointTable_consistent(struct sccpAccessPointTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpAccessPointTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpAccessPointTable_consistent(struct sccpAccessPointTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpLinkageTable_consistent(struct sccpLinkageTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpLinkageTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpLinkageTable_consistent(struct sccpLinkageTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpSclcTable_consistent(struct sccpSclcTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpSclcTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpSclcTable_consistent(struct sccpSclcTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpScocTable_consistent(struct sccpScocTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpScocTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpScocTable_consistent(struct sccpScocTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpScrcTable_consistent(struct sccpScrcTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpScrcTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpScrcTable_consistent(struct sccpScrcTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpEntitySetTable_consistent(struct sccpEntitySetTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpEntitySetTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpEntitySetTable_consistent(struct sccpEntitySetTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpEntitySetSapTable_consistent(struct sccpEntitySetSapTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpEntitySetSapTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpEntitySetSapTable_consistent(struct sccpEntitySetSapTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpConcernedAreaTable_consistent(struct sccpConcernedAreaTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpConcernedAreaTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpConcernedAreaTable_consistent(struct sccpConcernedAreaTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpRemoteSCCPTable_consistent(struct sccpRemoteSCCPTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpRemoteSCCPTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpRemoteSCCPTable_consistent(struct sccpRemoteSCCPTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpGtConversionRuleTable_consistent(struct sccpGtConversionRuleTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpGtConversionRuleTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpGtConversionRuleTable_consistent(struct sccpGtConversionRuleTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpAddressInfoTable_consistent(struct sccpAddressInfoTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpAddressInfoTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpAddressInfoTable_consistent(struct sccpAddressInfoTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpGtTranslatorTable_consistent(struct sccpGtTranslatorTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpGtTranslatorTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpGtTranslatorTable_consistent(struct sccpGtTranslatorTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpGtRuleTable_consistent(struct sccpGtRuleTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpGtRuleTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpGtRuleTable_consistent(struct sccpGtRuleTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int sccpSrvtTable_consistent(struct sccpSrvtTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the sccpSrvtTable table.  If the
 * table row is internally consistent, then this function returns true (1), otherwise the function
 * returns false (0) and it will not be possible to activate the row until the row's internal
 * consistency is corrected.
 */
int
sccpSrvtTable_consistent(struct sccpSrvtTable_data *thedata)
{
	/* XXX: check row consistency return true(1) if consistent, or false(0) if not. */
	return (1);
}

/**
 * @fn int write_sccpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static struct sccpNetworkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpNetworkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpNetworkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpNetworkEntityTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpNetworkEntityTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpNetworkEntityTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpNetworkEntityTable_del(StorageNew);
			sccpNetworkEntityTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpNetworkEntityTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpRowStatus;
			StorageTmp->sccpRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpNetworkEntityTable_consistent(StorageTmp)) {
					StorageTmp->sccpRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpRowStatus;
			StorageTmp->sccpRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpNetworkEntityTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpNetworkEntityTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpNetworkEntityTable_destroy(&StorageDel);
			/* sccpNetworkEntityTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSapNameRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpSapNameRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpSapNameTable_data *StorageTmp = NULL;
	static struct sccpSapNameTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpSapNameTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSapNameRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSapNameRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpSapNameRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpSapNameTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpSapNameTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpSapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpSapNameTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpSapId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpSapNameTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpSapNameTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpSapNameTable_del(StorageNew);
			sccpSapNameTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpSapNameTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpSapNameRowStatus;
			StorageTmp->sccpSapNameRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpSapNameTable_consistent(StorageTmp)) {
					StorageTmp->sccpSapNameRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpSapNameRowStatus;
			StorageTmp->sccpSapNameRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpSapNameRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpSapNameTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpSapNameRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpSapNameTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpSapNameRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpSapNameTable_destroy(&StorageDel);
			/* sccpSapNameTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAccessPointRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpAccessPointRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static struct sccpAccessPointTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpAccessPointRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpAccessPointTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpAccessPointTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpSapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpAccessPointTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpSapId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpAccessPointTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpAccessPointTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpAccessPointTable_del(StorageNew);
			sccpAccessPointTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpAccessPointTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpAccessPointRowStatus;
			StorageTmp->sccpAccessPointRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpAccessPointTable_consistent(StorageTmp)) {
					StorageTmp->sccpAccessPointRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpAccessPointRowStatus;
			StorageTmp->sccpAccessPointRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpAccessPointRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpAccessPointTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpAccessPointRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpAccessPointTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpAccessPointRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpAccessPointTable_destroy(&StorageDel);
			/* sccpAccessPointTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpLinkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static struct sccpLinkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpLinkageRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpLinkageTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpLinkageTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpLinkageId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpLinkageTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpLinkageId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpLinkageTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpLinkageTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpLinkageTable_del(StorageNew);
			sccpLinkageTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpLinkageTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpLinkageRowStatus;
			StorageTmp->sccpLinkageRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpLinkageTable_consistent(StorageTmp)) {
					StorageTmp->sccpLinkageRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpLinkageRowStatus;
			StorageTmp->sccpLinkageRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpLinkageRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpLinkageTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpLinkageRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpLinkageTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpLinkageRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpLinkageTable_destroy(&StorageDel);
			/* sccpLinkageTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpSclcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpSclcTable_data *StorageTmp = NULL;
	static struct sccpSclcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpSclcRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpSclcTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpSclcTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpSclcTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpSclcTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpSclcTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpSclcTable_del(StorageNew);
			sccpSclcTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpSclcTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpSclcRowStatus;
			StorageTmp->sccpSclcRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpSclcTable_consistent(StorageTmp)) {
					StorageTmp->sccpSclcRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpSclcRowStatus;
			StorageTmp->sccpSclcRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpSclcRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpSclcTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpSclcRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpSclcTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpSclcRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpSclcTable_destroy(&StorageDel);
			/* sccpSclcTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpScocRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpScocTable_data *StorageTmp = NULL;
	static struct sccpScocTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpScocRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpScocTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpScocTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpScocTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpScocTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpScocTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpScocTable_del(StorageNew);
			sccpScocTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpScocTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpScocRowStatus;
			StorageTmp->sccpScocRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpScocTable_consistent(StorageTmp)) {
					StorageTmp->sccpScocRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpScocRowStatus;
			StorageTmp->sccpScocRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpScocRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpScocTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpScocRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpScocTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpScocRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpScocTable_destroy(&StorageDel);
			/* sccpScocTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpScrcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpScrcTable_data *StorageTmp = NULL;
	static struct sccpScrcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpScrcRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpScrcTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpScrcTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpScrcTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&sccpScrcTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpScrcTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpScrcTable_del(StorageNew);
			sccpScrcTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpScrcTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpScrcRowStatus;
			StorageTmp->sccpScrcRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpScrcTable_consistent(StorageTmp)) {
					StorageTmp->sccpScrcRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpScrcRowStatus;
			StorageTmp->sccpScrcRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpScrcRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpScrcTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpScrcRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpScrcTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpScrcRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpScrcTable_destroy(&StorageDel);
			/* sccpScrcTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpEntitySetRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static struct sccpEntitySetTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpEntitySetRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpEntitySetTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpEntitySetTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpEntitySetId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpEntitySetTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpEntitySetTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpEntitySetTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpEntitySetTable_del(StorageNew);
			sccpEntitySetTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpEntitySetTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpEntitySetRowStatus;
			StorageTmp->sccpEntitySetRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpEntitySetTable_consistent(StorageTmp)) {
					StorageTmp->sccpEntitySetRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpEntitySetRowStatus;
			StorageTmp->sccpEntitySetRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpEntitySetRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpEntitySetTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpEntitySetRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpEntitySetTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpEntitySetRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpEntitySetTable_destroy(&StorageDel);
			/* sccpEntitySetTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpEntitySetSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	static struct sccpEntitySetSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpEntitySetSapRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpEntitySetSapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpEntitySetSapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpEntitySetId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpEntitySetSapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpEntitySetSapTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetSapId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetSapIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpEntitySetSapTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpEntitySetSapTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpEntitySetSapTable_del(StorageNew);
			sccpEntitySetSapTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpEntitySetSapTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpEntitySetSapRowStatus;
			StorageTmp->sccpEntitySetSapRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpEntitySetSapTable_consistent(StorageTmp)) {
					StorageTmp->sccpEntitySetSapRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpEntitySetSapRowStatus;
			StorageTmp->sccpEntitySetSapRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpEntitySetSapRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpEntitySetSapTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpEntitySetSapRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpEntitySetSapTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpEntitySetSapRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpEntitySetSapTable_destroy(&StorageDel);
			/* sccpEntitySetSapTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpConcernedAreaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpConcernedAreaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpConcernedAreaTable_data *StorageTmp = NULL;
	static struct sccpConcernedAreaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpConcernedAreaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpConcernedAreaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpConcernedAreaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpConcernedAreaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpConcernedAreaId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpConcernedAreaTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpConcernedAreaId, vp->val.string, vp->val_len);
			StorageNew->sccpConcernedAreaIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpConcernedAreaTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpConcernedAreaTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpConcernedAreaTable_del(StorageNew);
			sccpConcernedAreaTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpConcernedAreaTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpConcernedAreaRowStatus;
			StorageTmp->sccpConcernedAreaRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpConcernedAreaTable_consistent(StorageTmp)) {
					StorageTmp->sccpConcernedAreaRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpConcernedAreaRowStatus;
			StorageTmp->sccpConcernedAreaRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpConcernedAreaRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpConcernedAreaTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpConcernedAreaRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpConcernedAreaTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpConcernedAreaRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpConcernedAreaTable_destroy(&StorageDel);
			/* sccpConcernedAreaTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRemoteSCCPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpRemoteSCCPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	static struct sccpRemoteSCCPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpRemoteSCCPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpRemoteSCCPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpRemoteSCCPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpConcernedAreaId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpRemoteSCCPId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpRemoteSCCPTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpConcernedAreaId, vp->val.string, vp->val_len);
			StorageNew->sccpConcernedAreaIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpRemoteSCCPId, vp->val.string, vp->val_len);
			StorageNew->sccpRemoteSCCPIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpRemoteSCCPTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpRemoteSCCPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpRemoteSCCPTable_del(StorageNew);
			sccpRemoteSCCPTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpRemoteSCCPTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpRemoteSCCPRowStatus;
			StorageTmp->sccpRemoteSCCPRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpRemoteSCCPTable_consistent(StorageTmp)) {
					StorageTmp->sccpRemoteSCCPRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpRemoteSCCPRowStatus;
			StorageTmp->sccpRemoteSCCPRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpRemoteSCCPRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpRemoteSCCPTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpRemoteSCCPRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpRemoteSCCPTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpRemoteSCCPRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpRemoteSCCPTable_destroy(&StorageDel);
			/* sccpRemoteSCCPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtConversionRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpGtConversionRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static struct sccpGtConversionRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpGtConversionRuleRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpGtConversionRuleTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpGtConversionRuleTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpGtConversionRuleId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpGtConversionRuleTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtConversionRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtConversionRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpGtConversionRuleTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpGtConversionRuleTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpGtConversionRuleTable_del(StorageNew);
			sccpGtConversionRuleTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpGtConversionRuleTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpGtConversionRuleRowStatus;
			StorageTmp->sccpGtConversionRuleRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpGtConversionRuleTable_consistent(StorageTmp)) {
					StorageTmp->sccpGtConversionRuleRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpGtConversionRuleRowStatus;
			StorageTmp->sccpGtConversionRuleRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpGtConversionRuleRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpGtConversionRuleTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpGtConversionRuleRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpGtConversionRuleTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpGtConversionRuleRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpGtConversionRuleTable_destroy(&StorageDel);
			/* sccpGtConversionRuleTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpAddressInfoRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	static struct sccpAddressInfoTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpAddressInfoRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpAddressInfoTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpAddressInfoTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpGtConversionRuleId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpAddressInfoOperationId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpAddressInfoTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtConversionRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtConversionRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpAddressInfoOperationId, vp->val.string, vp->val_len);
			StorageNew->sccpAddressInfoOperationIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpAddressInfoTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpAddressInfoTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpAddressInfoTable_del(StorageNew);
			sccpAddressInfoTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpAddressInfoTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpAddressInfoRowStatus;
			StorageTmp->sccpAddressInfoRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpAddressInfoTable_consistent(StorageTmp)) {
					StorageTmp->sccpAddressInfoRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpAddressInfoRowStatus;
			StorageTmp->sccpAddressInfoRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpAddressInfoRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpAddressInfoTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpAddressInfoRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpAddressInfoTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpAddressInfoRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpAddressInfoTable_destroy(&StorageDel);
			/* sccpAddressInfoTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslatorRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpGtTranslatorRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static struct sccpGtTranslatorTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpGtTranslatorRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpGtTranslatorTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpGtTranslatorTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpGtTranslatorId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpGtTranslatorTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtTranslatorId, vp->val.string, vp->val_len);
			StorageNew->sccpGtTranslatorIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpGtTranslatorTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpGtTranslatorTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpGtTranslatorTable_del(StorageNew);
			sccpGtTranslatorTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpGtTranslatorTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpGtTranslatorRowStatus;
			StorageTmp->sccpGtTranslatorRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpGtTranslatorTable_consistent(StorageTmp)) {
					StorageTmp->sccpGtTranslatorRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpGtTranslatorRowStatus;
			StorageTmp->sccpGtTranslatorRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpGtTranslatorRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpGtTranslatorTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpGtTranslatorRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpGtTranslatorTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpGtTranslatorRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpGtTranslatorTable_destroy(&StorageDel);
			/* sccpGtTranslatorTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpGtRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static struct sccpGtRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpGtRuleRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpGtRuleTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpGtRuleTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpGtTranslatorId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpGtRuleId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpGtRuleTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtTranslatorId, vp->val.string, vp->val_len);
			StorageNew->sccpGtTranslatorIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpGtRuleTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpGtRuleTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpGtRuleTable_del(StorageNew);
			sccpGtRuleTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpGtRuleTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpGtRuleRowStatus;
			StorageTmp->sccpGtRuleRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpGtRuleTable_consistent(StorageTmp)) {
					StorageTmp->sccpGtRuleRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpGtRuleRowStatus;
			StorageTmp->sccpGtRuleRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpGtRuleRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpGtRuleTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpGtRuleRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpGtRuleTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpGtRuleRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpGtRuleTable_destroy(&StorageDel);
			/* sccpGtRuleTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRouteTestRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpRouteTestRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static struct sccpSrvtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRouteTestRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRouteTestRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpRouteTestRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpSrvtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpSrvtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* sccpRouteTestId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			if ((StorageNew = sccpSrvtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpRouteTestId, vp->val.string, vp->val_len);
			StorageNew->sccpRouteTestIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&sccpSrvtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpSrvtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpSrvtTable_del(StorageNew);
			sccpSrvtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpSrvtTable_add(StorageDel);
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_ACTIVE:
			old_value = StorageTmp->sccpRouteTestRowStatus;
			StorageTmp->sccpRouteTestRowStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if (!sccpSrvtTable_consistent(StorageTmp)) {
					StorageTmp->sccpRouteTestRowStatus = old_value;
					return SNMP_ERR_INCONSISTENTVALUE;
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpRouteTestRowStatus;
			StorageTmp->sccpRouteTestRowStatus = set_value;
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpRouteTestRowStatus = old_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpSrvtTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device */
				/* XXX: activate with underlying device */
				StorageNew->sccpRouteTestRowStatus = RS_ACTIVE;
			}
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* check if row is ready, otherwise leave at RS_NOTREADY */
			if (sccpSrvtTable_consistent(StorageNew)) {
				/* XXX: commit creation to underlying device, inactive */
				StorageNew->sccpRouteTestRowStatus = RS_NOTINSERVICE;
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpSrvtTable_destroy(&StorageDel);
			/* sccpSrvtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_sccpRouteTestResult_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sccpRouteTestResult_oid;
	trap.val_len = sizeof(sccpRouteTestResult_oid);
	trap.index = 0;
	send_v2trap(&trap);
}

#if defined MODULE
#if defined MASTER
/**
 * @fn void sccpMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
sccpMIB_loop_handler(int sig)
{
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	/* close files after each request */
	if (sa_fclose) {
		if (sa_fd != 0) {
			close(sa_fd);
			sa_fd = 0;
		}
		if (my_fd != 0) {
			close(my_fd);
			my_fd = 0;
		}
	}
	/* prepare for next request */
	sa_request++;
	if (sccpMIBold_signal_handler != NULL)
		(*sccpMIBold_signal_handler) (sig);
}
#endif				/* defined MASTER */
/**
 * @fn void sccpMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
sccpMIB_fd_handler(int fd, void *dummy)
{
	/* XXX: place actions to handle sa_readfd here... */
	return;
}
#endif				/* defined MOUDLE */
#if defined MASTER
const char sa_program[] = "sccpmib";
int sa_fclose = 1;			/* default close files between requests */
int sa_fd = 0;				/* file descriptor for MIB use */
int sa_readfd = 0;			/* file descriptor for autonomnous events */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
#endif				/* defined MASTER */
#if defined MASTER
#if !defined MODULE
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
int sa_nomead = 1;			/* default daemon mode */
int sa_output = 1;			/* default normal output */
int sa_agentx = 1;			/* default agentx mode */
int sa_alarms = 1;			/* default application alarms */
int sa_logaddr = 0;			/* log addresses */
int sa_logfillog = 0;			/* log to sa_logfile */
int sa_logstderr = 0;			/* log to standard error */
int sa_logstdout = 0;			/* log to standard output */
int sa_logsyslog = 0;			/* log to system logs */
int sa_logcallog = 0;			/* log to callback logs */
int sa_appendlog = 0;			/* append to log file without truncating */
char sa_logfile[256] = "/var/log/sccpmib.log";
char sa_pidfile[256] = "/var/run/sccpmib.pid";
char sa_sysctlf[256] = "/etc/sccpmib.conf";
int allow_severity = LOG_ERR;
int deny_severity = LOG_ERR;

/* file stream for log file */
FILE *stdlog = NULL;
static void
sa_version(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
%2$s\n\
Copyright (c) 2008-2009  Monavacon Limited.  All Rights Reserved.\n\
Distributed under Affero GPL Version 3, included here by reference.\n\
See `%1$s --copying' for copying permissions.\n\
", argv[0], ident);
}
static void
sa_usage(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-H|--help-directives}\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
", argv[0]);
}
static void
sa_help(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
Usage:\n\
    %1$s [general-options] [options] [arguments]\n\
    %1$s {-h|--help}\n\
    %1$s {-V|--version}\n\
    %1$s {-C|--copying}\n\
Arguments:\n\
    None.\n\
Options:\n\
    -a, --log-addresses\n\
        log addresses of connecting management stations.\n\
    -A, --append\n\
        append to logfiles without truncating.\n\
    -c, --config-file CONFIGFILE\n\
        use configuration file CONFIGFILE.\n\
    -C, --config-only\n\
        only load configuration given by -c option.\n\
    -d, --dump\n\
        dump sent and received PDUs.\n\
    -D, --debug [LEVEL]\n\
        set debugging verbosity to LEVEL.\n\
    -D, --debug-tokens [TOKEN[,TOKEN]*]\n\
        debug specified TOKEN's.\n\
    -f, --dont-fork\n\
        run in the foreground.\n\
    -g, --gid, --groupid GID\n\
        become group GID after listening.\n\
    -h, --help, -?, --?\n\
        print usage information and exit.\n\
    -H, --help-directives\n\
        print config directives and exit.\n\
    -I, --initialize [-]MODULE[,MODULE]*\n\
        initialize (or not, '-') these MODULE's.\n\
    -k, --keep-open\n\
        keep system files open between requests.\n\
    -l, --log-file [LOGFILE]\n\
        log to log file name LOGFILE.  [default: /var/log/sccpmib.log]\n\
    -L, --log-stderr\n\
        log to controlling terminal standard error.\n\
    -m, --mibs [+]MIB[,MIB]*\n\
        load these (additional '+') MIBs.\n\
    -M, --master\n\
        run as SNMP master instead of AgentX sub-agent.\n\
    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\n\
        search these (additional, '+') colon separated directories for MIBs.\n\
    -n, --nodaemon\n\
        run in the foreground.\n\
    -n, --name NAME\n\
        use NAME for configuration file base.  [default: sccpmib]\n\
    -p, --port PORTNUM\n\
        listen on port number PORTNUM.  [default: 161]\n\
    -p, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/sccpmib.pid]\n\
    -P, --pidfile PIDFILE\n\
        write daemon pid to PIDFILE.  [default: /var/run/sccpmib.pid]\n\
    -q, --quiet\n\
        suppress normal output.\n\
    -q, --quick\n\
        abbreviate output for machine readability.\n\
    -r, --noroot\n\
        do not require root privilege.\n\
    -s, --log-syslog\n\
        log to system logs.\n\
    -S, --sysctl-file FILENAME\n\
        write sysctl config file FILENAME.  [default: /etc/streams.conf]\n\
    -t, --agent-alarms\n\
        agent blocks {SIGALARM}.\n\
    -T, --transport [TRANSPORT]\n\
        default transport TRANSPORT.  [default: udp]\n\
    -u, --uid, --userid UID\n\
        become user UID after listening.\n\
    -U, --dont-remove-pidfile\n\
        do not remove PIDFILE when shutting down.\n\
    -v, --version\n\
        print version information and exit.\n\
    -V, --verbose [LEVEL]\n\
        be verbose to LEVEL.  [default: 1]\n\
    -x, --agentx-socket [SOCKET]\n\
        master AgentX on SOCKET.  [default: /var/agentx/master]\n\
    -X, --agentx\n\
        run as AgentX sub-agent instead of master (the default).\n\
    -y, --copying\n\
        print copying information and exit.\n\
", argv[0]);
}
static void
sa_copying(int argc, char *argv[])
{
	if (!sa_output && !sa_debug)
		return;
	fprintf(stdout, "\
--------------------------------------------------------------------------------\n\
%1$s\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com>\n\
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\n\
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms of the GNU Affero General Public License as published by the Free\n\
Software Foundation; Version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the GNU  Affero  General Public License along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\n\
", ident);
}

void
sa_help_directives(int argc, char *argv[])
{
	ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
	init_agent("sccpMIB");
	// init_mib_modules();
	init_mib();
	init_snmp("sccpMIB");
	snmp_log(MY_FACILITY(LOG_INFO), "Configuration directives understood:\n");
	/* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be writen to standard error and not standard output. */
	read_config_print_usage("    ");
}
static int
sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = handler ? handler : SIG_DFL;
	act.sa_flags = handler ? SA_RESTART : 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(signum, &act, NULL))
		return (-1);
	sigemptyset(&mask);
	sigaddset(&mask, signum);
	sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
	return (0);
}
static int sa_alm_signal = 0;
static int sa_pol_signal = 0;
static int sa_hup_signal = 0;
static int sa_int_signal = 0;
static int sa_trm_signal = 0;
static int sa_alm_handle = 0;
void
sa_alm_callback(uint req, void *arg)
{
	if (req == sa_alm_handle)
		sa_alm_handle = 0;
	sa_alm_signal = 1;
	return;
}

static RETSIGTYPE
sa_alm_handler(int signum)
{
	sa_alm_signal = 1;
	return (RETSIGTYPE) (0);
}
static void
sa_snmp_alm_handler(uint reg, void *clientarg)
{
	sa_alm_signal = 1;
	return;
}
static int
sa_alm_catch(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, &sa_alm_handler);
	return (-1);
}
static int
sa_alm_block(void)
{
	if (sa_alarms)
		return sa_sig_register(SIGALRM, NULL);
	if (sa_alm_handle) {
		uint handle = sa_alm_handle;

		sa_alm_handle = 0;
		snmp_alarm_unregister(handle);
	}
	return (0);
}
static int
sa_alm_action(void)
{
	sa_alm_signal = 0;
	return (0);
}

static RETSIGTYPE
sa_pol_handler(int signum)
{
	sa_pol_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_pol_catch(void)
{
	return sa_sig_register(SIGPOLL, &sa_pol_handler);
}
static int
sa_pol_block(void)
{
	return sa_sig_register(SIGPOLL, NULL);
}

/*
 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
 * configuration changes, indicating to the agent which has the sc(4) or
 * sad(4) Stream open that it is necessary to reread information from the
 * kernel.  This fact is merely recorded, as this information is not read each
 * time that a configuration change occurs, but only after a request from some
 * portion of that information occurs. This condition is also set when the
 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
 * siginfo the file descriptor issuing the signal, so we could distiguish
 * between sc(4) and sad(4) signals, but since one can be pushed over the
 * other, there is little point in distinguishing.
 *
 * sc(4) or sad(4) also should be modified to provide the general streams
 * statistics supported here; even though they are available through the /proc
 * filesystem on Linux Fast-STREAMS.
 */
static int
sa_pol_action(void)
{
	sa_pol_signal = 0;
	snmp_log(MY_FACILITY(LOG_INFO), "%s: Caught SIGPOLL, will re-read data structures", sa_program);
	sa_changed = 1;
	return (0);
}

static RETSIGTYPE
sa_hup_handler(int signum)
{
	sa_hup_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_hup_catch(void)
{
	if (sa_agentx)
		return sa_sig_register(SIGHUP, &sa_hup_handler);
	return (-1);
}
static int
sa_hup_block(void)
{
	return sa_sig_register(SIGHUP, NULL);
}
static int
sa_hup_action(void)
{
	/* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by logrotate asking us to close and reopen our log files. */
	sa_hup_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "Caught SIGHUP, reopening files.");
	if (sa_output > 1)
		snmp_log(MY_FACILITY(LOG_NOTICE), "Reopening output file %s", sa_logfile);
	if (sa_logfillog != 0) {
		fflush(stdlog);
		fclose(stdlog);
		snmp_disable_filelog();
		if ((stdlog = freopen(sa_logfile, sa_appendlog ? "a" : "w", stdlog)) == NULL) {
			/* I hope we have another log sink. */
			snmp_log(MY_FACILITY(LOG_ERR), "%s", strerror(errno));
			snmp_log(MY_FACILITY(LOG_ERR), "Could not reopen log file %s", sa_logfile);
		}
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	return (0);
}

static RETSIGTYPE
sa_int_handler(int signum)
{
	sa_int_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_int_catch(void)
{
	return sa_sig_register(SIGINT, &sa_int_handler);
}
static int
sa_int_block(void)
{
	return sa_sig_register(SIGINT, NULL);
}
static void sa_exit(int retval);
static int
sa_int_action(void)
{
	sa_int_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGINT, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}

static RETSIGTYPE
sa_trm_handler(int signum)
{
	sa_trm_signal = 1;
	return (RETSIGTYPE) (0);
}
static int
sa_trm_catch(void)
{
	return sa_sig_register(SIGTERM, &sa_trm_handler);
}
static int
sa_trm_block(void)
{
	return sa_sig_register(SIGTERM, NULL);
}
static void sa_exit(int retval);
static int
sa_trm_action(void)
{
	sa_trm_signal = 0;
	snmp_log(MY_FACILITY(LOG_WARNING), "%s: Caught SIGTERM, shutting down", sa_program);
	sa_exit(0);
	return (0);		/* should be no return */
}
static void
sa_sig_catch(void)
{
	sa_alm_catch();
	sa_pol_catch();
	sa_hup_catch();
	sa_int_catch();
	sa_trm_catch();
}
static void
sa_sig_block(void)
{
	sa_alm_block();
	sa_pol_block();
	sa_hup_block();
	sa_int_block();
	sa_trm_block();
}

int
sa_start_timer(long duration)
{
	if (sa_alarms) {
		struct itimerval setting = {
			{0, 0},
			{duration / 1000, (duration % 1000) * 1000}
		};
		if (sa_alm_catch())
			return (-1);
		if (setitimer(ITIMER_REAL, &setting, NULL))
			return (-1);
		sa_alm_signal = 0;
		return (0);
	} else {
#if defined NETSNMP_DS_APPLICATION_ID
		struct timeval setting = {
			duration / 1000, (duration % 1000) * 1000
		};
		sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
#else
		sa_alm_handle = snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
#endif
		return (sa_alm_handle ? 0 : -1);
	}
}
static void
sa_exit(int retval)
{
	if (retval)
		snmp_log(MY_FACILITY(LOG_ERR), "%s: Exiting %d", sa_program, retval);
	else
		snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Exiting %d", sa_program, retval);
	fflush(stdout);
	fflush(stderr);
	sa_sig_block();
	closelog();
	exit(retval);
}
static void
sa_init_logging(int argc, char *argv[])
{
	static char progname[256];

	/* The purpose of this function is to bring logging up before forking (and while still in the foreground) so that we can use the snmp_log() function before and during forking if necessary.
	   Note that the default configuration for snmp_log() is to send all logs to standard error. */
	strncpy(progname, basename(argv[0]), sizeof(progname));
	snmp_disable_log();
	if (sa_logfillog) {
		snmp_enable_filelog(sa_logfile, sa_appendlog);
	}
	if (sa_logstderr | sa_logstdout) {
#if defined LOG_PERROR
		/* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr, it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as the former is better 
		   formated. */
		if (!sa_logsyslog)
			snmp_enable_stderrlog();
#else				/* defined LOG_PERROR */
		snmp_enable_stderrlog();
#endif				/* defined LOG_PERROR */
	}
	if (sa_logsyslog) {
#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
		snmp_enable_syslog();
#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		snmp_enable_syslog_ident("sccpMIB", LOG_DAEMON);
#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
		/* Note that the way that snmp sets up the logger is not really the way we want it, so close the log and reopen it the way we want. */
		closelog();
#if defined LOG_PERROR
		openlog("sccpMIB", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0), MY_FACILITY(0));
#else				/* defined LOG_PERROR */
		openlog("sccpMIB", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
#endif				/* defined LOG_PERROR */
	}
	if (sa_logcallog) {
		snmp_enable_calllog();
	}
}
static void
sa_enter(int argc, char *argv[])
{
	if (sa_nomead) {
		pid_t pid;

		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent exits */
			exit(0);
		}
		setsid();	/* become a session leader */
		/* fork once more for SVR4 */
		if ((pid = fork()) < 0) {
			perror(argv[0]);
			exit(2);
		} else if (pid != 0) {
			/* parent responsible for writing pid file */
			if (sa_nomead || sa_pidfile[0] != '\0') {
				FILE *pidf;

				/* initialize default filename */
				if (sa_pidfile[0] == '\0')
					snprintf(sa_pidfile, sizeof(sa_pidfile), "/var/run/%s.pid", sa_program);
				if (sa_output > 1) {
					snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Writing daemon pid to file %s", sa_program, sa_pidfile);
				}
				if ((pidf = fopen(sa_pidfile, "w+"))) {
					fprintf(pidf, "%d", (int) pid);
					fflush(pidf);
					fclose(pidf);
				} else {
					snmp_log(MY_FACILITY(LOG_ERR), "%s: %m", sa_program);
					snmp_log(MY_FACILITY(LOG_ERR), "%s: Could not write pid to file %s", sa_program, sa_pidfile);
					sa_exit(2);
					/* no return */
				}
			}
			/* parent exits */
			exit(0);
		}
		/* child continues */
		/* release current directory */
		if (chdir("/") < 0) {
			perror(argv[0]);
			exit(2);
		}
		umask(0);	/* clear file creation mask */
		/* rearrange file streams */
		fclose(stdin);
	}
	/* continue as foreground or background */
	sa_init_logging(argc, argv);
	sa_sig_catch();
	snmp_log(MY_FACILITY(LOG_NOTICE), "%s: Startup complete.", sa_program);
}
static void
sa_mloop(int argc, char *argv[])
{
	if (sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as AgentX client\n", argv[0]);
		/* run as an AgentX client */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
	} else {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master agent\n", argv[0]);
		/* run as SNMP master */
		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
	}
	if (sa_alarms) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using application alarms\n", argv[0]);
		/* use application alarms */
		ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
	}
	/* initialize agent */
	init_agent("sccpMIB");
	/* initialize MIB */
	init_sccpMIB();
	/* initialize SNMP */
	init_snmp("sccpMIB");
	if (!sa_agentx) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: running as SNMP master\n", argv[0]);
#if !defined NETSNMP_DS_APPLICATION_ID
		init_master_agent(710, NULL, NULL);
#else
		init_master_agent();
#endif
	}
	for (;;) {
		int retval;

		/* to use select or poll you need to use the snmp_select_info() to obtain the fd of the agentx socket and add it to the fdset. */
		/* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */
#if 0
		if (snmp_select() == 0) {
			if (sa_alarms == 0)
				run_alarms();
		}
#endif
		retval = agent_check_and_process(1);	/* 0 == don't block */
		if (retval == 0) {
			/* alarm occurred, alarm conditions checked */
		} else if (retval == -1) {
			/* error (or signal) ocurred */
			if (sa_alm_signal) {
				sa_alm_action();
			}
			if (sa_pol_signal) {
				sa_pol_action();
			}
			if (sa_hup_signal) {
				sa_hup_action();
			}
			if (sa_int_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("sccpMIB");
				sa_int_action();	/* no return */
			}
			if (sa_trm_signal) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
				snmp_shutdown("sccpMIB");
				sa_trm_action();	/* no return */
			}
		} else if (retval > 0) {
			/* processed packets */
			if (sa_fclose) {
				/* close files after each request */
				if (sa_fd != 0) {
					int fd = sa_fd;

					sa_fd = 0;
					close(fd);
				}
			}
			sa_stats_refresh = 1;
			sa_request++;
		}
	}
	if (sa_debug)
		snmp_log(MY_FACILITY(LOG_DEBUG), "%s: shutting down\n", argv[0]);
	snmp_shutdown("sccpMIB");
}

int
main(int argc, char *argv[])
{
	for (;;) {
		int c, val, fd;
		char *cptr;
		struct passwd *pw;
		struct group *gr;
		struct stat st;

#if defined _GNU_SOURCE
		int option_index = 0;
                /* *INDENT-OFF* */
                static struct option long_options[] = {
                        {"log-addresses",	no_argument,		NULL, 'a'},
                        {"append",		no_argument,		NULL, 'A'},
                        {"config-file",		required_argument,	NULL, 'c'},
                        {"no-configs",		no_argument,		NULL, 'C'},
                        {"dump",		no_argument,		NULL, 'd'},
                        {"debug",		optional_argument,	NULL, 'D'},
                        {"debug-tokens",	optional_argument,	NULL, 'D'},
                        {"dont-fork",		no_argument,		NULL, 'f'},
                        {"gid",			required_argument,	NULL, 'g'},
                        {"groupid",		required_argument,	NULL, 'g'},
                        {"help",		no_argument,		NULL, 'h'},
                        {"?",			no_argument,		NULL, 'h'},
                        {"help-directives",	no_argument,		NULL, 'H'},
                        {"initialize",		required_argument,	NULL, 'I'},
                        {"init-modules",	required_argument,	NULL, 'I'},
                        {"keep-open",		no_argument,		NULL, 'k'},
                        {"log-file",		optional_argument,	NULL, 'l'},
                        {"logfile",		optional_argument,	NULL, 'l'},
                        {"Lf",			optional_argument,	NULL, 'l'},
                        {"LF",			required_argument,	NULL, 'l'},
                        {"log-stderr",		no_argument,		NULL, 'L'},
                        {"Le",			no_argument,		NULL, 'L'},
                        {"LE",			required_argument,	NULL, 'L'},
                        {"mibs",		required_argument,	NULL, 'm'},
                        {"master",		no_argument,		NULL, 'M'},
                        {"mibdirs",		required_argument,	NULL, 'M'},
                        {"nodaemon",		no_argument,		NULL, 'n'},
                        {"name",		required_argument,	NULL, 'n'},
                        {"dry-run",		no_argument,		NULL, 'N'},
                        {"log-stdout",		no_argument,		NULL, 'o'},
                        {"Lo",			no_argument,		NULL, 'o'},
                        {"LO",			required_argument,	NULL, 'o'},
                        {"port",		required_argument,	NULL, 'p'},
                        {"pidfile",		required_argument,	NULL, 'P'},
                        {"quiet",		no_argument,		NULL, 'q'},
                        {"quick",		no_argument,		NULL, 'q'},
                        {"noroot",		no_argument,		NULL, 'r'},
                        {"log-syslog",		no_argument,		NULL, 's'},
                        {"Ls",			no_argument,		NULL, 's'},
                        {"LS",			required_argument,	NULL, 's'},
                        {"syslog",		no_argument,		NULL, 's'},
                        {"sysctl-file",		required_argument,	NULL, 'S'},
                        {"agent-alarms",	no_argument,		NULL, 't'},
                        {"transport",		optional_argument,	NULL, 'T'},
                        {"uid",			required_argument,	NULL, 'u'},
                        {"userid",		required_argument,	NULL, 'u'},
                        {"dont-remove-pidfile",	no_argument,		NULL, 'U'},
                        {"leave-pidfile",	no_argument,		NULL, 'U'},
                        {"version",		no_argument,		NULL, 'v'},
                        {"verbose",		optional_argument,	NULL, 'V'},
                        {"agentx-socket",	required_argument,	NULL, 'x'},
                        {"agentx",		no_argument,		NULL, 'X'},
                        {"copying",		no_argument,		NULL, 'y'},
#if 0
                        {"directory",		required_argument,	NULL, 'd'},
                        {"basename",		required_argument,	NULL, 'b'},
                        {"outfile",		required_argument,	NULL, 'o'},
                        {"errfile",		required_argument,	NULL, 'e'},
#endif
                        { 0, }
                };
                /* *INDENT-ON* */

		c = getopt_long_only(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, ":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy");
#endif				/* defined _GNU_SOURCE */
		if (c == -1) {
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: done options processing\n", argv[0]);
			break;
		}
		switch (c) {
		case 0:
			goto bad_usage;
		case 'a':	/* -a, --log-addresses */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging addresses\n", argv[0]);
			sa_logaddr++;
			break;
		case 'A':	/* -A, --append */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will not truncate logfile\n", argv[0]);
#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
			ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
			sa_appendlog = 1;
			break;
		case 'c':	/* -c, --config-file CONFIGFILE */
			if (optarg == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using configuration file %s\n", argv[0], optarg);
			ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
			break;
		case 'C':	/* -C, --no-configs */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: not reading default config files\n", argv[0]);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
			break;
		case 'd':	/* -d, --dump */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting packet dump\n", argv[0]);
			sa_dump = 1;
			// snmp_set_dump_packet(sa_dump);
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
			break;
		case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing debug verbosity\n", argv[0]);
			if (optarg == NULL) {
				/* no option: must be -D, --debug */
				sa_debug++;
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging all tokens\n", argv[0]);
				if (sa_debug)
					debug_register_tokens("ALL");
			} else {
				cptr = optarg;
				if ((val = strtol(optarg, &cptr, 0)) < 0)
					goto bad_option;
				if (*cptr == '\0') {
					/* it is just a number, must be -D, --debug [LEVEL] */
					sa_debug = val;
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debug level is now %d\n", argv[0], sa_debug);
				} else {
					/* not a number, must be -D, --debug-tokens TOKENS */
					if (sa_debug)
						snmp_log(MY_FACILITY(LOG_DEBUG), "%s: debugging tokens %s\n", argv[0], optarg);
					debug_register_tokens(optarg);
				}
			}
			break;
		case 'f':	/* -f, --dont-fork */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing daemon mode\n", argv[0]);
			sa_nomead = 0;
			break;
		case 'u':	/* -u, --uid, --userid UID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* UID can be name or number */
			if ((pw = (*cptr == '\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as uid %s(%d)\n", argv[0], pw->pw_name, pw->pw_uid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
			break;
		case 'g':	/* -g, --gid, --groupdid GID */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0)
				goto bad_option;
			/* GID can be name or number */
			if ((gr = (*cptr == '\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
				goto bad_option;
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will run as gid %s(%d)\n", argv[0], gr->gr_name, gr->gr_gid);
			ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
			break;
		case 'h':	/* -h, --help, -?, --? */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing help message\n", argv[0]);
			sa_help(argc, argv);
			exit(0);
		case 'H':	/* -H, --help-directives */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing config directives\n", argv[0]);
			sa_help_directives(argc, argv);
			exit(0);
		case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will initialize modules: %s\n", argv[0], optarg);
			add_to_init_list(optarg);
			break;
		case 'k':	/* -k, --keep-open */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: keeping files open\n", argv[0]);
			sa_fclose = 0;
			break;
		case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
			if (optarg != NULL)
				strncpy(sa_logfile, optarg, sizeof(sa_logfile));
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will log to file %s\n", argv[0], sa_logfile);
			sa_logfillog = 1;
			break;
		case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
			/* Note that the recent NET-SNMP version of this option is far more complicated: -Le is the same as the old version of the option; -Lf LOGFILE is like the -l option; -Ls is
			   like the -s option; -Lo logs messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or O, logs priority p1 and above to X, or p1 thru p2 to X. */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to standard error\n", argv[0]);
			sa_logstderr = 1;
			break;
		case 'm':	/* -m, --mibs MIBS */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBS %s\n", argv[0], optarg);
			break;
		case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
			if (optarg) {
				/* -M, --mibdirs MIBDIRS */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using MIBDIRS %s\n", argv[0], optarg);
			} else {
				/* -M, --master */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting SNMP master\n", argv[0]);
				sa_agentx = 0;
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
			}
			break;
		case 'n':	/* -n, --nodaemon or -n, --name NAME */
			if (optarg) {
				/* -n, --name NAME */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using name %s\n", argv[0], optarg);
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
			} else {
				/* -n, --nodaemon */
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing deamon mode\n", argv[0]);
				sa_nomead = 0;
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, basename(argv[0]));
			}
			break;
		case 'N':	/* -N, --dry-run */
#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for dry-runs startup\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
			break;
#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -N option not supported\n", argv[0]);
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
		case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to stdout\n", argv[0]);
			sa_logstdout = 1;
			break;
		case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
			cptr = optarg;
			if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
				goto bad_option;
			if (*cptr == '\0') {
				char buf[4096];

				/* -p, --port PORTNUM */
				if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
					snprintf(buf, sizeof(buf), "%s,%s", cptr, optarg);
				else
					strncpy(buf, optarg, sizeof(buf));
				ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
				break;
			}
			/* fall through */
		case 'P':	/* -p, -P, --pidfile PIDFILE */
			if (optarg) {
				/* either it exists */
				if (stat(optarg, &st) == -1) {
					/* or we can create it */
					if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
						perror(argv[0]);
						goto bad_option;
					}
					close(fd);
				}
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting pid file to %s\n", argv[0], optarg);
				strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
			}
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using pidfile %s\n", argv[0], sa_pidfile);
			break;
		case 'q':	/* -q, --quiet, --quick */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: suppressing normal output\n", argv[0]);
			sa_debug = 0;
			sa_output = 0;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			// snmp_set_quick_print();
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
			break;
		case 'r':	/* -r, --noroot */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting for non-root access\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
			break;
		case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: logging to system logs\n", argv[0]);
			sa_logsyslog = 1;
			break;
		case 'S':	/* -S, -sysctl-file FILENAME */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: using %s for backing\n", argv[0], optarg);
			strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
			break;
		case 't':	/* -t, --agent-alarms */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting agent alarms\n", argv[0]);
			sa_alarms = 0;
			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
			break;
		case 'T':	/* -T, --transport [TRANSPORT] */
			if (optarg == NULL)
				goto udp_transport;
			if (!strcasecmp("TCP", optarg)) {
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to TCP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val |= SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else if (!strcasecmp("UDP", optarg)) {
			      udp_transport:
				if (sa_debug)
					snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting default transport to UDP\n", argv[0]);
				val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
				val &= ~SNMP_FLAGS_STREAM_SOCKET;
				ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
			} else
				goto bad_option;
			break;
		case 'U':
#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: will leave pidfile after shutdown\n", argv[0]);
			ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
#else
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: -U option not supported\n");
			goto bad_option;
#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
			break;
		case 'v':	/* -v, --version */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing version message\n", argv[0]);
			sa_version(argc, argv);
			exit(0);
		case 'V':	/* -V, --verbose [LEVEL] */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: increasing output verbosity\n", argv[0]);
			if (optarg == NULL) {
				sa_output++;
			} else {
				if ((val = strtol(optarg, NULL, 0)) < 0)
					goto bad_option;
				sa_output = val;
			}
			if (sa_output > 1)
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
			else
				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
			break;
		case 'x':	/* -x, --agentx-socket SOCKET */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX socket to %s\n", argv[0], optarg);
			ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
			// ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
			break;
		case 'X':	/* -X, --agentx */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: setting AgentX sub-agent\n", argv[0]);
			sa_agentx = 1;
			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
			break;
		case 'y':	/* -y, --copying */
			if (sa_debug)
				snmp_log(MY_FACILITY(LOG_DEBUG), "%s: printing copying message\n", argv[0]);
			sa_copying(argc, argv);
			exit(0);
		case '?':
		case ':':
		default:
		      bad_option:
			optind--;
			goto bad_nonopt;
		      bad_nonopt:
			if (sa_output || sa_debug) {
				if (optind < argc) {
					fprintf(stderr, "%s: syntax error near '", argv[0]);
					while (optind < argc)
						fprintf(stderr, "%s ", argv[optind++]);
					fprintf(stderr, "'\n");
				} else {
					fprintf(stderr, "%s: missing option or argument", argv[0]);
					fprintf(stderr, "\n");
				}
				fflush(stderr);
			      bad_usage:
				sa_usage(argc, argv);
			}
			exit(2);
		}
	}
	if (optind < argc) {
		if (sa_debug)
			snmp_log(MY_FACILITY(LOG_DEBUG), "%s: excess non-option arguments\n", argv[0]);
		goto bad_nonopt;
	}
	sa_enter(argc, argv);	/* daemonize if necessary */
	sa_mloop(argc, argv);	/* execute main loop */
	exit(0);
}
#endif				/* !defined MODULE */
#endif				/* defined MASTER */
