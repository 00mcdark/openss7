/*****************************************************************************

 @(#) $RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.7 $) $Date: 2009-01-03 10:51:05 $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2009-01-03 10:51:05 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: sccpMIB.c,v $
 Revision 0.9.2.7  2009-01-03 10:51:05  brian
 - updated agent

 Revision 0.9.2.6  2009-01-02 15:46:42  brian
 - corrections

 Revision 0.9.2.5  2009-01-02 15:04:14  brian
 - updated agents

 Revision 0.9.2.4  2008-12-31 16:04:46  brian
 - updated mibs

 Revision 0.9.2.3  2008-12-27 15:29:47  brian
 - split MTP and MTP OM mib

 Revision 0.9.2.2  2008-12-24 13:08:25  brian
 - building ss7confd

 *****************************************************************************/

#ident "@(#) $RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.7 $) $Date: 2009-01-03 10:51:05 $"

static char const ident[] = "$RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.7 $) $Date: 2009-01-03 10:51:05 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ss7MIB.h"
#include "x400pMIB.h"
#include "mtpMIB.h"
#include "mtpOmMIB.h"
#include "sccpMIB.h"
#include "sccpOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int sccpMIB_refresh = 1;
volatile int sccpNetworkEntityTable_refresh = 1;
volatile int sccpSapNameTable_refresh = 1;
volatile int sccpAccessPointTable_refresh = 1;
volatile int sccpLinkageTable_refresh = 1;
volatile int sccpSclcTable_refresh = 1;
volatile int sccpScocTable_refresh = 1;
volatile int sccpScrcTable_refresh = 1;
volatile int sccpEntitySetTable_refresh = 1;
volatile int sccpEntitySetSapTable_refresh = 1;
volatile int sccpConcernedAreaTable_refresh = 1;
volatile int sccpRemoteSCCPTable_refresh = 1;
volatile int sccpGtConversionRuleTable_refresh = 1;
volatile int sccpAddressInfoTable_refresh = 1;
volatile int sccpGtTranslatorTable_refresh = 1;
volatile int sccpGtRuleTable_refresh = 1;
volatile int sccpSrvtTable_refresh = 1;

/*
 * sccpMIB_variables_oid: object identifier for sccpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid sccpMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2 };
oid sccpNetworkEntityTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 1, 1, 1 };
oid sccpSapNameTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 2, 1, 1 };
oid sccpAccessPointTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 3, 1, 1 };
oid sccpLinkageTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 4, 1, 1 };
oid sccpSclcTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 5, 1, 1 };
oid sccpScocTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 6, 1, 1 };
oid sccpScrcTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 7, 1, 1 };
oid sccpEntitySetTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 8, 1, 1 };
oid sccpEntitySetSapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 9, 1, 1 };
oid sccpConcernedAreaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 10, 1, 1 };
oid sccpRemoteSCCPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 11, 1, 1 };
oid sccpGtConversionRuleTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 12, 1, 1 };
oid sccpAddressInfoTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 13, 1, 1 };
oid sccpGtTranslatorTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 14, 1, 1 };
oid sccpGtRuleTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 15, 1, 1 };
oid sccpSrvtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 16, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid sccpRouteTestResult_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 0 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid failureType_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };
oid traceSent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };
oid pointCodeList_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };
oid routePriorityList_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };
oid copyData_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };
oid congestionLevel_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };
oid globalTitle_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 3 };

/*
 * Other oids defined in this MIB.
 */
oid sccpLoadSharingRoundRobin_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 4 };
oid sccpLoadSharingSlsSplitting_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 4 };
oid sccpMIBCompliance_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 1 };
oid sccpNetworkEntityGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpSapNameGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpAccessPointGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpRemoteSAPGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpAvailableAfterSpRestartPackage_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpLinkageGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpSclcGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpScocGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpScrcGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpEntitySetGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpConcernedAreaGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpRemoteSCCPGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpGtTranslatorGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpSrvtGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpLocalSccpLinkagePackage_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpCongestionPackage_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpAddressInfoConversionRulePackage_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
oid sccpCommonLanguageNameGroup_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 2, 2 };
static const oid zeroDotZero_oid[2] = { 0, 0 };

/*
 * variable7 sccpMIB_variables: tree for sccpMIB
 * This variable defines function callbacks and type return information for the sccpMIB mib section
 */
struct variable7 sccpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   SCCPNETWORKENTITYALARMSTATUS  (4 % 256)
	{SCCPNETWORKENTITYALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   SCCPSYSTEMTYPES       (8 % 256)
	{SCCPSYSTEMTYPES, ASN_BIT_STR, RONLY, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 6}},
#define   SCCPVERSION           (9 % 256)
	{SCCPVERSION, ASN_OBJECT_ID, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 7}},
#define   SCCPLUDTANDLUDTSSUPPORTED  (10 % 256)
	{SCCPLUDTANDLUDTSSUPPORTED, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 8}},
#define   SCCPCOORDCHANGETIMER  (11 % 256)
	{SCCPCOORDCHANGETIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 9}},
#define   SCCPIGNORESSTTIMER    (12 % 256)
	{SCCPIGNORESSTTIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 10}},
#define   SCCPMAXSTATINFOTIMER  (13 % 256)
	{SCCPMAXSTATINFOTIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 11}},
#define   SCCPNETWORKENTITYNAME  (14 % 256)
	{SCCPNETWORKENTITYNAME, ASN_OCTET_STR, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 12}},
#define   SCCPROWSTATUS         (15 % 256)
	{SCCPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 13}},
#define   SCCPSAPNAMEROWSTATUS  (20 % 256)
	{SCCPSAPNAMEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSapNameTable, 6, {1, 1, 2, 1, 1, 1}},
#define   SCCPACCESSPOINTALARMSTATUS  (25 % 256)
	{SCCPACCESSPOINTALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 2}},
#define   SCCPSAP2ADDRESS       (26 % 256)
	{SCCPSAP2ADDRESS, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 3}},
#define   SCCPUSERENTITYNAMES   (27 % 256)
	{SCCPUSERENTITYNAMES, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 4}},
#define   SCCPPROVIDERENTITYNAMES  (28 % 256)
	{SCCPPROVIDERENTITYNAMES, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 5}},
#define   SCCPAVAILABILITYSTATUS  (29 % 256)
	{SCCPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 6}},
#define   SCCPCONCERNEDAREAPOINTER  (30 % 256)
	{SCCPCONCERNEDAREAPOINTER, ASN_UNSIGNED, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 7}},
#define   SCCPLINKAGEPOINTER    (31 % 256)
	{SCCPLINKAGEPOINTER, ASN_UNSIGNED, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 8}},
#define   SCCPSSAVAILABLEAFTERSPRESTART  (32 % 256)
	{SCCPSSAVAILABLEAFTERSPRESTART, ASN_INTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 9}},
#define   SCCPACCESSPOINTNAME   (33 % 256)
	{SCCPACCESSPOINTNAME, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 10}},
#define   SCCPACCESSPOINTROWSTATUS  (34 % 256)
	{SCCPACCESSPOINTROWSTATUS, ASN_INTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 11}},
#define   SCCPOPERATIONALPROTOCOLS  (39 % 256)
	{SCCPOPERATIONALPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 2}},
#define   SCCPSNSAP             (40 % 256)
	{SCCPSNSAP, ASN_OBJECT_ID, RONLY, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 3}},
#define   SCCPATTACKTIMERVALUE  (41 % 256)
	{SCCPATTACKTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 4}},
#define   SCCPDECAYTIMERVALUE   (42 % 256)
	{SCCPDECAYTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 5}},
#define   SCCPNROFRESTRICTIONLEVELS  (43 % 256)
	{SCCPNROFRESTRICTIONLEVELS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 6}},
#define   SCCPNROFSUBLEVELS     (44 % 256)
	{SCCPNROFSUBLEVELS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 7}},
#define   SCCPCLS               (45 % 256)
	{SCCPCLS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 8}},
#define   SCCPCONGESTIONTIMERVALUE  (46 % 256)
	{SCCPCONGESTIONTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 9}},
#define   SCCPP                 (47 % 256)
	{SCCPP, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 10}},
#define   SCCPIMPORTANCELEVELCR  (48 % 256)
	{SCCPIMPORTANCELEVELCR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 11}},
#define   SCCPIMPORTANCELEVELCC  (49 % 256)
	{SCCPIMPORTANCELEVELCC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 12}},
#define   SCCPIMPORTANCELEVELCREF  (50 % 256)
	{SCCPIMPORTANCELEVELCREF, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 13}},
#define   SCCPIMPORTANCELEVELDT1  (51 % 256)
	{SCCPIMPORTANCELEVELDT1, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 14}},
#define   SCCPIMPORTANCELEVELDT2  (52 % 256)
	{SCCPIMPORTANCELEVELDT2, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 15}},
#define   SCCPIMPORTANCELEVELAK  (53 % 256)
	{SCCPIMPORTANCELEVELAK, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 16}},
#define   SCCPIMPORTANCELEVELIT  (54 % 256)
	{SCCPIMPORTANCELEVELIT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 17}},
#define   SCCPIMPORTANCELEVELED  (55 % 256)
	{SCCPIMPORTANCELEVELED, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 18}},
#define   SCCPIMPORTANCELEVELEA  (56 % 256)
	{SCCPIMPORTANCELEVELEA, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 19}},
#define   SCCPIMPORTANCELEVELRSR  (57 % 256)
	{SCCPIMPORTANCELEVELRSR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 20}},
#define   SCCPIMPORTANCELEVELRSC  (58 % 256)
	{SCCPIMPORTANCELEVELRSC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 21}},
#define   SCCPIMPORTANCELEVELERR  (59 % 256)
	{SCCPIMPORTANCELEVELERR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 22}},
#define   SCCPIMPORTANCELEVELRLC  (60 % 256)
	{SCCPIMPORTANCELEVELRLC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 23}},
#define   SCCPIMPORTANCELEVELRLSD  (61 % 256)
	{SCCPIMPORTANCELEVELRLSD, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 24}},
#define   SCCPIMPORTANCELEVELUDT  (62 % 256)
	{SCCPIMPORTANCELEVELUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 25}},
#define   SCCPIMPORTANCELEVELUDTS  (63 % 256)
	{SCCPIMPORTANCELEVELUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 26}},
#define   SCCPIMPORTANCELEVELXUDT  (64 % 256)
	{SCCPIMPORTANCELEVELXUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 27}},
#define   SCCPIMPORTANCELEVELXUDTS  (65 % 256)
	{SCCPIMPORTANCELEVELXUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 28}},
#define   SCCPIMPORTANCELEVELLUDT  (66 % 256)
	{SCCPIMPORTANCELEVELLUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 29}},
#define   SCCPIMPORTANCELEVELLUDTS  (67 % 256)
	{SCCPIMPORTANCELEVELLUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 30}},
#define   SCCPRLM               (68 % 256)
	{SCCPRLM, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 31}},
#define   SCCPRSLM              (69 % 256)
	{SCCPRSLM, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 32}},
#define   SCCPLINKAGECONCERNEDAREAPOINTER  (70 % 256)
	{SCCPLINKAGECONCERNEDAREAPOINTER, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 33}},
#define   SCCPLOWERLIMITFORSEGMENTATION  (71 % 256)
	{SCCPLOWERLIMITFORSEGMENTATION, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 34}},
#define   SCCPUPPERLIMITFORSEGMENTATION  (72 % 256)
	{SCCPUPPERLIMITFORSEGMENTATION, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 35}},
#define   SCCPLINKAGENAME       (73 % 256)
	{SCCPLINKAGENAME, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 36}},
#define   SCCPLINKAGEROWSTATUS  (74 % 256)
	{SCCPLINKAGEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 37}},
#define   SCCPSCLCALARMSTATUS   (78 % 256)
	{SCCPSCLCALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 1}},
#define   SCCPSCLCOPERATIONALSTATE  (80 % 256)
	{SCCPSCLCOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 3}},
#define   SCCPTOTALREMOTESAPS   (81 % 256)
	{SCCPTOTALREMOTESAPS, ASN_INTEGER, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 4}},
#define   SCCPSCLCADMINISTRATIVESTATE  (82 % 256)
	{SCCPSCLCADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 5}},
#define   SCCPSCLCSUPPORTEDPROTOCOLS  (83 % 256)
	{SCCPSCLCSUPPORTEDPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 6}},
#define   SCCPSCLCOPERATIONALSYSTEMTYPE  (84 % 256)
	{SCCPSCLCOPERATIONALSYSTEMTYPE, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 7}},
#define   SCCPINITIALVALUEREASSTIMER  (85 % 256)
	{SCCPINITIALVALUEREASSTIMER, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 8}},
#define   SCCPSCLCNAME          (86 % 256)
	{SCCPSCLCNAME, ASN_OCTET_STR, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 9}},
#define   SCCPSCLCROWSTATUS     (87 % 256)
	{SCCPSCLCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 10}},
#define   SCCPCOPROTOCOLMACHINEID  (91 % 256)
	{SCCPCOPROTOCOLMACHINEID, ASN_OCTET_STR, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 1}},
#define   SCCPSCOCOPERATIONALSTATE  (92 % 256)
	{SCCPSCOCOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SCCPSCOCADMINISTRATIVESTATE  (93 % 256)
	{SCCPSCOCADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 3}},
#define   SCCPSCOCOPERATIONALSYSTEMTYPE  (94 % 256)
	{SCCPSCOCOPERATIONALSYSTEMTYPE, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 4}},
#define   SCCPSCOCSUPPORTEDPROTOCOLS  (95 % 256)
	{SCCPSCOCSUPPORTEDPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 5}},
#define   SCCPSCOCNAME          (96 % 256)
	{SCCPSCOCNAME, ASN_OCTET_STR, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 6}},
#define   SCCPSCOCROWSTATUS     (97 % 256)
	{SCCPSCOCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 7}},
#define   SCCPSCRCID            (101 % 256)
	{SCCPSCRCID, ASN_OCTET_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 1}},
#define   SCCPSCRCALARMSTATUS   (102 % 256)
	{SCCPSCRCALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 2}},
#define   SCCPSCRCNAME          (103 % 256)
	{SCCPSCRCNAME, ASN_OCTET_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 3}},
#define   SCCPSCRCROWSTATUS     (104 % 256)
	{SCCPSCRCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 4}},
#define   SCCPSHARINGMODE       (109 % 256)
	{SCCPSHARINGMODE, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 2}},
#define   SCCPLOADSHARINGALGPOINTER  (110 % 256)
	{SCCPLOADSHARINGALGPOINTER, ASN_OBJECT_ID, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 3}},
#define   SCCPENTITYSETNAME     (111 % 256)
	{SCCPENTITYSETNAME, ASN_OCTET_STR, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 4}},
#define   SCCPENTITYSETTYPE     (112 % 256)
	{SCCPENTITYSETTYPE, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 5}},
#define   SCCPENTITYSETSSN      (113 % 256)
	{SCCPENTITYSETSSN, ASN_OCTET_STR, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 6}},
#define   SCCPENTITYSETROWSTATUS  (114 % 256)
	{SCCPENTITYSETROWSTATUS, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 7}},
#define   SCCPENTITYSETSAPTYPE  (120 % 256)
	{SCCPENTITYSETSAPTYPE, ASN_INTEGER, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 2}},
#define   SCCPENTITYSETSAPPOINTER  (121 % 256)
	{SCCPENTITYSETSAPPOINTER, ASN_OBJECT_ID, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 3}},
#define   SCCPENTITYSETSAPROWSTATUS  (122 % 256)
	{SCCPENTITYSETSAPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 4}},
#define   SCCPREMOTESCCPMTPACCESSPOINT  (133 % 256)
	{SCCPREMOTESCCPMTPACCESSPOINT, ASN_OBJECT_ID, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 2}},
#define   SCCPREMOTESCCPNAME    (134 % 256)
	{SCCPREMOTESCCPNAME, ASN_OCTET_STR, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 3}},
#define   SCCPREMOTESCCPROWSTATUS  (135 % 256)
	{SCCPREMOTESCCPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 4}},
#define   SCCPGTNEWENCODINGSCHEME  (140 % 256)
	{SCCPGTNEWENCODINGSCHEME, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 2}},
#define   SCCPGTNEWNATUREOFADDRESS  (141 % 256)
	{SCCPGTNEWNATUREOFADDRESS, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 3}},
#define   SCCPGTNEWNUMBERINGPLAN  (142 % 256)
	{SCCPGTNEWNUMBERINGPLAN, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 4}},
#define   SCCPGTNEWTRANSLATIONTYPE  (143 % 256)
	{SCCPGTNEWTRANSLATIONTYPE, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 5}},
#define   SCCPGTCONVERSIONRULENAME  (144 % 256)
	{SCCPGTCONVERSIONRULENAME, ASN_OCTET_STR, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 6}},
#define   SCCPGTCONVERSIONRULEROWSTATUS  (145 % 256)
	{SCCPGTCONVERSIONRULEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 7}},
#define   SCCPADDRESSINFOOPERATION  (151 % 256)
	{SCCPADDRESSINFOOPERATION, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 2}},
#define   SCCPADDRESSINFOADDRESSELEMENT  (152 % 256)
	{SCCPADDRESSINFOADDRESSELEMENT, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 3}},
#define   SCCPADDRESSINFONROFADDRESSELEMENTS  (153 % 256)
	{SCCPADDRESSINFONROFADDRESSELEMENTS, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 4}},
#define   SCCPADDRESSINFOROWSTATUS  (154 % 256)
	{SCCPADDRESSINFOROWSTATUS, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 5}},
#define   SCCPGTINDICATOR       (159 % 256)
	{SCCPGTINDICATOR, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 2}},
#define   SCCPGTNATUREOFADDRESS  (160 % 256)
	{SCCPGTNATUREOFADDRESS, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SCCPGTNUMBERINGPLAN   (161 % 256)
	{SCCPGTNUMBERINGPLAN, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SCCPGTTRANSLATIONTYPE  (162 % 256)
	{SCCPGTTRANSLATIONTYPE, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 5}},
#define   SCCPGTTRANSLATORADMINISTRATIVESTATE  (163 % 256)
	{SCCPGTTRANSLATORADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 6}},
#define   SCCPGTTRANSLATORNAME  (164 % 256)
	{SCCPGTTRANSLATORNAME, ASN_OCTET_STR, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 7}},
#define   SCCPGTTRANSLATORROWSTATUS  (165 % 256)
	{SCCPGTTRANSLATORROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 8}},
#define   SCCPGTRULEADMINISTRATIVESTATE  (171 % 256)
	{SCCPGTRULEADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SCCPGTADDRESSINFORMATION  (172 % 256)
	{SCCPGTADDRESSINFORMATION, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SCCPGTCONVRULEPOINTER  (173 % 256)
	{SCCPGTCONVRULEPOINTER, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SCCPGTENCODINGSCHEME  (174 % 256)
	{SCCPGTENCODINGSCHEME, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SCCPENTITYSETPOINTER  (175 % 256)
	{SCCPENTITYSETPOINTER, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SCCPGTRULENAME        (176 % 256)
	{SCCPGTRULENAME, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SCCPGTRULEROWSTATUS   (177 % 256)
	{SCCPGTRULEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SCCPDSRVT             (182 % 256)
	{SCCPDSRVT, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SCCPNSRVT             (183 % 256)
	{SCCPNSRVT, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SCCPSRVTNAME          (184 % 256)
	{SCCPSRVTNAME, ASN_OCTET_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SCCPADMINISTRATIVESTATE  (185 % 256)
	{SCCPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SCCPOPERATIONALSTATE  (186 % 256)
	{SCCPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SCCPPROCEDURALSTATUS  (187 % 256)
	{SCCPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SCCPTRACEREQUESTED    (188 % 256)
	{SCCPTRACEREQUESTED, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SCCPTHRESHOLD         (189 % 256)
	{SCCPTHRESHOLD, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SCCPMTPBACKWARDROUTINGREQUESTED  (190 % 256)
	{SCCPMTPBACKWARDROUTINGREQUESTED, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SCCPORIGINALGT        (191 % 256)
	{SCCPORIGINALGT, ASN_OCTET_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 11}},
#define   SCCPINFOREQUEST       (192 % 256)
	{SCCPINFOREQUEST, ASN_BIT_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 12}},
#define   SCCPRETURNUNKNOWNPARAMS  (193 % 256)
	{SCCPRETURNUNKNOWNPARAMS, ASN_BIT_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 13}},
#define   SCCPROUTETESTROWSTATUS  (194 % 256)
	{SCCPROUTETESTROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 14}},
};

/* (L = length of the oidsuffix) */
struct sccpMIB_data *sccpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *sccpNetworkEntityTableStorage = NULL;
struct header_complex_index *sccpSapNameTableStorage = NULL;
struct header_complex_index *sccpAccessPointTableStorage = NULL;
struct header_complex_index *sccpLinkageTableStorage = NULL;
struct header_complex_index *sccpSclcTableStorage = NULL;
struct header_complex_index *sccpScocTableStorage = NULL;
struct header_complex_index *sccpScrcTableStorage = NULL;
struct header_complex_index *sccpEntitySetTableStorage = NULL;
struct header_complex_index *sccpEntitySetSapTableStorage = NULL;
struct header_complex_index *sccpConcernedAreaTableStorage = NULL;
struct header_complex_index *sccpRemoteSCCPTableStorage = NULL;
struct header_complex_index *sccpGtConversionRuleTableStorage = NULL;
struct header_complex_index *sccpAddressInfoTableStorage = NULL;
struct header_complex_index *sccpGtTranslatorTableStorage = NULL;
struct header_complex_index *sccpGtRuleTableStorage = NULL;
struct header_complex_index *sccpSrvtTableStorage = NULL;

/*
 * init_sccpMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_sccpMIB(void)
{
	DEBUGMSGTL(("sccpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("sccpMIB", sccpMIB_variables, variable7, sccpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_sccpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("sccpMIB", parse_sccpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpNetworkEntityTable", parse_sccpNetworkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSapNameTable", parse_sccpSapNameTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpAccessPointTable", parse_sccpAccessPointTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpLinkageTable", parse_sccpLinkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSclcTable", parse_sccpSclcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpScocTable", parse_sccpScocTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpScrcTable", parse_sccpScrcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpEntitySetTable", parse_sccpEntitySetTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpEntitySetSapTable", parse_sccpEntitySetSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpConcernedAreaTable", parse_sccpConcernedAreaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpRemoteSCCPTable", parse_sccpRemoteSCCPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtConversionRuleTable", parse_sccpGtConversionRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpAddressInfoTable", parse_sccpAddressInfoTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtTranslatorTable", parse_sccpGtTranslatorTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtRuleTable", parse_sccpGtRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSrvtTable", parse_sccpSrvtTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpNetworkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSapNameTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpAccessPointTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpLinkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSclcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpScocTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpScrcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpEntitySetTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpEntitySetSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpConcernedAreaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpRemoteSCCPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtConversionRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpAddressInfoTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtTranslatorTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSrvtTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

/*
 * deinit_sccpMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_sccpMIB(void)
{
	DEBUGMSGTL(("sccpMIB", "deinitializating...  "));
	unregister_mib(sccpMIB_variables_oid, sizeof(sccpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("sccpMIB");
	snmpd_unregister_config_handler("sccpNetworkEntityTable");
	snmpd_unregister_config_handler("sccpSapNameTable");
	snmpd_unregister_config_handler("sccpAccessPointTable");
	snmpd_unregister_config_handler("sccpLinkageTable");
	snmpd_unregister_config_handler("sccpSclcTable");
	snmpd_unregister_config_handler("sccpScocTable");
	snmpd_unregister_config_handler("sccpScrcTable");
	snmpd_unregister_config_handler("sccpEntitySetTable");
	snmpd_unregister_config_handler("sccpEntitySetSapTable");
	snmpd_unregister_config_handler("sccpConcernedAreaTable");
	snmpd_unregister_config_handler("sccpRemoteSCCPTable");
	snmpd_unregister_config_handler("sccpGtConversionRuleTable");
	snmpd_unregister_config_handler("sccpAddressInfoTable");
	snmpd_unregister_config_handler("sccpGtTranslatorTable");
	snmpd_unregister_config_handler("sccpGtRuleTable");
	snmpd_unregister_config_handler("sccpSrvtTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

int
term_sccpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_sccpMIB();
	return 0;
}

/**
 * @fn struct sccpMIB_data *sccpMIB_create(void)
 * @brief create a fresh data structure representing scalars in sccpMIB.
 * Creates a new sccpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in sccpMIB.
 */
struct sccpMIB_data *
sccpMIB_create(void)
{
	struct sccpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(sccpMIB_data);

	DEBUGMSGTL(("sccpMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int sccpMIB_destroy(struct sccpMIB_data **thedata)
 * @brief delete a scalars structure from sccpMIB.
 * @param thedata pointer to the data structure in sccpMIB.
 * Frees scalars that were previously removed from sccpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpMIB_destroy(struct sccpMIB_data **thedata)
{
	struct sccpMIB_data *StorageDel;

	DEBUGMSGTL(("sccpMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpMIB_add(struct sccpMIB_data *thedata)
 * @param thedata the structure representing sccpMIB scalars.
 * @brief adds node to the sccpMIB scalar data set.
 * Adds a scalar structure to the sccpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
sccpMIB_add(struct sccpMIB_data *thedata)
{
	DEBUGMSGTL(("sccpMIB", "adding data...  "));
	sccpMIBStorage = thedata;
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpMIB entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_sccpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpMIB_data *StorageTmp = sccpMIB_create();

	DEBUGMSGTL(("sccpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	sccpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

/*
 * store_sccpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_sccpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpMIB_data *StorageTmp;

	DEBUGMSGTL(("sccpMIB", "storing data...  "));
	refresh_sccpMIB();
	if ((StorageTmp = sccpMIBStorage) == NULL) {
		DEBUGMSGTL(("sccpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "sccpMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_sccpMIB(void)
 * @brief refresh the scalar values of sccpMIB.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_sccpMIB(void)
{
	if (sccpMIBStorage == NULL) {
		struct sccpMIB_data *StorageNew;

		if ((StorageNew = sccpMIB_create()) == NULL)
			return;
		sccpMIBStorage = StorageNew;
		sccpMIB_refresh = 1;
	}
	if (sccpMIB_refresh == 0)
		return;
	sccpMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
* @fn u_char * var_sccpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
* @param vp a pointer to the entry in the variables table for the requested variable.
* @param name the object identifier for which to find.
* @param length the length of the object identifier.
* @param exact whether the name is exact.
* @param var_len a pointer to the length of the representation of the object.
* @param write_method a pointer to a write method for the object.
* @brief locate variables in sccpMIB.
* This function returns a pointer to a memory area that is static across the request that contains
* the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
* GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
* telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
* overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
* writing.  Write-only objects can be effected in this way.
*/
u_char *
var_sccpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_sccpMIB();
	if ((StorageTmp = sccpMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn struct sccpNetworkEntityTable_data *sccpNetworkEntityTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpNetworkEntityTable table.
 * Creates a new sccpNetworkEntityTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpNetworkEntityTable_data *
sccpNetworkEntityTable_create(void)
{
	struct sccpNetworkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpNetworkEntityTable_data);

	DEBUGMSGTL(("sccpNetworkEntityTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpNetworkEntityTable_data *sccpNetworkEntityTable_duplicate(struct sccpNetworkEntityTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpNetworkEntityTable_data *
sccpNetworkEntityTable_duplicate(struct sccpNetworkEntityTable_data *thedata)
{
	struct sccpNetworkEntityTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpNetworkEntityTable_data);

	DEBUGMSGTL(("sccpNetworkEntityTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpNetworkEntityTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpNetworkEntityTable_destroy(struct sccpNetworkEntityTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpNetworkEntityTable_destroy(struct sccpNetworkEntityTable_data **thedata)
{
	struct sccpNetworkEntityTable_data *StorageDel;

	DEBUGMSGTL(("sccpNetworkEntityTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpNetworkEntityAlarmStatus);
		StorageDel->sccpNetworkEntityAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpLocalSapNames);
		StorageDel->sccpLocalSapNamesLen = 0;
		SNMP_FREE(StorageDel->sccpNetworkEntityTitles);
		StorageDel->sccpNetworkEntityTitlesLen = 0;
		SNMP_FREE(StorageDel->sccpSystemTypes);
		StorageDel->sccpSystemTypesLen = 0;
		SNMP_FREE(StorageDel->sccpVersion);
		StorageDel->sccpVersionLen = 0;
		SNMP_FREE(StorageDel->sccpNetworkEntityName);
		StorageDel->sccpNetworkEntityNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpNetworkEntityTable_add(struct sccpNetworkEntityTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpNetworkEntityTable table data set.
 * Adds a table row structure to the sccpNetworkEntityTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpNetworkEntityTable_add(struct sccpNetworkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpNetworkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpNetworkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpNetworkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpNetworkEntityTable_del(struct sccpNetworkEntityTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpNetworkEntityTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpNetworkEntityTable_del(struct sccpNetworkEntityTable_data *thedata)
{
	struct sccpNetworkEntityTable_data *StorageDel;

	DEBUGMSGTL(("sccpNetworkEntityTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpNetworkEntityTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpNetworkEntityTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpNetworkEntityTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpNetworkEntityTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpNetworkEntityTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpNetworkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpNetworkEntityTable_data *StorageTmp = sccpNetworkEntityTable_create();

	DEBUGMSGTL(("sccpNetworkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpNetworkEntityAlarmStatus, &StorageTmp->sccpNetworkEntityAlarmStatusLen);
	if (StorageTmp->sccpNetworkEntityAlarmStatus == NULL) {
		config_perror("invalid specification for sccpNetworkEntityAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpCommunicationsEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLocalSapNames, &StorageTmp->sccpLocalSapNamesLen);
	if (StorageTmp->sccpLocalSapNames == NULL) {
		config_perror("invalid specification for sccpLocalSapNames");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpNetworkEntityTitles, &StorageTmp->sccpNetworkEntityTitlesLen);
	if (StorageTmp->sccpNetworkEntityTitles == NULL) {
		config_perror("invalid specification for sccpNetworkEntityTitles");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSystemTypes, &StorageTmp->sccpSystemTypesLen);
	if (StorageTmp->sccpSystemTypes == NULL) {
		config_perror("invalid specification for sccpSystemTypes");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpVersion, &StorageTmp->sccpVersionLen);
	if (StorageTmp->sccpVersion == NULL) {
		config_perror("invalid specification for sccpVersion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLUDTandLUDTSSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCoordChangeTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpIgnoreSSTTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpMaxStatInfoTimer, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpNetworkEntityName, &StorageTmp->sccpNetworkEntityNameLen);
	if (StorageTmp->sccpNetworkEntityName == NULL) {
		config_perror("invalid specification for sccpNetworkEntityName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRowStatus, &tmpsize);
	sccpNetworkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
}

/*
 * store_sccpNetworkEntityTable(): store configuraiton file for sccpNetworkEntityTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpNetworkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpNetworkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpNetworkEntityTable", "storing data...  "));
	refresh_sccpNetworkEntityTable();
	(void) tmpsize;
	for (hcindex = sccpNetworkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpNetworkEntityTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpNetworkEntityTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpNetworkEntityAlarmStatus, &StorageTmp->sccpNetworkEntityAlarmStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpCommunicationsEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLocalSapNames, &StorageTmp->sccpLocalSapNamesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpNetworkEntityTitles, &StorageTmp->sccpNetworkEntityTitlesLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSystemTypes, &StorageTmp->sccpSystemTypesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpVersion, &StorageTmp->sccpVersionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLUDTandLUDTSSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCoordChangeTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpIgnoreSSTTimer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpMaxStatInfoTimer, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpNetworkEntityName, &StorageTmp->sccpNetworkEntityNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpSapNameTable_data *sccpSapNameTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpSapNameTable table.
 * Creates a new sccpSapNameTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpSapNameTable_data *
sccpSapNameTable_create(void)
{
	struct sccpSapNameTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSapNameTable_data);

	DEBUGMSGTL(("sccpSapNameTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpSapNameRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpSapNameTable_data *sccpSapNameTable_duplicate(struct sccpSapNameTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpSapNameTable_data *
sccpSapNameTable_duplicate(struct sccpSapNameTable_data *thedata)
{
	struct sccpSapNameTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSapNameTable_data);

	DEBUGMSGTL(("sccpSapNameTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpSapNameTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpSapNameTable_destroy(struct sccpSapNameTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpSapNameTable_destroy(struct sccpSapNameTable_data **thedata)
{
	struct sccpSapNameTable_data *StorageDel;

	DEBUGMSGTL(("sccpSapNameTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSapNameTable_add(struct sccpSapNameTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpSapNameTable table data set.
 * Adds a table row structure to the sccpSapNameTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpSapNameTable_add(struct sccpSapNameTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSapNameTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpSapId, sizeof(thedata->sccpSapId));
	header_complex_add_data(&sccpSapNameTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSapNameTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSapNameTable_del(struct sccpSapNameTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpSapNameTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpSapNameTable_del(struct sccpSapNameTable_data *thedata)
{
	struct sccpSapNameTable_data *StorageDel;

	DEBUGMSGTL(("sccpSapNameTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpSapNameTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpSapNameTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpSapNameTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpSapNameTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpSapNameTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpSapNameTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSapNameTable_data *StorageTmp = sccpSapNameTable_create();

	DEBUGMSGTL(("sccpSapNameTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpSapId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSapNameRowStatus, &tmpsize);
	sccpSapNameTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
}

/*
 * store_sccpSapNameTable(): store configuraiton file for sccpSapNameTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpSapNameTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSapNameTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSapNameTable", "storing data...  "));
	refresh_sccpSapNameTable();
	(void) tmpsize;
	for (hcindex = sccpSapNameTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSapNameTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpSapNameTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSapNameRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpAccessPointTable_data *sccpAccessPointTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpAccessPointTable table.
 * Creates a new sccpAccessPointTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpAccessPointTable_data *
sccpAccessPointTable_create(void)
{
	struct sccpAccessPointTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAccessPointTable_data);

	DEBUGMSGTL(("sccpAccessPointTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpSsAvailableAfterSpRestart = 2;
		StorageNew->sccpAccessPointRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpAccessPointTable_data *sccpAccessPointTable_duplicate(struct sccpAccessPointTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpAccessPointTable_data *
sccpAccessPointTable_duplicate(struct sccpAccessPointTable_data *thedata)
{
	struct sccpAccessPointTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAccessPointTable_data);

	DEBUGMSGTL(("sccpAccessPointTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpAccessPointTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpAccessPointTable_destroy(struct sccpAccessPointTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpAccessPointTable_destroy(struct sccpAccessPointTable_data **thedata)
{
	struct sccpAccessPointTable_data *StorageDel;

	DEBUGMSGTL(("sccpAccessPointTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpAccessPointAlarmStatus);
		StorageDel->sccpAccessPointAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpSap2Address);
		StorageDel->sccpSap2AddressLen = 0;
		SNMP_FREE(StorageDel->sccpUserEntityNames);
		StorageDel->sccpUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sccpProviderEntityNames);
		StorageDel->sccpProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->sccpAvailabilityStatus);
		StorageDel->sccpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->sccpAccessPointName);
		StorageDel->sccpAccessPointNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAccessPointTable_add(struct sccpAccessPointTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpAccessPointTable table data set.
 * Adds a table row structure to the sccpAccessPointTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpAccessPointTable_add(struct sccpAccessPointTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpAccessPointTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpSapId, sizeof(thedata->sccpSapId));
	header_complex_add_data(&sccpAccessPointTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpAccessPointTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAccessPointTable_del(struct sccpAccessPointTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpAccessPointTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpAccessPointTable_del(struct sccpAccessPointTable_data *thedata)
{
	struct sccpAccessPointTable_data *StorageDel;

	DEBUGMSGTL(("sccpAccessPointTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpAccessPointTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpAccessPointTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpAccessPointTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpAccessPointTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpAccessPointTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpAccessPointTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpAccessPointTable_data *StorageTmp = sccpAccessPointTable_create();

	DEBUGMSGTL(("sccpAccessPointTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpSapId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpAccessPointAlarmStatus, &StorageTmp->sccpAccessPointAlarmStatusLen);
	if (StorageTmp->sccpAccessPointAlarmStatus == NULL) {
		config_perror("invalid specification for sccpAccessPointAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSap2Address, &StorageTmp->sccpSap2AddressLen);
	if (StorageTmp->sccpSap2Address == NULL) {
		config_perror("invalid specification for sccpSap2Address");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpUserEntityNames, &StorageTmp->sccpUserEntityNamesLen);
	if (StorageTmp->sccpUserEntityNames == NULL) {
		config_perror("invalid specification for sccpUserEntityNames");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpProviderEntityNames, &StorageTmp->sccpProviderEntityNamesLen);
	if (StorageTmp->sccpProviderEntityNames == NULL) {
		config_perror("invalid specification for sccpProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpAvailabilityStatus, &StorageTmp->sccpAvailabilityStatusLen);
	if (StorageTmp->sccpAvailabilityStatus == NULL) {
		config_perror("invalid specification for sccpAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpConcernedAreaPointer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpLinkagePointer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSsAvailableAfterSpRestart, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpAccessPointName, &StorageTmp->sccpAccessPointNameLen);
	if (StorageTmp->sccpAccessPointName == NULL) {
		config_perror("invalid specification for sccpAccessPointName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAccessPointRowStatus, &tmpsize);
	sccpAccessPointTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
}

/*
 * store_sccpAccessPointTable(): store configuraiton file for sccpAccessPointTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpAccessPointTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpAccessPointTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpAccessPointTable", "storing data...  "));
	refresh_sccpAccessPointTable();
	(void) tmpsize;
	for (hcindex = sccpAccessPointTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpAccessPointTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpAccessPointTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpAccessPointAlarmStatus, &StorageTmp->sccpAccessPointAlarmStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSap2Address, &StorageTmp->sccpSap2AddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpUserEntityNames, &StorageTmp->sccpUserEntityNamesLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpProviderEntityNames, &StorageTmp->sccpProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpAvailabilityStatus, &StorageTmp->sccpAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpConcernedAreaPointer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpLinkagePointer, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSsAvailableAfterSpRestart, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpAccessPointName, &StorageTmp->sccpAccessPointNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAccessPointRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpLinkageTable_data *sccpLinkageTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpLinkageTable table.
 * Creates a new sccpLinkageTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpLinkageTable_data *
sccpLinkageTable_create(void)
{
	struct sccpLinkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpLinkageTable_data);

	DEBUGMSGTL(("sccpLinkageTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if (memdup((u_char **) &StorageNew->sccpOperationalProtocols, (u_char *) "\x04\x0F", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpOperationalProtocolsLen = 2;
		}
		StorageNew->sccpNrOfRestrictionLevels = 8;
		StorageNew->sccpNrOfSubLevels = 4;
		StorageNew->sccpCLS = 8;
		StorageNew->sccpp = 8;
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelCR, (u_char *) "\x02\x04", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelCRLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelCC, (u_char *) "\x03\x04", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelCCLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelCREF, (u_char *) "\x02\x04", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelCREFLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelDT1, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelDT1Len = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelDT2, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelDT2Len = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelAK, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelAKLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelIT, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelITLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelED, (u_char *) "\x07\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelEDLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelEA, (u_char *) "\x07\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelEALen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRSR, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelRSRLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRSC, (u_char *) "\x06\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelRSCLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelERR, (u_char *) "\x07\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelERRLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRLC, (u_char *) "\x04\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelRLCLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelRLSD, (u_char *) "\x06\x06", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelRLSDLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelUDT, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelUDTLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelUDTS, (u_char *) "\x03\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelUDTSLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelXUDT, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelXUDTLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelXUDTS, (u_char *) "\x03\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelXUDTSLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelLUDT, (u_char *) "\x04\x06", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelLUDTLen = 2;
		}
		if (memdup((u_char **) &StorageNew->sccpImportanceLevelLUDTS, (u_char *) "\x03\x00", 2) == SNMPERR_SUCCESS) {
			StorageNew->sccpImportanceLevelLUDTSLen = 2;
		}
		StorageNew->sccpLinkageRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpLinkageTable_data *sccpLinkageTable_duplicate(struct sccpLinkageTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpLinkageTable_data *
sccpLinkageTable_duplicate(struct sccpLinkageTable_data *thedata)
{
	struct sccpLinkageTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpLinkageTable_data);

	DEBUGMSGTL(("sccpLinkageTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpLinkageTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpLinkageTable_destroy(struct sccpLinkageTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpLinkageTable_destroy(struct sccpLinkageTable_data **thedata)
{
	struct sccpLinkageTable_data *StorageDel;

	DEBUGMSGTL(("sccpLinkageTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpOperationalProtocols);
		StorageDel->sccpOperationalProtocolsLen = 0;
		SNMP_FREE(StorageDel->sccpSnSAP);
		StorageDel->sccpSnSAPLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelCR);
		StorageDel->sccpImportanceLevelCRLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelCC);
		StorageDel->sccpImportanceLevelCCLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelCREF);
		StorageDel->sccpImportanceLevelCREFLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelDT1);
		StorageDel->sccpImportanceLevelDT1Len = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelDT2);
		StorageDel->sccpImportanceLevelDT2Len = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelAK);
		StorageDel->sccpImportanceLevelAKLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelIT);
		StorageDel->sccpImportanceLevelITLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelED);
		StorageDel->sccpImportanceLevelEDLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelEA);
		StorageDel->sccpImportanceLevelEALen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRSR);
		StorageDel->sccpImportanceLevelRSRLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRSC);
		StorageDel->sccpImportanceLevelRSCLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelERR);
		StorageDel->sccpImportanceLevelERRLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRLC);
		StorageDel->sccpImportanceLevelRLCLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelRLSD);
		StorageDel->sccpImportanceLevelRLSDLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelUDT);
		StorageDel->sccpImportanceLevelUDTLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelUDTS);
		StorageDel->sccpImportanceLevelUDTSLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelXUDT);
		StorageDel->sccpImportanceLevelXUDTLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelXUDTS);
		StorageDel->sccpImportanceLevelXUDTSLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelLUDT);
		StorageDel->sccpImportanceLevelLUDTLen = 0;
		SNMP_FREE(StorageDel->sccpImportanceLevelLUDTS);
		StorageDel->sccpImportanceLevelLUDTSLen = 0;
		SNMP_FREE(StorageDel->sccpLinkageConcernedAreaPointer);
		StorageDel->sccpLinkageConcernedAreaPointerLen = 0;
		SNMP_FREE(StorageDel->sccpLinkageName);
		StorageDel->sccpLinkageNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpLinkageTable_add(struct sccpLinkageTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpLinkageTable table data set.
 * Adds a table row structure to the sccpLinkageTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpLinkageTable_add(struct sccpLinkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpLinkageTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpLinkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpLinkageId, sizeof(thedata->sccpLinkageId));
	header_complex_add_data(&sccpLinkageTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpLinkageTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpLinkageTable_del(struct sccpLinkageTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpLinkageTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpLinkageTable_del(struct sccpLinkageTable_data *thedata)
{
	struct sccpLinkageTable_data *StorageDel;

	DEBUGMSGTL(("sccpLinkageTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpLinkageTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpLinkageTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpLinkageTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpLinkageTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpLinkageTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpLinkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpLinkageTable_data *StorageTmp = sccpLinkageTable_create();

	DEBUGMSGTL(("sccpLinkageTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpLinkageId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpOperationalProtocols, &StorageTmp->sccpOperationalProtocolsLen);
	if (StorageTmp->sccpOperationalProtocols == NULL) {
		config_perror("invalid specification for sccpOperationalProtocols");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpSnSAP, &StorageTmp->sccpSnSAPLen);
	if (StorageTmp->sccpSnSAP == NULL) {
		config_perror("invalid specification for sccpSnSAP");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAttackTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpDecayTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNrOfRestrictionLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNrOfSubLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCLS, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCongestionTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpp, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCR, &StorageTmp->sccpImportanceLevelCRLen);
	if (StorageTmp->sccpImportanceLevelCR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCR");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCC, &StorageTmp->sccpImportanceLevelCCLen);
	if (StorageTmp->sccpImportanceLevelCC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCC");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCREF, &StorageTmp->sccpImportanceLevelCREFLen);
	if (StorageTmp->sccpImportanceLevelCREF == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCREF");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelDT1, &StorageTmp->sccpImportanceLevelDT1Len);
	if (StorageTmp->sccpImportanceLevelDT1 == NULL) {
		config_perror("invalid specification for sccpImportanceLevelDT1");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelDT2, &StorageTmp->sccpImportanceLevelDT2Len);
	if (StorageTmp->sccpImportanceLevelDT2 == NULL) {
		config_perror("invalid specification for sccpImportanceLevelDT2");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelAK, &StorageTmp->sccpImportanceLevelAKLen);
	if (StorageTmp->sccpImportanceLevelAK == NULL) {
		config_perror("invalid specification for sccpImportanceLevelAK");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelIT, &StorageTmp->sccpImportanceLevelITLen);
	if (StorageTmp->sccpImportanceLevelIT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelIT");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelED, &StorageTmp->sccpImportanceLevelEDLen);
	if (StorageTmp->sccpImportanceLevelED == NULL) {
		config_perror("invalid specification for sccpImportanceLevelED");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelEA, &StorageTmp->sccpImportanceLevelEALen);
	if (StorageTmp->sccpImportanceLevelEA == NULL) {
		config_perror("invalid specification for sccpImportanceLevelEA");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRSR, &StorageTmp->sccpImportanceLevelRSRLen);
	if (StorageTmp->sccpImportanceLevelRSR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRSR");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRSC, &StorageTmp->sccpImportanceLevelRSCLen);
	if (StorageTmp->sccpImportanceLevelRSC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRSC");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelERR, &StorageTmp->sccpImportanceLevelERRLen);
	if (StorageTmp->sccpImportanceLevelERR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelERR");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRLC, &StorageTmp->sccpImportanceLevelRLCLen);
	if (StorageTmp->sccpImportanceLevelRLC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRLC");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRLSD, &StorageTmp->sccpImportanceLevelRLSDLen);
	if (StorageTmp->sccpImportanceLevelRLSD == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRLSD");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelUDT, &StorageTmp->sccpImportanceLevelUDTLen);
	if (StorageTmp->sccpImportanceLevelUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelUDT");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelUDTS, &StorageTmp->sccpImportanceLevelUDTSLen);
	if (StorageTmp->sccpImportanceLevelUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelUDTS");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelXUDT, &StorageTmp->sccpImportanceLevelXUDTLen);
	if (StorageTmp->sccpImportanceLevelXUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelXUDT");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelXUDTS, &StorageTmp->sccpImportanceLevelXUDTSLen);
	if (StorageTmp->sccpImportanceLevelXUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelXUDTS");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelLUDT, &StorageTmp->sccpImportanceLevelLUDTLen);
	if (StorageTmp->sccpImportanceLevelLUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelLUDT");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelLUDTS, &StorageTmp->sccpImportanceLevelLUDTSLen);
	if (StorageTmp->sccpImportanceLevelLUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelLUDTS");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRLM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRSLM, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLinkageConcernedAreaPointer, &StorageTmp->sccpLinkageConcernedAreaPointerLen);
	if (StorageTmp->sccpLinkageConcernedAreaPointer == NULL) {
		config_perror("invalid specification for sccpLinkageConcernedAreaPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLowerLimitForSegmentation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpUpperLimitForSegmentation, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLinkageName, &StorageTmp->sccpLinkageNameLen);
	if (StorageTmp->sccpLinkageName == NULL) {
		config_perror("invalid specification for sccpLinkageName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLinkageRowStatus, &tmpsize);
	sccpLinkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
}

/*
 * store_sccpLinkageTable(): store configuraiton file for sccpLinkageTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpLinkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpLinkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpLinkageTable", "storing data...  "));
	refresh_sccpLinkageTable();
	(void) tmpsize;
	for (hcindex = sccpLinkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpLinkageTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpLinkageTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpLinkageId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpOperationalProtocols, &StorageTmp->sccpOperationalProtocolsLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpSnSAP, &StorageTmp->sccpSnSAPLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAttackTimerValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpDecayTimerValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNrOfRestrictionLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNrOfSubLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCLS, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCongestionTimerValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpp, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCR, &StorageTmp->sccpImportanceLevelCRLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCC, &StorageTmp->sccpImportanceLevelCCLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCREF, &StorageTmp->sccpImportanceLevelCREFLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelDT1, &StorageTmp->sccpImportanceLevelDT1Len);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelDT2, &StorageTmp->sccpImportanceLevelDT2Len);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelAK, &StorageTmp->sccpImportanceLevelAKLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelIT, &StorageTmp->sccpImportanceLevelITLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelED, &StorageTmp->sccpImportanceLevelEDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelEA, &StorageTmp->sccpImportanceLevelEALen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRSR, &StorageTmp->sccpImportanceLevelRSRLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRSC, &StorageTmp->sccpImportanceLevelRSCLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelERR, &StorageTmp->sccpImportanceLevelERRLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRLC, &StorageTmp->sccpImportanceLevelRLCLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRLSD, &StorageTmp->sccpImportanceLevelRLSDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelUDT, &StorageTmp->sccpImportanceLevelUDTLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelUDTS, &StorageTmp->sccpImportanceLevelUDTSLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelXUDT, &StorageTmp->sccpImportanceLevelXUDTLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelXUDTS, &StorageTmp->sccpImportanceLevelXUDTSLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelLUDT, &StorageTmp->sccpImportanceLevelLUDTLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelLUDTS, &StorageTmp->sccpImportanceLevelLUDTSLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRLM, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRSLM, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLinkageConcernedAreaPointer, &StorageTmp->sccpLinkageConcernedAreaPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLowerLimitForSegmentation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpUpperLimitForSegmentation, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLinkageName, &StorageTmp->sccpLinkageNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLinkageRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpSclcTable_data *sccpSclcTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpSclcTable table.
 * Creates a new sccpSclcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpSclcTable_data *
sccpSclcTable_create(void)
{
	struct sccpSclcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSclcTable_data);

	DEBUGMSGTL(("sccpSclcTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpSclcRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpSclcTable_data *sccpSclcTable_duplicate(struct sccpSclcTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpSclcTable_data *
sccpSclcTable_duplicate(struct sccpSclcTable_data *thedata)
{
	struct sccpSclcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSclcTable_data);

	DEBUGMSGTL(("sccpSclcTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpSclcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpSclcTable_destroy(struct sccpSclcTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpSclcTable_destroy(struct sccpSclcTable_data **thedata)
{
	struct sccpSclcTable_data *StorageDel;

	DEBUGMSGTL(("sccpSclcTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpSclcAlarmStatus);
		StorageDel->sccpSclcAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpClProtocolMachineId);
		StorageDel->sccpClProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->sccpSclcSupportedProtocols);
		StorageDel->sccpSclcSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->sccpSclcName);
		StorageDel->sccpSclcNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSclcTable_add(struct sccpSclcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpSclcTable table data set.
 * Adds a table row structure to the sccpSclcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpSclcTable_add(struct sccpSclcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSclcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpSclcTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSclcTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSclcTable_del(struct sccpSclcTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpSclcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpSclcTable_del(struct sccpSclcTable_data *thedata)
{
	struct sccpSclcTable_data *StorageDel;

	DEBUGMSGTL(("sccpSclcTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpSclcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpSclcTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpSclcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpSclcTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpSclcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpSclcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSclcTable_data *StorageTmp = sccpSclcTable_create();

	DEBUGMSGTL(("sccpSclcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSclcAlarmStatus, &StorageTmp->sccpSclcAlarmStatusLen);
	if (StorageTmp->sccpSclcAlarmStatus == NULL) {
		config_perror("invalid specification for sccpSclcAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpClProtocolMachineId, &StorageTmp->sccpClProtocolMachineIdLen);
	if (StorageTmp->sccpClProtocolMachineId == NULL) {
		config_perror("invalid specification for sccpClProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpTotalRemoteSAPs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSclcSupportedProtocols, &StorageTmp->sccpSclcSupportedProtocolsLen);
	if (StorageTmp->sccpSclcSupportedProtocols == NULL) {
		config_perror("invalid specification for sccpSclcSupportedProtocols");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcOperationalSystemType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpInitialValueReassTimer, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSclcName, &StorageTmp->sccpSclcNameLen);
	if (StorageTmp->sccpSclcName == NULL) {
		config_perror("invalid specification for sccpSclcName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcRowStatus, &tmpsize);
	sccpSclcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
}

/*
 * store_sccpSclcTable(): store configuraiton file for sccpSclcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpSclcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSclcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSclcTable", "storing data...  "));
	refresh_sccpSclcTable();
	(void) tmpsize;
	for (hcindex = sccpSclcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSclcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpSclcTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSclcAlarmStatus, &StorageTmp->sccpSclcAlarmStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpClProtocolMachineId, &StorageTmp->sccpClProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpTotalRemoteSAPs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSclcSupportedProtocols, &StorageTmp->sccpSclcSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpInitialValueReassTimer, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSclcName, &StorageTmp->sccpSclcNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpScocTable_data *sccpScocTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpScocTable table.
 * Creates a new sccpScocTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpScocTable_data *
sccpScocTable_create(void)
{
	struct sccpScocTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScocTable_data);

	DEBUGMSGTL(("sccpScocTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpScocRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpScocTable_data *sccpScocTable_duplicate(struct sccpScocTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpScocTable_data *
sccpScocTable_duplicate(struct sccpScocTable_data *thedata)
{
	struct sccpScocTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScocTable_data);

	DEBUGMSGTL(("sccpScocTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpScocTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpScocTable_destroy(struct sccpScocTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpScocTable_destroy(struct sccpScocTable_data **thedata)
{
	struct sccpScocTable_data *StorageDel;

	DEBUGMSGTL(("sccpScocTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpCoProtocolMachineId);
		StorageDel->sccpCoProtocolMachineIdLen = 0;
		SNMP_FREE(StorageDel->sccpScocSupportedProtocols);
		StorageDel->sccpScocSupportedProtocolsLen = 0;
		SNMP_FREE(StorageDel->sccpScocName);
		StorageDel->sccpScocNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScocTable_add(struct sccpScocTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpScocTable table data set.
 * Adds a table row structure to the sccpScocTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpScocTable_add(struct sccpScocTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpScocTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpScocTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpScocTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScocTable_del(struct sccpScocTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpScocTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpScocTable_del(struct sccpScocTable_data *thedata)
{
	struct sccpScocTable_data *StorageDel;

	DEBUGMSGTL(("sccpScocTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpScocTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpScocTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpScocTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpScocTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpScocTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpScocTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpScocTable_data *StorageTmp = sccpScocTable_create();

	DEBUGMSGTL(("sccpScocTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpCoProtocolMachineId, &StorageTmp->sccpCoProtocolMachineIdLen);
	if (StorageTmp->sccpCoProtocolMachineId == NULL) {
		config_perror("invalid specification for sccpCoProtocolMachineId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocOperationalSystemType, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpScocSupportedProtocols, &StorageTmp->sccpScocSupportedProtocolsLen);
	if (StorageTmp->sccpScocSupportedProtocols == NULL) {
		config_perror("invalid specification for sccpScocSupportedProtocols");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScocName, &StorageTmp->sccpScocNameLen);
	if (StorageTmp->sccpScocName == NULL) {
		config_perror("invalid specification for sccpScocName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocRowStatus, &tmpsize);
	sccpScocTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
}

/*
 * store_sccpScocTable(): store configuraiton file for sccpScocTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpScocTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpScocTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpScocTable", "storing data...  "));
	refresh_sccpScocTable();
	(void) tmpsize;
	for (hcindex = sccpScocTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpScocTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpScocTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpCoProtocolMachineId, &StorageTmp->sccpCoProtocolMachineIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocOperationalSystemType, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpScocSupportedProtocols, &StorageTmp->sccpScocSupportedProtocolsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScocName, &StorageTmp->sccpScocNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpScrcTable_data *sccpScrcTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpScrcTable table.
 * Creates a new sccpScrcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpScrcTable_data *
sccpScrcTable_create(void)
{
	struct sccpScrcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScrcTable_data);

	DEBUGMSGTL(("sccpScrcTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpScrcRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpScrcTable_data *sccpScrcTable_duplicate(struct sccpScrcTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpScrcTable_data *
sccpScrcTable_duplicate(struct sccpScrcTable_data *thedata)
{
	struct sccpScrcTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpScrcTable_data);

	DEBUGMSGTL(("sccpScrcTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpScrcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpScrcTable_destroy(struct sccpScrcTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpScrcTable_destroy(struct sccpScrcTable_data **thedata)
{
	struct sccpScrcTable_data *StorageDel;

	DEBUGMSGTL(("sccpScrcTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpScrcId);
		StorageDel->sccpScrcIdLen = 0;
		SNMP_FREE(StorageDel->sccpScrcAlarmStatus);
		StorageDel->sccpScrcAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->sccpScrcName);
		StorageDel->sccpScrcNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScrcTable_add(struct sccpScrcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpScrcTable table data set.
 * Adds a table row structure to the sccpScrcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpScrcTable_add(struct sccpScrcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpScrcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&sccpScrcTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpScrcTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpScrcTable_del(struct sccpScrcTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpScrcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpScrcTable_del(struct sccpScrcTable_data *thedata)
{
	struct sccpScrcTable_data *StorageDel;

	DEBUGMSGTL(("sccpScrcTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpScrcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpScrcTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpScrcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpScrcTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpScrcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpScrcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpScrcTable_data *StorageTmp = sccpScrcTable_create();

	DEBUGMSGTL(("sccpScrcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScrcId, &StorageTmp->sccpScrcIdLen);
	if (StorageTmp->sccpScrcId == NULL) {
		config_perror("invalid specification for sccpScrcId");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpScrcAlarmStatus, &StorageTmp->sccpScrcAlarmStatusLen);
	if (StorageTmp->sccpScrcAlarmStatus == NULL) {
		config_perror("invalid specification for sccpScrcAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScrcName, &StorageTmp->sccpScrcNameLen);
	if (StorageTmp->sccpScrcName == NULL) {
		config_perror("invalid specification for sccpScrcName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScrcRowStatus, &tmpsize);
	sccpScrcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
}

/*
 * store_sccpScrcTable(): store configuraiton file for sccpScrcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpScrcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpScrcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpScrcTable", "storing data...  "));
	refresh_sccpScrcTable();
	(void) tmpsize;
	for (hcindex = sccpScrcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpScrcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpScrcTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScrcId, &StorageTmp->sccpScrcIdLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpScrcAlarmStatus, &StorageTmp->sccpScrcAlarmStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScrcName, &StorageTmp->sccpScrcNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScrcRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpEntitySetTable_data *sccpEntitySetTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpEntitySetTable table.
 * Creates a new sccpEntitySetTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpEntitySetTable_data *
sccpEntitySetTable_create(void)
{
	struct sccpEntitySetTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetTable_data);

	DEBUGMSGTL(("sccpEntitySetTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpEntitySetRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpEntitySetTable_data *sccpEntitySetTable_duplicate(struct sccpEntitySetTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpEntitySetTable_data *
sccpEntitySetTable_duplicate(struct sccpEntitySetTable_data *thedata)
{
	struct sccpEntitySetTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetTable_data);

	DEBUGMSGTL(("sccpEntitySetTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpEntitySetTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpEntitySetTable_destroy(struct sccpEntitySetTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpEntitySetTable_destroy(struct sccpEntitySetTable_data **thedata)
{
	struct sccpEntitySetTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpEntitySetId);
		StorageDel->sccpEntitySetIdLen = 0;
		SNMP_FREE(StorageDel->sccpLoadSharingAlgPointer);
		StorageDel->sccpLoadSharingAlgPointerLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetName);
		StorageDel->sccpEntitySetNameLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetSsn);
		StorageDel->sccpEntitySetSsnLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetTable_add(struct sccpEntitySetTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpEntitySetTable table data set.
 * Adds a table row structure to the sccpEntitySetTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpEntitySetTable_add(struct sccpEntitySetTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpEntitySetTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpEntitySetId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpEntitySetId, thedata->sccpEntitySetIdLen);
	header_complex_add_data(&sccpEntitySetTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpEntitySetTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetTable_del(struct sccpEntitySetTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpEntitySetTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpEntitySetTable_del(struct sccpEntitySetTable_data *thedata)
{
	struct sccpEntitySetTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpEntitySetTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpEntitySetTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpEntitySetTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpEntitySetTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpEntitySetTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpEntitySetTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpEntitySetTable_data *StorageTmp = sccpEntitySetTable_create();

	DEBUGMSGTL(("sccpEntitySetTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
	if (StorageTmp->sccpEntitySetId == NULL) {
		config_perror("invalid specification for sccpEntitySetId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSharingMode, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpLoadSharingAlgPointer, &StorageTmp->sccpLoadSharingAlgPointerLen);
	if (StorageTmp->sccpLoadSharingAlgPointer == NULL) {
		config_perror("invalid specification for sccpLoadSharingAlgPointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetName, &StorageTmp->sccpEntitySetNameLen);
	if (StorageTmp->sccpEntitySetName == NULL) {
		config_perror("invalid specification for sccpEntitySetName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetSsn, &StorageTmp->sccpEntitySetSsnLen);
	if (StorageTmp->sccpEntitySetSsn == NULL) {
		config_perror("invalid specification for sccpEntitySetSsn");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetRowStatus, &tmpsize);
	sccpEntitySetTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
}

/*
 * store_sccpEntitySetTable(): store configuraiton file for sccpEntitySetTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpEntitySetTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpEntitySetTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpEntitySetTable", "storing data...  "));
	refresh_sccpEntitySetTable();
	(void) tmpsize;
	for (hcindex = sccpEntitySetTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpEntitySetTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpEntitySetTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSharingMode, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpLoadSharingAlgPointer, &StorageTmp->sccpLoadSharingAlgPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetName, &StorageTmp->sccpEntitySetNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetSsn, &StorageTmp->sccpEntitySetSsnLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpEntitySetSapTable_data *sccpEntitySetSapTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpEntitySetSapTable table.
 * Creates a new sccpEntitySetSapTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpEntitySetSapTable_data *
sccpEntitySetSapTable_create(void)
{
	struct sccpEntitySetSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetSapTable_data);

	DEBUGMSGTL(("sccpEntitySetSapTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpEntitySetSapRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpEntitySetSapTable_data *sccpEntitySetSapTable_duplicate(struct sccpEntitySetSapTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpEntitySetSapTable_data *
sccpEntitySetSapTable_duplicate(struct sccpEntitySetSapTable_data *thedata)
{
	struct sccpEntitySetSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetSapTable_data);

	DEBUGMSGTL(("sccpEntitySetSapTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpEntitySetSapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpEntitySetSapTable_destroy(struct sccpEntitySetSapTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpEntitySetSapTable_destroy(struct sccpEntitySetSapTable_data **thedata)
{
	struct sccpEntitySetSapTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetSapTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpEntitySetId);
		StorageDel->sccpEntitySetIdLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetSapId);
		StorageDel->sccpEntitySetSapIdLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetSapPointer);
		StorageDel->sccpEntitySetSapPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetSapTable_add(struct sccpEntitySetSapTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpEntitySetSapTable table data set.
 * Adds a table row structure to the sccpEntitySetSapTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpEntitySetSapTable_add(struct sccpEntitySetSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpEntitySetSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpEntitySetId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpEntitySetId, thedata->sccpEntitySetIdLen);
	/* sccpEntitySetSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpEntitySetSapId, thedata->sccpEntitySetSapIdLen);
	header_complex_add_data(&sccpEntitySetSapTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpEntitySetSapTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpEntitySetSapTable_del(struct sccpEntitySetSapTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpEntitySetSapTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpEntitySetSapTable_del(struct sccpEntitySetSapTable_data *thedata)
{
	struct sccpEntitySetSapTable_data *StorageDel;

	DEBUGMSGTL(("sccpEntitySetSapTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpEntitySetSapTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpEntitySetSapTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpEntitySetSapTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpEntitySetSapTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpEntitySetSapTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpEntitySetSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpEntitySetSapTable_data *StorageTmp = sccpEntitySetSapTable_create();

	DEBUGMSGTL(("sccpEntitySetSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
	if (StorageTmp->sccpEntitySetId == NULL) {
		config_perror("invalid specification for sccpEntitySetId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetSapId, &StorageTmp->sccpEntitySetSapIdLen);
	if (StorageTmp->sccpEntitySetSapId == NULL) {
		config_perror("invalid specification for sccpEntitySetSapId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetSapType, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpEntitySetSapPointer, &StorageTmp->sccpEntitySetSapPointerLen);
	if (StorageTmp->sccpEntitySetSapPointer == NULL) {
		config_perror("invalid specification for sccpEntitySetSapPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetSapRowStatus, &tmpsize);
	sccpEntitySetSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
}

/*
 * store_sccpEntitySetSapTable(): store configuraiton file for sccpEntitySetSapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpEntitySetSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpEntitySetSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpEntitySetSapTable", "storing data...  "));
	refresh_sccpEntitySetSapTable();
	(void) tmpsize;
	for (hcindex = sccpEntitySetSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpEntitySetSapTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpEntitySetSapTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetId, &StorageTmp->sccpEntitySetIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetSapId, &StorageTmp->sccpEntitySetSapIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetSapType, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpEntitySetSapPointer, &StorageTmp->sccpEntitySetSapPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetSapRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpConcernedAreaTable_data *sccpConcernedAreaTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpConcernedAreaTable table.
 * Creates a new sccpConcernedAreaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpConcernedAreaTable_data *
sccpConcernedAreaTable_create(void)
{
	struct sccpConcernedAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpConcernedAreaTable_data);

	DEBUGMSGTL(("sccpConcernedAreaTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpConcernedAreaRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpConcernedAreaTable_data *sccpConcernedAreaTable_duplicate(struct sccpConcernedAreaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpConcernedAreaTable_data *
sccpConcernedAreaTable_duplicate(struct sccpConcernedAreaTable_data *thedata)
{
	struct sccpConcernedAreaTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpConcernedAreaTable_data);

	DEBUGMSGTL(("sccpConcernedAreaTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpConcernedAreaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpConcernedAreaTable_destroy(struct sccpConcernedAreaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpConcernedAreaTable_destroy(struct sccpConcernedAreaTable_data **thedata)
{
	struct sccpConcernedAreaTable_data *StorageDel;

	DEBUGMSGTL(("sccpConcernedAreaTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpConcernedAreaId);
		StorageDel->sccpConcernedAreaIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpConcernedAreaTable_add(struct sccpConcernedAreaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpConcernedAreaTable table data set.
 * Adds a table row structure to the sccpConcernedAreaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpConcernedAreaTable_add(struct sccpConcernedAreaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpConcernedAreaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpConcernedAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpConcernedAreaId, thedata->sccpConcernedAreaIdLen);
	header_complex_add_data(&sccpConcernedAreaTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpConcernedAreaTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpConcernedAreaTable_del(struct sccpConcernedAreaTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpConcernedAreaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpConcernedAreaTable_del(struct sccpConcernedAreaTable_data *thedata)
{
	struct sccpConcernedAreaTable_data *StorageDel;

	DEBUGMSGTL(("sccpConcernedAreaTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpConcernedAreaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpConcernedAreaTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpConcernedAreaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpConcernedAreaTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpConcernedAreaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpConcernedAreaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpConcernedAreaTable_data *StorageTmp = sccpConcernedAreaTable_create();

	DEBUGMSGTL(("sccpConcernedAreaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
	if (StorageTmp->sccpConcernedAreaId == NULL) {
		config_perror("invalid specification for sccpConcernedAreaId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpConcernedAreaRowStatus, &tmpsize);
	sccpConcernedAreaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
}

/*
 * store_sccpConcernedAreaTable(): store configuraiton file for sccpConcernedAreaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpConcernedAreaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpConcernedAreaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpConcernedAreaTable", "storing data...  "));
	refresh_sccpConcernedAreaTable();
	(void) tmpsize;
	for (hcindex = sccpConcernedAreaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpConcernedAreaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpConcernedAreaTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpConcernedAreaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpRemoteSCCPTable_data *sccpRemoteSCCPTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpRemoteSCCPTable table.
 * Creates a new sccpRemoteSCCPTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpRemoteSCCPTable_data *
sccpRemoteSCCPTable_create(void)
{
	struct sccpRemoteSCCPTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpRemoteSCCPTable_data);

	DEBUGMSGTL(("sccpRemoteSCCPTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpRemoteSCCPRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpRemoteSCCPTable_data *sccpRemoteSCCPTable_duplicate(struct sccpRemoteSCCPTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpRemoteSCCPTable_data *
sccpRemoteSCCPTable_duplicate(struct sccpRemoteSCCPTable_data *thedata)
{
	struct sccpRemoteSCCPTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpRemoteSCCPTable_data);

	DEBUGMSGTL(("sccpRemoteSCCPTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpRemoteSCCPTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpRemoteSCCPTable_destroy(struct sccpRemoteSCCPTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpRemoteSCCPTable_destroy(struct sccpRemoteSCCPTable_data **thedata)
{
	struct sccpRemoteSCCPTable_data *StorageDel;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpConcernedAreaId);
		StorageDel->sccpConcernedAreaIdLen = 0;
		SNMP_FREE(StorageDel->sccpRemoteSCCPId);
		StorageDel->sccpRemoteSCCPIdLen = 0;
		SNMP_FREE(StorageDel->sccpRemoteSCCPMTPAccessPoint);
		StorageDel->sccpRemoteSCCPMTPAccessPointLen = 0;
		SNMP_FREE(StorageDel->sccpRemoteSCCPName);
		StorageDel->sccpRemoteSCCPNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpRemoteSCCPTable_add(struct sccpRemoteSCCPTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpRemoteSCCPTable table data set.
 * Adds a table row structure to the sccpRemoteSCCPTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpRemoteSCCPTable_add(struct sccpRemoteSCCPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpConcernedAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpConcernedAreaId, thedata->sccpConcernedAreaIdLen);
	/* sccpRemoteSCCPId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpRemoteSCCPId, thedata->sccpRemoteSCCPIdLen);
	header_complex_add_data(&sccpRemoteSCCPTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpRemoteSCCPTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpRemoteSCCPTable_del(struct sccpRemoteSCCPTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpRemoteSCCPTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpRemoteSCCPTable_del(struct sccpRemoteSCCPTable_data *thedata)
{
	struct sccpRemoteSCCPTable_data *StorageDel;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpRemoteSCCPTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpRemoteSCCPTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpRemoteSCCPTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpRemoteSCCPTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpRemoteSCCPTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpRemoteSCCPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpRemoteSCCPTable_data *StorageTmp = sccpRemoteSCCPTable_create();

	DEBUGMSGTL(("sccpRemoteSCCPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
	if (StorageTmp->sccpConcernedAreaId == NULL) {
		config_perror("invalid specification for sccpConcernedAreaId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRemoteSCCPId, &StorageTmp->sccpRemoteSCCPIdLen);
	if (StorageTmp->sccpRemoteSCCPId == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPId");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpRemoteSCCPMTPAccessPoint, &StorageTmp->sccpRemoteSCCPMTPAccessPointLen);
	if (StorageTmp->sccpRemoteSCCPMTPAccessPoint == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPMTPAccessPoint");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRemoteSCCPName, &StorageTmp->sccpRemoteSCCPNameLen);
	if (StorageTmp->sccpRemoteSCCPName == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRemoteSCCPRowStatus, &tmpsize);
	sccpRemoteSCCPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
}

/*
 * store_sccpRemoteSCCPTable(): store configuraiton file for sccpRemoteSCCPTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpRemoteSCCPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpRemoteSCCPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "storing data...  "));
	refresh_sccpRemoteSCCPTable();
	(void) tmpsize;
	for (hcindex = sccpRemoteSCCPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpRemoteSCCPTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpRemoteSCCPTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpConcernedAreaId, &StorageTmp->sccpConcernedAreaIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRemoteSCCPId, &StorageTmp->sccpRemoteSCCPIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpRemoteSCCPMTPAccessPoint, &StorageTmp->sccpRemoteSCCPMTPAccessPointLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRemoteSCCPName, &StorageTmp->sccpRemoteSCCPNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRemoteSCCPRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpGtConversionRuleTable_data *sccpGtConversionRuleTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpGtConversionRuleTable table.
 * Creates a new sccpGtConversionRuleTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpGtConversionRuleTable_data *
sccpGtConversionRuleTable_create(void)
{
	struct sccpGtConversionRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtConversionRuleTable_data);

	DEBUGMSGTL(("sccpGtConversionRuleTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpGtNewEncodingScheme = 256;
		StorageNew->sccpGtNewNatureOfAddress = 256;
		StorageNew->sccpGtNewNumberingPlan = 256;
		StorageNew->sccpGtNewTranslationType = 256;
		StorageNew->sccpGtConversionRuleRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpGtConversionRuleTable_data *sccpGtConversionRuleTable_duplicate(struct sccpGtConversionRuleTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpGtConversionRuleTable_data *
sccpGtConversionRuleTable_duplicate(struct sccpGtConversionRuleTable_data *thedata)
{
	struct sccpGtConversionRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtConversionRuleTable_data);

	DEBUGMSGTL(("sccpGtConversionRuleTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpGtConversionRuleTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpGtConversionRuleTable_destroy(struct sccpGtConversionRuleTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpGtConversionRuleTable_destroy(struct sccpGtConversionRuleTable_data **thedata)
{
	struct sccpGtConversionRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtConversionRuleId);
		StorageDel->sccpGtConversionRuleIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtConversionRuleName);
		StorageDel->sccpGtConversionRuleNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtConversionRuleTable_add(struct sccpGtConversionRuleTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpGtConversionRuleTable table data set.
 * Adds a table row structure to the sccpGtConversionRuleTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpGtConversionRuleTable_add(struct sccpGtConversionRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtConversionRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtConversionRuleId, thedata->sccpGtConversionRuleIdLen);
	header_complex_add_data(&sccpGtConversionRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtConversionRuleTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtConversionRuleTable_del(struct sccpGtConversionRuleTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpGtConversionRuleTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpGtConversionRuleTable_del(struct sccpGtConversionRuleTable_data *thedata)
{
	struct sccpGtConversionRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpGtConversionRuleTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpGtConversionRuleTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpGtConversionRuleTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpGtConversionRuleTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpGtConversionRuleTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpGtConversionRuleTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtConversionRuleTable_data *StorageTmp = sccpGtConversionRuleTable_create();

	DEBUGMSGTL(("sccpGtConversionRuleTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
	if (StorageTmp->sccpGtConversionRuleId == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewEncodingScheme, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewNatureOfAddress, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewNumberingPlan, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewTranslationType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleName, &StorageTmp->sccpGtConversionRuleNameLen);
	if (StorageTmp->sccpGtConversionRuleName == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtConversionRuleRowStatus, &tmpsize);
	sccpGtConversionRuleTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
}

/*
 * store_sccpGtConversionRuleTable(): store configuraiton file for sccpGtConversionRuleTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtConversionRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtConversionRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "storing data...  "));
	refresh_sccpGtConversionRuleTable();
	(void) tmpsize;
	for (hcindex = sccpGtConversionRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtConversionRuleTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpGtConversionRuleTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewEncodingScheme, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewNatureOfAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewNumberingPlan, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewTranslationType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleName, &StorageTmp->sccpGtConversionRuleNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtConversionRuleRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpAddressInfoTable_data *sccpAddressInfoTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpAddressInfoTable table.
 * Creates a new sccpAddressInfoTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpAddressInfoTable_data *
sccpAddressInfoTable_create(void)
{
	struct sccpAddressInfoTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAddressInfoTable_data);

	DEBUGMSGTL(("sccpAddressInfoTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpAddressInfoRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpAddressInfoTable_data *sccpAddressInfoTable_duplicate(struct sccpAddressInfoTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpAddressInfoTable_data *
sccpAddressInfoTable_duplicate(struct sccpAddressInfoTable_data *thedata)
{
	struct sccpAddressInfoTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpAddressInfoTable_data);

	DEBUGMSGTL(("sccpAddressInfoTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpAddressInfoTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpAddressInfoTable_destroy(struct sccpAddressInfoTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpAddressInfoTable_destroy(struct sccpAddressInfoTable_data **thedata)
{
	struct sccpAddressInfoTable_data *StorageDel;

	DEBUGMSGTL(("sccpAddressInfoTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtConversionRuleId);
		StorageDel->sccpGtConversionRuleIdLen = 0;
		SNMP_FREE(StorageDel->sccpAddressInfoOperationId);
		StorageDel->sccpAddressInfoOperationIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAddressInfoTable_add(struct sccpAddressInfoTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpAddressInfoTable table data set.
 * Adds a table row structure to the sccpAddressInfoTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpAddressInfoTable_add(struct sccpAddressInfoTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpAddressInfoTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtConversionRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtConversionRuleId, thedata->sccpGtConversionRuleIdLen);
	/* sccpAddressInfoOperationId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpAddressInfoOperationId, thedata->sccpAddressInfoOperationIdLen);
	header_complex_add_data(&sccpAddressInfoTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpAddressInfoTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpAddressInfoTable_del(struct sccpAddressInfoTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpAddressInfoTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpAddressInfoTable_del(struct sccpAddressInfoTable_data *thedata)
{
	struct sccpAddressInfoTable_data *StorageDel;

	DEBUGMSGTL(("sccpAddressInfoTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpAddressInfoTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpAddressInfoTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpAddressInfoTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpAddressInfoTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpAddressInfoTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpAddressInfoTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpAddressInfoTable_data *StorageTmp = sccpAddressInfoTable_create();

	DEBUGMSGTL(("sccpAddressInfoTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
	if (StorageTmp->sccpGtConversionRuleId == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpAddressInfoOperationId, &StorageTmp->sccpAddressInfoOperationIdLen);
	if (StorageTmp->sccpAddressInfoOperationId == NULL) {
		config_perror("invalid specification for sccpAddressInfoOperationId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoOperation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoAddressElement, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoNrOfAddressElements, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoRowStatus, &tmpsize);
	sccpAddressInfoTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
}

/*
 * store_sccpAddressInfoTable(): store configuraiton file for sccpAddressInfoTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpAddressInfoTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpAddressInfoTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpAddressInfoTable", "storing data...  "));
	refresh_sccpAddressInfoTable();
	(void) tmpsize;
	for (hcindex = sccpAddressInfoTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpAddressInfoTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpAddressInfoTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleId, &StorageTmp->sccpGtConversionRuleIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpAddressInfoOperationId, &StorageTmp->sccpAddressInfoOperationIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoOperation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoAddressElement, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoNrOfAddressElements, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpGtTranslatorTable_data *sccpGtTranslatorTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpGtTranslatorTable table.
 * Creates a new sccpGtTranslatorTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpGtTranslatorTable_data *
sccpGtTranslatorTable_create(void)
{
	struct sccpGtTranslatorTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtTranslatorTable_data);

	DEBUGMSGTL(("sccpGtTranslatorTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpGtTranslatorRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpGtTranslatorTable_data *sccpGtTranslatorTable_duplicate(struct sccpGtTranslatorTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpGtTranslatorTable_data *
sccpGtTranslatorTable_duplicate(struct sccpGtTranslatorTable_data *thedata)
{
	struct sccpGtTranslatorTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtTranslatorTable_data);

	DEBUGMSGTL(("sccpGtTranslatorTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpGtTranslatorTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpGtTranslatorTable_destroy(struct sccpGtTranslatorTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpGtTranslatorTable_destroy(struct sccpGtTranslatorTable_data **thedata)
{
	struct sccpGtTranslatorTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtTranslatorTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtTranslatorId);
		StorageDel->sccpGtTranslatorIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtTranslatorName);
		StorageDel->sccpGtTranslatorNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtTranslatorTable_add(struct sccpGtTranslatorTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpGtTranslatorTable table data set.
 * Adds a table row structure to the sccpGtTranslatorTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpGtTranslatorTable_add(struct sccpGtTranslatorTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtTranslatorTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtTranslatorId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtTranslatorId, thedata->sccpGtTranslatorIdLen);
	header_complex_add_data(&sccpGtTranslatorTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtTranslatorTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtTranslatorTable_del(struct sccpGtTranslatorTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpGtTranslatorTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpGtTranslatorTable_del(struct sccpGtTranslatorTable_data *thedata)
{
	struct sccpGtTranslatorTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtTranslatorTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpGtTranslatorTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpGtTranslatorTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpGtTranslatorTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpGtTranslatorTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpGtTranslatorTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpGtTranslatorTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtTranslatorTable_data *StorageTmp = sccpGtTranslatorTable_create();

	DEBUGMSGTL(("sccpGtTranslatorTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
	if (StorageTmp->sccpGtTranslatorId == NULL) {
		config_perror("invalid specification for sccpGtTranslatorId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtIndicator, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNatureOfAddress, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNumberingPlan, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslationType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslatorAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorName, &StorageTmp->sccpGtTranslatorNameLen);
	if (StorageTmp->sccpGtTranslatorName == NULL) {
		config_perror("invalid specification for sccpGtTranslatorName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslatorRowStatus, &tmpsize);
	sccpGtTranslatorTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
}

/*
 * store_sccpGtTranslatorTable(): store configuraiton file for sccpGtTranslatorTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtTranslatorTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtTranslatorTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtTranslatorTable", "storing data...  "));
	refresh_sccpGtTranslatorTable();
	(void) tmpsize;
	for (hcindex = sccpGtTranslatorTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtTranslatorTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpGtTranslatorTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNatureOfAddress, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNumberingPlan, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslationType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslatorAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorName, &StorageTmp->sccpGtTranslatorNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslatorRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpGtRuleTable_data *sccpGtRuleTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpGtRuleTable table.
 * Creates a new sccpGtRuleTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpGtRuleTable_data *
sccpGtRuleTable_create(void)
{
	struct sccpGtRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtRuleTable_data);

	DEBUGMSGTL(("sccpGtRuleTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpGtRuleRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpGtRuleTable_data *sccpGtRuleTable_duplicate(struct sccpGtRuleTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpGtRuleTable_data *
sccpGtRuleTable_duplicate(struct sccpGtRuleTable_data *thedata)
{
	struct sccpGtRuleTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpGtRuleTable_data);

	DEBUGMSGTL(("sccpGtRuleTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpGtRuleTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpGtRuleTable_destroy(struct sccpGtRuleTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpGtRuleTable_destroy(struct sccpGtRuleTable_data **thedata)
{
	struct sccpGtRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtRuleTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpGtTranslatorId);
		StorageDel->sccpGtTranslatorIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtRuleId);
		StorageDel->sccpGtRuleIdLen = 0;
		SNMP_FREE(StorageDel->sccpGtAddressInformation);
		StorageDel->sccpGtAddressInformationLen = 0;
		SNMP_FREE(StorageDel->sccpGtConvRulePointer);
		StorageDel->sccpGtConvRulePointerLen = 0;
		SNMP_FREE(StorageDel->sccpEntitySetPointer);
		StorageDel->sccpEntitySetPointerLen = 0;
		SNMP_FREE(StorageDel->sccpGtRuleName);
		StorageDel->sccpGtRuleNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtRuleTable_add(struct sccpGtRuleTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpGtRuleTable table data set.
 * Adds a table row structure to the sccpGtRuleTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpGtRuleTable_add(struct sccpGtRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtTranslatorId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtTranslatorId, thedata->sccpGtTranslatorIdLen);
	/* sccpGtRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpGtRuleId, thedata->sccpGtRuleIdLen);
	header_complex_add_data(&sccpGtRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtRuleTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpGtRuleTable_del(struct sccpGtRuleTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpGtRuleTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpGtRuleTable_del(struct sccpGtRuleTable_data *thedata)
{
	struct sccpGtRuleTable_data *StorageDel;

	DEBUGMSGTL(("sccpGtRuleTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpGtRuleTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpGtRuleTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpGtRuleTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpGtRuleTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpGtRuleTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpGtRuleTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtRuleTable_data *StorageTmp = sccpGtRuleTable_create();

	DEBUGMSGTL(("sccpGtRuleTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
	if (StorageTmp->sccpGtTranslatorId == NULL) {
		config_perror("invalid specification for sccpGtTranslatorId");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtRuleId, &StorageTmp->sccpGtRuleIdLen);
	if (StorageTmp->sccpGtRuleId == NULL) {
		config_perror("invalid specification for sccpGtRuleId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtRuleAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtAddressInformation, &StorageTmp->sccpGtAddressInformationLen);
	if (StorageTmp->sccpGtAddressInformation == NULL) {
		config_perror("invalid specification for sccpGtAddressInformation");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConvRulePointer, &StorageTmp->sccpGtConvRulePointerLen);
	if (StorageTmp->sccpGtConvRulePointer == NULL) {
		config_perror("invalid specification for sccpGtConvRulePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtEncodingScheme, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetPointer, &StorageTmp->sccpEntitySetPointerLen);
	if (StorageTmp->sccpEntitySetPointer == NULL) {
		config_perror("invalid specification for sccpEntitySetPointer");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtRuleName, &StorageTmp->sccpGtRuleNameLen);
	if (StorageTmp->sccpGtRuleName == NULL) {
		config_perror("invalid specification for sccpGtRuleName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtRuleRowStatus, &tmpsize);
	sccpGtRuleTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
}

/*
 * store_sccpGtRuleTable(): store configuraiton file for sccpGtRuleTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtRuleTable", "storing data...  "));
	refresh_sccpGtRuleTable();
	(void) tmpsize;
	for (hcindex = sccpGtRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtRuleTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpGtRuleTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorId, &StorageTmp->sccpGtTranslatorIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtRuleId, &StorageTmp->sccpGtRuleIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtRuleAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtAddressInformation, &StorageTmp->sccpGtAddressInformationLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConvRulePointer, &StorageTmp->sccpGtConvRulePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtEncodingScheme, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetPointer, &StorageTmp->sccpEntitySetPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtRuleName, &StorageTmp->sccpGtRuleNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtRuleRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct sccpSrvtTable_data *sccpSrvtTable_create(void)
 * @brief create a fresh data structure representing a new row in the sccpSrvtTable table.
 * Creates a new sccpSrvtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct sccpSrvtTable_data *
sccpSrvtTable_create(void)
{
	struct sccpSrvtTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSrvtTable_data);

	DEBUGMSGTL(("sccpSrvtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->sccpMtpBackwardRoutingRequested = 2;
		StorageNew->sccpRouteTestRowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct sccpSrvtTable_data *sccpSrvtTable_duplicate(struct sccpSrvtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct sccpSrvtTable_data *
sccpSrvtTable_duplicate(struct sccpSrvtTable_data *thedata)
{
	struct sccpSrvtTable_data *StorageNew = SNMP_MALLOC_STRUCT(sccpSrvtTable_data);

	DEBUGMSGTL(("sccpSrvtTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	sccpSrvtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int sccpSrvtTable_destroy(struct sccpSrvtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
sccpSrvtTable_destroy(struct sccpSrvtTable_data **thedata)
{
	struct sccpSrvtTable_data *StorageDel;

	DEBUGMSGTL(("sccpSrvtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->sccpRouteTestId);
		StorageDel->sccpRouteTestIdLen = 0;
		SNMP_FREE(StorageDel->sccpSrvtName);
		StorageDel->sccpSrvtNameLen = 0;
		SNMP_FREE(StorageDel->sccpProceduralStatus);
		StorageDel->sccpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->sccpOriginalGT);
		StorageDel->sccpOriginalGTLen = 0;
		SNMP_FREE(StorageDel->sccpInfoRequest);
		StorageDel->sccpInfoRequestLen = 0;
		SNMP_FREE(StorageDel->sccpReturnUnknownParams);
		StorageDel->sccpReturnUnknownParamsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSrvtTable_add(struct sccpSrvtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the sccpSrvtTable table data set.
 * Adds a table row structure to the sccpSrvtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
sccpSrvtTable_add(struct sccpSrvtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSrvtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpRouteTestId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->sccpRouteTestId, thedata->sccpRouteTestIdLen);
	header_complex_add_data(&sccpSrvtTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSrvtTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int sccpSrvtTable_del(struct sccpSrvtTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the sccpSrvtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
sccpSrvtTable_del(struct sccpSrvtTable_data *thedata)
{
	struct sccpSrvtTable_data *StorageDel;

	DEBUGMSGTL(("sccpSrvtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(sccpSrvtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&sccpSrvtTableStorage, hciptr);
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_sccpSrvtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for sccpSrvtTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case sccpSrvtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_sccpSrvtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSrvtTable_data *StorageTmp = sccpSrvtTable_create();

	DEBUGMSGTL(("sccpSrvtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRouteTestId, &StorageTmp->sccpRouteTestIdLen);
	if (StorageTmp->sccpRouteTestId == NULL) {
		config_perror("invalid specification for sccpRouteTestId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpDSRVT, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNSRVT, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSrvtName, &StorageTmp->sccpSrvtNameLen);
	if (StorageTmp->sccpSrvtName == NULL) {
		config_perror("invalid specification for sccpSrvtName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpProceduralStatus, &StorageTmp->sccpProceduralStatusLen);
	if (StorageTmp->sccpProceduralStatus == NULL) {
		config_perror("invalid specification for sccpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpTraceRequested, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpThreshold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpMtpBackwardRoutingRequested, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpOriginalGT, &StorageTmp->sccpOriginalGTLen);
	if (StorageTmp->sccpOriginalGT == NULL) {
		config_perror("invalid specification for sccpOriginalGT");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpInfoRequest, &StorageTmp->sccpInfoRequestLen);
	if (StorageTmp->sccpInfoRequest == NULL) {
		config_perror("invalid specification for sccpInfoRequest");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpReturnUnknownParams, &StorageTmp->sccpReturnUnknownParamsLen);
	if (StorageTmp->sccpReturnUnknownParams == NULL) {
		config_perror("invalid specification for sccpReturnUnknownParams");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRouteTestRowStatus, &tmpsize);
	sccpSrvtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
}

/*
 * store_sccpSrvtTable(): store configuraiton file for sccpSrvtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_sccpSrvtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSrvtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSrvtTable", "storing data...  "));
	refresh_sccpSrvtTable();
	(void) tmpsize;
	for (hcindex = sccpSrvtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSrvtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "sccpSrvtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRouteTestId, &StorageTmp->sccpRouteTestIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpDSRVT, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNSRVT, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSrvtName, &StorageTmp->sccpSrvtNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpProceduralStatus, &StorageTmp->sccpProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpTraceRequested, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpThreshold, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpMtpBackwardRoutingRequested, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpOriginalGT, &StorageTmp->sccpOriginalGTLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpInfoRequest, &StorageTmp->sccpInfoRequestLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpReturnUnknownParams, &StorageTmp->sccpReturnUnknownParamsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRouteTestRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_sccpNetworkEntityTable(void)
 * @brief refresh the scalar values of the sccpNetworkEntityTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpNetworkEntityTable(void)
{
	if (sccpNetworkEntityTable_refresh == 0)
		return;
	sccpNetworkEntityTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpNetworkEntityTable_row(struct sccpNetworkEntityTable_data *StorageTmp)
 * @brief refresh the contents of the sccpNetworkEntityTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpNetworkEntityTable_row(struct sccpNetworkEntityTable_data *StorageTmp)
{
	if (StorageTmp->sccpNetworkEntityTable_request == sa_request)
		return;
	StorageTmp->sccpNetworkEntityTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpNetworkEntityTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpNetworkEntityTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpNetworkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpNetworkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpNetworkEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpNetworkEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPNETWORKENTITYALARMSTATUS:
		*write_method = write_sccpNetworkEntityAlarmStatus;
		*var_len = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		return (u_char *) StorageTmp->sccpNetworkEntityAlarmStatus;
	case SCCPSYSTEMTYPES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpSystemTypesLen;
		return (u_char *) StorageTmp->sccpSystemTypes;
	case SCCPVERSION:
		*write_method = write_sccpVersion;
		*var_len = StorageTmp->sccpVersionLen;
		return (u_char *) StorageTmp->sccpVersion;
	case SCCPLUDTANDLUDTSSUPPORTED:
		*write_method = write_sccpLUDTandLUDTSSupported;
		*var_len = sizeof(StorageTmp->sccpLUDTandLUDTSSupported);
		return (u_char *) &StorageTmp->sccpLUDTandLUDTSSupported;
	case SCCPCOORDCHANGETIMER:
		*write_method = write_sccpCoordChangeTimer;
		*var_len = sizeof(StorageTmp->sccpCoordChangeTimer);
		return (u_char *) &StorageTmp->sccpCoordChangeTimer;
	case SCCPIGNORESSTTIMER:
		*write_method = write_sccpIgnoreSSTTimer;
		*var_len = sizeof(StorageTmp->sccpIgnoreSSTTimer);
		return (u_char *) &StorageTmp->sccpIgnoreSSTTimer;
	case SCCPMAXSTATINFOTIMER:
		*write_method = write_sccpMaxStatInfoTimer;
		*var_len = sizeof(StorageTmp->sccpMaxStatInfoTimer);
		return (u_char *) &StorageTmp->sccpMaxStatInfoTimer;
	case SCCPNETWORKENTITYNAME:
		*write_method = write_sccpNetworkEntityName;
		*var_len = StorageTmp->sccpNetworkEntityNameLen;
		return (u_char *) StorageTmp->sccpNetworkEntityName;
	case SCCPROWSTATUS:
		*write_method = write_sccpRowStatus;
		*var_len = sizeof(StorageTmp->sccpRowStatus);
		return (u_char *) &StorageTmp->sccpRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpSapNameTable(void)
 * @brief refresh the scalar values of the sccpSapNameTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpSapNameTable(void)
{
	if (sccpSapNameTable_refresh == 0)
		return;
	sccpSapNameTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpSapNameTable_row(struct sccpSapNameTable_data *StorageTmp)
 * @brief refresh the contents of the sccpSapNameTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpSapNameTable_row(struct sccpSapNameTable_data *StorageTmp)
{
	if (StorageTmp->sccpSapNameTable_request == sa_request)
		return;
	StorageTmp->sccpSapNameTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpSapNameTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpSapNameTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpSapNameTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSapNameTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpSapNameTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpSapNameTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpSapNameTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpSapNameTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPSAPNAMEROWSTATUS:
		*write_method = write_sccpSapNameRowStatus;
		*var_len = sizeof(StorageTmp->sccpSapNameRowStatus);
		return (u_char *) &StorageTmp->sccpSapNameRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpAccessPointTable(void)
 * @brief refresh the scalar values of the sccpAccessPointTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpAccessPointTable(void)
{
	if (sccpAccessPointTable_refresh == 0)
		return;
	sccpAccessPointTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpAccessPointTable_row(struct sccpAccessPointTable_data *StorageTmp)
 * @brief refresh the contents of the sccpAccessPointTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpAccessPointTable_row(struct sccpAccessPointTable_data *StorageTmp)
{
	if (StorageTmp->sccpAccessPointTable_request == sa_request)
		return;
	StorageTmp->sccpAccessPointTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpAccessPointTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpAccessPointTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpAccessPointTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpAccessPointTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpAccessPointTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpAccessPointTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpAccessPointTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPACCESSPOINTALARMSTATUS:
		*write_method = write_sccpAccessPointAlarmStatus;
		*var_len = StorageTmp->sccpAccessPointAlarmStatusLen;
		return (u_char *) StorageTmp->sccpAccessPointAlarmStatus;
	case SCCPSAP2ADDRESS:
		*write_method = write_sccpSap2Address;
		*var_len = StorageTmp->sccpSap2AddressLen;
		return (u_char *) StorageTmp->sccpSap2Address;
	case SCCPUSERENTITYNAMES:
		*write_method = write_sccpUserEntityNames;
		*var_len = StorageTmp->sccpUserEntityNamesLen;
		return (u_char *) StorageTmp->sccpUserEntityNames;
	case SCCPPROVIDERENTITYNAMES:
		*write_method = write_sccpProviderEntityNames;
		*var_len = StorageTmp->sccpProviderEntityNamesLen;
		return (u_char *) StorageTmp->sccpProviderEntityNames;
	case SCCPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpAvailabilityStatusLen;
		return (u_char *) StorageTmp->sccpAvailabilityStatus;
	case SCCPCONCERNEDAREAPOINTER:
		*write_method = write_sccpConcernedAreaPointer;
		*var_len = sizeof(StorageTmp->sccpConcernedAreaPointer);
		return (u_char *) &StorageTmp->sccpConcernedAreaPointer;
	case SCCPLINKAGEPOINTER:
		*write_method = write_sccpLinkagePointer;
		*var_len = sizeof(StorageTmp->sccpLinkagePointer);
		return (u_char *) &StorageTmp->sccpLinkagePointer;
	case SCCPSSAVAILABLEAFTERSPRESTART:
		*write_method = write_sccpSsAvailableAfterSpRestart;
		*var_len = sizeof(StorageTmp->sccpSsAvailableAfterSpRestart);
		return (u_char *) &StorageTmp->sccpSsAvailableAfterSpRestart;
	case SCCPACCESSPOINTNAME:
		*write_method = write_sccpAccessPointName;
		*var_len = StorageTmp->sccpAccessPointNameLen;
		return (u_char *) StorageTmp->sccpAccessPointName;
	case SCCPACCESSPOINTROWSTATUS:
		*write_method = write_sccpAccessPointRowStatus;
		*var_len = sizeof(StorageTmp->sccpAccessPointRowStatus);
		return (u_char *) &StorageTmp->sccpAccessPointRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpLinkageTable(void)
 * @brief refresh the scalar values of the sccpLinkageTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpLinkageTable(void)
{
	if (sccpLinkageTable_refresh == 0)
		return;
	sccpLinkageTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpLinkageTable_row(struct sccpLinkageTable_data *StorageTmp)
 * @brief refresh the contents of the sccpLinkageTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpLinkageTable_row(struct sccpLinkageTable_data *StorageTmp)
{
	if (StorageTmp->sccpLinkageTable_request == sa_request)
		return;
	StorageTmp->sccpLinkageTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpLinkageTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpLinkageTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpLinkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpLinkageTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpLinkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpLinkageTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpLinkageTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPOPERATIONALPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpOperationalProtocolsLen;
		return (u_char *) StorageTmp->sccpOperationalProtocols;
	case SCCPSNSAP:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpSnSAPLen;
		return (u_char *) StorageTmp->sccpSnSAP;
	case SCCPATTACKTIMERVALUE:
		*write_method = write_sccpAttackTimerValue;
		*var_len = sizeof(StorageTmp->sccpAttackTimerValue);
		return (u_char *) &StorageTmp->sccpAttackTimerValue;
	case SCCPDECAYTIMERVALUE:
		*write_method = write_sccpDecayTimerValue;
		*var_len = sizeof(StorageTmp->sccpDecayTimerValue);
		return (u_char *) &StorageTmp->sccpDecayTimerValue;
	case SCCPNROFRESTRICTIONLEVELS:
		*write_method = write_sccpNrOfRestrictionLevels;
		*var_len = sizeof(StorageTmp->sccpNrOfRestrictionLevels);
		return (u_char *) &StorageTmp->sccpNrOfRestrictionLevels;
	case SCCPNROFSUBLEVELS:
		*write_method = write_sccpNrOfSubLevels;
		*var_len = sizeof(StorageTmp->sccpNrOfSubLevels);
		return (u_char *) &StorageTmp->sccpNrOfSubLevels;
	case SCCPCLS:
		*write_method = write_sccpCLS;
		*var_len = sizeof(StorageTmp->sccpCLS);
		return (u_char *) &StorageTmp->sccpCLS;
	case SCCPCONGESTIONTIMERVALUE:
		*write_method = write_sccpCongestionTimerValue;
		*var_len = sizeof(StorageTmp->sccpCongestionTimerValue);
		return (u_char *) &StorageTmp->sccpCongestionTimerValue;
	case SCCPP:
		*write_method = write_sccpp;
		*var_len = sizeof(StorageTmp->sccpp);
		return (u_char *) &StorageTmp->sccpp;
	case SCCPIMPORTANCELEVELCR:
		*write_method = write_sccpImportanceLevelCR;
		*var_len = StorageTmp->sccpImportanceLevelCRLen;
		return (u_char *) StorageTmp->sccpImportanceLevelCR;
	case SCCPIMPORTANCELEVELCC:
		*write_method = write_sccpImportanceLevelCC;
		*var_len = StorageTmp->sccpImportanceLevelCCLen;
		return (u_char *) StorageTmp->sccpImportanceLevelCC;
	case SCCPIMPORTANCELEVELCREF:
		*write_method = write_sccpImportanceLevelCREF;
		*var_len = StorageTmp->sccpImportanceLevelCREFLen;
		return (u_char *) StorageTmp->sccpImportanceLevelCREF;
	case SCCPIMPORTANCELEVELDT1:
		*write_method = write_sccpImportanceLevelDT1;
		*var_len = StorageTmp->sccpImportanceLevelDT1Len;
		return (u_char *) StorageTmp->sccpImportanceLevelDT1;
	case SCCPIMPORTANCELEVELDT2:
		*write_method = write_sccpImportanceLevelDT2;
		*var_len = StorageTmp->sccpImportanceLevelDT2Len;
		return (u_char *) StorageTmp->sccpImportanceLevelDT2;
	case SCCPIMPORTANCELEVELAK:
		*write_method = write_sccpImportanceLevelAK;
		*var_len = StorageTmp->sccpImportanceLevelAKLen;
		return (u_char *) StorageTmp->sccpImportanceLevelAK;
	case SCCPIMPORTANCELEVELIT:
		*write_method = write_sccpImportanceLevelIT;
		*var_len = StorageTmp->sccpImportanceLevelITLen;
		return (u_char *) StorageTmp->sccpImportanceLevelIT;
	case SCCPIMPORTANCELEVELED:
		*write_method = write_sccpImportanceLevelED;
		*var_len = StorageTmp->sccpImportanceLevelEDLen;
		return (u_char *) StorageTmp->sccpImportanceLevelED;
	case SCCPIMPORTANCELEVELEA:
		*write_method = write_sccpImportanceLevelEA;
		*var_len = StorageTmp->sccpImportanceLevelEALen;
		return (u_char *) StorageTmp->sccpImportanceLevelEA;
	case SCCPIMPORTANCELEVELRSR:
		*write_method = write_sccpImportanceLevelRSR;
		*var_len = StorageTmp->sccpImportanceLevelRSRLen;
		return (u_char *) StorageTmp->sccpImportanceLevelRSR;
	case SCCPIMPORTANCELEVELRSC:
		*write_method = write_sccpImportanceLevelRSC;
		*var_len = StorageTmp->sccpImportanceLevelRSCLen;
		return (u_char *) StorageTmp->sccpImportanceLevelRSC;
	case SCCPIMPORTANCELEVELERR:
		*write_method = write_sccpImportanceLevelERR;
		*var_len = StorageTmp->sccpImportanceLevelERRLen;
		return (u_char *) StorageTmp->sccpImportanceLevelERR;
	case SCCPIMPORTANCELEVELRLC:
		*write_method = write_sccpImportanceLevelRLC;
		*var_len = StorageTmp->sccpImportanceLevelRLCLen;
		return (u_char *) StorageTmp->sccpImportanceLevelRLC;
	case SCCPIMPORTANCELEVELRLSD:
		*write_method = write_sccpImportanceLevelRLSD;
		*var_len = StorageTmp->sccpImportanceLevelRLSDLen;
		return (u_char *) StorageTmp->sccpImportanceLevelRLSD;
	case SCCPIMPORTANCELEVELUDT:
		*write_method = write_sccpImportanceLevelUDT;
		*var_len = StorageTmp->sccpImportanceLevelUDTLen;
		return (u_char *) StorageTmp->sccpImportanceLevelUDT;
	case SCCPIMPORTANCELEVELUDTS:
		*write_method = write_sccpImportanceLevelUDTS;
		*var_len = StorageTmp->sccpImportanceLevelUDTSLen;
		return (u_char *) StorageTmp->sccpImportanceLevelUDTS;
	case SCCPIMPORTANCELEVELXUDT:
		*write_method = write_sccpImportanceLevelXUDT;
		*var_len = StorageTmp->sccpImportanceLevelXUDTLen;
		return (u_char *) StorageTmp->sccpImportanceLevelXUDT;
	case SCCPIMPORTANCELEVELXUDTS:
		*write_method = write_sccpImportanceLevelXUDTS;
		*var_len = StorageTmp->sccpImportanceLevelXUDTSLen;
		return (u_char *) StorageTmp->sccpImportanceLevelXUDTS;
	case SCCPIMPORTANCELEVELLUDT:
		*write_method = write_sccpImportanceLevelLUDT;
		*var_len = StorageTmp->sccpImportanceLevelLUDTLen;
		return (u_char *) StorageTmp->sccpImportanceLevelLUDT;
	case SCCPIMPORTANCELEVELLUDTS:
		*write_method = write_sccpImportanceLevelLUDTS;
		*var_len = StorageTmp->sccpImportanceLevelLUDTSLen;
		return (u_char *) StorageTmp->sccpImportanceLevelLUDTS;
	case SCCPRLM:
		*write_method = write_sccpRLM;
		*var_len = sizeof(StorageTmp->sccpRLM);
		return (u_char *) &StorageTmp->sccpRLM;
	case SCCPRSLM:
		*write_method = write_sccpRSLM;
		*var_len = sizeof(StorageTmp->sccpRSLM);
		return (u_char *) &StorageTmp->sccpRSLM;
	case SCCPLINKAGECONCERNEDAREAPOINTER:
		*write_method = write_sccpLinkageConcernedAreaPointer;
		*var_len = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		return (u_char *) StorageTmp->sccpLinkageConcernedAreaPointer;
	case SCCPLOWERLIMITFORSEGMENTATION:
		*write_method = write_sccpLowerLimitForSegmentation;
		*var_len = sizeof(StorageTmp->sccpLowerLimitForSegmentation);
		return (u_char *) &StorageTmp->sccpLowerLimitForSegmentation;
	case SCCPUPPERLIMITFORSEGMENTATION:
		*write_method = write_sccpUpperLimitForSegmentation;
		*var_len = sizeof(StorageTmp->sccpUpperLimitForSegmentation);
		return (u_char *) &StorageTmp->sccpUpperLimitForSegmentation;
	case SCCPLINKAGENAME:
		*write_method = write_sccpLinkageName;
		*var_len = StorageTmp->sccpLinkageNameLen;
		return (u_char *) StorageTmp->sccpLinkageName;
	case SCCPLINKAGEROWSTATUS:
		*write_method = write_sccpLinkageRowStatus;
		*var_len = sizeof(StorageTmp->sccpLinkageRowStatus);
		return (u_char *) &StorageTmp->sccpLinkageRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpSclcTable(void)
 * @brief refresh the scalar values of the sccpSclcTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpSclcTable(void)
{
	if (sccpSclcTable_refresh == 0)
		return;
	sccpSclcTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpSclcTable_row(struct sccpSclcTable_data *StorageTmp)
 * @brief refresh the contents of the sccpSclcTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpSclcTable_row(struct sccpSclcTable_data *StorageTmp)
{
	if (StorageTmp->sccpSclcTable_request == sa_request)
		return;
	StorageTmp->sccpSclcTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpSclcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpSclcTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpSclcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSclcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpSclcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpSclcTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpSclcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpSclcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPSCLCALARMSTATUS:
		*write_method = write_sccpSclcAlarmStatus;
		*var_len = StorageTmp->sccpSclcAlarmStatusLen;
		return (u_char *) StorageTmp->sccpSclcAlarmStatus;
	case SCCPSCLCOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpSclcOperationalState);
		return (u_char *) &StorageTmp->sccpSclcOperationalState;
	case SCCPTOTALREMOTESAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpTotalRemoteSAPs);
		return (u_char *) &StorageTmp->sccpTotalRemoteSAPs;
	case SCCPSCLCADMINISTRATIVESTATE:
		*write_method = write_sccpSclcAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpSclcAdministrativeState);
		return (u_char *) &StorageTmp->sccpSclcAdministrativeState;
	case SCCPSCLCSUPPORTEDPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpSclcSupportedProtocolsLen;
		return (u_char *) StorageTmp->sccpSclcSupportedProtocols;
	case SCCPSCLCOPERATIONALSYSTEMTYPE:
		*write_method = write_sccpSclcOperationalSystemType;
		*var_len = sizeof(StorageTmp->sccpSclcOperationalSystemType);
		return (u_char *) &StorageTmp->sccpSclcOperationalSystemType;
	case SCCPINITIALVALUEREASSTIMER:
		*write_method = write_sccpInitialValueReassTimer;
		*var_len = sizeof(StorageTmp->sccpInitialValueReassTimer);
		return (u_char *) &StorageTmp->sccpInitialValueReassTimer;
	case SCCPSCLCNAME:
		*write_method = write_sccpSclcName;
		*var_len = StorageTmp->sccpSclcNameLen;
		return (u_char *) StorageTmp->sccpSclcName;
	case SCCPSCLCROWSTATUS:
		*write_method = write_sccpSclcRowStatus;
		*var_len = sizeof(StorageTmp->sccpSclcRowStatus);
		return (u_char *) &StorageTmp->sccpSclcRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpScocTable(void)
 * @brief refresh the scalar values of the sccpScocTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpScocTable(void)
{
	if (sccpScocTable_refresh == 0)
		return;
	sccpScocTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpScocTable_row(struct sccpScocTable_data *StorageTmp)
 * @brief refresh the contents of the sccpScocTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpScocTable_row(struct sccpScocTable_data *StorageTmp)
{
	if (StorageTmp->sccpScocTable_request == sa_request)
		return;
	StorageTmp->sccpScocTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpScocTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpScocTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpScocTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpScocTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpScocTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpScocTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpScocTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpScocTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPCOPROTOCOLMACHINEID:
		*write_method = write_sccpCoProtocolMachineId;
		*var_len = StorageTmp->sccpCoProtocolMachineIdLen;
		return (u_char *) StorageTmp->sccpCoProtocolMachineId;
	case SCCPSCOCOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpScocOperationalState);
		return (u_char *) &StorageTmp->sccpScocOperationalState;
	case SCCPSCOCADMINISTRATIVESTATE:
		*write_method = write_sccpScocAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpScocAdministrativeState);
		return (u_char *) &StorageTmp->sccpScocAdministrativeState;
	case SCCPSCOCOPERATIONALSYSTEMTYPE:
		*write_method = write_sccpScocOperationalSystemType;
		*var_len = sizeof(StorageTmp->sccpScocOperationalSystemType);
		return (u_char *) &StorageTmp->sccpScocOperationalSystemType;
	case SCCPSCOCSUPPORTEDPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpScocSupportedProtocolsLen;
		return (u_char *) StorageTmp->sccpScocSupportedProtocols;
	case SCCPSCOCNAME:
		*write_method = write_sccpScocName;
		*var_len = StorageTmp->sccpScocNameLen;
		return (u_char *) StorageTmp->sccpScocName;
	case SCCPSCOCROWSTATUS:
		*write_method = write_sccpScocRowStatus;
		*var_len = sizeof(StorageTmp->sccpScocRowStatus);
		return (u_char *) &StorageTmp->sccpScocRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpScrcTable(void)
 * @brief refresh the scalar values of the sccpScrcTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpScrcTable(void)
{
	if (sccpScrcTable_refresh == 0)
		return;
	sccpScrcTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpScrcTable_row(struct sccpScrcTable_data *StorageTmp)
 * @brief refresh the contents of the sccpScrcTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpScrcTable_row(struct sccpScrcTable_data *StorageTmp)
{
	if (StorageTmp->sccpScrcTable_request == sa_request)
		return;
	StorageTmp->sccpScrcTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpScrcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpScrcTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpScrcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpScrcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpScrcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpScrcTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpScrcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpScrcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPSCRCID:
		*write_method = write_sccpScrcId;
		*var_len = StorageTmp->sccpScrcIdLen;
		return (u_char *) StorageTmp->sccpScrcId;
	case SCCPSCRCALARMSTATUS:
		*write_method = write_sccpScrcAlarmStatus;
		*var_len = StorageTmp->sccpScrcAlarmStatusLen;
		return (u_char *) StorageTmp->sccpScrcAlarmStatus;
	case SCCPSCRCNAME:
		*write_method = write_sccpScrcName;
		*var_len = StorageTmp->sccpScrcNameLen;
		return (u_char *) StorageTmp->sccpScrcName;
	case SCCPSCRCROWSTATUS:
		*write_method = write_sccpScrcRowStatus;
		*var_len = sizeof(StorageTmp->sccpScrcRowStatus);
		return (u_char *) &StorageTmp->sccpScrcRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpEntitySetTable(void)
 * @brief refresh the scalar values of the sccpEntitySetTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpEntitySetTable(void)
{
	if (sccpEntitySetTable_refresh == 0)
		return;
	sccpEntitySetTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpEntitySetTable_row(struct sccpEntitySetTable_data *StorageTmp)
 * @brief refresh the contents of the sccpEntitySetTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpEntitySetTable_row(struct sccpEntitySetTable_data *StorageTmp)
{
	if (StorageTmp->sccpEntitySetTable_request == sa_request)
		return;
	StorageTmp->sccpEntitySetTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpEntitySetTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpEntitySetTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpEntitySetTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpEntitySetTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpEntitySetTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpEntitySetTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpEntitySetTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPSHARINGMODE:
		*write_method = write_sccpSharingMode;
		*var_len = sizeof(StorageTmp->sccpSharingMode);
		return (u_char *) &StorageTmp->sccpSharingMode;
	case SCCPLOADSHARINGALGPOINTER:
		*write_method = write_sccpLoadSharingAlgPointer;
		*var_len = StorageTmp->sccpLoadSharingAlgPointerLen;
		return (u_char *) StorageTmp->sccpLoadSharingAlgPointer;
	case SCCPENTITYSETNAME:
		*write_method = write_sccpEntitySetName;
		*var_len = StorageTmp->sccpEntitySetNameLen;
		return (u_char *) StorageTmp->sccpEntitySetName;
	case SCCPENTITYSETTYPE:
		*write_method = write_sccpEntitySetType;
		*var_len = sizeof(StorageTmp->sccpEntitySetType);
		return (u_char *) &StorageTmp->sccpEntitySetType;
	case SCCPENTITYSETSSN:
		*write_method = write_sccpEntitySetSsn;
		*var_len = StorageTmp->sccpEntitySetSsnLen;
		return (u_char *) StorageTmp->sccpEntitySetSsn;
	case SCCPENTITYSETROWSTATUS:
		*write_method = write_sccpEntitySetRowStatus;
		*var_len = sizeof(StorageTmp->sccpEntitySetRowStatus);
		return (u_char *) &StorageTmp->sccpEntitySetRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpEntitySetSapTable(void)
 * @brief refresh the scalar values of the sccpEntitySetSapTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpEntitySetSapTable(void)
{
	if (sccpEntitySetSapTable_refresh == 0)
		return;
	sccpEntitySetSapTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpEntitySetSapTable_row(struct sccpEntitySetSapTable_data *StorageTmp)
 * @brief refresh the contents of the sccpEntitySetSapTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpEntitySetSapTable_row(struct sccpEntitySetSapTable_data *StorageTmp)
{
	if (StorageTmp->sccpEntitySetSapTable_request == sa_request)
		return;
	StorageTmp->sccpEntitySetSapTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpEntitySetSapTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpEntitySetSapTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpEntitySetSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpEntitySetSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpEntitySetSapTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpEntitySetSapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpEntitySetSapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPENTITYSETSAPTYPE:
		*write_method = write_sccpEntitySetSapType;
		*var_len = sizeof(StorageTmp->sccpEntitySetSapType);
		return (u_char *) &StorageTmp->sccpEntitySetSapType;
	case SCCPENTITYSETSAPPOINTER:
		*write_method = write_sccpEntitySetSapPointer;
		*var_len = StorageTmp->sccpEntitySetSapPointerLen;
		return (u_char *) StorageTmp->sccpEntitySetSapPointer;
	case SCCPENTITYSETSAPROWSTATUS:
		*write_method = write_sccpEntitySetSapRowStatus;
		*var_len = sizeof(StorageTmp->sccpEntitySetSapRowStatus);
		return (u_char *) &StorageTmp->sccpEntitySetSapRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpConcernedAreaTable(void)
 * @brief refresh the scalar values of the sccpConcernedAreaTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpConcernedAreaTable(void)
{
	if (sccpConcernedAreaTable_refresh == 0)
		return;
	sccpConcernedAreaTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpConcernedAreaTable_row(struct sccpConcernedAreaTable_data *StorageTmp)
 * @brief refresh the contents of the sccpConcernedAreaTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpConcernedAreaTable_row(struct sccpConcernedAreaTable_data *StorageTmp)
{
	if (StorageTmp->sccpConcernedAreaTable_request == sa_request)
		return;
	StorageTmp->sccpConcernedAreaTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpConcernedAreaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpConcernedAreaTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpConcernedAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpConcernedAreaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpConcernedAreaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpConcernedAreaTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpConcernedAreaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpConcernedAreaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpRemoteSCCPTable(void)
 * @brief refresh the scalar values of the sccpRemoteSCCPTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpRemoteSCCPTable(void)
{
	if (sccpRemoteSCCPTable_refresh == 0)
		return;
	sccpRemoteSCCPTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpRemoteSCCPTable_row(struct sccpRemoteSCCPTable_data *StorageTmp)
 * @brief refresh the contents of the sccpRemoteSCCPTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpRemoteSCCPTable_row(struct sccpRemoteSCCPTable_data *StorageTmp)
{
	if (StorageTmp->sccpRemoteSCCPTable_request == sa_request)
		return;
	StorageTmp->sccpRemoteSCCPTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpRemoteSCCPTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpRemoteSCCPTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpRemoteSCCPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpRemoteSCCPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpRemoteSCCPTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpRemoteSCCPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpRemoteSCCPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPREMOTESCCPMTPACCESSPOINT:
		*write_method = write_sccpRemoteSCCPMTPAccessPoint;
		*var_len = StorageTmp->sccpRemoteSCCPMTPAccessPointLen;
		return (u_char *) StorageTmp->sccpRemoteSCCPMTPAccessPoint;
	case SCCPREMOTESCCPNAME:
		*write_method = write_sccpRemoteSCCPName;
		*var_len = StorageTmp->sccpRemoteSCCPNameLen;
		return (u_char *) StorageTmp->sccpRemoteSCCPName;
	case SCCPREMOTESCCPROWSTATUS:
		*write_method = write_sccpRemoteSCCPRowStatus;
		*var_len = sizeof(StorageTmp->sccpRemoteSCCPRowStatus);
		return (u_char *) &StorageTmp->sccpRemoteSCCPRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpGtConversionRuleTable(void)
 * @brief refresh the scalar values of the sccpGtConversionRuleTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpGtConversionRuleTable(void)
{
	if (sccpGtConversionRuleTable_refresh == 0)
		return;
	sccpGtConversionRuleTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpGtConversionRuleTable_row(struct sccpGtConversionRuleTable_data *StorageTmp)
 * @brief refresh the contents of the sccpGtConversionRuleTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpGtConversionRuleTable_row(struct sccpGtConversionRuleTable_data *StorageTmp)
{
	if (StorageTmp->sccpGtConversionRuleTable_request == sa_request)
		return;
	StorageTmp->sccpGtConversionRuleTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpGtConversionRuleTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpGtConversionRuleTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpGtConversionRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtConversionRuleTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpGtConversionRuleTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpGtConversionRuleTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPGTNEWENCODINGSCHEME:
		*write_method = write_sccpGtNewEncodingScheme;
		*var_len = sizeof(StorageTmp->sccpGtNewEncodingScheme);
		return (u_char *) &StorageTmp->sccpGtNewEncodingScheme;
	case SCCPGTNEWNATUREOFADDRESS:
		*write_method = write_sccpGtNewNatureOfAddress;
		*var_len = sizeof(StorageTmp->sccpGtNewNatureOfAddress);
		return (u_char *) &StorageTmp->sccpGtNewNatureOfAddress;
	case SCCPGTNEWNUMBERINGPLAN:
		*write_method = write_sccpGtNewNumberingPlan;
		*var_len = sizeof(StorageTmp->sccpGtNewNumberingPlan);
		return (u_char *) &StorageTmp->sccpGtNewNumberingPlan;
	case SCCPGTNEWTRANSLATIONTYPE:
		*write_method = write_sccpGtNewTranslationType;
		*var_len = sizeof(StorageTmp->sccpGtNewTranslationType);
		return (u_char *) &StorageTmp->sccpGtNewTranslationType;
	case SCCPGTCONVERSIONRULENAME:
		*write_method = write_sccpGtConversionRuleName;
		*var_len = StorageTmp->sccpGtConversionRuleNameLen;
		return (u_char *) StorageTmp->sccpGtConversionRuleName;
	case SCCPGTCONVERSIONRULEROWSTATUS:
		*write_method = write_sccpGtConversionRuleRowStatus;
		*var_len = sizeof(StorageTmp->sccpGtConversionRuleRowStatus);
		return (u_char *) &StorageTmp->sccpGtConversionRuleRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpAddressInfoTable(void)
 * @brief refresh the scalar values of the sccpAddressInfoTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpAddressInfoTable(void)
{
	if (sccpAddressInfoTable_refresh == 0)
		return;
	sccpAddressInfoTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpAddressInfoTable_row(struct sccpAddressInfoTable_data *StorageTmp)
 * @brief refresh the contents of the sccpAddressInfoTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpAddressInfoTable_row(struct sccpAddressInfoTable_data *StorageTmp)
{
	if (StorageTmp->sccpAddressInfoTable_request == sa_request)
		return;
	StorageTmp->sccpAddressInfoTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpAddressInfoTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpAddressInfoTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpAddressInfoTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpAddressInfoTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpAddressInfoTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpAddressInfoTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpAddressInfoTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPADDRESSINFOOPERATION:
		*write_method = write_sccpAddressInfoOperation;
		*var_len = sizeof(StorageTmp->sccpAddressInfoOperation);
		return (u_char *) &StorageTmp->sccpAddressInfoOperation;
	case SCCPADDRESSINFOADDRESSELEMENT:
		*write_method = write_sccpAddressInfoAddressElement;
		*var_len = sizeof(StorageTmp->sccpAddressInfoAddressElement);
		return (u_char *) &StorageTmp->sccpAddressInfoAddressElement;
	case SCCPADDRESSINFONROFADDRESSELEMENTS:
		*write_method = write_sccpAddressInfoNrOfAddressElements;
		*var_len = sizeof(StorageTmp->sccpAddressInfoNrOfAddressElements);
		return (u_char *) &StorageTmp->sccpAddressInfoNrOfAddressElements;
	case SCCPADDRESSINFOROWSTATUS:
		*write_method = write_sccpAddressInfoRowStatus;
		*var_len = sizeof(StorageTmp->sccpAddressInfoRowStatus);
		return (u_char *) &StorageTmp->sccpAddressInfoRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpGtTranslatorTable(void)
 * @brief refresh the scalar values of the sccpGtTranslatorTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpGtTranslatorTable(void)
{
	if (sccpGtTranslatorTable_refresh == 0)
		return;
	sccpGtTranslatorTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpGtTranslatorTable_row(struct sccpGtTranslatorTable_data *StorageTmp)
 * @brief refresh the contents of the sccpGtTranslatorTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpGtTranslatorTable_row(struct sccpGtTranslatorTable_data *StorageTmp)
{
	if (StorageTmp->sccpGtTranslatorTable_request == sa_request)
		return;
	StorageTmp->sccpGtTranslatorTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpGtTranslatorTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpGtTranslatorTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpGtTranslatorTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtTranslatorTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpGtTranslatorTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpGtTranslatorTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPGTINDICATOR:
		*write_method = write_sccpGtIndicator;
		*var_len = sizeof(StorageTmp->sccpGtIndicator);
		return (u_char *) &StorageTmp->sccpGtIndicator;
	case SCCPGTNATUREOFADDRESS:
		*write_method = write_sccpGtNatureOfAddress;
		*var_len = sizeof(StorageTmp->sccpGtNatureOfAddress);
		return (u_char *) &StorageTmp->sccpGtNatureOfAddress;
	case SCCPGTNUMBERINGPLAN:
		*write_method = write_sccpGtNumberingPlan;
		*var_len = sizeof(StorageTmp->sccpGtNumberingPlan);
		return (u_char *) &StorageTmp->sccpGtNumberingPlan;
	case SCCPGTTRANSLATIONTYPE:
		*write_method = write_sccpGtTranslationType;
		*var_len = sizeof(StorageTmp->sccpGtTranslationType);
		return (u_char *) &StorageTmp->sccpGtTranslationType;
	case SCCPGTTRANSLATORADMINISTRATIVESTATE:
		*write_method = write_sccpGtTranslatorAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpGtTranslatorAdministrativeState);
		return (u_char *) &StorageTmp->sccpGtTranslatorAdministrativeState;
	case SCCPGTTRANSLATORNAME:
		*write_method = write_sccpGtTranslatorName;
		*var_len = StorageTmp->sccpGtTranslatorNameLen;
		return (u_char *) StorageTmp->sccpGtTranslatorName;
	case SCCPGTTRANSLATORROWSTATUS:
		*write_method = write_sccpGtTranslatorRowStatus;
		*var_len = sizeof(StorageTmp->sccpGtTranslatorRowStatus);
		return (u_char *) &StorageTmp->sccpGtTranslatorRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpGtRuleTable(void)
 * @brief refresh the scalar values of the sccpGtRuleTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpGtRuleTable(void)
{
	if (sccpGtRuleTable_refresh == 0)
		return;
	sccpGtRuleTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpGtRuleTable_row(struct sccpGtRuleTable_data *StorageTmp)
 * @brief refresh the contents of the sccpGtRuleTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpGtRuleTable_row(struct sccpGtRuleTable_data *StorageTmp)
{
	if (StorageTmp->sccpGtRuleTable_request == sa_request)
		return;
	StorageTmp->sccpGtRuleTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpGtRuleTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpGtRuleTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpGtRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtRuleTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtRuleTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpGtRuleTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpGtRuleTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPGTRULEADMINISTRATIVESTATE:
		*write_method = write_sccpGtRuleAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpGtRuleAdministrativeState);
		return (u_char *) &StorageTmp->sccpGtRuleAdministrativeState;
	case SCCPGTADDRESSINFORMATION:
		*write_method = write_sccpGtAddressInformation;
		*var_len = StorageTmp->sccpGtAddressInformationLen;
		return (u_char *) StorageTmp->sccpGtAddressInformation;
	case SCCPGTCONVRULEPOINTER:
		*write_method = write_sccpGtConvRulePointer;
		*var_len = StorageTmp->sccpGtConvRulePointerLen;
		return (u_char *) StorageTmp->sccpGtConvRulePointer;
	case SCCPGTENCODINGSCHEME:
		*write_method = write_sccpGtEncodingScheme;
		*var_len = sizeof(StorageTmp->sccpGtEncodingScheme);
		return (u_char *) &StorageTmp->sccpGtEncodingScheme;
	case SCCPENTITYSETPOINTER:
		*write_method = write_sccpEntitySetPointer;
		*var_len = StorageTmp->sccpEntitySetPointerLen;
		return (u_char *) StorageTmp->sccpEntitySetPointer;
	case SCCPGTRULENAME:
		*write_method = write_sccpGtRuleName;
		*var_len = StorageTmp->sccpGtRuleNameLen;
		return (u_char *) StorageTmp->sccpGtRuleName;
	case SCCPGTRULEROWSTATUS:
		*write_method = write_sccpGtRuleRowStatus;
		*var_len = sizeof(StorageTmp->sccpGtRuleRowStatus);
		return (u_char *) &StorageTmp->sccpGtRuleRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_sccpSrvtTable(void)
 * @brief refresh the scalar values of the sccpSrvtTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_sccpSrvtTable(void)
{
	if (sccpSrvtTable_refresh == 0)
		return;
	sccpSrvtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_sccpSrvtTable_row(struct sccpSrvtTable_data *StorageTmp)
 * @brief refresh the contents of the sccpSrvtTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_sccpSrvtTable_row(struct sccpSrvtTable_data *StorageTmp)
{
	if (StorageTmp->sccpSrvtTable_request == sa_request)
		return;
	StorageTmp->sccpSrvtTable_request = sa_request;
}

/**
 * @fn u_char *var_sccpSrvtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in sccpSrvtTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_sccpMIB above.
 */
u_char *
var_sccpSrvtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSrvtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpSrvtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_sccpSrvtTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpSrvtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case SCCPDSRVT:
		*write_method = write_sccpDSRVT;
		*var_len = sizeof(StorageTmp->sccpDSRVT);
		return (u_char *) &StorageTmp->sccpDSRVT;
	case SCCPNSRVT:
		*write_method = write_sccpNSRVT;
		*var_len = sizeof(StorageTmp->sccpNSRVT);
		return (u_char *) &StorageTmp->sccpNSRVT;
	case SCCPSRVTNAME:
		*write_method = write_sccpSrvtName;
		*var_len = StorageTmp->sccpSrvtNameLen;
		return (u_char *) StorageTmp->sccpSrvtName;
	case SCCPADMINISTRATIVESTATE:
		*write_method = write_sccpAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpAdministrativeState);
		return (u_char *) &StorageTmp->sccpAdministrativeState;
	case SCCPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpOperationalState);
		return (u_char *) &StorageTmp->sccpOperationalState;
	case SCCPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpProceduralStatusLen;
		return (u_char *) StorageTmp->sccpProceduralStatus;
	case SCCPTRACEREQUESTED:
		*write_method = write_sccpTraceRequested;
		*var_len = sizeof(StorageTmp->sccpTraceRequested);
		return (u_char *) &StorageTmp->sccpTraceRequested;
	case SCCPTHRESHOLD:
		*write_method = write_sccpThreshold;
		*var_len = sizeof(StorageTmp->sccpThreshold);
		return (u_char *) &StorageTmp->sccpThreshold;
	case SCCPMTPBACKWARDROUTINGREQUESTED:
		*write_method = write_sccpMtpBackwardRoutingRequested;
		*var_len = sizeof(StorageTmp->sccpMtpBackwardRoutingRequested);
		return (u_char *) &StorageTmp->sccpMtpBackwardRoutingRequested;
	case SCCPORIGINALGT:
		*write_method = write_sccpOriginalGT;
		*var_len = StorageTmp->sccpOriginalGTLen;
		return (u_char *) StorageTmp->sccpOriginalGT;
	case SCCPINFOREQUEST:
		*write_method = write_sccpInfoRequest;
		*var_len = StorageTmp->sccpInfoRequestLen;
		return (u_char *) StorageTmp->sccpInfoRequest;
	case SCCPRETURNUNKNOWNPARAMS:
		*write_method = write_sccpReturnUnknownParams;
		*var_len = StorageTmp->sccpReturnUnknownParamsLen;
		return (u_char *) StorageTmp->sccpReturnUnknownParams;
	case SCCPROUTETESTROWSTATUS:
		*write_method = write_sccpRouteTestRowStatus;
		*var_len = sizeof(StorageTmp->sccpRouteTestRowStatus);
		return (u_char *) &StorageTmp->sccpRouteTestRowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn int write_sccpNetworkEntityAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNetworkEntityAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpNetworkEntityAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpNetworkEntityAlarmStatus;
		old_length = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		StorageTmp->sccpNetworkEntityAlarmStatus = string;
		StorageTmp->sccpNetworkEntityAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNetworkEntityAlarmStatus = old_value;
		StorageTmp->sccpNetworkEntityAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 14..15 */
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid) || ((14 * sizeof(oid) > var_val_len || var_val_len > 15 * sizeof(oid)))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->sccpVersion;
		old_length = StorageTmp->sccpVersionLen;
		StorageTmp->sccpVersion = objid;
		StorageTmp->sccpVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpVersion = old_value;
		StorageTmp->sccpVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLUDTandLUDTSSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLUDTandLUDTSSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpLUDTandLUDTSSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpLUDTandLUDTSSupported;
		StorageTmp->sccpLUDTandLUDTSSupported = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLUDTandLUDTSSupported = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCoordChangeTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCoordChangeTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpCoordChangeTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpCoordChangeTimer;
		StorageTmp->sccpCoordChangeTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCoordChangeTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpIgnoreSSTTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpIgnoreSSTTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpIgnoreSSTTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpIgnoreSSTTimer;
		StorageTmp->sccpIgnoreSSTTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpIgnoreSSTTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpMaxStatInfoTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpMaxStatInfoTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpMaxStatInfoTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpMaxStatInfoTimer;
		StorageTmp->sccpMaxStatInfoTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpMaxStatInfoTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNetworkEntityName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNetworkEntityName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpNetworkEntityName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpNetworkEntityName;
		old_length = StorageTmp->sccpNetworkEntityNameLen;
		StorageTmp->sccpNetworkEntityName = string;
		StorageTmp->sccpNetworkEntityNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNetworkEntityName = old_value;
		StorageTmp->sccpNetworkEntityNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAccessPointAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAccessPointAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpAccessPointAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpAccessPointAlarmStatus;
		old_length = StorageTmp->sccpAccessPointAlarmStatusLen;
		StorageTmp->sccpAccessPointAlarmStatus = string;
		StorageTmp->sccpAccessPointAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAccessPointAlarmStatus = old_value;
		StorageTmp->sccpAccessPointAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSap2Address(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSap2Address(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSap2Address entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..1 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 1))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpSap2Address;
		old_length = StorageTmp->sccpSap2AddressLen;
		StorageTmp->sccpSap2Address = string;
		StorageTmp->sccpSap2AddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSap2Address = old_value;
		StorageTmp->sccpSap2AddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpUserEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpUserEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpUserEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpUserEntityNames;
		old_length = StorageTmp->sccpUserEntityNamesLen;
		StorageTmp->sccpUserEntityNames = string;
		StorageTmp->sccpUserEntityNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpUserEntityNames = old_value;
		StorageTmp->sccpUserEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpProviderEntityNames;
		old_length = StorageTmp->sccpProviderEntityNamesLen;
		StorageTmp->sccpProviderEntityNames = string;
		StorageTmp->sccpProviderEntityNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpProviderEntityNames = old_value;
		StorageTmp->sccpProviderEntityNamesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpConcernedAreaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpConcernedAreaPointer;
		StorageTmp->sccpConcernedAreaPointer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpConcernedAreaPointer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkagePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLinkagePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpLinkagePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpLinkagePointer;
		StorageTmp->sccpLinkagePointer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkagePointer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSsAvailableAfterSpRestart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSsAvailableAfterSpRestart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSsAvailableAfterSpRestart entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpSsAvailableAfterSpRestart;
		StorageTmp->sccpSsAvailableAfterSpRestart = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSsAvailableAfterSpRestart = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAccessPointName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAccessPointName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpAccessPointName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAccessPointRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpAccessPointName;
		old_length = StorageTmp->sccpAccessPointNameLen;
		StorageTmp->sccpAccessPointName = string;
		StorageTmp->sccpAccessPointNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAccessPointName = old_value;
		StorageTmp->sccpAccessPointNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAttackTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAttackTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAttackTimerValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpAttackTimerValue;
		StorageTmp->sccpAttackTimerValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAttackTimerValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpDecayTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpDecayTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpDecayTimerValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpDecayTimerValue;
		StorageTmp->sccpDecayTimerValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpDecayTimerValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNrOfRestrictionLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNrOfRestrictionLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpNrOfRestrictionLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpNrOfRestrictionLevels;
		StorageTmp->sccpNrOfRestrictionLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNrOfRestrictionLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNrOfSubLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNrOfSubLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpNrOfSubLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpNrOfSubLevels;
		StorageTmp->sccpNrOfSubLevels = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNrOfSubLevels = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCLS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCLS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpCLS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpCLS;
		StorageTmp->sccpCLS = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCLS = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCongestionTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCongestionTimerValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpCongestionTimerValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpCongestionTimerValue;
		StorageTmp->sccpCongestionTimerValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCongestionTimerValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpp;
		StorageTmp->sccpp = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpp = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelCR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelCR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0204'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelCR;
		old_length = StorageTmp->sccpImportanceLevelCRLen;
		StorageTmp->sccpImportanceLevelCR = string;
		StorageTmp->sccpImportanceLevelCRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelCR = old_value;
		StorageTmp->sccpImportanceLevelCRLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelCC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelCC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0304'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelCC;
		old_length = StorageTmp->sccpImportanceLevelCCLen;
		StorageTmp->sccpImportanceLevelCC = string;
		StorageTmp->sccpImportanceLevelCCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelCC = old_value;
		StorageTmp->sccpImportanceLevelCCLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelCREF(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelCREF(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCREF entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0204'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelCREF;
		old_length = StorageTmp->sccpImportanceLevelCREFLen;
		StorageTmp->sccpImportanceLevelCREF = string;
		StorageTmp->sccpImportanceLevelCREFLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelCREF = old_value;
		StorageTmp->sccpImportanceLevelCREFLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelDT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelDT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelDT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1 not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelDT1;
		old_length = StorageTmp->sccpImportanceLevelDT1Len;
		StorageTmp->sccpImportanceLevelDT1 = string;
		StorageTmp->sccpImportanceLevelDT1Len = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelDT1 = old_value;
		StorageTmp->sccpImportanceLevelDT1Len = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelDT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelDT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelDT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2 not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelDT2;
		old_length = StorageTmp->sccpImportanceLevelDT2Len;
		StorageTmp->sccpImportanceLevelDT2 = string;
		StorageTmp->sccpImportanceLevelDT2Len = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelDT2 = old_value;
		StorageTmp->sccpImportanceLevelDT2Len = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelAK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelAK(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelAK entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelAK;
		old_length = StorageTmp->sccpImportanceLevelAKLen;
		StorageTmp->sccpImportanceLevelAK = string;
		StorageTmp->sccpImportanceLevelAKLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelAK = old_value;
		StorageTmp->sccpImportanceLevelAKLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelIT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelIT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelIT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelIT;
		old_length = StorageTmp->sccpImportanceLevelITLen;
		StorageTmp->sccpImportanceLevelIT = string;
		StorageTmp->sccpImportanceLevelITLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelIT = old_value;
		StorageTmp->sccpImportanceLevelITLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelED(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelED(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelED entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0700'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelED;
		old_length = StorageTmp->sccpImportanceLevelEDLen;
		StorageTmp->sccpImportanceLevelED = string;
		StorageTmp->sccpImportanceLevelEDLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelED = old_value;
		StorageTmp->sccpImportanceLevelEDLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelEA(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelEA(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelEA entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0700'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelEA;
		old_length = StorageTmp->sccpImportanceLevelEALen;
		StorageTmp->sccpImportanceLevelEA = string;
		StorageTmp->sccpImportanceLevelEALen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelEA = old_value;
		StorageTmp->sccpImportanceLevelEALen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRSR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRSR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRSR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRSR;
		old_length = StorageTmp->sccpImportanceLevelRSRLen;
		StorageTmp->sccpImportanceLevelRSR = string;
		StorageTmp->sccpImportanceLevelRSRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRSR = old_value;
		StorageTmp->sccpImportanceLevelRSRLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRSC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRSC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRSC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0600'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRSC;
		old_length = StorageTmp->sccpImportanceLevelRSCLen;
		StorageTmp->sccpImportanceLevelRSC = string;
		StorageTmp->sccpImportanceLevelRSCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRSC = old_value;
		StorageTmp->sccpImportanceLevelRSCLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelERR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelERR(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelERR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0700'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelERR;
		old_length = StorageTmp->sccpImportanceLevelERRLen;
		StorageTmp->sccpImportanceLevelERR = string;
		StorageTmp->sccpImportanceLevelERRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelERR = old_value;
		StorageTmp->sccpImportanceLevelERRLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRLC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRLC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRLC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0400'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRLC;
		old_length = StorageTmp->sccpImportanceLevelRLCLen;
		StorageTmp->sccpImportanceLevelRLC = string;
		StorageTmp->sccpImportanceLevelRLCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRLC = old_value;
		StorageTmp->sccpImportanceLevelRLCLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelRLSD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelRLSD(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRLSD entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0606'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelRLSD;
		old_length = StorageTmp->sccpImportanceLevelRLSDLen;
		StorageTmp->sccpImportanceLevelRLSD = string;
		StorageTmp->sccpImportanceLevelRLSDLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelRLSD = old_value;
		StorageTmp->sccpImportanceLevelRLSDLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelUDT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelUDT;
		old_length = StorageTmp->sccpImportanceLevelUDTLen;
		StorageTmp->sccpImportanceLevelUDT = string;
		StorageTmp->sccpImportanceLevelUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelUDT = old_value;
		StorageTmp->sccpImportanceLevelUDTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelUDTS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0300'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelUDTS;
		old_length = StorageTmp->sccpImportanceLevelUDTSLen;
		StorageTmp->sccpImportanceLevelUDTS = string;
		StorageTmp->sccpImportanceLevelUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelUDTS = old_value;
		StorageTmp->sccpImportanceLevelUDTSLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelXUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelXUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelXUDT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelXUDT;
		old_length = StorageTmp->sccpImportanceLevelXUDTLen;
		StorageTmp->sccpImportanceLevelXUDT = string;
		StorageTmp->sccpImportanceLevelXUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelXUDT = old_value;
		StorageTmp->sccpImportanceLevelXUDTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelXUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelXUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelXUDTS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0300'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelXUDTS;
		old_length = StorageTmp->sccpImportanceLevelXUDTSLen;
		StorageTmp->sccpImportanceLevelXUDTS = string;
		StorageTmp->sccpImportanceLevelXUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelXUDTS = old_value;
		StorageTmp->sccpImportanceLevelXUDTSLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelLUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelLUDT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelLUDT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0406'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelLUDT;
		old_length = StorageTmp->sccpImportanceLevelLUDTLen;
		StorageTmp->sccpImportanceLevelLUDT = string;
		StorageTmp->sccpImportanceLevelLUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelLUDT = old_value;
		StorageTmp->sccpImportanceLevelLUDTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpImportanceLevelLUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpImportanceLevelLUDTS(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelLUDTS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 2..2 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value '0300'X */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpImportanceLevelLUDTS;
		old_length = StorageTmp->sccpImportanceLevelLUDTSLen;
		StorageTmp->sccpImportanceLevelLUDTS = string;
		StorageTmp->sccpImportanceLevelLUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpImportanceLevelLUDTS = old_value;
		StorageTmp->sccpImportanceLevelLUDTSLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpRLM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpRLM;
		StorageTmp->sccpRLM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRLM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRSLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRSLM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpRSLM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpRSLM;
		StorageTmp->sccpRSLM = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRSLM = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkageConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLinkageConcernedAreaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpLinkageConcernedAreaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpLinkageConcernedAreaPointer;
		old_length = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		StorageTmp->sccpLinkageConcernedAreaPointer = string;
		StorageTmp->sccpLinkageConcernedAreaPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkageConcernedAreaPointer = old_value;
		StorageTmp->sccpLinkageConcernedAreaPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLowerLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLowerLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpLowerLimitForSegmentation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 150..3592 */
		if ((150 > set_value || set_value > 3592)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpLowerLimitForSegmentation;
		StorageTmp->sccpLowerLimitForSegmentation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLowerLimitForSegmentation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpUpperLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpUpperLimitForSegmentation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpUpperLimitForSegmentation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 150..3592 */
		if ((150 > set_value || set_value > 3592)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpUpperLimitForSegmentation;
		StorageTmp->sccpUpperLimitForSegmentation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpUpperLimitForSegmentation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkageName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLinkageName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpLinkageName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpLinkageRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpLinkageName;
		old_length = StorageTmp->sccpLinkageNameLen;
		StorageTmp->sccpLinkageName = string;
		StorageTmp->sccpLinkageNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkageName = old_value;
		StorageTmp->sccpLinkageNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpSclcAlarmStatus;
		old_length = StorageTmp->sccpSclcAlarmStatusLen;
		StorageTmp->sccpSclcAlarmStatus = string;
		StorageTmp->sccpSclcAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcAlarmStatus = old_value;
		StorageTmp->sccpSclcAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCLCADMINISTRATIVESTATE_LOCKED:
		case SCCPSCLCADMINISTRATIVESTATE_UNLOCKED:
		case SCCPSCLCADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpSclcAdministrativeState;
		StorageTmp->sccpSclcAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCLCOPERATIONALSYSTEMTYPE_ES:
		case SCCPSCLCOPERATIONALSYSTEMTYPE_IS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpSclcOperationalSystemType;
		StorageTmp->sccpSclcOperationalSystemType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcOperationalSystemType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpInitialValueReassTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpInitialValueReassTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpInitialValueReassTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpInitialValueReassTimer;
		StorageTmp->sccpInitialValueReassTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpInitialValueReassTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSclcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSclcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSclcName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpSclcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpSclcName;
		old_length = StorageTmp->sccpSclcNameLen;
		StorageTmp->sccpSclcName = string;
		StorageTmp->sccpSclcNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcName = old_value;
		StorageTmp->sccpSclcNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpCoProtocolMachineId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpCoProtocolMachineId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpCoProtocolMachineId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpCoProtocolMachineId;
		old_length = StorageTmp->sccpCoProtocolMachineIdLen;
		StorageTmp->sccpCoProtocolMachineId = string;
		StorageTmp->sccpCoProtocolMachineIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCoProtocolMachineId = old_value;
		StorageTmp->sccpCoProtocolMachineIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScocAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpScocAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCOCADMINISTRATIVESTATE_LOCKED:
		case SCCPSCOCADMINISTRATIVESTATE_UNLOCKED:
		case SCCPSCOCADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpScocAdministrativeState;
		StorageTmp->sccpScocAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScocOperationalSystemType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpScocOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSCOCOPERATIONALSYSTEMTYPE_ES:
		case SCCPSCOCOPERATIONALSYSTEMTYPE_IS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpScocOperationalSystemType;
		StorageTmp->sccpScocOperationalSystemType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocOperationalSystemType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScocName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScocTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScocName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScocRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpScocName;
		old_length = StorageTmp->sccpScocNameLen;
		StorageTmp->sccpScocName = string;
		StorageTmp->sccpScocNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocName = old_value;
		StorageTmp->sccpScocNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScrcId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScrcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScrcId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScrcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpScrcId;
		old_length = StorageTmp->sccpScrcIdLen;
		StorageTmp->sccpScrcId = string;
		StorageTmp->sccpScrcIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScrcId = old_value;
		StorageTmp->sccpScrcIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScrcAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScrcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScrcAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScrcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpScrcAlarmStatus;
		old_length = StorageTmp->sccpScrcAlarmStatusLen;
		StorageTmp->sccpScrcAlarmStatus = string;
		StorageTmp->sccpScrcAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScrcAlarmStatus = old_value;
		StorageTmp->sccpScrcAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpScrcName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpScrcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpScrcName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpScrcRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpScrcName;
		old_length = StorageTmp->sccpScrcNameLen;
		StorageTmp->sccpScrcName = string;
		StorageTmp->sccpScrcNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScrcName = old_value;
		StorageTmp->sccpScrcNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSharingMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSharingMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpSharingMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPSHARINGMODE_SOLITARY:
		case SCCPSHARINGMODE_DUPLIDOMINANT:
		case SCCPSHARINGMODE_DUPLIREPLACEMENT:
		case SCCPSHARINGMODE_DUPLILOADSHARED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpSharingMode;
		StorageTmp->sccpSharingMode = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSharingMode = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLoadSharingAlgPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpLoadSharingAlgPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpLoadSharingAlgPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->sccpLoadSharingAlgPointer;
		old_length = StorageTmp->sccpLoadSharingAlgPointerLen;
		StorageTmp->sccpLoadSharingAlgPointer = objid;
		StorageTmp->sccpLoadSharingAlgPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLoadSharingAlgPointer = old_value;
		StorageTmp->sccpLoadSharingAlgPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpEntitySetName;
		old_length = StorageTmp->sccpEntitySetNameLen;
		StorageTmp->sccpEntitySetName = string;
		StorageTmp->sccpEntitySetNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetName = old_value;
		StorageTmp->sccpEntitySetNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPENTITYSETTYPE_ENDNODEENTITYSETWITHOUTSSN:
		case SCCPENTITYSETTYPE_ENDNODEENTITYSETWITHSSN:
		case SCCPENTITYSETTYPE_RELAYNODEENTITYSET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpEntitySetType;
		StorageTmp->sccpEntitySetType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSsn(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetSsn(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSsn entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..1 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 1))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpEntitySetSsn;
		old_length = StorageTmp->sccpEntitySetSsnLen;
		StorageTmp->sccpEntitySetSsn = string;
		StorageTmp->sccpEntitySetSsnLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSsn = old_value;
		StorageTmp->sccpEntitySetSsnLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSapType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetSapType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSapType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPENTITYSETSAPTYPE_EQUAL:
		case SCCPENTITYSETSAPTYPE_PRIMARY:
		case SCCPENTITYSETSAPTYPE_BACKUP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpEntitySetSapType;
		StorageTmp->sccpEntitySetSapType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSapType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSapPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetSapPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSapPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpEntitySetSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->sccpEntitySetSapPointer;
		old_length = StorageTmp->sccpEntitySetSapPointerLen;
		StorageTmp->sccpEntitySetSapPointer = objid;
		StorageTmp->sccpEntitySetSapPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSapPointer = old_value;
		StorageTmp->sccpEntitySetSapPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRemoteSCCPMTPAccessPoint(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRemoteSCCPMTPAccessPoint(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpRemoteSCCPMTPAccessPoint entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRemoteSCCPRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->sccpRemoteSCCPMTPAccessPoint;
		old_length = StorageTmp->sccpRemoteSCCPMTPAccessPointLen;
		StorageTmp->sccpRemoteSCCPMTPAccessPoint = objid;
		StorageTmp->sccpRemoteSCCPMTPAccessPointLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRemoteSCCPMTPAccessPoint = old_value;
		StorageTmp->sccpRemoteSCCPMTPAccessPointLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRemoteSCCPName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpRemoteSCCPName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpRemoteSCCPName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRemoteSCCPRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpRemoteSCCPName;
		old_length = StorageTmp->sccpRemoteSCCPNameLen;
		StorageTmp->sccpRemoteSCCPName = string;
		StorageTmp->sccpRemoteSCCPNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRemoteSCCPName = old_value;
		StorageTmp->sccpRemoteSCCPNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewEncodingScheme entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWENCODINGSCHEME_UNKNOWN:
		case SCCPGTNEWENCODINGSCHEME_BCDODD:
		case SCCPGTNEWENCODINGSCHEME_BCDEVEN:
		case SCCPGTNEWENCODINGSCHEME_NATIONALSPECIFIC:
		case SCCPGTNEWENCODINGSCHEME_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtNewEncodingScheme;
		StorageTmp->sccpGtNewEncodingScheme = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewEncodingScheme = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewNatureOfAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWNATUREOFADDRESS_UNKNOWN:
		case SCCPGTNEWNATUREOFADDRESS_ISDNTNP:
		case SCCPGTNEWNATUREOFADDRESS_GENERICNUMBERINGPLAN:
		case SCCPGTNEWNATUREOFADDRESS_DNP:
		case SCCPGTNEWNATUREOFADDRESS_TNP:
		case SCCPGTNEWNATUREOFADDRESS_MMNP:
		case SCCPGTNEWNATUREOFADDRESS_LMNP:
		case SCCPGTNEWNATUREOFADDRESS_ISDNMNP:
		case SCCPGTNEWNATUREOFADDRESS_PRIVATENUMBERINGPLAN:
		case SCCPGTNEWNATUREOFADDRESS_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtNewNatureOfAddress;
		StorageTmp->sccpGtNewNatureOfAddress = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewNatureOfAddress = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewNumberingPlan entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWNUMBERINGPLAN_UNKNOWN:
		case SCCPGTNEWNUMBERINGPLAN_SUBSCRIBER:
		case SCCPGTNEWNUMBERINGPLAN_NATIONAL:
		case SCCPGTNEWNUMBERINGPLAN_INTERNATIONAL:
		case SCCPGTNEWNUMBERINGPLAN_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtNewNumberingPlan;
		StorageTmp->sccpGtNewNumberingPlan = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewNumberingPlan = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNewTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNewTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewTranslationType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		switch (set_value) {
		case SCCPGTNEWTRANSLATIONTYPE_UNKNOWN:
		case SCCPGTNEWTRANSLATIONTYPE_ITCC:
		case SCCPGTNEWTRANSLATIONTYPE_GENERICNUMBERINGPLAN:
		case SCCPGTNEWTRANSLATIONTYPE_IEESS:
		case SCCPGTNEWTRANSLATIONTYPE_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtNewTranslationType;
		StorageTmp->sccpGtNewTranslationType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewTranslationType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtConversionRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtConversionRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtConversionRuleName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtConversionRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpGtConversionRuleName;
		old_length = StorageTmp->sccpGtConversionRuleNameLen;
		StorageTmp->sccpGtConversionRuleName = string;
		StorageTmp->sccpGtConversionRuleNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtConversionRuleName = old_value;
		StorageTmp->sccpGtConversionRuleNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoOperation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAddressInfoOperation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoOperation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAddressInfoRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPADDRESSINFOOPERATION_INSERT:
		case SCCPADDRESSINFOOPERATION_REPLACE:
		case SCCPADDRESSINFOOPERATION_PASSTRANSPARENTLY:
		case SCCPADDRESSINFOOPERATION_DELETE:
		case SCCPADDRESSINFOOPERATION_STOP:
		case SCCPADDRESSINFOOPERATION_COPYREMAIN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpAddressInfoOperation;
		StorageTmp->sccpAddressInfoOperation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoOperation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoAddressElement(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAddressInfoAddressElement(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoAddressElement entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAddressInfoRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpAddressInfoAddressElement;
		StorageTmp->sccpAddressInfoAddressElement = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoAddressElement = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoNrOfAddressElements(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAddressInfoNrOfAddressElements(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoNrOfAddressElements entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpAddressInfoRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpAddressInfoNrOfAddressElements;
		StorageTmp->sccpAddressInfoNrOfAddressElements = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoNrOfAddressElements = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTINDICATOR_NOGLOBALTITLE:
		case SCCPGTINDICATOR_NOAONLY:
		case SCCPGTINDICATOR_TTONLY:
		case SCCPGTINDICATOR_TT_NP_ES:
		case SCCPGTINDICATOR_TT_NP_ES_NOA:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtIndicator;
		StorageTmp->sccpGtIndicator = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtIndicator = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNatureOfAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNatureOfAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTNATUREOFADDRESS_UNKNOWN:
		case SCCPGTNATUREOFADDRESS_ISDNTNP:
		case SCCPGTNATUREOFADDRESS_GENERICNUMBERINGPLAN:
		case SCCPGTNATUREOFADDRESS_DNP:
		case SCCPGTNATUREOFADDRESS_TNP:
		case SCCPGTNATUREOFADDRESS_MMNP:
		case SCCPGTNATUREOFADDRESS_LMNP:
		case SCCPGTNATUREOFADDRESS_ISDNMNP:
		case SCCPGTNATUREOFADDRESS_PRIVATENUMBERINGPLAN:
		case SCCPGTNATUREOFADDRESS_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtNatureOfAddress;
		StorageTmp->sccpGtNatureOfAddress = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNatureOfAddress = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtNumberingPlan(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtNumberingPlan entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTNUMBERINGPLAN_UNKNOWN:
		case SCCPGTNUMBERINGPLAN_SUBSCRIBER:
		case SCCPGTNUMBERINGPLAN_NATIONAL:
		case SCCPGTNUMBERINGPLAN_INTERNATIONAL:
		case SCCPGTNUMBERINGPLAN_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtNumberingPlan;
		StorageTmp->sccpGtNumberingPlan = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNumberingPlan = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtTranslationType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslationType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTTRANSLATIONTYPE_UNKNOWN:
		case SCCPGTTRANSLATIONTYPE_ITCC:
		case SCCPGTTRANSLATIONTYPE_GENERICNUMBERINGPLAN:
		case SCCPGTTRANSLATIONTYPE_IEESS:
		case SCCPGTTRANSLATIONTYPE_NOTUSEDORNOOVERWRITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtTranslationType;
		StorageTmp->sccpGtTranslationType = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslationType = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslatorAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtTranslatorAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslatorAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTTRANSLATORADMINISTRATIVESTATE_LOCKED:
		case SCCPGTTRANSLATORADMINISTRATIVESTATE_UNLOCKED:
		case SCCPGTTRANSLATORADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtTranslatorAdministrativeState;
		StorageTmp->sccpGtTranslatorAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslatorAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslatorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtTranslatorName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslatorName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtTranslatorRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpGtTranslatorName;
		old_length = StorageTmp->sccpGtTranslatorNameLen;
		StorageTmp->sccpGtTranslatorName = string;
		StorageTmp->sccpGtTranslatorNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslatorName = old_value;
		StorageTmp->sccpGtTranslatorNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtRuleAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtRuleAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtRuleAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTRULEADMINISTRATIVESTATE_LOCKED:
		case SCCPGTRULEADMINISTRATIVESTATE_UNLOCKED:
		case SCCPGTRULEADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtRuleAdministrativeState;
		StorageTmp->sccpGtRuleAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtRuleAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtAddressInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtAddressInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtAddressInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpGtAddressInformation;
		old_length = StorageTmp->sccpGtAddressInformationLen;
		StorageTmp->sccpGtAddressInformation = string;
		StorageTmp->sccpGtAddressInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtAddressInformation = old_value;
		StorageTmp->sccpGtAddressInformationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtConvRulePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtConvRulePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtConvRulePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpGtConvRulePointer;
		old_length = StorageTmp->sccpGtConvRulePointerLen;
		StorageTmp->sccpGtConvRulePointer = string;
		StorageTmp->sccpGtConvRulePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtConvRulePointer = old_value;
		StorageTmp->sccpGtConvRulePointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtEncodingScheme(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpGtEncodingScheme entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case SCCPGTENCODINGSCHEME_UNKNOWN:
		case SCCPGTENCODINGSCHEME_BCDODD:
		case SCCPGTENCODINGSCHEME_BCDEVEN:
		case SCCPGTENCODINGSCHEME_NATIONALSPECIFIC:
		case SCCPGTENCODINGSCHEME_NOTUSEDORNOOVERWITE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpGtEncodingScheme;
		StorageTmp->sccpGtEncodingScheme = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtEncodingScheme = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpEntitySetPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpEntitySetPointer;
		old_length = StorageTmp->sccpEntitySetPointerLen;
		StorageTmp->sccpEntitySetPointer = string;
		StorageTmp->sccpEntitySetPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetPointer = old_value;
		StorageTmp->sccpEntitySetPointerLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpGtRuleName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpGtRuleName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpGtRuleRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpGtRuleName;
		old_length = StorageTmp->sccpGtRuleNameLen;
		StorageTmp->sccpGtRuleName = string;
		StorageTmp->sccpGtRuleNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtRuleName = old_value;
		StorageTmp->sccpGtRuleNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpDSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpDSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpDSRVT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpDSRVT;
		StorageTmp->sccpDSRVT = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpDSRVT = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpNSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpNSRVT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpNSRVT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpNSRVT;
		StorageTmp->sccpNSRVT = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNSRVT = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSrvtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpSrvtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpSrvtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpSrvtName;
		old_length = StorageTmp->sccpSrvtNameLen;
		StorageTmp->sccpSrvtName = string;
		StorageTmp->sccpSrvtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSrvtName = old_value;
		StorageTmp->sccpSrvtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case SCCPADMINISTRATIVESTATE_LOCKED:
		case SCCPADMINISTRATIVESTATE_UNLOCKED:
		case SCCPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpAdministrativeState;
		StorageTmp->sccpAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpTraceRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpTraceRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpTraceRequested entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpTraceRequested;
		StorageTmp->sccpTraceRequested = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpTraceRequested = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpThreshold(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpThreshold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpThreshold;
		StorageTmp->sccpThreshold = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpThreshold = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpMtpBackwardRoutingRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpMtpBackwardRoutingRequested(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("sccpMIB", "write_sccpMtpBackwardRoutingRequested entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->sccpMtpBackwardRoutingRequested;
		StorageTmp->sccpMtpBackwardRoutingRequested = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpMtpBackwardRoutingRequested = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpOriginalGT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpOriginalGT(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpOriginalGT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpOriginalGT;
		old_length = StorageTmp->sccpOriginalGTLen;
		StorageTmp->sccpOriginalGT = string;
		StorageTmp->sccpOriginalGTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpOriginalGT = old_value;
		StorageTmp->sccpOriginalGTLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpInfoRequest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpInfoRequest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpInfoRequest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((2 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		if (var_val_len < 1 || *var_val != (8 - (2 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpInfoRequest;
		old_length = StorageTmp->sccpInfoRequestLen;
		StorageTmp->sccpInfoRequest = string;
		StorageTmp->sccpInfoRequestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpInfoRequest = old_value;
		StorageTmp->sccpInfoRequestLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpReturnUnknownParams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_sccpReturnUnknownParams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("sccpMIB", "write_sccpReturnUnknownParams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->sccpRouteTestRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((1 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		if (var_val_len < 1 || *var_val != (8 - (1 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the 
				   UNDO case */
		old_value = StorageTmp->sccpReturnUnknownParams;
		old_length = StorageTmp->sccpReturnUnknownParamsLen;
		StorageTmp->sccpReturnUnknownParams = string;
		StorageTmp->sccpReturnUnknownParamsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpReturnUnknownParams = old_value;
		StorageTmp->sccpReturnUnknownParamsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static struct sccpNetworkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpNetworkEntityTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpNetworkEntityTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpNetworkEntityTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpNetworkEntityTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpNetworkEntityTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpNetworkEntityTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpNetworkEntityTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpNetworkEntityTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpRowStatus;
			StorageTmp->sccpRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpNetworkEntityTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpNetworkEntityTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpNetworkEntityTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpNetworkEntityTable_destroy(&StorageDel);
			/* sccpNetworkEntityTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSapNameRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpSapNameRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpSapNameTable_data *StorageTmp = NULL;
	static struct sccpSapNameTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpSapNameTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpSapNameTableStorage, NULL, &name[sizeof(sccpSapNameTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSapNameRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSapNameRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpSapNameRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpSapNameTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpSapNameTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpSapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpSapNameTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpSapNameTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpSapId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpSapNameTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpSapNameTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpSapNameRowStatus;
			StorageTmp->sccpSapNameRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpSapNameTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpSapNameTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpSapNameRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpSapNameTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpSapNameRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpSapNameRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpSapNameTable_destroy(&StorageDel);
			/* sccpSapNameTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAccessPointRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpAccessPointRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static struct sccpAccessPointTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpAccessPointTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpAccessPointTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpAccessPointRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpAccessPointTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpAccessPointTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpSapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpAccessPointTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpAccessPointTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpSapId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpAccessPointTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpAccessPointTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpAccessPointRowStatus;
			StorageTmp->sccpAccessPointRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpAccessPointTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpAccessPointTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpAccessPointRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpAccessPointTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpAccessPointRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpAccessPointRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpAccessPointTable_destroy(&StorageDel);
			/* sccpAccessPointTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpLinkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpLinkageRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static struct sccpLinkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpLinkageTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpLinkageTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpLinkageRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpLinkageTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpLinkageTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpLinkageId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpLinkageTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpLinkageTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpLinkageId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpLinkageTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpLinkageTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpLinkageRowStatus;
			StorageTmp->sccpLinkageRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpLinkageTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpLinkageTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpLinkageRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpLinkageTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpLinkageRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpLinkageRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpLinkageTable_destroy(&StorageDel);
			/* sccpLinkageTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpSclcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpSclcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpSclcTable_data *StorageTmp = NULL;
	static struct sccpSclcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpSclcTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpSclcTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpSclcRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpSclcTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpSclcTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpSclcTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpSclcTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpSclcTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpSclcTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpSclcRowStatus;
			StorageTmp->sccpSclcRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpSclcTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpSclcTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpSclcRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpSclcTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpSclcRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpSclcRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpSclcTable_destroy(&StorageDel);
			/* sccpSclcTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScocRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpScocRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpScocTable_data *StorageTmp = NULL;
	static struct sccpScocTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpScocTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpScocTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpScocRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpScocTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpScocTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpScocTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpScocTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpScocTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpScocTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpScocRowStatus;
			StorageTmp->sccpScocRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpScocTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpScocTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpScocRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpScocTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpScocRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpScocRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpScocTable_destroy(&StorageDel);
			/* sccpScocTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpScrcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpScrcRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpScrcTable_data *StorageTmp = NULL;
	static struct sccpScrcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpScrcTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpScrcTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpScrcRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpScrcTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpScrcTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpScrcTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpScrcTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpScrcTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpScrcTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpScrcRowStatus;
			StorageTmp->sccpScrcRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpScrcTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpScrcTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpScrcRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpScrcTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpScrcRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpScrcRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpScrcTable_destroy(&StorageDel);
			/* sccpScrcTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpEntitySetRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static struct sccpEntitySetTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpEntitySetTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpEntitySetTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpEntitySetRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpEntitySetTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpEntitySetTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpEntitySetId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpEntitySetTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpEntitySetTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpEntitySetTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpEntitySetTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpEntitySetRowStatus;
			StorageTmp->sccpEntitySetRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpEntitySetTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpEntitySetTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpEntitySetRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpEntitySetTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpEntitySetRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpEntitySetRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpEntitySetTable_destroy(&StorageDel);
			/* sccpEntitySetTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpEntitySetSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpEntitySetSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	static struct sccpEntitySetSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpEntitySetSapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[sizeof(sccpEntitySetSapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpEntitySetSapRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpEntitySetSapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpEntitySetSapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpEntitySetId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sccpEntitySetSapId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpEntitySetSapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpEntitySetSapTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetSapId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetSapIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpEntitySetSapTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpEntitySetSapTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpEntitySetSapRowStatus;
			StorageTmp->sccpEntitySetSapRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpEntitySetSapTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpEntitySetSapTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpEntitySetSapRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpEntitySetSapTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpEntitySetSapRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpEntitySetSapRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpEntitySetSapTable_destroy(&StorageDel);
			/* sccpEntitySetSapTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpConcernedAreaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpConcernedAreaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpConcernedAreaTable_data *StorageTmp = NULL;
	static struct sccpConcernedAreaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpConcernedAreaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpConcernedAreaTableStorage, NULL, &name[sizeof(sccpConcernedAreaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpConcernedAreaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpConcernedAreaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpConcernedAreaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpConcernedAreaId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpConcernedAreaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpConcernedAreaTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpConcernedAreaId, vp->val.string, vp->val_len);
			StorageNew->sccpConcernedAreaIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpConcernedAreaTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpConcernedAreaTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpConcernedAreaRowStatus;
			StorageTmp->sccpConcernedAreaRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpConcernedAreaTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpConcernedAreaTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpConcernedAreaRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpConcernedAreaTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpConcernedAreaRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpConcernedAreaRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpConcernedAreaTable_destroy(&StorageDel);
			/* sccpConcernedAreaTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRemoteSCCPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpRemoteSCCPRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	static struct sccpRemoteSCCPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpRemoteSCCPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[sizeof(sccpRemoteSCCPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpRemoteSCCPRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpRemoteSCCPTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpRemoteSCCPTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpConcernedAreaId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sccpRemoteSCCPId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpRemoteSCCPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpRemoteSCCPTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpConcernedAreaId, vp->val.string, vp->val_len);
			StorageNew->sccpConcernedAreaIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpRemoteSCCPId, vp->val.string, vp->val_len);
			StorageNew->sccpRemoteSCCPIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpRemoteSCCPTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpRemoteSCCPTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpRemoteSCCPRowStatus;
			StorageTmp->sccpRemoteSCCPRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpRemoteSCCPTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpRemoteSCCPTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpRemoteSCCPRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpRemoteSCCPTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpRemoteSCCPRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpRemoteSCCPRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpRemoteSCCPTable_destroy(&StorageDel);
			/* sccpRemoteSCCPTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtConversionRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpGtConversionRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static struct sccpGtConversionRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpGtConversionRuleTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpGtConversionRuleTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpGtConversionRuleRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpGtConversionRuleTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpGtConversionRuleTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpGtConversionRuleId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpGtConversionRuleTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpGtConversionRuleTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtConversionRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtConversionRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpGtConversionRuleTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpGtConversionRuleTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpGtConversionRuleRowStatus;
			StorageTmp->sccpGtConversionRuleRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpGtConversionRuleTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpGtConversionRuleTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpGtConversionRuleRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpGtConversionRuleTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpGtConversionRuleRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpGtConversionRuleRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpGtConversionRuleTable_destroy(&StorageDel);
			/* sccpGtConversionRuleTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpAddressInfoRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpAddressInfoRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	static struct sccpAddressInfoTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpAddressInfoTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpAddressInfoTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpAddressInfoRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpAddressInfoTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpAddressInfoTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpGtConversionRuleId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sccpAddressInfoOperationId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpAddressInfoTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpAddressInfoTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtConversionRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtConversionRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpAddressInfoOperationId, vp->val.string, vp->val_len);
			StorageNew->sccpAddressInfoOperationIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpAddressInfoTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpAddressInfoTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpAddressInfoRowStatus;
			StorageTmp->sccpAddressInfoRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpAddressInfoTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpAddressInfoTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpAddressInfoRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpAddressInfoTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpAddressInfoRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpAddressInfoRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpAddressInfoTable_destroy(&StorageDel);
			/* sccpAddressInfoTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtTranslatorRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpGtTranslatorRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static struct sccpGtTranslatorTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpGtTranslatorTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpGtTranslatorTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpGtTranslatorRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpGtTranslatorTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpGtTranslatorTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpGtTranslatorId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpGtTranslatorTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpGtTranslatorTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtTranslatorId, vp->val.string, vp->val_len);
			StorageNew->sccpGtTranslatorIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpGtTranslatorTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpGtTranslatorTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpGtTranslatorRowStatus;
			StorageTmp->sccpGtTranslatorRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpGtTranslatorTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpGtTranslatorTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpGtTranslatorRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpGtTranslatorTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpGtTranslatorRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpGtTranslatorRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpGtTranslatorTable_destroy(&StorageDel);
			/* sccpGtTranslatorTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpGtRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpGtRuleRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static struct sccpGtRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpGtRuleTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpGtRuleTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpGtRuleRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpGtRuleTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpGtRuleTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpGtTranslatorId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* sccpGtRuleId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpGtRuleTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpGtRuleTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtTranslatorId, vp->val.string, vp->val_len);
			StorageNew->sccpGtTranslatorIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpGtRuleTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpGtRuleTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpGtRuleRowStatus;
			StorageTmp->sccpGtRuleRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpGtRuleTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpGtRuleTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpGtRuleRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpGtRuleTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpGtRuleRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpGtRuleRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpGtRuleTable_destroy(&StorageDel);
			/* sccpGtRuleTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_sccpRouteTestRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_sccpRouteTestRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static struct sccpSrvtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpSrvtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpSrvtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRouteTestRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRouteTestRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->sccpRouteTestRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->sccpSrvtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->sccpSrvtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* sccpNetworkEntityId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* sccpRouteTestId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(sccpSrvtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = sccpSrvtTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpRouteTestId, vp->val.string, vp->val_len);
			StorageNew->sccpRouteTestIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			sccpSrvtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			sccpSrvtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->sccpRouteTestRowStatus;
			StorageTmp->sccpRouteTestRowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				sccpSrvtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			sccpSrvtTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->sccpRouteTestRowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			sccpSrvtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpRouteTestRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->sccpRouteTestRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			sccpSrvtTable_destroy(&StorageDel);
			/* sccpSrvtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
