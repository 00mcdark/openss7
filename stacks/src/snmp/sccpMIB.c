/*****************************************************************************

 @(#) $RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.2 $) $Date: 2008-12-24 13:08:25 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-24 13:08:25 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: sccpMIB.c,v $
 Revision 0.9.2.2  2008-12-24 13:08:25  brian
 - building ss7confd

 *****************************************************************************/

#ident "@(#) $RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.2 $) $Date: 2008-12-24 13:08:25 $"

static char const ident[] = "$RCSfile: sccpMIB.c,v $ $Name:  $($Revision: 0.9.2.2 $) $Date: 2008-12-24 13:08:25 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ss7MIB.h"
#include "x400pMIB.h"
#include "mtpMIB.h"
#include "sccpMIB.h"
#include "sccpOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int sccpMIB_refresh = 1;
volatile int sccpNetworkEntityTable_refresh = 1;
volatile int sccpSapNameTable_refresh = 1;
volatile int sccpAccessPointTable_refresh = 1;
volatile int sccpLinkageTable_refresh = 1;
volatile int sccpSclcTable_refresh = 1;
volatile int sccpScocTable_refresh = 1;
volatile int sccpScrcTable_refresh = 1;
volatile int sccpEntitySetTable_refresh = 1;
volatile int sccpEntitySetSapTable_refresh = 1;
volatile int sccpConcernedAreaTable_refresh = 1;
volatile int sccpRemoteSCCPTable_refresh = 1;
volatile int sccpGtConversionRuleTable_refresh = 1;
volatile int sccpAddressInfoTable_refresh = 1;
volatile int sccpGtTranslatorTable_refresh = 1;
volatile int sccpGtRuleTable_refresh = 1;
volatile int sccpSrvtTable_refresh = 1;

/*
 * sccpMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid sccpMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2 };
oid sccpNetworkEntityTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 1, 1, 1 };
oid sccpSapNameTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 2, 1, 1 };
oid sccpAccessPointTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 3, 1, 1 };
oid sccpLinkageTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 4, 1, 1 };
oid sccpSclcTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 5, 1, 1 };
oid sccpScocTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 6, 1, 1 };
oid sccpScrcTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 7, 1, 1 };
oid sccpEntitySetTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 8, 1, 1 };
oid sccpEntitySetSapTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 9, 1, 1 };
oid sccpConcernedAreaTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 10, 1, 1 };
oid sccpRemoteSCCPTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 11, 1, 1 };
oid sccpGtConversionRuleTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 12, 1, 1 };
oid sccpAddressInfoTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 13, 1, 1 };
oid sccpGtTranslatorTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 14, 1, 1 };
oid sccpGtRuleTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 15, 1, 1 };
oid sccpSrvtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 2, 1, 1, 16, 1, 1 };

/*
 * variable7 sccpMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the sccpMIB mib section
 */
struct variable7 sccpMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   SCCPNETWORKENTITYALARMSTATUS  (4 % 256)
	{SCCPNETWORKENTITYALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 2}},
#define   SCCPSYSTEMTYPES       (8 % 256)
	{SCCPSYSTEMTYPES, ASN_BIT_STR, RONLY, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 6}},
#define   SCCPVERSION           (9 % 256)
	{SCCPVERSION, ASN_OBJECT_ID, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 7}},
#define   SCCPLUDTANDLUDTSSUPPORTED  (10 % 256)
	{SCCPLUDTANDLUDTSSUPPORTED, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 8}},
#define   SCCPCOORDCHANGETIMER  (11 % 256)
	{SCCPCOORDCHANGETIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 9}},
#define   SCCPIGNORESSTTIMER    (12 % 256)
	{SCCPIGNORESSTTIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 10}},
#define   SCCPMAXSTATINFOTIMER  (13 % 256)
	{SCCPMAXSTATINFOTIMER, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 11}},
#define   SCCPNETWORKENTITYNAME  (14 % 256)
	{SCCPNETWORKENTITYNAME, ASN_OCTET_STR, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 12}},
#define   SCCPROWSTATUS         (15 % 256)
	{SCCPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpNetworkEntityTable, 6, {1, 1, 1, 1, 1, 13}},
#define   SCCPSAPNAMEROWSTATUS  (20 % 256)
	{SCCPSAPNAMEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSapNameTable, 6, {1, 1, 2, 1, 1, 1}},
#define   SCCPACCESSPOINTALARMSTATUS  (25 % 256)
	{SCCPACCESSPOINTALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 2}},
#define   SCCPSAP2ADDRESS       (26 % 256)
	{SCCPSAP2ADDRESS, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 3}},
#define   SCCPUSERENTITYNAMES   (27 % 256)
	{SCCPUSERENTITYNAMES, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 4}},
#define   SCCPPROVIDERENTITYNAMES  (28 % 256)
	{SCCPPROVIDERENTITYNAMES, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 5}},
#define   SCCPAVAILABILITYSTATUS  (29 % 256)
	{SCCPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 6}},
#define   SCCPCONCERNEDAREAPOINTER  (30 % 256)
	{SCCPCONCERNEDAREAPOINTER, ASN_UINTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 7}},
#define   SCCPLINKAGEPOINTER    (31 % 256)
	{SCCPLINKAGEPOINTER, ASN_UINTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 8}},
#define   SCCPSSAVAILABLEAFTERSPRESTART  (32 % 256)
	{SCCPSSAVAILABLEAFTERSPRESTART, ASN_INTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 9}},
#define   SCCPACCESSPOINTNAME   (33 % 256)
	{SCCPACCESSPOINTNAME, ASN_OCTET_STR, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 10}},
#define   SCCPACCESSPOINTROWSTATUS  (34 % 256)
	{SCCPACCESSPOINTROWSTATUS, ASN_INTEGER, RWRITE, var_sccpAccessPointTable, 6, {1, 1, 3, 1, 1, 11}},
#define   SCCPOPERATIONALPROTOCOLS  (39 % 256)
	{SCCPOPERATIONALPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 2}},
#define   SCCPSNSAP             (40 % 256)
	{SCCPSNSAP, ASN_OBJECT_ID, RONLY, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 3}},
#define   SCCPATTACKTIMERVALUE  (41 % 256)
	{SCCPATTACKTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 4}},
#define   SCCPDECAYTIMERVALUE   (42 % 256)
	{SCCPDECAYTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 5}},
#define   SCCPNROFRESTRICTIONLEVELS  (43 % 256)
	{SCCPNROFRESTRICTIONLEVELS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 6}},
#define   SCCPNROFSUBLEVELS     (44 % 256)
	{SCCPNROFSUBLEVELS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 7}},
#define   SCCPCLS               (45 % 256)
	{SCCPCLS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 8}},
#define   SCCPCONGESTIONTIMERVALUE  (46 % 256)
	{SCCPCONGESTIONTIMERVALUE, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 9}},
#define   SCCPP                 (47 % 256)
	{SCCPP, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 10}},
#define   SCCPIMPORTANCELEVELCR  (48 % 256)
	{SCCPIMPORTANCELEVELCR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 11}},
#define   SCCPIMPORTANCELEVELCC  (49 % 256)
	{SCCPIMPORTANCELEVELCC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 12}},
#define   SCCPIMPORTANCELEVELCREF  (50 % 256)
	{SCCPIMPORTANCELEVELCREF, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 13}},
#define   SCCPIMPORTANCELEVELDT1  (51 % 256)
	{SCCPIMPORTANCELEVELDT1, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 14}},
#define   SCCPIMPORTANCELEVELDT2  (52 % 256)
	{SCCPIMPORTANCELEVELDT2, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 15}},
#define   SCCPIMPORTANCELEVELAK  (53 % 256)
	{SCCPIMPORTANCELEVELAK, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 16}},
#define   SCCPIMPORTANCELEVELIT  (54 % 256)
	{SCCPIMPORTANCELEVELIT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 17}},
#define   SCCPIMPORTANCELEVELED  (55 % 256)
	{SCCPIMPORTANCELEVELED, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 18}},
#define   SCCPIMPORTANCELEVELEA  (56 % 256)
	{SCCPIMPORTANCELEVELEA, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 19}},
#define   SCCPIMPORTANCELEVELRSR  (57 % 256)
	{SCCPIMPORTANCELEVELRSR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 20}},
#define   SCCPIMPORTANCELEVELRSC  (58 % 256)
	{SCCPIMPORTANCELEVELRSC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 21}},
#define   SCCPIMPORTANCELEVELERR  (59 % 256)
	{SCCPIMPORTANCELEVELERR, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 22}},
#define   SCCPIMPORTANCELEVELRLC  (60 % 256)
	{SCCPIMPORTANCELEVELRLC, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 23}},
#define   SCCPIMPORTANCELEVELRLSD  (61 % 256)
	{SCCPIMPORTANCELEVELRLSD, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 24}},
#define   SCCPIMPORTANCELEVELUDT  (62 % 256)
	{SCCPIMPORTANCELEVELUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 25}},
#define   SCCPIMPORTANCELEVELUDTS  (63 % 256)
	{SCCPIMPORTANCELEVELUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 26}},
#define   SCCPIMPORTANCELEVELXUDT  (64 % 256)
	{SCCPIMPORTANCELEVELXUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 27}},
#define   SCCPIMPORTANCELEVELXUDTS  (65 % 256)
	{SCCPIMPORTANCELEVELXUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 28}},
#define   SCCPIMPORTANCELEVELLUDT  (66 % 256)
	{SCCPIMPORTANCELEVELLUDT, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 29}},
#define   SCCPIMPORTANCELEVELLUDTS  (67 % 256)
	{SCCPIMPORTANCELEVELLUDTS, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 30}},
#define   SCCPRLM               (68 % 256)
	{SCCPRLM, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 31}},
#define   SCCPRSLM              (69 % 256)
	{SCCPRSLM, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 32}},
#define   SCCPLINKAGECONCERNEDAREAPOINTER  (70 % 256)
	{SCCPLINKAGECONCERNEDAREAPOINTER, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 33}},
#define   SCCPLOWERLIMITFORSEGMENTATION  (71 % 256)
	{SCCPLOWERLIMITFORSEGMENTATION, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 34}},
#define   SCCPUPPERLIMITFORSEGMENTATION  (72 % 256)
	{SCCPUPPERLIMITFORSEGMENTATION, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 35}},
#define   SCCPLINKAGENAME       (73 % 256)
	{SCCPLINKAGENAME, ASN_OCTET_STR, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 36}},
#define   SCCPLINKAGEROWSTATUS  (74 % 256)
	{SCCPLINKAGEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpLinkageTable, 6, {1, 1, 4, 1, 1, 37}},
#define   SCCPSCLCALARMSTATUS   (78 % 256)
	{SCCPSCLCALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 1}},
#define   SCCPSCLCOPERATIONALSTATE  (80 % 256)
	{SCCPSCLCOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 3}},
#define   SCCPTOTALREMOTESAPS   (81 % 256)
	{SCCPTOTALREMOTESAPS, ASN_INTEGER, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 4}},
#define   SCCPSCLCADMINISTRATIVESTATE  (82 % 256)
	{SCCPSCLCADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 5}},
#define   SCCPSCLCSUPPORTEDPROTOCOLS  (83 % 256)
	{SCCPSCLCSUPPORTEDPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 6}},
#define   SCCPSCLCOPERATIONALSYSTEMTYPE  (84 % 256)
	{SCCPSCLCOPERATIONALSYSTEMTYPE, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 7}},
#define   SCCPINITIALVALUEREASSTIMER  (85 % 256)
	{SCCPINITIALVALUEREASSTIMER, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 8}},
#define   SCCPSCLCNAME          (86 % 256)
	{SCCPSCLCNAME, ASN_OCTET_STR, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 9}},
#define   SCCPSCLCROWSTATUS     (87 % 256)
	{SCCPSCLCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSclcTable, 6, {1, 1, 5, 1, 1, 10}},
#define   SCCPCOPROTOCOLMACHINEID  (91 % 256)
	{SCCPCOPROTOCOLMACHINEID, ASN_OCTET_STR, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 1}},
#define   SCCPSCOCOPERATIONALSTATE  (92 % 256)
	{SCCPSCOCOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 2}},
#define   SCCPSCOCADMINISTRATIVESTATE  (93 % 256)
	{SCCPSCOCADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 3}},
#define   SCCPSCOCOPERATIONALSYSTEMTYPE  (94 % 256)
	{SCCPSCOCOPERATIONALSYSTEMTYPE, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 4}},
#define   SCCPSCOCSUPPORTEDPROTOCOLS  (95 % 256)
	{SCCPSCOCSUPPORTEDPROTOCOLS, ASN_BIT_STR, RONLY, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 5}},
#define   SCCPSCOCNAME          (96 % 256)
	{SCCPSCOCNAME, ASN_OCTET_STR, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 6}},
#define   SCCPSCOCROWSTATUS     (97 % 256)
	{SCCPSCOCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpScocTable, 6, {1, 1, 6, 1, 1, 7}},
#define   SCCPSCRCID            (101 % 256)
	{SCCPSCRCID, ASN_OCTET_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 1}},
#define   SCCPSCRCALARMSTATUS   (102 % 256)
	{SCCPSCRCALARMSTATUS, ASN_BIT_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 2}},
#define   SCCPSCRCNAME          (103 % 256)
	{SCCPSCRCNAME, ASN_OCTET_STR, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 3}},
#define   SCCPSCRCROWSTATUS     (104 % 256)
	{SCCPSCRCROWSTATUS, ASN_INTEGER, RWRITE, var_sccpScrcTable, 6, {1, 1, 7, 1, 1, 4}},
#define   SCCPSHARINGMODE       (109 % 256)
	{SCCPSHARINGMODE, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 2}},
#define   SCCPLOADSHARINGALGPOINTER  (110 % 256)
	{SCCPLOADSHARINGALGPOINTER, ASN_OBJECT_ID, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 3}},
#define   SCCPENTITYSETNAME     (111 % 256)
	{SCCPENTITYSETNAME, ASN_OCTET_STR, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 4}},
#define   SCCPENTITYSETTYPE     (112 % 256)
	{SCCPENTITYSETTYPE, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 5}},
#define   SCCPENTITYSETSSN      (113 % 256)
	{SCCPENTITYSETSSN, ASN_OCTET_STR, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 6}},
#define   SCCPENTITYSETROWSTATUS  (114 % 256)
	{SCCPENTITYSETROWSTATUS, ASN_INTEGER, RWRITE, var_sccpEntitySetTable, 6, {1, 1, 8, 1, 1, 7}},
#define   SCCPENTITYSETSAPTYPE  (120 % 256)
	{SCCPENTITYSETSAPTYPE, ASN_INTEGER, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 2}},
#define   SCCPENTITYSETSAPPOINTER  (121 % 256)
	{SCCPENTITYSETSAPPOINTER, ASN_OBJECT_ID, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 3}},
#define   SCCPENTITYSETSAPROWSTATUS  (122 % 256)
	{SCCPENTITYSETSAPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpEntitySetSapTable, 6, {1, 1, 9, 1, 1, 4}},
#define   SCCPREMOTESCCPMTPACCESSPOINT  (133 % 256)
	{SCCPREMOTESCCPMTPACCESSPOINT, ASN_OBJECT_ID, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 2}},
#define   SCCPREMOTESCCPNAME    (134 % 256)
	{SCCPREMOTESCCPNAME, ASN_OCTET_STR, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 3}},
#define   SCCPREMOTESCCPROWSTATUS  (135 % 256)
	{SCCPREMOTESCCPROWSTATUS, ASN_INTEGER, RWRITE, var_sccpRemoteSCCPTable, 6, {1, 1, 11, 1, 1, 4}},
#define   SCCPGTNEWENCODINGSCHEME  (140 % 256)
	{SCCPGTNEWENCODINGSCHEME, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 2}},
#define   SCCPGTNEWNATUREOFADDRESS  (141 % 256)
	{SCCPGTNEWNATUREOFADDRESS, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 3}},
#define   SCCPGTNEWNUMBERINGPLAN  (142 % 256)
	{SCCPGTNEWNUMBERINGPLAN, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 4}},
#define   SCCPGTNEWTRANSLATIONTYPE  (143 % 256)
	{SCCPGTNEWTRANSLATIONTYPE, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 5}},
#define   SCCPGTCONVERSIONRULENAME  (144 % 256)
	{SCCPGTCONVERSIONRULENAME, ASN_OCTET_STR, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 6}},
#define   SCCPGTCONVERSIONRULEROWSTATUS  (145 % 256)
	{SCCPGTCONVERSIONRULEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtConversionRuleTable, 6, {1, 1, 12, 1, 1, 7}},
#define   SCCPADDRESSINFOOPERATION  (151 % 256)
	{SCCPADDRESSINFOOPERATION, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 2}},
#define   SCCPADDRESSINFOADDRESSELEMENT  (152 % 256)
	{SCCPADDRESSINFOADDRESSELEMENT, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 3}},
#define   SCCPADDRESSINFONROFADDRESSELEMENTS  (153 % 256)
	{SCCPADDRESSINFONROFADDRESSELEMENTS, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 4}},
#define   SCCPADDRESSINFOROWSTATUS  (154 % 256)
	{SCCPADDRESSINFOROWSTATUS, ASN_INTEGER, RWRITE, var_sccpAddressInfoTable, 6, {1, 1, 13, 1, 1, 5}},
#define   SCCPGTINDICATOR       (159 % 256)
	{SCCPGTINDICATOR, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 2}},
#define   SCCPGTNATUREOFADDRESS  (160 % 256)
	{SCCPGTNATUREOFADDRESS, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 3}},
#define   SCCPGTNUMBERINGPLAN   (161 % 256)
	{SCCPGTNUMBERINGPLAN, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 4}},
#define   SCCPGTTRANSLATIONTYPE  (162 % 256)
	{SCCPGTTRANSLATIONTYPE, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 5}},
#define   SCCPGTTRANSLATORADMINISTRATIVESTATE  (163 % 256)
	{SCCPGTTRANSLATORADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 6}},
#define   SCCPGTTRANSLATORNAME  (164 % 256)
	{SCCPGTTRANSLATORNAME, ASN_OCTET_STR, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 7}},
#define   SCCPGTTRANSLATORROWSTATUS  (165 % 256)
	{SCCPGTTRANSLATORROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtTranslatorTable, 6, {1, 1, 14, 1, 1, 8}},
#define   SCCPGTRULEADMINISTRATIVESTATE  (171 % 256)
	{SCCPGTRULEADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 2}},
#define   SCCPGTADDRESSINFORMATION  (172 % 256)
	{SCCPGTADDRESSINFORMATION, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 3}},
#define   SCCPGTCONVRULEPOINTER  (173 % 256)
	{SCCPGTCONVRULEPOINTER, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 4}},
#define   SCCPGTENCODINGSCHEME  (174 % 256)
	{SCCPGTENCODINGSCHEME, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 5}},
#define   SCCPENTITYSETPOINTER  (175 % 256)
	{SCCPENTITYSETPOINTER, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 6}},
#define   SCCPGTRULENAME        (176 % 256)
	{SCCPGTRULENAME, ASN_OCTET_STR, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 7}},
#define   SCCPGTRULEROWSTATUS   (177 % 256)
	{SCCPGTRULEROWSTATUS, ASN_INTEGER, RWRITE, var_sccpGtRuleTable, 6, {1, 1, 15, 1, 1, 8}},
#define   SCCPDSRVT             (182 % 256)
	{SCCPDSRVT, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 2}},
#define   SCCPNSRVT             (183 % 256)
	{SCCPNSRVT, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 3}},
#define   SCCPSRVTNAME          (184 % 256)
	{SCCPSRVTNAME, ASN_OCTET_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 4}},
#define   SCCPADMINISTRATIVESTATE  (185 % 256)
	{SCCPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 5}},
#define   SCCPOPERATIONALSTATE  (186 % 256)
	{SCCPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 6}},
#define   SCCPPROCEDURALSTATUS  (187 % 256)
	{SCCPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 7}},
#define   SCCPTRACEREQUESTED    (188 % 256)
	{SCCPTRACEREQUESTED, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 8}},
#define   SCCPTHRESHOLD         (189 % 256)
	{SCCPTHRESHOLD, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 9}},
#define   SCCPMTPBACKWARDROUTINGREQUESTED  (190 % 256)
	{SCCPMTPBACKWARDROUTINGREQUESTED, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 10}},
#define   SCCPORIGINALGT        (191 % 256)
	{SCCPORIGINALGT, ASN_OCTET_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 11}},
#define   SCCPINFOREQUEST       (192 % 256)
	{SCCPINFOREQUEST, ASN_BIT_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 12}},
#define   SCCPRETURNUNKNOWNPARAMS  (193 % 256)
	{SCCPRETURNUNKNOWNPARAMS, ASN_BIT_STR, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 13}},
#define   SCCPROUTETESTROWSTATUS  (194 % 256)
	{SCCPROUTETESTROWSTATUS, ASN_INTEGER, RWRITE, var_sccpSrvtTable, 6, {1, 1, 16, 1, 1, 14}},

};

/*    (L = length of the oidsuffix) */
struct sccpMIB_data *sccpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *sccpNetworkEntityTableStorage = NULL;
struct header_complex_index *sccpSapNameTableStorage = NULL;
struct header_complex_index *sccpAccessPointTableStorage = NULL;
struct header_complex_index *sccpLinkageTableStorage = NULL;
struct header_complex_index *sccpSclcTableStorage = NULL;
struct header_complex_index *sccpScocTableStorage = NULL;
struct header_complex_index *sccpScrcTableStorage = NULL;
struct header_complex_index *sccpEntitySetTableStorage = NULL;
struct header_complex_index *sccpEntitySetSapTableStorage = NULL;
struct header_complex_index *sccpConcernedAreaTableStorage = NULL;
struct header_complex_index *sccpRemoteSCCPTableStorage = NULL;
struct header_complex_index *sccpGtConversionRuleTableStorage = NULL;
struct header_complex_index *sccpAddressInfoTableStorage = NULL;
struct header_complex_index *sccpGtTranslatorTableStorage = NULL;
struct header_complex_index *sccpGtRuleTableStorage = NULL;
struct header_complex_index *sccpSrvtTableStorage = NULL;

/*
 * init_sccpMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_sccpMIB(void)
{
	DEBUGMSGTL(("sccpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("sccpMIB", sccpMIB_variables, variable7, sccpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_sccpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("sccpMIB", parse_sccpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpNetworkEntityTable", parse_sccpNetworkEntityTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSapNameTable", parse_sccpSapNameTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpAccessPointTable", parse_sccpAccessPointTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpLinkageTable", parse_sccpLinkageTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSclcTable", parse_sccpSclcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpScocTable", parse_sccpScocTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpScrcTable", parse_sccpScrcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpEntitySetTable", parse_sccpEntitySetTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpEntitySetSapTable", parse_sccpEntitySetSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpConcernedAreaTable", parse_sccpConcernedAreaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpRemoteSCCPTable", parse_sccpRemoteSCCPTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtConversionRuleTable", parse_sccpGtConversionRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpAddressInfoTable", parse_sccpAddressInfoTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtTranslatorTable", parse_sccpGtTranslatorTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpGtRuleTable", parse_sccpGtRuleTable, NULL, "HELP STRING");
	snmpd_register_config_handler("sccpSrvtTable", parse_sccpSrvtTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpNetworkEntityTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSapNameTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpAccessPointTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpLinkageTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSclcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpScocTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpScrcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpEntitySetTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpEntitySetSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpConcernedAreaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpRemoteSCCPTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtConversionRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpAddressInfoTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtTranslatorTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpGtRuleTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_sccpSrvtTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

/*
 * deinit_sccpMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_sccpMIB(void)
{
	DEBUGMSGTL(("sccpMIB", "deinitializating...  "));
	unregister_mib(sccpMIB_variables_oid, sizeof(sccpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("sccpMIB");
	snmpd_unregister_config_handler("sccpNetworkEntityTable");
	snmpd_unregister_config_handler("sccpSapNameTable");
	snmpd_unregister_config_handler("sccpAccessPointTable");
	snmpd_unregister_config_handler("sccpLinkageTable");
	snmpd_unregister_config_handler("sccpSclcTable");
	snmpd_unregister_config_handler("sccpScocTable");
	snmpd_unregister_config_handler("sccpScrcTable");
	snmpd_unregister_config_handler("sccpEntitySetTable");
	snmpd_unregister_config_handler("sccpEntitySetSapTable");
	snmpd_unregister_config_handler("sccpConcernedAreaTable");
	snmpd_unregister_config_handler("sccpRemoteSCCPTable");
	snmpd_unregister_config_handler("sccpGtConversionRuleTable");
	snmpd_unregister_config_handler("sccpAddressInfoTable");
	snmpd_unregister_config_handler("sccpGtTranslatorTable");
	snmpd_unregister_config_handler("sccpGtRuleTable");
	snmpd_unregister_config_handler("sccpSrvtTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

int
term_sccpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_sccpMIB();
	return 0;
}

/*
 * sccpMIB_add(): adds a structure node for scalars
 */
int
sccpMIB_add(struct sccpMIB_data *thedata)
{
	DEBUGMSGTL(("sccpMIB", "adding data...  "));
	sccpMIBStorage = thedata;
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpMIB_data);

	DEBUGMSGTL(("sccpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	sccpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpMIB", "done.\n"));
}

/*
 * store_sccpMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpMIB_data *StorageTmp;

	DEBUGMSGTL(("sccpMIB", "storing data...  "));
	refresh_sccpMIB();
	if ((StorageTmp = sccpMIBStorage) == NULL) {
		DEBUGMSGTL(("sccpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->sccpMIBStorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "sccpMIB ");
	cptr = line + strlen(line);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("sccpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_sccpMIB: refresh sccpMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_sccpMIB(void)
{
	if (sccpMIBStorage == NULL) {
		struct sccpMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(sccpMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */

		sccpMIBStorage = StorageNew;
		sccpMIB_refresh = 1;
	}
	if (sccpMIB_refresh == 0)
		return;
	sccpMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_sccpMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_sccpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_sccpMIB();
	if ((StorageTmp = sccpMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * sccpNetworkEntityTable_add(): adds a structure node to our data set
 */
int
sccpNetworkEntityTable_add(struct sccpNetworkEntityTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpNetworkEntityTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&sccpNetworkEntityTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpNetworkEntityTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpNetworkEntityTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpNetworkEntityTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpNetworkEntityTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpNetworkEntityTable_data);

	DEBUGMSGTL(("sccpNetworkEntityTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpNetworkEntityAlarmStatus, &tmpsize);
	StorageTmp->sccpNetworkEntityAlarmStatusLen = tmpsize;
	if (StorageTmp->sccpNetworkEntityAlarmStatus == NULL) {
		config_perror("invalid specification for sccpNetworkEntityAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpCommunicationsEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLocalSapNames, &tmpsize);
	StorageTmp->sccpLocalSapNamesLen = tmpsize;
	if (StorageTmp->sccpLocalSapNames == NULL) {
		config_perror("invalid specification for sccpLocalSapNames");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpNetworkEntityTitles, &tmpsize);
	StorageTmp->sccpNetworkEntityTitlesLen = tmpsize;
	if (StorageTmp->sccpNetworkEntityTitles == NULL) {
		config_perror("invalid specification for sccpNetworkEntityTitles");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSystemTypes, &tmpsize);
	StorageTmp->sccpSystemTypesLen = tmpsize;
	if (StorageTmp->sccpSystemTypes == NULL) {
		config_perror("invalid specification for sccpSystemTypes");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpVersion, &tmpsize);
	StorageTmp->sccpVersionLen = tmpsize;
	if (StorageTmp->sccpVersion == NULL) {
		config_perror("invalid specification for sccpVersion");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLUDTandLUDTSSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCoordChangeTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpIgnoreSSTTimer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpMaxStatInfoTimer, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpNetworkEntityName, &tmpsize);
	StorageTmp->sccpNetworkEntityNameLen = tmpsize;
	if (StorageTmp->sccpNetworkEntityName == NULL) {
		config_perror("invalid specification for sccpNetworkEntityName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRowStatus, &tmpsize);

	sccpNetworkEntityTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
}

/*
 * store_sccpNetworkEntityTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpNetworkEntityTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpNetworkEntityTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpNetworkEntityTable", "storing data...  "));
	refresh_sccpNetworkEntityTable();
	(void) tmpsize;
	for (hcindex = sccpNetworkEntityTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpNetworkEntityTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpNetworkEntityTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpNetworkEntityTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpNetworkEntityAlarmStatus, &tmpsize);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpCommunicationsEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpLocalSapNamesLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLocalSapNames, &tmpsize);
		tmpsize = StorageTmp->sccpNetworkEntityTitlesLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpNetworkEntityTitles, &tmpsize);
		tmpsize = StorageTmp->sccpSystemTypesLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSystemTypes, &tmpsize);
		tmpsize = StorageTmp->sccpVersionLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpVersion, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLUDTandLUDTSSupported, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCoordChangeTimer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpIgnoreSSTTimer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpMaxStatInfoTimer, &tmpsize);
		tmpsize = StorageTmp->sccpNetworkEntityNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpNetworkEntityName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpNetworkEntityTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpSapNameTable_add(): adds a structure node to our data set
 */
int
sccpSapNameTable_add(struct sccpSapNameTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSapNameTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpSapId, sizeof(thedata->sccpSapId));

	header_complex_add_data(&sccpSapNameTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSapNameTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpSapNameTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpSapNameTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSapNameTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpSapNameTable_data);

	DEBUGMSGTL(("sccpSapNameTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpSapId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSapNameRowStatus, &tmpsize);

	sccpSapNameTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
}

/*
 * store_sccpSapNameTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpSapNameTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSapNameTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSapNameTable", "storing data...  "));
	refresh_sccpSapNameTable();
	(void) tmpsize;
	for (hcindex = sccpSapNameTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSapNameTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpSapNameTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpSapNameTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpSapId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSapNameRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpSapNameTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpAccessPointTable_add(): adds a structure node to our data set
 */
int
sccpAccessPointTable_add(struct sccpAccessPointTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpAccessPointTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpSapId, sizeof(thedata->sccpSapId));

	header_complex_add_data(&sccpAccessPointTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpAccessPointTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpAccessPointTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpAccessPointTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpAccessPointTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpAccessPointTable_data);

	DEBUGMSGTL(("sccpAccessPointTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpSapId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpAccessPointAlarmStatus, &tmpsize);
	StorageTmp->sccpAccessPointAlarmStatusLen = tmpsize;
	if (StorageTmp->sccpAccessPointAlarmStatus == NULL) {
		config_perror("invalid specification for sccpAccessPointAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSap2Address, &tmpsize);
	StorageTmp->sccpSap2AddressLen = tmpsize;
	if (StorageTmp->sccpSap2Address == NULL) {
		config_perror("invalid specification for sccpSap2Address");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpUserEntityNames, &tmpsize);
	StorageTmp->sccpUserEntityNamesLen = tmpsize;
	if (StorageTmp->sccpUserEntityNames == NULL) {
		config_perror("invalid specification for sccpUserEntityNames");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpProviderEntityNames, &tmpsize);
	StorageTmp->sccpProviderEntityNamesLen = tmpsize;
	if (StorageTmp->sccpProviderEntityNames == NULL) {
		config_perror("invalid specification for sccpProviderEntityNames");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpAvailabilityStatus, &tmpsize);
	StorageTmp->sccpAvailabilityStatusLen = tmpsize;
	if (StorageTmp->sccpAvailabilityStatus == NULL) {
		config_perror("invalid specification for sccpAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpConcernedAreaPointer, &tmpsize);
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpLinkagePointer, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSsAvailableAfterSpRestart, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpAccessPointName, &tmpsize);
	StorageTmp->sccpAccessPointNameLen = tmpsize;
	if (StorageTmp->sccpAccessPointName == NULL) {
		config_perror("invalid specification for sccpAccessPointName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAccessPointRowStatus, &tmpsize);

	sccpAccessPointTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
}

/*
 * store_sccpAccessPointTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpAccessPointTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpAccessPointTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpAccessPointTable", "storing data...  "));
	refresh_sccpAccessPointTable();
	(void) tmpsize;
	for (hcindex = sccpAccessPointTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpAccessPointTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpAccessPointTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpAccessPointTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpSapId, &tmpsize);
		tmpsize = StorageTmp->sccpAccessPointAlarmStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpAccessPointAlarmStatus, &tmpsize);
		tmpsize = StorageTmp->sccpSap2AddressLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSap2Address, &tmpsize);
		tmpsize = StorageTmp->sccpUserEntityNamesLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpUserEntityNames, &tmpsize);
		tmpsize = StorageTmp->sccpProviderEntityNamesLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpProviderEntityNames, &tmpsize);
		tmpsize = StorageTmp->sccpAvailabilityStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpAvailabilityStatus, &tmpsize);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpConcernedAreaPointer, &tmpsize);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpLinkagePointer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSsAvailableAfterSpRestart, &tmpsize);
		tmpsize = StorageTmp->sccpAccessPointNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpAccessPointName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAccessPointRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpAccessPointTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpLinkageTable_add(): adds a structure node to our data set
 */
int
sccpLinkageTable_add(struct sccpLinkageTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpLinkageTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpLinkageId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpLinkageId, sizeof(thedata->sccpLinkageId));

	header_complex_add_data(&sccpLinkageTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpLinkageTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpLinkageTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpLinkageTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpLinkageTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpLinkageTable_data);

	DEBUGMSGTL(("sccpLinkageTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpLinkageId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpOperationalProtocols, &tmpsize);
	StorageTmp->sccpOperationalProtocolsLen = tmpsize;
	if (StorageTmp->sccpOperationalProtocols == NULL) {
		config_perror("invalid specification for sccpOperationalProtocols");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpSnSAP, &tmpsize);
	StorageTmp->sccpSnSAPLen = tmpsize;
	if (StorageTmp->sccpSnSAP == NULL) {
		config_perror("invalid specification for sccpSnSAP");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAttackTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpDecayTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNrOfRestrictionLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNrOfSubLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCLS, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpCongestionTimerValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpp, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCR, &tmpsize);
	StorageTmp->sccpImportanceLevelCRLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelCR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCR");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCC, &tmpsize);
	StorageTmp->sccpImportanceLevelCCLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelCC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCC");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelCREF, &tmpsize);
	StorageTmp->sccpImportanceLevelCREFLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelCREF == NULL) {
		config_perror("invalid specification for sccpImportanceLevelCREF");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelDT1, &tmpsize);
	StorageTmp->sccpImportanceLevelDT1Len = tmpsize;
	if (StorageTmp->sccpImportanceLevelDT1 == NULL) {
		config_perror("invalid specification for sccpImportanceLevelDT1");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelDT2, &tmpsize);
	StorageTmp->sccpImportanceLevelDT2Len = tmpsize;
	if (StorageTmp->sccpImportanceLevelDT2 == NULL) {
		config_perror("invalid specification for sccpImportanceLevelDT2");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelAK, &tmpsize);
	StorageTmp->sccpImportanceLevelAKLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelAK == NULL) {
		config_perror("invalid specification for sccpImportanceLevelAK");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelIT, &tmpsize);
	StorageTmp->sccpImportanceLevelITLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelIT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelIT");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelED, &tmpsize);
	StorageTmp->sccpImportanceLevelEDLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelED == NULL) {
		config_perror("invalid specification for sccpImportanceLevelED");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelEA, &tmpsize);
	StorageTmp->sccpImportanceLevelEALen = tmpsize;
	if (StorageTmp->sccpImportanceLevelEA == NULL) {
		config_perror("invalid specification for sccpImportanceLevelEA");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRSR, &tmpsize);
	StorageTmp->sccpImportanceLevelRSRLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelRSR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRSR");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRSC, &tmpsize);
	StorageTmp->sccpImportanceLevelRSCLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelRSC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRSC");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelERR, &tmpsize);
	StorageTmp->sccpImportanceLevelERRLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelERR == NULL) {
		config_perror("invalid specification for sccpImportanceLevelERR");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRLC, &tmpsize);
	StorageTmp->sccpImportanceLevelRLCLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelRLC == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRLC");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelRLSD, &tmpsize);
	StorageTmp->sccpImportanceLevelRLSDLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelRLSD == NULL) {
		config_perror("invalid specification for sccpImportanceLevelRLSD");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelUDT, &tmpsize);
	StorageTmp->sccpImportanceLevelUDTLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelUDT");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelUDTS, &tmpsize);
	StorageTmp->sccpImportanceLevelUDTSLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelUDTS");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelXUDT, &tmpsize);
	StorageTmp->sccpImportanceLevelXUDTLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelXUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelXUDT");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelXUDTS, &tmpsize);
	StorageTmp->sccpImportanceLevelXUDTSLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelXUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelXUDTS");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelLUDT, &tmpsize);
	StorageTmp->sccpImportanceLevelLUDTLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelLUDT == NULL) {
		config_perror("invalid specification for sccpImportanceLevelLUDT");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpImportanceLevelLUDTS, &tmpsize);
	StorageTmp->sccpImportanceLevelLUDTSLen = tmpsize;
	if (StorageTmp->sccpImportanceLevelLUDTS == NULL) {
		config_perror("invalid specification for sccpImportanceLevelLUDTS");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRLM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRSLM, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLinkageConcernedAreaPointer, &tmpsize);
	StorageTmp->sccpLinkageConcernedAreaPointerLen = tmpsize;
	if (StorageTmp->sccpLinkageConcernedAreaPointer == NULL) {
		config_perror("invalid specification for sccpLinkageConcernedAreaPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLowerLimitForSegmentation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpUpperLimitForSegmentation, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpLinkageName, &tmpsize);
	StorageTmp->sccpLinkageNameLen = tmpsize;
	if (StorageTmp->sccpLinkageName == NULL) {
		config_perror("invalid specification for sccpLinkageName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpLinkageRowStatus, &tmpsize);

	sccpLinkageTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
}

/*
 * store_sccpLinkageTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpLinkageTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpLinkageTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpLinkageTable", "storing data...  "));
	refresh_sccpLinkageTable();
	(void) tmpsize;
	for (hcindex = sccpLinkageTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpLinkageTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpLinkageTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpLinkageTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpLinkageId, &tmpsize);
		tmpsize = StorageTmp->sccpOperationalProtocolsLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpOperationalProtocols, &tmpsize);
		tmpsize = StorageTmp->sccpSnSAPLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpSnSAP, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAttackTimerValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpDecayTimerValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNrOfRestrictionLevels, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNrOfSubLevels, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCLS, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpCongestionTimerValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpp, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelCRLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCR, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelCCLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCC, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelCREFLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelCREF, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelDT1Len;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelDT1, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelDT2Len;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelDT2, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelAKLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelAK, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelITLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelIT, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelEDLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelED, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelEALen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelEA, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelRSRLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRSR, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelRSCLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRSC, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelERRLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelERR, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelRLCLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRLC, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelRLSDLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelRLSD, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelUDTLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelUDT, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelUDTSLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelUDTS, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelXUDTLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelXUDT, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelXUDTSLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelXUDTS, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelLUDTLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelLUDT, &tmpsize);
		tmpsize = StorageTmp->sccpImportanceLevelLUDTSLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpImportanceLevelLUDTS, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRLM, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRSLM, &tmpsize);
		tmpsize = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLinkageConcernedAreaPointer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLowerLimitForSegmentation, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpUpperLimitForSegmentation, &tmpsize);
		tmpsize = StorageTmp->sccpLinkageNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpLinkageName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpLinkageRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpLinkageTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpSclcTable_add(): adds a structure node to our data set
 */
int
sccpSclcTable_add(struct sccpSclcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSclcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&sccpSclcTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSclcTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpSclcTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpSclcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSclcTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpSclcTable_data);

	DEBUGMSGTL(("sccpSclcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSclcAlarmStatus, &tmpsize);
	StorageTmp->sccpSclcAlarmStatusLen = tmpsize;
	if (StorageTmp->sccpSclcAlarmStatus == NULL) {
		config_perror("invalid specification for sccpSclcAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpClProtocolMachineId, &tmpsize);
	StorageTmp->sccpClProtocolMachineIdLen = tmpsize;
	if (StorageTmp->sccpClProtocolMachineId == NULL) {
		config_perror("invalid specification for sccpClProtocolMachineId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpTotalRemoteSAPs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpSclcSupportedProtocols, &tmpsize);
	StorageTmp->sccpSclcSupportedProtocolsLen = tmpsize;
	if (StorageTmp->sccpSclcSupportedProtocols == NULL) {
		config_perror("invalid specification for sccpSclcSupportedProtocols");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcOperationalSystemType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpInitialValueReassTimer, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSclcName, &tmpsize);
	StorageTmp->sccpSclcNameLen = tmpsize;
	if (StorageTmp->sccpSclcName == NULL) {
		config_perror("invalid specification for sccpSclcName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSclcRowStatus, &tmpsize);

	sccpSclcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
}

/*
 * store_sccpSclcTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpSclcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSclcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSclcTable", "storing data...  "));
	refresh_sccpSclcTable();
	(void) tmpsize;
	for (hcindex = sccpSclcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSclcTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpSclcTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpSclcTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpSclcAlarmStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSclcAlarmStatus, &tmpsize);
		tmpsize = StorageTmp->sccpClProtocolMachineIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpClProtocolMachineId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcOperationalState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpTotalRemoteSAPs, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->sccpSclcSupportedProtocolsLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpSclcSupportedProtocols, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcOperationalSystemType, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpInitialValueReassTimer, &tmpsize);
		tmpsize = StorageTmp->sccpSclcNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSclcName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSclcRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpSclcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpScocTable_add(): adds a structure node to our data set
 */
int
sccpScocTable_add(struct sccpScocTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpScocTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&sccpScocTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpScocTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpScocTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpScocTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpScocTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpScocTable_data);

	DEBUGMSGTL(("sccpScocTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpCoProtocolMachineId, &tmpsize);
	StorageTmp->sccpCoProtocolMachineIdLen = tmpsize;
	if (StorageTmp->sccpCoProtocolMachineId == NULL) {
		config_perror("invalid specification for sccpCoProtocolMachineId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocOperationalSystemType, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpScocSupportedProtocols, &tmpsize);
	StorageTmp->sccpScocSupportedProtocolsLen = tmpsize;
	if (StorageTmp->sccpScocSupportedProtocols == NULL) {
		config_perror("invalid specification for sccpScocSupportedProtocols");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScocName, &tmpsize);
	StorageTmp->sccpScocNameLen = tmpsize;
	if (StorageTmp->sccpScocName == NULL) {
		config_perror("invalid specification for sccpScocName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScocRowStatus, &tmpsize);

	sccpScocTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
}

/*
 * store_sccpScocTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpScocTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpScocTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpScocTable", "storing data...  "));
	refresh_sccpScocTable();
	(void) tmpsize;
	for (hcindex = sccpScocTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpScocTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpScocTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpScocTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpCoProtocolMachineIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpCoProtocolMachineId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocOperationalState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocOperationalSystemType, &tmpsize);
		tmpsize = StorageTmp->sccpScocSupportedProtocolsLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpScocSupportedProtocols, &tmpsize);
		tmpsize = StorageTmp->sccpScocNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScocName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScocRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpScocTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpScrcTable_add(): adds a structure node to our data set
 */
int
sccpScrcTable_add(struct sccpScrcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpScrcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&sccpScrcTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpScrcTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpScrcTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpScrcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpScrcTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpScrcTable_data);

	DEBUGMSGTL(("sccpScrcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScrcId, &tmpsize);
	StorageTmp->sccpScrcIdLen = tmpsize;
	if (StorageTmp->sccpScrcId == NULL) {
		config_perror("invalid specification for sccpScrcId");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpScrcAlarmStatus, &tmpsize);
	StorageTmp->sccpScrcAlarmStatusLen = tmpsize;
	if (StorageTmp->sccpScrcAlarmStatus == NULL) {
		config_perror("invalid specification for sccpScrcAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpScrcName, &tmpsize);
	StorageTmp->sccpScrcNameLen = tmpsize;
	if (StorageTmp->sccpScrcName == NULL) {
		config_perror("invalid specification for sccpScrcName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpScrcRowStatus, &tmpsize);

	sccpScrcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
}

/*
 * store_sccpScrcTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpScrcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpScrcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpScrcTable", "storing data...  "));
	refresh_sccpScrcTable();
	(void) tmpsize;
	for (hcindex = sccpScrcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpScrcTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpScrcTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpScrcTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpScrcIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScrcId, &tmpsize);
		tmpsize = StorageTmp->sccpScrcAlarmStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpScrcAlarmStatus, &tmpsize);
		tmpsize = StorageTmp->sccpScrcNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpScrcName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpScrcRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpScrcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpEntitySetTable_add(): adds a structure node to our data set
 */
int
sccpEntitySetTable_add(struct sccpEntitySetTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpEntitySetTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpEntitySetId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpEntitySetId, thedata->sccpEntitySetIdLen);

	header_complex_add_data(&sccpEntitySetTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpEntitySetTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpEntitySetTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpEntitySetTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpEntitySetTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpEntitySetTable_data);

	DEBUGMSGTL(("sccpEntitySetTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetId, &tmpsize);
	StorageTmp->sccpEntitySetIdLen = tmpsize;
	if (StorageTmp->sccpEntitySetId == NULL) {
		config_perror("invalid specification for sccpEntitySetId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpSharingMode, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpLoadSharingAlgPointer, &tmpsize);
	StorageTmp->sccpLoadSharingAlgPointerLen = tmpsize;
	if (StorageTmp->sccpLoadSharingAlgPointer == NULL) {
		config_perror("invalid specification for sccpLoadSharingAlgPointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetName, &tmpsize);
	StorageTmp->sccpEntitySetNameLen = tmpsize;
	if (StorageTmp->sccpEntitySetName == NULL) {
		config_perror("invalid specification for sccpEntitySetName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetSsn, &tmpsize);
	StorageTmp->sccpEntitySetSsnLen = tmpsize;
	if (StorageTmp->sccpEntitySetSsn == NULL) {
		config_perror("invalid specification for sccpEntitySetSsn");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetRowStatus, &tmpsize);

	sccpEntitySetTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
}

/*
 * store_sccpEntitySetTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpEntitySetTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpEntitySetTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpEntitySetTable", "storing data...  "));
	refresh_sccpEntitySetTable();
	(void) tmpsize;
	for (hcindex = sccpEntitySetTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpEntitySetTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpEntitySetTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpEntitySetTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpSharingMode, &tmpsize);
		tmpsize = StorageTmp->sccpLoadSharingAlgPointerLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpLoadSharingAlgPointer, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetType, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetSsnLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetSsn, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpEntitySetTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpEntitySetSapTable_add(): adds a structure node to our data set
 */
int
sccpEntitySetSapTable_add(struct sccpEntitySetSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpEntitySetSapTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpEntitySetId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpEntitySetId, thedata->sccpEntitySetIdLen);
	/* sccpEntitySetSapId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpEntitySetSapId, thedata->sccpEntitySetSapIdLen);

	header_complex_add_data(&sccpEntitySetSapTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpEntitySetSapTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpEntitySetSapTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpEntitySetSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpEntitySetSapTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpEntitySetSapTable_data);

	DEBUGMSGTL(("sccpEntitySetSapTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetId, &tmpsize);
	StorageTmp->sccpEntitySetIdLen = tmpsize;
	if (StorageTmp->sccpEntitySetId == NULL) {
		config_perror("invalid specification for sccpEntitySetId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetSapId, &tmpsize);
	StorageTmp->sccpEntitySetSapIdLen = tmpsize;
	if (StorageTmp->sccpEntitySetSapId == NULL) {
		config_perror("invalid specification for sccpEntitySetSapId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetSapType, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpEntitySetSapPointer, &tmpsize);
	StorageTmp->sccpEntitySetSapPointerLen = tmpsize;
	if (StorageTmp->sccpEntitySetSapPointer == NULL) {
		config_perror("invalid specification for sccpEntitySetSapPointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpEntitySetSapRowStatus, &tmpsize);

	sccpEntitySetSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
}

/*
 * store_sccpEntitySetSapTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpEntitySetSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpEntitySetSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpEntitySetSapTable", "storing data...  "));
	refresh_sccpEntitySetSapTable();
	(void) tmpsize;
	for (hcindex = sccpEntitySetSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpEntitySetSapTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpEntitySetSapTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpEntitySetSapTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetId, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetSapIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetSapId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetSapType, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetSapPointerLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpEntitySetSapPointer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpEntitySetSapRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpEntitySetSapTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpConcernedAreaTable_add(): adds a structure node to our data set
 */
int
sccpConcernedAreaTable_add(struct sccpConcernedAreaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpConcernedAreaTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpConcernedAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpConcernedAreaId, thedata->sccpConcernedAreaIdLen);

	header_complex_add_data(&sccpConcernedAreaTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpConcernedAreaTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpConcernedAreaTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpConcernedAreaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpConcernedAreaTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpConcernedAreaTable_data);

	DEBUGMSGTL(("sccpConcernedAreaTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpConcernedAreaId, &tmpsize);
	StorageTmp->sccpConcernedAreaIdLen = tmpsize;
	if (StorageTmp->sccpConcernedAreaId == NULL) {
		config_perror("invalid specification for sccpConcernedAreaId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpConcernedAreaRowStatus, &tmpsize);

	sccpConcernedAreaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
}

/*
 * store_sccpConcernedAreaTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpConcernedAreaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpConcernedAreaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpConcernedAreaTable", "storing data...  "));
	refresh_sccpConcernedAreaTable();
	(void) tmpsize;
	for (hcindex = sccpConcernedAreaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpConcernedAreaTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpConcernedAreaTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpConcernedAreaTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpConcernedAreaIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpConcernedAreaId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpConcernedAreaRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpConcernedAreaTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpRemoteSCCPTable_add(): adds a structure node to our data set
 */
int
sccpRemoteSCCPTable_add(struct sccpRemoteSCCPTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpConcernedAreaId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpConcernedAreaId, thedata->sccpConcernedAreaIdLen);
	/* sccpRemoteSCCPId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpRemoteSCCPId, thedata->sccpRemoteSCCPIdLen);

	header_complex_add_data(&sccpRemoteSCCPTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpRemoteSCCPTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpRemoteSCCPTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpRemoteSCCPTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpRemoteSCCPTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpRemoteSCCPTable_data);

	DEBUGMSGTL(("sccpRemoteSCCPTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpConcernedAreaId, &tmpsize);
	StorageTmp->sccpConcernedAreaIdLen = tmpsize;
	if (StorageTmp->sccpConcernedAreaId == NULL) {
		config_perror("invalid specification for sccpConcernedAreaId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRemoteSCCPId, &tmpsize);
	StorageTmp->sccpRemoteSCCPIdLen = tmpsize;
	if (StorageTmp->sccpRemoteSCCPId == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPId");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->sccpRemoteSCCPMTPAccessPoint, &tmpsize);
	StorageTmp->sccpRemoteSCCPMTPAccessPointLen = tmpsize;
	if (StorageTmp->sccpRemoteSCCPMTPAccessPoint == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPMTPAccessPoint");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRemoteSCCPName, &tmpsize);
	StorageTmp->sccpRemoteSCCPNameLen = tmpsize;
	if (StorageTmp->sccpRemoteSCCPName == NULL) {
		config_perror("invalid specification for sccpRemoteSCCPName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRemoteSCCPRowStatus, &tmpsize);

	sccpRemoteSCCPTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
}

/*
 * store_sccpRemoteSCCPTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpRemoteSCCPTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpRemoteSCCPTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpRemoteSCCPTable", "storing data...  "));
	refresh_sccpRemoteSCCPTable();
	(void) tmpsize;
	for (hcindex = sccpRemoteSCCPTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpRemoteSCCPTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpRemoteSCCPTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpRemoteSCCPTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpConcernedAreaIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpConcernedAreaId, &tmpsize);
		tmpsize = StorageTmp->sccpRemoteSCCPIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRemoteSCCPId, &tmpsize);
		tmpsize = StorageTmp->sccpRemoteSCCPMTPAccessPointLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->sccpRemoteSCCPMTPAccessPoint, &tmpsize);
		tmpsize = StorageTmp->sccpRemoteSCCPNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRemoteSCCPName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRemoteSCCPRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpRemoteSCCPTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpGtConversionRuleTable_add(): adds a structure node to our data set
 */
int
sccpGtConversionRuleTable_add(struct sccpGtConversionRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtConversionRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpGtConversionRuleId, thedata->sccpGtConversionRuleIdLen);

	header_complex_add_data(&sccpGtConversionRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtConversionRuleTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpGtConversionRuleTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpGtConversionRuleTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtConversionRuleTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpGtConversionRuleTable_data);

	DEBUGMSGTL(("sccpGtConversionRuleTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleId, &tmpsize);
	StorageTmp->sccpGtConversionRuleIdLen = tmpsize;
	if (StorageTmp->sccpGtConversionRuleId == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewEncodingScheme, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewNatureOfAddress, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewNumberingPlan, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNewTranslationType, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleName, &tmpsize);
	StorageTmp->sccpGtConversionRuleNameLen = tmpsize;
	if (StorageTmp->sccpGtConversionRuleName == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtConversionRuleRowStatus, &tmpsize);

	sccpGtConversionRuleTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
}

/*
 * store_sccpGtConversionRuleTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtConversionRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtConversionRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtConversionRuleTable", "storing data...  "));
	refresh_sccpGtConversionRuleTable();
	(void) tmpsize;
	for (hcindex = sccpGtConversionRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtConversionRuleTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpGtConversionRuleTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpGtConversionRuleTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpGtConversionRuleIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewEncodingScheme, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewNatureOfAddress, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewNumberingPlan, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNewTranslationType, &tmpsize);
		tmpsize = StorageTmp->sccpGtConversionRuleNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtConversionRuleRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpGtConversionRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpAddressInfoTable_add(): adds a structure node to our data set
 */
int
sccpAddressInfoTable_add(struct sccpAddressInfoTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpAddressInfoTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtConversionRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpGtConversionRuleId, thedata->sccpGtConversionRuleIdLen);
	/* sccpAddressInfoOperationId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpAddressInfoOperationId, thedata->sccpAddressInfoOperationIdLen);

	header_complex_add_data(&sccpAddressInfoTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpAddressInfoTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpAddressInfoTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpAddressInfoTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpAddressInfoTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpAddressInfoTable_data);

	DEBUGMSGTL(("sccpAddressInfoTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConversionRuleId, &tmpsize);
	StorageTmp->sccpGtConversionRuleIdLen = tmpsize;
	if (StorageTmp->sccpGtConversionRuleId == NULL) {
		config_perror("invalid specification for sccpGtConversionRuleId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpAddressInfoOperationId, &tmpsize);
	StorageTmp->sccpAddressInfoOperationIdLen = tmpsize;
	if (StorageTmp->sccpAddressInfoOperationId == NULL) {
		config_perror("invalid specification for sccpAddressInfoOperationId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoOperation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoAddressElement, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoNrOfAddressElements, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAddressInfoRowStatus, &tmpsize);

	sccpAddressInfoTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
}

/*
 * store_sccpAddressInfoTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpAddressInfoTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpAddressInfoTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpAddressInfoTable", "storing data...  "));
	refresh_sccpAddressInfoTable();
	(void) tmpsize;
	for (hcindex = sccpAddressInfoTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpAddressInfoTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpAddressInfoTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpAddressInfoTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpGtConversionRuleIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConversionRuleId, &tmpsize);
		tmpsize = StorageTmp->sccpAddressInfoOperationIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpAddressInfoOperationId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoOperation, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoAddressElement, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoNrOfAddressElements, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAddressInfoRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpAddressInfoTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpGtTranslatorTable_add(): adds a structure node to our data set
 */
int
sccpGtTranslatorTable_add(struct sccpGtTranslatorTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtTranslatorTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtTranslatorId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpGtTranslatorId, thedata->sccpGtTranslatorIdLen);

	header_complex_add_data(&sccpGtTranslatorTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtTranslatorTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpGtTranslatorTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpGtTranslatorTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtTranslatorTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpGtTranslatorTable_data);

	DEBUGMSGTL(("sccpGtTranslatorTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorId, &tmpsize);
	StorageTmp->sccpGtTranslatorIdLen = tmpsize;
	if (StorageTmp->sccpGtTranslatorId == NULL) {
		config_perror("invalid specification for sccpGtTranslatorId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtIndicator, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNatureOfAddress, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtNumberingPlan, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslationType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslatorAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorName, &tmpsize);
	StorageTmp->sccpGtTranslatorNameLen = tmpsize;
	if (StorageTmp->sccpGtTranslatorName == NULL) {
		config_perror("invalid specification for sccpGtTranslatorName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtTranslatorRowStatus, &tmpsize);

	sccpGtTranslatorTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
}

/*
 * store_sccpGtTranslatorTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtTranslatorTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtTranslatorTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtTranslatorTable", "storing data...  "));
	refresh_sccpGtTranslatorTable();
	(void) tmpsize;
	for (hcindex = sccpGtTranslatorTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtTranslatorTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpGtTranslatorTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpGtTranslatorTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpGtTranslatorIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtIndicator, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNatureOfAddress, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtNumberingPlan, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslationType, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslatorAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->sccpGtTranslatorNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtTranslatorRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpGtTranslatorTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpGtRuleTable_add(): adds a structure node to our data set
 */
int
sccpGtRuleTable_add(struct sccpGtRuleTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpGtRuleTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpGtTranslatorId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpGtTranslatorId, thedata->sccpGtTranslatorIdLen);
	/* sccpGtRuleId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpGtRuleId, thedata->sccpGtRuleIdLen);

	header_complex_add_data(&sccpGtRuleTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpGtRuleTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpGtRuleTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpGtRuleTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpGtRuleTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpGtRuleTable_data);

	DEBUGMSGTL(("sccpGtRuleTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtTranslatorId, &tmpsize);
	StorageTmp->sccpGtTranslatorIdLen = tmpsize;
	if (StorageTmp->sccpGtTranslatorId == NULL) {
		config_perror("invalid specification for sccpGtTranslatorId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtRuleId, &tmpsize);
	StorageTmp->sccpGtRuleIdLen = tmpsize;
	if (StorageTmp->sccpGtRuleId == NULL) {
		config_perror("invalid specification for sccpGtRuleId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtRuleAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtAddressInformation, &tmpsize);
	StorageTmp->sccpGtAddressInformationLen = tmpsize;
	if (StorageTmp->sccpGtAddressInformation == NULL) {
		config_perror("invalid specification for sccpGtAddressInformation");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtConvRulePointer, &tmpsize);
	StorageTmp->sccpGtConvRulePointerLen = tmpsize;
	if (StorageTmp->sccpGtConvRulePointer == NULL) {
		config_perror("invalid specification for sccpGtConvRulePointer");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtEncodingScheme, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpEntitySetPointer, &tmpsize);
	StorageTmp->sccpEntitySetPointerLen = tmpsize;
	if (StorageTmp->sccpEntitySetPointer == NULL) {
		config_perror("invalid specification for sccpEntitySetPointer");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpGtRuleName, &tmpsize);
	StorageTmp->sccpGtRuleNameLen = tmpsize;
	if (StorageTmp->sccpGtRuleName == NULL) {
		config_perror("invalid specification for sccpGtRuleName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpGtRuleRowStatus, &tmpsize);

	sccpGtRuleTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
}

/*
 * store_sccpGtRuleTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpGtRuleTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpGtRuleTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpGtRuleTable", "storing data...  "));
	refresh_sccpGtRuleTable();
	(void) tmpsize;
	for (hcindex = sccpGtRuleTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpGtRuleTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpGtRuleTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpGtRuleTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpGtTranslatorIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtTranslatorId, &tmpsize);
		tmpsize = StorageTmp->sccpGtRuleIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtRuleId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtRuleAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->sccpGtAddressInformationLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtAddressInformation, &tmpsize);
		tmpsize = StorageTmp->sccpGtConvRulePointerLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtConvRulePointer, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtEncodingScheme, &tmpsize);
		tmpsize = StorageTmp->sccpEntitySetPointerLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpEntitySetPointer, &tmpsize);
		tmpsize = StorageTmp->sccpGtRuleNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpGtRuleName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpGtRuleRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpGtRuleTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * sccpSrvtTable_add(): adds a structure node to our data set
 */
int
sccpSrvtTable_add(struct sccpSrvtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("sccpSrvtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, (uint8_t *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* sccpRouteTestId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->sccpRouteTestId, thedata->sccpRouteTestIdLen);

	header_complex_add_data(&sccpSrvtTableStorage, vars, thedata);
	DEBUGMSGTL(("sccpSrvtTable", "registered an entry\n"));
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_sccpSrvtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_sccpSrvtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct sccpSrvtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(sccpSrvtTable_data);

	DEBUGMSGTL(("sccpSrvtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UINTEGER, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpRouteTestId, &tmpsize);
	StorageTmp->sccpRouteTestIdLen = tmpsize;
	if (StorageTmp->sccpRouteTestId == NULL) {
		config_perror("invalid specification for sccpRouteTestId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpDSRVT, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpNSRVT, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpSrvtName, &tmpsize);
	StorageTmp->sccpSrvtNameLen = tmpsize;
	if (StorageTmp->sccpSrvtName == NULL) {
		config_perror("invalid specification for sccpSrvtName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpProceduralStatus, &tmpsize);
	StorageTmp->sccpProceduralStatusLen = tmpsize;
	if (StorageTmp->sccpProceduralStatus == NULL) {
		config_perror("invalid specification for sccpProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpTraceRequested, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpThreshold, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpMtpBackwardRoutingRequested, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->sccpOriginalGT, &tmpsize);
	StorageTmp->sccpOriginalGTLen = tmpsize;
	if (StorageTmp->sccpOriginalGT == NULL) {
		config_perror("invalid specification for sccpOriginalGT");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpInfoRequest, &tmpsize);
	StorageTmp->sccpInfoRequestLen = tmpsize;
	if (StorageTmp->sccpInfoRequest == NULL) {
		config_perror("invalid specification for sccpInfoRequest");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->sccpReturnUnknownParams, &tmpsize);
	StorageTmp->sccpReturnUnknownParamsLen = tmpsize;
	if (StorageTmp->sccpReturnUnknownParams == NULL) {
		config_perror("invalid specification for sccpReturnUnknownParams");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->sccpRouteTestRowStatus, &tmpsize);

	sccpSrvtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
}

/*
 * store_sccpSrvtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_sccpSrvtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct sccpSrvtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("sccpSrvtTable", "storing data...  "));
	refresh_sccpSrvtTable();
	(void) tmpsize;
	for (hcindex = sccpSrvtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct sccpSrvtTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->sccpSrvtTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "sccpSrvtTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UINTEGER, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
		tmpsize = StorageTmp->sccpRouteTestIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpRouteTestId, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpDSRVT, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpNSRVT, &tmpsize);
		tmpsize = StorageTmp->sccpSrvtNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpSrvtName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpOperationalState, &tmpsize);
		tmpsize = StorageTmp->sccpProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpTraceRequested, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpThreshold, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpMtpBackwardRoutingRequested, &tmpsize);
		tmpsize = StorageTmp->sccpOriginalGTLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->sccpOriginalGT, &tmpsize);
		tmpsize = StorageTmp->sccpInfoRequestLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpInfoRequest, &tmpsize);
		tmpsize = StorageTmp->sccpReturnUnknownParamsLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->sccpReturnUnknownParams, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->sccpRouteTestRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("sccpSrvtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_sccpNetworkEntityTable(): refresh sccpNetworkEntityTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpNetworkEntityTable(void)
{
	if (sccpNetworkEntityTable_refresh == 0)
		return;
	sccpNetworkEntityTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpNetworkEntityTable_row(): refresh sccpNetworkEntityTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpNetworkEntityTable_row(struct sccpNetworkEntityTable_data *StorageTmp)
{
	if (StorageTmp->sccpNetworkEntityTable_request == sa_request)
		return;
	StorageTmp->sccpNetworkEntityTable_request = sa_request;
}

/*
 * var_sccpNetworkEntityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpNetworkEntityTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpNetworkEntityTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpNetworkEntityTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpNetworkEntityTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPNETWORKENTITYALARMSTATUS:
		*write_method = write_sccpNetworkEntityAlarmStatus;
		*var_len = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		return (uint8_t *) StorageTmp->sccpNetworkEntityAlarmStatus;
	case SCCPSYSTEMTYPES:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpSystemTypesLen;
		return (uint8_t *) StorageTmp->sccpSystemTypes;
	case SCCPVERSION:
		*write_method = write_sccpVersion;
		*var_len = StorageTmp->sccpVersionLen;
		return (uint8_t *) StorageTmp->sccpVersion;
	case SCCPLUDTANDLUDTSSUPPORTED:
		*write_method = write_sccpLUDTandLUDTSSupported;
		*var_len = sizeof(StorageTmp->sccpLUDTandLUDTSSupported);
		return (uint8_t *) &StorageTmp->sccpLUDTandLUDTSSupported;
	case SCCPCOORDCHANGETIMER:
		*write_method = write_sccpCoordChangeTimer;
		*var_len = sizeof(StorageTmp->sccpCoordChangeTimer);
		return (uint8_t *) &StorageTmp->sccpCoordChangeTimer;
	case SCCPIGNORESSTTIMER:
		*write_method = write_sccpIgnoreSSTTimer;
		*var_len = sizeof(StorageTmp->sccpIgnoreSSTTimer);
		return (uint8_t *) &StorageTmp->sccpIgnoreSSTTimer;
	case SCCPMAXSTATINFOTIMER:
		*write_method = write_sccpMaxStatInfoTimer;
		*var_len = sizeof(StorageTmp->sccpMaxStatInfoTimer);
		return (uint8_t *) &StorageTmp->sccpMaxStatInfoTimer;
	case SCCPNETWORKENTITYNAME:
		*write_method = write_sccpNetworkEntityName;
		*var_len = StorageTmp->sccpNetworkEntityNameLen;
		return (uint8_t *) StorageTmp->sccpNetworkEntityName;
	case SCCPROWSTATUS:
		*write_method = write_sccpRowStatus;
		*var_len = sizeof(StorageTmp->sccpRowStatus);
		return (uint8_t *) &StorageTmp->sccpRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpSapNameTable(): refresh sccpSapNameTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpSapNameTable(void)
{
	if (sccpSapNameTable_refresh == 0)
		return;
	sccpSapNameTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpSapNameTable_row(): refresh sccpSapNameTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpSapNameTable_row(struct sccpSapNameTable_data *StorageTmp)
{
	if (StorageTmp->sccpSapNameTable_request == sa_request)
		return;
	StorageTmp->sccpSapNameTable_request = sa_request;
}

/*
 * var_sccpSapNameTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpSapNameTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSapNameTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpSapNameTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpSapNameTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpSapNameTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpSapNameTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPSAPNAMEROWSTATUS:
		*write_method = write_sccpSapNameRowStatus;
		*var_len = sizeof(StorageTmp->sccpSapNameRowStatus);
		return (uint8_t *) &StorageTmp->sccpSapNameRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpAccessPointTable(): refresh sccpAccessPointTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpAccessPointTable(void)
{
	if (sccpAccessPointTable_refresh == 0)
		return;
	sccpAccessPointTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpAccessPointTable_row(): refresh sccpAccessPointTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpAccessPointTable_row(struct sccpAccessPointTable_data *StorageTmp)
{
	if (StorageTmp->sccpAccessPointTable_request == sa_request)
		return;
	StorageTmp->sccpAccessPointTable_request = sa_request;
}

/*
 * var_sccpAccessPointTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpAccessPointTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpAccessPointTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpAccessPointTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpAccessPointTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpAccessPointTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPACCESSPOINTALARMSTATUS:
		*write_method = write_sccpAccessPointAlarmStatus;
		*var_len = StorageTmp->sccpAccessPointAlarmStatusLen;
		return (uint8_t *) StorageTmp->sccpAccessPointAlarmStatus;
	case SCCPSAP2ADDRESS:
		*write_method = write_sccpSap2Address;
		*var_len = StorageTmp->sccpSap2AddressLen;
		return (uint8_t *) StorageTmp->sccpSap2Address;
	case SCCPUSERENTITYNAMES:
		*write_method = write_sccpUserEntityNames;
		*var_len = StorageTmp->sccpUserEntityNamesLen;
		return (uint8_t *) StorageTmp->sccpUserEntityNames;
	case SCCPPROVIDERENTITYNAMES:
		*write_method = write_sccpProviderEntityNames;
		*var_len = StorageTmp->sccpProviderEntityNamesLen;
		return (uint8_t *) StorageTmp->sccpProviderEntityNames;
	case SCCPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->sccpAvailabilityStatus;
	case SCCPCONCERNEDAREAPOINTER:
		*write_method = write_sccpConcernedAreaPointer;
		*var_len = sizeof(StorageTmp->sccpConcernedAreaPointer);
		return (uint8_t *) &StorageTmp->sccpConcernedAreaPointer;
	case SCCPLINKAGEPOINTER:
		*write_method = write_sccpLinkagePointer;
		*var_len = sizeof(StorageTmp->sccpLinkagePointer);
		return (uint8_t *) &StorageTmp->sccpLinkagePointer;
	case SCCPSSAVAILABLEAFTERSPRESTART:
		*write_method = write_sccpSsAvailableAfterSpRestart;
		*var_len = sizeof(StorageTmp->sccpSsAvailableAfterSpRestart);
		return (uint8_t *) &StorageTmp->sccpSsAvailableAfterSpRestart;
	case SCCPACCESSPOINTNAME:
		*write_method = write_sccpAccessPointName;
		*var_len = StorageTmp->sccpAccessPointNameLen;
		return (uint8_t *) StorageTmp->sccpAccessPointName;
	case SCCPACCESSPOINTROWSTATUS:
		*write_method = write_sccpAccessPointRowStatus;
		*var_len = sizeof(StorageTmp->sccpAccessPointRowStatus);
		return (uint8_t *) &StorageTmp->sccpAccessPointRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpLinkageTable(): refresh sccpLinkageTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpLinkageTable(void)
{
	if (sccpLinkageTable_refresh == 0)
		return;
	sccpLinkageTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpLinkageTable_row(): refresh sccpLinkageTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpLinkageTable_row(struct sccpLinkageTable_data *StorageTmp)
{
	if (StorageTmp->sccpLinkageTable_request == sa_request)
		return;
	StorageTmp->sccpLinkageTable_request = sa_request;
}

/*
 * var_sccpLinkageTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpLinkageTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpLinkageTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpLinkageTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpLinkageTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpLinkageTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPOPERATIONALPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpOperationalProtocolsLen;
		return (uint8_t *) StorageTmp->sccpOperationalProtocols;
	case SCCPSNSAP:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpSnSAPLen;
		return (uint8_t *) StorageTmp->sccpSnSAP;
	case SCCPATTACKTIMERVALUE:
		*write_method = write_sccpAttackTimerValue;
		*var_len = sizeof(StorageTmp->sccpAttackTimerValue);
		return (uint8_t *) &StorageTmp->sccpAttackTimerValue;
	case SCCPDECAYTIMERVALUE:
		*write_method = write_sccpDecayTimerValue;
		*var_len = sizeof(StorageTmp->sccpDecayTimerValue);
		return (uint8_t *) &StorageTmp->sccpDecayTimerValue;
	case SCCPNROFRESTRICTIONLEVELS:
		*write_method = write_sccpNrOfRestrictionLevels;
		*var_len = sizeof(StorageTmp->sccpNrOfRestrictionLevels);
		return (uint8_t *) &StorageTmp->sccpNrOfRestrictionLevels;
	case SCCPNROFSUBLEVELS:
		*write_method = write_sccpNrOfSubLevels;
		*var_len = sizeof(StorageTmp->sccpNrOfSubLevels);
		return (uint8_t *) &StorageTmp->sccpNrOfSubLevels;
	case SCCPCLS:
		*write_method = write_sccpCLS;
		*var_len = sizeof(StorageTmp->sccpCLS);
		return (uint8_t *) &StorageTmp->sccpCLS;
	case SCCPCONGESTIONTIMERVALUE:
		*write_method = write_sccpCongestionTimerValue;
		*var_len = sizeof(StorageTmp->sccpCongestionTimerValue);
		return (uint8_t *) &StorageTmp->sccpCongestionTimerValue;
	case SCCPP:
		*write_method = write_sccpp;
		*var_len = sizeof(StorageTmp->sccpp);
		return (uint8_t *) &StorageTmp->sccpp;
	case SCCPIMPORTANCELEVELCR:
		*write_method = write_sccpImportanceLevelCR;
		*var_len = StorageTmp->sccpImportanceLevelCRLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelCR;
	case SCCPIMPORTANCELEVELCC:
		*write_method = write_sccpImportanceLevelCC;
		*var_len = StorageTmp->sccpImportanceLevelCCLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelCC;
	case SCCPIMPORTANCELEVELCREF:
		*write_method = write_sccpImportanceLevelCREF;
		*var_len = StorageTmp->sccpImportanceLevelCREFLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelCREF;
	case SCCPIMPORTANCELEVELDT1:
		*write_method = write_sccpImportanceLevelDT1;
		*var_len = StorageTmp->sccpImportanceLevelDT1Len;
		return (uint8_t *) StorageTmp->sccpImportanceLevelDT1;
	case SCCPIMPORTANCELEVELDT2:
		*write_method = write_sccpImportanceLevelDT2;
		*var_len = StorageTmp->sccpImportanceLevelDT2Len;
		return (uint8_t *) StorageTmp->sccpImportanceLevelDT2;
	case SCCPIMPORTANCELEVELAK:
		*write_method = write_sccpImportanceLevelAK;
		*var_len = StorageTmp->sccpImportanceLevelAKLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelAK;
	case SCCPIMPORTANCELEVELIT:
		*write_method = write_sccpImportanceLevelIT;
		*var_len = StorageTmp->sccpImportanceLevelITLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelIT;
	case SCCPIMPORTANCELEVELED:
		*write_method = write_sccpImportanceLevelED;
		*var_len = StorageTmp->sccpImportanceLevelEDLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelED;
	case SCCPIMPORTANCELEVELEA:
		*write_method = write_sccpImportanceLevelEA;
		*var_len = StorageTmp->sccpImportanceLevelEALen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelEA;
	case SCCPIMPORTANCELEVELRSR:
		*write_method = write_sccpImportanceLevelRSR;
		*var_len = StorageTmp->sccpImportanceLevelRSRLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelRSR;
	case SCCPIMPORTANCELEVELRSC:
		*write_method = write_sccpImportanceLevelRSC;
		*var_len = StorageTmp->sccpImportanceLevelRSCLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelRSC;
	case SCCPIMPORTANCELEVELERR:
		*write_method = write_sccpImportanceLevelERR;
		*var_len = StorageTmp->sccpImportanceLevelERRLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelERR;
	case SCCPIMPORTANCELEVELRLC:
		*write_method = write_sccpImportanceLevelRLC;
		*var_len = StorageTmp->sccpImportanceLevelRLCLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelRLC;
	case SCCPIMPORTANCELEVELRLSD:
		*write_method = write_sccpImportanceLevelRLSD;
		*var_len = StorageTmp->sccpImportanceLevelRLSDLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelRLSD;
	case SCCPIMPORTANCELEVELUDT:
		*write_method = write_sccpImportanceLevelUDT;
		*var_len = StorageTmp->sccpImportanceLevelUDTLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelUDT;
	case SCCPIMPORTANCELEVELUDTS:
		*write_method = write_sccpImportanceLevelUDTS;
		*var_len = StorageTmp->sccpImportanceLevelUDTSLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelUDTS;
	case SCCPIMPORTANCELEVELXUDT:
		*write_method = write_sccpImportanceLevelXUDT;
		*var_len = StorageTmp->sccpImportanceLevelXUDTLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelXUDT;
	case SCCPIMPORTANCELEVELXUDTS:
		*write_method = write_sccpImportanceLevelXUDTS;
		*var_len = StorageTmp->sccpImportanceLevelXUDTSLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelXUDTS;
	case SCCPIMPORTANCELEVELLUDT:
		*write_method = write_sccpImportanceLevelLUDT;
		*var_len = StorageTmp->sccpImportanceLevelLUDTLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelLUDT;
	case SCCPIMPORTANCELEVELLUDTS:
		*write_method = write_sccpImportanceLevelLUDTS;
		*var_len = StorageTmp->sccpImportanceLevelLUDTSLen;
		return (uint8_t *) StorageTmp->sccpImportanceLevelLUDTS;
	case SCCPRLM:
		*write_method = write_sccpRLM;
		*var_len = sizeof(StorageTmp->sccpRLM);
		return (uint8_t *) &StorageTmp->sccpRLM;
	case SCCPRSLM:
		*write_method = write_sccpRSLM;
		*var_len = sizeof(StorageTmp->sccpRSLM);
		return (uint8_t *) &StorageTmp->sccpRSLM;
	case SCCPLINKAGECONCERNEDAREAPOINTER:
		*write_method = write_sccpLinkageConcernedAreaPointer;
		*var_len = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		return (uint8_t *) StorageTmp->sccpLinkageConcernedAreaPointer;
	case SCCPLOWERLIMITFORSEGMENTATION:
		*write_method = write_sccpLowerLimitForSegmentation;
		*var_len = sizeof(StorageTmp->sccpLowerLimitForSegmentation);
		return (uint8_t *) &StorageTmp->sccpLowerLimitForSegmentation;
	case SCCPUPPERLIMITFORSEGMENTATION:
		*write_method = write_sccpUpperLimitForSegmentation;
		*var_len = sizeof(StorageTmp->sccpUpperLimitForSegmentation);
		return (uint8_t *) &StorageTmp->sccpUpperLimitForSegmentation;
	case SCCPLINKAGENAME:
		*write_method = write_sccpLinkageName;
		*var_len = StorageTmp->sccpLinkageNameLen;
		return (uint8_t *) StorageTmp->sccpLinkageName;
	case SCCPLINKAGEROWSTATUS:
		*write_method = write_sccpLinkageRowStatus;
		*var_len = sizeof(StorageTmp->sccpLinkageRowStatus);
		return (uint8_t *) &StorageTmp->sccpLinkageRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpSclcTable(): refresh sccpSclcTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpSclcTable(void)
{
	if (sccpSclcTable_refresh == 0)
		return;
	sccpSclcTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpSclcTable_row(): refresh sccpSclcTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpSclcTable_row(struct sccpSclcTable_data *StorageTmp)
{
	if (StorageTmp->sccpSclcTable_request == sa_request)
		return;
	StorageTmp->sccpSclcTable_request = sa_request;
}

/*
 * var_sccpSclcTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpSclcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSclcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpSclcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpSclcTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpSclcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpSclcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPSCLCALARMSTATUS:
		*write_method = write_sccpSclcAlarmStatus;
		*var_len = StorageTmp->sccpSclcAlarmStatusLen;
		return (uint8_t *) StorageTmp->sccpSclcAlarmStatus;
	case SCCPSCLCOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpSclcOperationalState);
		return (uint8_t *) &StorageTmp->sccpSclcOperationalState;
	case SCCPTOTALREMOTESAPS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpTotalRemoteSAPs);
		return (uint8_t *) &StorageTmp->sccpTotalRemoteSAPs;
	case SCCPSCLCADMINISTRATIVESTATE:
		*write_method = write_sccpSclcAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpSclcAdministrativeState);
		return (uint8_t *) &StorageTmp->sccpSclcAdministrativeState;
	case SCCPSCLCSUPPORTEDPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpSclcSupportedProtocolsLen;
		return (uint8_t *) StorageTmp->sccpSclcSupportedProtocols;
	case SCCPSCLCOPERATIONALSYSTEMTYPE:
		*write_method = write_sccpSclcOperationalSystemType;
		*var_len = sizeof(StorageTmp->sccpSclcOperationalSystemType);
		return (uint8_t *) &StorageTmp->sccpSclcOperationalSystemType;
	case SCCPINITIALVALUEREASSTIMER:
		*write_method = write_sccpInitialValueReassTimer;
		*var_len = sizeof(StorageTmp->sccpInitialValueReassTimer);
		return (uint8_t *) &StorageTmp->sccpInitialValueReassTimer;
	case SCCPSCLCNAME:
		*write_method = write_sccpSclcName;
		*var_len = StorageTmp->sccpSclcNameLen;
		return (uint8_t *) StorageTmp->sccpSclcName;
	case SCCPSCLCROWSTATUS:
		*write_method = write_sccpSclcRowStatus;
		*var_len = sizeof(StorageTmp->sccpSclcRowStatus);
		return (uint8_t *) &StorageTmp->sccpSclcRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpScocTable(): refresh sccpScocTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpScocTable(void)
{
	if (sccpScocTable_refresh == 0)
		return;
	sccpScocTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpScocTable_row(): refresh sccpScocTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpScocTable_row(struct sccpScocTable_data *StorageTmp)
{
	if (StorageTmp->sccpScocTable_request == sa_request)
		return;
	StorageTmp->sccpScocTable_request = sa_request;
}

/*
 * var_sccpScocTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpScocTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpScocTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpScocTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpScocTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpScocTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpScocTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPCOPROTOCOLMACHINEID:
		*write_method = write_sccpCoProtocolMachineId;
		*var_len = StorageTmp->sccpCoProtocolMachineIdLen;
		return (uint8_t *) StorageTmp->sccpCoProtocolMachineId;
	case SCCPSCOCOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpScocOperationalState);
		return (uint8_t *) &StorageTmp->sccpScocOperationalState;
	case SCCPSCOCADMINISTRATIVESTATE:
		*write_method = write_sccpScocAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpScocAdministrativeState);
		return (uint8_t *) &StorageTmp->sccpScocAdministrativeState;
	case SCCPSCOCOPERATIONALSYSTEMTYPE:
		*write_method = write_sccpScocOperationalSystemType;
		*var_len = sizeof(StorageTmp->sccpScocOperationalSystemType);
		return (uint8_t *) &StorageTmp->sccpScocOperationalSystemType;
	case SCCPSCOCSUPPORTEDPROTOCOLS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpScocSupportedProtocolsLen;
		return (uint8_t *) StorageTmp->sccpScocSupportedProtocols;
	case SCCPSCOCNAME:
		*write_method = write_sccpScocName;
		*var_len = StorageTmp->sccpScocNameLen;
		return (uint8_t *) StorageTmp->sccpScocName;
	case SCCPSCOCROWSTATUS:
		*write_method = write_sccpScocRowStatus;
		*var_len = sizeof(StorageTmp->sccpScocRowStatus);
		return (uint8_t *) &StorageTmp->sccpScocRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpScrcTable(): refresh sccpScrcTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpScrcTable(void)
{
	if (sccpScrcTable_refresh == 0)
		return;
	sccpScrcTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpScrcTable_row(): refresh sccpScrcTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpScrcTable_row(struct sccpScrcTable_data *StorageTmp)
{
	if (StorageTmp->sccpScrcTable_request == sa_request)
		return;
	StorageTmp->sccpScrcTable_request = sa_request;
}

/*
 * var_sccpScrcTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpScrcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpScrcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpScrcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpScrcTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpScrcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpScrcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPSCRCID:
		*write_method = write_sccpScrcId;
		*var_len = StorageTmp->sccpScrcIdLen;
		return (uint8_t *) StorageTmp->sccpScrcId;
	case SCCPSCRCALARMSTATUS:
		*write_method = write_sccpScrcAlarmStatus;
		*var_len = StorageTmp->sccpScrcAlarmStatusLen;
		return (uint8_t *) StorageTmp->sccpScrcAlarmStatus;
	case SCCPSCRCNAME:
		*write_method = write_sccpScrcName;
		*var_len = StorageTmp->sccpScrcNameLen;
		return (uint8_t *) StorageTmp->sccpScrcName;
	case SCCPSCRCROWSTATUS:
		*write_method = write_sccpScrcRowStatus;
		*var_len = sizeof(StorageTmp->sccpScrcRowStatus);
		return (uint8_t *) &StorageTmp->sccpScrcRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpEntitySetTable(): refresh sccpEntitySetTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpEntitySetTable(void)
{
	if (sccpEntitySetTable_refresh == 0)
		return;
	sccpEntitySetTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpEntitySetTable_row(): refresh sccpEntitySetTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpEntitySetTable_row(struct sccpEntitySetTable_data *StorageTmp)
{
	if (StorageTmp->sccpEntitySetTable_request == sa_request)
		return;
	StorageTmp->sccpEntitySetTable_request = sa_request;
}

/*
 * var_sccpEntitySetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpEntitySetTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpEntitySetTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpEntitySetTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpEntitySetTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpEntitySetTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPSHARINGMODE:
		*write_method = write_sccpSharingMode;
		*var_len = sizeof(StorageTmp->sccpSharingMode);
		return (uint8_t *) &StorageTmp->sccpSharingMode;
	case SCCPLOADSHARINGALGPOINTER:
		*write_method = write_sccpLoadSharingAlgPointer;
		*var_len = StorageTmp->sccpLoadSharingAlgPointerLen;
		return (uint8_t *) StorageTmp->sccpLoadSharingAlgPointer;
	case SCCPENTITYSETNAME:
		*write_method = write_sccpEntitySetName;
		*var_len = StorageTmp->sccpEntitySetNameLen;
		return (uint8_t *) StorageTmp->sccpEntitySetName;
	case SCCPENTITYSETTYPE:
		*write_method = write_sccpEntitySetType;
		*var_len = sizeof(StorageTmp->sccpEntitySetType);
		return (uint8_t *) &StorageTmp->sccpEntitySetType;
	case SCCPENTITYSETSSN:
		*write_method = write_sccpEntitySetSsn;
		*var_len = StorageTmp->sccpEntitySetSsnLen;
		return (uint8_t *) StorageTmp->sccpEntitySetSsn;
	case SCCPENTITYSETROWSTATUS:
		*write_method = write_sccpEntitySetRowStatus;
		*var_len = sizeof(StorageTmp->sccpEntitySetRowStatus);
		return (uint8_t *) &StorageTmp->sccpEntitySetRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpEntitySetSapTable(): refresh sccpEntitySetSapTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpEntitySetSapTable(void)
{
	if (sccpEntitySetSapTable_refresh == 0)
		return;
	sccpEntitySetSapTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpEntitySetSapTable_row(): refresh sccpEntitySetSapTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpEntitySetSapTable_row(struct sccpEntitySetSapTable_data *StorageTmp)
{
	if (StorageTmp->sccpEntitySetSapTable_request == sa_request)
		return;
	StorageTmp->sccpEntitySetSapTable_request = sa_request;
}

/*
 * var_sccpEntitySetSapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpEntitySetSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpEntitySetSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpEntitySetSapTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpEntitySetSapTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpEntitySetSapTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPENTITYSETSAPTYPE:
		*write_method = write_sccpEntitySetSapType;
		*var_len = sizeof(StorageTmp->sccpEntitySetSapType);
		return (uint8_t *) &StorageTmp->sccpEntitySetSapType;
	case SCCPENTITYSETSAPPOINTER:
		*write_method = write_sccpEntitySetSapPointer;
		*var_len = StorageTmp->sccpEntitySetSapPointerLen;
		return (uint8_t *) StorageTmp->sccpEntitySetSapPointer;
	case SCCPENTITYSETSAPROWSTATUS:
		*write_method = write_sccpEntitySetSapRowStatus;
		*var_len = sizeof(StorageTmp->sccpEntitySetSapRowStatus);
		return (uint8_t *) &StorageTmp->sccpEntitySetSapRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpConcernedAreaTable(): refresh sccpConcernedAreaTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpConcernedAreaTable(void)
{
	if (sccpConcernedAreaTable_refresh == 0)
		return;
	sccpConcernedAreaTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpConcernedAreaTable_row(): refresh sccpConcernedAreaTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpConcernedAreaTable_row(struct sccpConcernedAreaTable_data *StorageTmp)
{
	if (StorageTmp->sccpConcernedAreaTable_request == sa_request)
		return;
	StorageTmp->sccpConcernedAreaTable_request = sa_request;
}

/*
 * var_sccpConcernedAreaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpConcernedAreaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpConcernedAreaTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpConcernedAreaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpConcernedAreaTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpConcernedAreaTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpConcernedAreaTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpRemoteSCCPTable(): refresh sccpRemoteSCCPTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpRemoteSCCPTable(void)
{
	if (sccpRemoteSCCPTable_refresh == 0)
		return;
	sccpRemoteSCCPTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpRemoteSCCPTable_row(): refresh sccpRemoteSCCPTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpRemoteSCCPTable_row(struct sccpRemoteSCCPTable_data *StorageTmp)
{
	if (StorageTmp->sccpRemoteSCCPTable_request == sa_request)
		return;
	StorageTmp->sccpRemoteSCCPTable_request = sa_request;
}

/*
 * var_sccpRemoteSCCPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpRemoteSCCPTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpRemoteSCCPTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpRemoteSCCPTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpRemoteSCCPTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpRemoteSCCPTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPREMOTESCCPMTPACCESSPOINT:
		*write_method = write_sccpRemoteSCCPMTPAccessPoint;
		*var_len = StorageTmp->sccpRemoteSCCPMTPAccessPointLen;
		return (uint8_t *) StorageTmp->sccpRemoteSCCPMTPAccessPoint;
	case SCCPREMOTESCCPNAME:
		*write_method = write_sccpRemoteSCCPName;
		*var_len = StorageTmp->sccpRemoteSCCPNameLen;
		return (uint8_t *) StorageTmp->sccpRemoteSCCPName;
	case SCCPREMOTESCCPROWSTATUS:
		*write_method = write_sccpRemoteSCCPRowStatus;
		*var_len = sizeof(StorageTmp->sccpRemoteSCCPRowStatus);
		return (uint8_t *) &StorageTmp->sccpRemoteSCCPRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpGtConversionRuleTable(): refresh sccpGtConversionRuleTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpGtConversionRuleTable(void)
{
	if (sccpGtConversionRuleTable_refresh == 0)
		return;
	sccpGtConversionRuleTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpGtConversionRuleTable_row(): refresh sccpGtConversionRuleTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpGtConversionRuleTable_row(struct sccpGtConversionRuleTable_data *StorageTmp)
{
	if (StorageTmp->sccpGtConversionRuleTable_request == sa_request)
		return;
	StorageTmp->sccpGtConversionRuleTable_request = sa_request;
}

/*
 * var_sccpGtConversionRuleTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpGtConversionRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtConversionRuleTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpGtConversionRuleTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpGtConversionRuleTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPGTNEWENCODINGSCHEME:
		*write_method = write_sccpGtNewEncodingScheme;
		*var_len = sizeof(StorageTmp->sccpGtNewEncodingScheme);
		return (uint8_t *) &StorageTmp->sccpGtNewEncodingScheme;
	case SCCPGTNEWNATUREOFADDRESS:
		*write_method = write_sccpGtNewNatureOfAddress;
		*var_len = sizeof(StorageTmp->sccpGtNewNatureOfAddress);
		return (uint8_t *) &StorageTmp->sccpGtNewNatureOfAddress;
	case SCCPGTNEWNUMBERINGPLAN:
		*write_method = write_sccpGtNewNumberingPlan;
		*var_len = sizeof(StorageTmp->sccpGtNewNumberingPlan);
		return (uint8_t *) &StorageTmp->sccpGtNewNumberingPlan;
	case SCCPGTNEWTRANSLATIONTYPE:
		*write_method = write_sccpGtNewTranslationType;
		*var_len = sizeof(StorageTmp->sccpGtNewTranslationType);
		return (uint8_t *) &StorageTmp->sccpGtNewTranslationType;
	case SCCPGTCONVERSIONRULENAME:
		*write_method = write_sccpGtConversionRuleName;
		*var_len = StorageTmp->sccpGtConversionRuleNameLen;
		return (uint8_t *) StorageTmp->sccpGtConversionRuleName;
	case SCCPGTCONVERSIONRULEROWSTATUS:
		*write_method = write_sccpGtConversionRuleRowStatus;
		*var_len = sizeof(StorageTmp->sccpGtConversionRuleRowStatus);
		return (uint8_t *) &StorageTmp->sccpGtConversionRuleRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpAddressInfoTable(): refresh sccpAddressInfoTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpAddressInfoTable(void)
{
	if (sccpAddressInfoTable_refresh == 0)
		return;
	sccpAddressInfoTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpAddressInfoTable_row(): refresh sccpAddressInfoTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpAddressInfoTable_row(struct sccpAddressInfoTable_data *StorageTmp)
{
	if (StorageTmp->sccpAddressInfoTable_request == sa_request)
		return;
	StorageTmp->sccpAddressInfoTable_request = sa_request;
}

/*
 * var_sccpAddressInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpAddressInfoTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpAddressInfoTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpAddressInfoTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpAddressInfoTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpAddressInfoTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPADDRESSINFOOPERATION:
		*write_method = write_sccpAddressInfoOperation;
		*var_len = sizeof(StorageTmp->sccpAddressInfoOperation);
		return (uint8_t *) &StorageTmp->sccpAddressInfoOperation;
	case SCCPADDRESSINFOADDRESSELEMENT:
		*write_method = write_sccpAddressInfoAddressElement;
		*var_len = sizeof(StorageTmp->sccpAddressInfoAddressElement);
		return (uint8_t *) &StorageTmp->sccpAddressInfoAddressElement;
	case SCCPADDRESSINFONROFADDRESSELEMENTS:
		*write_method = write_sccpAddressInfoNrOfAddressElements;
		*var_len = sizeof(StorageTmp->sccpAddressInfoNrOfAddressElements);
		return (uint8_t *) &StorageTmp->sccpAddressInfoNrOfAddressElements;
	case SCCPADDRESSINFOROWSTATUS:
		*write_method = write_sccpAddressInfoRowStatus;
		*var_len = sizeof(StorageTmp->sccpAddressInfoRowStatus);
		return (uint8_t *) &StorageTmp->sccpAddressInfoRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpGtTranslatorTable(): refresh sccpGtTranslatorTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpGtTranslatorTable(void)
{
	if (sccpGtTranslatorTable_refresh == 0)
		return;
	sccpGtTranslatorTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpGtTranslatorTable_row(): refresh sccpGtTranslatorTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpGtTranslatorTable_row(struct sccpGtTranslatorTable_data *StorageTmp)
{
	if (StorageTmp->sccpGtTranslatorTable_request == sa_request)
		return;
	StorageTmp->sccpGtTranslatorTable_request = sa_request;
}

/*
 * var_sccpGtTranslatorTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpGtTranslatorTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtTranslatorTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpGtTranslatorTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpGtTranslatorTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPGTINDICATOR:
		*write_method = write_sccpGtIndicator;
		*var_len = sizeof(StorageTmp->sccpGtIndicator);
		return (uint8_t *) &StorageTmp->sccpGtIndicator;
	case SCCPGTNATUREOFADDRESS:
		*write_method = write_sccpGtNatureOfAddress;
		*var_len = sizeof(StorageTmp->sccpGtNatureOfAddress);
		return (uint8_t *) &StorageTmp->sccpGtNatureOfAddress;
	case SCCPGTNUMBERINGPLAN:
		*write_method = write_sccpGtNumberingPlan;
		*var_len = sizeof(StorageTmp->sccpGtNumberingPlan);
		return (uint8_t *) &StorageTmp->sccpGtNumberingPlan;
	case SCCPGTTRANSLATIONTYPE:
		*write_method = write_sccpGtTranslationType;
		*var_len = sizeof(StorageTmp->sccpGtTranslationType);
		return (uint8_t *) &StorageTmp->sccpGtTranslationType;
	case SCCPGTTRANSLATORADMINISTRATIVESTATE:
		*write_method = write_sccpGtTranslatorAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpGtTranslatorAdministrativeState);
		return (uint8_t *) &StorageTmp->sccpGtTranslatorAdministrativeState;
	case SCCPGTTRANSLATORNAME:
		*write_method = write_sccpGtTranslatorName;
		*var_len = StorageTmp->sccpGtTranslatorNameLen;
		return (uint8_t *) StorageTmp->sccpGtTranslatorName;
	case SCCPGTTRANSLATORROWSTATUS:
		*write_method = write_sccpGtTranslatorRowStatus;
		*var_len = sizeof(StorageTmp->sccpGtTranslatorRowStatus);
		return (uint8_t *) &StorageTmp->sccpGtTranslatorRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpGtRuleTable(): refresh sccpGtRuleTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpGtRuleTable(void)
{
	if (sccpGtRuleTable_refresh == 0)
		return;
	sccpGtRuleTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpGtRuleTable_row(): refresh sccpGtRuleTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpGtRuleTable_row(struct sccpGtRuleTable_data *StorageTmp)
{
	if (StorageTmp->sccpGtRuleTable_request == sa_request)
		return;
	StorageTmp->sccpGtRuleTable_request = sa_request;
}

/*
 * var_sccpGtRuleTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpGtRuleTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpGtRuleTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpGtRuleTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpGtRuleTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpGtRuleTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPGTRULEADMINISTRATIVESTATE:
		*write_method = write_sccpGtRuleAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpGtRuleAdministrativeState);
		return (uint8_t *) &StorageTmp->sccpGtRuleAdministrativeState;
	case SCCPGTADDRESSINFORMATION:
		*write_method = write_sccpGtAddressInformation;
		*var_len = StorageTmp->sccpGtAddressInformationLen;
		return (uint8_t *) StorageTmp->sccpGtAddressInformation;
	case SCCPGTCONVRULEPOINTER:
		*write_method = write_sccpGtConvRulePointer;
		*var_len = StorageTmp->sccpGtConvRulePointerLen;
		return (uint8_t *) StorageTmp->sccpGtConvRulePointer;
	case SCCPGTENCODINGSCHEME:
		*write_method = write_sccpGtEncodingScheme;
		*var_len = sizeof(StorageTmp->sccpGtEncodingScheme);
		return (uint8_t *) &StorageTmp->sccpGtEncodingScheme;
	case SCCPENTITYSETPOINTER:
		*write_method = write_sccpEntitySetPointer;
		*var_len = StorageTmp->sccpEntitySetPointerLen;
		return (uint8_t *) StorageTmp->sccpEntitySetPointer;
	case SCCPGTRULENAME:
		*write_method = write_sccpGtRuleName;
		*var_len = StorageTmp->sccpGtRuleNameLen;
		return (uint8_t *) StorageTmp->sccpGtRuleName;
	case SCCPGTRULEROWSTATUS:
		*write_method = write_sccpGtRuleRowStatus;
		*var_len = sizeof(StorageTmp->sccpGtRuleRowStatus);
		return (uint8_t *) &StorageTmp->sccpGtRuleRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_sccpSrvtTable(): refresh sccpSrvtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_sccpSrvtTable(void)
{
	if (sccpSrvtTable_refresh == 0)
		return;
	sccpSrvtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_sccpSrvtTable_row(): refresh sccpSrvtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_sccpSrvtTable_row(struct sccpSrvtTable_data *StorageTmp)
{
	if (StorageTmp->sccpSrvtTable_request == sa_request)
		return;
	StorageTmp->sccpSrvtTable_request = sa_request;
}

/*
 * var_sccpSrvtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sccpMIB above.
 */
uint8_t *
var_sccpSrvtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct sccpSrvtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("sccpMIB", "var_sccpSrvtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_sccpSrvtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_sccpSrvtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case SCCPDSRVT:
		*write_method = write_sccpDSRVT;
		*var_len = sizeof(StorageTmp->sccpDSRVT);
		return (uint8_t *) &StorageTmp->sccpDSRVT;
	case SCCPNSRVT:
		*write_method = write_sccpNSRVT;
		*var_len = sizeof(StorageTmp->sccpNSRVT);
		return (uint8_t *) &StorageTmp->sccpNSRVT;
	case SCCPSRVTNAME:
		*write_method = write_sccpSrvtName;
		*var_len = StorageTmp->sccpSrvtNameLen;
		return (uint8_t *) StorageTmp->sccpSrvtName;
	case SCCPADMINISTRATIVESTATE:
		*write_method = write_sccpAdministrativeState;
		*var_len = sizeof(StorageTmp->sccpAdministrativeState);
		return (uint8_t *) &StorageTmp->sccpAdministrativeState;
	case SCCPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->sccpOperationalState);
		return (uint8_t *) &StorageTmp->sccpOperationalState;
	case SCCPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->sccpProceduralStatusLen;
		return (uint8_t *) StorageTmp->sccpProceduralStatus;
	case SCCPTRACEREQUESTED:
		*write_method = write_sccpTraceRequested;
		*var_len = sizeof(StorageTmp->sccpTraceRequested);
		return (uint8_t *) &StorageTmp->sccpTraceRequested;
	case SCCPTHRESHOLD:
		*write_method = write_sccpThreshold;
		*var_len = sizeof(StorageTmp->sccpThreshold);
		return (uint8_t *) &StorageTmp->sccpThreshold;
	case SCCPMTPBACKWARDROUTINGREQUESTED:
		*write_method = write_sccpMtpBackwardRoutingRequested;
		*var_len = sizeof(StorageTmp->sccpMtpBackwardRoutingRequested);
		return (uint8_t *) &StorageTmp->sccpMtpBackwardRoutingRequested;
	case SCCPORIGINALGT:
		*write_method = write_sccpOriginalGT;
		*var_len = StorageTmp->sccpOriginalGTLen;
		return (uint8_t *) StorageTmp->sccpOriginalGT;
	case SCCPINFOREQUEST:
		*write_method = write_sccpInfoRequest;
		*var_len = StorageTmp->sccpInfoRequestLen;
		return (uint8_t *) StorageTmp->sccpInfoRequest;
	case SCCPRETURNUNKNOWNPARAMS:
		*write_method = write_sccpReturnUnknownParams;
		*var_len = StorageTmp->sccpReturnUnknownParamsLen;
		return (uint8_t *) StorageTmp->sccpReturnUnknownParams;
	case SCCPROUTETESTROWSTATUS:
		*write_method = write_sccpRouteTestRowStatus;
		*var_len = sizeof(StorageTmp->sccpRouteTestRowStatus);
		return (uint8_t *) &StorageTmp->sccpRouteTestRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_sccpNetworkEntityAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpNetworkEntityAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpNetworkEntityAlarmStatus;
		tmplen = StorageTmp->sccpNetworkEntityAlarmStatusLen;
		memdup((void *) &StorageTmp->sccpNetworkEntityAlarmStatus, var_val, var_val_len);
		StorageTmp->sccpNetworkEntityAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpNetworkEntityAlarmStatus);
		StorageTmp->sccpNetworkEntityAlarmStatus = tmpvar;
		StorageTmp->sccpNetworkEntityAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpVersion(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpVersion;
		tmplen = StorageTmp->sccpVersionLen;
		memdup((void *) &StorageTmp->sccpVersion, var_val, var_val_len);
		StorageTmp->sccpVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpVersion);
		StorageTmp->sccpVersion = tmpvar;
		StorageTmp->sccpVersionLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLUDTandLUDTSSupported(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpLUDTandLUDTSSupported entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLUDTandLUDTSSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpLUDTandLUDTSSupported;
		StorageTmp->sccpLUDTandLUDTSSupported = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLUDTandLUDTSSupported = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpCoordChangeTimer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpCoordChangeTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoordChangeTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpCoordChangeTimer;
		StorageTmp->sccpCoordChangeTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCoordChangeTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpIgnoreSSTTimer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpIgnoreSSTTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpIgnoreSSTTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpIgnoreSSTTimer;
		StorageTmp->sccpIgnoreSSTTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpIgnoreSSTTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpMaxStatInfoTimer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpMaxStatInfoTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMaxStatInfoTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpMaxStatInfoTimer;
		StorageTmp->sccpMaxStatInfoTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpMaxStatInfoTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpNetworkEntityName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpNetworkEntityName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNetworkEntityName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpNetworkEntityName;
		tmplen = StorageTmp->sccpNetworkEntityNameLen;
		memdup((void *) &StorageTmp->sccpNetworkEntityName, var_val, var_val_len);
		StorageTmp->sccpNetworkEntityNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpNetworkEntityName);
		StorageTmp->sccpNetworkEntityName = tmpvar;
		StorageTmp->sccpNetworkEntityNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAccessPointAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAccessPointAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAccessPointAlarmStatus;
		tmplen = StorageTmp->sccpAccessPointAlarmStatusLen;
		memdup((void *) &StorageTmp->sccpAccessPointAlarmStatus, var_val, var_val_len);
		StorageTmp->sccpAccessPointAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpAccessPointAlarmStatus);
		StorageTmp->sccpAccessPointAlarmStatus = tmpvar;
		StorageTmp->sccpAccessPointAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSap2Address(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSap2Address entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSap2Address not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSap2Address;
		tmplen = StorageTmp->sccpSap2AddressLen;
		memdup((void *) &StorageTmp->sccpSap2Address, var_val, var_val_len);
		StorageTmp->sccpSap2AddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpSap2Address);
		StorageTmp->sccpSap2Address = tmpvar;
		StorageTmp->sccpSap2AddressLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpUserEntityNames(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpUserEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUserEntityNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpUserEntityNames;
		tmplen = StorageTmp->sccpUserEntityNamesLen;
		memdup((void *) &StorageTmp->sccpUserEntityNames, var_val, var_val_len);
		StorageTmp->sccpUserEntityNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpUserEntityNames);
		StorageTmp->sccpUserEntityNames = tmpvar;
		StorageTmp->sccpUserEntityNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpProviderEntityNames(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpProviderEntityNames entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpProviderEntityNames not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpProviderEntityNames;
		tmplen = StorageTmp->sccpProviderEntityNamesLen;
		memdup((void *) &StorageTmp->sccpProviderEntityNames, var_val, var_val_len);
		StorageTmp->sccpProviderEntityNamesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpProviderEntityNames);
		StorageTmp->sccpProviderEntityNames = tmpvar;
		StorageTmp->sccpProviderEntityNamesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpConcernedAreaPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpConcernedAreaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UINTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaPointer not ASN_UINTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpConcernedAreaPointer;
		StorageTmp->sccpConcernedAreaPointer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpConcernedAreaPointer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLinkagePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpLinkagePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UINTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkagePointer not ASN_UINTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpLinkagePointer;
		StorageTmp->sccpLinkagePointer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLinkagePointer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSsAvailableAfterSpRestart(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSsAvailableAfterSpRestart entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSsAvailableAfterSpRestart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSsAvailableAfterSpRestart;
		StorageTmp->sccpSsAvailableAfterSpRestart = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSsAvailableAfterSpRestart = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAccessPointName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAccessPointName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAccessPointName;
		tmplen = StorageTmp->sccpAccessPointNameLen;
		memdup((void *) &StorageTmp->sccpAccessPointName, var_val, var_val_len);
		StorageTmp->sccpAccessPointNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpAccessPointName);
		StorageTmp->sccpAccessPointName = tmpvar;
		StorageTmp->sccpAccessPointNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAttackTimerValue(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAttackTimerValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAttackTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAttackTimerValue;
		StorageTmp->sccpAttackTimerValue = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAttackTimerValue = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpDecayTimerValue(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpDecayTimerValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDecayTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpDecayTimerValue;
		StorageTmp->sccpDecayTimerValue = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpDecayTimerValue = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpNrOfRestrictionLevels(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpNrOfRestrictionLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfRestrictionLevels not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpNrOfRestrictionLevels;
		StorageTmp->sccpNrOfRestrictionLevels = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNrOfRestrictionLevels = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpNrOfSubLevels(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpNrOfSubLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNrOfSubLevels not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpNrOfSubLevels;
		StorageTmp->sccpNrOfSubLevels = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNrOfSubLevels = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpCLS(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpCLS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCLS not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpCLS;
		StorageTmp->sccpCLS = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCLS = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpCongestionTimerValue(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpCongestionTimerValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCongestionTimerValue not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpCongestionTimerValue;
		StorageTmp->sccpCongestionTimerValue = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpCongestionTimerValue = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpp(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpp entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpp not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpp;
		StorageTmp->sccpp = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpp = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelCR(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelCR;
		tmplen = StorageTmp->sccpImportanceLevelCRLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelCR, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelCRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelCR);
		StorageTmp->sccpImportanceLevelCR = tmpvar;
		StorageTmp->sccpImportanceLevelCRLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelCC(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelCC;
		tmplen = StorageTmp->sccpImportanceLevelCCLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelCC, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelCCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelCC);
		StorageTmp->sccpImportanceLevelCC = tmpvar;
		StorageTmp->sccpImportanceLevelCCLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelCREF(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelCREF entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelCREF not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelCREF;
		tmplen = StorageTmp->sccpImportanceLevelCREFLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelCREF, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelCREFLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelCREF);
		StorageTmp->sccpImportanceLevelCREF = tmpvar;
		StorageTmp->sccpImportanceLevelCREFLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelDT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelDT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT1 not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelDT1;
		tmplen = StorageTmp->sccpImportanceLevelDT1Len;
		memdup((void *) &StorageTmp->sccpImportanceLevelDT1, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelDT1Len = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelDT1);
		StorageTmp->sccpImportanceLevelDT1 = tmpvar;
		StorageTmp->sccpImportanceLevelDT1Len = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelDT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelDT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelDT2 not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelDT2;
		tmplen = StorageTmp->sccpImportanceLevelDT2Len;
		memdup((void *) &StorageTmp->sccpImportanceLevelDT2, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelDT2Len = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelDT2);
		StorageTmp->sccpImportanceLevelDT2 = tmpvar;
		StorageTmp->sccpImportanceLevelDT2Len = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelAK(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelAK entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelAK not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelAK;
		tmplen = StorageTmp->sccpImportanceLevelAKLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelAK, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelAKLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelAK);
		StorageTmp->sccpImportanceLevelAK = tmpvar;
		StorageTmp->sccpImportanceLevelAKLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelIT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelIT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelIT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelIT;
		tmplen = StorageTmp->sccpImportanceLevelITLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelIT, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelITLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelIT);
		StorageTmp->sccpImportanceLevelIT = tmpvar;
		StorageTmp->sccpImportanceLevelITLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelED(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelED entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelED not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelED;
		tmplen = StorageTmp->sccpImportanceLevelEDLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelED, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelEDLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelED);
		StorageTmp->sccpImportanceLevelED = tmpvar;
		StorageTmp->sccpImportanceLevelEDLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelEA(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelEA entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelEA not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelEA;
		tmplen = StorageTmp->sccpImportanceLevelEALen;
		memdup((void *) &StorageTmp->sccpImportanceLevelEA, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelEALen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelEA);
		StorageTmp->sccpImportanceLevelEA = tmpvar;
		StorageTmp->sccpImportanceLevelEALen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelRSR(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRSR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelRSR;
		tmplen = StorageTmp->sccpImportanceLevelRSRLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelRSR, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelRSRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelRSR);
		StorageTmp->sccpImportanceLevelRSR = tmpvar;
		StorageTmp->sccpImportanceLevelRSRLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelRSC(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRSC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRSC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelRSC;
		tmplen = StorageTmp->sccpImportanceLevelRSCLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelRSC, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelRSCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelRSC);
		StorageTmp->sccpImportanceLevelRSC = tmpvar;
		StorageTmp->sccpImportanceLevelRSCLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelERR(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelERR entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelERR not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelERR;
		tmplen = StorageTmp->sccpImportanceLevelERRLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelERR, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelERRLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelERR);
		StorageTmp->sccpImportanceLevelERR = tmpvar;
		StorageTmp->sccpImportanceLevelERRLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelRLC(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRLC entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLC not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelRLC;
		tmplen = StorageTmp->sccpImportanceLevelRLCLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelRLC, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelRLCLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelRLC);
		StorageTmp->sccpImportanceLevelRLC = tmpvar;
		StorageTmp->sccpImportanceLevelRLCLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelRLSD(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelRLSD entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelRLSD not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelRLSD;
		tmplen = StorageTmp->sccpImportanceLevelRLSDLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelRLSD, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelRLSDLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelRLSD);
		StorageTmp->sccpImportanceLevelRLSD = tmpvar;
		StorageTmp->sccpImportanceLevelRLSDLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelUDT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelUDT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelUDT;
		tmplen = StorageTmp->sccpImportanceLevelUDTLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelUDT, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelUDT);
		StorageTmp->sccpImportanceLevelUDT = tmpvar;
		StorageTmp->sccpImportanceLevelUDTLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelUDTS(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelUDTS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelUDTS;
		tmplen = StorageTmp->sccpImportanceLevelUDTSLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelUDTS, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelUDTS);
		StorageTmp->sccpImportanceLevelUDTS = tmpvar;
		StorageTmp->sccpImportanceLevelUDTSLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelXUDT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelXUDT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelXUDT;
		tmplen = StorageTmp->sccpImportanceLevelXUDTLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelXUDT, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelXUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelXUDT);
		StorageTmp->sccpImportanceLevelXUDT = tmpvar;
		StorageTmp->sccpImportanceLevelXUDTLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelXUDTS(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelXUDTS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelXUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelXUDTS;
		tmplen = StorageTmp->sccpImportanceLevelXUDTSLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelXUDTS, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelXUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelXUDTS);
		StorageTmp->sccpImportanceLevelXUDTS = tmpvar;
		StorageTmp->sccpImportanceLevelXUDTSLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelLUDT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelLUDT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelLUDT;
		tmplen = StorageTmp->sccpImportanceLevelLUDTLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelLUDT, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelLUDTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelLUDT);
		StorageTmp->sccpImportanceLevelLUDT = tmpvar;
		StorageTmp->sccpImportanceLevelLUDTLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpImportanceLevelLUDTS(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpImportanceLevelLUDTS entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpImportanceLevelLUDTS not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpImportanceLevelLUDTS;
		tmplen = StorageTmp->sccpImportanceLevelLUDTSLen;
		memdup((void *) &StorageTmp->sccpImportanceLevelLUDTS, var_val, var_val_len);
		StorageTmp->sccpImportanceLevelLUDTSLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpImportanceLevelLUDTS);
		StorageTmp->sccpImportanceLevelLUDTS = tmpvar;
		StorageTmp->sccpImportanceLevelLUDTSLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRLM(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpRLM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRLM not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpRLM;
		StorageTmp->sccpRLM = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRLM = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRSLM(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpRSLM entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRSLM not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpRSLM;
		StorageTmp->sccpRSLM = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpRSLM = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLinkageConcernedAreaPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpLinkageConcernedAreaPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageConcernedAreaPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpLinkageConcernedAreaPointer;
		tmplen = StorageTmp->sccpLinkageConcernedAreaPointerLen;
		memdup((void *) &StorageTmp->sccpLinkageConcernedAreaPointer, var_val, var_val_len);
		StorageTmp->sccpLinkageConcernedAreaPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpLinkageConcernedAreaPointer);
		StorageTmp->sccpLinkageConcernedAreaPointer = tmpvar;
		StorageTmp->sccpLinkageConcernedAreaPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLowerLimitForSegmentation(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpLowerLimitForSegmentation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLowerLimitForSegmentation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpLowerLimitForSegmentation;
		StorageTmp->sccpLowerLimitForSegmentation = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpLowerLimitForSegmentation = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpUpperLimitForSegmentation(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpUpperLimitForSegmentation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpUpperLimitForSegmentation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpUpperLimitForSegmentation;
		StorageTmp->sccpUpperLimitForSegmentation = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpUpperLimitForSegmentation = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLinkageName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpLinkageName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpLinkageName;
		tmplen = StorageTmp->sccpLinkageNameLen;
		memdup((void *) &StorageTmp->sccpLinkageName, var_val, var_val_len);
		StorageTmp->sccpLinkageNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpLinkageName);
		StorageTmp->sccpLinkageName = tmpvar;
		StorageTmp->sccpLinkageNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSclcAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpSclcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSclcAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSclcAlarmStatus;
		tmplen = StorageTmp->sccpSclcAlarmStatusLen;
		memdup((void *) &StorageTmp->sccpSclcAlarmStatus, var_val, var_val_len);
		StorageTmp->sccpSclcAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpSclcAlarmStatus);
		StorageTmp->sccpSclcAlarmStatus = tmpvar;
		StorageTmp->sccpSclcAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSclcAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSclcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSclcAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSclcAdministrativeState;
		StorageTmp->sccpSclcAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSclcOperationalSystemType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSclcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSclcOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcOperationalSystemType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSclcOperationalSystemType;
		StorageTmp->sccpSclcOperationalSystemType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSclcOperationalSystemType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpInitialValueReassTimer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSclcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpInitialValueReassTimer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInitialValueReassTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpInitialValueReassTimer;
		StorageTmp->sccpInitialValueReassTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpInitialValueReassTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSclcName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpSclcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSclcName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSclcName;
		tmplen = StorageTmp->sccpSclcNameLen;
		memdup((void *) &StorageTmp->sccpSclcName, var_val, var_val_len);
		StorageTmp->sccpSclcNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpSclcName);
		StorageTmp->sccpSclcName = tmpvar;
		StorageTmp->sccpSclcNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpCoProtocolMachineId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpScocTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpCoProtocolMachineId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpCoProtocolMachineId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpCoProtocolMachineId;
		tmplen = StorageTmp->sccpCoProtocolMachineIdLen;
		memdup((void *) &StorageTmp->sccpCoProtocolMachineId, var_val, var_val_len);
		StorageTmp->sccpCoProtocolMachineIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpCoProtocolMachineId);
		StorageTmp->sccpCoProtocolMachineId = tmpvar;
		StorageTmp->sccpCoProtocolMachineIdLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScocAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpScocTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpScocAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpScocAdministrativeState;
		StorageTmp->sccpScocAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScocOperationalSystemType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpScocTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpScocOperationalSystemType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocOperationalSystemType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpScocOperationalSystemType;
		StorageTmp->sccpScocOperationalSystemType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpScocOperationalSystemType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScocName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpScocTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpScocName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpScocName;
		tmplen = StorageTmp->sccpScocNameLen;
		memdup((void *) &StorageTmp->sccpScocName, var_val, var_val_len);
		StorageTmp->sccpScocNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpScocName);
		StorageTmp->sccpScocName = tmpvar;
		StorageTmp->sccpScocNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScrcId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpScrcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpScrcId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpScrcId;
		tmplen = StorageTmp->sccpScrcIdLen;
		memdup((void *) &StorageTmp->sccpScrcId, var_val, var_val_len);
		StorageTmp->sccpScrcIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpScrcId);
		StorageTmp->sccpScrcId = tmpvar;
		StorageTmp->sccpScrcIdLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScrcAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpScrcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpScrcAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpScrcAlarmStatus;
		tmplen = StorageTmp->sccpScrcAlarmStatusLen;
		memdup((void *) &StorageTmp->sccpScrcAlarmStatus, var_val, var_val_len);
		StorageTmp->sccpScrcAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpScrcAlarmStatus);
		StorageTmp->sccpScrcAlarmStatus = tmpvar;
		StorageTmp->sccpScrcAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScrcName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpScrcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpScrcName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpScrcName;
		tmplen = StorageTmp->sccpScrcNameLen;
		memdup((void *) &StorageTmp->sccpScrcName, var_val, var_val_len);
		StorageTmp->sccpScrcNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpScrcName);
		StorageTmp->sccpScrcName = tmpvar;
		StorageTmp->sccpScrcNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSharingMode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSharingMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSharingMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSharingMode;
		StorageTmp->sccpSharingMode = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpSharingMode = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLoadSharingAlgPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpLoadSharingAlgPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLoadSharingAlgPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpLoadSharingAlgPointer;
		tmplen = StorageTmp->sccpLoadSharingAlgPointerLen;
		memdup((void *) &StorageTmp->sccpLoadSharingAlgPointer, var_val, var_val_len);
		StorageTmp->sccpLoadSharingAlgPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpLoadSharingAlgPointer);
		StorageTmp->sccpLoadSharingAlgPointer = tmpvar;
		StorageTmp->sccpLoadSharingAlgPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpEntitySetName;
		tmplen = StorageTmp->sccpEntitySetNameLen;
		memdup((void *) &StorageTmp->sccpEntitySetName, var_val, var_val_len);
		StorageTmp->sccpEntitySetNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpEntitySetName);
		StorageTmp->sccpEntitySetName = tmpvar;
		StorageTmp->sccpEntitySetNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpEntitySetType;
		StorageTmp->sccpEntitySetType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetSsn(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSsn entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSsn not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpEntitySetSsn;
		tmplen = StorageTmp->sccpEntitySetSsnLen;
		memdup((void *) &StorageTmp->sccpEntitySetSsn, var_val, var_val_len);
		StorageTmp->sccpEntitySetSsnLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpEntitySetSsn);
		StorageTmp->sccpEntitySetSsn = tmpvar;
		StorageTmp->sccpEntitySetSsnLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetSapType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSapType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpEntitySetSapType;
		StorageTmp->sccpEntitySetSapType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpEntitySetSapType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetSapPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetSapPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpEntitySetSapPointer;
		tmplen = StorageTmp->sccpEntitySetSapPointerLen;
		memdup((void *) &StorageTmp->sccpEntitySetSapPointer, var_val, var_val_len);
		StorageTmp->sccpEntitySetSapPointerLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpEntitySetSapPointer);
		StorageTmp->sccpEntitySetSapPointer = tmpvar;
		StorageTmp->sccpEntitySetSapPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRemoteSCCPMTPAccessPoint(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpRemoteSCCPMTPAccessPoint entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPMTPAccessPoint not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpRemoteSCCPMTPAccessPoint;
		tmplen = StorageTmp->sccpRemoteSCCPMTPAccessPointLen;
		memdup((void *) &StorageTmp->sccpRemoteSCCPMTPAccessPoint, var_val, var_val_len);
		StorageTmp->sccpRemoteSCCPMTPAccessPointLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpRemoteSCCPMTPAccessPoint);
		StorageTmp->sccpRemoteSCCPMTPAccessPoint = tmpvar;
		StorageTmp->sccpRemoteSCCPMTPAccessPointLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRemoteSCCPName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpRemoteSCCPName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpRemoteSCCPName;
		tmplen = StorageTmp->sccpRemoteSCCPNameLen;
		memdup((void *) &StorageTmp->sccpRemoteSCCPName, var_val, var_val_len);
		StorageTmp->sccpRemoteSCCPNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpRemoteSCCPName);
		StorageTmp->sccpRemoteSCCPName = tmpvar;
		StorageTmp->sccpRemoteSCCPNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtNewEncodingScheme(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewEncodingScheme entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtNewEncodingScheme;
		StorageTmp->sccpGtNewEncodingScheme = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewEncodingScheme = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtNewNatureOfAddress(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewNatureOfAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNatureOfAddress not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtNewNatureOfAddress;
		StorageTmp->sccpGtNewNatureOfAddress = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewNatureOfAddress = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtNewNumberingPlan(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewNumberingPlan entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewNumberingPlan not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtNewNumberingPlan;
		StorageTmp->sccpGtNewNumberingPlan = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewNumberingPlan = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtNewTranslationType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtNewTranslationType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNewTranslationType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtNewTranslationType;
		StorageTmp->sccpGtNewTranslationType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNewTranslationType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtConversionRuleName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtConversionRuleName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtConversionRuleName;
		tmplen = StorageTmp->sccpGtConversionRuleNameLen;
		memdup((void *) &StorageTmp->sccpGtConversionRuleName, var_val, var_val_len);
		StorageTmp->sccpGtConversionRuleNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpGtConversionRuleName);
		StorageTmp->sccpGtConversionRuleName = tmpvar;
		StorageTmp->sccpGtConversionRuleNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAddressInfoOperation(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoOperation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoOperation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAddressInfoOperation;
		StorageTmp->sccpAddressInfoOperation = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoOperation = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAddressInfoAddressElement(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoAddressElement entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoAddressElement not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAddressInfoAddressElement;
		StorageTmp->sccpAddressInfoAddressElement = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoAddressElement = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAddressInfoNrOfAddressElements(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAddressInfoNrOfAddressElements entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoNrOfAddressElements not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAddressInfoNrOfAddressElements;
		StorageTmp->sccpAddressInfoNrOfAddressElements = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAddressInfoNrOfAddressElements = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtIndicator(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtIndicator entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtIndicator;
		StorageTmp->sccpGtIndicator = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtIndicator = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtNatureOfAddress(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtNatureOfAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNatureOfAddress not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtNatureOfAddress;
		StorageTmp->sccpGtNatureOfAddress = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNatureOfAddress = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtNumberingPlan(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtNumberingPlan entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtNumberingPlan not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtNumberingPlan;
		StorageTmp->sccpGtNumberingPlan = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtNumberingPlan = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtTranslationType(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslationType entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslationType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtTranslationType;
		StorageTmp->sccpGtTranslationType = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslationType = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtTranslatorAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslatorAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtTranslatorAdministrativeState;
		StorageTmp->sccpGtTranslatorAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtTranslatorAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtTranslatorName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtTranslatorName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtTranslatorName;
		tmplen = StorageTmp->sccpGtTranslatorNameLen;
		memdup((void *) &StorageTmp->sccpGtTranslatorName, var_val, var_val_len);
		StorageTmp->sccpGtTranslatorNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpGtTranslatorName);
		StorageTmp->sccpGtTranslatorName = tmpvar;
		StorageTmp->sccpGtTranslatorNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtRuleAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtRuleAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtRuleAdministrativeState;
		StorageTmp->sccpGtRuleAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtRuleAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtAddressInformation(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtAddressInformation entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtAddressInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtAddressInformation;
		tmplen = StorageTmp->sccpGtAddressInformationLen;
		memdup((void *) &StorageTmp->sccpGtAddressInformation, var_val, var_val_len);
		StorageTmp->sccpGtAddressInformationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpGtAddressInformation);
		StorageTmp->sccpGtAddressInformation = tmpvar;
		StorageTmp->sccpGtAddressInformationLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtConvRulePointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtConvRulePointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConvRulePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtConvRulePointer;
		tmplen = StorageTmp->sccpGtConvRulePointerLen;
		memdup((void *) &StorageTmp->sccpGtConvRulePointer, var_val, var_val_len);
		StorageTmp->sccpGtConvRulePointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpGtConvRulePointer);
		StorageTmp->sccpGtConvRulePointer = tmpvar;
		StorageTmp->sccpGtConvRulePointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtEncodingScheme(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtEncodingScheme entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtEncodingScheme not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtEncodingScheme;
		StorageTmp->sccpGtEncodingScheme = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpGtEncodingScheme = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetPointer(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpEntitySetPointer entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetPointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpEntitySetPointer;
		tmplen = StorageTmp->sccpEntitySetPointerLen;
		memdup((void *) &StorageTmp->sccpEntitySetPointer, var_val, var_val_len);
		StorageTmp->sccpEntitySetPointerLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpEntitySetPointer);
		StorageTmp->sccpEntitySetPointer = tmpvar;
		StorageTmp->sccpEntitySetPointerLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtRuleName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpGtRuleName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpGtRuleName;
		tmplen = StorageTmp->sccpGtRuleNameLen;
		memdup((void *) &StorageTmp->sccpGtRuleName, var_val, var_val_len);
		StorageTmp->sccpGtRuleNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpGtRuleName);
		StorageTmp->sccpGtRuleName = tmpvar;
		StorageTmp->sccpGtRuleNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpDSRVT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpDSRVT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpDSRVT not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpDSRVT;
		StorageTmp->sccpDSRVT = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpDSRVT = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpNSRVT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpNSRVT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpNSRVT not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpNSRVT;
		StorageTmp->sccpNSRVT = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpNSRVT = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSrvtName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpSrvtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSrvtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpSrvtName;
		tmplen = StorageTmp->sccpSrvtNameLen;
		memdup((void *) &StorageTmp->sccpSrvtName, var_val, var_val_len);
		StorageTmp->sccpSrvtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpSrvtName);
		StorageTmp->sccpSrvtName = tmpvar;
		StorageTmp->sccpSrvtNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpAdministrativeState;
		StorageTmp->sccpAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpTraceRequested(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpTraceRequested entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpTraceRequested not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpTraceRequested;
		StorageTmp->sccpTraceRequested = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpTraceRequested = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpThreshold(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpThreshold entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpThreshold not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpThreshold;
		StorageTmp->sccpThreshold = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpThreshold = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpMtpBackwardRoutingRequested(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpMtpBackwardRoutingRequested entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpMtpBackwardRoutingRequested not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpMtpBackwardRoutingRequested;
		StorageTmp->sccpMtpBackwardRoutingRequested = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->sccpMtpBackwardRoutingRequested = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpOriginalGT(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpOriginalGT entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpOriginalGT not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpOriginalGT;
		tmplen = StorageTmp->sccpOriginalGTLen;
		memdup((void *) &StorageTmp->sccpOriginalGT, var_val, var_val_len);
		StorageTmp->sccpOriginalGTLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpOriginalGT);
		StorageTmp->sccpOriginalGT = tmpvar;
		StorageTmp->sccpOriginalGTLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpInfoRequest(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpInfoRequest entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpInfoRequest not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpInfoRequest;
		tmplen = StorageTmp->sccpInfoRequestLen;
		memdup((void *) &StorageTmp->sccpInfoRequest, var_val, var_val_len);
		StorageTmp->sccpInfoRequestLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpInfoRequest);
		StorageTmp->sccpInfoRequest = tmpvar;
		StorageTmp->sccpInfoRequestLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpReturnUnknownParams(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("sccpMIB", "write_sccpReturnUnknownParams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpReturnUnknownParams not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->sccpReturnUnknownParams;
		tmplen = StorageTmp->sccpReturnUnknownParamsLen;
		memdup((void *) &StorageTmp->sccpReturnUnknownParams, var_val, var_val_len);
		StorageTmp->sccpReturnUnknownParamsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->sccpReturnUnknownParams);
		StorageTmp->sccpReturnUnknownParams = tmpvar;
		StorageTmp->sccpReturnUnknownParamsLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpNetworkEntityTable_data *StorageTmp = NULL;
	static struct sccpNetworkEntityTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpNetworkEntityTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpNetworkEntityTableStorage, NULL, &name[sizeof(sccpNetworkEntityTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpNetworkEntityTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpNetworkEntityTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpNetworkEntityTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpRowStatus;
			StorageTmp->sccpRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpNetworkEntityTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpNetworkEntityTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpNetworkEntityTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpNetworkEntityTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpNetworkEntityTable_add(StorageDel);
		} else {
			StorageTmp->sccpRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSapNameRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpSapNameTable_data *StorageTmp = NULL;
	static struct sccpSapNameTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpSapNameTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpSapNameTableStorage, NULL, &name[sizeof(sccpSapNameTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSapNameRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpSapId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpSapNameTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpSapNameTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpSapId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpSapNameRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpSapNameTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpSapNameRowStatus;
			StorageTmp->sccpSapNameRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpSapNameTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpSapNameTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpSapNameTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpSapNameTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpSapNameTable_add(StorageDel);
		} else {
			StorageTmp->sccpSapNameRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpSapNameRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpSapNameRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpSapNameRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpSapNameRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAccessPointRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpAccessPointTable_data *StorageTmp = NULL;
	static struct sccpAccessPointTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpAccessPointTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpAccessPointTableStorage, NULL, &name[sizeof(sccpAccessPointTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAccessPointRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpSapId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpAccessPointTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpAccessPointTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpSapId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sccpSsAvailableAfterSpRestart = 2;

			StorageNew->sccpAccessPointRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpAccessPointTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpAccessPointRowStatus;
			StorageTmp->sccpAccessPointRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpAccessPointTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpAccessPointTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpAccessPointTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpAccessPointTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpAccessPointTable_add(StorageDel);
		} else {
			StorageTmp->sccpAccessPointRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpAccessPointRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpAccessPointRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpAccessPointRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpAccessPointRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpLinkageRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpLinkageTable_data *StorageTmp = NULL;
	static struct sccpLinkageTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpLinkageTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpLinkageTableStorage, NULL, &name[sizeof(sccpLinkageTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpLinkageRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpLinkageId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpLinkageTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpLinkageTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->sccpLinkageId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sccpOperationalProtocols = strdup("{ class ( 0 ) , class1 ( 1 ) , class2 ( 2 ) , class3 ( 3 ) }");
			StorageNew->sccpOperationalProtocolsLen = strlen("{ class ( 0 ) , class1 ( 1 ) , class2 ( 2 ) , class3 ( 3 ) }");
			StorageNew->sccpNrOfRestrictionLevels = 8;
			StorageNew->sccpNrOfSubLevels = 4;
			StorageNew->sccpCLS = 8;
			StorageNew->sccpp = 8;
			StorageNew->sccpImportanceLevelCR = strdup("'0204'X");
			StorageNew->sccpImportanceLevelCRLen = strlen("'0204'X");
			StorageNew->sccpImportanceLevelCC = strdup("'0304'X");
			StorageNew->sccpImportanceLevelCCLen = strlen("'0304'X");
			StorageNew->sccpImportanceLevelCREF = strdup("'0204'X");
			StorageNew->sccpImportanceLevelCREFLen = strlen("'0204'X");
			StorageNew->sccpImportanceLevelDT1 = strdup("'0406'X");
			StorageNew->sccpImportanceLevelDT1Len = strlen("'0406'X");
			StorageNew->sccpImportanceLevelDT2 = strdup("'0406'X");
			StorageNew->sccpImportanceLevelDT2Len = strlen("'0406'X");
			StorageNew->sccpImportanceLevelAK = strdup("'0600'X");
			StorageNew->sccpImportanceLevelAKLen = strlen("'0600'X");
			StorageNew->sccpImportanceLevelIT = strdup("'0600'X");
			StorageNew->sccpImportanceLevelITLen = strlen("'0600'X");
			StorageNew->sccpImportanceLevelED = strdup("'0700'X");
			StorageNew->sccpImportanceLevelEDLen = strlen("'0700'X");
			StorageNew->sccpImportanceLevelEA = strdup("'0700'X");
			StorageNew->sccpImportanceLevelEALen = strlen("'0700'X");
			StorageNew->sccpImportanceLevelRSR = strdup("'0600'X");
			StorageNew->sccpImportanceLevelRSRLen = strlen("'0600'X");
			StorageNew->sccpImportanceLevelRSC = strdup("'0600'X");
			StorageNew->sccpImportanceLevelRSCLen = strlen("'0600'X");
			StorageNew->sccpImportanceLevelERR = strdup("'0700'X");
			StorageNew->sccpImportanceLevelERRLen = strlen("'0700'X");
			StorageNew->sccpImportanceLevelRLC = strdup("'0400'X");
			StorageNew->sccpImportanceLevelRLCLen = strlen("'0400'X");
			StorageNew->sccpImportanceLevelRLSD = strdup("'0606'X");
			StorageNew->sccpImportanceLevelRLSDLen = strlen("'0606'X");
			StorageNew->sccpImportanceLevelUDT = strdup("'0406'X");
			StorageNew->sccpImportanceLevelUDTLen = strlen("'0406'X");
			StorageNew->sccpImportanceLevelUDTS = strdup("'0300'X");
			StorageNew->sccpImportanceLevelUDTSLen = strlen("'0300'X");
			StorageNew->sccpImportanceLevelXUDT = strdup("'0406'X");
			StorageNew->sccpImportanceLevelXUDTLen = strlen("'0406'X");
			StorageNew->sccpImportanceLevelXUDTS = strdup("'0300'X");
			StorageNew->sccpImportanceLevelXUDTSLen = strlen("'0300'X");
			StorageNew->sccpImportanceLevelLUDT = strdup("'0406'X");
			StorageNew->sccpImportanceLevelLUDTLen = strlen("'0406'X");
			StorageNew->sccpImportanceLevelLUDTS = strdup("'0300'X");
			StorageNew->sccpImportanceLevelLUDTSLen = strlen("'0300'X");

			StorageNew->sccpLinkageRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpLinkageTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpLinkageRowStatus;
			StorageTmp->sccpLinkageRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpLinkageTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpLinkageTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpLinkageTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpLinkageTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpLinkageTable_add(StorageDel);
		} else {
			StorageTmp->sccpLinkageRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpLinkageRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpLinkageRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpLinkageRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpLinkageRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpSclcRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpSclcTable_data *StorageTmp = NULL;
	static struct sccpSclcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpSclcTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpSclcTableStorage, NULL, &name[sizeof(sccpSclcTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpSclcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpSclcTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpSclcTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpSclcRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpSclcTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpSclcRowStatus;
			StorageTmp->sccpSclcRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpSclcTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpSclcTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpSclcTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpSclcTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpSclcTable_add(StorageDel);
		} else {
			StorageTmp->sccpSclcRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpSclcRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpSclcRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpSclcRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpSclcRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScocRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpScocTable_data *StorageTmp = NULL;
	static struct sccpScocTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpScocTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpScocTableStorage, NULL, &name[sizeof(sccpScocTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScocRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpScocTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpScocTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpScocRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpScocTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpScocRowStatus;
			StorageTmp->sccpScocRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpScocTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpScocTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpScocTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpScocTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpScocTable_add(StorageDel);
		} else {
			StorageTmp->sccpScocRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpScocRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpScocRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpScocRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpScocRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpScrcRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpScrcTable_data *StorageTmp = NULL;
	static struct sccpScrcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpScrcTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpScrcTableStorage, NULL, &name[sizeof(sccpScrcTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpScrcRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpScrcTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpScrcTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpScrcRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpScrcTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpScrcRowStatus;
			StorageTmp->sccpScrcRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpScrcTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpScrcTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpScrcTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpScrcTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpScrcTable_add(StorageDel);
		} else {
			StorageTmp->sccpScrcRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpScrcRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpScrcRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpScrcRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpScrcRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpEntitySetTable_data *StorageTmp = NULL;
	static struct sccpEntitySetTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpEntitySetTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpEntitySetTableStorage, NULL, &name[sizeof(sccpEntitySetTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpEntitySetId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpEntitySetTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpEntitySetRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpEntitySetTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpEntitySetRowStatus;
			StorageTmp->sccpEntitySetRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpEntitySetTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpEntitySetTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpEntitySetTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpEntitySetTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpEntitySetTable_add(StorageDel);
		} else {
			StorageTmp->sccpEntitySetRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpEntitySetRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpEntitySetRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpEntitySetRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpEntitySetRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpEntitySetSapRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpEntitySetSapTable_data *StorageTmp = NULL;
	static struct sccpEntitySetSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpEntitySetSapTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpEntitySetSapTableStorage, NULL, &name[sizeof(sccpEntitySetSapTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpEntitySetSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpEntitySetId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpEntitySetSapId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpEntitySetSapTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpEntitySetSapTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpEntitySetSapId, vp->val.string, vp->val_len);
			StorageNew->sccpEntitySetSapIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpEntitySetSapRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpEntitySetSapTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpEntitySetSapRowStatus;
			StorageTmp->sccpEntitySetSapRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpEntitySetSapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpEntitySetSapTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpEntitySetSapTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpEntitySetSapTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpEntitySetSapTable_add(StorageDel);
		} else {
			StorageTmp->sccpEntitySetSapRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpEntitySetSapRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpEntitySetSapRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpEntitySetSapRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpEntitySetSapRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpConcernedAreaRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpConcernedAreaTable_data *StorageTmp = NULL;
	static struct sccpConcernedAreaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpConcernedAreaTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpConcernedAreaTableStorage, NULL, &name[sizeof(sccpConcernedAreaTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpConcernedAreaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpConcernedAreaId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpConcernedAreaTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpConcernedAreaTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpConcernedAreaId, vp->val.string, vp->val_len);
			StorageNew->sccpConcernedAreaIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpConcernedAreaRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpConcernedAreaTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpConcernedAreaRowStatus;
			StorageTmp->sccpConcernedAreaRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpConcernedAreaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpConcernedAreaTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpConcernedAreaTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpConcernedAreaTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpConcernedAreaTable_add(StorageDel);
		} else {
			StorageTmp->sccpConcernedAreaRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpConcernedAreaRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpConcernedAreaRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpConcernedAreaRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpConcernedAreaRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRemoteSCCPRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpRemoteSCCPTable_data *StorageTmp = NULL;
	static struct sccpRemoteSCCPTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpRemoteSCCPTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpRemoteSCCPTableStorage, NULL, &name[sizeof(sccpRemoteSCCPTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRemoteSCCPRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpConcernedAreaId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpRemoteSCCPId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpRemoteSCCPTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpRemoteSCCPTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpConcernedAreaId, vp->val.string, vp->val_len);
			StorageNew->sccpConcernedAreaIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpRemoteSCCPId, vp->val.string, vp->val_len);
			StorageNew->sccpRemoteSCCPIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpRemoteSCCPRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpRemoteSCCPTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpRemoteSCCPRowStatus;
			StorageTmp->sccpRemoteSCCPRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpRemoteSCCPTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpRemoteSCCPTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpRemoteSCCPTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpRemoteSCCPTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpRemoteSCCPTable_add(StorageDel);
		} else {
			StorageTmp->sccpRemoteSCCPRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpRemoteSCCPRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpRemoteSCCPRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpRemoteSCCPRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpRemoteSCCPRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtConversionRuleRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpGtConversionRuleTable_data *StorageTmp = NULL;
	static struct sccpGtConversionRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpGtConversionRuleTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpGtConversionRuleTableStorage, NULL, &name[sizeof(sccpGtConversionRuleTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtConversionRuleRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpGtConversionRuleId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpGtConversionRuleTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpGtConversionRuleTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtConversionRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtConversionRuleIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sccpGtNewEncodingScheme = 256;
			StorageNew->sccpGtNewNatureOfAddress = 256;
			StorageNew->sccpGtNewNumberingPlan = 256;
			StorageNew->sccpGtNewTranslationType = 256;

			StorageNew->sccpGtConversionRuleRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpGtConversionRuleTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpGtConversionRuleRowStatus;
			StorageTmp->sccpGtConversionRuleRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpGtConversionRuleTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpGtConversionRuleTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpGtConversionRuleTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpGtConversionRuleTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpGtConversionRuleTable_add(StorageDel);
		} else {
			StorageTmp->sccpGtConversionRuleRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpGtConversionRuleRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpGtConversionRuleRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpGtConversionRuleRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpGtConversionRuleRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpAddressInfoRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpAddressInfoTable_data *StorageTmp = NULL;
	static struct sccpAddressInfoTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpAddressInfoTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpAddressInfoTableStorage, NULL, &name[sizeof(sccpAddressInfoTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpAddressInfoRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpGtConversionRuleId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpAddressInfoOperationId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpAddressInfoTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpAddressInfoTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtConversionRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtConversionRuleIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpAddressInfoOperationId, vp->val.string, vp->val_len);
			StorageNew->sccpAddressInfoOperationIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpAddressInfoRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpAddressInfoTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpAddressInfoRowStatus;
			StorageTmp->sccpAddressInfoRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpAddressInfoTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpAddressInfoTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpAddressInfoTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpAddressInfoTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpAddressInfoTable_add(StorageDel);
		} else {
			StorageTmp->sccpAddressInfoRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpAddressInfoRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpAddressInfoRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpAddressInfoRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpAddressInfoRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtTranslatorRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpGtTranslatorTable_data *StorageTmp = NULL;
	static struct sccpGtTranslatorTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpGtTranslatorTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpGtTranslatorTableStorage, NULL, &name[sizeof(sccpGtTranslatorTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtTranslatorRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpGtTranslatorId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpGtTranslatorTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpGtTranslatorTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtTranslatorId, vp->val.string, vp->val_len);
			StorageNew->sccpGtTranslatorIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpGtTranslatorRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpGtTranslatorTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpGtTranslatorRowStatus;
			StorageTmp->sccpGtTranslatorRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpGtTranslatorTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpGtTranslatorTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpGtTranslatorTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpGtTranslatorTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpGtTranslatorTable_add(StorageDel);
		} else {
			StorageTmp->sccpGtTranslatorRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpGtTranslatorRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpGtTranslatorRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpGtTranslatorRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpGtTranslatorRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpGtRuleRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpGtRuleTable_data *StorageTmp = NULL;
	static struct sccpGtRuleTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpGtRuleTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpGtRuleTableStorage, NULL, &name[sizeof(sccpGtRuleTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpGtRuleRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpGtTranslatorId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpGtRuleId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpGtRuleTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpGtRuleTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtTranslatorId, vp->val.string, vp->val_len);
			StorageNew->sccpGtTranslatorIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpGtRuleId, vp->val.string, vp->val_len);
			StorageNew->sccpGtRuleIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->sccpGtRuleRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpGtRuleTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpGtRuleRowStatus;
			StorageTmp->sccpGtRuleRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpGtRuleTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpGtRuleTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpGtRuleTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpGtRuleTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpGtRuleTable_add(StorageDel);
		} else {
			StorageTmp->sccpGtRuleRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpGtRuleRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpGtRuleRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpGtRuleRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpGtRuleRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sccpRouteTestRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct sccpSrvtTable_data *StorageTmp = NULL;
	static struct sccpSrvtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(sccpSrvtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(sccpSrvtTableStorage, NULL, &name[sizeof(sccpSrvtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to sccpRouteTestRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UINTEGER, NULL, 0);	/* sccpNetworkEntityId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* sccpRouteTestId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(sccpSrvtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(sccpSrvtTable_data);
			StorageNew->sccpNetworkEntityId = *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->sccpRouteTestId, vp->val.string, vp->val_len);
			StorageNew->sccpRouteTestIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->sccpMtpBackwardRoutingRequested = 2;

			StorageNew->sccpRouteTestRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				sccpSrvtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->sccpRouteTestRowStatus;
			StorageTmp->sccpRouteTestRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(sccpSrvtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpSrvtTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(sccpSrvtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&sccpSrvtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			sccpSrvtTable_add(StorageDel);
		} else {
			StorageTmp->sccpRouteTestRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->sccpRouteTestRowStatus == RS_CREATEANDGO) {
				StorageTmp->sccpRouteTestRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->sccpRouteTestRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->sccpRouteTestRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
