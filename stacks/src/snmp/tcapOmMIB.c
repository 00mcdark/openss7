/*****************************************************************************

 @(#) $RCSfile: tcapOmMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2009-01-03 10:51:07 $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2009-01-03 10:51:07 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: tcapOmMIB.c,v $
 Revision 0.9.2.4  2009-01-03 10:51:07  brian
 - updated agent

 Revision 0.9.2.3  2009-01-02 15:46:44  brian
 - corrections

 Revision 0.9.2.2  2009-01-02 15:04:16  brian
 - updated agents

 Revision 0.9.2.1  2008-12-31 16:09:08  brian
 - added new mibs

 *****************************************************************************/

#ident "@(#) $RCSfile: tcapOmMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2009-01-03 10:51:07 $"

static char const ident[] = "$RCSfile: tcapOmMIB.c,v $ $Name:  $($Revision: 0.9.2.4 $) $Date: 2009-01-03 10:51:07 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "tcapOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int tcapOmMIB_refresh = 1;
volatile int tcapOmNodeTable_refresh = 1;
volatile int tcapOmNodeCurrentTable_refresh = 1;
volatile int tcapOmNode5minIntTable_refresh = 1;
volatile int tcapOmNode15minIntTable_refresh = 1;
volatile int tcapOmMsgsTable_refresh = 1;
volatile int tcapOmMsgsCurrentTable_refresh = 1;
volatile int tcapOmMsgs5minIntTable_refresh = 1;
volatile int tcapOmMsgs15minIntTable_refresh = 1;
volatile int tcapOmAETable_refresh = 1;
volatile int tcapOmAECurrentTable_refresh = 1;
volatile int tcapOmAE5minIntTable_refresh = 1;
volatile int tcapOmAE15minIntTable_refresh = 1;
volatile int tcapOmTcTable_refresh = 1;
volatile int tcapOmTcCurrentTable_refresh = 1;
volatile int tcapOmTc5minIntTable_refresh = 1;
volatile int tcapOmTc15minIntTable_refresh = 1;
volatile int tcapOmDevelRecvTable_refresh = 1;
volatile int tcapOmDevelRecvCurrentTable_refresh = 1;
volatile int tcapOmDevelRecv5minIntTable_refresh = 1;
volatile int tcapOmDevelRecv15minIntTable_refresh = 1;
volatile int tcapOmDevelSentTable_refresh = 1;
volatile int tcapOmDevelSentCurrentTable_refresh = 1;
volatile int tcapOmDevelSent5minIntTable_refresh = 1;
volatile int tcapOmDevelSent15minIntTable_refresh = 1;

/*
 * tcapOmMIB_variables_oid: object identifier for tcapOmMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid tcapOmMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 4 };

/*
 * Oids for use in notifications defined in this MIB.
 */

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid tcapOmMessageType_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 4, 1, 3 };

/*
 * Other oids defined in this MIB.
 */

static const oid zeroDotZero_oid[2] = { 0, 0 };

/*
 * variable7 tcapOmMIB_variables: tree for tcapOmMIB
 * This variable defines function callbacks and type return information for the tcapOmMIB mib section
 */
struct variable7 tcapOmMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   TCAPOMNODEMESSAGESSENT  (4 % 256)
	{TCAPOMNODEMESSAGESSENT, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 1}},
#define   TCAPOMNODEMESSAGESRECV  (5 % 256)
	{TCAPOMNODEMESSAGESRECV, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 2}},
#define   TCAPOMNODECOMPONENTSSENT  (6 % 256)
	{TCAPOMNODECOMPONENTSSENT, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 3}},
#define   TCAPOMNODECOMPONENTSRECV  (7 % 256)
	{TCAPOMNODECOMPONENTSRECV, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 4}},
#define   TCAPOMNODE5MINVALIDINTERVALS  (8 % 256)
	{TCAPOMNODE5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 5}},
#define   TCAPOMNODE15MINVALIDINTERVALS  (9 % 256)
	{TCAPOMNODE15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 6}},
#define   TCAPOMNODECURRENTMESSAGESSENT  (13 % 256)
	{TCAPOMNODECURRENTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 1}},
#define   TCAPOMNODECURRENTMESSAGESRECV  (14 % 256)
	{TCAPOMNODECURRENTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 2}},
#define   TCAPOMNODECURRENTCOMPONENTSSENT  (15 % 256)
	{TCAPOMNODECURRENTCOMPONENTSSENT, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 3}},
#define   TCAPOMNODECURRENTCOMPONENTSRECV  (16 % 256)
	{TCAPOMNODECURRENTCOMPONENTSRECV, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 4}},
#define   TCAPOMNODE5MININTMESSAGESSENT  (21 % 256)
	{TCAPOMNODE5MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 1}},
#define   TCAPOMNODE5MININTMESSAGESRECV  (22 % 256)
	{TCAPOMNODE5MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 2}},
#define   TCAPOMNODE5MININTCOMPONENTSSENT  (23 % 256)
	{TCAPOMNODE5MININTCOMPONENTSSENT, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 3}},
#define   TCAPOMNODE5MININTCOMPONENTSRECV  (24 % 256)
	{TCAPOMNODE5MININTCOMPONENTSRECV, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 4}},
#define   TCAPOMNODE15MININTMESSAGESSENT  (29 % 256)
	{TCAPOMNODE15MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 1}},
#define   TCAPOMNODE15MININTMESSAGESRECV  (30 % 256)
	{TCAPOMNODE15MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 2}},
#define   TCAPOMNODE15MININTCOMPONENTSSENT  (31 % 256)
	{TCAPOMNODE15MININTCOMPONENTSSENT, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 3}},
#define   TCAPOMNODE15MININTCOMPONENTSRECV  (32 % 256)
	{TCAPOMNODE15MININTCOMPONENTSRECV, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 4}},
#define   TCAPOMMSGSMESSAGESSENT  (37 % 256)
	{TCAPOMMSGSMESSAGESSENT, ASN_COUNTER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 1}},
#define   TCAPOMMSGSMESSAGESRECV  (38 % 256)
	{TCAPOMMSGSMESSAGESRECV, ASN_COUNTER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   TCAPOMMSGS5MINVALIDINTERVALS  (39 % 256)
	{TCAPOMMSGS5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   TCAPOMMSGS15MINVALIDINTERVALS  (40 % 256)
	{TCAPOMMSGS15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   TCAPOMMSGSCURRENTMESSAGESSENT  (45 % 256)
	{TCAPOMMSGSCURRENTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmMsgsCurrentTable, 6, {1, 1, 2, 2, 1, 1}},
#define   TCAPOMMSGSCURRENTMESSAGESRECV  (46 % 256)
	{TCAPOMMSGSCURRENTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmMsgsCurrentTable, 6, {1, 1, 2, 2, 1, 2}},
#define   TCAPOMMSGS5MININTMESSAGESSENT  (52 % 256)
	{TCAPOMMSGS5MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmMsgs5minIntTable, 6, {1, 1, 2, 3, 1, 1}},
#define   TCAPOMMSGS5MININTMESSAGESRECV  (53 % 256)
	{TCAPOMMSGS5MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmMsgs5minIntTable, 6, {1, 1, 2, 3, 1, 2}},
#define   TCAPOMMSGS15MININTMESSAGESSENT  (59 % 256)
	{TCAPOMMSGS15MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmMsgs15minIntTable, 6, {1, 1, 2, 4, 1, 1}},
#define   TCAPOMMSGS15MININTMESSAGESRECV  (60 % 256)
	{TCAPOMMSGS15MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmMsgs15minIntTable, 6, {1, 1, 2, 4, 1, 2}},
#define   TCAPOMAEMEASUREMENTDELETED  (64 % 256)
	{TCAPOMAEMEASUREMENTDELETED, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 1}},
#define   TCAPOMAENEWTRANSACTIONS  (65 % 256)
	{TCAPOMAENEWTRANSACTIONS, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 2}},
#define   TCAPOMAEMEANOPENTRANSACTIONS  (66 % 256)
	{TCAPOMAEMEANOPENTRANSACTIONS, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 3}},
#define   TCAPOMAENOTUSED       (67 % 256)
	{TCAPOMAENOTUSED, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 4}},
#define   TCAPOMAECUMMULATIVEMEANDURATION  (68 % 256)
	{TCAPOMAECUMMULATIVEMEANDURATION, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 5}},
#define   TCAPOMAEMAXIMUMOPENTRANACTIONS  (69 % 256)
	{TCAPOMAEMAXIMUMOPENTRANACTIONS, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 6}},
#define   TCAPOMAETHRESHOLDEXCEEDED  (70 % 256)
	{TCAPOMAETHRESHOLDEXCEEDED, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 7}},
#define   TCAPOMAE5MINVALIDINTERVALS  (71 % 256)
	{TCAPOMAE5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 8}},
#define   TCAPOMAE15MINVALIDINTERVALS  (72 % 256)
	{TCAPOMAE15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 9}},
#define   TCAPOMAECURRENTMEASUREMENTDELETED  (76 % 256)
	{TCAPOMAECURRENTMEASUREMENTDELETED, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 1}},
#define   TCAPOMAECURRENTNEWTRANSACTIONS  (77 % 256)
	{TCAPOMAECURRENTNEWTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 2}},
#define   TCAPOMAECURRENTMEANOPENTRANSACTIONS  (78 % 256)
	{TCAPOMAECURRENTMEANOPENTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 3}},
#define   TCAPOMAECURRENTNOTUSED  (79 % 256)
	{TCAPOMAECURRENTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 4}},
#define   TCAPOMAECURRENTCUMMULATIVEMEANDURATION  (80 % 256)
	{TCAPOMAECURRENTCUMMULATIVEMEANDURATION, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 5}},
#define   TCAPOMAECURRENTMAXIMUMOPENTRANACTIONS  (81 % 256)
	{TCAPOMAECURRENTMAXIMUMOPENTRANACTIONS, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 6}},
#define   TCAPOMAECURRENTTHRESHOLDEXCEEDED  (82 % 256)
	{TCAPOMAECURRENTTHRESHOLDEXCEEDED, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 7}},
#define   TCAPOMAE5MININTMEASUREMENTDELETED  (87 % 256)
	{TCAPOMAE5MININTMEASUREMENTDELETED, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 1}},
#define   TCAPOMAE5MININTNEWTRANSACTIONS  (88 % 256)
	{TCAPOMAE5MININTNEWTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 2}},
#define   TCAPOMAE5MININTMEANOPENTRANSACTIONS  (89 % 256)
	{TCAPOMAE5MININTMEANOPENTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 3}},
#define   TCAPOMAE5MININTNOTUSED  (90 % 256)
	{TCAPOMAE5MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 4}},
#define   TCAPOMAE5MININTCUMMULATIVEMEANDURATION  (91 % 256)
	{TCAPOMAE5MININTCUMMULATIVEMEANDURATION, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 5}},
#define   TCAPOMAE5MININTMAXIMUMOPENTRANACTIONS  (92 % 256)
	{TCAPOMAE5MININTMAXIMUMOPENTRANACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 6}},
#define   TCAPOMAE5MININTTHRESHOLDEXCEEDED  (93 % 256)
	{TCAPOMAE5MININTTHRESHOLDEXCEEDED, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 7}},
#define   TCAPOMAE15MININTMEASUREMENTDELETED  (98 % 256)
	{TCAPOMAE15MININTMEASUREMENTDELETED, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 1}},
#define   TCAPOMAE15MININTNEWTRANSACTIONS  (99 % 256)
	{TCAPOMAE15MININTNEWTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 2}},
#define   TCAPOMAE15MININTMEANOPENTRANSACTIONS  (100 % 256)
	{TCAPOMAE15MININTMEANOPENTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 3}},
#define   TCAPOMAE15MININTNOTUSED  (101 % 256)
	{TCAPOMAE15MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 4}},
#define   TCAPOMAE15MININTCUMMULATIVEMEANDURATION  (102 % 256)
	{TCAPOMAE15MININTCUMMULATIVEMEANDURATION, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 5}},
#define   TCAPOMAE15MININTMAXIMUMOPENTRANACTIONS  (103 % 256)
	{TCAPOMAE15MININTMAXIMUMOPENTRANACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 6}},
#define   TCAPOMAE15MININTTHRESHOLDEXCEEDED  (104 % 256)
	{TCAPOMAE15MININTTHRESHOLDEXCEEDED, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 7}},
#define   TCAPOMTCPABORTRECVUNRECTID  (108 % 256)
	{TCAPOMTCPABORTRECVUNRECTID, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 1}},
#define   TCAPOMTCPABORTRECVRESOURCELIM  (109 % 256)
	{TCAPOMTCPABORTRECVRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 2}},
#define   TCAPOMTCREJECTRECVRESOURCELIM  (110 % 256)
	{TCAPOMTCREJECTRECVRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 3}},
#define   TCAPOMTCPABORTSENTUNRECTID  (111 % 256)
	{TCAPOMTCPABORTSENTUNRECTID, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 4}},
#define   TCAPOMTCPABORTSENTRESOURCELIM  (112 % 256)
	{TCAPOMTCPABORTSENTRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 5}},
#define   TCAPOMTCREJECTSENTRESOURCELIM  (113 % 256)
	{TCAPOMTCREJECTSENTRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 6}},
#define   TCAPOMTCTCUSERCANCEL  (114 % 256)
	{TCAPOMTCTCUSERCANCEL, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 7}},
#define   TCAPOMTCMESSAGESDISCARDED  (115 % 256)
	{TCAPOMTCMESSAGESDISCARDED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 8}},
#define   TCAPOMTCNOTUSED       (116 % 256)
	{TCAPOMTCNOTUSED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 9}},
#define   TCAPOMTCPABORTSRECEIVED  (117 % 256)
	{TCAPOMTCPABORTSRECEIVED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 10}},
#define   TCAPOMTCTCUSERREJECTSRECEIVED  (118 % 256)
	{TCAPOMTCTCUSERREJECTSRECEIVED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 11}},
#define   TCAPOMTCTPERRORS      (119 % 256)
	{TCAPOMTCTPERRORS, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 12}},
#define   TCAPOMTC5MINVALIDINTERVALS  (120 % 256)
	{TCAPOMTC5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 13}},
#define   TCAPOMTC15MINVALIDINTERVALS  (121 % 256)
	{TCAPOMTC15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 14}},
#define   TCAPOMTCCURRENTPABORTRECVUNRECTID  (125 % 256)
	{TCAPOMTCCURRENTPABORTRECVUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 1}},
#define   TCAPOMTCCURRENTPABORTRECVRESOURCELIM  (126 % 256)
	{TCAPOMTCCURRENTPABORTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 2}},
#define   TCAPOMTCCURRENTREJECTRECVRESOURCELIM  (127 % 256)
	{TCAPOMTCCURRENTREJECTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 3}},
#define   TCAPOMTCCURRENTPABORTSENTUNRECTID  (128 % 256)
	{TCAPOMTCCURRENTPABORTSENTUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 4}},
#define   TCAPOMTCCURRENTPABORTSENTRESOURCELIM  (129 % 256)
	{TCAPOMTCCURRENTPABORTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 5}},
#define   TCAPOMTCCURRENTREJECTSENTRESOURCELIM  (130 % 256)
	{TCAPOMTCCURRENTREJECTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 6}},
#define   TCAPOMTCCURRENTTCUSERCANCEL  (131 % 256)
	{TCAPOMTCCURRENTTCUSERCANCEL, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 7}},
#define   TCAPOMTCCURRENTMESSAGESDISCARDED  (132 % 256)
	{TCAPOMTCCURRENTMESSAGESDISCARDED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 8}},
#define   TCAPOMTCCURRENTNOTUSED  (133 % 256)
	{TCAPOMTCCURRENTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 9}},
#define   TCAPOMTCCURRENTPABORTSRECEIVED  (134 % 256)
	{TCAPOMTCCURRENTPABORTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 10}},
#define   TCAPOMTCCURRENTTCUSERREJECTSRECEIVED  (135 % 256)
	{TCAPOMTCCURRENTTCUSERREJECTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 11}},
#define   TCAPOMTCCURRENTTPERRORS  (136 % 256)
	{TCAPOMTCCURRENTTPERRORS, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 12}},
#define   TCAPOMTC5MININTPABORTRECVUNRECTID  (141 % 256)
	{TCAPOMTC5MININTPABORTRECVUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 1}},
#define   TCAPOMTC5MININTPABORTRECVRESOURCELIM  (142 % 256)
	{TCAPOMTC5MININTPABORTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 2}},
#define   TCAPOMTC5MININTREJECTRECVRESOURCELIM  (143 % 256)
	{TCAPOMTC5MININTREJECTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 3}},
#define   TCAPOMTC5MININTPABORTSENTUNRECTID  (144 % 256)
	{TCAPOMTC5MININTPABORTSENTUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 4}},
#define   TCAPOMTC5MININTPABORTSENTRESOURCELIM  (145 % 256)
	{TCAPOMTC5MININTPABORTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 5}},
#define   TCAPOMTC5MININTREJECTSENTRESOURCELIM  (146 % 256)
	{TCAPOMTC5MININTREJECTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 6}},
#define   TCAPOMTC5MININTTCUSERCANCEL  (147 % 256)
	{TCAPOMTC5MININTTCUSERCANCEL, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 7}},
#define   TCAPOMTC5MININTMESSAGESDISCARDED  (148 % 256)
	{TCAPOMTC5MININTMESSAGESDISCARDED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 8}},
#define   TCAPOMTC5MININTNOTUSED  (149 % 256)
	{TCAPOMTC5MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 9}},
#define   TCAPOMTC5MININTPABORTSRECEIVED  (150 % 256)
	{TCAPOMTC5MININTPABORTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 10}},
#define   TCAPOMTC5MININTTCUSERREJECTSRECEIVED  (151 % 256)
	{TCAPOMTC5MININTTCUSERREJECTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 11}},
#define   TCAPOMTC5MININTTPERRORS  (152 % 256)
	{TCAPOMTC5MININTTPERRORS, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 12}},
#define   TCAPOMTC15MININTPABORTRECVUNRECTID  (157 % 256)
	{TCAPOMTC15MININTPABORTRECVUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 1}},
#define   TCAPOMTC15MININTPABORTRECVRESOURCELIM  (158 % 256)
	{TCAPOMTC15MININTPABORTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 2}},
#define   TCAPOMTC15MININTREJECTRECVRESOURCELIM  (159 % 256)
	{TCAPOMTC15MININTREJECTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 3}},
#define   TCAPOMTC15MININTPABORTSENTUNRECTID  (160 % 256)
	{TCAPOMTC15MININTPABORTSENTUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 4}},
#define   TCAPOMTC15MININTPABORTSENTRESOURCELIM  (161 % 256)
	{TCAPOMTC15MININTPABORTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 5}},
#define   TCAPOMTC15MININTREJECTSENTRESOURCELIM  (162 % 256)
	{TCAPOMTC15MININTREJECTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 6}},
#define   TCAPOMTC15MININTTCUSERCANCEL  (163 % 256)
	{TCAPOMTC15MININTTCUSERCANCEL, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 7}},
#define   TCAPOMTC15MININTMESSAGESDISCARDED  (164 % 256)
	{TCAPOMTC15MININTMESSAGESDISCARDED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 8}},
#define   TCAPOMTC15MININTNOTUSED  (165 % 256)
	{TCAPOMTC15MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 9}},
#define   TCAPOMTC15MININTPABORTSRECEIVED  (166 % 256)
	{TCAPOMTC15MININTPABORTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 10}},
#define   TCAPOMTC15MININTTCUSERREJECTSRECEIVED  (167 % 256)
	{TCAPOMTC15MININTTCUSERREJECTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 11}},
#define   TCAPOMTC15MININTTPERRORS  (168 % 256)
	{TCAPOMTC15MININTTPERRORS, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 12}},
#define   TCAPOMDEVELRECVPABORTMESSAGETYPE  (172 % 256)
	{TCAPOMDEVELRECVPABORTMESSAGETYPE, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 1}},
#define   TCAPOMDEVELRECVPABORTINCORRECTTP  (173 % 256)
	{TCAPOMDEVELRECVPABORTINCORRECTTP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 2}},
#define   TCAPOMDEVELRECVPABORTBADTP  (174 % 256)
	{TCAPOMDEVELRECVPABORTBADTP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 3}},
#define   TCAPOMDEVELRECVREJECTUNRECCOMP  (175 % 256)
	{TCAPOMDEVELRECVREJECTUNRECCOMP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 4}},
#define   TCAPOMDEVELRECVREJECTMISTYPECOMP  (176 % 256)
	{TCAPOMDEVELRECVREJECTMISTYPECOMP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 5}},
#define   TCAPOMDEVELRECVREJECTBADCOMPSTRUCT  (177 % 256)
	{TCAPOMDEVELRECVREJECTBADCOMPSTRUCT, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 6}},
#define   TCAPOMDEVELRECVREJECTUNRECLINKID  (178 % 256)
	{TCAPOMDEVELRECVREJECTUNRECLINKID, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 7}},
#define   TCAPOMDEVELRECVREJECTUNRECIDRETRES  (179 % 256)
	{TCAPOMDEVELRECVREJECTUNRECIDRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 8}},
#define   TCAPOMDEVELRECVREJECTUNEXPRETRES  (180 % 256)
	{TCAPOMDEVELRECVREJECTUNEXPRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 9}},
#define   TCAPOMDEVELRECVREJECTUNRECIDRETERR  (181 % 256)
	{TCAPOMDEVELRECVREJECTUNRECIDRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 10}},
#define   TCAPOMDEVELRECVREJECTUNEXPRETERR  (182 % 256)
	{TCAPOMDEVELRECVREJECTUNEXPRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 11}},
#define   TCAPOMDEVELRECVUSRREJDUPINVOKEID  (183 % 256)
	{TCAPOMDEVELRECVUSRREJDUPINVOKEID, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 12}},
#define   TCAPOMDEVELRECVUSRREJUNRECOPER  (184 % 256)
	{TCAPOMDEVELRECVUSRREJUNRECOPER, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 13}},
#define   TCAPOMDEVELRECVUSRREJPARMINVOKE  (185 % 256)
	{TCAPOMDEVELRECVUSRREJPARMINVOKE, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 14}},
#define   TCAPOMDEVELRECVUSRREJRELEASING  (186 % 256)
	{TCAPOMDEVELRECVUSRREJRELEASING, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 15}},
#define   TCAPOMDEVELRECVUSRREJUNEXPLINKRESP  (187 % 256)
	{TCAPOMDEVELRECVUSRREJUNEXPLINKRESP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 16}},
#define   TCAPOMDEVELRECVUSRREJUNEXPLINKOPER  (188 % 256)
	{TCAPOMDEVELRECVUSRREJUNEXPLINKOPER, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 17}},
#define   TCAPOMDEVELRECVUSRREJUNRECERROR  (189 % 256)
	{TCAPOMDEVELRECVUSRREJUNRECERROR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 18}},
#define   TCAPOMDEVELRECVUSRREJUNEXPERROR  (190 % 256)
	{TCAPOMDEVELRECVUSRREJUNEXPERROR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 19}},
#define   TCAPOMDEVELRECVUSRREJPARMRETRESULT  (191 % 256)
	{TCAPOMDEVELRECVUSRREJPARMRETRESULT, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 20}},
#define   TCAPOMDEVELRECVUSRREJPARMRETERROR  (192 % 256)
	{TCAPOMDEVELRECVUSRREJPARMRETERROR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 21}},
#define   TCAPOMDEVELRECV5MINVALIDINTERVALS  (193 % 256)
	{TCAPOMDEVELRECV5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 22}},
#define   TCAPOMDEVELRECV15MINVALIDINTERVALS  (194 % 256)
	{TCAPOMDEVELRECV15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 23}},
#define   TCAPOMDEVELRECVCURRENTPABORTMESSAGETYPE  (198 % 256)
	{TCAPOMDEVELRECVCURRENTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 1}},
#define   TCAPOMDEVELRECVCURRENTPABORTINCORRECTTP  (199 % 256)
	{TCAPOMDEVELRECVCURRENTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 2}},
#define   TCAPOMDEVELRECVCURRENTPABORTBADTP  (200 % 256)
	{TCAPOMDEVELRECVCURRENTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 3}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECCOMP  (201 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 4}},
#define   TCAPOMDEVELRECVCURRENTREJECTMISTYPECOMP  (202 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 5}},
#define   TCAPOMDEVELRECVCURRENTREJECTBADCOMPSTRUCT  (203 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 6}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECLINKID  (204 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 7}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETRES  (205 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 8}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNEXPRETRES  (206 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 9}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETERR  (207 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 10}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNEXPRETERR  (208 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 11}},
#define   TCAPOMDEVELRECVCURRENTUSRREJDUPINVOKEID  (209 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 12}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNRECOPER  (210 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 13}},
#define   TCAPOMDEVELRECVCURRENTUSRREJPARMINVOKE  (211 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 14}},
#define   TCAPOMDEVELRECVCURRENTUSRREJRELEASING  (212 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 15}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKRESP  (213 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 16}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKOPER  (214 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 17}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNRECERROR  (215 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 18}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNEXPERROR  (216 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 19}},
#define   TCAPOMDEVELRECVCURRENTUSRREJPARMRETRESULT  (217 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 20}},
#define   TCAPOMDEVELRECVCURRENTUSRREJPARMRETERROR  (218 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 21}},
#define   TCAPOMDEVELRECV5MININTPABORTMESSAGETYPE  (223 % 256)
	{TCAPOMDEVELRECV5MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 1}},
#define   TCAPOMDEVELRECV5MININTPABORTINCORRECTTP  (224 % 256)
	{TCAPOMDEVELRECV5MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 2}},
#define   TCAPOMDEVELRECV5MININTPABORTBADTP  (225 % 256)
	{TCAPOMDEVELRECV5MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 3}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECCOMP  (226 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 4}},
#define   TCAPOMDEVELRECV5MININTREJECTMISTYPECOMP  (227 % 256)
	{TCAPOMDEVELRECV5MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 5}},
#define   TCAPOMDEVELRECV5MININTREJECTBADCOMPSTRUCT  (228 % 256)
	{TCAPOMDEVELRECV5MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 6}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECLINKID  (229 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 7}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECIDRETRES  (230 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 8}},
#define   TCAPOMDEVELRECV5MININTREJECTUNEXPRETRES  (231 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 9}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECIDRETERR  (232 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 10}},
#define   TCAPOMDEVELRECV5MININTREJECTUNEXPRETERR  (233 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 11}},
#define   TCAPOMDEVELRECV5MININTUSRREJDUPINVOKEID  (234 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 12}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNRECOPER  (235 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 13}},
#define   TCAPOMDEVELRECV5MININTUSRREJPARMINVOKE  (236 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 14}},
#define   TCAPOMDEVELRECV5MININTUSRREJRELEASING  (237 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 15}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKRESP  (238 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 16}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKOPER  (239 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 17}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNRECERROR  (240 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 18}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNEXPERROR  (241 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 19}},
#define   TCAPOMDEVELRECV5MININTUSRREJPARMRETRESULT  (242 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 20}},
#define   TCAPOMDEVELRECV5MININTUSRREJPARMRETERROR  (243 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 21}},
#define   TCAPOMDEVELRECV15MININTPABORTMESSAGETYPE  (248 % 256)
	{TCAPOMDEVELRECV15MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 1}},
#define   TCAPOMDEVELRECV15MININTPABORTINCORRECTTP  (249 % 256)
	{TCAPOMDEVELRECV15MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 2}},
#define   TCAPOMDEVELRECV15MININTPABORTBADTP  (250 % 256)
	{TCAPOMDEVELRECV15MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 3}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECCOMP  (251 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 4}},
#define   TCAPOMDEVELRECV15MININTREJECTMISTYPECOMP  (252 % 256)
	{TCAPOMDEVELRECV15MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 5}},
#define   TCAPOMDEVELRECV15MININTREJECTBADCOMPSTRUCT  (253 % 256)
	{TCAPOMDEVELRECV15MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 6}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECLINKID  (254 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 7}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECIDRETRES  (255 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 8}},
#define   TCAPOMDEVELRECV15MININTREJECTUNEXPRETRES  (256 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 9}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECIDRETERR  (257 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 10}},
#define   TCAPOMDEVELRECV15MININTREJECTUNEXPRETERR  (258 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 11}},
#define   TCAPOMDEVELRECV15MININTUSRREJDUPINVOKEID  (259 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 12}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNRECOPER  (260 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 13}},
#define   TCAPOMDEVELRECV15MININTUSRREJPARMINVOKE  (261 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 14}},
#define   TCAPOMDEVELRECV15MININTUSRREJRELEASING  (262 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 15}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKRESP  (263 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 16}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKOPER  (264 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 17}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNRECERROR  (265 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 18}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNEXPERROR  (266 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 19}},
#define   TCAPOMDEVELRECV15MININTUSRREJPARMRETRESULT  (267 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 20}},
#define   TCAPOMDEVELRECV15MININTUSRREJPARMRETERROR  (268 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 21}},
#define   TCAPOMDEVELSENTPABORTMESSAGETYPE  (272 % 256)
	{TCAPOMDEVELSENTPABORTMESSAGETYPE, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 1}},
#define   TCAPOMDEVELSENTPABORTINCORRECTTP  (273 % 256)
	{TCAPOMDEVELSENTPABORTINCORRECTTP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 2}},
#define   TCAPOMDEVELSENTPABORTBADTP  (274 % 256)
	{TCAPOMDEVELSENTPABORTBADTP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 3}},
#define   TCAPOMDEVELSENTREJECTUNRECCOMP  (275 % 256)
	{TCAPOMDEVELSENTREJECTUNRECCOMP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 4}},
#define   TCAPOMDEVELSENTREJECTMISTYPECOMP  (276 % 256)
	{TCAPOMDEVELSENTREJECTMISTYPECOMP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 5}},
#define   TCAPOMDEVELSENTREJECTBADCOMPSTRUCT  (277 % 256)
	{TCAPOMDEVELSENTREJECTBADCOMPSTRUCT, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 6}},
#define   TCAPOMDEVELSENTREJECTUNRECLINKID  (278 % 256)
	{TCAPOMDEVELSENTREJECTUNRECLINKID, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 7}},
#define   TCAPOMDEVELSENTREJECTUNRECIDRETRES  (279 % 256)
	{TCAPOMDEVELSENTREJECTUNRECIDRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 8}},
#define   TCAPOMDEVELSENTREJECTUNEXPRETRES  (280 % 256)
	{TCAPOMDEVELSENTREJECTUNEXPRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 9}},
#define   TCAPOMDEVELSENTREJECTUNRECIDRETERR  (281 % 256)
	{TCAPOMDEVELSENTREJECTUNRECIDRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 10}},
#define   TCAPOMDEVELSENTREJECTUNEXPRETERR  (282 % 256)
	{TCAPOMDEVELSENTREJECTUNEXPRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 11}},
#define   TCAPOMDEVELSENTUSRREJDUPINVOKEID  (283 % 256)
	{TCAPOMDEVELSENTUSRREJDUPINVOKEID, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 12}},
#define   TCAPOMDEVELSENTUSRREJUNRECOPER  (284 % 256)
	{TCAPOMDEVELSENTUSRREJUNRECOPER, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 13}},
#define   TCAPOMDEVELSENTUSRREJPARMINVOKE  (285 % 256)
	{TCAPOMDEVELSENTUSRREJPARMINVOKE, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 14}},
#define   TCAPOMDEVELSENTUSRREJRELEASING  (286 % 256)
	{TCAPOMDEVELSENTUSRREJRELEASING, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 15}},
#define   TCAPOMDEVELSENTUSRREJUNEXPLINKRESP  (287 % 256)
	{TCAPOMDEVELSENTUSRREJUNEXPLINKRESP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 16}},
#define   TCAPOMDEVELSENTUSRREJUNEXPLINKOPER  (288 % 256)
	{TCAPOMDEVELSENTUSRREJUNEXPLINKOPER, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 17}},
#define   TCAPOMDEVELSENTUSRREJUNRECERROR  (289 % 256)
	{TCAPOMDEVELSENTUSRREJUNRECERROR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 18}},
#define   TCAPOMDEVELSENTUSRREJUNEXPERROR  (290 % 256)
	{TCAPOMDEVELSENTUSRREJUNEXPERROR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 19}},
#define   TCAPOMDEVELSENTUSRREJPARMRETRESULT  (291 % 256)
	{TCAPOMDEVELSENTUSRREJPARMRETRESULT, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 20}},
#define   TCAPOMDEVELSENTUSRREJPARMRETERROR  (292 % 256)
	{TCAPOMDEVELSENTUSRREJPARMRETERROR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 21}},
#define   TCAPOMDEVELSENT5MINVALIDINTERVALS  (293 % 256)
	{TCAPOMDEVELSENT5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 22}},
#define   TCAPOMDEVELSENT15MINVALIDINTERVALS  (294 % 256)
	{TCAPOMDEVELSENT15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 23}},
#define   TCAPOMDEVELSENTCURRENTPABORTMESSAGETYPE  (298 % 256)
	{TCAPOMDEVELSENTCURRENTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 1}},
#define   TCAPOMDEVELSENTCURRENTPABORTINCORRECTTP  (299 % 256)
	{TCAPOMDEVELSENTCURRENTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 2}},
#define   TCAPOMDEVELSENTCURRENTPABORTBADTP  (300 % 256)
	{TCAPOMDEVELSENTCURRENTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 3}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECCOMP  (301 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 4}},
#define   TCAPOMDEVELSENTCURRENTREJECTMISTYPECOMP  (302 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 5}},
#define   TCAPOMDEVELSENTCURRENTREJECTBADCOMPSTRUCT  (303 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 6}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECLINKID  (304 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 7}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETRES  (305 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 8}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNEXPRETRES  (306 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 9}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETERR  (307 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 10}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNEXPRETERR  (308 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 11}},
#define   TCAPOMDEVELSENTCURRENTUSRREJDUPINVOKEID  (309 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 12}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNRECOPER  (310 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 13}},
#define   TCAPOMDEVELSENTCURRENTUSRREJPARMINVOKE  (311 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 14}},
#define   TCAPOMDEVELSENTCURRENTUSRREJRELEASING  (312 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 15}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKRESP  (313 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 16}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKOPER  (314 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 17}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNRECERROR  (315 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 18}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNEXPERROR  (316 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 19}},
#define   TCAPOMDEVELSENTCURRENTUSRREJPARMRETRESULT  (317 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 20}},
#define   TCAPOMDEVELSENTCURRENTUSRREJPARMRETERROR  (318 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 21}},
#define   TCAPOMDEVELSENT5MININTPABORTMESSAGETYPE  (323 % 256)
	{TCAPOMDEVELSENT5MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 1}},
#define   TCAPOMDEVELSENT5MININTPABORTINCORRECTTP  (324 % 256)
	{TCAPOMDEVELSENT5MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 2}},
#define   TCAPOMDEVELSENT5MININTPABORTBADTP  (325 % 256)
	{TCAPOMDEVELSENT5MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 3}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECCOMP  (326 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 4}},
#define   TCAPOMDEVELSENT5MININTREJECTMISTYPECOMP  (327 % 256)
	{TCAPOMDEVELSENT5MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 5}},
#define   TCAPOMDEVELSENT5MININTREJECTBADCOMPSTRUCT  (328 % 256)
	{TCAPOMDEVELSENT5MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 6}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECLINKID  (329 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 7}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECIDRETRES  (330 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 8}},
#define   TCAPOMDEVELSENT5MININTREJECTUNEXPRETRES  (331 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 9}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECIDRETERR  (332 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 10}},
#define   TCAPOMDEVELSENT5MININTREJECTUNEXPRETERR  (333 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 11}},
#define   TCAPOMDEVELSENT5MININTUSRREJDUPINVOKEID  (334 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 12}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNRECOPER  (335 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 13}},
#define   TCAPOMDEVELSENT5MININTUSRREJPARMINVOKE  (336 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 14}},
#define   TCAPOMDEVELSENT5MININTUSRREJRELEASING  (337 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 15}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKRESP  (338 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 16}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKOPER  (339 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 17}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNRECERROR  (340 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 18}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNEXPERROR  (341 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 19}},
#define   TCAPOMDEVELSENT5MININTUSRREJPARMRETRESULT  (342 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 20}},
#define   TCAPOMDEVELSENT5MININTUSRREJPARMRETERROR  (343 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 21}},
#define   TCAPOMDEVELSENT15MININTPABORTMESSAGETYPE  (348 % 256)
	{TCAPOMDEVELSENT15MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 1}},
#define   TCAPOMDEVELSENT15MININTPABORTINCORRECTTP  (349 % 256)
	{TCAPOMDEVELSENT15MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 2}},
#define   TCAPOMDEVELSENT15MININTPABORTBADTP  (350 % 256)
	{TCAPOMDEVELSENT15MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 3}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECCOMP  (351 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 4}},
#define   TCAPOMDEVELSENT15MININTREJECTMISTYPECOMP  (352 % 256)
	{TCAPOMDEVELSENT15MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 5}},
#define   TCAPOMDEVELSENT15MININTREJECTBADCOMPSTRUCT  (353 % 256)
	{TCAPOMDEVELSENT15MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 6}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECLINKID  (354 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 7}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECIDRETRES  (355 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 8}},
#define   TCAPOMDEVELSENT15MININTREJECTUNEXPRETRES  (356 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 9}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECIDRETERR  (357 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 10}},
#define   TCAPOMDEVELSENT15MININTREJECTUNEXPRETERR  (358 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 11}},
#define   TCAPOMDEVELSENT15MININTUSRREJDUPINVOKEID  (359 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 12}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNRECOPER  (360 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 13}},
#define   TCAPOMDEVELSENT15MININTUSRREJPARMINVOKE  (361 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 14}},
#define   TCAPOMDEVELSENT15MININTUSRREJRELEASING  (362 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 15}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKRESP  (363 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 16}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKOPER  (364 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 17}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNRECERROR  (365 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 18}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNEXPERROR  (366 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 19}},
#define   TCAPOMDEVELSENT15MININTUSRREJPARMRETRESULT  (367 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 20}},
#define   TCAPOMDEVELSENT15MININTUSRREJPARMRETERROR  (368 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 21}},
#define   TCAPOM1STANDINTERVALACTIVATE  (369 % 256)
	{TCAPOM1STANDINTERVALACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 1}},
#define   TCAPOM1STANDINTERVALDEACTIVATE  (370 % 256)
	{TCAPOM1STANDINTERVALDEACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 2}},
#define   TCAPOM5MINACTIVATE    (371 % 256)
	{TCAPOM5MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 3}},
#define   TCAPOM5MINDEAACTIVATE  (372 % 256)
	{TCAPOM5MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 4}},
#define   TCAPOM15MINACTIVATE   (373 % 256)
	{TCAPOM15MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 5}},
#define   TCAPOM15MINDEAACTIVATE  (374 % 256)
	{TCAPOM15MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 6}},
#define   TCAPOMDISCONTINUITYTIME  (376 % 256)
	{TCAPOMDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_tcapOmMIB, 3, {1, 2, 8}},
#define   TCAPOMTIMESTAMP       (377 % 256)
	{TCAPOMTIMESTAMP, ASN_TIMETICKS, RONLY, var_tcapOmMIB, 3, {1, 2, 9}},
#define   TCAPOM5MINMAXINTERVALS  (378 % 256)
	{TCAPOM5MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_tcapOmMIB, 3, {1, 2, 10}},
#define   TCAPOM15MINMAXINTERVALS  (379 % 256)
	{TCAPOM15MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_tcapOmMIB, 3, {1, 2, 11}},
};

/* (L = length of the oidsuffix) */
struct tcapOmMIB_data *tcapOmMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *tcapOmNodeTableStorage = NULL;
struct header_complex_index *tcapOmNodeCurrentTableStorage = NULL;
struct header_complex_index *tcapOmNode5minIntTableStorage = NULL;
struct header_complex_index *tcapOmNode15minIntTableStorage = NULL;
struct header_complex_index *tcapOmMsgsTableStorage = NULL;
struct header_complex_index *tcapOmMsgsCurrentTableStorage = NULL;
struct header_complex_index *tcapOmMsgs5minIntTableStorage = NULL;
struct header_complex_index *tcapOmMsgs15minIntTableStorage = NULL;
struct header_complex_index *tcapOmAETableStorage = NULL;
struct header_complex_index *tcapOmAECurrentTableStorage = NULL;
struct header_complex_index *tcapOmAE5minIntTableStorage = NULL;
struct header_complex_index *tcapOmAE15minIntTableStorage = NULL;
struct header_complex_index *tcapOmTcTableStorage = NULL;
struct header_complex_index *tcapOmTcCurrentTableStorage = NULL;
struct header_complex_index *tcapOmTc5minIntTableStorage = NULL;
struct header_complex_index *tcapOmTc15minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecvTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecvCurrentTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecv5minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecv15minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelSentTableStorage = NULL;
struct header_complex_index *tcapOmDevelSentCurrentTableStorage = NULL;
struct header_complex_index *tcapOmDevelSent5minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelSent15minIntTableStorage = NULL;

/*
 * init_tcapOmMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_tcapOmMIB(void)
{
	DEBUGMSGTL(("tcapOmMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("tcapOmMIB", tcapOmMIB_variables, variable7, tcapOmMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_tcapOmMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("tcapOmMIB", parse_tcapOmMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNodeTable", parse_tcapOmNodeTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNodeCurrentTable", parse_tcapOmNodeCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNode5minIntTable", parse_tcapOmNode5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNode15minIntTable", parse_tcapOmNode15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgsTable", parse_tcapOmMsgsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgsCurrentTable", parse_tcapOmMsgsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgs5minIntTable", parse_tcapOmMsgs5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgs15minIntTable", parse_tcapOmMsgs15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAETable", parse_tcapOmAETable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAECurrentTable", parse_tcapOmAECurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAE5minIntTable", parse_tcapOmAE5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAE15minIntTable", parse_tcapOmAE15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTcTable", parse_tcapOmTcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTcCurrentTable", parse_tcapOmTcCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTc5minIntTable", parse_tcapOmTc5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTc15minIntTable", parse_tcapOmTc15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecvTable", parse_tcapOmDevelRecvTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecvCurrentTable", parse_tcapOmDevelRecvCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecv5minIntTable", parse_tcapOmDevelRecv5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecv15minIntTable", parse_tcapOmDevelRecv15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSentTable", parse_tcapOmDevelSentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSentCurrentTable", parse_tcapOmDevelSentCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSent5minIntTable", parse_tcapOmDevelSent5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSent15minIntTable", parse_tcapOmDevelSent15minIntTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNodeTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNodeCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNode5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNode15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgs5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgs15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAECurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAE5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAE15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTcCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTc5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTc15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecvTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecvCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecv5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecv15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSentCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSent5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSent15minIntTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
}

/*
 * deinit_tcapOmMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_tcapOmMIB(void)
{
	DEBUGMSGTL(("tcapOmMIB", "deinitializating...  "));
	unregister_mib(tcapOmMIB_variables_oid, sizeof(tcapOmMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("tcapOmMIB");
	snmpd_unregister_config_handler("tcapOmNodeTable");
	snmpd_unregister_config_handler("tcapOmNodeCurrentTable");
	snmpd_unregister_config_handler("tcapOmNode5minIntTable");
	snmpd_unregister_config_handler("tcapOmNode15minIntTable");
	snmpd_unregister_config_handler("tcapOmMsgsTable");
	snmpd_unregister_config_handler("tcapOmMsgsCurrentTable");
	snmpd_unregister_config_handler("tcapOmMsgs5minIntTable");
	snmpd_unregister_config_handler("tcapOmMsgs15minIntTable");
	snmpd_unregister_config_handler("tcapOmAETable");
	snmpd_unregister_config_handler("tcapOmAECurrentTable");
	snmpd_unregister_config_handler("tcapOmAE5minIntTable");
	snmpd_unregister_config_handler("tcapOmAE15minIntTable");
	snmpd_unregister_config_handler("tcapOmTcTable");
	snmpd_unregister_config_handler("tcapOmTcCurrentTable");
	snmpd_unregister_config_handler("tcapOmTc5minIntTable");
	snmpd_unregister_config_handler("tcapOmTc15minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelRecvTable");
	snmpd_unregister_config_handler("tcapOmDevelRecvCurrentTable");
	snmpd_unregister_config_handler("tcapOmDevelRecv5minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelRecv15minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelSentTable");
	snmpd_unregister_config_handler("tcapOmDevelSentCurrentTable");
	snmpd_unregister_config_handler("tcapOmDevelSent5minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelSent15minIntTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
}

int
term_tcapOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_tcapOmMIB();
	return 0;
}

/**
 * @fn struct tcapOmMIB_data *tcapOmMIB_create(void)
 * @brief create a fresh data structure representing scalars in tcapOmMIB.
 * Creates a new tcapOmMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in tcapOmMIB.
 */
struct tcapOmMIB_data *
tcapOmMIB_create(void)
{
	struct tcapOmMIB_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMIB_data);

	DEBUGMSGTL(("tcapOmMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->tcapOm5MinMaxIntervals = 96;
		StorageNew->tcapOm15MinMaxIntervals = 96;

	}
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int tcapOmMIB_destroy(struct tcapOmMIB_data **thedata)
 * @brief delete a scalars structure from tcapOmMIB.
 * @param thedata pointer to the data structure in tcapOmMIB.
 * Frees scalars that were previously removed from tcapOmMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmMIB_destroy(struct tcapOmMIB_data **thedata)
{
	struct tcapOmMIB_data *StorageDel;

	DEBUGMSGTL(("tcapOmMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->tcapOm1stAndIntervalActivate);
		StorageDel->tcapOm1stAndIntervalActivateLen = 0;
		SNMP_FREE(StorageDel->tcapOm1stAndIntervalDeactivate);
		StorageDel->tcapOm1stAndIntervalDeactivateLen = 0;
		SNMP_FREE(StorageDel->tcapOm5MinActivate);
		StorageDel->tcapOm5MinActivateLen = 0;
		SNMP_FREE(StorageDel->tcapOm5MinDeaActivate);
		StorageDel->tcapOm5MinDeaActivateLen = 0;
		SNMP_FREE(StorageDel->tcapOm15MinActivate);
		StorageDel->tcapOm15MinActivateLen = 0;
		SNMP_FREE(StorageDel->tcapOm15MinDeaActivate);
		StorageDel->tcapOm15MinDeaActivateLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMIB_add(struct tcapOmMIB_data *thedata)
 * @param thedata the structure representing tcapOmMIB scalars.
 * @brief adds node to the tcapOmMIB scalar data set.
 * Adds a scalar structure to the tcapOmMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
tcapOmMIB_add(struct tcapOmMIB_data *thedata)
{
	DEBUGMSGTL(("tcapOmMIB", "adding data...  "));
	tcapOmMIBStorage = thedata;
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmMIB entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_tcapOmMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMIB_data *StorageTmp = tcapOmMIB_create();

	DEBUGMSGTL(("tcapOmMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
#if 0
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->tcapOmDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->tcapOmTimeStamp, &tmpsize);
#endif
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOm5MinMaxIntervals, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOm15MinMaxIntervals, &tmpsize);
	tcapOmMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
}

/*
 * store_tcapOmMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMIB_data *StorageTmp;

	DEBUGMSGTL(("tcapOmMIB", "storing data...  "));
	refresh_tcapOmMIB();
	if ((StorageTmp = tcapOmMIBStorage) == NULL) {
		DEBUGMSGTL(("tcapOmMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "tcapOmMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
#if 0
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->tcapOmDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->tcapOmTimeStamp, &tmpsize);
#endif
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOm5MinMaxIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOm15MinMaxIntervals, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_tcapOmMIB(void)
 * @brief refresh the scalar values of tcapOmMIB.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_tcapOmMIB(void)
{
	if (tcapOmMIBStorage == NULL) {
		struct tcapOmMIB_data *StorageNew;

		if ((StorageNew = tcapOmMIB_create()) == NULL)
			return;
		tcapOmMIBStorage = StorageNew;
		tcapOmMIB_refresh = 1;
	}
	if (tcapOmMIB_refresh == 0)
		return;
	tcapOmMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
* @fn u_char * var_tcapOmMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
* @param vp a pointer to the entry in the variables table for the requested variable.
* @param name the object identifier for which to find.
* @param length the length of the object identifier.
* @param exact whether the name is exact.
* @param var_len a pointer to the length of the representation of the object.
* @param write_method a pointer to a write method for the object.
* @brief locate variables in tcapOmMIB.
* This function returns a pointer to a memory area that is static across the request that contains
* the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
* GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
* telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
* overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
* writing.  Write-only objects can be effected in this way.
*/
u_char *
var_tcapOmMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_tcapOmMIB();
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOM1STANDINTERVALACTIVATE:
		*write_method = write_tcapOm1stAndIntervalActivate;
		*var_len = 0;	/* write-only */
		return (u_char *) NULL;	/* write-only */
	case TCAPOM1STANDINTERVALDEACTIVATE:
		*write_method = write_tcapOm1stAndIntervalDeactivate;
		*var_len = 0;	/* write-only */
		return (u_char *) NULL;	/* write-only */
	case TCAPOM5MINACTIVATE:
		*write_method = write_tcapOm5MinActivate;
		*var_len = 0;	/* write-only */
		return (u_char *) NULL;	/* write-only */
	case TCAPOM5MINDEAACTIVATE:
		*write_method = write_tcapOm5MinDeaActivate;
		*var_len = 0;	/* write-only */
		return (u_char *) NULL;	/* write-only */
	case TCAPOM15MINACTIVATE:
		*write_method = write_tcapOm15MinActivate;
		*var_len = 0;	/* write-only */
		return (u_char *) NULL;	/* write-only */
	case TCAPOM15MINDEAACTIVATE:
		*write_method = write_tcapOm15MinDeaActivate;
		*var_len = 0;	/* write-only */
		return (u_char *) NULL;	/* write-only */
	case TCAPOMDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDiscontinuityTime);
		return (u_char *) &StorageTmp->tcapOmDiscontinuityTime;
	case TCAPOMTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTimeStamp);
		return (u_char *) &StorageTmp->tcapOmTimeStamp;
	case TCAPOM5MINMAXINTERVALS:
		*write_method = write_tcapOm5MinMaxIntervals;
		*var_len = sizeof(StorageTmp->tcapOm5MinMaxIntervals);
		return (u_char *) &StorageTmp->tcapOm5MinMaxIntervals;
	case TCAPOM15MINMAXINTERVALS:
		*write_method = write_tcapOm15MinMaxIntervals;
		*var_len = sizeof(StorageTmp->tcapOm15MinMaxIntervals);
		return (u_char *) &StorageTmp->tcapOm15MinMaxIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn struct tcapOmNodeTable_data *tcapOmNodeTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmNodeTable table.
 * Creates a new tcapOmNodeTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmNodeTable_data *
tcapOmNodeTable_create(void)
{
	struct tcapOmNodeTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNodeTable_data);

	DEBUGMSGTL(("tcapOmNodeTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmNodeTable_data *tcapOmNodeTable_duplicate(struct tcapOmNodeTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmNodeTable_data *
tcapOmNodeTable_duplicate(struct tcapOmNodeTable_data *thedata)
{
	struct tcapOmNodeTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNodeTable_data);

	DEBUGMSGTL(("tcapOmNodeTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmNodeTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmNodeTable_destroy(struct tcapOmNodeTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmNodeTable_destroy(struct tcapOmNodeTable_data **thedata)
{
	struct tcapOmNodeTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNodeTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNodeTable_add(struct tcapOmNodeTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmNodeTable table data set.
 * Adds a table row structure to the tcapOmNodeTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmNodeTable_add(struct tcapOmNodeTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNodeTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&tcapOmNodeTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNodeTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNodeTable_del(struct tcapOmNodeTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmNodeTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmNodeTable_del(struct tcapOmNodeTable_data *thedata)
{
	struct tcapOmNodeTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNodeTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmNodeTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmNodeTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmNodeTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmNodeTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmNodeTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmNodeTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNodeTable_data *StorageTmp = tcapOmNodeTable_create();

	DEBUGMSGTL(("tcapOmNodeTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeComponentsRecv, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmNode5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmNode15minValidIntervals, &tmpsize);
	tcapOmNodeTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
}

/*
 * store_tcapOmNodeTable(): store configuraiton file for tcapOmNodeTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNodeTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNodeTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNodeTable", "storing data...  "));
	refresh_tcapOmNodeTable();
	(void) tmpsize;
	for (hcindex = tcapOmNodeTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNodeTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNodeTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeComponentsRecv, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmNode5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmNode15minValidIntervals, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmNodeCurrentTable_data *tcapOmNodeCurrentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmNodeCurrentTable table.
 * Creates a new tcapOmNodeCurrentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmNodeCurrentTable_data *
tcapOmNodeCurrentTable_create(void)
{
	struct tcapOmNodeCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNodeCurrentTable_data);

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmNodeCurrentTable_data *tcapOmNodeCurrentTable_duplicate(struct tcapOmNodeCurrentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmNodeCurrentTable_data *
tcapOmNodeCurrentTable_duplicate(struct tcapOmNodeCurrentTable_data *thedata)
{
	struct tcapOmNodeCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNodeCurrentTable_data);

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmNodeCurrentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmNodeCurrentTable_destroy(struct tcapOmNodeCurrentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmNodeCurrentTable_destroy(struct tcapOmNodeCurrentTable_data **thedata)
{
	struct tcapOmNodeCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNodeCurrentTable_add(struct tcapOmNodeCurrentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmNodeCurrentTable table data set.
 * Adds a table row structure to the tcapOmNodeCurrentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmNodeCurrentTable_add(struct tcapOmNodeCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	header_complex_add_data(&tcapOmNodeCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNodeCurrentTable_del(struct tcapOmNodeCurrentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmNodeCurrentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmNodeCurrentTable_del(struct tcapOmNodeCurrentTable_data *thedata)
{
	struct tcapOmNodeCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmNodeCurrentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmNodeCurrentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmNodeCurrentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmNodeCurrentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmNodeCurrentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmNodeCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNodeCurrentTable_data *StorageTmp = tcapOmNodeCurrentTable_create();

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentComponentsRecv, &tmpsize);
	tcapOmNodeCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
}

/*
 * store_tcapOmNodeCurrentTable(): store configuraiton file for tcapOmNodeCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNodeCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNodeCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "storing data...  "));
	refresh_tcapOmNodeCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmNodeCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNodeCurrentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNodeCurrentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentComponentsRecv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmNode5minIntTable_data *tcapOmNode5minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmNode5minIntTable table.
 * Creates a new tcapOmNode5minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmNode5minIntTable_data *
tcapOmNode5minIntTable_create(void)
{
	struct tcapOmNode5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNode5minIntTable_data);

	DEBUGMSGTL(("tcapOmNode5minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmNode5minIntTable_data *tcapOmNode5minIntTable_duplicate(struct tcapOmNode5minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmNode5minIntTable_data *
tcapOmNode5minIntTable_duplicate(struct tcapOmNode5minIntTable_data *thedata)
{
	struct tcapOmNode5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNode5minIntTable_data);

	DEBUGMSGTL(("tcapOmNode5minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmNode5minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmNode5minIntTable_destroy(struct tcapOmNode5minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmNode5minIntTable_destroy(struct tcapOmNode5minIntTable_data **thedata)
{
	struct tcapOmNode5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNode5minIntTable_add(struct tcapOmNode5minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmNode5minIntTable table data set.
 * Adds a table row structure to the tcapOmNode5minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmNode5minIntTable_add(struct tcapOmNode5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmNode5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNode5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNode5minIntTable_del(struct tcapOmNode5minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmNode5minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmNode5minIntTable_del(struct tcapOmNode5minIntTable_data *thedata)
{
	struct tcapOmNode5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmNode5minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmNode5minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmNode5minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmNode5minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmNode5minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmNode5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNode5minIntTable_data *StorageTmp = tcapOmNode5minIntTable_create();

	DEBUGMSGTL(("tcapOmNode5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntComponentsRecv, &tmpsize);
	tcapOmNode5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
}

/*
 * store_tcapOmNode5minIntTable(): store configuraiton file for tcapOmNode5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNode5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNode5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "storing data...  "));
	refresh_tcapOmNode5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmNode5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNode5minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNode5minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntComponentsRecv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmNode15minIntTable_data *tcapOmNode15minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmNode15minIntTable table.
 * Creates a new tcapOmNode15minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmNode15minIntTable_data *
tcapOmNode15minIntTable_create(void)
{
	struct tcapOmNode15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNode15minIntTable_data);

	DEBUGMSGTL(("tcapOmNode15minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmNode15minIntTable_data *tcapOmNode15minIntTable_duplicate(struct tcapOmNode15minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmNode15minIntTable_data *
tcapOmNode15minIntTable_duplicate(struct tcapOmNode15minIntTable_data *thedata)
{
	struct tcapOmNode15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmNode15minIntTable_data);

	DEBUGMSGTL(("tcapOmNode15minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmNode15minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmNode15minIntTable_destroy(struct tcapOmNode15minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmNode15minIntTable_destroy(struct tcapOmNode15minIntTable_data **thedata)
{
	struct tcapOmNode15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNode15minIntTable_add(struct tcapOmNode15minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmNode15minIntTable table data set.
 * Adds a table row structure to the tcapOmNode15minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmNode15minIntTable_add(struct tcapOmNode15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmNode15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNode15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmNode15minIntTable_del(struct tcapOmNode15minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmNode15minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmNode15minIntTable_del(struct tcapOmNode15minIntTable_data *thedata)
{
	struct tcapOmNode15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmNode15minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmNode15minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmNode15minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmNode15minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmNode15minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmNode15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNode15minIntTable_data *StorageTmp = tcapOmNode15minIntTable_create();

	DEBUGMSGTL(("tcapOmNode15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntComponentsRecv, &tmpsize);
	tcapOmNode15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
}

/*
 * store_tcapOmNode15minIntTable(): store configuraiton file for tcapOmNode15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNode15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNode15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "storing data...  "));
	refresh_tcapOmNode15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmNode15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNode15minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNode15minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntComponentsRecv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmMsgsTable_data *tcapOmMsgsTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmMsgsTable table.
 * Creates a new tcapOmMsgsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmMsgsTable_data *
tcapOmMsgsTable_create(void)
{
	struct tcapOmMsgsTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgsTable_data);

	DEBUGMSGTL(("tcapOmMsgsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmMsgsTable_data *tcapOmMsgsTable_duplicate(struct tcapOmMsgsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmMsgsTable_data *
tcapOmMsgsTable_duplicate(struct tcapOmMsgsTable_data *thedata)
{
	struct tcapOmMsgsTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgsTable_data);

	DEBUGMSGTL(("tcapOmMsgsTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmMsgsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmMsgsTable_destroy(struct tcapOmMsgsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmMsgsTable_destroy(struct tcapOmMsgsTable_data **thedata)
{
	struct tcapOmMsgsTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgsTable_add(struct tcapOmMsgsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmMsgsTable table data set.
 * Adds a table row structure to the tcapOmMsgsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmMsgsTable_add(struct tcapOmMsgsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmMessageType */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapOmMessageType, sizeof(thedata->tcapOmMessageType));
	header_complex_add_data(&tcapOmMsgsTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgsTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgsTable_del(struct tcapOmMsgsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmMsgsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmMsgsTable_del(struct tcapOmMsgsTable_data *thedata)
{
	struct tcapOmMsgsTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmMsgsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmMsgsTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmMsgsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmMsgsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmMsgsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmMsgsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgsTable_data *StorageTmp = tcapOmMsgsTable_create();

	DEBUGMSGTL(("tcapOmMsgsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOmMessageType, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmMsgsMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmMsgsMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmMsgs5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmMsgs15minValidIntervals, &tmpsize);
	tcapOmMsgsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
}

/*
 * store_tcapOmMsgsTable(): store configuraiton file for tcapOmMsgsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgsTable", "storing data...  "));
	refresh_tcapOmMsgsTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOmMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmMsgsMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmMsgsMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmMsgs5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmMsgs15minValidIntervals, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmMsgsCurrentTable_data *tcapOmMsgsCurrentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmMsgsCurrentTable table.
 * Creates a new tcapOmMsgsCurrentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmMsgsCurrentTable_data *
tcapOmMsgsCurrentTable_create(void)
{
	struct tcapOmMsgsCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgsCurrentTable_data);

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmMsgsCurrentTable_data *tcapOmMsgsCurrentTable_duplicate(struct tcapOmMsgsCurrentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmMsgsCurrentTable_data *
tcapOmMsgsCurrentTable_duplicate(struct tcapOmMsgsCurrentTable_data *thedata)
{
	struct tcapOmMsgsCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgsCurrentTable_data);

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmMsgsCurrentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmMsgsCurrentTable_destroy(struct tcapOmMsgsCurrentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmMsgsCurrentTable_destroy(struct tcapOmMsgsCurrentTable_data **thedata)
{
	struct tcapOmMsgsCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgsCurrentTable_add(struct tcapOmMsgsCurrentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmMsgsCurrentTable table data set.
 * Adds a table row structure to the tcapOmMsgsCurrentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmMsgsCurrentTable_add(struct tcapOmMsgsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmMessageType */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapOmMessageType, sizeof(thedata->tcapOmMessageType));
	header_complex_add_data(&tcapOmMsgsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgsCurrentTable_del(struct tcapOmMsgsCurrentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmMsgsCurrentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmMsgsCurrentTable_del(struct tcapOmMsgsCurrentTable_data *thedata)
{
	struct tcapOmMsgsCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmMsgsCurrentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmMsgsCurrentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmMsgsCurrentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmMsgsCurrentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmMsgsCurrentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmMsgsCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgsCurrentTable_data *StorageTmp = tcapOmMsgsCurrentTable_create();

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOmMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgsCurrentMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgsCurrentMessagesRecv, &tmpsize);
	tcapOmMsgsCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
}

/*
 * store_tcapOmMsgsCurrentTable(): store configuraiton file for tcapOmMsgsCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "storing data...  "));
	refresh_tcapOmMsgsCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgsCurrentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgsCurrentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOmMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgsCurrentMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgsCurrentMessagesRecv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmMsgs5minIntTable_data *tcapOmMsgs5minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmMsgs5minIntTable table.
 * Creates a new tcapOmMsgs5minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmMsgs5minIntTable_data *
tcapOmMsgs5minIntTable_create(void)
{
	struct tcapOmMsgs5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgs5minIntTable_data);

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmMsgs5minIntTable_data *tcapOmMsgs5minIntTable_duplicate(struct tcapOmMsgs5minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmMsgs5minIntTable_data *
tcapOmMsgs5minIntTable_duplicate(struct tcapOmMsgs5minIntTable_data *thedata)
{
	struct tcapOmMsgs5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgs5minIntTable_data);

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmMsgs5minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmMsgs5minIntTable_destroy(struct tcapOmMsgs5minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmMsgs5minIntTable_destroy(struct tcapOmMsgs5minIntTable_data **thedata)
{
	struct tcapOmMsgs5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgs5minIntTable_add(struct tcapOmMsgs5minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmMsgs5minIntTable table data set.
 * Adds a table row structure to the tcapOmMsgs5minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmMsgs5minIntTable_add(struct tcapOmMsgs5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmMessageType */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapOmMessageType, sizeof(thedata->tcapOmMessageType));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmMsgs5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgs5minIntTable_del(struct tcapOmMsgs5minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmMsgs5minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmMsgs5minIntTable_del(struct tcapOmMsgs5minIntTable_data *thedata)
{
	struct tcapOmMsgs5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmMsgs5minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmMsgs5minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmMsgs5minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmMsgs5minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmMsgs5minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmMsgs5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgs5minIntTable_data *StorageTmp = tcapOmMsgs5minIntTable_create();

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOmMessageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs5minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs5minIntMessagesRecv, &tmpsize);
	tcapOmMsgs5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
}

/*
 * store_tcapOmMsgs5minIntTable(): store configuraiton file for tcapOmMsgs5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgs5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgs5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "storing data...  "));
	refresh_tcapOmMsgs5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgs5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgs5minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgs5minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOmMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs5minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs5minIntMessagesRecv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmMsgs15minIntTable_data *tcapOmMsgs15minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmMsgs15minIntTable table.
 * Creates a new tcapOmMsgs15minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmMsgs15minIntTable_data *
tcapOmMsgs15minIntTable_create(void)
{
	struct tcapOmMsgs15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgs15minIntTable_data);

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmMsgs15minIntTable_data *tcapOmMsgs15minIntTable_duplicate(struct tcapOmMsgs15minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmMsgs15minIntTable_data *
tcapOmMsgs15minIntTable_duplicate(struct tcapOmMsgs15minIntTable_data *thedata)
{
	struct tcapOmMsgs15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmMsgs15minIntTable_data);

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmMsgs15minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmMsgs15minIntTable_destroy(struct tcapOmMsgs15minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmMsgs15minIntTable_destroy(struct tcapOmMsgs15minIntTable_data **thedata)
{
	struct tcapOmMsgs15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgs15minIntTable_add(struct tcapOmMsgs15minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmMsgs15minIntTable table data set.
 * Adds a table row structure to the tcapOmMsgs15minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmMsgs15minIntTable_add(struct tcapOmMsgs15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmMessageType */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapOmMessageType, sizeof(thedata->tcapOmMessageType));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmMsgs15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmMsgs15minIntTable_del(struct tcapOmMsgs15minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmMsgs15minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmMsgs15minIntTable_del(struct tcapOmMsgs15minIntTable_data *thedata)
{
	struct tcapOmMsgs15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmMsgs15minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmMsgs15minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmMsgs15minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmMsgs15minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmMsgs15minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmMsgs15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgs15minIntTable_data *StorageTmp = tcapOmMsgs15minIntTable_create();

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOmMessageType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs15minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs15minIntMessagesRecv, &tmpsize);
	tcapOmMsgs15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
}

/*
 * store_tcapOmMsgs15minIntTable(): store configuraiton file for tcapOmMsgs15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgs15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgs15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "storing data...  "));
	refresh_tcapOmMsgs15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgs15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgs15minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgs15minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOmMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs15minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs15minIntMessagesRecv, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmAETable_data *tcapOmAETable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmAETable table.
 * Creates a new tcapOmAETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmAETable_data *
tcapOmAETable_create(void)
{
	struct tcapOmAETable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAETable_data);

	DEBUGMSGTL(("tcapOmAETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmAETable_data *tcapOmAETable_duplicate(struct tcapOmAETable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmAETable_data *
tcapOmAETable_duplicate(struct tcapOmAETable_data *thedata)
{
	struct tcapOmAETable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAETable_data);

	DEBUGMSGTL(("tcapOmAETable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmAETable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmAETable_destroy(struct tcapOmAETable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmAETable_destroy(struct tcapOmAETable_data **thedata)
{
	struct tcapOmAETable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAETable_add(struct tcapOmAETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmAETable table data set.
 * Adds a table row structure to the tcapOmAETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmAETable_add(struct tcapOmAETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	header_complex_add_data(&tcapOmAETableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAETable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAETable_del(struct tcapOmAETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmAETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmAETable_del(struct tcapOmAETable_data *thedata)
{
	struct tcapOmAETable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmAETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmAETableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmAETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmAETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmAETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmAETable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAETable_data *StorageTmp = tcapOmAETable_create();

	DEBUGMSGTL(("tcapOmAETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAENewTransactions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAENotUsed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAECummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEThresholdExceeded, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmAE5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmAE15minValidIntervals, &tmpsize);
	tcapOmAETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
}

/*
 * store_tcapOmAETable(): store configuraiton file for tcapOmAETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAETable", "storing data...  "));
	refresh_tcapOmAETable();
	(void) tmpsize;
	for (hcindex = tcapOmAETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAENewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAENotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAECummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEThresholdExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmAE5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmAE15minValidIntervals, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmAECurrentTable_data *tcapOmAECurrentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmAECurrentTable table.
 * Creates a new tcapOmAECurrentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmAECurrentTable_data *
tcapOmAECurrentTable_create(void)
{
	struct tcapOmAECurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAECurrentTable_data);

	DEBUGMSGTL(("tcapOmAECurrentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmAECurrentTable_data *tcapOmAECurrentTable_duplicate(struct tcapOmAECurrentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmAECurrentTable_data *
tcapOmAECurrentTable_duplicate(struct tcapOmAECurrentTable_data *thedata)
{
	struct tcapOmAECurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAECurrentTable_data);

	DEBUGMSGTL(("tcapOmAECurrentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmAECurrentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmAECurrentTable_destroy(struct tcapOmAECurrentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmAECurrentTable_destroy(struct tcapOmAECurrentTable_data **thedata)
{
	struct tcapOmAECurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAECurrentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAECurrentTable_add(struct tcapOmAECurrentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmAECurrentTable table data set.
 * Adds a table row structure to the tcapOmAECurrentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmAECurrentTable_add(struct tcapOmAECurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAECurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	header_complex_add_data(&tcapOmAECurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAECurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAECurrentTable_del(struct tcapOmAECurrentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmAECurrentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmAECurrentTable_del(struct tcapOmAECurrentTable_data *thedata)
{
	struct tcapOmAECurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAECurrentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmAECurrentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmAECurrentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmAECurrentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmAECurrentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmAECurrentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmAECurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAECurrentTable_data *StorageTmp = tcapOmAECurrentTable_create();

	DEBUGMSGTL(("tcapOmAECurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentNewTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentCummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentThresholdExceeded, &tmpsize);
	tcapOmAECurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
}

/*
 * store_tcapOmAECurrentTable(): store configuraiton file for tcapOmAECurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAECurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAECurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAECurrentTable", "storing data...  "));
	refresh_tcapOmAECurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmAECurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAECurrentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAECurrentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentNewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentCummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentThresholdExceeded, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmAE5minIntTable_data *tcapOmAE5minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmAE5minIntTable table.
 * Creates a new tcapOmAE5minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmAE5minIntTable_data *
tcapOmAE5minIntTable_create(void)
{
	struct tcapOmAE5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAE5minIntTable_data);

	DEBUGMSGTL(("tcapOmAE5minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmAE5minIntTable_data *tcapOmAE5minIntTable_duplicate(struct tcapOmAE5minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmAE5minIntTable_data *
tcapOmAE5minIntTable_duplicate(struct tcapOmAE5minIntTable_data *thedata)
{
	struct tcapOmAE5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAE5minIntTable_data);

	DEBUGMSGTL(("tcapOmAE5minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmAE5minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmAE5minIntTable_destroy(struct tcapOmAE5minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmAE5minIntTable_destroy(struct tcapOmAE5minIntTable_data **thedata)
{
	struct tcapOmAE5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAE5minIntTable_add(struct tcapOmAE5minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmAE5minIntTable table data set.
 * Adds a table row structure to the tcapOmAE5minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmAE5minIntTable_add(struct tcapOmAE5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmAE5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAE5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAE5minIntTable_del(struct tcapOmAE5minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmAE5minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmAE5minIntTable_del(struct tcapOmAE5minIntTable_data *thedata)
{
	struct tcapOmAE5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmAE5minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmAE5minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmAE5minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmAE5minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmAE5minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmAE5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAE5minIntTable_data *StorageTmp = tcapOmAE5minIntTable_create();

	DEBUGMSGTL(("tcapOmAE5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntNewTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntCummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntThresholdExceeded, &tmpsize);
	tcapOmAE5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
}

/*
 * store_tcapOmAE5minIntTable(): store configuraiton file for tcapOmAE5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAE5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAE5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "storing data...  "));
	refresh_tcapOmAE5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmAE5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAE5minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAE5minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntNewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntCummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntThresholdExceeded, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmAE15minIntTable_data *tcapOmAE15minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmAE15minIntTable table.
 * Creates a new tcapOmAE15minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmAE15minIntTable_data *
tcapOmAE15minIntTable_create(void)
{
	struct tcapOmAE15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAE15minIntTable_data);

	DEBUGMSGTL(("tcapOmAE15minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmAE15minIntTable_data *tcapOmAE15minIntTable_duplicate(struct tcapOmAE15minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmAE15minIntTable_data *
tcapOmAE15minIntTable_duplicate(struct tcapOmAE15minIntTable_data *thedata)
{
	struct tcapOmAE15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmAE15minIntTable_data);

	DEBUGMSGTL(("tcapOmAE15minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmAE15minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmAE15minIntTable_destroy(struct tcapOmAE15minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmAE15minIntTable_destroy(struct tcapOmAE15minIntTable_data **thedata)
{
	struct tcapOmAE15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAE15minIntTable_add(struct tcapOmAE15minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmAE15minIntTable table data set.
 * Adds a table row structure to the tcapOmAE15minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmAE15minIntTable_add(struct tcapOmAE15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmAE15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAE15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmAE15minIntTable_del(struct tcapOmAE15minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmAE15minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmAE15minIntTable_del(struct tcapOmAE15minIntTable_data *thedata)
{
	struct tcapOmAE15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmAE15minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmAE15minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmAE15minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmAE15minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmAE15minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmAE15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAE15minIntTable_data *StorageTmp = tcapOmAE15minIntTable_create();

	DEBUGMSGTL(("tcapOmAE15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntNewTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntCummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntThresholdExceeded, &tmpsize);
	tcapOmAE15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
}

/*
 * store_tcapOmAE15minIntTable(): store configuraiton file for tcapOmAE15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAE15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAE15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "storing data...  "));
	refresh_tcapOmAE15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmAE15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAE15minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAE15minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntNewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntCummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntThresholdExceeded, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmTcTable_data *tcapOmTcTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmTcTable table.
 * Creates a new tcapOmTcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmTcTable_data *
tcapOmTcTable_create(void)
{
	struct tcapOmTcTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTcTable_data);

	DEBUGMSGTL(("tcapOmTcTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmTcTable_data *tcapOmTcTable_duplicate(struct tcapOmTcTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmTcTable_data *
tcapOmTcTable_duplicate(struct tcapOmTcTable_data *thedata)
{
	struct tcapOmTcTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTcTable_data);

	DEBUGMSGTL(("tcapOmTcTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmTcTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmTcTable_destroy(struct tcapOmTcTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmTcTable_destroy(struct tcapOmTcTable_data **thedata)
{
	struct tcapOmTcTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTcTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTcTable_add(struct tcapOmTcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmTcTable table data set.
 * Adds a table row structure to the tcapOmTcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmTcTable_add(struct tcapOmTcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	header_complex_add_data(&tcapOmTcTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTcTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTcTable_del(struct tcapOmTcTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmTcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmTcTable_del(struct tcapOmTcTable_data *thedata)
{
	struct tcapOmTcTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTcTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmTcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmTcTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmTcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmTcTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmTcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmTcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTcTable_data *StorageTmp = tcapOmTcTable_create();

	DEBUGMSGTL(("tcapOmTcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcNotUsed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcTpErrors, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmTc5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmTc15minValidIntervals, &tmpsize);
	tcapOmTcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
}

/*
 * store_tcapOmTcTable(): store configuraiton file for tcapOmTcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTcTable", "storing data...  "));
	refresh_tcapOmTcTable();
	(void) tmpsize;
	for (hcindex = tcapOmTcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTcTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcTpErrors, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmTc5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmTc15minValidIntervals, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmTcCurrentTable_data *tcapOmTcCurrentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmTcCurrentTable table.
 * Creates a new tcapOmTcCurrentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmTcCurrentTable_data *
tcapOmTcCurrentTable_create(void)
{
	struct tcapOmTcCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTcCurrentTable_data);

	DEBUGMSGTL(("tcapOmTcCurrentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmTcCurrentTable_data *tcapOmTcCurrentTable_duplicate(struct tcapOmTcCurrentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmTcCurrentTable_data *
tcapOmTcCurrentTable_duplicate(struct tcapOmTcCurrentTable_data *thedata)
{
	struct tcapOmTcCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTcCurrentTable_data);

	DEBUGMSGTL(("tcapOmTcCurrentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmTcCurrentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmTcCurrentTable_destroy(struct tcapOmTcCurrentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmTcCurrentTable_destroy(struct tcapOmTcCurrentTable_data **thedata)
{
	struct tcapOmTcCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTcCurrentTable_add(struct tcapOmTcCurrentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmTcCurrentTable table data set.
 * Adds a table row structure to the tcapOmTcCurrentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmTcCurrentTable_add(struct tcapOmTcCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	header_complex_add_data(&tcapOmTcCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTcCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTcCurrentTable_del(struct tcapOmTcCurrentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmTcCurrentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmTcCurrentTable_del(struct tcapOmTcCurrentTable_data *thedata)
{
	struct tcapOmTcCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmTcCurrentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmTcCurrentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmTcCurrentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmTcCurrentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmTcCurrentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmTcCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTcCurrentTable_data *StorageTmp = tcapOmTcCurrentTable_create();

	DEBUGMSGTL(("tcapOmTcCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentTpErrors, &tmpsize);
	tcapOmTcCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
}

/*
 * store_tcapOmTcCurrentTable(): store configuraiton file for tcapOmTcCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTcCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTcCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "storing data...  "));
	refresh_tcapOmTcCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmTcCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTcCurrentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTcCurrentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentTpErrors, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmTc5minIntTable_data *tcapOmTc5minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmTc5minIntTable table.
 * Creates a new tcapOmTc5minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmTc5minIntTable_data *
tcapOmTc5minIntTable_create(void)
{
	struct tcapOmTc5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTc5minIntTable_data);

	DEBUGMSGTL(("tcapOmTc5minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmTc5minIntTable_data *tcapOmTc5minIntTable_duplicate(struct tcapOmTc5minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmTc5minIntTable_data *
tcapOmTc5minIntTable_duplicate(struct tcapOmTc5minIntTable_data *thedata)
{
	struct tcapOmTc5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTc5minIntTable_data);

	DEBUGMSGTL(("tcapOmTc5minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmTc5minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmTc5minIntTable_destroy(struct tcapOmTc5minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmTc5minIntTable_destroy(struct tcapOmTc5minIntTable_data **thedata)
{
	struct tcapOmTc5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTc5minIntTable_add(struct tcapOmTc5minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmTc5minIntTable table data set.
 * Adds a table row structure to the tcapOmTc5minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmTc5minIntTable_add(struct tcapOmTc5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmTc5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTc5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTc5minIntTable_del(struct tcapOmTc5minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmTc5minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmTc5minIntTable_del(struct tcapOmTc5minIntTable_data *thedata)
{
	struct tcapOmTc5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmTc5minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmTc5minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmTc5minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmTc5minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmTc5minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmTc5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTc5minIntTable_data *StorageTmp = tcapOmTc5minIntTable_create();

	DEBUGMSGTL(("tcapOmTc5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntTpErrors, &tmpsize);
	tcapOmTc5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
}

/*
 * store_tcapOmTc5minIntTable(): store configuraiton file for tcapOmTc5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTc5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTc5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "storing data...  "));
	refresh_tcapOmTc5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmTc5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTc5minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTc5minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntTpErrors, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmTc15minIntTable_data *tcapOmTc15minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmTc15minIntTable table.
 * Creates a new tcapOmTc15minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmTc15minIntTable_data *
tcapOmTc15minIntTable_create(void)
{
	struct tcapOmTc15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTc15minIntTable_data);

	DEBUGMSGTL(("tcapOmTc15minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmTc15minIntTable_data *tcapOmTc15minIntTable_duplicate(struct tcapOmTc15minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmTc15minIntTable_data *
tcapOmTc15minIntTable_duplicate(struct tcapOmTc15minIntTable_data *thedata)
{
	struct tcapOmTc15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmTc15minIntTable_data);

	DEBUGMSGTL(("tcapOmTc15minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmTc15minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmTc15minIntTable_destroy(struct tcapOmTc15minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmTc15minIntTable_destroy(struct tcapOmTc15minIntTable_data **thedata)
{
	struct tcapOmTc15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTc15minIntTable_add(struct tcapOmTc15minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmTc15minIntTable table data set.
 * Adds a table row structure to the tcapOmTc15minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmTc15minIntTable_add(struct tcapOmTc15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmTc15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTc15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmTc15minIntTable_del(struct tcapOmTc15minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmTc15minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmTc15minIntTable_del(struct tcapOmTc15minIntTable_data *thedata)
{
	struct tcapOmTc15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmTc15minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmTc15minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmTc15minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmTc15minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmTc15minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmTc15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTc15minIntTable_data *StorageTmp = tcapOmTc15minIntTable_create();

	DEBUGMSGTL(("tcapOmTc15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntTpErrors, &tmpsize);
	tcapOmTc15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
}

/*
 * store_tcapOmTc15minIntTable(): store configuraiton file for tcapOmTc15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTc15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTc15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "storing data...  "));
	refresh_tcapOmTc15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmTc15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTc15minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTc15minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntTpErrors, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelRecvTable_data *tcapOmDevelRecvTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelRecvTable table.
 * Creates a new tcapOmDevelRecvTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelRecvTable_data *
tcapOmDevelRecvTable_create(void)
{
	struct tcapOmDevelRecvTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecvTable_data);

	DEBUGMSGTL(("tcapOmDevelRecvTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelRecvTable_data *tcapOmDevelRecvTable_duplicate(struct tcapOmDevelRecvTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelRecvTable_data *
tcapOmDevelRecvTable_duplicate(struct tcapOmDevelRecvTable_data *thedata)
{
	struct tcapOmDevelRecvTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecvTable_data);

	DEBUGMSGTL(("tcapOmDevelRecvTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelRecvTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelRecvTable_destroy(struct tcapOmDevelRecvTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelRecvTable_destroy(struct tcapOmDevelRecvTable_data **thedata)
{
	struct tcapOmDevelRecvTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecvTable_add(struct tcapOmDevelRecvTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelRecvTable table data set.
 * Adds a table row structure to the tcapOmDevelRecvTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelRecvTable_add(struct tcapOmDevelRecvTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	header_complex_add_data(&tcapOmDevelRecvTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecvTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecvTable_del(struct tcapOmDevelRecvTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelRecvTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelRecvTable_del(struct tcapOmDevelRecvTable_data *thedata)
{
	struct tcapOmDevelRecvTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelRecvTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelRecvTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelRecvTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelRecvTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelRecvTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelRecvTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecvTable_data *StorageTmp = tcapOmDevelRecvTable_create();

	DEBUGMSGTL(("tcapOmDevelRecvTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejParmRetError, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelRecv5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelRecv15minValidIntervals, &tmpsize);
	tcapOmDevelRecvTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecvTable(): store configuraiton file for tcapOmDevelRecvTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecvTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecvTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "storing data...  "));
	refresh_tcapOmDevelRecvTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecvTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecvTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecvTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejParmRetError, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelRecv5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelRecv15minValidIntervals, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelRecvCurrentTable_data *tcapOmDevelRecvCurrentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelRecvCurrentTable table.
 * Creates a new tcapOmDevelRecvCurrentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelRecvCurrentTable_data *
tcapOmDevelRecvCurrentTable_create(void)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecvCurrentTable_data);

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelRecvCurrentTable_data *tcapOmDevelRecvCurrentTable_duplicate(struct tcapOmDevelRecvCurrentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelRecvCurrentTable_data *
tcapOmDevelRecvCurrentTable_duplicate(struct tcapOmDevelRecvCurrentTable_data *thedata)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecvCurrentTable_data);

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelRecvCurrentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelRecvCurrentTable_destroy(struct tcapOmDevelRecvCurrentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelRecvCurrentTable_destroy(struct tcapOmDevelRecvCurrentTable_data **thedata)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecvCurrentTable_add(struct tcapOmDevelRecvCurrentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelRecvCurrentTable table data set.
 * Adds a table row structure to the tcapOmDevelRecvCurrentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelRecvCurrentTable_add(struct tcapOmDevelRecvCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	header_complex_add_data(&tcapOmDevelRecvCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecvCurrentTable_del(struct tcapOmDevelRecvCurrentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelRecvCurrentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelRecvCurrentTable_del(struct tcapOmDevelRecvCurrentTable_data *thedata)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelRecvCurrentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelRecvCurrentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelRecvCurrentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelRecvCurrentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelRecvCurrentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelRecvCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecvCurrentTable_data *StorageTmp = tcapOmDevelRecvCurrentTable_create();

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError, &tmpsize);
	tcapOmDevelRecvCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecvCurrentTable(): store configuraiton file for tcapOmDevelRecvCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecvCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecvCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "storing data...  "));
	refresh_tcapOmDevelRecvCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecvCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecvCurrentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecvCurrentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelRecv5minIntTable_data *tcapOmDevelRecv5minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelRecv5minIntTable table.
 * Creates a new tcapOmDevelRecv5minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelRecv5minIntTable_data *
tcapOmDevelRecv5minIntTable_create(void)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecv5minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelRecv5minIntTable_data *tcapOmDevelRecv5minIntTable_duplicate(struct tcapOmDevelRecv5minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelRecv5minIntTable_data *
tcapOmDevelRecv5minIntTable_duplicate(struct tcapOmDevelRecv5minIntTable_data *thedata)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecv5minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelRecv5minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelRecv5minIntTable_destroy(struct tcapOmDevelRecv5minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelRecv5minIntTable_destroy(struct tcapOmDevelRecv5minIntTable_data **thedata)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecv5minIntTable_add(struct tcapOmDevelRecv5minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelRecv5minIntTable table data set.
 * Adds a table row structure to the tcapOmDevelRecv5minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelRecv5minIntTable_add(struct tcapOmDevelRecv5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmDevelRecv5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecv5minIntTable_del(struct tcapOmDevelRecv5minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelRecv5minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelRecv5minIntTable_del(struct tcapOmDevelRecv5minIntTable_data *thedata)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelRecv5minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelRecv5minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelRecv5minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelRecv5minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelRecv5minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelRecv5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecv5minIntTable_data *StorageTmp = tcapOmDevelRecv5minIntTable_create();

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError, &tmpsize);
	tcapOmDevelRecv5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecv5minIntTable(): store configuraiton file for tcapOmDevelRecv5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecv5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecv5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "storing data...  "));
	refresh_tcapOmDevelRecv5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecv5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecv5minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecv5minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelRecv15minIntTable_data *tcapOmDevelRecv15minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelRecv15minIntTable table.
 * Creates a new tcapOmDevelRecv15minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelRecv15minIntTable_data *
tcapOmDevelRecv15minIntTable_create(void)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecv15minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelRecv15minIntTable_data *tcapOmDevelRecv15minIntTable_duplicate(struct tcapOmDevelRecv15minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelRecv15minIntTable_data *
tcapOmDevelRecv15minIntTable_duplicate(struct tcapOmDevelRecv15minIntTable_data *thedata)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelRecv15minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelRecv15minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelRecv15minIntTable_destroy(struct tcapOmDevelRecv15minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelRecv15minIntTable_destroy(struct tcapOmDevelRecv15minIntTable_data **thedata)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecv15minIntTable_add(struct tcapOmDevelRecv15minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelRecv15minIntTable table data set.
 * Adds a table row structure to the tcapOmDevelRecv15minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelRecv15minIntTable_add(struct tcapOmDevelRecv15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmDevelRecv15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelRecv15minIntTable_del(struct tcapOmDevelRecv15minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelRecv15minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelRecv15minIntTable_del(struct tcapOmDevelRecv15minIntTable_data *thedata)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelRecv15minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelRecv15minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelRecv15minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelRecv15minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelRecv15minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelRecv15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecv15minIntTable_data *StorageTmp = tcapOmDevelRecv15minIntTable_create();

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError, &tmpsize);
	tcapOmDevelRecv15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecv15minIntTable(): store configuraiton file for tcapOmDevelRecv15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecv15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecv15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "storing data...  "));
	refresh_tcapOmDevelRecv15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecv15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecv15minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecv15minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelSentTable_data *tcapOmDevelSentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelSentTable table.
 * Creates a new tcapOmDevelSentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelSentTable_data *
tcapOmDevelSentTable_create(void)
{
	struct tcapOmDevelSentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSentTable_data);

	DEBUGMSGTL(("tcapOmDevelSentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelSentTable_data *tcapOmDevelSentTable_duplicate(struct tcapOmDevelSentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelSentTable_data *
tcapOmDevelSentTable_duplicate(struct tcapOmDevelSentTable_data *thedata)
{
	struct tcapOmDevelSentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSentTable_data);

	DEBUGMSGTL(("tcapOmDevelSentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelSentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelSentTable_destroy(struct tcapOmDevelSentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelSentTable_destroy(struct tcapOmDevelSentTable_data **thedata)
{
	struct tcapOmDevelSentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSentTable_add(struct tcapOmDevelSentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelSentTable table data set.
 * Adds a table row structure to the tcapOmDevelSentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelSentTable_add(struct tcapOmDevelSentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));
	header_complex_add_data(&tcapOmDevelSentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSentTable_del(struct tcapOmDevelSentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelSentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelSentTable_del(struct tcapOmDevelSentTable_data *thedata)
{
	struct tcapOmDevelSentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelSentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelSentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelSentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelSentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelSentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelSentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSentTable_data *StorageTmp = tcapOmDevelSentTable_create();

	DEBUGMSGTL(("tcapOmDevelSentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejParmRetError, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelSent5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelSent15minValidIntervals, &tmpsize);
	tcapOmDevelSentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
}

/*
 * store_tcapOmDevelSentTable(): store configuraiton file for tcapOmDevelSentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSentTable", "storing data...  "));
	refresh_tcapOmDevelSentTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejParmRetError, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelSent5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelSent15minValidIntervals, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelSentCurrentTable_data *tcapOmDevelSentCurrentTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelSentCurrentTable table.
 * Creates a new tcapOmDevelSentCurrentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelSentCurrentTable_data *
tcapOmDevelSentCurrentTable_create(void)
{
	struct tcapOmDevelSentCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSentCurrentTable_data);

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelSentCurrentTable_data *tcapOmDevelSentCurrentTable_duplicate(struct tcapOmDevelSentCurrentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelSentCurrentTable_data *
tcapOmDevelSentCurrentTable_duplicate(struct tcapOmDevelSentCurrentTable_data *thedata)
{
	struct tcapOmDevelSentCurrentTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSentCurrentTable_data);

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelSentCurrentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelSentCurrentTable_destroy(struct tcapOmDevelSentCurrentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelSentCurrentTable_destroy(struct tcapOmDevelSentCurrentTable_data **thedata)
{
	struct tcapOmDevelSentCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSentCurrentTable_add(struct tcapOmDevelSentCurrentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelSentCurrentTable table data set.
 * Adds a table row structure to the tcapOmDevelSentCurrentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelSentCurrentTable_add(struct tcapOmDevelSentCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));
	header_complex_add_data(&tcapOmDevelSentCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSentCurrentTable_del(struct tcapOmDevelSentCurrentTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelSentCurrentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelSentCurrentTable_del(struct tcapOmDevelSentCurrentTable_data *thedata)
{
	struct tcapOmDevelSentCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelSentCurrentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelSentCurrentTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelSentCurrentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelSentCurrentTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelSentCurrentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelSentCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSentCurrentTable_data *StorageTmp = tcapOmDevelSentCurrentTable_create();

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError, &tmpsize);
	tcapOmDevelSentCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
}

/*
 * store_tcapOmDevelSentCurrentTable(): store configuraiton file for tcapOmDevelSentCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSentCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSentCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "storing data...  "));
	refresh_tcapOmDevelSentCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSentCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSentCurrentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSentCurrentTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelSent5minIntTable_data *tcapOmDevelSent5minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelSent5minIntTable table.
 * Creates a new tcapOmDevelSent5minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelSent5minIntTable_data *
tcapOmDevelSent5minIntTable_create(void)
{
	struct tcapOmDevelSent5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSent5minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelSent5minIntTable_data *tcapOmDevelSent5minIntTable_duplicate(struct tcapOmDevelSent5minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelSent5minIntTable_data *
tcapOmDevelSent5minIntTable_duplicate(struct tcapOmDevelSent5minIntTable_data *thedata)
{
	struct tcapOmDevelSent5minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSent5minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelSent5minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelSent5minIntTable_destroy(struct tcapOmDevelSent5minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelSent5minIntTable_destroy(struct tcapOmDevelSent5minIntTable_data **thedata)
{
	struct tcapOmDevelSent5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSent5minIntTable_add(struct tcapOmDevelSent5minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelSent5minIntTable table data set.
 * Adds a table row structure to the tcapOmDevelSent5minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelSent5minIntTable_add(struct tcapOmDevelSent5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmDevelSent5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSent5minIntTable_del(struct tcapOmDevelSent5minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelSent5minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelSent5minIntTable_del(struct tcapOmDevelSent5minIntTable_data *thedata)
{
	struct tcapOmDevelSent5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelSent5minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelSent5minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelSent5minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelSent5minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelSent5minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelSent5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSent5minIntTable_data *StorageTmp = tcapOmDevelSent5minIntTable_create();

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError, &tmpsize);
	tcapOmDevelSent5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelSent5minIntTable(): store configuraiton file for tcapOmDevelSent5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSent5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSent5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "storing data...  "));
	refresh_tcapOmDevelSent5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSent5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSent5minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSent5minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct tcapOmDevelSent15minIntTable_data *tcapOmDevelSent15minIntTable_create(void)
 * @brief create a fresh data structure representing a new row in the tcapOmDevelSent15minIntTable table.
 * Creates a new tcapOmDevelSent15minIntTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct tcapOmDevelSent15minIntTable_data *
tcapOmDevelSent15minIntTable_create(void)
{
	struct tcapOmDevelSent15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSent15minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct tcapOmDevelSent15minIntTable_data *tcapOmDevelSent15minIntTable_duplicate(struct tcapOmDevelSent15minIntTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct tcapOmDevelSent15minIntTable_data *
tcapOmDevelSent15minIntTable_duplicate(struct tcapOmDevelSent15minIntTable_data *thedata)
{
	struct tcapOmDevelSent15minIntTable_data *StorageNew = SNMP_MALLOC_STRUCT(tcapOmDevelSent15minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	tcapOmDevelSent15minIntTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int tcapOmDevelSent15minIntTable_destroy(struct tcapOmDevelSent15minIntTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
tcapOmDevelSent15minIntTable_destroy(struct tcapOmDevelSent15minIntTable_data **thedata)
{
	struct tcapOmDevelSent15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSent15minIntTable_add(struct tcapOmDevelSent15minIntTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the tcapOmDevelSent15minIntTable table data set.
 * Adds a table row structure to the tcapOmDevelSent15minIntTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
tcapOmDevelSent15minIntTable_add(struct tcapOmDevelSent15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));
	header_complex_add_data(&tcapOmDevelSent15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int tcapOmDevelSent15minIntTable_del(struct tcapOmDevelSent15minIntTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the tcapOmDevelSent15minIntTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
tcapOmDevelSent15minIntTable_del(struct tcapOmDevelSent15minIntTable_data *thedata)
{
	struct tcapOmDevelSent15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(tcapOmDevelSent15minIntTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&tcapOmDevelSent15minIntTableStorage, hciptr);
	}
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_tcapOmDevelSent15minIntTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for tcapOmDevelSent15minIntTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case tcapOmDevelSent15minIntTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_tcapOmDevelSent15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSent15minIntTable_data *StorageTmp = tcapOmDevelSent15minIntTable_create();

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError, &tmpsize);
	tcapOmDevelSent15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelSent15minIntTable(): store configuraiton file for tcapOmDevelSent15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSent15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSent15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "storing data...  "));
	refresh_tcapOmDevelSent15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSent15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSent15minIntTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSent15minIntTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_tcapOmNodeTable(void)
 * @brief refresh the scalar values of the tcapOmNodeTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNodeTable(void)
{
	if (tcapOmNodeTable_refresh == 0)
		return;
	tcapOmNodeTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmNodeTable_row(struct tcapOmNodeTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmNodeTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNodeTable_row(struct tcapOmNodeTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNodeTable_request == sa_request)
		return;
	StorageTmp->tcapOmNodeTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmNodeTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmNodeTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNodeTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNodeTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNodeTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmNodeTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNodeTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNodeTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMNODEMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNodeMessagesSent;
	case TCAPOMNODEMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNodeMessagesRecv;
	case TCAPOMNODECOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNodeComponentsSent;
	case TCAPOMNODECOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNodeComponentsRecv;
	case TCAPOMNODE5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmNode5minValidIntervals;
	case TCAPOMNODE15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmNode15minValidIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmNodeCurrentTable(void)
 * @brief refresh the scalar values of the tcapOmNodeCurrentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNodeCurrentTable(void)
{
	if (tcapOmNodeCurrentTable_refresh == 0)
		return;
	tcapOmNodeCurrentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmNodeCurrentTable_row(struct tcapOmNodeCurrentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmNodeCurrentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNodeCurrentTable_row(struct tcapOmNodeCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNodeCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmNodeCurrentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmNodeCurrentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmNodeCurrentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNodeCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNodeCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNodeCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmNodeCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNodeCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNodeCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMNODECURRENTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentMessagesSent;
	case TCAPOMNODECURRENTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentMessagesRecv;
	case TCAPOMNODECURRENTCOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentComponentsSent;
	case TCAPOMNODECURRENTCOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentComponentsRecv;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmNode5minIntTable(void)
 * @brief refresh the scalar values of the tcapOmNode5minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNode5minIntTable(void)
{
	if (tcapOmNode5minIntTable_refresh == 0)
		return;
	tcapOmNode5minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmNode5minIntTable_row(struct tcapOmNode5minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmNode5minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNode5minIntTable_row(struct tcapOmNode5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNode5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmNode5minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmNode5minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmNode5minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNode5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNode5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNode5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmNode5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNode5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNode5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMNODE5MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNode5minIntMessagesSent;
	case TCAPOMNODE5MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNode5minIntMessagesRecv;
	case TCAPOMNODE5MININTCOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNode5minIntComponentsSent;
	case TCAPOMNODE5MININTCOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNode5minIntComponentsRecv;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmNode15minIntTable(void)
 * @brief refresh the scalar values of the tcapOmNode15minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNode15minIntTable(void)
{
	if (tcapOmNode15minIntTable_refresh == 0)
		return;
	tcapOmNode15minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmNode15minIntTable_row(struct tcapOmNode15minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmNode15minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNode15minIntTable_row(struct tcapOmNode15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNode15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmNode15minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmNode15minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmNode15minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNode15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNode15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNode15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmNode15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNode15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNode15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMNODE15MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNode15minIntMessagesSent;
	case TCAPOMNODE15MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNode15minIntMessagesRecv;
	case TCAPOMNODE15MININTCOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNode15minIntComponentsSent;
	case TCAPOMNODE15MININTCOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNode15minIntComponentsRecv;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmMsgsTable(void)
 * @brief refresh the scalar values of the tcapOmMsgsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgsTable(void)
{
	if (tcapOmMsgsTable_refresh == 0)
		return;
	tcapOmMsgsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmMsgsTable_row(struct tcapOmMsgsTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmMsgsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgsTable_row(struct tcapOmMsgsTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgsTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgsTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmMsgsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmMsgsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmMsgsTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMMSGSMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgsMessagesSent;
	case TCAPOMMSGSMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgsMessagesRecv;
	case TCAPOMMSGS5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmMsgs5minValidIntervals;
	case TCAPOMMSGS15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmMsgs15minValidIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmMsgsCurrentTable(void)
 * @brief refresh the scalar values of the tcapOmMsgsCurrentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgsCurrentTable(void)
{
	if (tcapOmMsgsCurrentTable_refresh == 0)
		return;
	tcapOmMsgsCurrentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmMsgsCurrentTable_row(struct tcapOmMsgsCurrentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmMsgsCurrentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgsCurrentTable_row(struct tcapOmMsgsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgsCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgsCurrentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmMsgsCurrentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmMsgsCurrentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgsCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmMsgsCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgsCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMMSGSCURRENTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsCurrentMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgsCurrentMessagesSent;
	case TCAPOMMSGSCURRENTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsCurrentMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgsCurrentMessagesRecv;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmMsgs5minIntTable(void)
 * @brief refresh the scalar values of the tcapOmMsgs5minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgs5minIntTable(void)
{
	if (tcapOmMsgs5minIntTable_refresh == 0)
		return;
	tcapOmMsgs5minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmMsgs5minIntTable_row(struct tcapOmMsgs5minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmMsgs5minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgs5minIntTable_row(struct tcapOmMsgs5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgs5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgs5minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmMsgs5minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmMsgs5minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgs5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgs5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgs5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmMsgs5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgs5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgs5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMMSGS5MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs5minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgs5minIntMessagesSent;
	case TCAPOMMSGS5MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs5minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgs5minIntMessagesRecv;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmMsgs15minIntTable(void)
 * @brief refresh the scalar values of the tcapOmMsgs15minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgs15minIntTable(void)
{
	if (tcapOmMsgs15minIntTable_refresh == 0)
		return;
	tcapOmMsgs15minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmMsgs15minIntTable_row(struct tcapOmMsgs15minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmMsgs15minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgs15minIntTable_row(struct tcapOmMsgs15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgs15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgs15minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmMsgs15minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmMsgs15minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgs15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgs15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgs15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmMsgs15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgs15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgs15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMMSGS15MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs15minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgs15minIntMessagesSent;
	case TCAPOMMSGS15MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs15minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgs15minIntMessagesRecv;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmAETable(void)
 * @brief refresh the scalar values of the tcapOmAETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAETable(void)
{
	if (tcapOmAETable_refresh == 0)
		return;
	tcapOmAETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmAETable_row(struct tcapOmAETable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmAETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAETable_row(struct tcapOmAETable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAETable_request == sa_request)
		return;
	StorageTmp->tcapOmAETable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmAETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmAETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmAETable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMAEMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAEMeasurementDeleted;
	case TCAPOMAENEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAENewTransactions);
		return (u_char *) &StorageTmp->tcapOmAENewTransactions;
	case TCAPOMAEMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAEMeanOpenTransactions;
	case TCAPOMAENOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAENotUsed);
		return (u_char *) &StorageTmp->tcapOmAENotUsed;
	case TCAPOMAECUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAECummulativeMeanDuration;
	case TCAPOMAEMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAEMaximumOpenTranactions;
	case TCAPOMAETHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAEThresholdExceeded;
	case TCAPOMAE5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmAE5minValidIntervals;
	case TCAPOMAE15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmAE15minValidIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmAECurrentTable(void)
 * @brief refresh the scalar values of the tcapOmAECurrentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAECurrentTable(void)
{
	if (tcapOmAECurrentTable_refresh == 0)
		return;
	tcapOmAECurrentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmAECurrentTable_row(struct tcapOmAECurrentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmAECurrentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAECurrentTable_row(struct tcapOmAECurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAECurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmAECurrentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmAECurrentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmAECurrentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAECurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAECurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAECurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmAECurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAECurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAECurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMAECURRENTMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAECurrentMeasurementDeleted;
	case TCAPOMAECURRENTNEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentNewTransactions);
		return (u_char *) &StorageTmp->tcapOmAECurrentNewTransactions;
	case TCAPOMAECURRENTMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAECurrentMeanOpenTransactions;
	case TCAPOMAECURRENTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentNotUsed);
		return (u_char *) &StorageTmp->tcapOmAECurrentNotUsed;
	case TCAPOMAECURRENTCUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentCummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAECurrentCummulativeMeanDuration;
	case TCAPOMAECURRENTMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAECurrentMaximumOpenTranactions;
	case TCAPOMAECURRENTTHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAECurrentThresholdExceeded;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmAE5minIntTable(void)
 * @brief refresh the scalar values of the tcapOmAE5minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAE5minIntTable(void)
{
	if (tcapOmAE5minIntTable_refresh == 0)
		return;
	tcapOmAE5minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmAE5minIntTable_row(struct tcapOmAE5minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmAE5minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAE5minIntTable_row(struct tcapOmAE5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAE5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmAE5minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmAE5minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmAE5minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAE5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAE5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAE5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmAE5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAE5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAE5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMAE5MININTMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAE5minIntMeasurementDeleted;
	case TCAPOMAE5MININTNEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntNewTransactions);
		return (u_char *) &StorageTmp->tcapOmAE5minIntNewTransactions;
	case TCAPOMAE5MININTMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAE5minIntMeanOpenTransactions;
	case TCAPOMAE5MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmAE5minIntNotUsed;
	case TCAPOMAE5MININTCUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntCummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAE5minIntCummulativeMeanDuration;
	case TCAPOMAE5MININTMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAE5minIntMaximumOpenTranactions;
	case TCAPOMAE5MININTTHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAE5minIntThresholdExceeded;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmAE15minIntTable(void)
 * @brief refresh the scalar values of the tcapOmAE15minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAE15minIntTable(void)
{
	if (tcapOmAE15minIntTable_refresh == 0)
		return;
	tcapOmAE15minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmAE15minIntTable_row(struct tcapOmAE15minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmAE15minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAE15minIntTable_row(struct tcapOmAE15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAE15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmAE15minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmAE15minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmAE15minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAE15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAE15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAE15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmAE15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAE15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAE15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMAE15MININTMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAE15minIntMeasurementDeleted;
	case TCAPOMAE15MININTNEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntNewTransactions);
		return (u_char *) &StorageTmp->tcapOmAE15minIntNewTransactions;
	case TCAPOMAE15MININTMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAE15minIntMeanOpenTransactions;
	case TCAPOMAE15MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmAE15minIntNotUsed;
	case TCAPOMAE15MININTCUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntCummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAE15minIntCummulativeMeanDuration;
	case TCAPOMAE15MININTMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAE15minIntMaximumOpenTranactions;
	case TCAPOMAE15MININTTHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAE15minIntThresholdExceeded;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmTcTable(void)
 * @brief refresh the scalar values of the tcapOmTcTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTcTable(void)
{
	if (tcapOmTcTable_refresh == 0)
		return;
	tcapOmTcTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmTcTable_row(struct tcapOmTcTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmTcTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTcTable_row(struct tcapOmTcTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTcTable_request == sa_request)
		return;
	StorageTmp->tcapOmTcTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmTcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmTcTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmTcTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMTCPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcPabortRecvUnrecTid;
	case TCAPOMTCPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcPabortRecvResourceLim;
	case TCAPOMTCREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcRejectRecvResourceLim;
	case TCAPOMTCPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcPabortSentUnrecTid;
	case TCAPOMTCPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcPabortSentResourceLim;
	case TCAPOMTCREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcRejectSentResourceLim;
	case TCAPOMTCTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTcTcUserCancel;
	case TCAPOMTCMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTcMessagesDiscarded;
	case TCAPOMTCNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcNotUsed);
		return (u_char *) &StorageTmp->tcapOmTcNotUsed;
	case TCAPOMTCPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTcPabortsReceived;
	case TCAPOMTCTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTcTcUserRejectsReceived;
	case TCAPOMTCTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcTpErrors);
		return (u_char *) &StorageTmp->tcapOmTcTpErrors;
	case TCAPOMTC5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmTc5minValidIntervals;
	case TCAPOMTC15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmTc15minValidIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmTcCurrentTable(void)
 * @brief refresh the scalar values of the tcapOmTcCurrentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTcCurrentTable(void)
{
	if (tcapOmTcCurrentTable_refresh == 0)
		return;
	tcapOmTcCurrentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmTcCurrentTable_row(struct tcapOmTcCurrentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmTcCurrentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTcCurrentTable_row(struct tcapOmTcCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTcCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmTcCurrentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmTcCurrentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmTcCurrentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTcCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTcCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTcCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmTcCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTcCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTcCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMTCCURRENTPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid;
	case TCAPOMTCCURRENTPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortRecvResourceLim;
	case TCAPOMTCCURRENTREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentRejectRecvResourceLim;
	case TCAPOMTCCURRENTPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortSentUnrecTid;
	case TCAPOMTCCURRENTPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortSentResourceLim;
	case TCAPOMTCCURRENTREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentRejectSentResourceLim;
	case TCAPOMTCCURRENTTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTcCurrentTcUserCancel;
	case TCAPOMTCCURRENTMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTcCurrentMessagesDiscarded;
	case TCAPOMTCCURRENTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentNotUsed);
		return (u_char *) &StorageTmp->tcapOmTcCurrentNotUsed;
	case TCAPOMTCCURRENTPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortsReceived;
	case TCAPOMTCCURRENTTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTcCurrentTcUserRejectsReceived;
	case TCAPOMTCCURRENTTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentTpErrors);
		return (u_char *) &StorageTmp->tcapOmTcCurrentTpErrors;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmTc5minIntTable(void)
 * @brief refresh the scalar values of the tcapOmTc5minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTc5minIntTable(void)
{
	if (tcapOmTc5minIntTable_refresh == 0)
		return;
	tcapOmTc5minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmTc5minIntTable_row(struct tcapOmTc5minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmTc5minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTc5minIntTable_row(struct tcapOmTc5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTc5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmTc5minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmTc5minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmTc5minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTc5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTc5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTc5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmTc5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTc5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTc5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMTC5MININTPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid;
	case TCAPOMTC5MININTPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortRecvResourceLim;
	case TCAPOMTC5MININTREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntRejectRecvResourceLim;
	case TCAPOMTC5MININTPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortSentUnrecTid;
	case TCAPOMTC5MININTPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortSentResourceLim;
	case TCAPOMTC5MININTREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntRejectSentResourceLim;
	case TCAPOMTC5MININTTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTc5minIntTcUserCancel;
	case TCAPOMTC5MININTMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTc5minIntMessagesDiscarded;
	case TCAPOMTC5MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmTc5minIntNotUsed;
	case TCAPOMTC5MININTPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortsReceived;
	case TCAPOMTC5MININTTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTc5minIntTcUserRejectsReceived;
	case TCAPOMTC5MININTTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntTpErrors);
		return (u_char *) &StorageTmp->tcapOmTc5minIntTpErrors;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmTc15minIntTable(void)
 * @brief refresh the scalar values of the tcapOmTc15minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTc15minIntTable(void)
{
	if (tcapOmTc15minIntTable_refresh == 0)
		return;
	tcapOmTc15minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmTc15minIntTable_row(struct tcapOmTc15minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmTc15minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTc15minIntTable_row(struct tcapOmTc15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTc15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmTc15minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmTc15minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmTc15minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTc15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTc15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTc15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmTc15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTc15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTc15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMTC15MININTPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid;
	case TCAPOMTC15MININTPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortRecvResourceLim;
	case TCAPOMTC15MININTREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntRejectRecvResourceLim;
	case TCAPOMTC15MININTPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortSentUnrecTid;
	case TCAPOMTC15MININTPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortSentResourceLim;
	case TCAPOMTC15MININTREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntRejectSentResourceLim;
	case TCAPOMTC15MININTTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTc15minIntTcUserCancel;
	case TCAPOMTC15MININTMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTc15minIntMessagesDiscarded;
	case TCAPOMTC15MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmTc15minIntNotUsed;
	case TCAPOMTC15MININTPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortsReceived;
	case TCAPOMTC15MININTTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTc15minIntTcUserRejectsReceived;
	case TCAPOMTC15MININTTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntTpErrors);
		return (u_char *) &StorageTmp->tcapOmTc15minIntTpErrors;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelRecvTable(void)
 * @brief refresh the scalar values of the tcapOmDevelRecvTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecvTable(void)
{
	if (tcapOmDevelRecvTable_refresh == 0)
		return;
	tcapOmDevelRecvTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelRecvTable_row(struct tcapOmDevelRecvTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelRecvTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecvTable_row(struct tcapOmDevelRecvTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecvTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecvTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelRecvTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelRecvTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecvTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecvTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecvTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelRecvTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecvTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecvTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELRECVPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecvPabortMessageType;
	case TCAPOMDEVELRECVPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvPabortIncorrectTp;
	case TCAPOMDEVELRECVPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvPabortBadTp;
	case TCAPOMDEVELRECVREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecComp;
	case TCAPOMDEVELRECVREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectMistypeComp;
	case TCAPOMDEVELRECVREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectBadCompStruct;
	case TCAPOMDEVELRECVREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecLinkId;
	case TCAPOMDEVELRECVREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes;
	case TCAPOMDEVELRECVREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnexpRetRes;
	case TCAPOMDEVELRECVREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr;
	case TCAPOMDEVELRECVREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnexpRetErr;
	case TCAPOMDEVELRECVUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId;
	case TCAPOMDEVELRECVUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnrecOper;
	case TCAPOMDEVELRECVUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejParmInvoke;
	case TCAPOMDEVELRECVUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejReleasing;
	case TCAPOMDEVELRECVUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECVUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECVUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnrecError;
	case TCAPOMDEVELRECVUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnexpError;
	case TCAPOMDEVELRECVUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejParmRetResult;
	case TCAPOMDEVELRECVUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejParmRetError;
	case TCAPOMDEVELRECV5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minValidIntervals;
	case TCAPOMDEVELRECV15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minValidIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelRecvCurrentTable(void)
 * @brief refresh the scalar values of the tcapOmDevelRecvCurrentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecvCurrentTable(void)
{
	if (tcapOmDevelRecvCurrentTable_refresh == 0)
		return;
	tcapOmDevelRecvCurrentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelRecvCurrentTable_row(struct tcapOmDevelRecvCurrentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelRecvCurrentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecvCurrentTable_row(struct tcapOmDevelRecvCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecvCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecvCurrentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelRecvCurrentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelRecvCurrentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecvCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecvCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelRecvCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecvCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecvCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELRECVCURRENTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentPabortMessageType;
	case TCAPOMDEVELRECVCURRENTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp;
	case TCAPOMDEVELRECVCURRENTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentPabortBadTp;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp;
	case TCAPOMDEVELRECVCURRENTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp;
	case TCAPOMDEVELRECVCURRENTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes;
	case TCAPOMDEVELRECVCURRENTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr;
	case TCAPOMDEVELRECVCURRENTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr;
	case TCAPOMDEVELRECVCURRENTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId;
	case TCAPOMDEVELRECVCURRENTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper;
	case TCAPOMDEVELRECVCURRENTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke;
	case TCAPOMDEVELRECVCURRENTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing;
	case TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECVCURRENTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError;
	case TCAPOMDEVELRECVCURRENTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError;
	case TCAPOMDEVELRECVCURRENTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult;
	case TCAPOMDEVELRECVCURRENTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelRecv5minIntTable(void)
 * @brief refresh the scalar values of the tcapOmDevelRecv5minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecv5minIntTable(void)
{
	if (tcapOmDevelRecv5minIntTable_refresh == 0)
		return;
	tcapOmDevelRecv5minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelRecv5minIntTable_row(struct tcapOmDevelRecv5minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelRecv5minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecv5minIntTable_row(struct tcapOmDevelRecv5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecv5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecv5minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelRecv5minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelRecv5minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecv5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecv5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelRecv5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecv5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecv5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELRECV5MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntPabortMessageType;
	case TCAPOMDEVELRECV5MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp;
	case TCAPOMDEVELRECV5MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntPabortBadTp;
	case TCAPOMDEVELRECV5MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp;
	case TCAPOMDEVELRECV5MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp;
	case TCAPOMDEVELRECV5MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct;
	case TCAPOMDEVELRECV5MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId;
	case TCAPOMDEVELRECV5MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELRECV5MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes;
	case TCAPOMDEVELRECV5MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELRECV5MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr;
	case TCAPOMDEVELRECV5MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId;
	case TCAPOMDEVELRECV5MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper;
	case TCAPOMDEVELRECV5MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke;
	case TCAPOMDEVELRECV5MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing;
	case TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECV5MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError;
	case TCAPOMDEVELRECV5MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError;
	case TCAPOMDEVELRECV5MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult;
	case TCAPOMDEVELRECV5MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelRecv15minIntTable(void)
 * @brief refresh the scalar values of the tcapOmDevelRecv15minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecv15minIntTable(void)
{
	if (tcapOmDevelRecv15minIntTable_refresh == 0)
		return;
	tcapOmDevelRecv15minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelRecv15minIntTable_row(struct tcapOmDevelRecv15minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelRecv15minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecv15minIntTable_row(struct tcapOmDevelRecv15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecv15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecv15minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelRecv15minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelRecv15minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecv15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecv15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelRecv15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecv15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecv15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELRECV15MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntPabortMessageType;
	case TCAPOMDEVELRECV15MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp;
	case TCAPOMDEVELRECV15MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntPabortBadTp;
	case TCAPOMDEVELRECV15MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp;
	case TCAPOMDEVELRECV15MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp;
	case TCAPOMDEVELRECV15MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct;
	case TCAPOMDEVELRECV15MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId;
	case TCAPOMDEVELRECV15MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELRECV15MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes;
	case TCAPOMDEVELRECV15MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELRECV15MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr;
	case TCAPOMDEVELRECV15MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId;
	case TCAPOMDEVELRECV15MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper;
	case TCAPOMDEVELRECV15MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke;
	case TCAPOMDEVELRECV15MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing;
	case TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECV15MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError;
	case TCAPOMDEVELRECV15MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError;
	case TCAPOMDEVELRECV15MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult;
	case TCAPOMDEVELRECV15MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelSentTable(void)
 * @brief refresh the scalar values of the tcapOmDevelSentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSentTable(void)
{
	if (tcapOmDevelSentTable_refresh == 0)
		return;
	tcapOmDevelSentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelSentTable_row(struct tcapOmDevelSentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelSentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSentTable_row(struct tcapOmDevelSentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSentTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelSentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelSentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelSentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELSENTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSentPabortMessageType;
	case TCAPOMDEVELSENTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentPabortIncorrectTp;
	case TCAPOMDEVELSENTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentPabortBadTp;
	case TCAPOMDEVELSENTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecComp;
	case TCAPOMDEVELSENTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectMistypeComp;
	case TCAPOMDEVELSENTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectBadCompStruct;
	case TCAPOMDEVELSENTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecLinkId;
	case TCAPOMDEVELSENTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes;
	case TCAPOMDEVELSENTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnexpRetRes;
	case TCAPOMDEVELSENTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr;
	case TCAPOMDEVELSENTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnexpRetErr;
	case TCAPOMDEVELSENTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejDupInvokeId;
	case TCAPOMDEVELSENTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnrecOper;
	case TCAPOMDEVELSENTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejParmInvoke;
	case TCAPOMDEVELSENTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejReleasing;
	case TCAPOMDEVELSENTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnrecError;
	case TCAPOMDEVELSENTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnexpError;
	case TCAPOMDEVELSENTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejParmRetResult;
	case TCAPOMDEVELSENTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejParmRetError;
	case TCAPOMDEVELSENT5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minValidIntervals;
	case TCAPOMDEVELSENT15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minValidIntervals;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelSentCurrentTable(void)
 * @brief refresh the scalar values of the tcapOmDevelSentCurrentTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSentCurrentTable(void)
{
	if (tcapOmDevelSentCurrentTable_refresh == 0)
		return;
	tcapOmDevelSentCurrentTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelSentCurrentTable_row(struct tcapOmDevelSentCurrentTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelSentCurrentTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSentCurrentTable_row(struct tcapOmDevelSentCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSentCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSentCurrentTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelSentCurrentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelSentCurrentTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSentCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSentCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSentCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelSentCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSentCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSentCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELSENTCURRENTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentPabortMessageType;
	case TCAPOMDEVELSENTCURRENTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp;
	case TCAPOMDEVELSENTCURRENTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentPabortBadTp;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp;
	case TCAPOMDEVELSENTCURRENTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp;
	case TCAPOMDEVELSENTCURRENTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes;
	case TCAPOMDEVELSENTCURRENTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr;
	case TCAPOMDEVELSENTCURRENTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr;
	case TCAPOMDEVELSENTCURRENTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId;
	case TCAPOMDEVELSENTCURRENTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper;
	case TCAPOMDEVELSENTCURRENTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke;
	case TCAPOMDEVELSENTCURRENTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing;
	case TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENTCURRENTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError;
	case TCAPOMDEVELSENTCURRENTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError;
	case TCAPOMDEVELSENTCURRENTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult;
	case TCAPOMDEVELSENTCURRENTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelSent5minIntTable(void)
 * @brief refresh the scalar values of the tcapOmDevelSent5minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSent5minIntTable(void)
{
	if (tcapOmDevelSent5minIntTable_refresh == 0)
		return;
	tcapOmDevelSent5minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelSent5minIntTable_row(struct tcapOmDevelSent5minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelSent5minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSent5minIntTable_row(struct tcapOmDevelSent5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSent5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSent5minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelSent5minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelSent5minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSent5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSent5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSent5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelSent5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSent5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSent5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELSENT5MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntPabortMessageType;
	case TCAPOMDEVELSENT5MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp;
	case TCAPOMDEVELSENT5MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntPabortBadTp;
	case TCAPOMDEVELSENT5MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp;
	case TCAPOMDEVELSENT5MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp;
	case TCAPOMDEVELSENT5MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct;
	case TCAPOMDEVELSENT5MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId;
	case TCAPOMDEVELSENT5MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELSENT5MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes;
	case TCAPOMDEVELSENT5MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELSENT5MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr;
	case TCAPOMDEVELSENT5MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId;
	case TCAPOMDEVELSENT5MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper;
	case TCAPOMDEVELSENT5MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke;
	case TCAPOMDEVELSENT5MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing;
	case TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENT5MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError;
	case TCAPOMDEVELSENT5MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError;
	case TCAPOMDEVELSENT5MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult;
	case TCAPOMDEVELSENT5MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_tcapOmDevelSent15minIntTable(void)
 * @brief refresh the scalar values of the tcapOmDevelSent15minIntTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSent15minIntTable(void)
{
	if (tcapOmDevelSent15minIntTable_refresh == 0)
		return;
	tcapOmDevelSent15minIntTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_tcapOmDevelSent15minIntTable_row(struct tcapOmDevelSent15minIntTable_data *StorageTmp)
 * @brief refresh the contents of the tcapOmDevelSent15minIntTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSent15minIntTable_row(struct tcapOmDevelSent15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSent15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSent15minIntTable_request = sa_request;
}

/**
 * @fn u_char *var_tcapOmDevelSent15minIntTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in tcapOmDevelSent15minIntTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSent15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSent15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSent15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_tcapOmDevelSent15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSent15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSent15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case TCAPOMDEVELSENT15MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntPabortMessageType;
	case TCAPOMDEVELSENT15MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp;
	case TCAPOMDEVELSENT15MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntPabortBadTp;
	case TCAPOMDEVELSENT15MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp;
	case TCAPOMDEVELSENT15MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp;
	case TCAPOMDEVELSENT15MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct;
	case TCAPOMDEVELSENT15MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId;
	case TCAPOMDEVELSENT15MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELSENT15MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes;
	case TCAPOMDEVELSENT15MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELSENT15MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr;
	case TCAPOMDEVELSENT15MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId;
	case TCAPOMDEVELSENT15MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper;
	case TCAPOMDEVELSENT15MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke;
	case TCAPOMDEVELSENT15MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing;
	case TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENT15MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError;
	case TCAPOMDEVELSENT15MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError;
	case TCAPOMDEVELSENT15MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult;
	case TCAPOMDEVELSENT15MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn int write_tcapOm1stAndIntervalActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm1stAndIntervalActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm1stAndIntervalActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->tcapOm1stAndIntervalActivate;
		old_length = StorageTmp->tcapOm1stAndIntervalActivateLen;
		StorageTmp->tcapOm1stAndIntervalActivate = objid;
		StorageTmp->tcapOm1stAndIntervalActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm1stAndIntervalActivate = old_value;
		StorageTmp->tcapOm1stAndIntervalActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm1stAndIntervalDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm1stAndIntervalDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm1stAndIntervalDeactivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalDeactivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalDeactivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->tcapOm1stAndIntervalDeactivate;
		old_length = StorageTmp->tcapOm1stAndIntervalDeactivateLen;
		StorageTmp->tcapOm1stAndIntervalDeactivate = objid;
		StorageTmp->tcapOm1stAndIntervalDeactivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm1stAndIntervalDeactivate = old_value;
		StorageTmp->tcapOm1stAndIntervalDeactivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm5MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm5MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm5MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->tcapOm5MinActivate;
		old_length = StorageTmp->tcapOm5MinActivateLen;
		StorageTmp->tcapOm5MinActivate = objid;
		StorageTmp->tcapOm5MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm5MinActivate = old_value;
		StorageTmp->tcapOm5MinActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm5MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm5MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm5MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->tcapOm5MinDeaActivate;
		old_length = StorageTmp->tcapOm5MinDeaActivateLen;
		StorageTmp->tcapOm5MinDeaActivate = objid;
		StorageTmp->tcapOm5MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm5MinDeaActivate = old_value;
		StorageTmp->tcapOm5MinDeaActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm15MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm15MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm15MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->tcapOm15MinActivate;
		old_length = StorageTmp->tcapOm15MinActivateLen;
		StorageTmp->tcapOm15MinActivate = objid;
		StorageTmp->tcapOm15MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm15MinActivate = old_value;
		StorageTmp->tcapOm15MinActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm15MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm15MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm15MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->tcapOm15MinDeaActivate;
		old_length = StorageTmp->tcapOm15MinDeaActivateLen;
		StorageTmp->tcapOm15MinDeaActivate = objid;
		StorageTmp->tcapOm15MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm15MinDeaActivate = old_value;
		StorageTmp->tcapOm15MinDeaActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm5MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm5MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm5MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..288 */
		if ((0 > set_value || set_value > 288)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->tcapOm5MinMaxIntervals;
		StorageTmp->tcapOm5MinMaxIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm5MinMaxIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_tcapOm15MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_tcapOm15MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm15MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..672 */
		if ((0 > set_value || set_value > 672)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->tcapOm15MinMaxIntervals;
		StorageTmp->tcapOm15MinMaxIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm15MinMaxIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
