/*****************************************************************************

 @(#) $RCSfile$ $Name$($Revision$) $Date$

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date$ by $Author$

 -----------------------------------------------------------------------------

 $Log$
 *****************************************************************************/

#ident "@(#) $RCSfile$ $Name$($Revision$) $Date$"

static char const ident[] = "$RCSfile$ $Name$($Revision$) $Date$";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "tcapOmMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int tcapOmMIB_refresh = 1;
volatile int tcapOmNodeTable_refresh = 1;
volatile int tcapOmNodeCurrentTable_refresh = 1;
volatile int tcapOmNode5minIntTable_refresh = 1;
volatile int tcapOmNode15minIntTable_refresh = 1;
volatile int tcapOmMsgsTable_refresh = 1;
volatile int tcapOmMsgsCurrentTable_refresh = 1;
volatile int tcapOmMsgs5minIntTable_refresh = 1;
volatile int tcapOmMsgs15minIntTable_refresh = 1;
volatile int tcapOmAETable_refresh = 1;
volatile int tcapOmAECurrentTable_refresh = 1;
volatile int tcapOmAE5minIntTable_refresh = 1;
volatile int tcapOmAE15minIntTable_refresh = 1;
volatile int tcapOmTcTable_refresh = 1;
volatile int tcapOmTcCurrentTable_refresh = 1;
volatile int tcapOmTc5minIntTable_refresh = 1;
volatile int tcapOmTc15minIntTable_refresh = 1;
volatile int tcapOmDevelRecvTable_refresh = 1;
volatile int tcapOmDevelRecvCurrentTable_refresh = 1;
volatile int tcapOmDevelRecv5minIntTable_refresh = 1;
volatile int tcapOmDevelRecv15minIntTable_refresh = 1;
volatile int tcapOmDevelSentTable_refresh = 1;
volatile int tcapOmDevelSentCurrentTable_refresh = 1;
volatile int tcapOmDevelSent5minIntTable_refresh = 1;
volatile int tcapOmDevelSent15minIntTable_refresh = 1;

/*
 * tcapOmMIB_variables_oid: object identifier for tcapOmMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid tcapOmMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 4 };

/*
 * variable7 tcapOmMIB_variables: tree for tcapOmMIB
 * This variable defines function callbacks and type return information for the tcapOmMIB mib section
 */
struct variable7 tcapOmMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   TCAPOMNODEMESSAGESSENT  (4 % 256)
	{TCAPOMNODEMESSAGESSENT, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 1}},
#define   TCAPOMNODEMESSAGESRECV  (5 % 256)
	{TCAPOMNODEMESSAGESRECV, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 2}},
#define   TCAPOMNODECOMPONENTSSENT  (6 % 256)
	{TCAPOMNODECOMPONENTSSENT, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 3}},
#define   TCAPOMNODECOMPONENTSRECV  (7 % 256)
	{TCAPOMNODECOMPONENTSRECV, ASN_COUNTER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 4}},
#define   TCAPOMNODE5MINVALIDINTERVALS  (8 % 256)
	{TCAPOMNODE5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 5}},
#define   TCAPOMNODE15MINVALIDINTERVALS  (9 % 256)
	{TCAPOMNODE15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmNodeTable, 6, {1, 1, 1, 1, 1, 6}},
#define   TCAPOMNODECURRENTMESSAGESSENT  (13 % 256)
	{TCAPOMNODECURRENTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 1}},
#define   TCAPOMNODECURRENTMESSAGESRECV  (14 % 256)
	{TCAPOMNODECURRENTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 2}},
#define   TCAPOMNODECURRENTCOMPONENTSSENT  (15 % 256)
	{TCAPOMNODECURRENTCOMPONENTSSENT, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 3}},
#define   TCAPOMNODECURRENTCOMPONENTSRECV  (16 % 256)
	{TCAPOMNODECURRENTCOMPONENTSRECV, ASN_GAUGE, RONLY, var_tcapOmNodeCurrentTable, 6, {1, 1, 1, 2, 1, 4}},
#define   TCAPOMNODE5MININTMESSAGESSENT  (21 % 256)
	{TCAPOMNODE5MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 1}},
#define   TCAPOMNODE5MININTMESSAGESRECV  (22 % 256)
	{TCAPOMNODE5MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 2}},
#define   TCAPOMNODE5MININTCOMPONENTSSENT  (23 % 256)
	{TCAPOMNODE5MININTCOMPONENTSSENT, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 3}},
#define   TCAPOMNODE5MININTCOMPONENTSRECV  (24 % 256)
	{TCAPOMNODE5MININTCOMPONENTSRECV, ASN_GAUGE, RONLY, var_tcapOmNode5minIntTable, 6, {1, 1, 1, 3, 1, 4}},
#define   TCAPOMNODE15MININTMESSAGESSENT  (29 % 256)
	{TCAPOMNODE15MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 1}},
#define   TCAPOMNODE15MININTMESSAGESRECV  (30 % 256)
	{TCAPOMNODE15MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 2}},
#define   TCAPOMNODE15MININTCOMPONENTSSENT  (31 % 256)
	{TCAPOMNODE15MININTCOMPONENTSSENT, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 3}},
#define   TCAPOMNODE15MININTCOMPONENTSRECV  (32 % 256)
	{TCAPOMNODE15MININTCOMPONENTSRECV, ASN_GAUGE, RONLY, var_tcapOmNode15minIntTable, 6, {1, 1, 1, 4, 1, 4}},
#define   TCAPOMMSGSMESSAGESSENT  (36 % 256)
	{TCAPOMMSGSMESSAGESSENT, ASN_COUNTER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 1}},
#define   TCAPOMMSGSMESSAGESRECV  (37 % 256)
	{TCAPOMMSGSMESSAGESRECV, ASN_COUNTER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   TCAPOMMSGS5MINVALIDINTERVALS  (38 % 256)
	{TCAPOMMSGS5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   TCAPOMMSGS15MINVALIDINTERVALS  (39 % 256)
	{TCAPOMMSGS15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmMsgsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   TCAPOMMSGSCURRENTMESSAGESSENT  (43 % 256)
	{TCAPOMMSGSCURRENTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmMsgsCurrentTable, 6, {1, 1, 2, 2, 1, 1}},
#define   TCAPOMMSGSCURRENTMESSAGESRECV  (44 % 256)
	{TCAPOMMSGSCURRENTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmMsgsCurrentTable, 6, {1, 1, 2, 2, 1, 2}},
#define   TCAPOMMSGS5MININTMESSAGESSENT  (49 % 256)
	{TCAPOMMSGS5MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmMsgs5minIntTable, 6, {1, 1, 2, 3, 1, 1}},
#define   TCAPOMMSGS5MININTMESSAGESRECV  (50 % 256)
	{TCAPOMMSGS5MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmMsgs5minIntTable, 6, {1, 1, 2, 3, 1, 2}},
#define   TCAPOMMSGS15MININTMESSAGESSENT  (55 % 256)
	{TCAPOMMSGS15MININTMESSAGESSENT, ASN_GAUGE, RONLY, var_tcapOmMsgs15minIntTable, 6, {1, 1, 2, 4, 1, 1}},
#define   TCAPOMMSGS15MININTMESSAGESRECV  (56 % 256)
	{TCAPOMMSGS15MININTMESSAGESRECV, ASN_GAUGE, RONLY, var_tcapOmMsgs15minIntTable, 6, {1, 1, 2, 4, 1, 2}},
#define   TCAPOMAEMEASUREMENTDELETED  (60 % 256)
	{TCAPOMAEMEASUREMENTDELETED, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 1}},
#define   TCAPOMAENEWTRANSACTIONS  (61 % 256)
	{TCAPOMAENEWTRANSACTIONS, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 2}},
#define   TCAPOMAEMEANOPENTRANSACTIONS  (62 % 256)
	{TCAPOMAEMEANOPENTRANSACTIONS, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 3}},
#define   TCAPOMAENOTUSED       (63 % 256)
	{TCAPOMAENOTUSED, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 4}},
#define   TCAPOMAECUMMULATIVEMEANDURATION  (64 % 256)
	{TCAPOMAECUMMULATIVEMEANDURATION, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 5}},
#define   TCAPOMAEMAXIMUMOPENTRANACTIONS  (65 % 256)
	{TCAPOMAEMAXIMUMOPENTRANACTIONS, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 6}},
#define   TCAPOMAETHRESHOLDEXCEEDED  (66 % 256)
	{TCAPOMAETHRESHOLDEXCEEDED, ASN_COUNTER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 7}},
#define   TCAPOMAE5MINVALIDINTERVALS  (67 % 256)
	{TCAPOMAE5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 8}},
#define   TCAPOMAE15MINVALIDINTERVALS  (68 % 256)
	{TCAPOMAE15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmAETable, 6, {1, 1, 3, 1, 1, 9}},
#define   TCAPOMAECURRENTMEASUREMENTDELETED  (72 % 256)
	{TCAPOMAECURRENTMEASUREMENTDELETED, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 1}},
#define   TCAPOMAECURRENTNEWTRANSACTIONS  (73 % 256)
	{TCAPOMAECURRENTNEWTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 2}},
#define   TCAPOMAECURRENTMEANOPENTRANSACTIONS  (74 % 256)
	{TCAPOMAECURRENTMEANOPENTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 3}},
#define   TCAPOMAECURRENTNOTUSED  (75 % 256)
	{TCAPOMAECURRENTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 4}},
#define   TCAPOMAECURRENTCUMMULATIVEMEANDURATION  (76 % 256)
	{TCAPOMAECURRENTCUMMULATIVEMEANDURATION, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 5}},
#define   TCAPOMAECURRENTMAXIMUMOPENTRANACTIONS  (77 % 256)
	{TCAPOMAECURRENTMAXIMUMOPENTRANACTIONS, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 6}},
#define   TCAPOMAECURRENTTHRESHOLDEXCEEDED  (78 % 256)
	{TCAPOMAECURRENTTHRESHOLDEXCEEDED, ASN_GAUGE, RONLY, var_tcapOmAECurrentTable, 6, {1, 1, 3, 2, 1, 7}},
#define   TCAPOMAE5MININTMEASUREMENTDELETED  (83 % 256)
	{TCAPOMAE5MININTMEASUREMENTDELETED, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 1}},
#define   TCAPOMAE5MININTNEWTRANSACTIONS  (84 % 256)
	{TCAPOMAE5MININTNEWTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 2}},
#define   TCAPOMAE5MININTMEANOPENTRANSACTIONS  (85 % 256)
	{TCAPOMAE5MININTMEANOPENTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 3}},
#define   TCAPOMAE5MININTNOTUSED  (86 % 256)
	{TCAPOMAE5MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 4}},
#define   TCAPOMAE5MININTCUMMULATIVEMEANDURATION  (87 % 256)
	{TCAPOMAE5MININTCUMMULATIVEMEANDURATION, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 5}},
#define   TCAPOMAE5MININTMAXIMUMOPENTRANACTIONS  (88 % 256)
	{TCAPOMAE5MININTMAXIMUMOPENTRANACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 6}},
#define   TCAPOMAE5MININTTHRESHOLDEXCEEDED  (89 % 256)
	{TCAPOMAE5MININTTHRESHOLDEXCEEDED, ASN_GAUGE, RONLY, var_tcapOmAE5minIntTable, 6, {1, 1, 3, 3, 1, 7}},
#define   TCAPOMAE15MININTMEASUREMENTDELETED  (94 % 256)
	{TCAPOMAE15MININTMEASUREMENTDELETED, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 1}},
#define   TCAPOMAE15MININTNEWTRANSACTIONS  (95 % 256)
	{TCAPOMAE15MININTNEWTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 2}},
#define   TCAPOMAE15MININTMEANOPENTRANSACTIONS  (96 % 256)
	{TCAPOMAE15MININTMEANOPENTRANSACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 3}},
#define   TCAPOMAE15MININTNOTUSED  (97 % 256)
	{TCAPOMAE15MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 4}},
#define   TCAPOMAE15MININTCUMMULATIVEMEANDURATION  (98 % 256)
	{TCAPOMAE15MININTCUMMULATIVEMEANDURATION, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 5}},
#define   TCAPOMAE15MININTMAXIMUMOPENTRANACTIONS  (99 % 256)
	{TCAPOMAE15MININTMAXIMUMOPENTRANACTIONS, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 6}},
#define   TCAPOMAE15MININTTHRESHOLDEXCEEDED  (100 % 256)
	{TCAPOMAE15MININTTHRESHOLDEXCEEDED, ASN_GAUGE, RONLY, var_tcapOmAE15minIntTable, 6, {1, 1, 3, 4, 1, 7}},
#define   TCAPOMTCPABORTRECVUNRECTID  (104 % 256)
	{TCAPOMTCPABORTRECVUNRECTID, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 1}},
#define   TCAPOMTCPABORTRECVRESOURCELIM  (105 % 256)
	{TCAPOMTCPABORTRECVRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 2}},
#define   TCAPOMTCREJECTRECVRESOURCELIM  (106 % 256)
	{TCAPOMTCREJECTRECVRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 3}},
#define   TCAPOMTCPABORTSENTUNRECTID  (107 % 256)
	{TCAPOMTCPABORTSENTUNRECTID, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 4}},
#define   TCAPOMTCPABORTSENTRESOURCELIM  (108 % 256)
	{TCAPOMTCPABORTSENTRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 5}},
#define   TCAPOMTCREJECTSENTRESOURCELIM  (109 % 256)
	{TCAPOMTCREJECTSENTRESOURCELIM, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 6}},
#define   TCAPOMTCTCUSERCANCEL  (110 % 256)
	{TCAPOMTCTCUSERCANCEL, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 7}},
#define   TCAPOMTCMESSAGESDISCARDED  (111 % 256)
	{TCAPOMTCMESSAGESDISCARDED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 8}},
#define   TCAPOMTCNOTUSED       (112 % 256)
	{TCAPOMTCNOTUSED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 9}},
#define   TCAPOMTCPABORTSRECEIVED  (113 % 256)
	{TCAPOMTCPABORTSRECEIVED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 10}},
#define   TCAPOMTCTCUSERREJECTSRECEIVED  (114 % 256)
	{TCAPOMTCTCUSERREJECTSRECEIVED, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 11}},
#define   TCAPOMTCTPERRORS      (115 % 256)
	{TCAPOMTCTPERRORS, ASN_COUNTER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 12}},
#define   TCAPOMTC5MINVALIDINTERVALS  (116 % 256)
	{TCAPOMTC5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 13}},
#define   TCAPOMTC15MINVALIDINTERVALS  (117 % 256)
	{TCAPOMTC15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmTcTable, 6, {1, 1, 4, 1, 1, 14}},
#define   TCAPOMTCCURRENTPABORTRECVUNRECTID  (121 % 256)
	{TCAPOMTCCURRENTPABORTRECVUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 1}},
#define   TCAPOMTCCURRENTPABORTRECVRESOURCELIM  (122 % 256)
	{TCAPOMTCCURRENTPABORTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 2}},
#define   TCAPOMTCCURRENTREJECTRECVRESOURCELIM  (123 % 256)
	{TCAPOMTCCURRENTREJECTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 3}},
#define   TCAPOMTCCURRENTPABORTSENTUNRECTID  (124 % 256)
	{TCAPOMTCCURRENTPABORTSENTUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 4}},
#define   TCAPOMTCCURRENTPABORTSENTRESOURCELIM  (125 % 256)
	{TCAPOMTCCURRENTPABORTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 5}},
#define   TCAPOMTCCURRENTREJECTSENTRESOURCELIM  (126 % 256)
	{TCAPOMTCCURRENTREJECTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 6}},
#define   TCAPOMTCCURRENTTCUSERCANCEL  (127 % 256)
	{TCAPOMTCCURRENTTCUSERCANCEL, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 7}},
#define   TCAPOMTCCURRENTMESSAGESDISCARDED  (128 % 256)
	{TCAPOMTCCURRENTMESSAGESDISCARDED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 8}},
#define   TCAPOMTCCURRENTNOTUSED  (129 % 256)
	{TCAPOMTCCURRENTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 9}},
#define   TCAPOMTCCURRENTPABORTSRECEIVED  (130 % 256)
	{TCAPOMTCCURRENTPABORTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 10}},
#define   TCAPOMTCCURRENTTCUSERREJECTSRECEIVED  (131 % 256)
	{TCAPOMTCCURRENTTCUSERREJECTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 11}},
#define   TCAPOMTCCURRENTTPERRORS  (132 % 256)
	{TCAPOMTCCURRENTTPERRORS, ASN_GAUGE, RONLY, var_tcapOmTcCurrentTable, 6, {1, 1, 4, 2, 1, 12}},
#define   TCAPOMTC5MININTPABORTRECVUNRECTID  (137 % 256)
	{TCAPOMTC5MININTPABORTRECVUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 1}},
#define   TCAPOMTC5MININTPABORTRECVRESOURCELIM  (138 % 256)
	{TCAPOMTC5MININTPABORTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 2}},
#define   TCAPOMTC5MININTREJECTRECVRESOURCELIM  (139 % 256)
	{TCAPOMTC5MININTREJECTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 3}},
#define   TCAPOMTC5MININTPABORTSENTUNRECTID  (140 % 256)
	{TCAPOMTC5MININTPABORTSENTUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 4}},
#define   TCAPOMTC5MININTPABORTSENTRESOURCELIM  (141 % 256)
	{TCAPOMTC5MININTPABORTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 5}},
#define   TCAPOMTC5MININTREJECTSENTRESOURCELIM  (142 % 256)
	{TCAPOMTC5MININTREJECTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 6}},
#define   TCAPOMTC5MININTTCUSERCANCEL  (143 % 256)
	{TCAPOMTC5MININTTCUSERCANCEL, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 7}},
#define   TCAPOMTC5MININTMESSAGESDISCARDED  (144 % 256)
	{TCAPOMTC5MININTMESSAGESDISCARDED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 8}},
#define   TCAPOMTC5MININTNOTUSED  (145 % 256)
	{TCAPOMTC5MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 9}},
#define   TCAPOMTC5MININTPABORTSRECEIVED  (146 % 256)
	{TCAPOMTC5MININTPABORTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 10}},
#define   TCAPOMTC5MININTTCUSERREJECTSRECEIVED  (147 % 256)
	{TCAPOMTC5MININTTCUSERREJECTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 11}},
#define   TCAPOMTC5MININTTPERRORS  (148 % 256)
	{TCAPOMTC5MININTTPERRORS, ASN_GAUGE, RONLY, var_tcapOmTc5minIntTable, 6, {1, 1, 4, 3, 1, 12}},
#define   TCAPOMTC15MININTPABORTRECVUNRECTID  (153 % 256)
	{TCAPOMTC15MININTPABORTRECVUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 1}},
#define   TCAPOMTC15MININTPABORTRECVRESOURCELIM  (154 % 256)
	{TCAPOMTC15MININTPABORTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 2}},
#define   TCAPOMTC15MININTREJECTRECVRESOURCELIM  (155 % 256)
	{TCAPOMTC15MININTREJECTRECVRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 3}},
#define   TCAPOMTC15MININTPABORTSENTUNRECTID  (156 % 256)
	{TCAPOMTC15MININTPABORTSENTUNRECTID, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 4}},
#define   TCAPOMTC15MININTPABORTSENTRESOURCELIM  (157 % 256)
	{TCAPOMTC15MININTPABORTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 5}},
#define   TCAPOMTC15MININTREJECTSENTRESOURCELIM  (158 % 256)
	{TCAPOMTC15MININTREJECTSENTRESOURCELIM, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 6}},
#define   TCAPOMTC15MININTTCUSERCANCEL  (159 % 256)
	{TCAPOMTC15MININTTCUSERCANCEL, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 7}},
#define   TCAPOMTC15MININTMESSAGESDISCARDED  (160 % 256)
	{TCAPOMTC15MININTMESSAGESDISCARDED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 8}},
#define   TCAPOMTC15MININTNOTUSED  (161 % 256)
	{TCAPOMTC15MININTNOTUSED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 9}},
#define   TCAPOMTC15MININTPABORTSRECEIVED  (162 % 256)
	{TCAPOMTC15MININTPABORTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 10}},
#define   TCAPOMTC15MININTTCUSERREJECTSRECEIVED  (163 % 256)
	{TCAPOMTC15MININTTCUSERREJECTSRECEIVED, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 11}},
#define   TCAPOMTC15MININTTPERRORS  (164 % 256)
	{TCAPOMTC15MININTTPERRORS, ASN_GAUGE, RONLY, var_tcapOmTc15minIntTable, 6, {1, 1, 4, 4, 1, 12}},
#define   TCAPOMDEVELRECVPABORTMESSAGETYPE  (168 % 256)
	{TCAPOMDEVELRECVPABORTMESSAGETYPE, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 1}},
#define   TCAPOMDEVELRECVPABORTINCORRECTTP  (169 % 256)
	{TCAPOMDEVELRECVPABORTINCORRECTTP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 2}},
#define   TCAPOMDEVELRECVPABORTBADTP  (170 % 256)
	{TCAPOMDEVELRECVPABORTBADTP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 3}},
#define   TCAPOMDEVELRECVREJECTUNRECCOMP  (171 % 256)
	{TCAPOMDEVELRECVREJECTUNRECCOMP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 4}},
#define   TCAPOMDEVELRECVREJECTMISTYPECOMP  (172 % 256)
	{TCAPOMDEVELRECVREJECTMISTYPECOMP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 5}},
#define   TCAPOMDEVELRECVREJECTBADCOMPSTRUCT  (173 % 256)
	{TCAPOMDEVELRECVREJECTBADCOMPSTRUCT, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 6}},
#define   TCAPOMDEVELRECVREJECTUNRECLINKID  (174 % 256)
	{TCAPOMDEVELRECVREJECTUNRECLINKID, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 7}},
#define   TCAPOMDEVELRECVREJECTUNRECIDRETRES  (175 % 256)
	{TCAPOMDEVELRECVREJECTUNRECIDRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 8}},
#define   TCAPOMDEVELRECVREJECTUNEXPRETRES  (176 % 256)
	{TCAPOMDEVELRECVREJECTUNEXPRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 9}},
#define   TCAPOMDEVELRECVREJECTUNRECIDRETERR  (177 % 256)
	{TCAPOMDEVELRECVREJECTUNRECIDRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 10}},
#define   TCAPOMDEVELRECVREJECTUNEXPRETERR  (178 % 256)
	{TCAPOMDEVELRECVREJECTUNEXPRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 11}},
#define   TCAPOMDEVELRECVUSRREJDUPINVOKEID  (179 % 256)
	{TCAPOMDEVELRECVUSRREJDUPINVOKEID, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 12}},
#define   TCAPOMDEVELRECVUSRREJUNRECOPER  (180 % 256)
	{TCAPOMDEVELRECVUSRREJUNRECOPER, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 13}},
#define   TCAPOMDEVELRECVUSRREJPARMINVOKE  (181 % 256)
	{TCAPOMDEVELRECVUSRREJPARMINVOKE, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 14}},
#define   TCAPOMDEVELRECVUSRREJRELEASING  (182 % 256)
	{TCAPOMDEVELRECVUSRREJRELEASING, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 15}},
#define   TCAPOMDEVELRECVUSRREJUNEXPLINKRESP  (183 % 256)
	{TCAPOMDEVELRECVUSRREJUNEXPLINKRESP, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 16}},
#define   TCAPOMDEVELRECVUSRREJUNEXPLINKOPER  (184 % 256)
	{TCAPOMDEVELRECVUSRREJUNEXPLINKOPER, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 17}},
#define   TCAPOMDEVELRECVUSRREJUNRECERROR  (185 % 256)
	{TCAPOMDEVELRECVUSRREJUNRECERROR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 18}},
#define   TCAPOMDEVELRECVUSRREJUNEXPERROR  (186 % 256)
	{TCAPOMDEVELRECVUSRREJUNEXPERROR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 19}},
#define   TCAPOMDEVELRECVUSRREJPARMRETRESULT  (187 % 256)
	{TCAPOMDEVELRECVUSRREJPARMRETRESULT, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 20}},
#define   TCAPOMDEVELRECVUSRREJPARMRETERROR  (188 % 256)
	{TCAPOMDEVELRECVUSRREJPARMRETERROR, ASN_COUNTER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 21}},
#define   TCAPOMDEVELRECV5MINVALIDINTERVALS  (189 % 256)
	{TCAPOMDEVELRECV5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 22}},
#define   TCAPOMDEVELRECV15MINVALIDINTERVALS  (190 % 256)
	{TCAPOMDEVELRECV15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelRecvTable, 6, {1, 1, 5, 1, 1, 23}},
#define   TCAPOMDEVELRECVCURRENTPABORTMESSAGETYPE  (194 % 256)
	{TCAPOMDEVELRECVCURRENTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 1}},
#define   TCAPOMDEVELRECVCURRENTPABORTINCORRECTTP  (195 % 256)
	{TCAPOMDEVELRECVCURRENTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 2}},
#define   TCAPOMDEVELRECVCURRENTPABORTBADTP  (196 % 256)
	{TCAPOMDEVELRECVCURRENTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 3}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECCOMP  (197 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 4}},
#define   TCAPOMDEVELRECVCURRENTREJECTMISTYPECOMP  (198 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 5}},
#define   TCAPOMDEVELRECVCURRENTREJECTBADCOMPSTRUCT  (199 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 6}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECLINKID  (200 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 7}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETRES  (201 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 8}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNEXPRETRES  (202 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 9}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETERR  (203 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 10}},
#define   TCAPOMDEVELRECVCURRENTREJECTUNEXPRETERR  (204 % 256)
	{TCAPOMDEVELRECVCURRENTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 11}},
#define   TCAPOMDEVELRECVCURRENTUSRREJDUPINVOKEID  (205 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 12}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNRECOPER  (206 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 13}},
#define   TCAPOMDEVELRECVCURRENTUSRREJPARMINVOKE  (207 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 14}},
#define   TCAPOMDEVELRECVCURRENTUSRREJRELEASING  (208 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 15}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKRESP  (209 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 16}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKOPER  (210 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 17}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNRECERROR  (211 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 18}},
#define   TCAPOMDEVELRECVCURRENTUSRREJUNEXPERROR  (212 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 19}},
#define   TCAPOMDEVELRECVCURRENTUSRREJPARMRETRESULT  (213 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 20}},
#define   TCAPOMDEVELRECVCURRENTUSRREJPARMRETERROR  (214 % 256)
	{TCAPOMDEVELRECVCURRENTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecvCurrentTable, 6, {1, 1, 5, 2, 1, 21}},
#define   TCAPOMDEVELRECV5MININTPABORTMESSAGETYPE  (219 % 256)
	{TCAPOMDEVELRECV5MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 1}},
#define   TCAPOMDEVELRECV5MININTPABORTINCORRECTTP  (220 % 256)
	{TCAPOMDEVELRECV5MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 2}},
#define   TCAPOMDEVELRECV5MININTPABORTBADTP  (221 % 256)
	{TCAPOMDEVELRECV5MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 3}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECCOMP  (222 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 4}},
#define   TCAPOMDEVELRECV5MININTREJECTMISTYPECOMP  (223 % 256)
	{TCAPOMDEVELRECV5MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 5}},
#define   TCAPOMDEVELRECV5MININTREJECTBADCOMPSTRUCT  (224 % 256)
	{TCAPOMDEVELRECV5MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 6}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECLINKID  (225 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 7}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECIDRETRES  (226 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 8}},
#define   TCAPOMDEVELRECV5MININTREJECTUNEXPRETRES  (227 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 9}},
#define   TCAPOMDEVELRECV5MININTREJECTUNRECIDRETERR  (228 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 10}},
#define   TCAPOMDEVELRECV5MININTREJECTUNEXPRETERR  (229 % 256)
	{TCAPOMDEVELRECV5MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 11}},
#define   TCAPOMDEVELRECV5MININTUSRREJDUPINVOKEID  (230 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 12}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNRECOPER  (231 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 13}},
#define   TCAPOMDEVELRECV5MININTUSRREJPARMINVOKE  (232 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 14}},
#define   TCAPOMDEVELRECV5MININTUSRREJRELEASING  (233 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 15}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKRESP  (234 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 16}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKOPER  (235 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 17}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNRECERROR  (236 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 18}},
#define   TCAPOMDEVELRECV5MININTUSRREJUNEXPERROR  (237 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 19}},
#define   TCAPOMDEVELRECV5MININTUSRREJPARMRETRESULT  (238 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 20}},
#define   TCAPOMDEVELRECV5MININTUSRREJPARMRETERROR  (239 % 256)
	{TCAPOMDEVELRECV5MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv5minIntTable, 6, {1, 1, 5, 3, 1, 21}},
#define   TCAPOMDEVELRECV15MININTPABORTMESSAGETYPE  (244 % 256)
	{TCAPOMDEVELRECV15MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 1}},
#define   TCAPOMDEVELRECV15MININTPABORTINCORRECTTP  (245 % 256)
	{TCAPOMDEVELRECV15MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 2}},
#define   TCAPOMDEVELRECV15MININTPABORTBADTP  (246 % 256)
	{TCAPOMDEVELRECV15MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 3}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECCOMP  (247 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 4}},
#define   TCAPOMDEVELRECV15MININTREJECTMISTYPECOMP  (248 % 256)
	{TCAPOMDEVELRECV15MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 5}},
#define   TCAPOMDEVELRECV15MININTREJECTBADCOMPSTRUCT  (249 % 256)
	{TCAPOMDEVELRECV15MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 6}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECLINKID  (250 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 7}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECIDRETRES  (251 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 8}},
#define   TCAPOMDEVELRECV15MININTREJECTUNEXPRETRES  (252 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 9}},
#define   TCAPOMDEVELRECV15MININTREJECTUNRECIDRETERR  (253 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 10}},
#define   TCAPOMDEVELRECV15MININTREJECTUNEXPRETERR  (254 % 256)
	{TCAPOMDEVELRECV15MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 11}},
#define   TCAPOMDEVELRECV15MININTUSRREJDUPINVOKEID  (255 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 12}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNRECOPER  (256 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 13}},
#define   TCAPOMDEVELRECV15MININTUSRREJPARMINVOKE  (257 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 14}},
#define   TCAPOMDEVELRECV15MININTUSRREJRELEASING  (258 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 15}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKRESP  (259 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 16}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKOPER  (260 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 17}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNRECERROR  (261 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 18}},
#define   TCAPOMDEVELRECV15MININTUSRREJUNEXPERROR  (262 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 19}},
#define   TCAPOMDEVELRECV15MININTUSRREJPARMRETRESULT  (263 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 20}},
#define   TCAPOMDEVELRECV15MININTUSRREJPARMRETERROR  (264 % 256)
	{TCAPOMDEVELRECV15MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelRecv15minIntTable, 6, {1, 1, 5, 4, 1, 21}},
#define   TCAPOMDEVELSENTPABORTMESSAGETYPE  (268 % 256)
	{TCAPOMDEVELSENTPABORTMESSAGETYPE, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 1}},
#define   TCAPOMDEVELSENTPABORTINCORRECTTP  (269 % 256)
	{TCAPOMDEVELSENTPABORTINCORRECTTP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 2}},
#define   TCAPOMDEVELSENTPABORTBADTP  (270 % 256)
	{TCAPOMDEVELSENTPABORTBADTP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 3}},
#define   TCAPOMDEVELSENTREJECTUNRECCOMP  (271 % 256)
	{TCAPOMDEVELSENTREJECTUNRECCOMP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 4}},
#define   TCAPOMDEVELSENTREJECTMISTYPECOMP  (272 % 256)
	{TCAPOMDEVELSENTREJECTMISTYPECOMP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 5}},
#define   TCAPOMDEVELSENTREJECTBADCOMPSTRUCT  (273 % 256)
	{TCAPOMDEVELSENTREJECTBADCOMPSTRUCT, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 6}},
#define   TCAPOMDEVELSENTREJECTUNRECLINKID  (274 % 256)
	{TCAPOMDEVELSENTREJECTUNRECLINKID, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 7}},
#define   TCAPOMDEVELSENTREJECTUNRECIDRETRES  (275 % 256)
	{TCAPOMDEVELSENTREJECTUNRECIDRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 8}},
#define   TCAPOMDEVELSENTREJECTUNEXPRETRES  (276 % 256)
	{TCAPOMDEVELSENTREJECTUNEXPRETRES, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 9}},
#define   TCAPOMDEVELSENTREJECTUNRECIDRETERR  (277 % 256)
	{TCAPOMDEVELSENTREJECTUNRECIDRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 10}},
#define   TCAPOMDEVELSENTREJECTUNEXPRETERR  (278 % 256)
	{TCAPOMDEVELSENTREJECTUNEXPRETERR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 11}},
#define   TCAPOMDEVELSENTUSRREJDUPINVOKEID  (279 % 256)
	{TCAPOMDEVELSENTUSRREJDUPINVOKEID, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 12}},
#define   TCAPOMDEVELSENTUSRREJUNRECOPER  (280 % 256)
	{TCAPOMDEVELSENTUSRREJUNRECOPER, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 13}},
#define   TCAPOMDEVELSENTUSRREJPARMINVOKE  (281 % 256)
	{TCAPOMDEVELSENTUSRREJPARMINVOKE, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 14}},
#define   TCAPOMDEVELSENTUSRREJRELEASING  (282 % 256)
	{TCAPOMDEVELSENTUSRREJRELEASING, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 15}},
#define   TCAPOMDEVELSENTUSRREJUNEXPLINKRESP  (283 % 256)
	{TCAPOMDEVELSENTUSRREJUNEXPLINKRESP, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 16}},
#define   TCAPOMDEVELSENTUSRREJUNEXPLINKOPER  (284 % 256)
	{TCAPOMDEVELSENTUSRREJUNEXPLINKOPER, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 17}},
#define   TCAPOMDEVELSENTUSRREJUNRECERROR  (285 % 256)
	{TCAPOMDEVELSENTUSRREJUNRECERROR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 18}},
#define   TCAPOMDEVELSENTUSRREJUNEXPERROR  (286 % 256)
	{TCAPOMDEVELSENTUSRREJUNEXPERROR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 19}},
#define   TCAPOMDEVELSENTUSRREJPARMRETRESULT  (287 % 256)
	{TCAPOMDEVELSENTUSRREJPARMRETRESULT, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 20}},
#define   TCAPOMDEVELSENTUSRREJPARMRETERROR  (288 % 256)
	{TCAPOMDEVELSENTUSRREJPARMRETERROR, ASN_COUNTER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 21}},
#define   TCAPOMDEVELSENT5MINVALIDINTERVALS  (289 % 256)
	{TCAPOMDEVELSENT5MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 22}},
#define   TCAPOMDEVELSENT15MINVALIDINTERVALS  (290 % 256)
	{TCAPOMDEVELSENT15MINVALIDINTERVALS, ASN_INTEGER, RONLY, var_tcapOmDevelSentTable, 6, {1, 1, 5, 5, 1, 23}},
#define   TCAPOMDEVELSENTCURRENTPABORTMESSAGETYPE  (294 % 256)
	{TCAPOMDEVELSENTCURRENTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 1}},
#define   TCAPOMDEVELSENTCURRENTPABORTINCORRECTTP  (295 % 256)
	{TCAPOMDEVELSENTCURRENTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 2}},
#define   TCAPOMDEVELSENTCURRENTPABORTBADTP  (296 % 256)
	{TCAPOMDEVELSENTCURRENTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 3}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECCOMP  (297 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 4}},
#define   TCAPOMDEVELSENTCURRENTREJECTMISTYPECOMP  (298 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 5}},
#define   TCAPOMDEVELSENTCURRENTREJECTBADCOMPSTRUCT  (299 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 6}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECLINKID  (300 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 7}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETRES  (301 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 8}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNEXPRETRES  (302 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 9}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETERR  (303 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 10}},
#define   TCAPOMDEVELSENTCURRENTREJECTUNEXPRETERR  (304 % 256)
	{TCAPOMDEVELSENTCURRENTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 11}},
#define   TCAPOMDEVELSENTCURRENTUSRREJDUPINVOKEID  (305 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 12}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNRECOPER  (306 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 13}},
#define   TCAPOMDEVELSENTCURRENTUSRREJPARMINVOKE  (307 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 14}},
#define   TCAPOMDEVELSENTCURRENTUSRREJRELEASING  (308 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 15}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKRESP  (309 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 16}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKOPER  (310 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 17}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNRECERROR  (311 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 18}},
#define   TCAPOMDEVELSENTCURRENTUSRREJUNEXPERROR  (312 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 19}},
#define   TCAPOMDEVELSENTCURRENTUSRREJPARMRETRESULT  (313 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 20}},
#define   TCAPOMDEVELSENTCURRENTUSRREJPARMRETERROR  (314 % 256)
	{TCAPOMDEVELSENTCURRENTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSentCurrentTable, 6, {1, 1, 5, 6, 1, 21}},
#define   TCAPOMDEVELSENT5MININTPABORTMESSAGETYPE  (319 % 256)
	{TCAPOMDEVELSENT5MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 1}},
#define   TCAPOMDEVELSENT5MININTPABORTINCORRECTTP  (320 % 256)
	{TCAPOMDEVELSENT5MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 2}},
#define   TCAPOMDEVELSENT5MININTPABORTBADTP  (321 % 256)
	{TCAPOMDEVELSENT5MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 3}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECCOMP  (322 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 4}},
#define   TCAPOMDEVELSENT5MININTREJECTMISTYPECOMP  (323 % 256)
	{TCAPOMDEVELSENT5MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 5}},
#define   TCAPOMDEVELSENT5MININTREJECTBADCOMPSTRUCT  (324 % 256)
	{TCAPOMDEVELSENT5MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 6}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECLINKID  (325 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 7}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECIDRETRES  (326 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 8}},
#define   TCAPOMDEVELSENT5MININTREJECTUNEXPRETRES  (327 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 9}},
#define   TCAPOMDEVELSENT5MININTREJECTUNRECIDRETERR  (328 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 10}},
#define   TCAPOMDEVELSENT5MININTREJECTUNEXPRETERR  (329 % 256)
	{TCAPOMDEVELSENT5MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 11}},
#define   TCAPOMDEVELSENT5MININTUSRREJDUPINVOKEID  (330 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 12}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNRECOPER  (331 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 13}},
#define   TCAPOMDEVELSENT5MININTUSRREJPARMINVOKE  (332 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 14}},
#define   TCAPOMDEVELSENT5MININTUSRREJRELEASING  (333 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 15}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKRESP  (334 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 16}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKOPER  (335 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 17}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNRECERROR  (336 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 18}},
#define   TCAPOMDEVELSENT5MININTUSRREJUNEXPERROR  (337 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 19}},
#define   TCAPOMDEVELSENT5MININTUSRREJPARMRETRESULT  (338 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 20}},
#define   TCAPOMDEVELSENT5MININTUSRREJPARMRETERROR  (339 % 256)
	{TCAPOMDEVELSENT5MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent5minIntTable, 6, {1, 1, 5, 7, 1, 21}},
#define   TCAPOMDEVELSENT15MININTPABORTMESSAGETYPE  (344 % 256)
	{TCAPOMDEVELSENT15MININTPABORTMESSAGETYPE, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 1}},
#define   TCAPOMDEVELSENT15MININTPABORTINCORRECTTP  (345 % 256)
	{TCAPOMDEVELSENT15MININTPABORTINCORRECTTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 2}},
#define   TCAPOMDEVELSENT15MININTPABORTBADTP  (346 % 256)
	{TCAPOMDEVELSENT15MININTPABORTBADTP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 3}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECCOMP  (347 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECCOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 4}},
#define   TCAPOMDEVELSENT15MININTREJECTMISTYPECOMP  (348 % 256)
	{TCAPOMDEVELSENT15MININTREJECTMISTYPECOMP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 5}},
#define   TCAPOMDEVELSENT15MININTREJECTBADCOMPSTRUCT  (349 % 256)
	{TCAPOMDEVELSENT15MININTREJECTBADCOMPSTRUCT, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 6}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECLINKID  (350 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECLINKID, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 7}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECIDRETRES  (351 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECIDRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 8}},
#define   TCAPOMDEVELSENT15MININTREJECTUNEXPRETRES  (352 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNEXPRETRES, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 9}},
#define   TCAPOMDEVELSENT15MININTREJECTUNRECIDRETERR  (353 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNRECIDRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 10}},
#define   TCAPOMDEVELSENT15MININTREJECTUNEXPRETERR  (354 % 256)
	{TCAPOMDEVELSENT15MININTREJECTUNEXPRETERR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 11}},
#define   TCAPOMDEVELSENT15MININTUSRREJDUPINVOKEID  (355 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJDUPINVOKEID, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 12}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNRECOPER  (356 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNRECOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 13}},
#define   TCAPOMDEVELSENT15MININTUSRREJPARMINVOKE  (357 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJPARMINVOKE, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 14}},
#define   TCAPOMDEVELSENT15MININTUSRREJRELEASING  (358 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJRELEASING, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 15}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKRESP  (359 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKRESP, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 16}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKOPER  (360 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKOPER, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 17}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNRECERROR  (361 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNRECERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 18}},
#define   TCAPOMDEVELSENT15MININTUSRREJUNEXPERROR  (362 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJUNEXPERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 19}},
#define   TCAPOMDEVELSENT15MININTUSRREJPARMRETRESULT  (363 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJPARMRETRESULT, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 20}},
#define   TCAPOMDEVELSENT15MININTUSRREJPARMRETERROR  (364 % 256)
	{TCAPOMDEVELSENT15MININTUSRREJPARMRETERROR, ASN_GAUGE, RONLY, var_tcapOmDevelSent15minIntTable, 6, {1, 1, 5, 8, 1, 21}},
#define   TCAPOM1STANDINTERVALACTIVATE  (365 % 256)
	{TCAPOM1STANDINTERVALACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 1}},
#define   TCAPOM1STANDINTERVALDEACTIVATE  (366 % 256)
	{TCAPOM1STANDINTERVALDEACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 2}},
#define   TCAPOM5MINACTIVATE    (367 % 256)
	{TCAPOM5MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 3}},
#define   TCAPOM5MINDEAACTIVATE  (368 % 256)
	{TCAPOM5MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 4}},
#define   TCAPOM15MINACTIVATE   (369 % 256)
	{TCAPOM15MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 5}},
#define   TCAPOM15MINDEAACTIVATE  (370 % 256)
	{TCAPOM15MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_tcapOmMIB, 3, {1, 2, 6}},
#define   TCAPOMDISCONTINUITYTIME  (372 % 256)
	{TCAPOMDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_tcapOmMIB, 3, {1, 2, 8}},
#define   TCAPOMTIMESTAMP       (373 % 256)
	{TCAPOMTIMESTAMP, ASN_TIMETICKS, RONLY, var_tcapOmMIB, 3, {1, 2, 9}},
#define   TCAPOM5MINMAXINTERVALS  (374 % 256)
	{TCAPOM5MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_tcapOmMIB, 3, {1, 2, 10}},
#define   TCAPOM15MINMAXINTERVALS  (375 % 256)
	{TCAPOM15MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_tcapOmMIB, 3, {1, 2, 11}},

};

/* (L = length of the oidsuffix) */
struct tcapOmMIB_data *tcapOmMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *tcapOmNodeTableStorage = NULL;
struct header_complex_index *tcapOmNodeCurrentTableStorage = NULL;
struct header_complex_index *tcapOmNode5minIntTableStorage = NULL;
struct header_complex_index *tcapOmNode15minIntTableStorage = NULL;
struct header_complex_index *tcapOmMsgsTableStorage = NULL;
struct header_complex_index *tcapOmMsgsCurrentTableStorage = NULL;
struct header_complex_index *tcapOmMsgs5minIntTableStorage = NULL;
struct header_complex_index *tcapOmMsgs15minIntTableStorage = NULL;
struct header_complex_index *tcapOmAETableStorage = NULL;
struct header_complex_index *tcapOmAECurrentTableStorage = NULL;
struct header_complex_index *tcapOmAE5minIntTableStorage = NULL;
struct header_complex_index *tcapOmAE15minIntTableStorage = NULL;
struct header_complex_index *tcapOmTcTableStorage = NULL;
struct header_complex_index *tcapOmTcCurrentTableStorage = NULL;
struct header_complex_index *tcapOmTc5minIntTableStorage = NULL;
struct header_complex_index *tcapOmTc15minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecvTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecvCurrentTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecv5minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelRecv15minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelSentTableStorage = NULL;
struct header_complex_index *tcapOmDevelSentCurrentTableStorage = NULL;
struct header_complex_index *tcapOmDevelSent5minIntTableStorage = NULL;
struct header_complex_index *tcapOmDevelSent15minIntTableStorage = NULL;

/*
 * init_tcapOmMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_tcapOmMIB(void)
{
	DEBUGMSGTL(("tcapOmMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("tcapOmMIB", tcapOmMIB_variables, variable7, tcapOmMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_tcapOmMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("tcapOmMIB", parse_tcapOmMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNodeTable", parse_tcapOmNodeTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNodeCurrentTable", parse_tcapOmNodeCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNode5minIntTable", parse_tcapOmNode5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmNode15minIntTable", parse_tcapOmNode15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgsTable", parse_tcapOmMsgsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgsCurrentTable", parse_tcapOmMsgsCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgs5minIntTable", parse_tcapOmMsgs5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmMsgs15minIntTable", parse_tcapOmMsgs15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAETable", parse_tcapOmAETable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAECurrentTable", parse_tcapOmAECurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAE5minIntTable", parse_tcapOmAE5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmAE15minIntTable", parse_tcapOmAE15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTcTable", parse_tcapOmTcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTcCurrentTable", parse_tcapOmTcCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTc5minIntTable", parse_tcapOmTc5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmTc15minIntTable", parse_tcapOmTc15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecvTable", parse_tcapOmDevelRecvTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecvCurrentTable", parse_tcapOmDevelRecvCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecv5minIntTable", parse_tcapOmDevelRecv5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelRecv15minIntTable", parse_tcapOmDevelRecv15minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSentTable", parse_tcapOmDevelSentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSentCurrentTable", parse_tcapOmDevelSentCurrentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSent5minIntTable", parse_tcapOmDevelSent5minIntTable, NULL, "HELP STRING");
	snmpd_register_config_handler("tcapOmDevelSent15minIntTable", parse_tcapOmDevelSent15minIntTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNodeTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNodeCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNode5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmNode15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgsCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgs5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmMsgs15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAECurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAE5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmAE15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTcCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTc5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmTc15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecvTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecvCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecv5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelRecv15minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSentCurrentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSent5minIntTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_tcapOmDevelSent15minIntTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
}

/*
 * deinit_tcapOmMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_tcapOmMIB(void)
{
	DEBUGMSGTL(("tcapOmMIB", "deinitializating...  "));
	unregister_mib(tcapOmMIB_variables_oid, sizeof(tcapOmMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("tcapOmMIB");
	snmpd_unregister_config_handler("tcapOmNodeTable");
	snmpd_unregister_config_handler("tcapOmNodeCurrentTable");
	snmpd_unregister_config_handler("tcapOmNode5minIntTable");
	snmpd_unregister_config_handler("tcapOmNode15minIntTable");
	snmpd_unregister_config_handler("tcapOmMsgsTable");
	snmpd_unregister_config_handler("tcapOmMsgsCurrentTable");
	snmpd_unregister_config_handler("tcapOmMsgs5minIntTable");
	snmpd_unregister_config_handler("tcapOmMsgs15minIntTable");
	snmpd_unregister_config_handler("tcapOmAETable");
	snmpd_unregister_config_handler("tcapOmAECurrentTable");
	snmpd_unregister_config_handler("tcapOmAE5minIntTable");
	snmpd_unregister_config_handler("tcapOmAE15minIntTable");
	snmpd_unregister_config_handler("tcapOmTcTable");
	snmpd_unregister_config_handler("tcapOmTcCurrentTable");
	snmpd_unregister_config_handler("tcapOmTc5minIntTable");
	snmpd_unregister_config_handler("tcapOmTc15minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelRecvTable");
	snmpd_unregister_config_handler("tcapOmDevelRecvCurrentTable");
	snmpd_unregister_config_handler("tcapOmDevelRecv5minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelRecv15minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelSentTable");
	snmpd_unregister_config_handler("tcapOmDevelSentCurrentTable");
	snmpd_unregister_config_handler("tcapOmDevelSent5minIntTable");
	snmpd_unregister_config_handler("tcapOmDevelSent15minIntTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
}

int
term_tcapOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_tcapOmMIB();
	return 0;
}

/*
 * tcapOmMIB_add(): adds a structure node for scalars
 */
int
tcapOmMIB_add(struct tcapOmMIB_data *thedata)
{
	DEBUGMSGTL(("tcapOmMIB", "adding data...  "));
	tcapOmMIBStorage = thedata;
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmMIB(): parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmMIB_data);

	DEBUGMSGTL(("tcapOmMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
#if 0
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->tcapOm1stAndIntervalActivate, &tmpsize);
	StorageTmp->tcapOm1stAndIntervalActivateLen = tmpsize;
	if (StorageTmp->tcapOm1stAndIntervalActivate == NULL) {
		config_perror("invalid specification for tcapOm1stAndIntervalActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->tcapOm1stAndIntervalDeactivate, &tmpsize);
	StorageTmp->tcapOm1stAndIntervalDeactivateLen = tmpsize;
	if (StorageTmp->tcapOm1stAndIntervalDeactivate == NULL) {
		config_perror("invalid specification for tcapOm1stAndIntervalDeactivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->tcapOm5MinActivate, &tmpsize);
	StorageTmp->tcapOm5MinActivateLen = tmpsize;
	if (StorageTmp->tcapOm5MinActivate == NULL) {
		config_perror("invalid specification for tcapOm5MinActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->tcapOm5MinDeaActivate, &tmpsize);
	StorageTmp->tcapOm5MinDeaActivateLen = tmpsize;
	if (StorageTmp->tcapOm5MinDeaActivate == NULL) {
		config_perror("invalid specification for tcapOm5MinDeaActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->tcapOm15MinActivate, &tmpsize);
	StorageTmp->tcapOm15MinActivateLen = tmpsize;
	if (StorageTmp->tcapOm15MinActivate == NULL) {
		config_perror("invalid specification for tcapOm15MinActivate");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->tcapOm15MinDeaActivate, &tmpsize);
	StorageTmp->tcapOm15MinDeaActivateLen = tmpsize;
	if (StorageTmp->tcapOm15MinDeaActivate == NULL) {
		config_perror("invalid specification for tcapOm15MinDeaActivate");
		return;
	}

	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->tcapOmDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->tcapOmTimeStamp, &tmpsize);
#endif
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOm5MinMaxIntervals, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapOm15MinMaxIntervals, &tmpsize);

	tcapOmMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
}

/*
 * store_tcapOmMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMIB_data *StorageTmp;

	DEBUGMSGTL(("tcapOmMIB", "storing data...  "));
	refresh_tcapOmMIB();
	if ((StorageTmp = tcapOmMIBStorage) == NULL) {
		DEBUGMSGTL(("tcapOmMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->tcapOmMIBStorageType == ST_NONVOLATILE) */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "tcapOmMIB ");
		cptr = line + strlen(line);
#if 0
		tmpsize = StorageTmp->tcapOm1stAndIntervalActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->tcapOm1stAndIntervalActivate, &tmpsize);
		tmpsize = StorageTmp->tcapOm1stAndIntervalDeactivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->tcapOm1stAndIntervalDeactivate, &tmpsize);
		tmpsize = StorageTmp->tcapOm5MinActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->tcapOm5MinActivate, &tmpsize);
		tmpsize = StorageTmp->tcapOm5MinDeaActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->tcapOm5MinDeaActivate, &tmpsize);
		tmpsize = StorageTmp->tcapOm15MinActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->tcapOm15MinActivate, &tmpsize);
		tmpsize = StorageTmp->tcapOm15MinDeaActivateLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->tcapOm15MinDeaActivate, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->tcapOmDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->tcapOmTimeStamp, &tmpsize);
#endif
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOm5MinMaxIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapOm15MinMaxIntervals, &tmpsize);

		snmpd_store_config(line);
	}
	DEBUGMSGTL(("tcapOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_tcapOmMIB: refresh tcapOmMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_tcapOmMIB(void)
{
	if (tcapOmMIBStorage == NULL) {
		struct tcapOmMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(tcapOmMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->tcapOm5MinMaxIntervals = 96;
		StorageNew->tcapOm15MinMaxIntervals = 96;

		tcapOmMIBStorage = StorageNew;
		tcapOmMIB_refresh = 1;
	}
	if (tcapOmMIB_refresh == 0)
		return;
	tcapOmMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_tcapOmMIB(): locate variables in tcapOmMIB
 *
 * This function is called every time the agent gets a request for a scalar variable that might be
 * found within your mib section registered above.  It is up to you to do the right thing and return
 * the correct value.  You should also correct the value of "var_len" if necessary.
 *
 * Please see the documentation for more information about writing module extensions, and check out
 * the examples in the examples and mibII directories.
 */
u_char *
var_tcapOmMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_tcapOmMIB();
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOM1STANDINTERVALACTIVATE:
		*write_method = write_tcapOm1stAndIntervalActivate;
		*var_len = StorageTmp->tcapOm1stAndIntervalActivateLen;
		return (u_char *) StorageTmp->tcapOm1stAndIntervalActivate;
	case TCAPOM1STANDINTERVALDEACTIVATE:
		*write_method = write_tcapOm1stAndIntervalDeactivate;
		*var_len = StorageTmp->tcapOm1stAndIntervalDeactivateLen;
		return (u_char *) StorageTmp->tcapOm1stAndIntervalDeactivate;
	case TCAPOM5MINACTIVATE:
		*write_method = write_tcapOm5MinActivate;
		*var_len = StorageTmp->tcapOm5MinActivateLen;
		return (u_char *) StorageTmp->tcapOm5MinActivate;
	case TCAPOM5MINDEAACTIVATE:
		*write_method = write_tcapOm5MinDeaActivate;
		*var_len = StorageTmp->tcapOm5MinDeaActivateLen;
		return (u_char *) StorageTmp->tcapOm5MinDeaActivate;
	case TCAPOM15MINACTIVATE:
		*write_method = write_tcapOm15MinActivate;
		*var_len = StorageTmp->tcapOm15MinActivateLen;
		return (u_char *) StorageTmp->tcapOm15MinActivate;
	case TCAPOM15MINDEAACTIVATE:
		*write_method = write_tcapOm15MinDeaActivate;
		*var_len = StorageTmp->tcapOm15MinDeaActivateLen;
		return (u_char *) StorageTmp->tcapOm15MinDeaActivate;
	case TCAPOMDISCONTINUITYTIME:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDiscontinuityTime);
		return (u_char *) &StorageTmp->tcapOmDiscontinuityTime;
	case TCAPOMTIMESTAMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTimeStamp);
		return (u_char *) &StorageTmp->tcapOmTimeStamp;
	case TCAPOM5MINMAXINTERVALS:
		*write_method = write_tcapOm5MinMaxIntervals;
		*var_len = sizeof(StorageTmp->tcapOm5MinMaxIntervals);
		return (u_char *) &StorageTmp->tcapOm5MinMaxIntervals;
	case TCAPOM15MINMAXINTERVALS:
		*write_method = write_tcapOm15MinMaxIntervals;
		*var_len = sizeof(StorageTmp->tcapOm15MinMaxIntervals);
		return (u_char *) &StorageTmp->tcapOm15MinMaxIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * tcapOmNodeTable_add(): adds a structure node to our data set
 */
int
tcapOmNodeTable_add(struct tcapOmNodeTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNodeTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&tcapOmNodeTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNodeTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNodeTable_del(): delete a structure
 */
int
tcapOmNodeTable_del(struct tcapOmNodeTable_data **thedata)
{
	struct tcapOmNodeTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNodeTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmNodeTable(): parse configuration file for tcapOmNodeTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmNodeTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNodeTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmNodeTable_data);

	DEBUGMSGTL(("tcapOmNodeTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmNodeComponentsRecv, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmNode5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmNode15minValidIntervals, &tmpsize);

	tcapOmNodeTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
}

/*
 * store_tcapOmNodeTable(): store configuraiton file for tcapOmNodeTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNodeTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNodeTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNodeTable", "storing data...  "));
	refresh_tcapOmNodeTable();
	(void) tmpsize;
	for (hcindex = tcapOmNodeTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNodeTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmNodeTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNodeTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmNodeComponentsRecv, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmNode5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmNode15minValidIntervals, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNodeTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNodeCurrentTable_add(): adds a structure node to our data set
 */
int
tcapOmNodeCurrentTable_add(struct tcapOmNodeCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&tcapOmNodeCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNodeCurrentTable_del(): delete a structure
 */
int
tcapOmNodeCurrentTable_del(struct tcapOmNodeCurrentTable_data **thedata)
{
	struct tcapOmNodeCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmNodeCurrentTable(): parse configuration file for tcapOmNodeCurrentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmNodeCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNodeCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmNodeCurrentTable_data);

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNodeCurrentComponentsRecv, &tmpsize);

	tcapOmNodeCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
}

/*
 * store_tcapOmNodeCurrentTable(): store configuraiton file for tcapOmNodeCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNodeCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNodeCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNodeCurrentTable", "storing data...  "));
	refresh_tcapOmNodeCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmNodeCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNodeCurrentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmNodeCurrentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNodeCurrentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNodeCurrentComponentsRecv, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNodeCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNode5minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmNode5minIntTable_add(struct tcapOmNode5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmNode5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNode5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNode5minIntTable_del(): delete a structure
 */
int
tcapOmNode5minIntTable_del(struct tcapOmNode5minIntTable_data **thedata)
{
	struct tcapOmNode5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmNode5minIntTable(): parse configuration file for tcapOmNode5minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmNode5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNode5minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmNode5minIntTable_data);

	DEBUGMSGTL(("tcapOmNode5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode5minIntComponentsRecv, &tmpsize);

	tcapOmNode5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
}

/*
 * store_tcapOmNode5minIntTable(): store configuraiton file for tcapOmNode5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNode5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNode5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNode5minIntTable", "storing data...  "));
	refresh_tcapOmNode5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmNode5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNode5minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmNode5minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNode5minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode5minIntComponentsRecv, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNode5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNode15minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmNode15minIntTable_add(struct tcapOmNode15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmNode15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmNode15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmNode15minIntTable_del(): delete a structure
 */
int
tcapOmNode15minIntTable_del(struct tcapOmNode15minIntTable_data **thedata)
{
	struct tcapOmNode15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmNode15minIntTable(): parse configuration file for tcapOmNode15minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmNode15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmNode15minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmNode15minIntTable_data);

	DEBUGMSGTL(("tcapOmNode15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntComponentsSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmNode15minIntComponentsRecv, &tmpsize);

	tcapOmNode15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
}

/*
 * store_tcapOmNode15minIntTable(): store configuraiton file for tcapOmNode15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmNode15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmNode15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmNode15minIntTable", "storing data...  "));
	refresh_tcapOmNode15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmNode15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmNode15minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmNode15minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmNode15minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntComponentsSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmNode15minIntComponentsRecv, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmNode15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgsTable_add(): adds a structure node to our data set
 */
int
tcapOmMsgsTable_add(struct tcapOmMsgsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&tcapOmMsgsTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgsTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgsTable_del(): delete a structure
 */
int
tcapOmMsgsTable_del(struct tcapOmMsgsTable_data **thedata)
{
	struct tcapOmMsgsTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgsTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmMsgsTable(): parse configuration file for tcapOmMsgsTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmMsgsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmMsgsTable_data);

	DEBUGMSGTL(("tcapOmMsgsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmMsgsMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmMsgsMessagesRecv, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmMsgs5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmMsgs15minValidIntervals, &tmpsize);

	tcapOmMsgsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
}

/*
 * store_tcapOmMsgsTable(): store configuraiton file for tcapOmMsgsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgsTable", "storing data...  "));
	refresh_tcapOmMsgsTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgsTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmMsgsTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgsTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmMsgsMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmMsgsMessagesRecv, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmMsgs5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmMsgs15minValidIntervals, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgsCurrentTable_add(): adds a structure node to our data set
 */
int
tcapOmMsgsCurrentTable_add(struct tcapOmMsgsCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));

	header_complex_add_data(&tcapOmMsgsCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgsCurrentTable_del(): delete a structure
 */
int
tcapOmMsgsCurrentTable_del(struct tcapOmMsgsCurrentTable_data **thedata)
{
	struct tcapOmMsgsCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmMsgsCurrentTable(): parse configuration file for tcapOmMsgsCurrentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmMsgsCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgsCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmMsgsCurrentTable_data);

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgsCurrentMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgsCurrentMessagesRecv, &tmpsize);

	tcapOmMsgsCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
}

/*
 * store_tcapOmMsgsCurrentTable(): store configuraiton file for tcapOmMsgsCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgsCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgsCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "storing data...  "));
	refresh_tcapOmMsgsCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgsCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgsCurrentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmMsgsCurrentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgsCurrentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgsCurrentMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgsCurrentMessagesRecv, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgsCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgs5minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmMsgs5minIntTable_add(struct tcapOmMsgs5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmMsgs5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgs5minIntTable_del(): delete a structure
 */
int
tcapOmMsgs5minIntTable_del(struct tcapOmMsgs5minIntTable_data **thedata)
{
	struct tcapOmMsgs5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmMsgs5minIntTable(): parse configuration file for tcapOmMsgs5minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmMsgs5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgs5minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmMsgs5minIntTable_data);

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs5minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs5minIntMessagesRecv, &tmpsize);

	tcapOmMsgs5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
}

/*
 * store_tcapOmMsgs5minIntTable(): store configuraiton file for tcapOmMsgs5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgs5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgs5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "storing data...  "));
	refresh_tcapOmMsgs5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgs5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgs5minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmMsgs5minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgs5minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs5minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs5minIntMessagesRecv, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgs5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgs15minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmMsgs15minIntTable_add(struct tcapOmMsgs15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* sccpNetworkEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->sccpNetworkEntityId, sizeof(thedata->sccpNetworkEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmMsgs15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmMsgs15minIntTable_del(): delete a structure
 */
int
tcapOmMsgs15minIntTable_del(struct tcapOmMsgs15minIntTable_data **thedata)
{
	struct tcapOmMsgs15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmMsgs15minIntTable(): parse configuration file for tcapOmMsgs15minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmMsgs15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmMsgs15minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmMsgs15minIntTable_data);

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->sccpNetworkEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs15minIntMessagesSent, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmMsgs15minIntMessagesRecv, &tmpsize);

	tcapOmMsgs15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
}

/*
 * store_tcapOmMsgs15minIntTable(): store configuraiton file for tcapOmMsgs15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmMsgs15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmMsgs15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "storing data...  "));
	refresh_tcapOmMsgs15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmMsgs15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmMsgs15minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmMsgs15minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmMsgs15minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->sccpNetworkEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs15minIntMessagesSent, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmMsgs15minIntMessagesRecv, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmMsgs15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAETable_add(): adds a structure node to our data set
 */
int
tcapOmAETable_add(struct tcapOmAETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));

	header_complex_add_data(&tcapOmAETableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAETable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAETable_del(): delete a structure
 */
int
tcapOmAETable_del(struct tcapOmAETable_data **thedata)
{
	struct tcapOmAETable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAETable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmAETable(): parse configuration file for tcapOmAETable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmAETable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAETable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmAETable_data);

	DEBUGMSGTL(("tcapOmAETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAENewTransactions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAENotUsed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAECummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmAEThresholdExceeded, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmAE5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmAE15minValidIntervals, &tmpsize);

	tcapOmAETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
}

/*
 * store_tcapOmAETable(): store configuraiton file for tcapOmAETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAETable", "storing data...  "));
	refresh_tcapOmAETable();
	(void) tmpsize;
	for (hcindex = tcapOmAETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAETable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmAETableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAETable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAENewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAENotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAECummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmAEThresholdExceeded, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmAE5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmAE15minValidIntervals, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAECurrentTable_add(): adds a structure node to our data set
 */
int
tcapOmAECurrentTable_add(struct tcapOmAECurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAECurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));

	header_complex_add_data(&tcapOmAECurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAECurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAECurrentTable_del(): delete a structure
 */
int
tcapOmAECurrentTable_del(struct tcapOmAECurrentTable_data **thedata)
{
	struct tcapOmAECurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAECurrentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmAECurrentTable(): parse configuration file for tcapOmAECurrentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmAECurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAECurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmAECurrentTable_data);

	DEBUGMSGTL(("tcapOmAECurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentNewTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentCummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAECurrentThresholdExceeded, &tmpsize);

	tcapOmAECurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
}

/*
 * store_tcapOmAECurrentTable(): store configuraiton file for tcapOmAECurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAECurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAECurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAECurrentTable", "storing data...  "));
	refresh_tcapOmAECurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmAECurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAECurrentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmAECurrentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAECurrentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentNewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentCummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAECurrentThresholdExceeded, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAECurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAE5minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmAE5minIntTable_add(struct tcapOmAE5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmAE5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAE5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAE5minIntTable_del(): delete a structure
 */
int
tcapOmAE5minIntTable_del(struct tcapOmAE5minIntTable_data **thedata)
{
	struct tcapOmAE5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmAE5minIntTable(): parse configuration file for tcapOmAE5minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmAE5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAE5minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmAE5minIntTable_data);

	DEBUGMSGTL(("tcapOmAE5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntNewTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntCummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE5minIntThresholdExceeded, &tmpsize);

	tcapOmAE5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
}

/*
 * store_tcapOmAE5minIntTable(): store configuraiton file for tcapOmAE5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAE5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAE5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAE5minIntTable", "storing data...  "));
	refresh_tcapOmAE5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmAE5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAE5minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmAE5minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAE5minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntNewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntCummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE5minIntThresholdExceeded, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAE5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAE15minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmAE15minIntTable_add(struct tcapOmAE15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmAE15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmAE15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmAE15minIntTable_del(): delete a structure
 */
int
tcapOmAE15minIntTable_del(struct tcapOmAE15minIntTable_data **thedata)
{
	struct tcapOmAE15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmAE15minIntTable(): parse configuration file for tcapOmAE15minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmAE15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmAE15minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmAE15minIntTable_data);

	DEBUGMSGTL(("tcapOmAE15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntMeasurementDeleted, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntNewTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntMeanOpenTransactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntCummulativeMeanDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntMaximumOpenTranactions, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmAE15minIntThresholdExceeded, &tmpsize);

	tcapOmAE15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
}

/*
 * store_tcapOmAE15minIntTable(): store configuraiton file for tcapOmAE15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmAE15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmAE15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmAE15minIntTable", "storing data...  "));
	refresh_tcapOmAE15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmAE15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmAE15minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmAE15minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmAE15minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntMeasurementDeleted, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntNewTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntMeanOpenTransactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntCummulativeMeanDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntMaximumOpenTranactions, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmAE15minIntThresholdExceeded, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmAE15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTcTable_add(): adds a structure node to our data set
 */
int
tcapOmTcTable_add(struct tcapOmTcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));

	header_complex_add_data(&tcapOmTcTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTcTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTcTable_del(): delete a structure
 */
int
tcapOmTcTable_del(struct tcapOmTcTable_data **thedata)
{
	struct tcapOmTcTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTcTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmTcTable(): parse configuration file for tcapOmTcTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmTcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTcTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmTcTable_data);

	DEBUGMSGTL(("tcapOmTcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcNotUsed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmTcTpErrors, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmTc5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmTc15minValidIntervals, &tmpsize);

	tcapOmTcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
}

/*
 * store_tcapOmTcTable(): store configuraiton file for tcapOmTcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTcTable", "storing data...  "));
	refresh_tcapOmTcTable();
	(void) tmpsize;
	for (hcindex = tcapOmTcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTcTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmTcTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTcTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmTcTpErrors, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmTc5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmTc15minValidIntervals, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTcCurrentTable_add(): adds a structure node to our data set
 */
int
tcapOmTcCurrentTable_add(struct tcapOmTcCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));

	header_complex_add_data(&tcapOmTcCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTcCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTcCurrentTable_del(): delete a structure
 */
int
tcapOmTcCurrentTable_del(struct tcapOmTcCurrentTable_data **thedata)
{
	struct tcapOmTcCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmTcCurrentTable(): parse configuration file for tcapOmTcCurrentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmTcCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTcCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmTcCurrentTable_data);

	DEBUGMSGTL(("tcapOmTcCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTcCurrentTpErrors, &tmpsize);

	tcapOmTcCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
}

/*
 * store_tcapOmTcCurrentTable(): store configuraiton file for tcapOmTcCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTcCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTcCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTcCurrentTable", "storing data...  "));
	refresh_tcapOmTcCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmTcCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTcCurrentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmTcCurrentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTcCurrentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTcCurrentTpErrors, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTcCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTc5minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmTc5minIntTable_add(struct tcapOmTc5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmTc5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTc5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTc5minIntTable_del(): delete a structure
 */
int
tcapOmTc5minIntTable_del(struct tcapOmTc5minIntTable_data **thedata)
{
	struct tcapOmTc5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmTc5minIntTable(): parse configuration file for tcapOmTc5minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmTc5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTc5minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmTc5minIntTable_data);

	DEBUGMSGTL(("tcapOmTc5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc5minIntTpErrors, &tmpsize);

	tcapOmTc5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
}

/*
 * store_tcapOmTc5minIntTable(): store configuraiton file for tcapOmTc5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTc5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTc5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTc5minIntTable", "storing data...  "));
	refresh_tcapOmTc5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmTc5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTc5minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmTc5minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTc5minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc5minIntTpErrors, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTc5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTc15minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmTc15minIntTable_add(struct tcapOmTc15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmTc15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmTc15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmTc15minIntTable_del(): delete a structure
 */
int
tcapOmTc15minIntTable_del(struct tcapOmTc15minIntTable_data **thedata)
{
	struct tcapOmTc15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmTc15minIntTable(): parse configuration file for tcapOmTc15minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmTc15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmTc15minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmTc15minIntTable_data);

	DEBUGMSGTL(("tcapOmTc15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntRejectRecvResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortSentUnrecTid, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntRejectSentResourceLim, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntTcUserCancel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntMessagesDiscarded, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntNotUsed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntPabortsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntTcUserRejectsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmTc15minIntTpErrors, &tmpsize);

	tcapOmTc15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
}

/*
 * store_tcapOmTc15minIntTable(): store configuraiton file for tcapOmTc15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmTc15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmTc15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmTc15minIntTable", "storing data...  "));
	refresh_tcapOmTc15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmTc15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmTc15minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmTc15minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmTc15minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntRejectRecvResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortSentUnrecTid, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntRejectSentResourceLim, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntTcUserCancel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntMessagesDiscarded, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntNotUsed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntPabortsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntTcUserRejectsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmTc15minIntTpErrors, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmTc15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecvTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelRecvTable_add(struct tcapOmDevelRecvTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));

	header_complex_add_data(&tcapOmDevelRecvTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecvTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecvTable_del(): delete a structure
 */
int
tcapOmDevelRecvTable_del(struct tcapOmDevelRecvTable_data **thedata)
{
	struct tcapOmDevelRecvTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelRecvTable(): parse configuration file for tcapOmDevelRecvTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelRecvTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecvTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelRecvTable_data);

	DEBUGMSGTL(("tcapOmDevelRecvTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelRecvUsrRejParmRetError, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelRecv5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelRecv15minValidIntervals, &tmpsize);

	tcapOmDevelRecvTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecvTable(): store configuraiton file for tcapOmDevelRecvTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecvTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecvTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecvTable", "storing data...  "));
	refresh_tcapOmDevelRecvTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecvTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecvTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelRecvTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecvTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelRecvUsrRejParmRetError, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelRecv5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelRecv15minValidIntervals, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecvTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecvCurrentTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelRecvCurrentTable_add(struct tcapOmDevelRecvCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));

	header_complex_add_data(&tcapOmDevelRecvCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecvCurrentTable_del(): delete a structure
 */
int
tcapOmDevelRecvCurrentTable_del(struct tcapOmDevelRecvCurrentTable_data **thedata)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelRecvCurrentTable(): parse configuration file for tcapOmDevelRecvCurrentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelRecvCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecvCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelRecvCurrentTable_data);

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError, &tmpsize);

	tcapOmDevelRecvCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecvCurrentTable(): store configuraiton file for tcapOmDevelRecvCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecvCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecvCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "storing data...  "));
	refresh_tcapOmDevelRecvCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecvCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecvCurrentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelRecvCurrentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecvCurrentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecvCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecv5minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelRecv5minIntTable_add(struct tcapOmDevelRecv5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmDevelRecv5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecv5minIntTable_del(): delete a structure
 */
int
tcapOmDevelRecv5minIntTable_del(struct tcapOmDevelRecv5minIntTable_data **thedata)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelRecv5minIntTable(): parse configuration file for tcapOmDevelRecv5minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelRecv5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecv5minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelRecv5minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError, &tmpsize);

	tcapOmDevelRecv5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecv5minIntTable(): store configuraiton file for tcapOmDevelRecv5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecv5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecv5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "storing data...  "));
	refresh_tcapOmDevelRecv5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecv5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecv5minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelRecv5minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecv5minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecv5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecv15minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelRecv15minIntTable_add(struct tcapOmDevelRecv15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapApplicationEntityId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapApplicationEntityId, sizeof(thedata->tcapApplicationEntityId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmDevelRecv15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelRecv15minIntTable_del(): delete a structure
 */
int
tcapOmDevelRecv15minIntTable_del(struct tcapOmDevelRecv15minIntTable_data **thedata)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelRecv15minIntTable(): parse configuration file for tcapOmDevelRecv15minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelRecv15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelRecv15minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelRecv15minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapApplicationEntityId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError, &tmpsize);

	tcapOmDevelRecv15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelRecv15minIntTable(): store configuraiton file for tcapOmDevelRecv15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelRecv15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelRecv15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "storing data...  "));
	refresh_tcapOmDevelRecv15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelRecv15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelRecv15minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelRecv15minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelRecv15minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapApplicationEntityId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelRecv15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSentTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelSentTable_add(struct tcapOmDevelSentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));

	header_complex_add_data(&tcapOmDevelSentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSentTable_del(): delete a structure
 */
int
tcapOmDevelSentTable_del(struct tcapOmDevelSentTable_data **thedata)
{
	struct tcapOmDevelSentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelSentTable(): parse configuration file for tcapOmDevelSentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelSentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelSentTable_data);

	DEBUGMSGTL(("tcapOmDevelSentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->tcapOmDevelSentUsrRejParmRetError, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelSent5minValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmDevelSent15minValidIntervals, &tmpsize);

	tcapOmDevelSentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
}

/*
 * store_tcapOmDevelSentTable(): store configuraiton file for tcapOmDevelSentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSentTable", "storing data...  "));
	refresh_tcapOmDevelSentTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelSentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->tcapOmDevelSentUsrRejParmRetError, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelSent5minValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmDevelSent15minValidIntervals, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSentCurrentTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelSentCurrentTable_add(struct tcapOmDevelSentCurrentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));

	header_complex_add_data(&tcapOmDevelSentCurrentTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSentCurrentTable_del(): delete a structure
 */
int
tcapOmDevelSentCurrentTable_del(struct tcapOmDevelSentCurrentTable_data **thedata)
{
	struct tcapOmDevelSentCurrentTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelSentCurrentTable(): parse configuration file for tcapOmDevelSentCurrentTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelSentCurrentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSentCurrentTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelSentCurrentTable_data);

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError, &tmpsize);

	tcapOmDevelSentCurrentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
}

/*
 * store_tcapOmDevelSentCurrentTable(): store configuraiton file for tcapOmDevelSentCurrentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSentCurrentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSentCurrentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "storing data...  "));
	refresh_tcapOmDevelSentCurrentTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSentCurrentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSentCurrentTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelSentCurrentTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSentCurrentTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSentCurrentTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSent5minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelSent5minIntTable_add(struct tcapOmDevelSent5minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmDevelSent5minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSent5minIntTable_del(): delete a structure
 */
int
tcapOmDevelSent5minIntTable_del(struct tcapOmDevelSent5minIntTable_data **thedata)
{
	struct tcapOmDevelSent5minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelSent5minIntTable(): parse configuration file for tcapOmDevelSent5minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelSent5minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSent5minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelSent5minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError, &tmpsize);

	tcapOmDevelSent5minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelSent5minIntTable(): store configuraiton file for tcapOmDevelSent5minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSent5minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSent5minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "storing data...  "));
	refresh_tcapOmDevelSent5minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSent5minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSent5minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelSent5minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSent5minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSent5minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSent15minIntTable_add(): adds a structure node to our data set
 */
int
tcapOmDevelSent15minIntTable_add(struct tcapOmDevelSent15minIntTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* tcapTcUserId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->tcapTcUserId, sizeof(thedata->tcapTcUserId));
	/* tcapOmInterval */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->tcapOmInterval, sizeof(thedata->tcapOmInterval));

	header_complex_add_data(&tcapOmDevelSent15minIntTableStorage, vars, thedata);
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "registered an entry\n"));
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * tcapOmDevelSent15minIntTable_del(): delete a structure
 */
int
tcapOmDevelSent15minIntTable_del(struct tcapOmDevelSent15minIntTable_data **thedata)
{
	struct tcapOmDevelSent15minIntTable_data *StorageDel;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_tcapOmDevelSent15minIntTable(): parse configuration file for tcapOmDevelSent15minIntTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_tcapOmDevelSent15minIntTable(const char *token, char *line)
{
	size_t tmpsize;
	struct tcapOmDevelSent15minIntTable_data *StorageTmp = SNMP_MALLOC_STRUCT(tcapOmDevelSent15minIntTable_data);

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->tcapTcUserId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->tcapOmInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntPabortMessageType, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntPabortBadTp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError, &tmpsize);

	tcapOmDevelSent15minIntTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
}

/*
 * store_tcapOmDevelSent15minIntTable(): store configuraiton file for tcapOmDevelSent15minIntTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_tcapOmDevelSent15minIntTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct tcapOmDevelSent15minIntTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "storing data...  "));
	refresh_tcapOmDevelSent15minIntTable();
	(void) tmpsize;
	for (hcindex = tcapOmDevelSent15minIntTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct tcapOmDevelSent15minIntTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->tcapOmDevelSent15minIntTableStorageType == ST_NONVOLATILE) */
		if (0) {
			memset(line, 0, sizeof(line));
			strcat(line, "tcapOmDevelSent15minIntTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->tcapTcUserId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->tcapOmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntPabortMessageType, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntPabortBadTp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError, &tmpsize);

			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("tcapOmDevelSent15minIntTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_tcapOmNodeTable(): refresh tcapOmNodeTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNodeTable(void)
{
	if (tcapOmNodeTable_refresh == 0)
		return;
	tcapOmNodeTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmNodeTable_row(): refresh tcapOmNodeTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNodeTable_row(struct tcapOmNodeTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNodeTable_request == sa_request)
		return;
	StorageTmp->tcapOmNodeTable_request = sa_request;
}

/*
 * var_tcapOmNodeTable(): locate variables in tcapOmNodeTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNodeTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNodeTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNodeTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmNodeTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNodeTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNodeTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMNODEMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNodeMessagesSent;
	case TCAPOMNODEMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNodeMessagesRecv;
	case TCAPOMNODECOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNodeComponentsSent;
	case TCAPOMNODECOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNodeComponentsRecv;
	case TCAPOMNODE5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmNode5minValidIntervals;
	case TCAPOMNODE15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmNode15minValidIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmNodeCurrentTable(): refresh tcapOmNodeCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNodeCurrentTable(void)
{
	if (tcapOmNodeCurrentTable_refresh == 0)
		return;
	tcapOmNodeCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmNodeCurrentTable_row(): refresh tcapOmNodeCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNodeCurrentTable_row(struct tcapOmNodeCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNodeCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmNodeCurrentTable_request = sa_request;
}

/*
 * var_tcapOmNodeCurrentTable(): locate variables in tcapOmNodeCurrentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNodeCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNodeCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNodeCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmNodeCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNodeCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNodeCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMNODECURRENTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentMessagesSent;
	case TCAPOMNODECURRENTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentMessagesRecv;
	case TCAPOMNODECURRENTCOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentComponentsSent;
	case TCAPOMNODECURRENTCOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNodeCurrentComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNodeCurrentComponentsRecv;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmNode5minIntTable(): refresh tcapOmNode5minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNode5minIntTable(void)
{
	if (tcapOmNode5minIntTable_refresh == 0)
		return;
	tcapOmNode5minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmNode5minIntTable_row(): refresh tcapOmNode5minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNode5minIntTable_row(struct tcapOmNode5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNode5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmNode5minIntTable_request = sa_request;
}

/*
 * var_tcapOmNode5minIntTable(): locate variables in tcapOmNode5minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNode5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNode5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNode5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmNode5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNode5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNode5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMNODE5MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNode5minIntMessagesSent;
	case TCAPOMNODE5MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNode5minIntMessagesRecv;
	case TCAPOMNODE5MININTCOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNode5minIntComponentsSent;
	case TCAPOMNODE5MININTCOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode5minIntComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNode5minIntComponentsRecv;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmNode15minIntTable(): refresh tcapOmNode15minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmNode15minIntTable(void)
{
	if (tcapOmNode15minIntTable_refresh == 0)
		return;
	tcapOmNode15minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmNode15minIntTable_row(): refresh tcapOmNode15minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmNode15minIntTable_row(struct tcapOmNode15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmNode15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmNode15minIntTable_request = sa_request;
}

/*
 * var_tcapOmNode15minIntTable(): locate variables in tcapOmNode15minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmNode15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmNode15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmNode15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmNode15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmNode15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmNode15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMNODE15MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmNode15minIntMessagesSent;
	case TCAPOMNODE15MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmNode15minIntMessagesRecv;
	case TCAPOMNODE15MININTCOMPONENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntComponentsSent);
		return (u_char *) &StorageTmp->tcapOmNode15minIntComponentsSent;
	case TCAPOMNODE15MININTCOMPONENTSRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmNode15minIntComponentsRecv);
		return (u_char *) &StorageTmp->tcapOmNode15minIntComponentsRecv;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmMsgsTable(): refresh tcapOmMsgsTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgsTable(void)
{
	if (tcapOmMsgsTable_refresh == 0)
		return;
	tcapOmMsgsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmMsgsTable_row(): refresh tcapOmMsgsTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgsTable_row(struct tcapOmMsgsTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgsTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgsTable_request = sa_request;
}

/*
 * var_tcapOmMsgsTable(): locate variables in tcapOmMsgsTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmMsgsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMMSGSMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgsMessagesSent;
	case TCAPOMMSGSMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgsMessagesRecv;
	case TCAPOMMSGS5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmMsgs5minValidIntervals;
	case TCAPOMMSGS15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmMsgs15minValidIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmMsgsCurrentTable(): refresh tcapOmMsgsCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgsCurrentTable(void)
{
	if (tcapOmMsgsCurrentTable_refresh == 0)
		return;
	tcapOmMsgsCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmMsgsCurrentTable_row(): refresh tcapOmMsgsCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgsCurrentTable_row(struct tcapOmMsgsCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgsCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgsCurrentTable_request = sa_request;
}

/*
 * var_tcapOmMsgsCurrentTable(): locate variables in tcapOmMsgsCurrentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgsCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgsCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgsCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmMsgsCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgsCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgsCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMMSGSCURRENTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsCurrentMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgsCurrentMessagesSent;
	case TCAPOMMSGSCURRENTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgsCurrentMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgsCurrentMessagesRecv;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmMsgs5minIntTable(): refresh tcapOmMsgs5minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgs5minIntTable(void)
{
	if (tcapOmMsgs5minIntTable_refresh == 0)
		return;
	tcapOmMsgs5minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmMsgs5minIntTable_row(): refresh tcapOmMsgs5minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgs5minIntTable_row(struct tcapOmMsgs5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgs5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgs5minIntTable_request = sa_request;
}

/*
 * var_tcapOmMsgs5minIntTable(): locate variables in tcapOmMsgs5minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgs5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgs5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgs5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmMsgs5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgs5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgs5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMMSGS5MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs5minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgs5minIntMessagesSent;
	case TCAPOMMSGS5MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs5minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgs5minIntMessagesRecv;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmMsgs15minIntTable(): refresh tcapOmMsgs15minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmMsgs15minIntTable(void)
{
	if (tcapOmMsgs15minIntTable_refresh == 0)
		return;
	tcapOmMsgs15minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmMsgs15minIntTable_row(): refresh tcapOmMsgs15minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmMsgs15minIntTable_row(struct tcapOmMsgs15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmMsgs15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmMsgs15minIntTable_request = sa_request;
}

/*
 * var_tcapOmMsgs15minIntTable(): locate variables in tcapOmMsgs15minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmMsgs15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmMsgs15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmMsgs15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmMsgs15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmMsgs15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmMsgs15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMMSGS15MININTMESSAGESSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs15minIntMessagesSent);
		return (u_char *) &StorageTmp->tcapOmMsgs15minIntMessagesSent;
	case TCAPOMMSGS15MININTMESSAGESRECV:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmMsgs15minIntMessagesRecv);
		return (u_char *) &StorageTmp->tcapOmMsgs15minIntMessagesRecv;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmAETable(): refresh tcapOmAETable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAETable(void)
{
	if (tcapOmAETable_refresh == 0)
		return;
	tcapOmAETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmAETable_row(): refresh tcapOmAETable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAETable_row(struct tcapOmAETable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAETable_request == sa_request)
		return;
	StorageTmp->tcapOmAETable_request = sa_request;
}

/*
 * var_tcapOmAETable(): locate variables in tcapOmAETable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmAETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAETableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMAEMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAEMeasurementDeleted;
	case TCAPOMAENEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAENewTransactions);
		return (u_char *) &StorageTmp->tcapOmAENewTransactions;
	case TCAPOMAEMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAEMeanOpenTransactions;
	case TCAPOMAENOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAENotUsed);
		return (u_char *) &StorageTmp->tcapOmAENotUsed;
	case TCAPOMAECUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAECummulativeMeanDuration;
	case TCAPOMAEMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAEMaximumOpenTranactions;
	case TCAPOMAETHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAEThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAEThresholdExceeded;
	case TCAPOMAE5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmAE5minValidIntervals;
	case TCAPOMAE15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmAE15minValidIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmAECurrentTable(): refresh tcapOmAECurrentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAECurrentTable(void)
{
	if (tcapOmAECurrentTable_refresh == 0)
		return;
	tcapOmAECurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmAECurrentTable_row(): refresh tcapOmAECurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAECurrentTable_row(struct tcapOmAECurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAECurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmAECurrentTable_request = sa_request;
}

/*
 * var_tcapOmAECurrentTable(): locate variables in tcapOmAECurrentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAECurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAECurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAECurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmAECurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAECurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAECurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMAECURRENTMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAECurrentMeasurementDeleted;
	case TCAPOMAECURRENTNEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentNewTransactions);
		return (u_char *) &StorageTmp->tcapOmAECurrentNewTransactions;
	case TCAPOMAECURRENTMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAECurrentMeanOpenTransactions;
	case TCAPOMAECURRENTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentNotUsed);
		return (u_char *) &StorageTmp->tcapOmAECurrentNotUsed;
	case TCAPOMAECURRENTCUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentCummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAECurrentCummulativeMeanDuration;
	case TCAPOMAECURRENTMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAECurrentMaximumOpenTranactions;
	case TCAPOMAECURRENTTHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAECurrentThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAECurrentThresholdExceeded;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmAE5minIntTable(): refresh tcapOmAE5minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAE5minIntTable(void)
{
	if (tcapOmAE5minIntTable_refresh == 0)
		return;
	tcapOmAE5minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmAE5minIntTable_row(): refresh tcapOmAE5minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAE5minIntTable_row(struct tcapOmAE5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAE5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmAE5minIntTable_request = sa_request;
}

/*
 * var_tcapOmAE5minIntTable(): locate variables in tcapOmAE5minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAE5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAE5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAE5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmAE5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAE5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAE5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMAE5MININTMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAE5minIntMeasurementDeleted;
	case TCAPOMAE5MININTNEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntNewTransactions);
		return (u_char *) &StorageTmp->tcapOmAE5minIntNewTransactions;
	case TCAPOMAE5MININTMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAE5minIntMeanOpenTransactions;
	case TCAPOMAE5MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmAE5minIntNotUsed;
	case TCAPOMAE5MININTCUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntCummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAE5minIntCummulativeMeanDuration;
	case TCAPOMAE5MININTMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAE5minIntMaximumOpenTranactions;
	case TCAPOMAE5MININTTHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE5minIntThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAE5minIntThresholdExceeded;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmAE15minIntTable(): refresh tcapOmAE15minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmAE15minIntTable(void)
{
	if (tcapOmAE15minIntTable_refresh == 0)
		return;
	tcapOmAE15minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmAE15minIntTable_row(): refresh tcapOmAE15minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmAE15minIntTable_row(struct tcapOmAE15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmAE15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmAE15minIntTable_request = sa_request;
}

/*
 * var_tcapOmAE15minIntTable(): locate variables in tcapOmAE15minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmAE15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmAE15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmAE15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmAE15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmAE15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmAE15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMAE15MININTMEASUREMENTDELETED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntMeasurementDeleted);
		return (u_char *) &StorageTmp->tcapOmAE15minIntMeasurementDeleted;
	case TCAPOMAE15MININTNEWTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntNewTransactions);
		return (u_char *) &StorageTmp->tcapOmAE15minIntNewTransactions;
	case TCAPOMAE15MININTMEANOPENTRANSACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntMeanOpenTransactions);
		return (u_char *) &StorageTmp->tcapOmAE15minIntMeanOpenTransactions;
	case TCAPOMAE15MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmAE15minIntNotUsed;
	case TCAPOMAE15MININTCUMMULATIVEMEANDURATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntCummulativeMeanDuration);
		return (u_char *) &StorageTmp->tcapOmAE15minIntCummulativeMeanDuration;
	case TCAPOMAE15MININTMAXIMUMOPENTRANACTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntMaximumOpenTranactions);
		return (u_char *) &StorageTmp->tcapOmAE15minIntMaximumOpenTranactions;
	case TCAPOMAE15MININTTHRESHOLDEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmAE15minIntThresholdExceeded);
		return (u_char *) &StorageTmp->tcapOmAE15minIntThresholdExceeded;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmTcTable(): refresh tcapOmTcTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTcTable(void)
{
	if (tcapOmTcTable_refresh == 0)
		return;
	tcapOmTcTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmTcTable_row(): refresh tcapOmTcTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTcTable_row(struct tcapOmTcTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTcTable_request == sa_request)
		return;
	StorageTmp->tcapOmTcTable_request = sa_request;
}

/*
 * var_tcapOmTcTable(): locate variables in tcapOmTcTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmTcTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMTCPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcPabortRecvUnrecTid;
	case TCAPOMTCPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcPabortRecvResourceLim;
	case TCAPOMTCREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcRejectRecvResourceLim;
	case TCAPOMTCPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcPabortSentUnrecTid;
	case TCAPOMTCPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcPabortSentResourceLim;
	case TCAPOMTCREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcRejectSentResourceLim;
	case TCAPOMTCTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTcTcUserCancel;
	case TCAPOMTCMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTcMessagesDiscarded;
	case TCAPOMTCNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcNotUsed);
		return (u_char *) &StorageTmp->tcapOmTcNotUsed;
	case TCAPOMTCPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTcPabortsReceived;
	case TCAPOMTCTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTcTcUserRejectsReceived;
	case TCAPOMTCTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcTpErrors);
		return (u_char *) &StorageTmp->tcapOmTcTpErrors;
	case TCAPOMTC5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmTc5minValidIntervals;
	case TCAPOMTC15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmTc15minValidIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmTcCurrentTable(): refresh tcapOmTcCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTcCurrentTable(void)
{
	if (tcapOmTcCurrentTable_refresh == 0)
		return;
	tcapOmTcCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmTcCurrentTable_row(): refresh tcapOmTcCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTcCurrentTable_row(struct tcapOmTcCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTcCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmTcCurrentTable_request = sa_request;
}

/*
 * var_tcapOmTcCurrentTable(): locate variables in tcapOmTcCurrentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTcCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTcCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTcCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmTcCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTcCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTcCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMTCCURRENTPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortRecvUnrecTid;
	case TCAPOMTCCURRENTPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortRecvResourceLim;
	case TCAPOMTCCURRENTREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentRejectRecvResourceLim;
	case TCAPOMTCCURRENTPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortSentUnrecTid;
	case TCAPOMTCCURRENTPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortSentResourceLim;
	case TCAPOMTCCURRENTREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTcCurrentRejectSentResourceLim;
	case TCAPOMTCCURRENTTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTcCurrentTcUserCancel;
	case TCAPOMTCCURRENTMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTcCurrentMessagesDiscarded;
	case TCAPOMTCCURRENTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentNotUsed);
		return (u_char *) &StorageTmp->tcapOmTcCurrentNotUsed;
	case TCAPOMTCCURRENTPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTcCurrentPabortsReceived;
	case TCAPOMTCCURRENTTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTcCurrentTcUserRejectsReceived;
	case TCAPOMTCCURRENTTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTcCurrentTpErrors);
		return (u_char *) &StorageTmp->tcapOmTcCurrentTpErrors;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmTc5minIntTable(): refresh tcapOmTc5minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTc5minIntTable(void)
{
	if (tcapOmTc5minIntTable_refresh == 0)
		return;
	tcapOmTc5minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmTc5minIntTable_row(): refresh tcapOmTc5minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTc5minIntTable_row(struct tcapOmTc5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTc5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmTc5minIntTable_request = sa_request;
}

/*
 * var_tcapOmTc5minIntTable(): locate variables in tcapOmTc5minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTc5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTc5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTc5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmTc5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTc5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTc5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMTC5MININTPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortRecvUnrecTid;
	case TCAPOMTC5MININTPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortRecvResourceLim;
	case TCAPOMTC5MININTREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntRejectRecvResourceLim;
	case TCAPOMTC5MININTPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortSentUnrecTid;
	case TCAPOMTC5MININTPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortSentResourceLim;
	case TCAPOMTC5MININTREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc5minIntRejectSentResourceLim;
	case TCAPOMTC5MININTTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTc5minIntTcUserCancel;
	case TCAPOMTC5MININTMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTc5minIntMessagesDiscarded;
	case TCAPOMTC5MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmTc5minIntNotUsed;
	case TCAPOMTC5MININTPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTc5minIntPabortsReceived;
	case TCAPOMTC5MININTTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTc5minIntTcUserRejectsReceived;
	case TCAPOMTC5MININTTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc5minIntTpErrors);
		return (u_char *) &StorageTmp->tcapOmTc5minIntTpErrors;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmTc15minIntTable(): refresh tcapOmTc15minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmTc15minIntTable(void)
{
	if (tcapOmTc15minIntTable_refresh == 0)
		return;
	tcapOmTc15minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmTc15minIntTable_row(): refresh tcapOmTc15minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmTc15minIntTable_row(struct tcapOmTc15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmTc15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmTc15minIntTable_request = sa_request;
}

/*
 * var_tcapOmTc15minIntTable(): locate variables in tcapOmTc15minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmTc15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmTc15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmTc15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmTc15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmTc15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmTc15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMTC15MININTPABORTRECVUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortRecvUnrecTid;
	case TCAPOMTC15MININTPABORTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortRecvResourceLim;
	case TCAPOMTC15MININTREJECTRECVRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntRejectRecvResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntRejectRecvResourceLim;
	case TCAPOMTC15MININTPABORTSENTUNRECTID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortSentUnrecTid);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortSentUnrecTid;
	case TCAPOMTC15MININTPABORTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortSentResourceLim;
	case TCAPOMTC15MININTREJECTSENTRESOURCELIM:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntRejectSentResourceLim);
		return (u_char *) &StorageTmp->tcapOmTc15minIntRejectSentResourceLim;
	case TCAPOMTC15MININTTCUSERCANCEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntTcUserCancel);
		return (u_char *) &StorageTmp->tcapOmTc15minIntTcUserCancel;
	case TCAPOMTC15MININTMESSAGESDISCARDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntMessagesDiscarded);
		return (u_char *) &StorageTmp->tcapOmTc15minIntMessagesDiscarded;
	case TCAPOMTC15MININTNOTUSED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntNotUsed);
		return (u_char *) &StorageTmp->tcapOmTc15minIntNotUsed;
	case TCAPOMTC15MININTPABORTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntPabortsReceived);
		return (u_char *) &StorageTmp->tcapOmTc15minIntPabortsReceived;
	case TCAPOMTC15MININTTCUSERREJECTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntTcUserRejectsReceived);
		return (u_char *) &StorageTmp->tcapOmTc15minIntTcUserRejectsReceived;
	case TCAPOMTC15MININTTPERRORS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmTc15minIntTpErrors);
		return (u_char *) &StorageTmp->tcapOmTc15minIntTpErrors;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelRecvTable(): refresh tcapOmDevelRecvTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecvTable(void)
{
	if (tcapOmDevelRecvTable_refresh == 0)
		return;
	tcapOmDevelRecvTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelRecvTable_row(): refresh tcapOmDevelRecvTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecvTable_row(struct tcapOmDevelRecvTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecvTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecvTable_request = sa_request;
}

/*
 * var_tcapOmDevelRecvTable(): locate variables in tcapOmDevelRecvTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecvTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecvTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecvTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelRecvTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecvTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecvTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELRECVPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecvPabortMessageType;
	case TCAPOMDEVELRECVPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvPabortIncorrectTp;
	case TCAPOMDEVELRECVPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvPabortBadTp;
	case TCAPOMDEVELRECVREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecComp;
	case TCAPOMDEVELRECVREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectMistypeComp;
	case TCAPOMDEVELRECVREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectBadCompStruct;
	case TCAPOMDEVELRECVREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecLinkId;
	case TCAPOMDEVELRECVREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetRes;
	case TCAPOMDEVELRECVREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnexpRetRes;
	case TCAPOMDEVELRECVREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnrecIdRetErr;
	case TCAPOMDEVELRECVREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvRejectUnexpRetErr;
	case TCAPOMDEVELRECVUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejDupInvokeId;
	case TCAPOMDEVELRECVUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnrecOper;
	case TCAPOMDEVELRECVUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejParmInvoke;
	case TCAPOMDEVELRECVUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejReleasing;
	case TCAPOMDEVELRECVUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECVUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECVUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnrecError;
	case TCAPOMDEVELRECVUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejUnexpError;
	case TCAPOMDEVELRECVUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejParmRetResult;
	case TCAPOMDEVELRECVUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvUsrRejParmRetError;
	case TCAPOMDEVELRECV5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minValidIntervals;
	case TCAPOMDEVELRECV15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minValidIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelRecvCurrentTable(): refresh tcapOmDevelRecvCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecvCurrentTable(void)
{
	if (tcapOmDevelRecvCurrentTable_refresh == 0)
		return;
	tcapOmDevelRecvCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelRecvCurrentTable_row(): refresh tcapOmDevelRecvCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecvCurrentTable_row(struct tcapOmDevelRecvCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecvCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecvCurrentTable_request = sa_request;
}

/*
 * var_tcapOmDevelRecvCurrentTable(): locate variables in tcapOmDevelRecvCurrentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecvCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecvCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecvCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelRecvCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecvCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecvCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELRECVCURRENTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentPabortMessageType;
	case TCAPOMDEVELRECVCURRENTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentPabortIncorrectTp;
	case TCAPOMDEVELRECVCURRENTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentPabortBadTp;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecComp;
	case TCAPOMDEVELRECVCURRENTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectMistypeComp;
	case TCAPOMDEVELRECVCURRENTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectBadCompStruct;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecLinkId;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetRes;
	case TCAPOMDEVELRECVCURRENTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetRes;
	case TCAPOMDEVELRECVCURRENTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnrecIdRetErr;
	case TCAPOMDEVELRECVCURRENTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentRejectUnexpRetErr;
	case TCAPOMDEVELRECVCURRENTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejDupInvokeId;
	case TCAPOMDEVELRECVCURRENTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecOper;
	case TCAPOMDEVELRECVCURRENTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmInvoke;
	case TCAPOMDEVELRECVCURRENTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejReleasing;
	case TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECVCURRENTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECVCURRENTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnrecError;
	case TCAPOMDEVELRECVCURRENTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejUnexpError;
	case TCAPOMDEVELRECVCURRENTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetResult;
	case TCAPOMDEVELRECVCURRENTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecvCurrentUsrRejParmRetError;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelRecv5minIntTable(): refresh tcapOmDevelRecv5minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecv5minIntTable(void)
{
	if (tcapOmDevelRecv5minIntTable_refresh == 0)
		return;
	tcapOmDevelRecv5minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelRecv5minIntTable_row(): refresh tcapOmDevelRecv5minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecv5minIntTable_row(struct tcapOmDevelRecv5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecv5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecv5minIntTable_request = sa_request;
}

/*
 * var_tcapOmDevelRecv5minIntTable(): locate variables in tcapOmDevelRecv5minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecv5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecv5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecv5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelRecv5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecv5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecv5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELRECV5MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntPabortMessageType;
	case TCAPOMDEVELRECV5MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntPabortIncorrectTp;
	case TCAPOMDEVELRECV5MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntPabortBadTp;
	case TCAPOMDEVELRECV5MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecComp;
	case TCAPOMDEVELRECV5MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectMistypeComp;
	case TCAPOMDEVELRECV5MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectBadCompStruct;
	case TCAPOMDEVELRECV5MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecLinkId;
	case TCAPOMDEVELRECV5MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELRECV5MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetRes;
	case TCAPOMDEVELRECV5MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELRECV5MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntRejectUnexpRetErr;
	case TCAPOMDEVELRECV5MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejDupInvokeId;
	case TCAPOMDEVELRECV5MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecOper;
	case TCAPOMDEVELRECV5MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmInvoke;
	case TCAPOMDEVELRECV5MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejReleasing;
	case TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECV5MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECV5MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnrecError;
	case TCAPOMDEVELRECV5MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejUnexpError;
	case TCAPOMDEVELRECV5MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetResult;
	case TCAPOMDEVELRECV5MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv5minIntUsrRejParmRetError;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelRecv15minIntTable(): refresh tcapOmDevelRecv15minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelRecv15minIntTable(void)
{
	if (tcapOmDevelRecv15minIntTable_refresh == 0)
		return;
	tcapOmDevelRecv15minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelRecv15minIntTable_row(): refresh tcapOmDevelRecv15minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelRecv15minIntTable_row(struct tcapOmDevelRecv15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelRecv15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelRecv15minIntTable_request = sa_request;
}

/*
 * var_tcapOmDevelRecv15minIntTable(): locate variables in tcapOmDevelRecv15minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelRecv15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelRecv15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelRecv15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelRecv15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelRecv15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelRecv15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELRECV15MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntPabortMessageType;
	case TCAPOMDEVELRECV15MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntPabortIncorrectTp;
	case TCAPOMDEVELRECV15MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntPabortBadTp;
	case TCAPOMDEVELRECV15MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecComp;
	case TCAPOMDEVELRECV15MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectMistypeComp;
	case TCAPOMDEVELRECV15MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectBadCompStruct;
	case TCAPOMDEVELRECV15MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecLinkId;
	case TCAPOMDEVELRECV15MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELRECV15MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetRes;
	case TCAPOMDEVELRECV15MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELRECV15MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntRejectUnexpRetErr;
	case TCAPOMDEVELRECV15MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejDupInvokeId;
	case TCAPOMDEVELRECV15MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecOper;
	case TCAPOMDEVELRECV15MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmInvoke;
	case TCAPOMDEVELRECV15MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejReleasing;
	case TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELRECV15MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELRECV15MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnrecError;
	case TCAPOMDEVELRECV15MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejUnexpError;
	case TCAPOMDEVELRECV15MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetResult;
	case TCAPOMDEVELRECV15MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelRecv15minIntUsrRejParmRetError;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelSentTable(): refresh tcapOmDevelSentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSentTable(void)
{
	if (tcapOmDevelSentTable_refresh == 0)
		return;
	tcapOmDevelSentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelSentTable_row(): refresh tcapOmDevelSentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSentTable_row(struct tcapOmDevelSentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSentTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSentTable_request = sa_request;
}

/*
 * var_tcapOmDevelSentTable(): locate variables in tcapOmDevelSentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelSentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELSENTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSentPabortMessageType;
	case TCAPOMDEVELSENTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentPabortIncorrectTp;
	case TCAPOMDEVELSENTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentPabortBadTp;
	case TCAPOMDEVELSENTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecComp;
	case TCAPOMDEVELSENTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectMistypeComp;
	case TCAPOMDEVELSENTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectBadCompStruct;
	case TCAPOMDEVELSENTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecLinkId;
	case TCAPOMDEVELSENTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecIdRetRes;
	case TCAPOMDEVELSENTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnexpRetRes;
	case TCAPOMDEVELSENTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnrecIdRetErr;
	case TCAPOMDEVELSENTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentRejectUnexpRetErr;
	case TCAPOMDEVELSENTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejDupInvokeId;
	case TCAPOMDEVELSENTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnrecOper;
	case TCAPOMDEVELSENTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejParmInvoke;
	case TCAPOMDEVELSENTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejReleasing;
	case TCAPOMDEVELSENTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnrecError;
	case TCAPOMDEVELSENTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejUnexpError;
	case TCAPOMDEVELSENTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejParmRetResult;
	case TCAPOMDEVELSENTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSentUsrRejParmRetError;
	case TCAPOMDEVELSENT5MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minValidIntervals;
	case TCAPOMDEVELSENT15MINVALIDINTERVALS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minValidIntervals);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minValidIntervals;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelSentCurrentTable(): refresh tcapOmDevelSentCurrentTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSentCurrentTable(void)
{
	if (tcapOmDevelSentCurrentTable_refresh == 0)
		return;
	tcapOmDevelSentCurrentTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelSentCurrentTable_row(): refresh tcapOmDevelSentCurrentTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSentCurrentTable_row(struct tcapOmDevelSentCurrentTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSentCurrentTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSentCurrentTable_request = sa_request;
}

/*
 * var_tcapOmDevelSentCurrentTable(): locate variables in tcapOmDevelSentCurrentTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSentCurrentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSentCurrentTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSentCurrentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelSentCurrentTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSentCurrentTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSentCurrentTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELSENTCURRENTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentPabortMessageType;
	case TCAPOMDEVELSENTCURRENTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentPabortIncorrectTp;
	case TCAPOMDEVELSENTCURRENTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentPabortBadTp;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecComp;
	case TCAPOMDEVELSENTCURRENTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectMistypeComp;
	case TCAPOMDEVELSENTCURRENTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectBadCompStruct;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecLinkId;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetRes;
	case TCAPOMDEVELSENTCURRENTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetRes;
	case TCAPOMDEVELSENTCURRENTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnrecIdRetErr;
	case TCAPOMDEVELSENTCURRENTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentRejectUnexpRetErr;
	case TCAPOMDEVELSENTCURRENTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejDupInvokeId;
	case TCAPOMDEVELSENTCURRENTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecOper;
	case TCAPOMDEVELSENTCURRENTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejParmInvoke;
	case TCAPOMDEVELSENTCURRENTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejReleasing;
	case TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENTCURRENTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENTCURRENTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnrecError;
	case TCAPOMDEVELSENTCURRENTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejUnexpError;
	case TCAPOMDEVELSENTCURRENTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetResult;
	case TCAPOMDEVELSENTCURRENTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSentCurrentUsrRejParmRetError;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelSent5minIntTable(): refresh tcapOmDevelSent5minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSent5minIntTable(void)
{
	if (tcapOmDevelSent5minIntTable_refresh == 0)
		return;
	tcapOmDevelSent5minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelSent5minIntTable_row(): refresh tcapOmDevelSent5minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSent5minIntTable_row(struct tcapOmDevelSent5minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSent5minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSent5minIntTable_request = sa_request;
}

/*
 * var_tcapOmDevelSent5minIntTable(): locate variables in tcapOmDevelSent5minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSent5minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSent5minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSent5minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelSent5minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSent5minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSent5minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELSENT5MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntPabortMessageType;
	case TCAPOMDEVELSENT5MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntPabortIncorrectTp;
	case TCAPOMDEVELSENT5MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntPabortBadTp;
	case TCAPOMDEVELSENT5MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecComp;
	case TCAPOMDEVELSENT5MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectMistypeComp;
	case TCAPOMDEVELSENT5MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectBadCompStruct;
	case TCAPOMDEVELSENT5MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecLinkId;
	case TCAPOMDEVELSENT5MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELSENT5MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetRes;
	case TCAPOMDEVELSENT5MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELSENT5MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntRejectUnexpRetErr;
	case TCAPOMDEVELSENT5MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejDupInvokeId;
	case TCAPOMDEVELSENT5MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecOper;
	case TCAPOMDEVELSENT5MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejParmInvoke;
	case TCAPOMDEVELSENT5MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejReleasing;
	case TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENT5MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENT5MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnrecError;
	case TCAPOMDEVELSENT5MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejUnexpError;
	case TCAPOMDEVELSENT5MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetResult;
	case TCAPOMDEVELSENT5MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSent5minIntUsrRejParmRetError;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_tcapOmDevelSent15minIntTable(): refresh tcapOmDevelSent15minIntTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_tcapOmDevelSent15minIntTable(void)
{
	if (tcapOmDevelSent15minIntTable_refresh == 0)
		return;
	tcapOmDevelSent15minIntTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_tcapOmDevelSent15minIntTable_row(): refresh tcapOmDevelSent15minIntTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_tcapOmDevelSent15minIntTable_row(struct tcapOmDevelSent15minIntTable_data *StorageTmp)
{
	if (StorageTmp->tcapOmDevelSent15minIntTable_request == sa_request)
		return;
	StorageTmp->tcapOmDevelSent15minIntTable_request = sa_request;
}

/*
 * var_tcapOmDevelSent15minIntTable(): locate variables in tcapOmDevelSent15minIntTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_tcapOmMIB above.
 */
u_char *
var_tcapOmDevelSent15minIntTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct tcapOmDevelSent15minIntTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("tcapOmMIB", "var_tcapOmDevelSent15minIntTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_tcapOmDevelSent15minIntTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(tcapOmDevelSent15minIntTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_tcapOmDevelSent15minIntTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case TCAPOMDEVELSENT15MININTPABORTMESSAGETYPE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntPabortMessageType);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntPabortMessageType;
	case TCAPOMDEVELSENT15MININTPABORTINCORRECTTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntPabortIncorrectTp;
	case TCAPOMDEVELSENT15MININTPABORTBADTP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntPabortBadTp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntPabortBadTp;
	case TCAPOMDEVELSENT15MININTREJECTUNRECCOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecComp;
	case TCAPOMDEVELSENT15MININTREJECTMISTYPECOMP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectMistypeComp;
	case TCAPOMDEVELSENT15MININTREJECTBADCOMPSTRUCT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectBadCompStruct;
	case TCAPOMDEVELSENT15MININTREJECTUNRECLINKID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecLinkId;
	case TCAPOMDEVELSENT15MININTREJECTUNRECIDRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetRes;
	case TCAPOMDEVELSENT15MININTREJECTUNEXPRETRES:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetRes;
	case TCAPOMDEVELSENT15MININTREJECTUNRECIDRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnrecIdRetErr;
	case TCAPOMDEVELSENT15MININTREJECTUNEXPRETERR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntRejectUnexpRetErr;
	case TCAPOMDEVELSENT15MININTUSRREJDUPINVOKEID:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejDupInvokeId;
	case TCAPOMDEVELSENT15MININTUSRREJUNRECOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecOper;
	case TCAPOMDEVELSENT15MININTUSRREJPARMINVOKE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejParmInvoke;
	case TCAPOMDEVELSENT15MININTUSRREJRELEASING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejReleasing;
	case TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKRESP:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkResp;
	case TCAPOMDEVELSENT15MININTUSRREJUNEXPLINKOPER:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpLinkOper;
	case TCAPOMDEVELSENT15MININTUSRREJUNRECERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnrecError;
	case TCAPOMDEVELSENT15MININTUSRREJUNEXPERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejUnexpError;
	case TCAPOMDEVELSENT15MININTUSRREJPARMRETRESULT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetResult;
	case TCAPOMDEVELSENT15MININTUSRREJPARMRETERROR:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError);
		return (u_char *) &StorageTmp->tcapOmDevelSent15minIntUsrRejParmRetError;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_tcapOm1stAndIntervalActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm1stAndIntervalActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm1stAndIntervalActivate;
		old_length = StorageTmp->tcapOm1stAndIntervalActivateLen;
		StorageTmp->tcapOm1stAndIntervalActivate = objid;
		StorageTmp->tcapOm1stAndIntervalActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm1stAndIntervalActivate = old_value;
		StorageTmp->tcapOm1stAndIntervalActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm1stAndIntervalDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm1stAndIntervalDeactivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalDeactivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm1stAndIntervalDeactivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm1stAndIntervalDeactivate;
		old_length = StorageTmp->tcapOm1stAndIntervalDeactivateLen;
		StorageTmp->tcapOm1stAndIntervalDeactivate = objid;
		StorageTmp->tcapOm1stAndIntervalDeactivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm1stAndIntervalDeactivate = old_value;
		StorageTmp->tcapOm1stAndIntervalDeactivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm5MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm5MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm5MinActivate;
		old_length = StorageTmp->tcapOm5MinActivateLen;
		StorageTmp->tcapOm5MinActivate = objid;
		StorageTmp->tcapOm5MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm5MinActivate = old_value;
		StorageTmp->tcapOm5MinActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm5MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm5MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm5MinDeaActivate;
		old_length = StorageTmp->tcapOm5MinDeaActivateLen;
		StorageTmp->tcapOm5MinDeaActivate = objid;
		StorageTmp->tcapOm5MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm5MinDeaActivate = old_value;
		StorageTmp->tcapOm5MinDeaActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm15MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm15MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm15MinActivate;
		old_length = StorageTmp->tcapOm15MinActivateLen;
		StorageTmp->tcapOm15MinActivate = objid;
		StorageTmp->tcapOm15MinActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm15MinActivate = old_value;
		StorageTmp->tcapOm15MinActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm15MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm15MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm15MinDeaActivate;
		old_length = StorageTmp->tcapOm15MinDeaActivateLen;
		StorageTmp->tcapOm15MinDeaActivate = objid;
		StorageTmp->tcapOm15MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm15MinDeaActivate = old_value;
		StorageTmp->tcapOm15MinDeaActivateLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm5MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm5MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..288 */
		if ((0 > set_value || set_value > 288)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm5MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm5MinMaxIntervals;
		StorageTmp->tcapOm5MinMaxIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm5MinMaxIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_tcapOm15MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct tcapOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("tcapOmMIB", "write_tcapOm15MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = tcapOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..672 */
		if ((0 > set_value || set_value > 672)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to tcapOm15MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->tcapOm15MinMaxIntervals;
		StorageTmp->tcapOm15MinMaxIntervals = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->tcapOm15MinMaxIntervals = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
